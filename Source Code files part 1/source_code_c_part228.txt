eters.Length];
            int[] tempMarshalResponseMap = new int[parameters.Length];

            // count instances of each type of parameter
            co = 0;
            foreach (ParameterInfo param in parameters)
            {
                bool bIsIn = param.IsIn;    // [In]
                bool bIsOut = param.IsOut;  // [Out]  note: out int a === [Out] ref int b
                
                bool bIsByRef = param.ParameterType.IsByRef; // (ref or normal)                

                if (!bIsByRef)
                {
                    // it's a normal parameter (always passed in)
                    inRefCount++;
                    if (bIsOut)
                        nonRefOutCount++;
                }
                else
                if (bIsOut)
                {
                    outRefCount++;
                    outOnlyCount++;
                }
                else 
                {
                    inRefCount++;
                    outRefCount++;
                }

                // create maps for marshaling
                bool bMarshalIn = false;
                bool bMarshalOut = false;
                if (bIsByRef)
                {
                    if (bIsIn == bIsOut)
                    {
                        // "ref int a" or "[In, Out] ref int a"
                        bMarshalIn = true;
                        bMarshalOut = true;
                    }
                    else
                    {
                        // "[In] ref int a" or "out int a"
                        bMarshalIn = bIsIn;     
                        bMarshalOut = bIsOut;  
                    }
                }
                else
                {
                    // "int a" or "[In, Out] a"
                    bMarshalIn = true;     
                    bMarshalOut = bIsOut;
                }
                
           
                if (bMarshalIn)
                    tempMarshalRequestMap[marshalRequestCount++] = co;
                    
                if (bMarshalOut)
                    tempMarshalResponseMap[marshalResponseCount++] = co;

                co++; // parameter index
            } // foreach (ParameterInfo param in parameters)

            inRefArgMap = new int[inRefCount];
            outRefArgMap = new int[outRefCount];
            outOnlyArgMap = new int[outOnlyCount];
            nonRefOutArgMap = new int[nonRefOutCount];

            inRefCount = 0;
            outRefCount = 0;
            outOnlyCount = 0;
            nonRefOutCount = 0;

            // build up parameter maps
            for (co = 0; co < parameters.Length; co++)
            {
                ParameterInfo param = parameters[co];

                bool bIsOut = param.IsOut;  // [Out]  note: out int a === [Out] ref int b
                
                bool bIsByRef = param.ParameterType.IsByRef; // (ref or normal) 

                if (!bIsByRef)
                {
                    // it's an in parameter
                    inRefArgMap[inRefCount++] = co;
                    if (bIsOut)
                        nonRefOutArgMap[nonRefOutCount++] = co;
                }
                else
                if (bIsOut)
                {
                    outRefArgMap[outRefCount++] = co;
                    outOnlyArgMap[outOnlyCount++] = co;
                }    
                else 
                {
                    inRefArgMap[inRefCount++] = co;
                    outRefArgMap[outRefCount++] = co;
                }
            }
        
            // copy over marshal maps
            marshalRequestMap = new int[marshalRequestCount];
            Array.Copy(tempMarshalRequestMap, marshalRequestMap, marshalRequestCount);
            
            marshalResponseMap = new int[marshalResponseCount];
            Array.Copy(tempMarshalResponseMap, marshalResponseMap, marshalResponseCount);
        
        } // GetParameterMaps
        

        // 
        // Helper methods for expanding and contracting argument lists
        //   when translating from async methods to sync methods and back.
        //

        internal static Object[] ExpandAsyncBeginArgsToSyncArgs(RemotingMethodCachedData syncMethod,
                                                                Object[] asyncBeginArgs)
        {
            // This is when we have a list of args associated with BeginFoo(), and
            //   we want a list of args we can use to invoke Foo().

            ParameterInfo[] parameters = syncMethod.Parameters;
            int syncParamCount = parameters.Length;
            int[] inRefArgMap = syncMethod.InRefArgMap;            
            
            Object[] args = new Object[syncParamCount];
            
            for (int co = 0; co < inRefArgMap.Length; co++)
            {
                args[inRefArgMap[co]] = asyncBeginArgs[co];
            }

            // We also are required to create an instance for any primitive parameters
            //   that are only out parameters (PrivateProcessMessage requires it).
            foreach (int outArg in syncMethod.OutOnlyArgMap)
            {
                Type type = parameters[outArg].ParameterType.GetElementType();
                if (type.IsValueType)
                    args[outArg] = Activator.CreateInstance(type, true);
            }

            return args;                  
        } // ExpandAsyncBeginArgsToSyncArgs

        internal static Object[] ExpandAsyncEndArgsToSyncArgs(RemotingMethodCachedData syncMethod,
                                                              Object[] asyncEndArgs)
        {
            // This is when we have a list of args associated with EndFoo(), and
            //   we want to size it to a list of args associated with Foo();

            Object[] args = new Object[syncMethod.Parameters.Length];

            int[] outRefArgMap = syncMethod.OutRefArgMap;
            
            for (int co = 0; co < outRefArgMap.Length; co++)
            {
                args[outRefArgMap[co]] = asyncEndArgs[co];
            }

            return args;            
        } // ExpandAsyncEndArgsToSyncArgs
        
        
    } // class ArgMapper

    internal class ErrorMessage: IMethodCallMessage
    {

        // IMessage
        public IDictionary Properties     { get{ return null;} }

        // IMethodMessage
        public String Uri                      { get{ return m_URI; } set{ m_URI = value; } }
        public String MethodName               { get{ return m_MethodName; }}
        public String TypeName                 { get{ return m_TypeName; } }
        public Object MethodSignature          { get { return m_MethodSignature; } }
        public MethodBase MethodBase           { get { return null; } }
        
        public int ArgCount                    { get { return m_ArgCount;} }
        public String GetArgName(int index)     { return m_ArgName; }
        public Object GetArg(int argNum)        { return null;}
        public Object[] Args                   { get { return null;} }

        public bool HasVarArgs                 { get { return false;} }


        // IMethodCallMessage
        public int InArgCount                  { get { return m_ArgCount;} }
        public String GetInArgName(int index)   { return null; }
        public Object GetInArg(int argNum)      { return null;}
        public Object[] InArgs                { get { return null; }}
        public LogicalCallContext LogicalCallContext { get { return null; } }

        String m_URI = "Exception";
        String m_MethodName = "Unknown";
        String m_TypeName = "Unknown";
        Object m_MethodSignature = null;
        int m_ArgCount = 0;
        String m_ArgName = "Unknown";
    }



    //+================================================================================
    //
    // Synopsis:  Message wrapper used as base class for all exposed message wrappers.
    //   This is needed so that we can extract the identity object from a custom message.
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="InternalMessageWrapper"]/*' />
    /// <internalonly/>
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class InternalMessageWrapper
    {
        /// <include file='doc\Message.uex' path='docs/doc[@for="InternalMessageWrapper.WrappedMessage"]/*' />
	/// <internalonly/>
        protected IMessage WrappedMessage;
    
        /// <include file='doc\Message.uex' path='docs/doc[@for="InternalMessageWrapper.InternalMessageWrapper"]/*' />
	/// <internalonly/>
        public InternalMessageWrapper(IMessage msg)
        {
            WrappedMessage = msg;
        } // InternalMessageWrapper

        internal Object GetIdentityObject()
        {      
            IInternalMessage iim = WrappedMessage as IInternalMessage;
            if (null != iim)
            {
                return iim.IdentityObject;
            }                
            else
            {
                InternalMessageWrapper imw = WrappedMessage as InternalMessageWrapper;
                if(null != imw)
                {
                    return imw.GetIdentityObject();
                }
            else
                {
                return null;
                }
            }                
        } // GetIdentityObject

        internal Object GetServerIdentityObject()
        {      
            IInternalMessage iim = WrappedMessage as IInternalMessage;
            if (null != iim)
            {
                return iim.ServerIdentityObject;
            }                
            else
            {
                InternalMessageWrapper imw = WrappedMessage as InternalMessageWrapper;
                if (null != imw)
                {
                    return imw.GetServerIdentityObject();
                }
            else
                {
                return null;
                }                    
            }
        } // GetServerIdentityObject
	
    } // class InternalMessageWrapper



    //+================================================================================
    //
    // Synopsis:  Message wrapper used for creating custom method call messages.
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper"]/*' />
    /// <internalonly/>
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class MethodCallMessageWrapper : InternalMessageWrapper, IMethodCallMessage
    {
        // we need to overload the dictionary to delegate special values to this class
        private class MCMWrapperDictionary : Hashtable
        {
            private IMethodCallMessage _mcmsg; // pointer to this message object
            private IDictionary        _idict; // point to contained message's dictionary

            public MCMWrapperDictionary(IMethodCallMessage msg, IDictionary idict)
            {
                _mcmsg = msg;
                _idict = idict;
            }

            public override Object this[Object key]
            {
                get
                {   
                    System.String strKey = key as System.String;
                    if (null != strKey)
                    {
                        switch (strKey)
                        {
                        case "__Uri": return _mcmsg.Uri;
                        case "__MethodName": return _mcmsg.MethodName;
                        case "__MethodSignature": return _mcmsg.MethodSignature;
                        case "__TypeName": return _mcmsg.TypeName;
                        case "__Args": return _mcmsg.Args;
                        }
                    }
                    return _idict[key];
                }
                set
                {
                    System.String strKey = key as System.String;
                    if (null != strKey)
                    {
                        switch (strKey)
                        {
                        case "__MethodName": 
                        case "__MethodSignature": 
                        case "__TypeName": 
                        case "__Args": 
                            throw new RemotingException(
                                Environment.GetResourceString("Remoting_Default")); 
                        }
                        _idict[key] = value;
                    }
                }
            } 
        } // class MCMWrapperDictionary


        IMethodCallMessage _msg;
        IDictionary _properties;
	    ArgMapper  _argMapper = null;
        Object[] _args;    
        

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.MethodCallMessageWrapper"]/*' />
	/// <internalonly/>
        public MethodCallMessageWrapper(IMethodCallMessage msg) : base(msg) 
        {
            _msg = msg;
            _args = _msg.Args;
        } // MethodCallMessageWrapper
        

        // IMethodMessage implementation
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.Uri"]/*' />
	/// <internalonly/>
        public virtual String Uri 
        { 
            get 
            {
                return _msg.Uri;
            } 
            set 
            { 
                _msg.Properties[Message.UriKey] = value;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.MethodName"]/*' />
	/// <internalonly/>
        public virtual String MethodName { get {return _msg.MethodName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.TypeName"]/*' />
	/// <internalonly/>
        public virtual String TypeName { get {return _msg.TypeName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.MethodSignature"]/*' />
	/// <internalonly/>
        public virtual Object MethodSignature { get {return _msg.MethodSignature;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.LogicalCallContext"]/*' />
	/// <internalonly/>
        public virtual LogicalCallContext LogicalCallContext { get {return _msg.LogicalCallContext;}}   
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.MethodBase"]/*' />
	/// <internalonly/>
        public virtual MethodBase MethodBase { get {return _msg.MethodBase;}}        
           
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.ArgCount"]/*' />
	/// <internalonly/>
        public virtual int ArgCount 
        {
            get
            {
                if (_args != null)
                    return _args.Length;
                else
                    return 0;
            }
        }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.GetArgName"]/*' />
	/// <internalonly/>
        public virtual String GetArgName(int index) { return _msg.GetArgName(index); }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.GetArg"]/*' />
	/// <internalonly/>
        public virtual Object GetArg(int argNum) { return _args[argNum]; }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.Args"]/*' />
	/// <internalonly/>
        public virtual Object[] Args 
        {
            get { return _args; }
            set { _args = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.HasVarArgs"]/*' />
	/// <internalonly/>
        public virtual bool HasVarArgs { get {return _msg.HasVarArgs;} }
        
        // end of IMethodMessage implementation


        // IMethodCallMessage implementation
        //   (We cannot simply delegate to the internal message
        //    since we override the definition of Args and create our own array
        //    which can be modified.)
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.InArgCount"]/*' />
	/// <internalonly/>
        public virtual int InArgCount                        
        { 
            get 
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, false);
                return _argMapper.ArgCount;
            }
        } // InArgCount

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.GetInArg"]/*' />
	/// <internalonly/>
        public virtual Object  GetInArg(int argNum)   
        {
            if (_argMapper == null) _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArg(argNum);
        } // GetInArg
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.GetInArgName"]/*' />
	/// <internalonly/>
        public virtual String GetInArgName(int index) 
        { 
            if (_argMapper == null) _argMapper = new ArgMapper(this, false);
            return _argMapper.GetArgName(index);
        } // GetInArgName
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.InArgs"]/*' />
	/// <internalonly/>
        public virtual Object[] InArgs                       
        {
            get
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, false);
                return _argMapper.Args;
            }
        } // InArgs
 
        // end of IMethodCallMessage implementation


        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.Properties"]/*' />
	/// <internalonly/>
        public virtual IDictionary Properties 
    	{ 
    	    get 
    	    {
    	        if (_properties == null)
    	            _properties = new MCMWrapperDictionary(this, _msg.Properties);
    	        return _properties;
    	    }
    	}

    } // class MethodCallMessageWrapper



    //+================================================================================
    //
    // Synopsis:  Message wrapper used for creating custom method return messages.
    //
    //-================================================================================
    /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper"]/*' />
    /// <internalonly/>
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class MethodReturnMessageWrapper : InternalMessageWrapper, IMethodReturnMessage
    {
        // we need to overload the dictionary to delegate special values to this class
        private class MRMWrapperDictionary : Hashtable
        {
            private IMethodReturnMessage _mrmsg; // pointer to this message object
            private IDictionary          _idict; // point to contained message's dictionary

            public MRMWrapperDictionary(IMethodReturnMessage msg, IDictionary idict)
            {
                _mrmsg = msg;
                _idict = idict;
            }

            public override Object this[Object key]
            {
                get
                {   
                    System.String strKey = key as System.String;
                    if (null != strKey)
                    {
                        switch (strKey)
                        {
                        case "__Uri": return _mrmsg.Uri;
                        case "__MethodName": return _mrmsg.MethodName;
                        case "__MethodSignature": return _mrmsg.MethodSignature;
                        case "__TypeName": return _mrmsg.TypeName;
                        case "__Return": return _mrmsg.ReturnValue;
                        case "__OutArgs": return _mrmsg.OutArgs;
                        }
                    }
                    return _idict[key];
                }
                set
                {
                    System.String strKey = key as System.String;
                    if (null != strKey)
                    {
                        switch (strKey)
                        {
                        case "__MethodName":
                        case "__MethodSignature":
                        case "__TypeName":
                        case "__Return":
                        case "__OutArgs":
                            throw new RemotingException(
                                Environment.GetResourceString("Remoting_Default")); 
                        }
                        _idict[key] = value;
                    }
                }
            } 
        } // class MCMWrapperDictionary


        IMethodReturnMessage _msg;
        IDictionary _properties;
	    ArgMapper  _argMapper = null;
        Object[] _args = null;    
        Object _returnValue = null;
        Exception _exception = null;
        

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.MethodReturnMessageWrapper"]/*' />
	/// <internalonly/>
        public MethodReturnMessageWrapper(IMethodReturnMessage msg) : base(msg) 
        {
            _msg = msg;
            _args = _msg.Args;
            _returnValue = _msg.ReturnValue; // be careful if you decide to lazily assign _returnValue 
                                             //   since the return value might actually be null
            _exception = _msg.Exception; // (same thing as above goes for _exception)
        } // MethodReturnMessageWrapper
        

        // IMethodMessage implementation
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.Uri"]/*' />
	/// <internalonly/>
        public String Uri 
        { 
            get 
            {
                return _msg.Uri;
            } 

            set
            {
                _msg.Properties[Message.UriKey] = value;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.MethodName"]/*' />
	/// <internalonly/>
        public virtual String MethodName { get {return _msg.MethodName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.TypeName"]/*' />
	/// <internalonly/>
        public virtual String TypeName { get {return _msg.TypeName;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.MethodSignature"]/*' />
	/// <internalonly/>
        public virtual Object MethodSignature { get {return _msg.MethodSignature;}}
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.LogicalCallContext"]/*' />
	/// <internalonly/>
        public virtual LogicalCallContext LogicalCallContext { get {return _msg.LogicalCallContext;}}                       
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.MethodBase"]/*' />
	/// <internalonly/>
        public virtual MethodBase MethodBase { get {return _msg.MethodBase;}}
           
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.ArgCount"]/*' />
	/// <internalonly/>
        public virtual int ArgCount 
        {
            get
            {
                if (_args != null)
                    return _args.Length;
                else
                    return 0;
            }
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.GetArgName"]/*' />
	/// <internalonly/>
        public virtual String GetArgName(int index) { return _msg.GetArgName(index); }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.GetArg"]/*' />
	/// <internalonly/>
        public virtual Object GetArg(int argNum) { return _args[argNum]; }
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.Args"]/*' />
	/// <internalonly/>
        public virtual Object[] Args 
        { 
            get { return _args; }
            set { _args = value; }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.HasVarArgs"]/*' />
	/// <internalonly/>
        public virtual bool HasVarArgs { get {return _msg.HasVarArgs;} }
        
        // end of IMethodMessage implementation


        // IMethodReturnMessage implementation
        //   (We cannot simply delegate to the internal message
        //    since we override the definition of Args and create our own array
        //    which can be modified.)
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.OutArgCount"]/*' />
	/// <internalonly/>
        public virtual int OutArgCount                        
        { 
            get 
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.ArgCount;
            }
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.GetOutArg"]/*' />
	/// <internalonly/>
        public virtual Object  GetOutArg(int argNum)   
        {   
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArg(argNum);
        }

        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.GetOutArgName"]/*' />
	/// <internalonly/>
        public virtual String GetOutArgName(int index) 
        { 
            if (_argMapper == null) _argMapper = new ArgMapper(this, true);
            return _argMapper.GetArgName(index);
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.OutArgs"]/*' />
	/// <internalonly/>
        public virtual Object[] OutArgs                       
        {
            get
            {
                if (_argMapper == null) _argMapper = new ArgMapper(this, true);
                return _argMapper.Args;
            }
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.Exception"]/*' />
	/// <internalonly/>
        public virtual Exception Exception
        {
            get { return _exception; }
            set { _exception = value; }
        }
        
        /// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.ReturnValue"]/*' />
	/// <internalonly/>
        public virtual Object ReturnValue 
        {
            get { return _returnValue; }
            set { _returnValue = value; }
        }
 
        // end of IMethodReturnMessage implementation

        // IMessage
    	/// <include file='doc\Message.uex' path='docs/doc[@for="MethodReturnMessageWrapper.Properties"]/*' />
	/// <internalonly/>
    	public virtual IDictionary Properties 
    	{ 
    	    get 
    	    {
    	        if (_properties == null)
    	            _properties = new MRMWrapperDictionary(this, _msg.Properties);
    	        return _properties;
    	    }
    	}


    } // class MethodReturnMessageWrapper

} // namespace Remoting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\soapinteroptypes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**  File:    SoapInteropTypes.cs
** 
**  Purpose: Types for Wsdl and Soap interop
**
**  Date:    March 2, 2001
**
===========================================================*/

namespace System.Runtime.Remoting.Metadata.W3cXsd2001
{
    using System;
    using System.Globalization;
    using System.Text;


    internal class SoapType
    {
        internal static String FilterBin64(String value)
        {
            StringBuilder sb = new StringBuilder();
            for (int i=0; i<value.Length; i++)
            {
                if (!(value[i] == ' '|| value[i] == '\n' || value[i] == '\r'))
                    sb.Append(value[i]);
            }
            return sb.ToString();
        }

        internal static String LineFeedsBin64(String value)
        {
            // Add linefeeds every 76 characters
            StringBuilder sb = new StringBuilder();
            for (int i=0; i<value.Length; i++)
            {
                if (i%76 == 0)
                    sb.Append('\n');
                sb.Append(value[i]);
            }
            return sb.ToString();
        }

		internal static String Escape(String value)
		{
			if (value == null || value.Length == 0)
			    return value;
			StringBuilder stringBuffer = new StringBuilder();
			int index = value.IndexOf('&');
			if (index > -1)
			{
				stringBuffer.Append(value);
				stringBuffer.Replace("&", "&#38;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('"');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("\"", "&#34;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('\'');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("\'", "&#39;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('<');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace("<", "&#60;", index, stringBuffer.Length - index);
			}

			index = value.IndexOf('>');
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace(">", "&#62;", index, stringBuffer.Length - index);
			}

            index = value.IndexOf(Char.MinValue);
			if (index > -1)
			{
				if (stringBuffer.Length == 0)
					stringBuffer.Append(value);
				stringBuffer.Replace(Char.MinValue.ToString(), "&#0;", index, stringBuffer.Length - index);
            }

            String returnValue = null;

			if (stringBuffer.Length > 0)
				returnValue = stringBuffer.ToString();
			else
				returnValue = value;

            return returnValue;
		}



        internal static Type typeofSoapTime = typeof(SoapTime);
        internal static Type typeofSoapDate = typeof(SoapDate);
        internal static Type typeofSoapYearMonth = typeof(SoapYearMonth);
        internal static Type typeofSoapYear = typeof(SoapYear);
        internal static Type typeofSoapMonthDay = typeof(SoapMonthDay);
        internal static Type typeofSoapDay = typeof(SoapDay);
        internal static Type typeofSoapMonth = typeof(SoapMonth);
        internal static Type typeofSoapHexBinary = typeof(SoapHexBinary);
        internal static Type typeofSoapBase64Binary = typeof(SoapBase64Binary);
        internal static Type typeofSoapInteger = typeof(SoapInteger);
        internal static Type typeofSoapPositiveInteger = typeof(SoapPositiveInteger);
        internal static Type typeofSoapNonPositiveInteger = typeof(SoapNonPositiveInteger);
        internal static Type typeofSoapNonNegativeInteger = typeof(SoapNonNegativeInteger);
        internal static Type typeofSoapNegativeInteger = typeof(SoapNegativeInteger);
        internal static Type typeofSoapAnyUri = typeof(SoapAnyUri);
        internal static Type typeofSoapQName = typeof(SoapQName);
        internal static Type typeofSoapNotation = typeof(SoapNotation);
        internal static Type typeofSoapNormalizedString = typeof(SoapNormalizedString);
        internal static Type typeofSoapToken = typeof(SoapToken);
        internal static Type typeofSoapLanguage = typeof(SoapLanguage);
        internal static Type typeofSoapName = typeof(SoapName);
        internal static Type typeofSoapIdrefs = typeof(SoapIdrefs);
        internal static Type typeofSoapEntities = typeof(SoapEntities);
        internal static Type typeofSoapNmtoken = typeof(SoapNmtoken);
        internal static Type typeofSoapNmtokens = typeof(SoapNmtokens);
        internal static Type typeofSoapNcName = typeof(SoapNcName);
        internal static Type typeofSoapId = typeof(SoapId);
        internal static Type typeofSoapIdref = typeof(SoapIdref);
        internal static Type typeofSoapEntity = typeof(SoapEntity);    
        internal static Type typeofISoapXsd = typeof(ISoapXsd);    
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="ISoapXsd"]/*' />
    public interface ISoapXsd
    {
        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="ISoapXsd.GetXsdType"]/*' />

        String GetXsdType();
    }

    // Soap interop xsd types
    //Convert from ISO Date to urt DateTime
    // The form of the Date is yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff or yyyy'-'MM'-'dd' or yyyy'-'MM'-'dd'T'HH':'mm':'ss

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDateTime"]/*' />
    public sealed class SoapDateTime 
    {
     
        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDateTime.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "dateTime";}
        }

        private static String[] formats = 
        {
            "yyyy-MM-dd'T'HH:mm:ss.fffffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.ffff",
            "yyyy-MM-dd'T'HH:mm:ss.ffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.fff",
            "yyyy-MM-dd'T'HH:mm:ss.fffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.ff",
            "yyyy-MM-dd'T'HH:mm:ss.ffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.f",
            "yyyy-MM-dd'T'HH:mm:ss.fzzz", 
            "yyyy-MM-dd'T'HH:mm:ss", 
            "yyyy-MM-dd'T'HH:mm:sszzz",
            "yyyy-MM-dd'T'HH:mm:ss.fffff",
            "yyyy-MM-dd'T'HH:mm:ss.fffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.ffffff",
            "yyyy-MM-dd'T'HH:mm:ss.ffffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.fffffff",
            "yyyy-MM-dd'T'HH:mm:ss.ffffffff",
            "yyyy-MM-dd'T'HH:mm:ss.ffffffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.fffffffff",
            "yyyy-MM-dd'T'HH:mm:ss.fffffffffzzz", 
            "yyyy-MM-dd'T'HH:mm:ss.ffffffffff",
            "yyyy-MM-dd'T'HH:mm:ss.ffffffffffzzz"            
        };


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDateTime.ToString"]/*' />
        public static String ToString(DateTime value)
        {
            return value.ToString("yyyy-MM-dd'T'HH:mm:ss.fffffffzzz", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDateTime.Parse"]/*' />
        public static DateTime Parse(String value)
        {
            DateTime dt;
            try
            {
                if (value == null)
                    dt = DateTime.MinValue;
                else
                {
                    String time = value;
                    if (value.EndsWith("Z"))
                        time = value.Substring(0, value.Length-1)+"-00:00";
                    dt = DateTime.ParseExact(time, formats, CultureInfo.InvariantCulture,DateTimeStyles.None);
                }

            }
            catch (Exception)
            {
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:dateTime", value));                
            }

            return dt;
        }
        
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDuration"]/*' />
    public sealed class SoapDuration
    {
        // Convert from ISO/xsd TimeDuration to urt TimeSpan
        // The form of the time duration is PxxYxxDTxxHxxMxx.xxxS or PxxYxxDTxxHxxMxxS
        // Keep in sync with Message.cs


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDuration.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "duration";}
        }

        // calcuate carryover points by ISO 8601 : 1998 section 5.5.3.2.1 Alternate format
        // algorithm not to exceed 12 months, 30 day
        // note with this algorithm year has 360 days.
        private static void CarryOver(int inDays, out int years, out int months, out int days)
        {
            years = inDays/360;
            int yearDays = years*360;
            months = Math.Max(0, inDays - yearDays)/30;
            int monthDays = months*30;
            days = Math.Max(0, inDays - (yearDays+monthDays)); 
            days = inDays%30;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDuration.ToString"]/*' />
        public static String ToString(TimeSpan timeSpan)
        {
            StringBuilder sb = new StringBuilder(10);
            sb.Length = 0;
            int t = 0;
            if (TimeSpan.Compare(timeSpan, TimeSpan.Zero) < 1)
            {
                sb.Append('-');
                //timeSpan = timeSpan.Negate(); //negating timespan at top level not at each piece such as Day
            }

            int years = 0;
            int months = 0;
            int days = 0;

            CarryOver(Math.Abs(timeSpan.Days), out years, out months, out days);

            sb.Append('P');
            sb.Append(years);
            sb.Append('Y');
            sb.Append(months);
            sb.Append('M');
            sb.Append(days);
            sb.Append("DT");
            t= timeSpan.Hours;
            sb.Append(Math.Abs(timeSpan.Hours));
            sb.Append('H');
            sb.Append(Math.Abs(timeSpan.Minutes));
            sb.Append('M');
            sb.Append(Math.Abs(timeSpan.Seconds));
            t= Math.Abs(timeSpan.Milliseconds);
            if (t != 0)
            {
                long timea = Math.Abs(timeSpan.Ticks % TimeSpan.TicksPerDay);
                int t1 = (int)(timea % TimeSpan.TicksPerSecond);
                if (t1 != 0)
                {
                    String t2 = ParseNumbers.IntToString(t1, 10, 7, '0', 0);
                    sb.Append('.');
                    //String mill = t.ToString();
                    sb.Append(t2);
                }
            }
            sb.Append('S');
            return sb.ToString();
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDuration.Parse"]/*' />
        public static TimeSpan Parse(String value)
        {
            int sign = 1;

            try
            {
                if (value == null)
                    return TimeSpan.Zero;

                if (value[0] == '-')
                    sign = -1;


                Char[] c = value.ToCharArray();
                int[] timeValues = new int[7];
                String year = "0";
                String month = "0";
                String day = "0";
                String hour = "0";
                String minute = "0";
                String second = "0";
                String fraction = "0";
                bool btime = false;
                bool bmill = false;
                int beginField = 0;

                for (int i=0; i<c.Length; i++)
                {
                    switch (c[i])
                    {
                        case 'P':
                            beginField = i+1;
                            break;
                        case 'Y':
                            year = new String(c,beginField, i-beginField);
                            beginField = i+1;
                            break;
                        case 'M':
                            if (btime)
                                minute = new String(c, beginField, i-beginField);
                            else
                                month = new String(c, beginField, i-beginField);
                            beginField = i+1;
                            break;
                        case 'D':
                            day = new String(c, beginField, i-beginField);
                            beginField = i+1;
                            break;
                        case 'T':
                            btime = true;
                            beginField = i+1;
                            break;
                        case 'H':
                            hour = new String(c, beginField, i-beginField);
                            beginField = i+1;
                            break;
                        case '.':
                            bmill = true;
                            second = new String(c, beginField, i-beginField);
                            beginField = i+1;
                            break;
                        case 'S':
                            if (!bmill)
                                second = new String(c, beginField, i-beginField);
                            else
                                fraction = new String(c, beginField, i-beginField);
                            break;
                        case 'Z':
                            break;
                        default:
                            // Number continue to loop until end of number
                            break;
                    }                                                                                                                                                                                                                                                                  
                }

                long ticks = sign*
                    (
                     (Int64.Parse(year, CultureInfo.InvariantCulture)*360+Int64.Parse(month)*30+Int64.Parse(day))*TimeSpan.TicksPerDay+
                     Int64.Parse(hour, CultureInfo.InvariantCulture)*TimeSpan.TicksPerHour+
                     Int64.Parse(minute, CultureInfo.InvariantCulture)*TimeSpan.TicksPerMinute+
                     Convert.ToInt64(Double.Parse(second+"."+fraction, CultureInfo.InvariantCulture)*(Double)TimeSpan.TicksPerSecond)
                    );
                return new TimeSpan(ticks);
            }
            catch (Exception)
            {
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:duration", value));                
            }
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime"]/*' />
    [Serializable]
    public sealed class SoapTime : ISoapXsd
    {
        DateTime _value = DateTime.MinValue;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "time";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "HH:mm:ss.fffffffzzz",
            "HH:mm:ss.ffff",
            "HH:mm:ss.ffffzzz",
            "HH:mm:ss.fff",
            "HH:mm:ss.fffzzz",
            "HH:mm:ss.ff",
            "HH:mm:ss.ffzzz",
            "HH:mm:ss.f",
            "HH:mm:ss.fzzz",
            "HH:mm:ss", 
            "HH:mm:sszzz",
            "HH:mm:ss.fffff",
            "HH:mm:ss.fffffzzz",
            "HH:mm:ss.ffffff",
            "HH:mm:ss.ffffffzzz",
            "HH:mm:ss.fffffff",
            "HH:mm:ss.ffffffff",
            "HH:mm:ss.ffffffffzzz",
            "HH:mm:ss.fffffffff",
            "HH:mm:ss.fffffffffzzz",
            "HH:mm:ss.fffffffff",
            "HH:mm:ss.fffffffffzzz"
        };


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.SoapTime"]/*' />
        public SoapTime()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.SoapTime1"]/*' />
        public SoapTime(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.ToString"]/*' />
        public override String ToString()
        {
            // Set the date to todays date to avoid daylight savings time problems.
            DateTime today = DateTime.Today;
            DateTime time = new DateTime(today.Year, today.Month, today.Day, _value.Hour, _value.Minute, _value.Second, _value.Millisecond);
            return time.ToString("HH:mm:ss.fffffffzzz", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapTime.Parse"]/*' />
        public static SoapTime Parse(String value)
        {
            String time = value;
            if (value.EndsWith("Z"))
                time = value.Substring(0, value.Length-1)+"-00:00";
            SoapTime dt = new SoapTime(DateTime.ParseExact(time, formats, CultureInfo.InvariantCulture,DateTimeStyles.None));
            return dt;
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate"]/*' />
    [Serializable]
    public sealed class SoapDate : ISoapXsd
    {

        DateTime _value = DateTime.MinValue;
        int _sign = 0;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "date";}
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "yyyy-MM-dd",
            "'+'yyyy-MM-dd",
            "'-'yyyy-MM-dd",
            "yyyy-MM-ddzzz",
            "'+'yyyy-MM-ddzzz",
            "'-'yyyy-MM-ddzzz"
        };



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.SoapDate"]/*' />
        public SoapDate()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.SoapDate1"]/*' />
        public SoapDate(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.SoapDate2"]/*' />
        public SoapDate(DateTime value, int sign)
        {
            _value = value;
            _sign = sign;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.Sign"]/*' />
        public int Sign
        {
            get {return _sign;}
            set {_sign = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.ToString"]/*' />
        public override String ToString()
        {
            if (_sign < 0)
                return _value.ToString("'-'yyyy-MM-dd", CultureInfo.InvariantCulture);
            else
                return _value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDate.Parse"]/*' />
        public static SoapDate Parse(String value)
        {
            int sign = 0;
            if (value[0] == '-')
                sign = -1;
            return new SoapDate(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None), sign);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth"]/*' />
    [Serializable]
    public sealed class SoapYearMonth : ISoapXsd
    {

        DateTime _value = DateTime.MinValue;
        int _sign = 0;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "gYearMonth";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "yyyy-MM",
            "'+'yyyy-MM",
            "'-'yyyy-MM",
            "yyyy-MMzzz",
            "'+'yyyy-MMzzz",
            "'-'yyyy-MMzzz"
        };



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.SoapYearMonth"]/*' />
        public SoapYearMonth()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.SoapYearMonth1"]/*' />
        public SoapYearMonth(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.SoapYearMonth2"]/*' />
        public SoapYearMonth(DateTime value, int sign)
        {
            _value = value;
            _sign = sign;
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.Sign"]/*' />
        public int Sign
        {
            get {return _sign;}
            set {_sign = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.ToString"]/*' />
        public override String ToString()
        {
            if (_sign < 0)
                return _value.ToString("'-'yyyy-MM", CultureInfo.InvariantCulture);
            else
                return _value.ToString("yyyy-MM", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYearMonth.Parse"]/*' />
        public static SoapYearMonth Parse(String value)
        {
            int sign = 0;
            if (value[0] == '-')
                sign = -1;
            return new SoapYearMonth(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None), sign);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear"]/*' />
    [Serializable]
    public sealed class SoapYear : ISoapXsd
    {

        DateTime _value = DateTime.MinValue;
        int _sign = 0;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "gYear";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "yyyy",
            "'+'yyyy",
            "'-'yyyy",
            "yyyyzzz",
            "'+'yyyyzzz",
            "'-'yyyyzzz"
        };



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.SoapYear"]/*' />
        public SoapYear()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.SoapYear1"]/*' />
        public SoapYear(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.SoapYear2"]/*' />
        public SoapYear(DateTime value, int sign)
        {
            _value = value;
            _sign = sign;
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.Sign"]/*' />
        public int Sign
        {
            get {return _sign;}
            set {_sign = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.ToString"]/*' />
        public override String ToString()
        {
            if (_sign < 0)
                return _value.ToString("'-'yyyy", CultureInfo.InvariantCulture);
            else
                return _value.ToString("yyyy", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapYear.Parse"]/*' />
        public static SoapYear Parse(String value)
        {
            int sign = 0;
            if (value[0] == '-')
                sign = -1;
            return new SoapYear(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None), sign);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay"]/*' />
    [Serializable]
    public sealed class SoapMonthDay : ISoapXsd
    {
        DateTime _value = DateTime.MinValue;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "gMonthDay";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "--MM-dd",
            "--MM-ddzzz"
        };



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.SoapMonthDay"]/*' />
        public SoapMonthDay()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.SoapMonthDay1"]/*' />
        public SoapMonthDay(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString("'--'MM'-'dd", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonthDay.Parse"]/*' />
        public static SoapMonthDay Parse(String value)
        {
            return new SoapMonthDay(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay"]/*' />
    [Serializable]
    public sealed class SoapDay : ISoapXsd
    {
        DateTime _value = DateTime.MinValue;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "gDay";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        private static String[] formats = 
        {
            "---dd",
            "---ddzzz"
        };


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.SoapDay"]/*' />
        public SoapDay()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.SoapDay1"]/*' />
        public SoapDay(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString("---dd", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapDay.Parse"]/*' />
        public static SoapDay Parse(String value)
        {
            return new SoapDay(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth"]/*' />
    [Serializable]
    public sealed class SoapMonth : ISoapXsd
    {
        DateTime _value = DateTime.MinValue;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "gMonth";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        private static String[] formats = 
        {
            "--MM--",
            "--MM--zzz"
        };



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.SoapMonth"]/*' />
        public SoapMonth()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.SoapMonth1"]/*' />
        public SoapMonth(DateTime value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.Value"]/*' />
        public DateTime Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString("--MM--", CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapMonth.Parse"]/*' />
        public static SoapMonth Parse(String value)
        {
            return new SoapMonth(DateTime.ParseExact(value, formats, CultureInfo.InvariantCulture,DateTimeStyles.None));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary"]/*' />
    [Serializable]
    public sealed class SoapHexBinary : ISoapXsd
    {
        Byte[] _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "hexBinary";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.SoapHexBinary"]/*' />
        public SoapHexBinary()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.SoapHexBinary1"]/*' />
        public SoapHexBinary(Byte[] value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.Value"]/*' />
        public Byte[] Value
        {
            get {return _value;}
            set {_value = value;}
        }

        StringBuilder sb = new StringBuilder(100);

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.ToString"]/*' />
        public override String ToString()
        {
            sb.Length = 0;
            for (int i=0; i<_value.Length; i++)
            {
                String s = _value[i].ToString("X");
                if (s.Length == 1)
                    sb.Append('0');
                sb.Append(s);
            }
            return sb.ToString();
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapHexBinary.Parse"]/*' />
        public static SoapHexBinary Parse(String value)
        {
            return new SoapHexBinary(ToByteArray(SoapType.FilterBin64(value)));
        }



        private static Byte[] ToByteArray(String value)
        {
            Char[] cA = value.ToCharArray();
            if (cA.Length%2 != 0)
            {
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:hexBinary", value));                
            }
            Byte[] bA = new Byte[cA.Length/2];
            for (int i = 0; i< cA.Length/2; i++)
            {
                bA[i] = (Byte)(ToByte(cA[i*2], value)*16+ToByte(cA[i*2+1], value));
            }

            return bA;
        }

        private static Byte ToByte(Char c, String value)
        {
            Byte b = (Byte)0;
            String s = c.ToString();
            try
            {
                s = c.ToString();
                b = Byte.Parse(s, NumberStyles.HexNumber);
            }
            catch (Exception)
            {
                String.Format(Environment.GetResourceString("Remoting_SOAPInteropxsdInvalid"), "xsd:hexBinary", value);                
            }

            return b;
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary"]/*' />
    [Serializable]
    public sealed class SoapBase64Binary : ISoapXsd
    {
        Byte[] _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "base64Binary";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.SoapBase64Binary"]/*' />
        public SoapBase64Binary()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.SoapBase64Binary1"]/*' />
        public SoapBase64Binary(Byte[] value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.Value"]/*' />
        public Byte[] Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.ToString"]/*' />
        public override String ToString()
        {
            if (_value == null)
                return null;

            // Put in line feeds every 76 characters.
            return SoapType.LineFeedsBin64(Convert.ToBase64String(_value));
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapBase64Binary.Parse"]/*' />
        public static SoapBase64Binary Parse(String value)
        {
            if (value == null || value.Length == 0)
                return new SoapBase64Binary(new Byte[0]);

            Byte[] bA;
            try
            {
                bA = Convert.FromBase64String(SoapType.FilterBin64(value));
            }
            catch (Exception)
            {
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "base64Binary", value));                
            }
            return new SoapBase64Binary(bA);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger"]/*' />
    [Serializable]
    public sealed class SoapInteger : ISoapXsd
    {
        Decimal _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "integer";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.SoapInteger"]/*' />
        public SoapInteger()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.SoapInteger1"]/*' />
        public SoapInteger (Decimal value)
        {
            _value = Decimal.Truncate(value);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.Value"]/*' />
        public Decimal Value
        {
            get {return _value;}
            set {_value = Decimal.Truncate(value);}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapInteger.Parse"]/*' />
        public static SoapInteger Parse(String value)
        {
            return new SoapInteger(Decimal.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger"]/*' />
    [Serializable]
    public sealed class SoapPositiveInteger : ISoapXsd
    {
        Decimal _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "positiveInteger";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.SoapPositiveInteger"]/*' />
        public SoapPositiveInteger()
        {
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.SoapPositiveInteger1"]/*' />
        public SoapPositiveInteger (Decimal value)
        {
            _value = Decimal.Truncate(value);
            if (_value < Decimal.One)
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:positiveInteger", value));
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.Value"]/*' />
        public Decimal Value
        {
            get {return _value;}
            set {
                _value = Decimal.Truncate(value);
                if (_value < Decimal.One)
                    throw new RemotingException(
                                               String.Format(
                                                            Environment.GetResourceString(
                                                                                         "Remoting_SOAPInteropxsdInvalid"), "xsd:positiveInteger", value));
            }
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapPositiveInteger.Parse"]/*' />
        public static SoapPositiveInteger Parse(String value)
        {
            return new SoapPositiveInteger(Decimal.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger"]/*' />
    [Serializable]
    public sealed class SoapNonPositiveInteger : ISoapXsd
    {
        Decimal _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "nonPositiveInteger";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.SoapNonPositiveInteger"]/*' />
        public SoapNonPositiveInteger()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.SoapNonPositiveInteger1"]/*' />
        public SoapNonPositiveInteger (Decimal value)
        {
            _value = Decimal.Truncate(value);
            if (_value > Decimal.Zero)
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:nonPositiveInteger", value));
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.Value"]/*' />
        public Decimal Value
        {
            get {return _value;}
            set {
                _value = Decimal.Truncate(value);
                if (_value > Decimal.Zero)
                    throw new RemotingException(
                                               String.Format(
                                                            Environment.GetResourceString(
                                                                                         "Remoting_SOAPInteropxsdInvalid"), "xsd:nonPositiveInteger", value));
            }
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.ToString"]/*' />
        public override String ToString()
        {
            return  _value.ToString(CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonPositiveInteger.Parse"]/*' />
        public static SoapNonPositiveInteger Parse(String value)
        {
            return new SoapNonPositiveInteger(Decimal.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger"]/*' />
    [Serializable]
    public sealed class SoapNonNegativeInteger : ISoapXsd
    {
        Decimal _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "nonNegativeInteger";}
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.SoapNonNegativeInteger"]/*' />
        public SoapNonNegativeInteger()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.SoapNonNegativeInteger1"]/*' />
        public SoapNonNegativeInteger (Decimal value)
        {
            _value = Decimal.Truncate(value);
            if (_value < Decimal.Zero)
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:nonNegativeInteger", value));
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.Value"]/*' />
        public Decimal Value
        {
            get {return _value;}
            set {
                _value = Decimal.Truncate(value);
                if (_value < Decimal.Zero)
                    throw new RemotingException(
                                               String.Format(
                                                            Environment.GetResourceString(
                                                                                         "Remoting_SOAPInteropxsdInvalid"), "xsd:nonNegativeInteger", value));
            }
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNonNegativeInteger.Parse"]/*' />
        public static SoapNonNegativeInteger Parse(String value)
        {
            return new SoapNonNegativeInteger(Decimal.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture));
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger"]/*' />
    [Serializable]
    public sealed class SoapNegativeInteger : ISoapXsd
    {
        Decimal _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "negativeInteger";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.SoapNegativeInteger"]/*' />
        public SoapNegativeInteger()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.SoapNegativeInteger1"]/*' />
        public SoapNegativeInteger (Decimal value)
        {
            _value = Decimal.Truncate(value);
            if (value > Decimal.MinusOne)
                throw new RemotingException(
                                           String.Format(
                                                        Environment.GetResourceString(
                                                                                     "Remoting_SOAPInteropxsdInvalid"), "xsd:negativeInteger", value));
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.Value"]/*' />
        public Decimal Value
        {
            get {return _value;}
            set {
                _value = Decimal.Truncate(value);
                if (_value > Decimal.MinusOne)
                    throw new RemotingException(
                                               String.Format(
                                                            Environment.GetResourceString(
                                                                                         "Remoting_SOAPInteropxsdInvalid"), "xsd:negativeInteger", value));
            }
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.ToString"]/*' />
        public override String ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNegativeInteger.Parse"]/*' />
        public static SoapNegativeInteger Parse(String value)
        {
            return new SoapNegativeInteger(Decimal.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture));
        }
    }



    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri"]/*' />
    [Serializable]
    public sealed class SoapAnyUri : ISoapXsd
    {
        String _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "anyURI";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.SoapAnyUri"]/*' />
        public SoapAnyUri()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.SoapAnyUri1"]/*' />
        public SoapAnyUri (String value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.ToString"]/*' />
        public override String ToString()
        {
            return _value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapAnyUri.Parse"]/*' />
        public static SoapAnyUri Parse(String value)
        {
            return new SoapAnyUri(value);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName"]/*' />
    [Serializable]
    public sealed class SoapQName : ISoapXsd
    {
        String _name;
        String _namespace;
        String _key;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "QName";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.SoapQName"]/*' />
        public SoapQName()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.SoapQName1"]/*' />
        public SoapQName(String value)
        {
            _name = value;
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.SoapQName2"]/*' />
        public SoapQName (String key, String name)
        {
            _name = name;
            _key = key;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.SoapQName3"]/*' />
        public SoapQName (String key, String name, String namespaceValue)
        {
            _name = name;
            _namespace = namespaceValue;
            _key = key;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.Name"]/*' />
        public String Name
        {
            get {return _name;}
            set {_name = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.Namespace"]/*' />
        public String Namespace
        {
            get {
                /*
                if (_namespace == null || _namespace.Length == 0)
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_SOAPQNameNamespace"), _name));
                    */

                return _namespace;
                }
            set {_namespace = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.Key"]/*' />
        public String Key
        {
            get {return _key;}
            set {_key = value;}
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.ToString"]/*' />
        public override String ToString()
        {
            if (_key == null || _key.Length == 0)
                return _name;
            else
                return _key+":"+_name;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapQName.Parse"]/*' />
        public static SoapQName Parse(String value)
        {
            if (value == null)
                return new SoapQName();

            String key = "";
            String name = value;

            int index = value.IndexOf(':');
            if (index > 0)
            {
                key = value.Substring(0,index);
                name = value.Substring(index+1);
            }

            return new SoapQName(key, name);
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation"]/*' />
    [Serializable]
    public sealed class SoapNotation : ISoapXsd
    {
        String _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "NOTATION";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.SoapNotation"]/*' />
        public SoapNotation()
        {
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.SoapNotation1"]/*' />
        public SoapNotation (String value)
        {
            _value = value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.ToString"]/*' />
        public override String ToString()
        {
            return _value;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNotation.Parse"]/*' />
        public static SoapNotation Parse(String value)
        {
            return new SoapNotation(value);
        }
    }


    // Used to pass a string to xml which won't be escaped.

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString"]/*' />
    [Serializable]
    public sealed class SoapNormalizedString : ISoapXsd
    {
        String _value;


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.XsdType"]/*' />
        public static String XsdType
        {
            get{ return "normalizedString";}
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.SoapNormalizedString"]/*' />
        public SoapNormalizedString()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.SoapNormalizedString1"]/*' />
        public SoapNormalizedString (String value)
        {
            _value = Validate(value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = Validate(value);}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNormalizedString.Parse"]/*' />
        public static SoapNormalizedString Parse(String value)
        {
            return new SoapNormalizedString(value);
        }

        private String Validate(String value)
        {
            if (value == null || value.Length == 0)
                return value;

            Char[] validateChar = {(Char)0xD, (Char)0xA, (Char)0x9};

            int index = value.LastIndexOfAny(validateChar); 

            if (index > -1)
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_SOAPInteropxsdInvalid"), "xsd:normalizedString", value));

            return value;
        }

    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken"]/*' />
    [Serializable]
    public sealed class SoapToken : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.XsdType"]/*' />
        public static String XsdType
        {
            get{return "token";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.SoapToken"]/*' />
        public SoapToken()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.SoapToken1"]/*' />
        public SoapToken (String value)
        {
            _value = Validate(value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = Validate(value);}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapToken.Parse"]/*' />
        public static SoapToken Parse(String value)
        {
            return new SoapToken(value);
        }

        private String Validate(String value)
        {
            if (value == null || value.Length == 0)
                return value;

            Char[] validateChar = {(Char)0xD, (Char)0x9};

            int index = value.LastIndexOfAny(validateChar); 

            if (index > -1)
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_SOAPInteropxsdInvalid"), "xsd:token", value));

            if (value.Length > 0)
            {
                if (Char.IsWhiteSpace(value[0]) || Char.IsWhiteSpace(value[value.Length - 1]))
                    throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_SOAPInteropxsdInvalid"), "xsd:token", value));
            }

            index = value.IndexOf("  ");
            if (index > -1)
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_SOAPInteropxsdInvalid"), "xsd:token", value));

            return value;
        }
    }


    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage"]/*' />
    [Serializable]
    public sealed class SoapLanguage : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.XsdType"]/*' />
        public static String XsdType
        {
            get{return "language";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.SoapLanguage"]/*' />
        public SoapLanguage()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.SoapLanguage1"]/*' />
        public SoapLanguage (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapLanguage.Parse"]/*' />
        public static SoapLanguage Parse(String value)
        {
            return new SoapLanguage(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName"]/*' />
    [Serializable]
    public sealed class SoapName : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.XsdType"]/*' />
        public static String XsdType
        {
            get{return "Name";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.SoapName"]/*' />
        public SoapName()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.SoapName1"]/*' />
        public SoapName (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapName.Parse"]/*' />
        public static SoapName Parse(String value)
        {
            return new SoapName(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs"]/*' />
    [Serializable]
    public sealed class SoapIdrefs : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.XsdType"]/*' />
        public static String XsdType
        {
            get{return "IDREFS";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.SoapIdrefs"]/*' />
        public SoapIdrefs()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.SoapIdrefs1"]/*' />
        public SoapIdrefs (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdrefs.Parse"]/*' />
        public static SoapIdrefs Parse(String value)
        {
            return new SoapIdrefs(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities"]/*' />
    [Serializable]
    public sealed class SoapEntities : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.XsdType"]/*' />
        public static String XsdType
        {
            get{return "ENTITIES";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }


        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.SoapEntities"]/*' />
        public SoapEntities()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.SoapEntities1"]/*' />
        public SoapEntities (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntities.Parse"]/*' />
        public static SoapEntities Parse(String value)
        {
            return new SoapEntities(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken"]/*' />
    [Serializable]
    public sealed class SoapNmtoken : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.XsdType"]/*' />
        public static String XsdType
        {
            get{return "NMTOKEN";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.SoapNmtoken"]/*' />
        public SoapNmtoken()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.SoapNmtoken1"]/*' />
        public SoapNmtoken (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtoken.Parse"]/*' />
        public static SoapNmtoken Parse(String value)
        {
            return new SoapNmtoken(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens"]/*' />
    [Serializable]
    public sealed class SoapNmtokens : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.XsdType"]/*' />
        public static String XsdType
        {
            get{return "NMTOKENS";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.SoapNmtokens"]/*' />
        public SoapNmtokens()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.SoapNmtokens1"]/*' />
        public SoapNmtokens (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNmtokens.Parse"]/*' />
        public static SoapNmtokens Parse(String value)
        {
            return new SoapNmtokens(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName"]/*' />
    [Serializable]
    public sealed class SoapNcName : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.XsdType"]/*' />
        public static String XsdType
        {
            get{return "NCName";}
        }



        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.SoapNcName"]/*' />
        public SoapNcName()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.SoapNcName1"]/*' />
        public SoapNcName (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapNcName.Parse"]/*' />
        public static SoapNcName Parse(String value)
        {
            return new SoapNcName(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId"]/*' />
    [Serializable]
    public sealed class SoapId : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.XsdType"]/*' />
        public static String XsdType
        {
            get{return "ID";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.SoapId"]/*' />
        public SoapId()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.SoapId1"]/*' />
        public SoapId (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapId.Parse"]/*' />
        public static SoapId Parse(String value)
        {
            return new SoapId(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref"]/*' />
    [Serializable]
    public sealed class SoapIdref : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.XsdType"]/*' />
        public static String XsdType
        {
            get{return "IDREF";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.SoapIdref"]/*' />
        public SoapIdref()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.SoapIdref1"]/*' />
        public SoapIdref (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapIdref.Parse"]/*' />
        public static SoapIdref Parse(String value)
        {
            return new SoapIdref(value);
        }
    }

    /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity"]/*' />
    [Serializable]
    public sealed class SoapEntity : ISoapXsd
    {
        String _value;

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.XsdType"]/*' />
        public static String XsdType
        {
            get{return "ENTITY";}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.GetXsdType"]/*' />
        public String GetXsdType()
        {
            return XsdType;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.SoapEntity"]/*' />
        public SoapEntity()
        {
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.SoapEntity1"]/*' />
        public SoapEntity (String value)
        {
            _value = value;
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.Value"]/*' />
        public String Value
        {
            get {return _value;}
            set {_value = value;}
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.ToString"]/*' />
        public override String ToString()
        {
            return SoapType.Escape(_value);
        }

        /// <include file='doc\SoapInteropTypes.uex' path='docs/doc[@for="SoapEntity.Parse"]/*' />
        public static SoapEntity Parse(String value)
        {
            return new SoapEntity(value);
        }
    }
        }

    // namespace System.Runtime.Remoting.Metadata
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\serveridentity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Remoting {
    using System;
    using System.Collections;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Proxies;
    
    //  ServerIdentity derives from Identity and holds the extra server specific information
    //  associated with each instance of a remoted server object.
    //
    internal class ServerIdentity : Identity, ISerializable
    {
        // Internal members 
        internal Context _srvCtx;

        // These two fields are used for (purely) MarshalByRef object identities
        // For context bound objects we have corresponding fields in RemotingProxy
        // that are used instead. This is done to facilitate GC in x-context cases.
        internal IMessageSink _serverObjectChain;
        internal StackBuilderSink _stackBuilderSink;
    
        // This manages the dynamic properties registered on per object/proxy basis
        internal DynamicPropertyHolder _dphSrv;
    
        internal Type _srvType;  // type of server object
        internal bool _bMarshaledAsSpecificType = false;
        internal int _firstCallDispatched = 0;
        

        // outstanding external references
        private  int _refCount;


        //   Creates a new server identity. This form is used by RemotingServices.Wrap
        //
        internal ServerIdentity(MarshalByRefObject obj, Context serverCtx) : base(obj is ContextBoundObject)
        {
            if(null != obj)
            {
                if(!RemotingServices.IsTransparentProxy(obj))
                {
                    _srvType = obj.GetType();
                }
                else
                {
                    RealProxy rp = RemotingServices.GetRealProxy(obj);
                    _srvType =   rp.GetProxiedType();
                }
            }
            
            _srvCtx = serverCtx;
            _serverObjectChain = null; 
            _stackBuilderSink = null;
            _refCount = 0;
        }

        // This is used by RS::SetObjectUriForMarshal
        internal ServerIdentity(MarshalByRefObject obj, Context serverCtx, String uri) : 
            this(obj, serverCtx)
        {
            SetOrCreateURI(uri, true); // calling from the constructor
        }
        
    
        // Informational methods on the ServerIdentity.
        // Get the native context for the server object.
        internal Context ServerContext
        {
            get {return _srvCtx;}
        }
    
        internal void SetSingleCallObjectMode()
        {
            BCLDebug.Assert( !IsSingleCall() && !IsSingleton(), "Bad serverID");
            _flags |= IDFLG_SERVER_SINGLECALL; 
        }

        internal void SetSingletonObjectMode()
        {
            BCLDebug.Assert( !IsSingleCall() && !IsSingleton(), "Bad serverID");
            _flags |= IDFLG_SERVER_SINGLETON; 
        }
       
        internal bool IsSingleCall()
        {
            return ((_flags&IDFLG_SERVER_SINGLECALL) != 0); 
        }

        internal bool IsSingleton()
        {
            return ((_flags&IDFLG_SERVER_SINGLETON) != 0); 
        }
    
        internal IMessageSink GetServerObjectChain(out MarshalByRefObject obj)
        {
            obj = null;
            // NOTE: Lifetime relies on the Identity flags for 
            // SingleCall and Singleton being set by the time this getter 
            // is called.
            if (!this.IsSingleCall())
            {
                // This is the common case 
                if (_serverObjectChain == null) 
                {
                    lock(this)
                    {
                        if(_serverObjectChain == null)
                        {
                            MarshalByRefObject srvObj = 
                                (MarshalByRefObject) 
                                    this.TPOrObject;

                            _serverObjectChain = 
                                _srvCtx.CreateServerObjectChain(
                                    srvObj);
                                
                        }
                    }   
                }
                BCLDebug.Assert( null != _serverObjectChain, 
                    "null != _serverObjectChain");

                return _serverObjectChain;                    
            }
            else 
            {
                // ---------- SINGLE CALL WKO --------------
                // In this case, we are expected to provide 
                // a fresh server object for each dispatch.
                // Since the server object chain is object 
                // specific, we must create a fresh chain too.

                // We must be in the correct context for this
                // to succeed.

                // NOTE: It may be useful to recycle the context too
                // but for V1 we will keep the context we setup for
                // the first object around and always dispatch the call
                // through that context ... when we are here we have
                // already been through the server sink chain. We will
                // only dispatch through the object sink chain of the
                // object we will create below ... if for some reason   
                // the object creates its own context we will not go
                // through the server sink chain for that context again.
                // We should fix this in V-next and always create everything
                // from scratch for single-call wellKnown objects
                
                BCLDebug.Assert(Thread.CurrentContext==_srvCtx,
                    "Bad context mismatch");
                MarshalByRefObject srvObj = null;
                IMessageSink objChain = null;
                if (_tpOrObject != null && _firstCallDispatched == 0 && Interlocked.CompareExchange(ref _firstCallDispatched, 1, 0) == 0)
                {
                    // use the instance of server object created to 
                    // set up the pipeline.
                    srvObj = (MarshalByRefObject) _tpOrObject;

                    objChain = _serverObjectChain;

                    if (objChain == null)
                    {
                        objChain = _srvCtx.CreateServerObjectChain(srvObj);
                    }
                }
                else
                {
                    // For singleCall we create a fresh object & its chain
                    // on each dispatch!
                    srvObj = (MarshalByRefObject)
                            Activator.CreateInstance((Type)_srvType, true);

                    // make sure that object didn't Marshal itself.
                    // (well known objects should live up to their promise
                    // of exporting themselves through exactly one url)
                    String tempUri = RemotingServices.GetObjectUri(srvObj);
                    if (tempUri != null)
                    {
                        throw new RemotingException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Remoting_WellKnown_CtorCantMarshal"),
                                this.URI));
                    }

                    // Set the identity depending on whether we have the server
                    // or proxy
                    if(!RemotingServices.IsTransparentProxy(srvObj))
                    {

#if _DEBUG
                        Identity idObj = srvObj.__RaceSetServerIdentity(this);
#else
                        srvObj.__RaceSetServerIdentity(this);
#endif
#if _DEBUG
                        BCLDebug.Assert(idObj == this, "Bad ID state!" );             
                        BCLDebug.Assert(idObj == MarshalByRefObject.GetIdentity(srvObj), "Bad ID state!" );             
#endif
                    }
                    else
                    {
                        RealProxy rp = null;
                        rp = RemotingServices.GetRealProxy(srvObj);
                        BCLDebug.Assert(null != rp, "null != rp");
    //  #if _DEBUG
    //                      Identity idObj = (ServerIdentity) rp.SetIdentity(this);
    // #else
                        rp.IdentityObject = this;
    // #endif 
#if _DEBUG
                        // REVIEW: turn these on after adding a clean way to 
                        // reset identity-s on x-context proxies ... (id needs
                        // to be set in the proxy && on the _serverObject in
                        // the proxy)
                        // BCLDebug.Assert(idObj == this, "Bad ID state!" );             
                        // BCLDebug.Assert(idObj == rp.IdentityObject, "Bad ID state!" );             
#endif
                    }
                    // Create the object chain and return it
                    objChain = _srvCtx.CreateServerObjectChain(srvObj);
                }

                // This is passed out to the caller so that for single-call
                // case we can call Dispose when the incoming call is done
                obj = srvObj;
                return objChain;
            }
        }
    
        internal Type ServerType
        {
            get { return _srvType; }
            set { _srvType = value; }
        } // ServerType

        internal bool MarshaledAsSpecificType
        {
            get { return _bMarshaledAsSpecificType; }
            set { _bMarshaledAsSpecificType = value; }
        } // MarshaledAsSpecificType
        
    
        internal IMessageSink RaceSetServerObjectChain(
            IMessageSink serverObjectChain)
        {
            if (_serverObjectChain == null)
            {
                lock(this) 
                {
                    if (_serverObjectChain == null)
                    {
                        _serverObjectChain = serverObjectChain;
                    }
                }
            }
            return _serverObjectChain;       
        }

    
        /*package*/
        internal bool AddServerSideDynamicProperty(
            IDynamicProperty prop)
        {
            if (_dphSrv == null)
            {
                DynamicPropertyHolder dphSrv = new DynamicPropertyHolder();
                lock (this)
                {
                    if (_dphSrv == null)
                    {
                        _dphSrv = dphSrv;
                    }
                }
            }
            return _dphSrv.AddDynamicProperty(prop);
        }
        
        /*package*/
        internal bool RemoveServerSideDynamicProperty(String name)
        {
            if (_dphSrv == null) 
            {
                throw new ArgumentException(Environment.GetResourceString("Arg_PropNotFound") );        
            }
            return _dphSrv.RemoveDynamicProperty(name);
        }
    
        internal StackBuilderSink ServerStackBuilderSink
        {
            get
            {
                if (_stackBuilderSink == null) 
                {
                
                    lock(this) 
                    {
                        if (_stackBuilderSink == null) 
                        {
                            IMessageSink so = _serverObjectChain;
                            IMessageSink pNext;
                            if (so == null)
                            {
                                return null;
                            }
                            while ((pNext = so.NextSink) != null) 
                            {
                                so = pNext;
                            }
                            BCLDebug.Assert(
                                so is ServerObjectTerminatorSink,
                                "so is typeof(ServerObjectTerminatorSink");
                                
                            _stackBuilderSink = 
                                ((ServerObjectTerminatorSink) so)._stackBuilderSink;
                        }
                    }
                }
                return _stackBuilderSink;                
            }
        }
        /*
         *   Returns an array of context specific dynamic properties
         *   registered for this context. The number of such properties
         *   is designated by length of the returned array.
         */
        /* package */
        internal IDynamicProperty[] ServerSideDynamicProperties
        {
            get 
            {
                if (_dphSrv==null)
                {
                    return null;
                }   
                else
                {
                    return _dphSrv.DynamicProperties;
                }
            }
        }
            
        internal ArrayWithSize ServerSideDynamicSinks
        {
            get
            {
                if (_dphSrv == null)
                    {
                        return null;
                    }
                else
                    {
                        return _dphSrv.DynamicSinks;
                    }
            }
        }
               
        internal override void AssertValid()
        {
            base.AssertValid();
            if((null != this.TPOrObject) && !RemotingServices.IsTransparentProxy(this.TPOrObject))
            {
                BCLDebug.Assert(MarshalByRefObject.GetIdentity((MarshalByRefObject)this.TPOrObject) == this, "Server ID mismatch with Object");
            }
        }
    
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) 
        {
            Message.DebugOut("Exception::ServerIdentity::GetObjectData\n");
            throw new NotSupportedException(
                Environment.GetResourceString("NotSupported_Method"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\synchronizeddispatch.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//   Synchronization Property for URT Contexts. Uses the ThreadPool API.
//   An instance of this property in a context enforces a synchronization
//   domain for the context (and all contexts that share the same instance).
//   This means that at any instant, at most 1 thread could be executing
//   in all contexts that share an instance of this property.
//
//   This is done by contributing sinks that intercept and serialize in-coming
//   calls for the respective contexts.
//
//   If the property is marked for re-entrancy, then call-outs are 
//   intercepted too. The call-out interception allows other waiting threads
//   to enter the synchronization domain for maximal throughput.
//   
namespace System.Runtime.Remoting.Contexts {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Activation;
    using System.Security.Permissions;
    using System;
    using Queue = System.Collections.Queue;
    using ArrayList = System.Collections.ArrayList;
    /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute"]/*' />
    [Serializable]
    [AttributeUsage(AttributeTargets.Class)]
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class SynchronizationAttribute
        : ContextAttribute, IContributeServerContextSink, 
                    IContributeClientContextSink
    {
        // The class should not be instantiated in a context that has Synchronization
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.NOT_SUPPORTED"]/*' />
        public const int NOT_SUPPORTED  = 0x00000001;
        
        // The class does not care if the context has Synchronization or not
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.SUPPORTED"]/*' />
        public const int SUPPORTED      = 0x00000002;
    
        // The class should be instantiated in a context that has Synchronization
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.REQUIRED"]/*' />
        public const int REQUIRED    = 0x00000004;
    
        // The class should be instantiated in a context with a new instance of 
        // Synchronization property each time
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.REQUIRES_NEW"]/*' />
        public const int REQUIRES_NEW = 0x00000008;
    
        private const String PROPERTY_NAME = "Synchronization";
    
        private static readonly UInt32 _timeOut = (UInt32)0x7fffffff;
        // event that releases a thread-pool worker thread
        [NonSerialized()]internal AutoResetEvent _asyncWorkEvent;
        // queue of work items.
        [NonSerialized()]internal Queue _workItemQueue;
        // flag for the domain lock (access always synchronized on the _workItemQueue)
        [NonSerialized()]internal bool _locked;
        // flag to indicate if the lock should be released during call-outs
        internal bool _bReEntrant;
        // flag for use as an attribute on types
        internal int _flavor;

        [NonSerialized()]private SynchronizationAttribute _cliCtxAttr;
        // Logical call id (used only in non-reentrant case for deadlock avoidance)
        [NonSerialized()]private String _syncLcid;
        [NonSerialized()]private ArrayList _asyncLcidList;
        
    
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.Locked"]/*' />
        public virtual bool Locked {get { return _locked;} set { _locked=value; } }	
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.IsReEntrant"]/*' />
        public virtual bool IsReEntrant { get { return _bReEntrant;} }	

        internal String SyncCallOutLCID
        {
            get 
            { 
                BCLDebug.Assert(
                    !_bReEntrant, 
                    "Should not use this for the reentrant case");
                    
                return _syncLcid;
            }

            set
            {
                BCLDebug.Assert(
                    !_bReEntrant, 
                    "Should not use this for the reentrant case");

                BCLDebug.Assert(
                    _syncLcid==null 
                        || (_syncLcid!=null && value==null) 
                        || _syncLcid.Equals(value), 
                    "context can be associated with one logical call at a time");
                
                _syncLcid = value;
            }
        }

        internal ArrayList AsyncCallOutLCIDList
        {
            get { return _asyncLcidList; }
        }

        internal bool IsKnownLCID(IMessage reqMsg)
        {
            String msgLCID = 
                ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey])
                    .RemotingData.LogicalCallID;
            return ( msgLCID.Equals(_syncLcid)
                    || _asyncLcidList.Contains(msgLCID));
            
        }

    
        /*
        *   Constructor for the synchronized dispatch property
        */
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute"]/*' />
        public SynchronizationAttribute()
        
            : this(REQUIRED, false) {
        }
    
        /*
        *   Constructor. 
        *   If reEntrant is true, we allow other calls to come in
        *   if the currently running call leaves the domain for a call-out.
        */
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute1"]/*' />
        public SynchronizationAttribute(bool reEntrant)
        
            : this(REQUIRED, reEntrant) {
        }
    
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute2"]/*' />
        public SynchronizationAttribute(int flag)
        
            : this(flag, false) {
        }
    
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute3"]/*' />
        public SynchronizationAttribute(int flag, bool reEntrant)
        
            // Invoke ContextProperty ctor!
            : base(PROPERTY_NAME) {
            
            _bReEntrant = reEntrant;
    
            switch (flag)
            {
            case NOT_SUPPORTED:
            case SUPPORTED:
            case REQUIRED:
            case REQUIRES_NEW:
                _flavor = flag;
                break;
            default:
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidFlag"), "flag");
            }
        }
    
        // Override ContextAttribute's implementation of IContextAttribute::IsContextOK
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.IsContextOK"]/*' />
        public override bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            if (ctx == null)
                throw new ArgumentNullException("ctx");
            if (msg == null)
                throw new ArgumentNullException("msg");

            // FUTURE: we should also check for ThreadAffinity!
            // If the context has ThreadAffinity then it is synchronized by default!
            bool isOK = true;
            if (_flavor == REQUIRES_NEW)
            {
                isOK = false;
                // Each activation request instantiates a new attribute class.
                // We are relying on that for the REQUIRES_NEW case!
                BCLDebug.Assert(ctx.GetProperty(PROPERTY_NAME) != this,
                    "ctx.GetProperty(PROPERTY_NAME) != this");
            }
            else
            {
                SynchronizationAttribute syncProp = (SynchronizationAttribute) ctx.GetProperty(PROPERTY_NAME);
                if (   ( (_flavor == NOT_SUPPORTED)&&(syncProp != null) )
                    || ( (_flavor == REQUIRED)&&(syncProp == null) )
                    )
                {
                    isOK = false;
                }

                if (_flavor == REQUIRED)
                {
                    // pick up the property from the current context
                    _cliCtxAttr = syncProp;
                }
            }
            return isOK;
        }
    
        // Override ContextAttribute's impl. of IContextAttribute::GetPropForNewCtx
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.GetPropertiesForNewContext"]/*' />
        public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
        {
            if ( (_flavor==NOT_SUPPORTED) || (_flavor==SUPPORTED) || (null == ctorMsg) )
            {
                return ;
            }

            if (_cliCtxAttr != null)
            {
                BCLDebug.Assert(_flavor == REQUIRED,"Use cli-ctx property only for the REQUIRED flavor");
                ctorMsg.ContextProperties.Add((IContextProperty)_cliCtxAttr);
                _cliCtxAttr = null;
            }
            else
            {
                ctorMsg.ContextProperties.Add((IContextProperty)this);
            }
        }
    
        // We need this to make the use of the property as an attribute 
        // light-weight. This allows us to delay initialize everything we
        // need to fully function as a ContextProperty.
        internal virtual void InitIfNecessary()
        {
            lock(this) 
            {
                if (_asyncWorkEvent == null)
                {
                    // initialize thread pool event to non-signaled state.
                    _asyncWorkEvent = new AutoResetEvent(false);
        
                    _workItemQueue = new Queue();
                    _asyncLcidList = new ArrayList();
                    
                    WaitOrTimerCallback callBackDelegate = 
                        new WaitOrTimerCallback(this.DispatcherCallBack);
        
                    // Register a callback to be executed by the thread-pool
                    // each time the event is signaled.
                    ThreadPool.RegisterWaitForSingleObject(
                                    _asyncWorkEvent, 
                                    callBackDelegate, 
                                    null, // state info
                                    _timeOut, 
                                    false); // bExecuteOnlyOnce
                }
            }
        }
    
        /* 
        * Call back function -- executed for each work item that 
        * was enqueued. This is invoked by a thread-pool thread for
        * async work items and the caller thread for sync items.
        */
        private void DispatcherCallBack(Object stateIgnored, bool ignored)
        {
            // This function should be called by only one thread at a time. We will 
            // ensure this by releasing exactly one waiting thread to go work on 
            // a WorkItem

            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] --- In DispatherCallBack ");

            BCLDebug.Assert(_locked==true,"_locked==true");
            WorkItem work;     
            // get the work item out of the queue.
            lock (_workItemQueue)
            {
                work = (WorkItem) _workItemQueue.Dequeue();
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] --- Dequeued Work for: " + work._thread.GetHashCode());
            }
            BCLDebug.Assert(work!=null,"work!=null");
            BCLDebug.Assert(work.IsSignaled() && !(work.IsDummy()),"work.IsSignaled() && !(work.IsDummy())");
            // execute the work item (WorkItem.Execute will switch to the proper context)
            ExecuteWorkItem(work);
            HandleWorkCompletion();
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] --- CallBack finished for: " + work._thread.GetHashCode());
        }
    
        /*
        *   This is used by the call-out (client context) sinks to notify 
        *   the domain manager that the thread is leaving
        */
        internal virtual void HandleThreadExit()
        {
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~~ Thread EXIT ~~~~");
            // For now treat this as if the work was completed!
            BCLDebug.Assert(_locked==true,"_locked==true");
            HandleWorkCompletion();    
        }
    
        /* 
        *   This is used by a returning call-out thread to request
        *   that it be queued for re-entry into the domain.
        */
        internal virtual void HandleThreadReEntry()
        {
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~~ Thread REQUEST REENTRY ~~~~");
            // Treat this as if a new work item needs to be done
            // FUTURE: can we do with a single static item here?
            // We will queue a dummy work item to act as a Wait object.
            WorkItem work = new WorkItem(null, null, null);
            work.SetDummy();
            HandleWorkRequest(work);
        }
    
        /*
        *   This gets called at the end of work.Execute and from 
        *   HandleThreadExit() in the re-entrant scenario.
        *   This is the point where we decide what to do next!
        */
        internal virtual void HandleWorkCompletion()
        {
            // We should still have the lock held for the workItem that just completed
            BCLDebug.Assert(_locked==true,"_locked==true");
            // Now we check the queue to see if we need to release any one?
            WorkItem nextWork = null;
            bool bNotify = false;
            lock (_workItemQueue)
            {      
                if (_workItemQueue.Count >= 1)
                {
                    nextWork = (WorkItem) _workItemQueue.Peek();
                    bNotify = true;
                    nextWork.SetSignaled();
                }
                else
                {
                    // We set locked to false only in the case there is no
                    // next work to be done.
                    // NOTE: this is the only place _locked in ever set to false!
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Domain UNLOCKED!");
                    _locked = false;
                }
            }
            // See if we found a non-signaled work item at the head. 
            if (bNotify)
            {
                // In both sync and async cases we just hand off the _locked state to
                // the next thread which will execute.
                if (nextWork.IsAsync())
                {
                    // Async-WorkItem: signal ThreadPool event to release one thread
                    _asyncWorkEvent.Set();
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ### Signal " + nextWork._thread.GetHashCode() + (nextWork.IsDummy()?" DUMMY ":" REAL "));
                }
                else
                {
                    // Sync-WorkItem: notify the waiting sync-thread.
                    lock(nextWork)
                    {
                        Monitor.Pulse(nextWork);
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ Notify " + nextWork._thread.GetHashCode() + (nextWork.IsDummy()?" DUMMY ":" REAL ") );
                    }
                }
            }
        }
    
        /*
        *   This is called by any new incoming thread or from
        *   HandleThreadReEntry() when a call-out thread wants to
        *   re-enter the domain. 
        *   In the latter case, the WorkItem is a dummy item, it
        *   just serves the purpose of something to block on till
        *   the thread is given a green signal to re-enter.
        */
        internal virtual void HandleWorkRequest(WorkItem work)
        {
            // FUTURE: right now completion(dummy) items and regular items are 
            // treated similarly, without priorities. We might want to change this
            // so that completion items are prioritized
            bool bQueued;

            // Check for nested call backs
            if (!IsNestedCall(work._reqMsg))
            {
                // See what type of work it is
                if (work.IsAsync()) 
                {
                    // Async work is always queued.
                    bQueued = true;
                    // Enqueue the workItem
                    lock (_workItemQueue)
                    {
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ### Async Item EnQueue " + work._thread.GetHashCode());
                        work.SetWaiting();
                        _workItemQueue.Enqueue(work);
                        // If this is the only work item in the queue we will
                        // have to trigger the thread-pool event ourselves
                        if ( (!_locked) && (_workItemQueue.Count == 1) )
                        {
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ### Async Signal Self: " + work._thread.GetHashCode());
                            work.SetSignaled();
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ### Domain Locked!");
                            _locked = true;
                            _asyncWorkEvent.Set();                    
                        }
                    }
                }
                else
                {        
                    // Sync work is queued only if there are other items
                    // already in the queue.
                    lock(work)
                    {
                        // Enqueue if we need to
                        lock(_workItemQueue)
                        {
                            if ((!_locked) && (_workItemQueue.Count == 0))
                            {                    
                                _locked = true;
                                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ### Domain Locked!");
                                bQueued = false;
                            }
                            else
                            {
                                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ ENQUEUE Sync!" + (work.IsDummy()?" DUMMY ":" REAL ") + work._thread);
                                bQueued = true;
                                work.SetWaiting();
                                _workItemQueue.Enqueue(work);
                            }
                        }
                        
                        if (bQueued == true)
                        {
                            // If we queued a work item we must wait for some
                            // other thread to peek at it and Notify us.
                            
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ WORK::WAIT" + work._thread);
                            Monitor.Wait(work);
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ FINISH Work::WAIT" + work._thread);
                            BCLDebug.Assert(_locked==true,"_locked==true");
                            // Our turn to complete the work! 
                            // Execute the callBack only if this is real work
                            if (!work.IsDummy())
                            {
                                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ Invoke DispatcherCallBack " + work._thread);
                                // We invoke the callback here that does exactly
                                // what we need to do ... dequeue work, execute, checkForMore
                                DispatcherCallBack(null, true);
                            }
                            else
                            {
                                // DummyWork is just use to block/unblock a returning call.
                                // Throw away our dummy WorkItem. 
                                lock(_workItemQueue)
                                {
                                    _workItemQueue.Dequeue();
                                }
                                // We don't check for more work here since we are already 
                                // in the midst of an executing WorkItem (at the end of which
                                // the check will be performed)
                            }
                        }
                        else
                        {
                            // We did not queue the work item.
                            if (!work.IsDummy())
                            {
                                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ Execute direct" + work._thread);
                                // Execute the work.
                                BCLDebug.Assert(_locked==true,"_locked==true");
                                work.SetSignaled();
                                ExecuteWorkItem(work);
                                // Check for more work
                                HandleWorkCompletion();
                            }
                        }
                    }
                }
            }    
            else
            {
                // We allow the nested calls to execute directly                
                
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ~~~ Execute Nested Call direct" + work._thread);
                // Execute the work.
                BCLDebug.Assert(_locked==true,"_locked==true");
                work.SetSignaled();
                work.Execute();
                // We are still inside the top level call ...
                // so after work.Execute finishes we don't check for more work
                // or unlock the domain as we do elsewhere.
            }            
        }

        internal void ExecuteWorkItem(WorkItem work)
        {
            work.Execute();
        }

        internal bool IsNestedCall(IMessage reqMsg)
        {
            // This returns TRUE only if it is a non-reEntrant context
            // AND 
            // (the LCID of the reqMsg matches that of 
            // the top level sync call lcid associated with the context.
            //  OR
            // it matches one of the async call out lcids)
            
            bool bNested = false;
            if (!IsReEntrant)
            {
                String lcid = SyncCallOutLCID;                
                if (lcid != null)
                {
                    // This means we are inside a top level call
                    LogicalCallContext callCtx = 
                        (LogicalCallContext)reqMsg.Properties[Message.CallContextKey];
                        
                    if ( callCtx!=null && 
                        lcid.Equals(callCtx.RemotingData.LogicalCallID))
                    {
                        // This is a nested call (we made a call out during
                        // the top level call and eventually that has resulted 
                        // in an incoming call with the same lcid)
                        bNested = true;
                    }                    
                }
                if (!bNested && AsyncCallOutLCIDList.Count>0)
                {
                    // This means we are inside a top level call
                    LogicalCallContext callCtx = 
                        (LogicalCallContext)reqMsg.Properties[Message.CallContextKey];
                    if (AsyncCallOutLCIDList.Contains(callCtx.RemotingData.LogicalCallID))
                    {
                        bNested = true;
                    }
                }
            }
            return bNested;
        }
        
        
        /*
        *   Implements IContributeServerContextSink::GetServerContextSink
        *   Create a SynchronizedDispatch sink and return it.
        */
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.GetServerContextSink"]/*' />
        public virtual IMessageSink GetServerContextSink(IMessageSink nextSink)
        {
            InitIfNecessary();
            
            SynchronizedServerContextSink propertySink = 
                new SynchronizedServerContextSink(
                            this,   
                            nextSink);
                            
            return (IMessageSink) propertySink;
        }
    
        /*
        *   Implements IContributeClientContextSink::GetClientContextSink
        *   Create a CallOut sink and return it.
        */
        /// <include file='doc\SynchronizedDispatch.uex' path='docs/doc[@for="SynchronizationAttribute.GetClientContextSink"]/*' />
        public virtual IMessageSink GetClientContextSink(IMessageSink nextSink)
        {
            InitIfNecessary();
            
            SynchronizedClientContextSink propertySink = 
                new SynchronizedClientContextSink(
                            this,
                            nextSink);
                                                                        
            return (IMessageSink) propertySink;
        }
        
    }
    
    /*************************************** SERVER SINK ********************************/
    /*
    *   Implements the sink contributed by the Synch-Dispatch
    *   Property. The sink holds a back pointer to the property.
    *   The sink intercepts incoming calls to objects resident in
    *   the Context and co-ordinates with the property to enforce
    *   the domain policy.
    */
    internal class SynchronizedServerContextSink
            : InternalSink, IMessageSink
    {
        internal IMessageSink   _nextSink;
        internal SynchronizationAttribute _property;
    
        internal SynchronizedServerContextSink(SynchronizationAttribute prop, IMessageSink nextSink)
        {
            _property = prop;
            _nextSink = nextSink;
        }
        
        /*
        * Implements IMessageSink::SyncProcessMessage
        */
        public virtual IMessage SyncProcessMessage(IMessage reqMsg)
        {
            // 1. Create a work item 
            WorkItem work = new WorkItem(reqMsg,
                                        _nextSink,
                                        null /* replySink */);
    
            // 2. Notify the property to handle the WorkItem
            // The work item may get put in a Queue or may execute directly
            // if the domain is free.
            _property.HandleWorkRequest(work);
    
            // 3. Pick up retMsg from the WorkItem and return
            return work.ReplyMessage;
        }
    
        /*
        *   Implements IMessageSink::AsyncProcessMessage
        */
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            // 1. Create a work item 
            WorkItem work = new WorkItem(reqMsg,
                                        _nextSink,
                                        replySink);
            work.SetAsync();
            // 2. We always queue the work item in async case
            _property.HandleWorkRequest(work); 
            // 3. Return an IMsgCtrl
            return null;    
        }
    
        /*  
        * Implements IMessageSink::GetNextSink
        */
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }
        }
    }
    
    //*************************************** WORK ITEM ********************************//
    /*
    *   A work item holds the info about a call to Sync or
    *   Async-ProcessMessage.
    */
    internal class WorkItem
    {
        private const int FLG_WAITING  = 0x0001;
        private const int FLG_SIGNALED = 0x0002;
        private const int FLG_ASYNC      = 0x0004;
        private const int FLG_DUMMY     = 0x0008;
    
        internal int _flags;
        internal IMessage _reqMsg;
        internal IMessageSink _nextSink;
        // ReplySink will be null for an sync work item.
        internal IMessageSink _replySink;
        // ReplyMsg is set once the sync call is completed
        internal IMessage _replyMsg;
    
        // Context in which the work should execute.
        internal Context _ctx;

        internal LogicalCallContext _callCtx;
    
        //DBGDBG
        //internal int _thread;   
        
        internal WorkItem(IMessage reqMsg, IMessageSink nextSink, IMessageSink replySink)
        {
            _reqMsg = reqMsg;
            _replyMsg = null;
            _nextSink = nextSink;
            _replySink = replySink;
            _ctx = Thread.CurrentContext;
            _callCtx = CallContext.GetLogicalCallContext();
            //DBGDBG 
            //_thread = Thread.CurrentThread.GetHashCode();
        }
    
        // To mark a work item being enqueued
        internal virtual void SetWaiting()
        {
            BCLDebug.Assert(!IsWaiting(),"!IsWaiting()");
            _flags |= FLG_WAITING;
        }
    
        internal virtual bool IsWaiting()
        {
            return (_flags&FLG_WAITING) == FLG_WAITING;
        }
    
        // To mark a work item that has been given the green light!
        internal virtual void SetSignaled()
        {
            BCLDebug.Assert(!IsSignaled(),"!IsSignaled()");
            _flags |= FLG_SIGNALED;
        }
    
        internal virtual bool IsSignaled()
        {
            return (_flags & FLG_SIGNALED) == FLG_SIGNALED;
        }
    
        internal virtual void SetAsync()
        {
            _flags |= FLG_ASYNC;
        }
        
        internal virtual bool IsAsync()
        {
            return (_flags & FLG_ASYNC) == FLG_ASYNC;
        }
    
        internal virtual void SetDummy()
        {
            _flags |= FLG_DUMMY;
        }
        
        internal virtual bool IsDummy()
        {
            return (_flags & FLG_DUMMY) == FLG_DUMMY;
        }
        
    
        /*
        *   Execute is called to complete a work item (sync or async).
        *   Execute assumes that the context is set correctly and the lock
        *   is taken (i.e. it makes no policy decisions)
        * 
        *   It is called from the following 3 points:
        *       1. thread pool thread executing the callback for an async item
        *       2. calling thread executing the callback for a queued sync item
        *       3. calling thread directly calling Execute for a non-queued sync item
        */
        internal virtual void Execute()
        {
            // Execute should be called with the domain policy enforced
            // i.e. a Synchronization domain should be locked etc ...
            BCLDebug.Assert(IsSignaled(),"IsSignaled()");
            ContextTransitionFrame frame = new ContextTransitionFrame();
            Thread.CurrentThread.EnterContext(_ctx, ref frame);            
         
            LogicalCallContext oldCallCtx = CallContext.SetLogicalCallContext(_callCtx);
            if (IsAsync())
            {
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] AsyncWork.Execute");
                _nextSink.AsyncProcessMessage(_reqMsg, _replySink);            
            }
            else if (_nextSink != null)
            {
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SyncWork.Execute");               
                _replyMsg = _nextSink.SyncProcessMessage(_reqMsg);                
            }                        
            CallContext.SetLogicalCallContext(oldCallCtx);
            
            Thread.CurrentThread.ReturnToContext(ref frame);
        }
        internal virtual IMessage ReplyMessage { get {return _replyMsg;}}	
    }
    
    //*************************************** CLIENT SINK ********************************//
    
    /*
    *   Implements the client context sink contributed by the
    *   Property. The sink holds a back pointer to the property.
    *   The sink intercepts outgoing calls from objects the Context 
    *   and co-ordinates with the property to enforce the domain policy.
    */
    internal class SynchronizedClientContextSink
            : InternalSink, IMessageSink
    {
        internal IMessageSink   _nextSink;
        internal SynchronizationAttribute _property;
    
        internal SynchronizedClientContextSink(SynchronizationAttribute prop, IMessageSink nextSink)
        {
            _property = prop;
            _nextSink = nextSink;
        }
        
        /*
        *   Implements IMessageSink::SyncProcessMessage for the call-out sink
        */
        public virtual IMessage SyncProcessMessage(IMessage reqMsg)
        {            
            BCLDebug.Assert(_property.Locked == true,"_property.Locked == true");
            IMessage replyMsg;
            if (_property.IsReEntrant)
            {
                // In this case we are required to let anybody waiting for
                // the domain to enter and execute
                // Notify the property that we are leaving 
                _property.HandleThreadExit();

                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: Sync call-out");
                replyMsg = _nextSink.SyncProcessMessage(reqMsg);
    
                // We will just block till we are given permission to re-enter
                // Notify the property that we wish to re-enter the domain.
                // This will block the thread here if someone is in the domain.
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: Sync call-out returned, waiting for lock");                
                _property.HandleThreadReEntry(); 
                BCLDebug.Assert(_property.Locked == true,"_property.Locked == true");
            }
            else
            {
                // In the non-reentrant case we are just a pass-through sink
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Sync call-out (pass through)");                
                // We should mark the domain with our LCID so that call-backs are allowed to enter..
                LogicalCallContext cctx = 
                    (LogicalCallContext) reqMsg.Properties[Message.CallContextKey];
                                                         
                String lcid = cctx.RemotingData.LogicalCallID;
                bool bClear = false;
                if (lcid == null)
                {
                    // We used to assign call-ids in RemotingProxy.cs at the
                    // start of each Invoke. As an optimization we now do it 
                    // here in a delayed fashion... since currently only 
                    // Synchronization needs it
                    // Note that for Sync-calls we would just inherit an LCID
                    // if the call has one, if not we create one. However for
                    // async calls we always generate a new LCID.
                    lcid = Identity.GetNewLogicalCallID();
                    cctx.RemotingData.LogicalCallID = lcid;
                    bClear = true;

                    BCLDebug.Assert(
                        _property.SyncCallOutLCID == null,
                        "Synchronization domain is already in a callOut state");
                }

                bool bTopLevel=false;
                if (_property.SyncCallOutLCID==null)
                {
                    _property.SyncCallOutLCID = lcid;
                    bTopLevel = true;
                }
                    
                BCLDebug.Assert(lcid.Equals(_property.SyncCallOutLCID), "Bad synchronization domain state!");                    
                
                replyMsg = _nextSink.SyncProcessMessage(reqMsg);

                // if a top level call out returned we clear the callId in the domain
                if (bTopLevel)
                {
                    _property.SyncCallOutLCID = null;

                    // The sync callOut is done, we do not need the lcid
                    // that was associated with the call any more.
                    // (clear it only if we added one to the reqMsg)
                    if (bClear)
                    {
                        // Note that we make changes to the callCtx in 
                        // the reply message ... since this is the one that
                        // will get installed back on the thread that called
                        // the proxy.
                        LogicalCallContext cctxRet = 
                            (LogicalCallContext) replyMsg.Properties[Message.CallContextKey];
                        BCLDebug.Assert(    
                            cctxRet != null,
                            "CallContext should be non-null");
                        cctxRet.RemotingData.LogicalCallID = null;
                    }
                }
                
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Sync call-out returned");
            }
            return replyMsg;
        }
    
        /*
        *   Implements IMessageSink::AsyncProcessMessage for the call-out sink
        */
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
        {
            IMessageCtrl msgCtrl = null;
            
            BCLDebug.Assert(_property.Locked == true,"_property.Locked == true");

            if (!_property.IsReEntrant)
            {
                // In this case new calls are not allowed to enter the domain
                // We need to track potentially more than one async-call-outs
                // and allow the completion notifications to come in for those

                LogicalCallContext cctx = 
                    (LogicalCallContext) reqMsg.Properties[Message.CallContextKey];
                // We used to generate a new lcid automatically in RemotingProxy
                // Invoke at the start of each Async call.
                // However now we do it here as an optimization (since only
                // Synchronization needs it)
                // RemotingProxy invoke code does Clone() the callContext at 
                // the start of each Async call so we don't have to worry 
                // about stomping someone else's lcid here.

                                                         
                String lcid =  Identity.GetNewLogicalCallID();
                cctx.RemotingData.LogicalCallID = lcid;
                    

                BCLDebug.Assert(
                    _property.SyncCallOutLCID == null,
                    "Cannot handle async call outs when already in a top-level sync call out");
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Async CallOut: adding to lcidList: " + lcid);                                            
                _property.AsyncCallOutLCIDList.Add(lcid);
            }
            // We will call AsyncProcessMessage directly on this thread 
            // since the thread should not block much. However, we will
            // have to intercept the callback on the replySink chain for
            // which we wrap the caller provided replySink into our sink.
            AsyncReplySink mySink = new AsyncReplySink(replySink, _property);          
            
            // NOTE: we will need to yield the Synchronization Domain at
            // some time or another to get our own callBack to complete.

            // Note that for the Async call-outs we have to provide an interception 
            // sink whether we are re-entrant or not since we want 
            // the replySink.SyncProcessMessage call to be wait for the lock just like
            // any other call-in.
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Async call-out");
            
            msgCtrl = _nextSink.AsyncProcessMessage(reqMsg, (IMessageSink)mySink);
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Async call-out AsyncPM returned, reply to come separately");

            return msgCtrl;
        }
    
        /*
        *   Implements IMessageSink::GetNextSink
        */
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }

        }
    
        /*
        *   This class just implements the CallBack sink we provide to 
        *   intercept the callback of an Async out-call. The CallBack sink
        *   ensures that arbitrary threads do not enter our Synchronization
        *   Domain without asking us if it is Ok!
        */
        internal class AsyncReplySink : IMessageSink
        {
            internal IMessageSink _nextSink;
            internal SynchronizationAttribute _property;
            internal AsyncReplySink(IMessageSink nextSink, SynchronizationAttribute prop)
            {
                _nextSink = nextSink;
                _property = prop;
            }
    
            public virtual IMessage SyncProcessMessage(IMessage reqMsg)
            {
                
                // We handle this as a regular new Sync workItem
                // 1. Create a work item 
                WorkItem work = new WorkItem(reqMsg,
                                            _nextSink,
                                            null /* replySink */);
    
                // 2. Notify the property to handle the WorkItem
                // The work item may get put in a Queue or may execute right away.
                _property.HandleWorkRequest(work);

                if (!_property.IsReEntrant)
                {
                    // Remove the async lcid we had added to the call out list.
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: InterceptionSink::SyncPM Removing async call-out lcid: " + ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey]).RemotingData.LogicalCallID);                   
                    _property.AsyncCallOutLCIDList.Remove(
                        ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey]).RemotingData.LogicalCallID);
                }
    
                // 3. Pick up retMsg from the WorkItem and return
                return work.ReplyMessage;                    
            }
    
            public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
            {
                throw new NotSupportedException();
            }
    
            /*
            * Implements IMessageSink::GetNextSink
            */
            public IMessageSink NextSink
            {
                get
                {
                    return _nextSink;
                }
            }
        }   
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingsurrogateselector.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// comments

namespace System.Runtime.Remoting.Messaging {

    using System;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Reflection;
    using System.Threading;
    using System.Globalization;
    using System.Collections;
    using System.Security.Permissions;	
    /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="MessageSurrogateFilter"]/*' />
    public delegate bool MessageSurrogateFilter(String key, Object value);

    /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    [SecurityPermissionAttribute(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class RemotingSurrogateSelector : ISurrogateSelector
    {
        // Private static data
        private static Type s_IMethodCallMessageType = typeof(IMethodCallMessage);
        private static Type s_IMethodReturnMessageType = typeof(IMethodReturnMessage);
        private static Type s_ObjRefType = typeof(ObjRef);

        // Private member data
        private Object _rootObj = null;    
        private ISurrogateSelector _next = null;
        private RemotingSurrogate  _remotingSurrogate = new RemotingSurrogate();
        private ObjRefSurrogate _objRefSurrogate = new ObjRefSurrogate();
        private ISerializationSurrogate _messageSurrogate  = null;
        private MessageSurrogateFilter _filter = null;

        
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.RemotingSurrogateSelector"]/*' />
        public RemotingSurrogateSelector()
        {
            _messageSurrogate = new MessageSurrogate(this);
        }

        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.Filter"]/*' />
        public MessageSurrogateFilter Filter
        {
            set { _filter = value; }
            get { return _filter; }
        }

        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.SetRootObject"]/*' />
        public void SetRootObject(Object obj)
        {
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }
            _rootObj = obj;
            SoapMessageSurrogate soapMsg = _messageSurrogate as SoapMessageSurrogate;
            if (null != soapMsg)
            {
                soapMsg.SetRootObject(_rootObj);
            }
        }
        
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.GetRootObject"]/*' />
        public Object GetRootObject()
        {
            return _rootObj;
        }
    
        // Specifies the next ISurrogateSelector to be examined for surrogates if the current
        // instance doesn't have a surrogate for the given type and assembly in the given context.
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.ChainSelector"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void ChainSelector(ISurrogateSelector selector) {_next = selector;}
    
        // Returns the appropriate surrogate for the given type in the given context.
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.GetSurrogate"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector ssout)
        {        
            if (type == null)
            {
                throw new ArgumentNullException("type");
            }
    
            Message.DebugOut("Entered  GetSurrogate for " + type.FullName + "\n");
    
            if (type.IsMarshalByRef)
            {
                Message.DebugOut("Selected surrogate for " + type.FullName);
                ssout = this;
                return _remotingSurrogate;
            }
            else if (s_IMethodCallMessageType.IsAssignableFrom(type) ||
                     s_IMethodReturnMessageType.IsAssignableFrom(type))
            {
                ssout = this;
                return _messageSurrogate;
            }
            else if (s_ObjRefType.IsAssignableFrom(type))
            {
                ssout = this;
                return _objRefSurrogate;
            }
            else if (_next != null)
            {
                return _next.GetSurrogate(type, context, out ssout);
            }
            else 
            {
                ssout = null;
                return null;
            }
          
        } // GetSurrogate
    
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.GetNextSelector"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual ISurrogateSelector GetNextSelector() { return _next;}
    
        /// <include file='doc\RemotingSurrogateSelector.uex' path='docs/doc[@for="RemotingSurrogateSelector.UseSoapFormat"]/*' />
        public virtual void UseSoapFormat()
        {
            _messageSurrogate = new SoapMessageSurrogate(this);
            ((SoapMessageSurrogate)_messageSurrogate).SetRootObject(_rootObj);
        }
    }
    
    internal class RemotingSurrogate : ISerializationSurrogate
    {
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void GetObjectData(Object obj, SerializationInfo info, StreamingContext context)
        {               
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }
            
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            //
            // This code is to special case marshalling types inheriting from RemotingClientProxy
            // Check whether type inherits from RemotingClientProxy and serialize the correct ObjRef
            // after getting the correct proxy to the actual server object
            //
                
            Message.DebugOut("RemotingSurrogate::GetObjectData obj.Type: " + obj.GetType().FullName + " \n");
            if(RemotingServices.IsTransparentProxy(obj))
            {
                RealProxy rp = RemotingServices.GetRealProxy(obj);
                rp.GetObjectData(info, context);
            }
            else
            {
                    RemotingServices.GetObjectData(obj, info, context);
            }
        }


	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual Object  SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
        { 
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_PopulateData"));
        }

    } // class RemotingSurrogate


    internal class ObjRefSurrogate : ISerializationSurrogate
    {    
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void GetObjectData(Object obj, SerializationInfo info, StreamingContext context)
        {               
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }
            
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            //
            // This code is to provide special handling for ObjRef's that are supposed
            //   to be passed as parameters.
            //
                
            ((ObjRef)obj).GetObjectData(info, context);
            // add flag indicating the ObjRef was passed as a parameter
            info.AddValue("fIsMarshalled", 0);            
        } // GetObjectData

	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual Object  SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
        { 
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_PopulateData"));
        }

    } // class ObjRefSurrogate
    
    
    internal class SoapMessageSurrogate : ISerializationSurrogate
    {
        // Private static data
        private static Type _voidType = typeof(void);
        private static Type _soapFaultType = typeof(SoapFault);

        // Member data
        String DefaultFakeRecordAssemblyName = "http://schemas.microsoft.com/urt/SystemRemotingSoapTopRecord";
        Object _rootObj = null;
        RemotingSurrogateSelector _ss;

        internal SoapMessageSurrogate(RemotingSurrogateSelector ss)
        {
            _ss = ss;
        }

        internal void SetRootObject(Object obj)
        {
            _rootObj = obj;
        }

        internal virtual String[] GetInArgNames(IMethodCallMessage m, int c)
        {
            String[] names = new String[c];
            for (int i = 0; i < c; i++)
            {
                String name = m.GetInArgName(i);
                if (name == null)
                {
                    name = "__param" + i;
                }
                names[i] = name;
            }
            return names;
        }
       
        internal virtual String[] GetNames(IMethodCallMessage m, int c)
        {
            String[] names = new String[c];
            for (int i = 0; i < c; i++)
            {
                String name = m.GetArgName(i);
                if (name == null)
                {
                    name = "__param" + i;
                }
                names[i] = name;
            }
            return names;
        }
    
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void GetObjectData(Object obj, SerializationInfo info, StreamingContext context)
        {
            if (info==null) 
            {
               throw new ArgumentNullException("info");
            }
                        
            if ( (obj!=null) && (obj !=_rootObj))
            {
                (new MessageSurrogate(_ss)).GetObjectData(obj, info, context);
            }
            else 
            {
                IMethodReturnMessage msg = obj as IMethodReturnMessage;
                if(null != msg)
                {

                    if (msg.Exception == null)
                    {
                        String responseElementName;
                        String responseElementNS;
                        String returnElementName;                    

                        // obtain response element name namespace
                        MethodBase mb = msg.MethodBase;
                        SoapMethodAttribute attr = (SoapMethodAttribute)InternalRemotingServices.GetCachedSoapAttribute(mb);
                        responseElementName = attr.ResponseXmlElementName;
                        responseElementNS = attr.ResponseXmlNamespace;
                        returnElementName = attr.ReturnXmlElementName;

                        ArgMapper mapper = new ArgMapper(msg, true /*fOut*/);
                        Object[] args = mapper.Args;
                        info.FullTypeName = responseElementName;
                        info.AssemblyName = responseElementNS;
                        Type retType = ((MethodInfo)mb).ReturnType;                                         
                        if (!((retType == null) || (retType == _voidType)))
                        {
                            info.AddValue(returnElementName, msg.ReturnValue, retType);
                        }
                        if (args != null)
                        {
                            Type[] types = mapper.ArgTypes;
                            for (int i=0; i<args.Length; i++)
                            {
                                String name;
                                name = mapper.GetArgName(i);
                                if ((name == null) || (name.Length == 0))
                                {
                                    name = "__param" + i;
                                }
                                info.AddValue(
                                        name, 
                                        args[i], 
                                        types[i].IsByRef?
                                            types[i].GetElementType():types[i]);
                            }
                        }
                    }
                    else
                    {
                        Object oClientIsClr = CallContext.GetData("__ClientIsClr");
                        bool bClientIsClr = (oClientIsClr == null) ? true:(bool)oClientIsClr;
                        info.FullTypeName = "FormatterWrapper";
                        info.AssemblyName = DefaultFakeRecordAssemblyName;

                        Exception ex = msg.Exception;
                        StringBuilder sb = new StringBuilder();
                        bool bMustUnderstandError = false;
                        while(ex != null)
                        {
                            if (ex.Message.StartsWith("MustUnderstand"))
                                bMustUnderstandError = true;

                            sb.Append(" **** ");
                            sb.Append(ex.GetType().FullName); 
                            sb.Append(" - ");
                            sb.Append(ex.Message);
                            
                            ex = ex.InnerException;
                        }

                        ServerFault serverFault = null;
                        if (bClientIsClr)
                            serverFault = new ServerFault(msg.Exception); // Clr is the Client use full exception
                        else
                            serverFault = new ServerFault(msg.Exception.GetType().AssemblyQualifiedName, sb.ToString(), msg.Exception.StackTrace); 

                        String faultType = "Server";
                        if (bMustUnderstandError)
                            faultType = "MustUnderstand";

                        SoapFault soapFault = new SoapFault(faultType, sb.ToString(), null, serverFault);
                        info.AddValue("__WrappedObject", soapFault, _soapFaultType);                   
                    }
                }
                else
                {

                    IMethodCallMessage mcm = (IMethodCallMessage)obj;

                    // obtain method namespace        
                    MethodBase mb = mcm.MethodBase;                
                    String methodElementNS = SoapServices.GetXmlNamespaceForMethodCall(mb);       

                    Object[] args = mcm.InArgs;
                    String[] names = GetInArgNames(mcm, args.Length);
                    Type[] sig = (Type[])mcm.MethodSignature;
                    info.FullTypeName = mcm.MethodName;
                    info.AssemblyName = methodElementNS;
                    RemotingMethodCachedData cache = (RemotingMethodCachedData)InternalRemotingServices.GetReflectionCachedData(mb);
                    int[] requestArgMap = cache.MarshalRequestArgMap;


                    BCLDebug.Assert(
                        args!=null || sig.Length == args.Length, 
                        "Signature mismatch");

                    for (int i = 0; i < args.Length; i++)
                    {
                        String paramName = null;
                        if ((names[i] == null) || (names[i].Length == 0))
                            paramName = "__param" + i;
                        else
                            paramName = names[i];

                        int sigPosition = requestArgMap[i];
                        Type argType = null;

                        if (sig[sigPosition].IsByRef)
                            argType = sig[sigPosition].GetElementType();
                        else
                            argType = sig[sigPosition];

                        info.AddValue(paramName, args[i], argType);
                    }
                }
            }
        } // GetObjectData
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual Object  SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
        { 
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_PopulateData"));
        }

    }
    
    internal class MessageSurrogate : ISerializationSurrogate
    {
        // Private static data
        private static Type _constructionCallType = typeof(ConstructionCall);
        private static Type _methodCallType = typeof(MethodCall);
        private static Type _constructionResponseType = typeof(ConstructionResponse);
        private static Type _methodResponseType = typeof(MethodResponse);
        private static Type _exceptionType = typeof(Exception);
        private static Type _objectType = typeof(Object);

        // Private static member data
        private RemotingSurrogateSelector _ss;

        internal MessageSurrogate(RemotingSurrogateSelector ss)
        {
            _ss = ss;
        }
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual void GetObjectData(Object obj, SerializationInfo info, StreamingContext context)
        {
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }

            if (info==null) {
                throw new ArgumentNullException("info");
            }

            bool returnMessage = false;
            bool constructionMessage = false;
            IMethodMessage msg = obj as IMethodMessage;
            if (null != msg)
            {
                IDictionaryEnumerator de = msg.Properties.GetEnumerator();
                if (msg is IMethodCallMessage) 
                {
                    if (obj is IConstructionCallMessage)
                        constructionMessage = true;
                    info.SetType(constructionMessage ? _constructionCallType : _methodCallType);
                }
                else 
                {
                    IMethodReturnMessage mrm = msg as IMethodReturnMessage;
                    if (null != mrm)
                    {
                        returnMessage = true;
                        info.SetType((obj is IConstructionReturnMessage) ? _constructionResponseType : _methodResponseType);
                        if (((IMethodReturnMessage)msg).Exception != null)
                        {
                            info.AddValue("__fault",((IMethodReturnMessage)msg).Exception, _exceptionType);
                        }
                            
                    }
                    else 
                    {
                        throw new RemotingException(Environment.GetResourceString("Remoting_InvalidMsg"));                
                    }
                }
                    
                while (de.MoveNext()) {
                    if ((obj == _ss.GetRootObject()) && (_ss.Filter != null) && _ss.Filter((String)de.Key, de.Value))
                        continue;

                    if (de.Value!=null) {

                        String key = de.Key.ToString();
                        if (key.Equals("__CallContext"))
                        {
                            // If the CallContext has only the call Id, then there is no need to put the entire 
                            // LogicalCallContext type on the wire
                            LogicalCallContext lcc = (LogicalCallContext)de.Value;
                            if (lcc.HasInfo)
                                info.AddValue(key, lcc);
                            else
                                info.AddValue(key, lcc.RemotingData.LogicalCallID);                        
                        }
                        else if (key.Equals("__MethodSignature"))
                        {
                            // If the method is not overloaded, the method signature does not need to go on the wire
                            // note - IsMethodOverloaded does not work well with constructors
                            if (constructionMessage || RemotingServices.IsMethodOverloaded(msg))
                            {
                                info.AddValue(key, de.Value);
                                continue;
                            }
                            Message.DebugOut("MessageSurrogate::GetObjectData. Method not overloaded, so no MethodSignature \n");
                        }
                        else 
                        {
                            /* If the streaming context says this is a x-domain call, then there is no
                                need to include the following fields in the return message. Right now I am not sure 
                                how to identify a cross-domain streaming context - Ashok 
                            */
                            /*
                            if (returnMessage && 
                                    (key.Equals("__Uri") ||
                                     key.Equals("__MethodName") ||
                                     key.Equals("__TypeName")))
                                     continue;                                     
                            else
                            */
                                returnMessage = returnMessage;
                                info.AddValue(key, de.Value);
                        }

                    } else {
                        info.AddValue(de.Key.ToString(), de.Value, _objectType);
                    }
                }
            }
            else
            {
                throw new RemotingException(Environment.GetResourceString("Remoting_InvalidMsg"));
            }
    
        }
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        public virtual Object  SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
        { 
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_PopulateData"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\stackbuildersink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StackBuilderSink.cs
**
** Author:  Matt Smith
**
** Purpose: Terminating sink which will build a stack and 
**          make a method call on an object
**
** Date:    Apr 10, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Messaging {
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Metadata;
    using System.Reflection;
	using System.Runtime.CompilerServices;
	using System.Security.Principal;
    /* Assembly Access */
    using System;

    [Serializable]
    internal class StackBuilderSink : IMessageSink
    {

        //+============================================================
        //
        // Method:     Constructor, public
        //
        // Synopsis:   Store server object
        //
        // History:    06-May-1999  MattSmit   Created
        //-============================================================
        public StackBuilderSink(MarshalByRefObject server)
        {
            _server = server;
        }
        public StackBuilderSink(Object server)
        {
            _server = server;
            if (_server==null)
            {
                _bStatic = true;
            }
        }

        public virtual IMessage SyncProcessMessage(IMessage msg)
        {
            return SyncProcessMessage(msg, 0, false);
        }

        internal virtual IMessage SyncProcessMessage(IMessage msg, int methodPtr, bool fExecuteInContext) 
        { 
            // Validate message here 
            IMessage errMsg = InternalSink.ValidateMessage(msg);        
            if (errMsg != null)
            {
                return errMsg;
            }

            IMethodCallMessage mcMsg = msg as IMethodCallMessage;            

            IMessage retMessage;
            LogicalCallContext oldCallCtx = null;
            bool isCallContextSet = false;
            try
            {
                Object server = _server;

                BCLDebug.Assert((server!=null) == (!_bStatic),
                                "Invalid state in stackbuilder sink?");

                // validate the method base if necessary
                VerifyIsOkToCallMethod(server, mcMsg);
                
                // install call context onto the thread, holding onto
                // the one that is currently on the thread
   
                LogicalCallContext messageCallContext = null;
                if (mcMsg != null)
                {
                    messageCallContext = mcMsg.LogicalCallContext;                    
                }
                else
                {
                    messageCallContext = (LogicalCallContext)msg.Properties["__CallContext"];
                }
                                
                oldCallCtx = CallContext.SetLogicalCallContext(messageCallContext);
                isCallContextSet = true;
                messageCallContext.PropagateIncomingHeadersToCallContext(msg);

                PreserveThreadPrincipalIfNecessary(messageCallContext, oldCallCtx);
                

                // NOTE: target for dispatch will be NULL when the StackBuilderSink
                // is used for async delegates on static methods.

                RemotingServices.LogRemotingStage(RemotingServices.SERVER_MSG_STACK_BUILD);

                // *** NOTE ***
                // Although we always pass _server to these calls in the EE,
                // when we execute using Message::Dispatch we are using TP as 
                // the this-ptr ... (what the call site thinks is the this-ptr)
                // when we execute using StackBuilderSink::PrivatePM we use
                // _server as the this-ptr (which could be different if there
                // is interception for strictly MBR types in the same AD).
                // ************
                if (IsOKToStackBlt(mcMsg, server) 
                    && ((Message)mcMsg).Dispatch(server, fExecuteInContext))
                {
                    //retMessage = StackBasedReturnMessage.GetObjectFromPool((Message)mcMsg);
                    retMessage = new StackBasedReturnMessage();
                    ((StackBasedReturnMessage)retMessage).InitFields((Message)mcMsg);

                    // call context could be different then the one from before the call.
                    LogicalCallContext latestCallContext = CallContext.GetLogicalCallContext();
                    // retrieve outgoing response headers
                    latestCallContext.PropagateOutgoingHeadersToMessage(retMessage);
                    
                    // Install call context back into Message (from the thread)
                    ((StackBasedReturnMessage)retMessage).SetLogicalCallContext(latestCallContext);
                } 
                else
                {
                    MethodBase mb = GetMethodBase(mcMsg); 
                    Object[] outArgs = null;
                    Object ret = null;                      
                    
                    RemotingMethodCachedData methodCache = 
                        InternalRemotingServices.GetReflectionCachedData(mb);

                    Message.DebugOut("StackBuilderSink::Calling PrivateProcessMessage\n");

                    Object[] args = Message.CoerceArgs(mcMsg, methodCache.Parameters);
                
                    ret = PrivateProcessMessage(
                                        mb,
                                        args,
                                        server,
                                        methodPtr,
                                        fExecuteInContext,
                                        out outArgs); 
                    CopyNonByrefOutArgsFromOriginalArgs(methodCache, args, ref outArgs);


                    // call context could be different then the one from before the call.
                    LogicalCallContext latestCallContext = CallContext.GetLogicalCallContext();

                    retMessage = new ReturnMessage( 
                                        ret, 
                                        outArgs, 
                                        (outArgs == null ? 0 : outArgs.Length),
                                        latestCallContext,
                                        mcMsg);

                    // retrieve outgoing response headers
                    latestCallContext.PropagateOutgoingHeadersToMessage(retMessage);
                }

                // restore the call context on the thread
                CallContext.SetLogicalCallContext(oldCallCtx);

            } catch (Exception e)
            {
                Message.DebugOut(
                "StackBuilderSink::The server object probably threw an exception " +
                                 e.Message + e.StackTrace + "\n" );
                retMessage = new ReturnMessage(e, mcMsg);
                ((ReturnMessage)retMessage).SetLogicalCallContext(mcMsg.LogicalCallContext);

                if (isCallContextSet)
                    CallContext.SetLogicalCallContext(oldCallCtx);
            }


            RemotingServices.LogRemotingStage(RemotingServices.SERVER_RET_SINK_CHAIN);
            return retMessage;
        }

        public virtual IMessageCtrl AsyncProcessMessage(
            IMessage msg, IMessageSink replySink) 
        { 
            IMethodCallMessage mcMsg = (IMethodCallMessage)msg;

            IMessageCtrl retCtrl = null;
            IMessage retMessage = null;
            LogicalCallContext oldCallCtx = null;
            bool isCallContextSet = false;
            try
            {
                LogicalCallContext callCtx =  (LogicalCallContext)
                    mcMsg.Properties[Message.CallContextKey];
                    
                Object server = _server;

                // validate the method base if necessary
                VerifyIsOkToCallMethod(server, mcMsg);
                
                // install call context onto the thread, holding onto
                // the one that is currently on the thread

                oldCallCtx = CallContext.SetLogicalCallContext(callCtx);
                isCallContextSet = true;
                // retrieve incoming headers
                callCtx.PropagateIncomingHeadersToCallContext(msg);

                PreserveThreadPrincipalIfNecessary(callCtx, oldCallCtx);

                // see if this is a server message that was dispatched asynchronously
                ServerChannelSinkStack sinkStack = 
                    msg.Properties["__SinkStack"] as ServerChannelSinkStack;
                if (sinkStack != null)
                    sinkStack.ServerObject = server;
                
                BCLDebug.Assert((server!=null)==(!_bStatic),
                                "Invalid state in stackbuilder sink?");                               

                MethodBase mb = GetMethodBase(mcMsg); 
                Object[] outArgs = null;
                Object ret = null;                
                RemotingMethodCachedData methodCache = 
                    InternalRemotingServices.GetReflectionCachedData(mb);
                Object[] args = Message.CoerceArgs(mcMsg, methodCache.Parameters);

                ret = PrivateProcessMessage(mb,
                                            args,
                                            server,
                                            0,
                                            false,
                                            out outArgs);
                CopyNonByrefOutArgsFromOriginalArgs(methodCache, args, ref outArgs);
                                                       
                if(replySink != null)
                {     
                    // call context could be different then the one from before the call.
                    LogicalCallContext latestCallContext = CallContext.GetLogicalCallContext();
                    
                    retMessage = new ReturnMessage(
                                        ret, 
                                        outArgs, 
                                        (outArgs == null ? 0 : outArgs.Length), 
                                        latestCallContext, 
                                        mcMsg);

                    // retrieve outgoing response headers
                    latestCallContext.PropagateOutgoingHeadersToMessage(retMessage);
    
                    replySink.SyncProcessMessage(retMessage);
                }
            } 
            catch (Exception e)
            {
                try
                {
                    if(replySink != null)
                    {
                        retMessage = new ReturnMessage(e, mcMsg);
                        ((ReturnMessage)retMessage).SetLogicalCallContext(
                                (LogicalCallContext)
                                    mcMsg.Properties[Message.CallContextKey]);

                        replySink.SyncProcessMessage(retMessage);
                    }
                }
                catch(Exception )
                {
                    // Fatal error..  can't do anything ..
                    // bail out silently.
                }
            }
            finally
            {
                // restore the call context on the thread
                if (isCallContextSet)
                    CallContext.SetLogicalCallContext(oldCallCtx);
            }

            return retCtrl; 
        } // AsyncProcessMessage
        

        public IMessageSink NextSink
        {
            get
            {
                // there is no nextSink for the StackBuilderSink
                return null;
            }
        }

        // This check if the call-site on the TP is in our own AD
        // It also handles the special case where the TP is on 
        // a well-known object and we cannot do stack-blting
        internal bool IsOKToStackBlt(IMethodMessage mcMsg, Object server)
        {
            bool bOK = false;
            Message msg = mcMsg as Message;
            if(null != msg)
            {
                IInternalMessage iiMsg = (IInternalMessage) msg;
 
                // If there is a frame in the message we can always
                // Blt it (provided it is not a proxy to a well-known
                // object in our own appDomain)!
                // The GetThisPtr == server test allows for people to wrap
                // our proxy with their own interception .. in that case
                // we should not blt the stack.
                if (msg.GetFramePtr() != IntPtr.Zero
                    && msg.GetThisPtr() == server
                    && 
                    (   iiMsg.IdentityObject == null ||
                        (  iiMsg.IdentityObject != null 
                            && iiMsg.IdentityObject == iiMsg.ServerIdentityObject
                        )
                    )
                )
                {
                    bOK = true;
                }
            }

            return bOK;
        }
        
        private static MethodBase GetMethodBase(IMethodMessage msg)
        {
            MethodBase mb = msg.MethodBase;
            if(null == mb)      
            {
                BCLDebug.Trace("REMOTE", "Method missing w/name ", msg.MethodName);
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Message_MethodMissing"),
                            msg.MethodName,
                            msg.TypeName));
            }
                    
            return mb;
        }

        private static void VerifyIsOkToCallMethod(Object server, IMethodMessage msg)
        {
            bool bTypeChecked = false;
            MarshalByRefObject mbr = server as MarshalByRefObject;
            if (mbr != null)
            {
                bool fServer;
                Identity id = MarshalByRefObject.GetIdentity(mbr, out fServer);
                if (id != null)
                {
                    ServerIdentity srvId = id as ServerIdentity;
                    if ((srvId != null) && srvId.MarshaledAsSpecificType)
                    {
                        Type srvType = srvId.ServerType;
                        if (srvType != null)
                        {
                            MethodBase mb = GetMethodBase(msg);
                            Type declaringType = mb.DeclaringType;
                        
                            // make sure that srvType is not more restrictive than method base
                            // (i.e. someone marshaled with a specific type or interface exposed)
                            if ((declaringType != srvType) &&
                                !declaringType.IsAssignableFrom(srvType))
                            {
                                throw new RemotingException(
                                    String.Format(
                                        Environment.GetResourceString("Remoting_InvalidCallingType"),
                                        mb.DeclaringType.FullName, srvType.FullName));
                                    
                            }
                            // Set flag so we don't repeat this work below.
                            if (declaringType.IsInterface)
                            {
                                VerifyNotIRemoteDispatch(declaringType);
                            }    
                            bTypeChecked = true;
                        }
                    }
                }

                // We must always verify that the type corresponding to 
                // the method being invoked is compatible with the real server 
                // type.
                if (!bTypeChecked)
                {
                    MethodBase mb = GetMethodBase(msg); 
                    Type reflectedType = mb.ReflectedType;
                    if (!reflectedType.IsInterface)
                    {
                        if (!reflectedType.IsInstanceOfType(mbr))
                        {
                            throw new RemotingException(
                                String.Format(
                                    Environment.GetResourceString("Remoting_InvalidCallingType"),
                                    reflectedType.FullName, 
                                    mbr.GetType().FullName));
                        }
                    }
                    // This code prohibits calls made to System.EnterpriseServices.IRemoteDispatch
                    // so that remote call cannot bypass lowFilterLevel logic in the serializers.
                    // This special casing should be removed in the future
                    else
                    {
                        VerifyNotIRemoteDispatch(reflectedType);
                    }
                }
            }            

        } // VerifyIsOkToCallMethod

        // This code prohibits calls made to System.EnterpriseServices.IRemoteDispatch
        // so that remote call cannot bypass lowFilterLevel logic in the serializers.
        // This special casing should be removed in the future
        // Check whether we are calling IRemoteDispatch
        private static void VerifyNotIRemoteDispatch(Type reflectedType)
        {
            if(reflectedType.FullName.Equals(sIRemoteDispatch) && 
               reflectedType.Module.Assembly.nGetSimpleName().Equals(sIRemoteDispatchAssembly))
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_CantInvokeIRemoteDispatch"));
            }
        }
        
        // copies references of non-byref [In, Out] args from the input args to
        //   the output args array.
        internal void CopyNonByrefOutArgsFromOriginalArgs(RemotingMethodCachedData methodCache,
                                                         Object[] args,
                                                         ref Object[] marshalResponseArgs)
        {            
            int[] map = methodCache.NonRefOutArgMap;
            if (map.Length > 0)
            {
                if (marshalResponseArgs == null)
                    marshalResponseArgs = new Object[methodCache.Parameters.Length];
                
                foreach (int pos in map)
                {
                    marshalResponseArgs[pos] = args[pos];
                }
            }
        }


        // For the incoming call, we sometimes need to preserve the thread principal from
        //   the executing thread, instead of blindly bashing it with the one from the message.
        //   For instance, in cross process calls, the principal will always be null
        //   in the incoming message. However, when we are hosted in ASP.Net, ASP.Net will handle
        //   authentication and set up the thread principal. We should dispatch the call
        //   using the identity that it set up.
        internal static void PreserveThreadPrincipalIfNecessary(
            LogicalCallContext messageCallContext, 
            LogicalCallContext threadCallContext)
        {
            BCLDebug.Assert(messageCallContext != null, "message should always have a call context");

            if (threadCallContext != null)
            {
                if (messageCallContext.Principal == null)
                {                
                    IPrincipal currentPrincipal = threadCallContext.Principal;
                    if (currentPrincipal != null)
                    {
                        messageCallContext.Principal = currentPrincipal;
                    }
                }
            }
        } // PreserveThreadPrincipalIfNecessary


        internal Object ServerObject
        {
            get { return _server; }
        }
        
        
        //+============================================================
        //
        // Method:     PrivateProcessMessage, public
        //
        // Synopsis:   does the actual work of building the stack, 
        //             finding the correct code address and calling it.
        //
        // History:    06-May-1999  MattSmit   Created
        //-============================================================
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public extern Object  PrivateProcessMessage(
            MethodBase   mb, Object[] args, Object server, int methodPtr,
            bool fExecuteInContext, out Object[] outArgs);

        private Object _server;              // target object
        private static string sIRemoteDispatch = "System.EnterpriseServices.IRemoteDispatch";
        private static string sIRemoteDispatchAssembly = "System.EnterpriseServices";

        bool _bStatic;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemotingProxy.cool
**
** Author:  Tarun Anand (TarunA)
**
** Purpose: Defines the general purpose remoting proxy
**
** Date:    May 12, 1999
**
===========================================================*/
namespace System.Runtime.Remoting.Proxies {
    using System.Threading;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Channels;
    using System;
    using MethodInfo = System.Reflection.MethodInfo;
    using MethodBase = System.Reflection.MethodBase;
    // Remoting proxy
    internal class RemotingProxy : RealProxy, IRemotingTypeInfo 
    {
        // Static Fields
        private static MethodInfo _getTypeMethod = typeof(System.Object).GetMethod("GetType");
        private static MethodInfo _getHashCodeMethod = typeof(System.Object).GetMethod("GetHashCode");

        private static Type s_typeofObject = typeof(System.Object);
        private static Type s_typeofMarshalByRefObject = typeof(System.MarshalByRefObject);



        //*******************WARNING******************************************
        // If you change the names of these fields then change the corresponding
        // names in remoting.cpp 
        //********************************************************************
        private ConstructorCallMessage _ccm;
        private int _ctorThread;
            

        // Constructor
        public RemotingProxy(Type serverType)        
        : base(serverType) 
        {
        }

        private RemotingProxy()
        {
            // Prevent anyone from creating a blank instance of a proxy
            // without the underlying server type
        }

        internal int CtorThread
        {
            get
            {
                return _ctorThread;
            }
            set
            {
                //NOTE : the assert below is correct for activated objects. 
                //But for a connected object (where new XXX() does a Connect()
                //the InternalActivate codepath may execute twice .. since
                //we would be returning the same proxy for multiple calls to
                //new XXX() & JIT would try to execute the default .ctor on
                //the returned proxy. 
                
                //BCLDebug.Assert(_ctorThread == 0, "ctorThread already set??");
                _ctorThread = value;
            }
        }

        // This is used when a TP is called with SyncProcessMessage
        internal static IMessage CallProcessMessage(IMessageSink ms, 
                                                    IMessage reqMsg, 
                                                    ArrayWithSize proxySinks,
                                                    Thread currentThread,
                                                    Context currentContext,
                                                    bool bSkippingContextChain)
        {                   
            // Notify Dynamic Sinks: CALL starting          
            if (proxySinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                            reqMsg, 
                                            proxySinks, 
                                            true,   // bCliSide
                                            true,   // bStart
                                            false); // bAsync
            }

            RemotingServices.LogRemotingStage(RemotingServices.CLIENT_MSG_SINK_CHAIN);            

            bool bHasDynamicSinks = false;
            if (bSkippingContextChain)
            {
                // this would have been done in the client context terminator sink
                bHasDynamicSinks = 
                    currentContext.NotifyDynamicSinks(reqMsg, 
                        true,   // bCliSide
                        true,   // bStart
                        false,  // bAsync
                        true);  // bNotifyGlobals 
   
                ChannelServices.NotifyProfiler(reqMsg, RemotingProfilerEvent.ClientSend);
            }
            
            if (ms == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Proxy_NoChannelSink"));                    
            }

            IMessage retMsg = ms.SyncProcessMessage(reqMsg);

            if (bSkippingContextChain)
            {
                // this would have been done in the client context terminator sink
                ChannelServices.NotifyProfiler(retMsg, RemotingProfilerEvent.ClientReceive);

                if (bHasDynamicSinks)
                {
                    currentContext.NotifyDynamicSinks(
                        retMsg, 
                        true,   // bCliSide
                        false,   // bStart
                        false,  // bAsync
                        true);  // bNotifyGlobals  
                }
            }            

            IMethodReturnMessage mrm = retMsg as IMethodReturnMessage;
            if (retMsg == null || mrm == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Message_BadType"));                    
            }

            // notify DynamicSinks: CALL returned
            if (proxySinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                            retMsg, 
                                            proxySinks, 
                                            true,   // bCliSide
                                            false,  // bStart
                                            false); // bAsync
            }

           
            RemotingServices.LogRemotingStage(RemotingServices.CLIENT_RET_PROPAGATION);

            return retMsg;
        }

        // Implement Invoke
        public override IMessage Invoke(IMessage reqMsg) 
        {
            // Dispatch based on whether its a constructor call
            // or a method call

            IConstructionCallMessage ccm = reqMsg as IConstructionCallMessage;        
            
            if(ccm != null)
            {
                // Activate
                return InternalActivate(ccm);
            }
            else
            {
                // Handle regular method calls

                // Check that the initialization has completed
                if(!Initialized)
                {
                    // This covers the case where an object may call out
                    // on another object passing its "this" pointer during its
                    // .ctor. 
                    // The other object attempting to call on the this pointer
                    // (in x-context case) would be calling on a proxy not
                    // marked fully initialized. 
                    // FUTURE: may be allow all threads to get through. If an
                    // object has been intrepid enough to pass its this pointer
                    // around during construction it better be prepared!

                    // Let the original constructor thread go through but 
                    // throw for other threads. 
                    if (CtorThread == Thread.CurrentThread.GetHashCode())
                    {
                        ServerIdentity srvId = IdentityObject as ServerIdentity;
                        BCLDebug.Assert(
                            srvId != null
                            && 
                            ((ServerIdentity)IdentityObject).ServerContext != null,
                            "Wrap may associate with wrong context!");

                        // If we are here, the server object passed itself 
                        // out to another x-context object during the .ctor
                        // That guy is calling us back. Let us call Wrap() 
                        // earlier than usual so that envoy & channel sinks
                        // get set up!
                        // FUTURE: there is a note in CreateEnvoyAndChannelSinks
                        // related to creating an EnvoyChain from the wrong
                        // context which may hurt here too because we are
                        // definitely not in the object's home context.
                        RemotingServices.Wrap( 
                            (ContextBoundObject) this.UnwrappedServerObject);

                    }
                    else
                    {
                        // Throw an exception to indicate that we are 
                        // calling on a proxy while the constructor call 
                        // is still running.
                        throw new RemotingException(Environment.GetResourceString("Remoting_Proxy_InvalidCall"));
                    }
                    
                }
                
                // Dispatch
                int callType = Message.Sync;
                Message msg = reqMsg as Message;
                if (msg != null)
                {
                    callType = msg.GetCallType(); 
                }                
                
                return InternalInvoke((IMethodCallMessage)reqMsg, false, callType);
            }
            
        } // Invoke
        

        // This is called for all remoted calls on a TP except Ctors
        // The method called may be Sync, Async or OneWay(special case of Async)
        // In the Async case we come here for both BeginInvoke & EndInvoke
        internal virtual IMessage InternalInvoke(
            IMethodCallMessage reqMcmMsg, bool useDispatchMessage, int callType)
        {
            Message reqMsg = reqMcmMsg as Message;            
            if ((reqMsg == null) && (callType != Message.Sync))
            {
                // Only the synchronous call type is supported for messages that
                //   aren't of type Message.               
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Proxy_InvalidCallType"));
            }
        
            IMessage retMsg = null;
            Thread currentThread = Thread.CurrentThread;

            // pick up call context from the thread
            LogicalCallContext cctx = currentThread.GetLogicalCallContext();

            Identity idObj = IdentityObject;
            ServerIdentity serverID = idObj as ServerIdentity;
            if ((null != serverID) && idObj.IsFullyDisconnected())
            {
                throw new ArgumentException(
                   String.Format(Environment.GetResourceString("Remoting_ServerObjectNotFound"), reqMcmMsg.Uri));
            }

            // Short-circuit calls to Object::GetType and Object::GetHashCode
            MethodBase mb = reqMcmMsg.MethodBase;
            if(_getTypeMethod == mb)
            {
                // Time to load the true type of the remote object....
                Type t = GetProxiedType();
                return new ReturnMessage(t, null, 0, cctx, reqMcmMsg);
            }

            if (_getHashCodeMethod == mb)
            {
                int hashCode = idObj.GetHashCode();
                return new ReturnMessage(hashCode, null, 0, cctx, reqMcmMsg);
            }

            // check for channel sink
            if (idObj.ChannelSink == null)
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Proxy_NoChannelSink"));
            }

            // Set the identity in the message object
            IInternalMessage iim = (IInternalMessage)reqMcmMsg;
            iim.IdentityObject = idObj;

            if (null != serverID)
            {
                Message.DebugOut("Setting serveridentity on message \n");
                iim.ServerIdentityObject = serverID;
                    
            }
            else
            {
                // We need to set the URI only for identities that 
                // are not the server identities. The uri is used to
                // dispatch methods for objects outside the appdomain.
                // Inside the appdomain (xcontext case) we dispatch 
                // by getting the server object from the server identity.
               iim.SetURI(idObj.URI);
            }       

            Message.DebugOut("InternalInvoke. Dispatching based on class type\n");
            AsyncResult ar = null;
            switch (callType)
            {
            case Message.Sync:
                Message.DebugOut("RemotingProxy.Invoke Call: SyncProcessMsg\n");
                BCLDebug.Assert(!useDispatchMessage,"!useDispatchMessage");                
                bool bSkipContextChain = false;
                Context currentContext = currentThread.GetCurrentContextInternal();
                IMessageSink nextSink = idObj.EnvoyChain;

                // if we are in the default context, there can be no 
                // client context chain, so we can skip the intermediate 
                // calls if there are no envoy sinks

                if (currentContext.IsDefaultContext)
                {
                    if (nextSink is EnvoyTerminatorSink)
                    {
                        bSkipContextChain = true;

                        // jump directly to the channel sink
                        nextSink = idObj.ChannelSink;
                    }
                }

                retMsg = CallProcessMessage(nextSink,
                                            reqMcmMsg, 
                                            idObj.ProxySideDynamicSinks,
                                            currentThread,
                                            currentContext,
                                            bSkipContextChain);

                break;

            case Message.BeginAsync:
            case Message.BeginAsync | Message.OneWay:                
                // For async calls we clone the call context from the thread
                // This is a limited clone (we dont deep copy the user data)
                cctx = (LogicalCallContext) cctx.Clone(); 
                iim.SetCallContext(cctx);  
                
                ar = new AsyncResult(reqMsg);
              
                InternalInvokeAsync(ar, reqMsg, useDispatchMessage, callType);

                Message.DebugOut("Propagate out params for BeginAsync\n");
                retMsg = new ReturnMessage(ar, null, 0, null/*cctx*/, reqMsg);
                break;

            case Message.OneWay:
                // For async calls we clone the call context from the thread
                // This is a limited clone (we dont deep copy the user data)
                cctx = (LogicalCallContext) cctx.Clone();
                iim.SetCallContext(cctx);
                InternalInvokeAsync(null, reqMsg, useDispatchMessage, callType);
                retMsg = new ReturnMessage(null, null, 0, null/*cctx*/, reqMcmMsg);
                break;

            case (Message.EndAsync | Message.OneWay):
                retMsg = new ReturnMessage(null, null, 0, null/*cctx*/, reqMcmMsg);
                break;

            case Message.EndAsync:
                // For endAsync, we merge back the returned callContext
                // into the thread's callContext
                retMsg = RealProxy.EndInvokeHelper(reqMsg, true);
                break;
            }
            
            return retMsg;
        }

        // This is called from InternalInvoke above when someone makes an
        // Async (or a one way) call on a TP
        internal void InternalInvokeAsync(IMessageSink ar,  Message reqMsg, 
            bool useDispatchMessage, int callType)
        {
            IMessageCtrl cc = null;
            Identity idObj = IdentityObject;
            ServerIdentity serverID = idObj as ServerIdentity;
            MethodCall cpyMsg= new MethodCall(reqMsg);
            IInternalMessage iim = ((IInternalMessage)cpyMsg);

            // Set the identity in the message object
            iim.IdentityObject = idObj;
            if (null != serverID)
            {
                Message.DebugOut("Setting SrvID on deser msg\n");
                iim.ServerIdentityObject = serverID;                    
            }

            if (useDispatchMessage)
            {
                Message.DebugOut(
                    "RemotingProxy.Invoke: Calling AsyncDispatchMessage\n");

                BCLDebug.Assert(ar != null,"ar != null");
                BCLDebug.Assert( (callType & Message.BeginAsync) != 0,
                                "BeginAsync flag not set!");

                Message.DebugOut("Calling AsynDispatchMessage \n");
                cc = ChannelServices.AsyncDispatchMessage(
                                        cpyMsg, 
                                        ((callType & Message.OneWay) != 0) 
                                        ? null : ar);
            }
            else if (null != idObj.EnvoyChain)
            {
                Message.DebugOut("RemotingProxy.Invoke: Calling AsyncProcessMsg on the envoy chain\n");

                cc = idObj.EnvoyChain.AsyncProcessMessage(
                                        cpyMsg, 
                                        ((callType & Message.OneWay) != 0) 
                                        ? null : ar);
            }
            else
            {
                // Channel sink cannot be null since it is the last sink in
                // the client context
                // Assert if Invoke is called without a channel sink
                BCLDebug.Assert(false, "How did we get here?");
                throw new ExecutionEngineException(
                    Environment.GetResourceString("Remoting_Proxy_InvalidState"));
            }

            if ((callType & Message.BeginAsync) != 0)
            {

                if ((callType & Message.OneWay) != 0)
                {
                    ar.SyncProcessMessage(null);
                }
            }
        }

           /// <include file='doc\remotingproxy.uex' path='docs/doc[@for="RemotingProxy.InternalActivate"]/*' />
        // New method for activators.
        
        // This gets called during remoting intercepted activation when 
        // JIT tries to run a constructor on a TP (which remoting gave it
        // in place of an actual uninitialized instance of the expected type)
        private IConstructionReturnMessage InternalActivate(IConstructionCallMessage ctorMsg)
        {
            // Remember the hashcode of the constructor thread.
            CtorThread = Thread.CurrentThread.GetHashCode();

            IConstructionReturnMessage ctorRetMsg = ActivationServices.Activate(this, ctorMsg);

            // Set the flag to indicate that the object is initialized
            // Note: this assert is not valid for WKOs
            //BCLDebug.Assert(!Initialized, "Proxy marked as initialized before activation call completed");
            Initialized = true;

            return ctorRetMsg;
        }

        // Invoke for case where call is in the same context as the server object
        // (This special static method is used for AsyncDelegate-s ... this is called
        // directly from the EE)
        private static void Invoke(Object NotUsed, ref MessageData msgData)
        {
            Message m = new Message();
            m.InitFields(msgData);

            Object thisPtr = m.GetThisPtr();
            Delegate d;
            if ((d = thisPtr as Delegate) != null)
            {
                // FUTURE: It looks like this is only working on contextbound 
                // and remoted Marshalbyref objects.  Investigate.
                RemotingProxy rp = (RemotingProxy)
                    RemotingServices.GetRealProxy(d.Target);

                if (rp != null)
                {
                    rp.InternalInvoke(m, true, m.GetCallType());
                }
                else
                {
                    int callType = m.GetCallType();
                    AsyncResult ar;
                    switch (callType)
                    {
                    case Message.BeginAsync:
                    case Message.BeginAsync | Message.OneWay:
                        // pick up call context from the thread
                        m.Properties[Message.CallContextKey] =
                            CallContext.GetLogicalCallContext().Clone();
                        ar = new AsyncResult(m);
                        AgileAsyncWorkerItem  workItem = 
                            new AgileAsyncWorkerItem(
                                    m, 
                                    ((callType & Message.OneWay) != 0) ? 
                                        null : ar, d.Target);

                        ThreadPool.QueueUserWorkItem(
                            new WaitCallback(
                                    AgileAsyncWorkerItem.ThreadPoolCallBack),
                            workItem);

                        if ((callType & Message.OneWay) != 0)
                        {
                            ar.SyncProcessMessage(null);
                        }
                        m.PropagateOutParameters(null, ar);
                        break;

                    case (Message.EndAsync | Message.OneWay):
                        return;

                    case Message.EndAsync:
                        // This will also merge back the call context
                        // onto the thread that called EndAsync
                        RealProxy.EndInvokeHelper(m, false);
                        break;
                    default:
                        BCLDebug.Assert(
                            false, 
                            "Should never be here. Sync delegate code for agile object ended up in remoting");
            break;
                    }
                }
            }
            else
            {
                // Static invoke called with incorrect this pointer ...
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Default"));                    
            }
        }
    

        internal ConstructorCallMessage ConstructorMessage
        {
            get
            {
                return _ccm;
            }

            set
            {
                _ccm = value;
            }
        }

        //
        // IRemotingTypeInfo interface
        //

        // Obtain the fully qualified name of the type that the proxy represents
        public String TypeName 
        {
            get
            {
                return GetProxiedType().FullName;
            }
            
            set
            {
                throw new NotSupportedException();
            }
        }

        // interop methods
        public override IntPtr GetCOMIUnknown(bool fIsBeingMarshalled)
        {
            IntPtr pUnk = IntPtr.Zero;
            Object otp = GetTransparentProxy();            
            bool fIsXProcess = RemotingServices.IsObjectOutOfProcess(otp);
            if (fIsXProcess)
            {
                // we are in a different process
                if (fIsBeingMarshalled)
                {
                    // we need to go to the server to get the real IUnknown
                    pUnk =  MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);
                    //
                    // byte[] b = ((MarshalByRefObject)otp).GetDCOMBuffer();
                    // IntPtr pUnk = ComponentServices.GetIUnknownFromDCOMUnmarshalBuffer(b);
                    // return pUnk;;
                }
                else
                {
                    // create an IUnknown here
                    pUnk =  MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);    
                }
            }
            else
            {
                bool fIsXAppDomain = RemotingServices.IsObjectOutOfAppDomain(otp);
                // we are in the same proces, ask the object for its IUnknown
                if (fIsXAppDomain)
                {
                    // do an appdomain switch
                    pUnk = ((MarshalByRefObject)otp).GetComIUnknown(fIsBeingMarshalled);
                }
                else
                {    
                    // otherwise go ahead and create a CCW here
                    pUnk = MarshalByRefObject.GetComIUnknown((MarshalByRefObject)otp);
                }
            }

            int i = pUnk.ToInt32();
            return pUnk;
        }
        
        public override void SetCOMIUnknown(IntPtr i)
        {
            // for now ignore this
        }

        // Check whether we can cast the transparent proxy to the given type
        public bool CanCastTo(Type castType, Object o)
        {
            bool fCastOK = false;

            // The identity should be non-null
            BCLDebug.Assert(null != IdentityObject,"null != IdentityObject");

            Message.DebugOut("CheckCast for identity " + IdentityObject.GetType());

            if ((castType == s_typeofObject) ||
                (castType == s_typeofMarshalByRefObject))
            {
                return true;
            }

            // Get the objref of the proxy
            ObjRef oRef = IdentityObject.ObjectRef;

            // If the object ref is non-null then check against the type info
            // stored in the it
            if (null != oRef)
            {
                Object oTP = GetTransparentProxy();

                // Check that there is a matching type in the server object 
                // hierarchy represented in the objref                                      
                Message.DebugOut("Calling CanCastTo for type " + castType);
                IRemotingTypeInfo typeInfo = oRef.TypeInfo;
                if(null != typeInfo)
                {
                    fCastOK = typeInfo.CanCastTo(castType, oTP);
                    if (!fCastOK && typeInfo.GetType()==typeof(TypeInfo) && oRef.IsWellKnown() )
                    {
                        fCastOK = CanCastToWK(castType);
                    }
                }                
                else
                {
                    if (oRef.IsObjRefLite())
                    {
                        // we should do a dynamic cast across the network
                        fCastOK = MarshalByRefObject.CanCastToXmlTypeHelper(castType, (MarshalByRefObject)o);  
                    }
                }
            }
            // This is a well known object which does not have a backing ObjRef
            else
            {
                fCastOK = CanCastToWK(castType);
            }
            return fCastOK;
        }

        // WellKnown proxies we always allow casts to interfaces, and allow 
        // casting down a single branch in the type hierarchy (both are on good
        // faith. The calls are failed on server side if a bogus cast is done)
        bool CanCastToWK(Type castType)
        {
            Message.DebugOut( "CheckCast for well known objects and type " + castType);
            bool fCastOK = false;
            // Check whether the type to which we want to cast is
            // compatible with the current type
            if(castType.IsClass)
            {
                fCastOK = GetProxiedType().IsAssignableFrom(castType);
            }
            else
            {
                // NOTE: we are coming here also for x-context proxies
                // when unmanaged code cannot determine if the cast is not
                // okay .. is this necessary?
                if (!(IdentityObject is ServerIdentity))
                {
                    BCLDebug.Assert(
                        IdentityObject.URI != null,
                        "Bad WellKnown ID");
                    // Always allow interface casts to succeed. If the 
                    // interface is not supported by the well known object
                    // then we will throw an exception when the interface
                    // is invoked.
                    fCastOK = true;
                }
            }
            return fCastOK;
        }
    }


    internal class AgileAsyncWorkerItem
    {
        private IMethodCallMessage _message;
        private AsyncResult        _ar;
        private Object             _target;

        public AgileAsyncWorkerItem(IMethodCallMessage message, AsyncResult ar, Object target)
        {
            _message = new MethodCall(message, false);
            _ar = ar;
            _target = target;
        }

        public static void ThreadPoolCallBack(Object o)
        {
            ((AgileAsyncWorkerItem) o).DoAsyncCall();
        }

        public void DoAsyncCall()
        {
            (new StackBuilderSink(_target)).AsyncProcessMessage(_message, _ar);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\soap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    Soap.cs
**
** Purpose: Classes used for SOAP configuration.
**
** Date:    Sep 30, 2000
**
===========================================================*/
namespace System.Runtime.Remoting {
    using System;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Security.Permissions;
    using System.Threading;
    
    using CultureInfo = System.Globalization.CultureInfo;


    /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class SoapServices
    {
        // hide the default constructor
        private SoapServices()
        {
        }
    
        // tables for interop type maps (both map "name namespace" to a Type object)
        private static Hashtable _interopXmlElementToType = Hashtable.Synchronized(new Hashtable());
        private static Hashtable _interopTypeToXmlElement = Hashtable.Synchronized(new Hashtable());

        private static Hashtable _interopXmlTypeToType = Hashtable.Synchronized(new Hashtable());
        private static Hashtable _interopTypeToXmlType = Hashtable.Synchronized(new Hashtable());

        private static Hashtable _xmlToFieldTypeMap = Hashtable.Synchronized(new Hashtable());
        
        private static Hashtable _methodBaseToSoapAction = Hashtable.Synchronized(new Hashtable());
        private static Hashtable _soapActionToMethodBase = Hashtable.Synchronized(new Hashtable());
        

        private static String CreateKey(String elementName, String elementNamespace)
        {
            if (elementNamespace == null)
                return elementName;
            else
                return elementName + " " + elementNamespace;
        }

        // Used for storing interop type mappings
        private class XmlEntry
        {
            public String Name;
            public String Namespace;

            public XmlEntry(String name, String xmlNamespace)
            {
                Name = name;
                Namespace = xmlNamespace;
            }
        } // class XmlEntry


        // contains mappings for xml element and attribute names to actual field names.
        private class XmlToFieldTypeMap
        {
            private class FieldEntry
            {
                public Type Type;
                public String Name;

                public FieldEntry(Type type, String name)
                {
                    Type = type;
                    Name = name;
                }
            }
        
            private Hashtable _attributes = new Hashtable();
            private Hashtable _elements = new Hashtable();

            public XmlToFieldTypeMap(){}

            public void AddXmlElement(Type fieldType, String fieldName,
                                      String xmlElement, String xmlNamespace)
            {
                _elements[CreateKey(xmlElement, xmlNamespace)] =
                    new FieldEntry(fieldType, fieldName);                    
            }

            public void AddXmlAttribute(Type fieldType, String fieldName,
                                        String xmlAttribute, String xmlNamespace)
            {
                _attributes[CreateKey(xmlAttribute, xmlNamespace)] =
                    new FieldEntry(fieldType, fieldName);
            }

            public void GetFieldTypeAndNameFromXmlElement(String xmlElement, String xmlNamespace,
                                                          out Type type, out String name)
            {
                FieldEntry field = (FieldEntry)_elements[CreateKey(xmlElement, xmlNamespace)];
                if (field != null)
                {
                    type = field.Type;
                    name = field.Name;
                }
                else
                {
                    type = null;
                    name = null;
                }
            } // GetTypeFromXmlElement
            
            public void GetFieldTypeAndNameFromXmlAttribute(String xmlAttribute, String xmlNamespace,
                                                            out Type type, out String name)
            {
                FieldEntry field = (FieldEntry)_attributes[CreateKey(xmlAttribute, xmlNamespace)];
                if (field != null)
                {
                    type = field.Type;
                    name = field.Name;
                }
                else
                {
                    type = null;
                    name = null;
                }
            } // GetTypeFromXmlAttribute
            
        } // class XmlToFieldTypeMap

    
        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.RegisterInteropXmlElement"]/*' />
        public static void RegisterInteropXmlElement(String xmlElement, String xmlNamespace,
                                                     Type type)
        {
            _interopXmlElementToType[CreateKey(xmlElement, xmlNamespace)] = type;
            _interopTypeToXmlElement[type] = new XmlEntry(xmlElement, xmlNamespace);
        } // RegisterInteropXmlElement


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.RegisterInteropXmlType"]/*' />
        public static void RegisterInteropXmlType(String xmlType, String xmlTypeNamespace,
                                                  Type type)
        {
            _interopXmlTypeToType[CreateKey(xmlType, xmlTypeNamespace)] = type;
            _interopTypeToXmlType[type] = new XmlEntry(xmlType, xmlTypeNamespace);
        } // RegisterInteropXmlType


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.PreLoad"]/*' />
        public static void PreLoad(Type type)
        {
            // register soap action values
                MethodInfo[] methods = type.GetMethods();
                foreach (MethodInfo mi in methods)
                {
                    // This will only add an entry to the table if SoapAction was explicitly set
                    //   on the SoapMethodAttribute.
                    RegisterSoapActionForMethodBase(mi);
                }

            // register interop xml elements and types if specified
            SoapTypeAttribute attr = (SoapTypeAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(type);

            if (attr.IsInteropXmlElement())            
                RegisterInteropXmlElement(attr.XmlElementName, attr.XmlNamespace, type);
            if (attr.IsInteropXmlType())
                RegisterInteropXmlType(attr.XmlTypeName, attr.XmlTypeNamespace, type);

            // construct field maps for mapping xml elements and attributes back to
            //   the correct type            
            int mapCount = 0;
            XmlToFieldTypeMap map = new XmlToFieldTypeMap();
            
            foreach(FieldInfo field in type.GetFields())
            {
                SoapFieldAttribute fieldAttr = (SoapFieldAttribute)
                    InternalRemotingServices.GetCachedSoapAttribute(field);
            
                if (fieldAttr.IsInteropXmlElement())
                {
                    String xmlName = fieldAttr.XmlElementName;
                    String xmlNamespace = fieldAttr.XmlNamespace;
                    if (fieldAttr.UseAttribute)
                        map.AddXmlAttribute(field.FieldType, field.Name, xmlName, xmlNamespace);
                    else
                        map.AddXmlElement(field.FieldType, field.Name, xmlName, xmlNamespace);
                        
                    mapCount++;
                }
            } // foreach field

            // add field map if there is more than one entry
            if (mapCount > 0)
                _xmlToFieldTypeMap[type] = map;
                
        } // PreLoad


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.PreLoad2"]/*' />
        public static void PreLoad(Assembly assembly)
        {
            Type[] types = assembly.GetTypes();
            foreach (Type type in types)
            {
                PreLoad(type);
            }
        } // PreLoad       
                                                             
        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetInteropTypeFromXmlElement"]/*' />
        public static Type GetInteropTypeFromXmlElement(String xmlElement, String xmlNamespace)
        {
            return (Type)_interopXmlElementToType[CreateKey(xmlElement, xmlNamespace)];
        } // GetInteropTypeFromXmlElement


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetInteropTypeFromXmlType"]/*' />
        public static Type GetInteropTypeFromXmlType(String xmlType, String xmlTypeNamespace)
        {
            return (Type)_interopXmlTypeToType[CreateKey(xmlType, xmlTypeNamespace)];
        } // GetInteropTypeFromXmlElement     


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetInteropFieldTypeAndNameFromXmlElement"]/*' />
        public static void GetInteropFieldTypeAndNameFromXmlElement(Type containingType,
            String xmlElement, String xmlNamespace,
            out Type type, out String name)
        {        
            if (containingType == null)
            {
                type = null;
                name = null;
                return;
            }
        
            XmlToFieldTypeMap map = (XmlToFieldTypeMap)_xmlToFieldTypeMap[containingType];
            if (map != null)            
            {
                map.GetFieldTypeAndNameFromXmlElement(xmlElement, xmlNamespace,
                                                      out type, out name);
            }
            else
            {
                type = null;
                name = null;
            }
        } // GetInteropFieldTypeFromXmlElement


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetInteropFieldTypeAndNameFromXmlAttribute"]/*' />
        public static void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType,
            String xmlAttribute, String xmlNamespace,
            out Type type, out String name)
        {
            if (containingType == null)
            {
                type = null;
                name = null;
                return;
            }
        
            XmlToFieldTypeMap map = (XmlToFieldTypeMap)_xmlToFieldTypeMap[containingType];
            if (map != null)
            {
                map.GetFieldTypeAndNameFromXmlAttribute(xmlAttribute, xmlNamespace,
                                                        out type, out name);
            }
            else
            {
                type = null;
                name = null;
            }
        } // GetInteropFieldTypeFromXmlAttribute


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetXmlElementForInteropType"]/*' />
        public static bool GetXmlElementForInteropType(Type type, 
                                                       out String xmlElement, out String xmlNamespace)
        {
            // check table first
            XmlEntry entry = (XmlEntry)_interopTypeToXmlElement[type];
            if (entry != null)
            {
                xmlElement = entry.Name;
                xmlNamespace = entry.Namespace;
                return true;
            }

            // check soap attribute
            SoapTypeAttribute attr = (SoapTypeAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(type);

            if (attr.IsInteropXmlElement())
            {
                xmlElement = attr.XmlElementName;
                xmlNamespace = attr.XmlNamespace;
                return true;
            }
            else
            {
                xmlElement = null;
                xmlNamespace = null;
                return false;
            }
        } // GetXmlElementForInteropType


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetXmlTypeForInteropType"]/*' />
        public static bool GetXmlTypeForInteropType(Type type, 
                                                    out String xmlType, out String xmlTypeNamespace)
        {
            // check table first
            XmlEntry entry = (XmlEntry)_interopTypeToXmlType[type];
            if (entry != null)
            {
                xmlType = entry.Name;
                xmlTypeNamespace = entry.Namespace;
                return true;
            }

            // check soap attribute
            SoapTypeAttribute attr = (SoapTypeAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(type);

            if (attr.IsInteropXmlType())
            {
                xmlType = attr.XmlTypeName;
                xmlTypeNamespace = attr.XmlTypeNamespace;
                return true;
            }
            else
            {
                xmlType = null;
                xmlTypeNamespace = null;
                return false;
            }           
        } // GetXmlTypeForInteropType


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetXmlNamespaceForMethodCall"]/*' />
        public static String GetXmlNamespaceForMethodCall(MethodBase mb)
        {
            SoapMethodAttribute attr = (SoapMethodAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(mb);
            return attr.XmlNamespace;
        } // GetXmlNamespaceForMethodCall


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetXmlNamespaceForMethodResponse"]/*' />
        public static String GetXmlNamespaceForMethodResponse(MethodBase mb)
        {
            SoapMethodAttribute attr = (SoapMethodAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(mb);
            return attr.ResponseXmlNamespace;
        } // GetXmlNamespaceForMethodResponse


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.RegisterSoapActionForMethodBase"]/*' />
        public static void RegisterSoapActionForMethodBase(MethodBase mb)
        {
            SoapMethodAttribute attr = 
                     (SoapMethodAttribute)InternalRemotingServices.GetCachedSoapAttribute(mb);
            if (attr.SoapActionExplicitySet)
                RegisterSoapActionForMethodBase(mb, attr.SoapAction);
        } // RegisterSoapActionForMethodBase
        

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.RegisterSoapActionForMethodBase1"]/*' />
        public static void RegisterSoapActionForMethodBase(MethodBase mb, String soapAction)
        {
            if (soapAction != null)
            {            
                _methodBaseToSoapAction[mb] = soapAction;

                // get table of method bases
                ArrayList mbTable = (ArrayList)_soapActionToMethodBase[soapAction];
                if (mbTable == null)
                {
                    lock (_soapActionToMethodBase)
                    {
                        mbTable = ArrayList.Synchronized(new ArrayList());
                        _soapActionToMethodBase[soapAction] = mbTable;
                    }
                }
                mbTable.Add(mb);
            }
        } // RegisterSoapActionForMethodBase



        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetSoapActionFromMethodBase"]/*' />
        public static String GetSoapActionFromMethodBase(MethodBase mb)
        {
            String soapAction = (String)_methodBaseToSoapAction[mb];

            if (soapAction == null)
            {                      
                SoapMethodAttribute attr = 
                     (SoapMethodAttribute)InternalRemotingServices.GetCachedSoapAttribute(mb);
                soapAction = attr.SoapAction;
            }
            
            return soapAction;
        } // GetSoapActionFromMethodBase


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.IsSoapActionValidForMethodBase"]/*' />
        public static bool IsSoapActionValidForMethodBase(String soapAction, MethodBase mb)
        {
            // remove quotation marks if present
            if ((soapAction[0] == '"') && (soapAction[soapAction.Length - 1] == '"'))
                soapAction = soapAction.Substring(1, soapAction.Length - 2);

            // compare this to the soapAction on the method base
            SoapMethodAttribute attr = (SoapMethodAttribute)
                InternalRemotingServices.GetCachedSoapAttribute(mb);
            if (String.CompareOrdinal(attr.SoapAction, soapAction) == 0)
                return true;

            // check to see if a soap action value is registered for this
            String registeredSoapAction = (String)_methodBaseToSoapAction[mb];
            if (registeredSoapAction != null)
            {
                if (String.CompareOrdinal(registeredSoapAction, soapAction) == 0)
                    return true;
            }

            // otherwise, parse SOAPAction and verify
            String typeName, methodName;
            
            String[] parts = soapAction.Split(new char[1]{'#'});
            if (parts.Length == 2)
            {
                bool assemblyIncluded;
                typeName = XmlNamespaceEncoder.GetTypeNameForSoapActionNamespace(
                    parts[0], out assemblyIncluded);
                if (typeName == null)
                    return false;

                methodName = parts[1];
                
                // compare to values of method base (FUTURE: Use more direct method for this)
                Type type = mb.DeclaringType;
                String actualTypeName = type.FullName;
                if (assemblyIncluded)
                    actualTypeName += ", " + type.Module.Assembly.nGetSimpleName();

                // return true if type and method name are the same
                return actualTypeName.Equals(typeName) && mb.Name.Equals(methodName);
            }
            else
                return false;            
        } // IsSoapActionValidForMethodBase


        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.GetTypeAndMethodNameFromSoapAction"]/*' />        
        public static bool GetTypeAndMethodNameFromSoapAction(String soapAction,
                                                              out String typeName,
                                                              out String methodName)
        {             
            // remove quotation marks if present
            if ((soapAction[0] == '"') && (soapAction[soapAction.Length - 1] == '"'))
                soapAction = soapAction.Substring(1, soapAction.Length - 2);

            ArrayList mbTable = (ArrayList)_soapActionToMethodBase[soapAction];
            if (mbTable != null)
            {
                // indicate that we can't resolve soap action to type and method name
                if (mbTable.Count > 1)
                {
                    typeName = null;
                    methodName = null;
                    return false;
                }
        
                MethodBase mb = (MethodBase)mbTable[0];
                if (mb != null)
                {
                    Type type = mb.DeclaringType;
                    typeName = type.FullName + ", " + type.Module.Assembly.nGetSimpleName();
                    methodName = mb.Name;
                    return true;
                }                
            }

    
            String[] parts = soapAction.Split(new char[1]{'#'});
            if (parts.Length == 2)
            {
                bool assemblyIncluded;
                typeName = XmlNamespaceEncoder.GetTypeNameForSoapActionNamespace(
                    parts[0], out assemblyIncluded);
                if (typeName == null)
                {
                    methodName = null;
                    return false;
                }

                methodName = parts[1];
                return true;
            }
            else
            {
                typeName = null;
                methodName = null;
                return false;
            }

        } // GetTypeAndMethodNameFromSoapAction


        //Future namespaces might be
        // urn:a.clr.ms.com/assembly
        // urn:n.clr.ms.com/typeNamespace
        // urn:f.clr.ms.com/typeNamespace/assembly

        //namespaces are 
        // http://schemas.microsoft.com/clr/assem/assembly
        // http://schemas.microsoft.com/clr/ns/typeNamespace
        // http://schemas.microsoft.com/clr/nsassem/typeNamespace/assembly

        internal static String startNS = "http://schemas.microsoft.com/clr/";
        internal static String assemblyNS = "http://schemas.microsoft.com/clr/assem/";
        internal static String namespaceNS = "http://schemas.microsoft.com/clr/ns/";
        internal static String fullNS = "http://schemas.microsoft.com/clr/nsassem/";

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.XmlNsForClrType"]/*' />
        public static String XmlNsForClrType
        {
            get {return startNS;}
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.XmlNsForClrTypeWithAssembly"]/*' />
        public static String XmlNsForClrTypeWithAssembly
        {
            get {return assemblyNS;}
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.XmlNsForClrTypeWithNs"]/*' />
        public static String XmlNsForClrTypeWithNs
        {
            get {return namespaceNS;}
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.XmlNsForClrTypeWithNsAndAssembly"]/*' />
        public static String XmlNsForClrTypeWithNsAndAssembly
        {
            get {return fullNS;}
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.IsClrTypeNamespace"]/*' />
        public static bool IsClrTypeNamespace(String namespaceString)
        {
            if (namespaceString.StartsWith(startNS))
                return true;
            else
                return false;
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.CodeXmlNamespaceForClrTypeNamespace"]/*' />
        public static String CodeXmlNamespaceForClrTypeNamespace(String typeNamespace, String assemblyName)
        {
            StringBuilder sb = new StringBuilder(256);
            if (IsNameNull(typeNamespace))
            {
                if (IsNameNull(assemblyName))
                    throw new ArgumentNullException("typeNamespace"+",assemblyName");
                else
                {
                    sb.Append(assemblyNS);
                    UriEncode(assemblyName, sb);
                }
            }
            else if (IsNameNull(assemblyName))
            {
                sb.Append(namespaceNS);
                sb.Append(typeNamespace);
            }
            else
            {
                sb.Append(fullNS);
                if (typeNamespace[0] == '.')
                    sb.Append(typeNamespace.Substring(1));
                else
                    sb.Append(typeNamespace);
                sb.Append('/');
                UriEncode(assemblyName, sb);
            }
            return sb.ToString();
        }

        /// <include file='doc\Soap.uex' path='docs/doc[@for="SoapServices.DecodeXmlNamespaceForClrTypeNamespace"]/*' />
        public static bool DecodeXmlNamespaceForClrTypeNamespace(String inNamespace, out String typeNamespace, out String assemblyName)
        {
            if (IsNameNull(inNamespace))
                throw new ArgumentNullException("inNamespace");

            assemblyName = null;
            typeNamespace = "";

            if (inNamespace.StartsWith(assemblyNS))
                assemblyName = UriDecode(inNamespace.Substring(assemblyNS.Length));
            else if (inNamespace.StartsWith(namespaceNS))
                typeNamespace = inNamespace.Substring(namespaceNS.Length);
            else if (inNamespace.StartsWith(fullNS))
            {
                int index = inNamespace.IndexOf("/", fullNS.Length);
                typeNamespace = inNamespace.Substring(fullNS.Length,index-fullNS.Length);
                assemblyName = UriDecode(inNamespace.Substring(index+1));
            }
            else
                return false;

            return true;
        }

        internal static String UriEncode(String value)
        {
            if (value == null || value.Length == 0)
                return value;

            StringBuilder sb = new StringBuilder();
            UriEncode(value, sb);
            return sb.ToString();
        }

        internal static void UriEncode(String value, StringBuilder sb)
        {
            if (value == null || value.Length == 0)
                return;

            for (int i=0; i<value.Length; i++)
            {
                if (value[i] == ' ')
                    sb.Append("%20");
                else if (value[i] == '=')
                    sb.Append("%3D");
                else if (value[i] == ',')
                    sb.Append("%2C");

                else
                    sb.Append(value[i]);
            }
        }

        internal static String UriDecode(String value)
        {
            if (value == null || value.Length == 0)
                return value;

            StringBuilder sb = new StringBuilder();

            for (int i=0; i<value.Length; i++)
            {
                if (value[i] == '%' && (value.Length-i >= 3))
                {
                    if (value[i+1] == '2' && value[i+2] == '0')
                    {
                        sb.Append(' ');
                        i += 2;
                    }
                    else if (value[i+1] == '3' && value[i+2] == 'D')
                    {
                        sb.Append('=');
                        i += 2;
                    }
                    else if (value[i+1] == '2' && value[i+2] == 'C')
                    {
                        sb.Append(',');
                        i += 2;
                    }

                    else
                        sb.Append(value[i]);
                }
                else
                    sb.Append(value[i]);
            }
            return sb.ToString();
        }



        private static bool IsNameNull(String name)
        {
            if (name == null || name.Length == 0)
                return true;
            else
                return false;
        }
        
    } // class SoapServices

    

    internal sealed class XmlNamespaceEncoder
    {   
        // REVIEW: Do we still need this after upcoming breaking changes?        
        // encode a type as an xml namespace (dynamic url is for types which have
        //   dynamically changing uri's, such as .SOAP files)
        internal static String GetXmlNamespaceForType(Type type, String dynamicUrl)
        {        
            String typeName = type.FullName;
            Assembly assem = type.Module.Assembly;
            StringBuilder sb = new StringBuilder(256);
            Assembly systemAssembly = typeof(String).Module.Assembly;

            if(assem == systemAssembly)
            {
                sb.Append(SoapServices.namespaceNS);
                sb.Append(typeName);
            }
            else
            {
                sb.Append(SoapServices.fullNS);
                sb.Append(typeName);
                sb.Append('/');
                sb.Append(assem.nGetSimpleName());
            }

            return sb.ToString();
        } // GetXmlNamespaceForType


        // encode a type namespace as an xml namespace (dynamic url is for types which have
        //   dynamically changing uri's, such as .SOAP files)
        internal static String GetXmlNamespaceForTypeNamespace(Type type, String dynamicUrl)
        {        
            String typeNamespace = type.Namespace;
            Assembly assem = type.Module.Assembly;
            StringBuilder sb = new StringBuilder(256);
            Assembly systemAssembly = typeof(String).Module.Assembly;

            if(assem == systemAssembly)
            {
                sb.Append(SoapServices.namespaceNS);
                sb.Append(typeNamespace);
            }
            else
            {
                sb.Append(SoapServices.fullNS);
                sb.Append(typeNamespace);
                sb.Append('/');
                sb.Append(assem.nGetSimpleName());
            }

            return sb.ToString();
        } // GetXmlNamespaceForTypeNamespace


        internal static String GetTypeNameForSoapActionNamespace(String uri)
        {
            bool assemblyIncluded;
            return GetTypeNameForSoapActionNamespace(uri, out assemblyIncluded);
        }

        // retrieve xml namespace that matches this type
        internal static String GetTypeNameForSoapActionNamespace(String uri, out bool assemblyIncluded)
        {
            assemblyIncluded = false;
            String urtNSprefix = SoapServices.fullNS;
            String systemNSprefix = SoapServices.namespaceNS;
            
            if (uri.StartsWith(urtNSprefix))
            {
                uri = uri.Substring(urtNSprefix.Length); // now contains type/assembly
                char[] sep = new char[]{'/'};
                String[] parts = uri.Split(sep); 
                if (parts.Length != 2)
                    return null;
                else
                {
                    assemblyIncluded = true;
                    return parts[0] + ", " + parts[1];
                }
            }
            if (uri.StartsWith(systemNSprefix))
            {
                String assemName = typeof(String).Module.Assembly.nGetSimpleName();
                assemblyIncluded = true;
                return uri.Substring(systemNSprefix.Length) + ", " + assemName; // now contains type
            }

            return null;
        } // GetTypeForXmlNamespace
        
    
        internal static String Encode(String ns)
        {
            if((null != ns) && (0 != ns.Length))
            {
                StringBuilder sb = new StringBuilder(2*ns.Length);
                
                if(Char.IsDigit(ns[0]))
                {
                    // The first character cannot be a numeral in 
                    // an identifier. We add an extra '_' for such cases.
                    sb.Append('_');
                }
                for(int i=0;i<ns.Length;i++)
                {
                    char ch = ns[i];
                    char escCh;
                    switch(ch)
                    {
                    case '.':
                        escCh = 'a';
                        break;
    
                    case '/':
                        escCh = 'b';
                        break;
    
                    case '\\':
                        escCh = 'c';
                        break;
    
                    case ':':
                        escCh = 'd';
                        break;
    
                    case '_':
                        escCh = 'e';
                        break;
                        
                    case '+':
                        escCh = 'f';
                        break;                  
    
                    case '-':
                        escCh = 'g';
                        break;                  
                        
                    case '*':
                        escCh = 'h';
                        break;                  
                        
                    default:
                        escCh = ch;
                        goto escape;
                    }
                    sb.Append('_');
                escape:
                    sb.Append(escCh);
                }

                return(sb.ToString());
            }
            
            return ns;
        }

        internal static String Decode(String ns)
        {
            if((null != ns) && (0 != ns.Length))
            {
                StringBuilder sb = null;
                int start = 0;
                if('_' == ns[0] && Char.IsDigit(ns[1]))
                {
                    start = 1;
                    sb = new StringBuilder(ns.Length - 1);   
                }
                else
                {           
                    sb = new StringBuilder(ns.Length);
                }
                
                for(int i = start;i<ns.Length;i++)
                {
                    char ch = ns[i];
                    char escCh;
                    switch(ch)
                    {
                    case '_':
                        ++i;
                        escCh = ns[i];
                        switch(escCh)
                        {
                        case 'a':
                            escCh = '.';
                            break;
                        case 'b':
                            escCh = '/';
                            break;
                        case 'c':
                            escCh = '\\';
                            break;
                        case 'd':
                            escCh = ':';
                            break;
                        case 'e':
                            escCh = '_';
                            break;
                        case 'f':
                            escCh = '+';                        
                            break;
                        case 'g':
                            escCh = '-';                        
                            break;
                        case 'h':
                            escCh = '*';                        
                            break;
                        default:
                            BCLDebug.Assert(false, "How did we arrive here?");
                            break;
                        }
                        break;
    
                    default:
                        escCh = ch;
            break;
                    }
                    sb.Append(escCh);
                }
    
                return(sb.ToString());
            }
            
            return ns;
        }
    } // XmlNamespaceEncoder
    
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\trackingservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    TrackingServices.cool
**
** Author(s):   Tarun Anand    (TarunA)
**
** Purpose: Defines the services for tracking lifetime and other 
**          operations on objects.
**
** Date:    Feb 28, 2000
**
===========================================================*/
namespace System.Runtime.Remoting.Services {
    using System.Security.Permissions;	
    using System;

/// <include file='doc\TrackingServices.uex' path='docs/doc[@for="ITrackingHandler"]/*' />
public interface ITrackingHandler
{
    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="ITrackingHandler.MarshaledObject"]/*' />
    // Notify a handler that an object has been marshaled
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
    void MarshaledObject(Object obj, ObjRef or);
    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="ITrackingHandler.UnmarshaledObject"]/*' />
    
    // Notify a handler that an object has been unmarshaled
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
    void UnmarshaledObject(Object obj, ObjRef or);
    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="ITrackingHandler.DisconnectedObject"]/*' />
    
    // Notify a handler that an object has been disconnected
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)] 		
    void DisconnectedObject(Object obj);
        
}


/// <include file='doc\TrackingServices.uex' path='docs/doc[@for="TrackingServices"]/*' />
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
public class TrackingServices
{
    // Private member variables        
    private static ITrackingHandler[] _Handlers = new ITrackingHandler[0];  // Array of registered tracking handlers
    private static int _Size = 0;                                           // Number of elements in the array

    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="TrackingServices.RegisterTrackingHandler"]/*' />
    public static void RegisterTrackingHandler(ITrackingHandler handler)
    {
        lock(typeof(TrackingServices))
        {        
            // Validate arguments
            if(null == handler)
            {
                throw new ArgumentNullException("handler");
            }
    
            // Check to make sure that the handler has not been registered
            if(-1 == Match(handler))
            {
                // Allocate a new array if necessary
                if((null == _Handlers) || (_Size == _Handlers.Length))
                {
                    ITrackingHandler[] temp = new ITrackingHandler[_Size*2+4];
                    if(null != _Handlers)
                    {
                        Array.Copy(_Handlers, temp, _Size);
                    }
                    _Handlers = temp;
                }        
                
                _Handlers[_Size++] = handler;
            }
            else
            {
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_TrackingHandlerAlreadyRegistered"), "handler"));
            }
        }
    }
    
    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="TrackingServices.UnregisterTrackingHandler"]/*' />
    public static void UnregisterTrackingHandler(ITrackingHandler handler)
    {
        lock(typeof(TrackingServices))
        {
            // Validate arguments
            if(null == handler)
            {
                throw new ArgumentNullException("handler");
            }

            // Check to make sure that the channel has been registered
            int matchingIdx = Match(handler);
            if(-1 == matchingIdx)
            {
                throw new RemotingException(String.Format(Environment.GetResourceString("Remoting_HandlerNotRegistered"), handler));
            }

            // Delete the entry by copying the remaining entries        
            Array.Copy(_Handlers, matchingIdx+1, _Handlers, matchingIdx, _Size-matchingIdx-1);
            _Size--;
        }        
    }
    
    /// <include file='doc\TrackingServices.uex' path='docs/doc[@for="TrackingServices.RegisteredHandlers"]/*' />
    public static ITrackingHandler[] RegisteredHandlers
    {
        get 
        {
            lock(typeof(TrackingServices))
            {
                if(0 == _Size)
                {
                    return new ITrackingHandler[0];
                }
                else 
                {
                    // Copy the array of registered handlers into a new array
                    // and return
                    ITrackingHandler[] temp = new ITrackingHandler[_Size];
                    for(int i = 0; i < _Size; i++)
                    {
                        temp[i] = _Handlers[i];
                    }
                    return temp;
                }
            }
        }
    }

    // Notify all the handlers that an object has been marshaled
    internal static void MarshaledObject(Object obj, ObjRef or)
    {
        ITrackingHandler[] temp = _Handlers;
        for(int i = 0; i < _Size; i++)
        {
            temp[i].MarshaledObject(obj, or);
        }
    }
    
    // Notify all the handlers that an object has been unmarshaled
    internal static void UnmarshaledObject(Object obj, ObjRef or)
    {
        ITrackingHandler[] temp = _Handlers;
        for(int i = 0; i < _Size; i++)
        {
            temp[i].UnmarshaledObject(obj, or);
        }
    }
    
    // Notify all the handlers that an object has been disconnected
    internal static void DisconnectedObject(Object obj)
    {
        ITrackingHandler[] temp = _Handlers;
        for(int i = 0; i < _Size; i++)
        {
            temp[i].DisconnectedObject(obj);
        }
    }
    
    private static int Match(ITrackingHandler handler)
    {
        int idx = -1;

        for(int i = 0; i < _Size; i++)
        {
            if(_Handlers[i] == handler)
            {
                idx = i;
                break;
            }
        }

        return idx;
    }
}

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\terminatorsinks.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//   Remoting terminator sinks for sink chains along a remoting call.
//   There is only one static instance of each of these exposed through
//   the MessageSink property.
//
namespace System.Runtime.Remoting.Messaging {

    using System;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Channels; 
    using System.Runtime.Remoting.Contexts;    
    using System.Collections;
   //   Methods shared by all terminator sinks.
   //
    [Serializable]
    internal class InternalSink
    {
        /*
         *  Checks the replySink param for NULL and type.
         *  If the param is good, it returns NULL.
         *  Else it returns a Message with the relevant exception.
         */
        internal static IMessage ValidateMessage(IMessage reqMsg)
        {
            IMessage retMsg = null;
            if (reqMsg == null)
            {
                retMsg = new ReturnMessage( new ArgumentNullException("reqMsg"), null);
            }
            return retMsg;
        }

        /*
         *  This check is performed only for client & server context 
         *  terminator sinks and only on the Async path.
         *  
         */
        internal static IMessage DisallowAsyncActivation(IMessage reqMsg)
        {
            // FUTURE: revisit this when Async activation is
            // supported!
            if (reqMsg is IConstructionCallMessage)
            {

                return new ReturnMessage(
                                new RemotingException(
                                    "Async Activation not supported!"),
                                null /*reqMsg*/ );  
            }
            return null;
        }
    
        internal static Identity GetIdentity(IMessage reqMsg)
        {
            Identity id = null;

            if (reqMsg is IInternalMessage)
            {
                id = ((IInternalMessage) reqMsg).IdentityObject;
            }
            else if (reqMsg is InternalMessageWrapper)
            {
                id = (Identity)((InternalMessageWrapper)reqMsg).GetIdentityObject();
            }
    
            // Try the slow path if the identity has not been obtained yet
            if(null == id)
            {
                String objURI = GetURI(reqMsg);
    
                id = IdentityHolder.ResolveIdentity(objURI);
                
                // An object could get disconnected on another thread while a call is in progress
                if(id == null)
                {
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Remoting_ServerObjectNotFound"), objURI));
                }
            }
    
            return id;
        }
    
        internal static ServerIdentity GetServerIdentity(IMessage reqMsg)
        {
            ServerIdentity srvID = null;
            bool bOurMsg = false;
            String objURI = null;

            IInternalMessage iim = reqMsg as IInternalMessage;
            if (iim != null)
            {
                Message.DebugOut("GetServerIdentity.ServerIdentity from IInternalMessage\n");
                srvID = ((IInternalMessage) reqMsg).ServerIdentityObject;
                bOurMsg = true;
            }
            else if (reqMsg is InternalMessageWrapper)
            {
                srvID = (ServerIdentity)((InternalMessageWrapper)reqMsg).GetServerIdentityObject();
            }
            
            // Try the slow path if the identity has not been obtained yet
            if(null == srvID)
            {
                Message.DebugOut("GetServerIdentity.ServerIdentity from IMethodCallMessage\n");
                objURI = GetURI(reqMsg);
                Identity id = 
                    IdentityHolder.ResolveIdentity(objURI);
                if(id is ServerIdentity)
                {
                    srvID = (ServerIdentity)id;            

                    // Cache the serverIdentity in the message
                    if (bOurMsg)
                    {
                        iim.ServerIdentityObject = srvID;
                    }
                }
            }

            return srvID;
        }

        // Retrieve the URI either via a method call or through 
        // a dictionary property.
        internal static String GetURI(IMessage msg)
        {
            String uri = null;

            IMethodMessage mm = msg as IMethodMessage;
            if (mm != null)
            {
                uri = mm.Uri;
            }
            else
            {                
                IDictionary prop = msg.Properties;
                if(null != prop)
                {
                    uri = (String)prop["__Uri"];
                }                
            }

            return uri;
        }
    }
    

   //
   // Terminator sink for server envoy message sink chain. This delegates
   // to the client context chain for the call.
   //
    
    /* package scope */
    [Serializable]
    internal class EnvoyTerminatorSink : InternalSink, IMessageSink
    {
        private static EnvoyTerminatorSink messageSink;
        private static Object staticSyncObject = new Object();
    
        internal static IMessageSink MessageSink 
        {
            get 
            {   
                if (messageSink == null) 
                {
                    EnvoyTerminatorSink tmpSink = new EnvoyTerminatorSink();
                    lock(staticSyncObject)
                    {
                        if (messageSink == null)
                        {
                            messageSink = tmpSink;
                        }
                    }
                }
                return messageSink;
            }
        }
    
        public virtual IMessage     SyncProcessMessage(IMessage reqMsg) 
        {
            Message.DebugOut("---------------------------Envoy Chain Terminator: SyncProcessMessage");
            IMessage errMsg = ValidateMessage(reqMsg);        
            if (errMsg != null)
            {
                return errMsg;
            }
            // Validate returns null if the reqMsg is okay!
            return Thread.CurrentContext.GetClientContextChain().SyncProcessMessage(reqMsg);
        }        
        
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            Message.DebugOut("---------------------------Envoy Chain Terminator: AsyncProcessMessage");
            IMessageCtrl msgCtrl = null;
            IMessage errMsg = ValidateMessage(reqMsg);

            if (errMsg != null)
            {
                // Notify replySink of error if we can
                // FUTURE: is it okay to reply right away before we return 
                // the IMessageCtrl for the original call?
                if (replySink != null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            { 
                msgCtrl = Thread.CurrentContext.GetClientContextChain().AsyncProcessMessage(reqMsg, replySink);                
            }
            return msgCtrl;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                // We are the terminal sink of this chain
                return null;
            }
        }
    
    }
    
    
   //
   // Terminator sink for client context message sink chain. This delegates
   // to the appropriate channel sink for the call.
   //
   //
    
    /* package scope */
    internal class ClientContextTerminatorSink : InternalSink, IMessageSink
    {
        private static ClientContextTerminatorSink messageSink;
        private static Object staticSyncObject = new Object();

        internal static IMessageSink MessageSink 
        {
            get 
            {   
                if (messageSink == null) 
                {
                    ClientContextTerminatorSink tmpSink = new ClientContextTerminatorSink();
                    lock(staticSyncObject)
                    {
                        if (messageSink == null)
                        {
                            messageSink = tmpSink;
                        }
                    }
                }
                return messageSink;
            }
        }
            
        public virtual IMessage     SyncProcessMessage(IMessage reqMsg) 
        {
            Message.DebugOut("+++++++++++++++++++++++++ CliCtxTerminator: SyncProcessMsg");
            IMessage errMsg = ValidateMessage(reqMsg);        
    
            if (errMsg != null)
            {
                return errMsg;
            }
            
            Context ctx = Thread.CurrentContext;

            bool bHasDynamicSinks = 
                ctx.NotifyDynamicSinks(reqMsg, 
                        true,   // bCliSide
                        true,   // bStart
                        false,  // bAsync
                        true);  // bNotifyGlobals                           

            IMessage replyMsg;
            if (reqMsg is IConstructionCallMessage)
            {
                errMsg = ctx.NotifyActivatorProperties(
                                reqMsg, 
                                false /*bServerSide*/);
                if (errMsg != null)
                {
                    return errMsg;
                }

                replyMsg = ((IConstructionCallMessage)reqMsg).Activator.Activate(
                                (IConstructionCallMessage)reqMsg);
                BCLDebug.Assert(replyMsg is IConstructionReturnMessage,"bad ctorRetMsg");
                errMsg = ctx.NotifyActivatorProperties(
                                replyMsg, 
                                false /*bServerSide*/);
                if (errMsg != null)
                {
                    return errMsg;
                }
            }
            else
            {
                ChannelServices.NotifyProfiler(reqMsg, RemotingProfilerEvent.ClientSend);

                // Forward call to the channel.
                IMessageSink channelSink = GetChannelSink(reqMsg);
                // Move to default context unless we are going through
                // the cross-context channel
                ContextTransitionFrame frame = new ContextTransitionFrame();
                if (channelSink != CrossContextChannel.MessageSink)
                {
                    Thread.CurrentThread.EnterContext(
                        Context.DefaultContext,
                        ref frame);
                }
                replyMsg = channelSink.SyncProcessMessage(reqMsg);

                if (channelSink != CrossContextChannel.MessageSink)
                {
                    Thread.CurrentThread.ReturnToContext(ref frame);
                }

                ChannelServices.NotifyProfiler(replyMsg, RemotingProfilerEvent.ClientReceive);
            }
            
            
            if (bHasDynamicSinks)
            {
                ctx.NotifyDynamicSinks(reqMsg, 
                                   true,   // bCliSide
                                   false,  // bStart
                                   false,  // bAsync
                                   true);  // bNotifyGlobals 
            }
            
            return replyMsg;
        }
        
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            Message.DebugOut("+++++++++++++++++++++++++ CliCtxTerminator: AsyncProcessMsg");
            IMessage errMsg = ValidateMessage(reqMsg);
            IMessageCtrl msgCtrl=null;
            if (errMsg == null)
            {
                errMsg = DisallowAsyncActivation(reqMsg);
            }

            if (errMsg != null)
            {
                if (replySink != null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {   
                // If active, notify the profiler that an asynchronous remoting call is being made.
                if (RemotingServices.CORProfilerTrackRemotingAsync())
                {
                    Guid g;

                    RemotingServices.CORProfilerRemotingClientSendingMessage(out g, true);

                    if (RemotingServices.CORProfilerTrackRemotingCookie())
                        reqMsg.Properties["CORProfilerCookie"] = g;

                    // Only wrap the replySink if the call wants a reply
                    if (replySink != null)
                    {
                        // Now wrap the reply sink in our own so that we can notify the profiler of
                        // when the reply is received.  Upon invocation, it will notify the profiler
                        // then pass control on to the replySink passed in above.
                        IMessageSink profSink = new ClientAsyncReplyTerminatorSink(replySink);
    
                        // Replace the reply sink with our own
                        replySink = profSink;
                    }
                }

                Context cliCtx = Thread.CurrentContext;

                // Notify dynamic sinks that an Async call started
                cliCtx.NotifyDynamicSinks(
                        reqMsg, 
                        true,   // bCliSide
                        true,   // bStart
                        true,   // bAsync
                        true);  // bNotifyGlobals                           

                // Intercept the async reply to force the thread back
                // into the client-context before it executes further
                // and to notify dynamic sinks
                if (replySink != null)
                {
                    replySink = new AsyncReplySink(replySink, cliCtx); 
                }

                // Forward call to the channel.
                IMessageSink channelSink = GetChannelSink(reqMsg);
                // Move to default context unless we are going through
                // the cross-context channel
                ContextTransitionFrame frame = new ContextTransitionFrame();
                if (channelSink != CrossContextChannel.MessageSink)
                {
                    Thread.CurrentThread.EnterContext(
                        Context.DefaultContext,
                        ref frame);
                }
                msgCtrl = channelSink.AsyncProcessMessage(reqMsg, replySink);

                if (channelSink != CrossContextChannel.MessageSink)
                {
                    Thread.CurrentThread.ReturnToContext(ref frame);
                }
            }
            return msgCtrl;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                // We are the terminal sink of this chain
                return null;
            }
        }
    
        // Find the next chain (or channel) sink to delegate to.
        private IMessageSink GetChannelSink(IMessage reqMsg)
        {      
            Identity id = GetIdentity(reqMsg);
            return id.ChannelSink;
        }
    }

    internal class AsyncReplySink : IMessageSink
        {
            
            IMessageSink _replySink;// original reply sink that we are wrapping
            Context _cliCtx;        // the context this call emerged from 
            
            internal AsyncReplySink(IMessageSink replySink, Context cliCtx)
            {
                _replySink = replySink;
                _cliCtx = cliCtx;
            }
    
            public virtual IMessage SyncProcessMessage(IMessage reqMsg)
            {
            // we just switch back to the old context before calling
            // the next replySink
            IMessage retMsg = null;
            if (_replySink != null)
            {
                ContextTransitionFrame frame = new ContextTransitionFrame();
                Thread.CurrentThread.EnterContext(_cliCtx, ref frame);

                // Call the dynamic sinks to notify that the async call
                // has completed
                Thread.CurrentContext.NotifyDynamicSinks(
                    reqMsg, // this is the async reply
                    true,   // bCliSide
                    false,  // bStart
                    true,   // bAsync
                    true);  // bNotifyGlobals

                // call the original reply sink now that we have moved
                // to the correct client context
                retMsg = _replySink.SyncProcessMessage(reqMsg);

                // return the thread to its earlier context
                Thread.CurrentThread.ReturnToContext(ref frame);
            }
            return retMsg;
            }
    
            public virtual IMessageCtrl AsyncProcessMessage(
                IMessage reqMsg, IMessageSink replySink)
            {
                throw new NotSupportedException();
            }
    
            public IMessageSink NextSink
            {
                get
                {
                    return _replySink;
                }
            }
        }   


    
    
   //
   // Terminator sink for server context message sink chain. This delegates
   // to the appropriate object sink chain for the call.
   //
   //
    
    /* package scope */
    [Serializable]
    internal class ServerContextTerminatorSink : InternalSink, IMessageSink
    {
        private static ServerContextTerminatorSink messageSink;
        private static Object staticSyncObject = new Object();
    
        internal static IMessageSink MessageSink 
        {
            get 
            {   
                if (messageSink == null) 
                {
                    ServerContextTerminatorSink tmpSink = new ServerContextTerminatorSink();
                    lock(staticSyncObject)
                    {
                        if (messageSink == null)
                        {
                            messageSink = tmpSink;
                        }
                    }
                }
                return messageSink;
            }
        }
    
        public virtual IMessage     SyncProcessMessage(IMessage reqMsg) 
        {
            Message.DebugOut("+++++++++++++++++++++++++ SrvCtxTerminator: SyncProcessMsg");
            IMessage errMsg = ValidateMessage(reqMsg);        
            if (errMsg != null)
            {
                return errMsg;
            }
            
            
            Context ctx = Thread.CurrentContext;
            IMessage replyMsg;
            if (reqMsg is IConstructionCallMessage)
            {
                errMsg = ctx.NotifyActivatorProperties(
                                reqMsg, 
                                true /*bServerSide*/);
                if (errMsg != null)
                {
                    return errMsg;
                }

                replyMsg = ((IConstructionCallMessage)reqMsg).Activator.Activate((IConstructionCallMessage)reqMsg);
                BCLDebug.Assert(replyMsg is IConstructionReturnMessage,"bad ctorRetMsg");
                errMsg = ctx.NotifyActivatorProperties(
                                replyMsg, 
                                true /*bServerSide*/);
                if (errMsg != null)
                {
                    return errMsg;
                }
            }
            else
            {
                // Pass call on to the server object specific chain
                MarshalByRefObject obj;
                replyMsg = GetObjectChain(reqMsg, out obj).SyncProcessMessage(reqMsg);
                IDisposable iDis = null;
                if (obj != null && ((iDis=(obj as IDisposable)) != null))
                {
                    iDis.Dispose();
                }
            }

            return replyMsg;
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            Message.DebugOut("+++++++++++++++++++++++++ SrvCtxTerminator: SyncProcessMsg");
            IMessageCtrl msgCtrl=null;
            IMessage errMsg = ValidateMessage(reqMsg);

            if (errMsg == null)
            {
                errMsg = DisallowAsyncActivation(reqMsg);
            }

            if (errMsg != null)
            {
                if (replySink!=null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {
                // FUTURE: notify dynamic property sinks.
                MarshalByRefObject obj;
                IMessageSink nextChain = GetObjectChain(reqMsg, out obj);
                IDisposable iDis;
                if (obj != null && ((iDis = (obj as IDisposable)) != null))
                {
                    DisposeSink dsink = new DisposeSink(iDis, replySink); 
                    replySink = dsink;
                }
                msgCtrl = nextChain.AsyncProcessMessage(
                                reqMsg, 
                                replySink);
                
            }
            return msgCtrl;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                // We are the terminal sink of this chain
                return null;
            }
        }
    
        internal virtual IMessageSink GetObjectChain(IMessage reqMsg,out MarshalByRefObject obj)
        {
            ServerIdentity srvID = GetServerIdentity(reqMsg);
            return srvID.GetServerObjectChain(out obj);   
        }    
    }

    internal class DisposeSink : IMessageSink
    {
        IDisposable _iDis;
        IMessageSink _replySink;
        internal DisposeSink(IDisposable iDis, IMessageSink replySink)
        {
            _iDis = iDis;
            _replySink = replySink; 
        }

        public virtual IMessage SyncProcessMessage(IMessage reqMsg)
        {
            IMessage replyMsg = null;
            if (_replySink != null)
            {
                replyMsg = _replySink.SyncProcessMessage(reqMsg);
            }
            // call dispose on the object now!
            _iDis.Dispose();
            return replyMsg;
        }

        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
        {
            throw new NotSupportedException();
        }
        public IMessageSink NextSink
        {
            get
            {
                return _replySink;
            }
        }
    }

    
   //
   // Terminator sink for the server object sink chain. This should
   // be just replaced by the dispatcher sink.
   //  
    
    /* package scope */
    [Serializable]
    internal class ServerObjectTerminatorSink : InternalSink, IMessageSink
    {
        internal StackBuilderSink _stackBuilderSink;
        internal ServerObjectTerminatorSink(MarshalByRefObject srvObj)   
        {
            _stackBuilderSink = new StackBuilderSink(srvObj);
        }
            
    
        public virtual IMessage     SyncProcessMessage(IMessage reqMsg) 
        {
            Message.DebugOut("+++++++++++++++++++++++++ SrvObjTerminator: SyncProcessMsg\n");
            IMessage errMsg = ValidateMessage(reqMsg);
            if (errMsg != null)
            {
                return errMsg;
            }
            
            ServerIdentity srvID = GetServerIdentity(reqMsg);
       
            BCLDebug.Assert(null != srvID,"null != srvID");
            ArrayWithSize objectSinks = srvID.ServerSideDynamicSinks;
            if (objectSinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                    reqMsg, 
                                    objectSinks, 
                                    false,  // bCliSide
                                    true,   // bStart
                                    false); // bAsync
            }
    
            Message.DebugOut("ServerObjectTerminator.Invoking method on object\n");
    
            // Pass call on to the server object specific chain
            BCLDebug.Assert(null != _stackBuilderSink,"null != _stackBuilderSink");

            IMessage replyMsg;
            
            IMessageSink serverAsSink = _stackBuilderSink.ServerObject as IMessageSink;
            if (serverAsSink != null)
                replyMsg = serverAsSink.SyncProcessMessage(reqMsg);
            else
                replyMsg = _stackBuilderSink.SyncProcessMessage(reqMsg);
            
            if (objectSinks != null)
            {
                DynamicPropertyHolder.NotifyDynamicSinks(
                                    replyMsg, 
                                    objectSinks, 
                                    false,  // bCliSide
                                    false,  // bStart
                                    false); // bAsync
            }
            return replyMsg;
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink) 
        {
            IMessageCtrl msgCtrl=null;
            IMessage errMsg = ValidateMessage(reqMsg);
            // FUTURE: notify dynamic sinks for Async.
            
            if (errMsg!=null)
            {
                if (replySink!=null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {
                // Pass call on to the server object specific chain
                IMessageSink serverAsSink = _stackBuilderSink.ServerObject as IMessageSink;
                if (serverAsSink != null)
                    msgCtrl = serverAsSink.AsyncProcessMessage(reqMsg, replySink);
                else
                    msgCtrl = _stackBuilderSink.AsyncProcessMessage(reqMsg, replySink);
            }
            return msgCtrl;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                // We are the terminal sink of this chain
                return null;            
            }
        }
        
    }


   //
   // Terminator sink used for profiling so that we can intercept asynchronous
   // replies on the client side.
   //  
    
    /* package scope */
    internal class ClientAsyncReplyTerminatorSink : IMessageSink
    {
        internal IMessageSink _nextSink;

        internal ClientAsyncReplyTerminatorSink(IMessageSink nextSink)
        {
            BCLDebug.Assert(nextSink != null,
                           "null IMessageSink passed to ClientAsyncReplyTerminatorSink ctor.");
            _nextSink = nextSink;
        }

        public virtual IMessage SyncProcessMessage(IMessage replyMsg)
        {
            // If this class has been brought into the picture, then the following must be true.
            BCLDebug.Assert(RemotingServices.CORProfilerTrackRemoting(),
                            "CORProfilerTrackRemoting returned false, but we're in AsyncProcessMessage!");
            BCLDebug.Assert(RemotingServices.CORProfilerTrackRemotingAsync(),
                            "CORProfilerTrackRemoting returned false, but we're in AsyncProcessMessage!");

            Guid g = Guid.Empty;

            // If GUID cookies are active, then we try to get it from the properties dictionary
            if (RemotingServices.CORProfilerTrackRemotingCookie())
            {
                Object obj = replyMsg.Properties["CORProfilerCookie"];

                if (obj != null)
                {
                    g = (Guid) obj;
                }
            }

            // Notify the profiler that we are receiving an async reply from the server-side
            RemotingServices.CORProfilerRemotingClientReceivingReply(g, true);

            // Now that we've done the intercepting, pass the message on to the regular chain
            return _nextSink.SyncProcessMessage(replyMsg);
        }
    
        public virtual IMessageCtrl AsyncProcessMessage(IMessage replyMsg, IMessageSink replySink)
        {
            // Since this class is only used for intercepting async replies, this function should
            // never get called. (Async replies are synchronous, ironically)
            BCLDebug.Assert(false, "ClientAsyncReplyTerminatorSink.AsyncProcessMessage called!");

            return null;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }
        }

        // Do I need a finalize here?
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\__hresults.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//=============================================================================
//
// Class: __HResults
//
// Purpose: Define HResult constants. Every exception has one of these.
//
// Date: 98/08/31 11:57:11 AM
//
//===========================================================================*/
namespace System.Runtime.Remoting {
	using System;
    internal sealed class __HResults
    {
		public const int COR_E_REMOTING = unchecked((int)0x8013150B);
		public const int COR_E_SERVER = unchecked((int)0x8013150E);		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\threadaffinity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  ThreadAffinity Property for URT Contexts. Uses the ThreadPool API.
//
//  An instance of this property in a context enforces a thread affinity
//  domain for the context (and all contexts that share the same instance).
//  This means that for all contexts sharing an instance of this property,
//  all methods on objects resident in those context will execute on
//  the same thread for the lifetime of the objects.
// 
//  This is done by contributing message sinks that intercept and serialize 
//  in-coming calls. 
//
//  If the property is marked for re-entrancy, then call-outs are 
//  intercepted too. The call-out interception allows other waiting threads
//  to enter the synchronization domain.
//  (testing branch!)
//
namespace System.Runtime.Remoting.Contexts {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System;
    using System.Collections;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Remoting.Activation;

    // FUTURE: override defaults inherited from ContextAttribute!
    /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class)]
    internal class ThreadAffinityAttribute
        : ContextAttribute, IContributeServerContextSink,
                    IContributeClientContextSink
    {
        // The class should not be instantiated in a context that has ThreadAffinity
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.NOT_SUPPORTED"]/*' />
        public const int NOT_SUPPORTED  = 0x00000001;
        
        // The class does not care if the context has ThreadAffinity or not
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.SUPPORTED"]/*' />
        public const int SUPPORTED      = 0x00000002;
    
        // The class should be instantiated in a context that has ThreadAffinity
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.REQUIRED"]/*' />
        public const int REQUIRED    = 0x00000004;
    
        // The class should be instantiated in a context with a new instance of 
        // ThreadAffinity property each time.
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.REQUIRES_NEW"]/*' />
        public const int REQUIRES_NEW = 0x00000008;
    
        private const String PROPERTY_NAME = "ThreadAffinity";
    
        // This is the worker thread (or the ThreadAffinity thread)
        private Thread _thread;
        // Re-Entrancy flag
        private bool _bReEntrant;
    
        // This holds the queues for new and completion work items.
        // This is used by the worker thread. We have to keep the object
        // for the worker thread delegate separate for our cleanup logic
        // to work correctly.
        internal WorkerThreadData _workerData;
        
        // CustomAttribute flag
        private int _flavor;

        // completionSeqNum to track completion calls from call-outs (in re-entrant case)
        private int _completionSeqNum;
    
        internal virtual Queue WorkItemQueue {get {return _workerData._workItemQueue;} }    	
        internal virtual ArrayList CompletionList { get {return _workerData._completionList;} }
        internal virtual bool IsReEntrant { get {return _bReEntrant;} }	
        internal virtual int GetNewCompletionSeqNum() { return Interlocked.Increment(ref _completionSeqNum);}
    
        // FUTURE: attribute syntax needs some thought ... for example
        // how can a Type request that each instance be in a domain of its own
        // or that all instances be in the same domain.
        // How do multiple Types express interest to be in the same
        // thread affinity domain?
        // Also, we must guarantee the ThreadAffinity Sink is the last in any chain!
        
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.ThreadAffinityAttribute"]/*' />
        [Obsolete("Being removed from product. Speak with JHawk!")]
        public ThreadAffinityAttribute()
        
            : this(REQUIRED, false) {
        }
    
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.ThreadAffinityAttribute1"]/*' />
        [Obsolete("Being removed from product. Speak with JHawk!")]
        public ThreadAffinityAttribute(bool bReEntrant)
            : this(REQUIRED, bReEntrant) {
        }
    
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.ThreadAffinityAttribute2"]/*' />
        [Obsolete("Being removed from product. Speak with JHawk!")]
        public ThreadAffinityAttribute(int flag)
            : this(flag, false) {
        }
        
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.ThreadAffinityAttribute3"]/*' />
        [Obsolete("Being removed from product. Speak with JHawk!")]
        public ThreadAffinityAttribute(int flag, bool bReEntrant)
        
            // ContextProperty ctor!
            : base(PROPERTY_NAME) {
            switch (flag)
            {
            case NOT_SUPPORTED:
            case SUPPORTED:
            case REQUIRED:
            case REQUIRES_NEW:
                _flavor = flag;
                break;
            default:
                throw new ArgumentException(
                    String.Format(
                        Environment.GetResourceString("Remoting_ThreadAffinity_InvalidFlag"), flag));
            }        
            _bReEntrant = bReEntrant;
        }
    
        // Override ContextAttribute's implementation of IContextAttribute::IsContextOK
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.IsContextOK"]/*' />
        public override bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            if (ctx == null) 
                throw new ArgumentNullException("ctx");
            if (msg == null) 
                throw new ArgumentNullException("ctorMsg");

            // FUTURE: should we base our answer also on whether the context
            // has Synchronization or not?
            bool isOK = true;
            if (_flavor == REQUIRES_NEW)
            {
                isOK = false;
                // Each activation request instantiates a new attribute class.
                // We are relying on that for the REQUIRES_NEW case!
                BCLDebug.Assert(ctx.GetProperty(PROPERTY_NAME) != this,"ctx.GetProperty(PROPERTY_NAME) != this");
            }
            else
            {
                ThreadAffinityAttribute taProp = (ThreadAffinityAttribute) ctx.GetProperty(PROPERTY_NAME);
                if (   ( (_flavor == NOT_SUPPORTED)&&(taProp != null) )
                    || ( (_flavor == REQUIRED)&&(taProp == null) )
                    )
                {
                    isOK = false;
                }
            }      
            return isOK;
        }
    
        // Override ContextAttribute's impl. of IContextAttribute::GetPropForNewCtx
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.GetPropertiesForNewContext"]/*' />
        public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
        {
            if ( (_flavor==NOT_SUPPORTED) 
                || (_flavor==SUPPORTED) 
                || (null == ctorMsg) )
            {
                return ;
            }
            else
            {
                ctorMsg.ContextProperties.Add((IContextProperty)this);
            }
        }

        // Override IContextProperty::Freeze
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.Freeze"]/*' />
        public override void Freeze(Context ctx)
        {
            // This flag is used by the x-context channel when it 
            // decides whether to use the threadpool or not for
            // async calls.
            // It is also used to do Waits appropriately for outgoing
            // async calls from this context.
            ctx.SetThreadPoolAware();
        }
    
        // We need this to make the use of the property as an attribute 
        // light-weight. This allows us to delay initialize everything we
        // need to fully function as a ContextProperty.
        internal virtual void InitIfNecessary()
        {
            lock(this) 
            {
                if ( _workerData == null )
                {
                    _workerData = new WorkerThreadData(_bReEntrant);
                    _thread = new Thread(new ThreadStart(_workerData.WorkerFunc));
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode() + "] WORKER THREAD CREATE! ID= ["+_thread.GetHashCode()+"]");

                    //This will cause the thread to pump windows messages
                    _thread.ApartmentState = ApartmentState.STA;
                    
                    // Set this to a backGround thread so the EE shuts down 
                    // when other threads are done!
                    _thread.IsBackground = true;
                    //DBG _thread.Name = " >>> Worker <<< ";
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode() + "] WORKER THREAD START!!");        
                    _thread.Start();
                }
            }
        }
        
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.GetServerContextSink"]/*' />
        public virtual IMessageSink GetServerContextSink(IMessageSink nextSink)
        {
            InitIfNecessary();
            return new ThreadAffinityServerContextSink(this, nextSink);
        }
    
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.GetClientContextSink"]/*' />
        public virtual IMessageSink GetClientContextSink(IMessageSink nextSink)
        {
            InitIfNecessary();
            return new ThreadAffinityClientContextSink(this, nextSink);
        }
            
        internal virtual void ShutDownWorkerThread()
        {
            // This is called by the property finalizer
            // This means all contexts that ever used this instance of
            // ThreadAffinity property have been GC-ed    
    
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ===== Called ShutDown on worker thread!");
            if (_workerData != null)
            {
                lock (WorkItemQueue)
                {
                    WorkItemQueue.Enqueue(new TAWorkItem(null,null,null,-1));
                    Monitor.Pulse(WorkItemQueue);
                }
                _thread.Abort();
                _thread = null;
            }
        }
    
        /// <include file='doc\ThreadAffinity.uex' path='docs/doc[@for="ThreadAffinityAttribute.Finalize"]/*' />
        ~ThreadAffinityAttribute()
        {
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ===== Prop::Finalize!");
            ShutDownWorkerThread();
        }

        internal bool IsNestedCall(IMessage reqMsg)
        {
            // This returns TRUE only if it is a non-reEntrant context
            // AND 
            // (the LCID of the reqMsg matches that of 
            // the top level sync call lcid associated with the context.
            //  OR
            // it matches one of the async call out lcids)
            
            bool bNested = false;
            if (!IsReEntrant)
            {
                String lcid = _workerData.SyncCallOutLCID;                
                if (lcid != null)
                {
                    // This means we are inside a top level call
                    LogicalCallContext callCtx = 
                        (LogicalCallContext)reqMsg.Properties[Message.CallContextKey];
                        
                    if (lcid.Equals(callCtx.RemotingData.LogicalCallID))
                    {
                        // This is a nested call (we made a call out during
                        // the top level call and eventually that has resulted 
                        // in an incoming call with the same lcid)
                        bNested = true;
                    }                    
                }
                
                if (!bNested && _workerData.AsyncCallOutLCIDList.Count>0)
                {
                    // This means we are inside a top level call
                    LogicalCallContext callCtx = 
                        (LogicalCallContext)reqMsg.Properties[Message.CallContextKey];
                    if (_workerData.AsyncCallOutLCIDList.Contains(callCtx.RemotingData.LogicalCallID))
                    {
                        bNested = true;
                    }
                }
            }
            return bNested;
        }
    
        // This holds the 2 queues used by the worker thread and the sinks.
        internal class WorkerThreadData 
        {
            // We use this queue to enqueue incoming calls to the worker thread
            internal Queue _workItemQueue;
            // We use this to enque out-of-order completion calls in call-out (reEntrant) case
            internal ArrayList _completionList;
            // If we are re-entrant or not
            internal bool _bReEntrant;
            // Logical call id (used only in non-reentrant case for deadlock avoidance)
            private String _syncLcid;
            private ArrayList _asyncLcidList;
            
            internal WorkerThreadData(bool bReEntrant)
            {
                _workItemQueue = new Queue();
                _completionList = new ArrayList();
                _bReEntrant = bReEntrant;
                _syncLcid = null;
                _asyncLcidList = new ArrayList();
            }

            internal String SyncCallOutLCID
            {
                get 
                { 
                    BCLDebug.Assert(
                        !_bReEntrant, 
                        "Should not use this for the reentrant case");
                        
                    return _syncLcid;
                }

                set
                {
                    BCLDebug.Assert(
                        !_bReEntrant, 
                        "Should not use this for the reentrant case");

                    BCLDebug.Assert(
                        _syncLcid==null 
                            || (_syncLcid!=null && value==null) 
                            || _syncLcid.Equals(value), 
                        "context can be associated with one synchronous logical call at a time");
                    
                    _syncLcid = value;
                }
            }

            internal ArrayList AsyncCallOutLCIDList
            {
                get { return _asyncLcidList; }
            }

            internal bool IsKnownLCID(IMessage reqMsg)
            {
                String msgLCID = 
                    ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey])
                        .RemotingData.LogicalCallID;
                return ( msgLCID.Equals(_syncLcid)
                        || _asyncLcidList.Contains(msgLCID));
                
            }
            
            /*  This is the function that the worker thread executes. 
             *  It just calls MessagePump() with a callID of -1. This means
             *  that MessagePump (and hence the thread) will return when
             *  someone queues a TAWorkItem with a completionSeqNum of -1.
             */
            internal virtual void WorkerFunc()
            {
                MessagePump(-1);
            }
    
            /*  This is the message loop that the worker threads spins in
             *  when waiting for work (or after having made a call out).
             */
            internal virtual IMessage MessagePump(int completionSeqNum)
            {
                // In the reentrant case, the worker thread loops looking
                // for a work-completion message with the expected completionSeqNum              
                
                // This executes till we receive a message with the CompletionSeqNum
                // we are looking for. We terminate the loop if CompletionSeqNum == -1.        
                TAWorkItem work;
                int lastCount = 0;
                while (true)
                {    
                    work = null;
                    // Wait for someone to notify us of work or shutdown
                    lock(_workItemQueue)
                    {
                        if (_workItemQueue.Count == 0)
                        {
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode() + "] MsgPump WORKER: WAIT()!");
    
                            Monitor.Wait(_workItemQueue); 
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode() + "] MsgPump WORKER: woke up!");
                        }
                        work = (TAWorkItem)_workItemQueue.Dequeue();
                    }
                    
                    if (work.CompletionSeqNum > 0)
                    {    
                        // We can get completion messages in this loop only
                        // in the re-entrant case ... where we could be on the
                        // stack multiple times.
                        // The non-re-entrant case uses the SpecialMessagePump
                        // for call-outs.
                        BCLDebug.Assert(
                            _bReEntrant,
                            "Do not expect to be here for non-re-entrant case!");
                    
                        // Check the CompletionSeqNum of this workItem with ours.
                        if (work.CompletionSeqNum == completionSeqNum)
                        {
                            // This is the completion message we were looping for
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] WORKER: MessagePump returning reply");
                            
                            // The request message of this completion message is our 
                            // reply to the original caller!
                            return work.RequestMessage;
                        }
                        else
                        {                            
                            // This is a completion item but not of interest to us, enqueue it to 
                            // a separate completion queue.

                            // Note that things would be better if the most recent
                            // work request completed first from an efficiency point.
                            // In a sense, the delay in a more recent work request 
                            // hurts an earlier work request that got completed 
                            // This is by design (STAs work in this fashion)!
                            
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] *** MessagePump # " + completionSeqNum + " Completion ENQ *** " + work.CompletionSeqNum);
                            _completionList.Add(work);
                            continue;
                        }
                    }
                    else if (work.CompletionSeqNum == -1)
                    {
                        // We post a TAWorkItem with -1 CompletionSeqNum to terminate.
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] **** MessagePump # " + completionSeqNum + " Terminating!");
                        return null;
                    }
    
                    // If we are here we must have real work to be Executed.
                    // Execute the work and notify the blocked waiting thread.
                    
                    BCLDebug.Assert(work.CompletionSeqNum == 0,"work.CompletionSeqNum == 0");
                    work.Execute();
                    lock(work)
                    {
                        Monitor.Pulse(work); 
                        work._reqMsg = null;
                    }
                    
                    // If we are re-entrant then let us first check if 
                    // a completion item with our completionSeqNum is in the completion Queue.
                    // This could happen if the completion item came in while 
                    // the work.Execute() above made a call-out causing the worker
                    // to spin in another MessagePump.            
                    // We need to check only if new items have been added 
                    // after we last checked.            
                    if (_bReEntrant && _completionList.Count > lastCount)
                    {                        
                        // Remember the current count.
                        lastCount = _completionList.Count;
                        
                        // Enumerate the completion list looking for our completionSeqNum
                        // We remove it and return the reply message ... otherwise
                        // we loop waiting for our completion message or new work
                        for (int i=0; i<_completionList.Count; i++)
                        {
                            if (((TAWorkItem)_completionList[i]).CompletionSeqNum == completionSeqNum)
                            {
                                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] *** MessagePump ENUM in completionSeqNum # " + completionSeqNum + "Terminating!");                     
                                IMessage retMsg = ((TAWorkItem)_completionList[i]).RequestMessage;
                                _completionList.RemoveAt(i);
                                return retMsg;
                            }                        
                        }                        
                    }                        
                }// while(true) MessagePump!
            }


            // This specialMessagePump is used to listen for incoming calls
            // or a reply for SYNCHRONOUS call-outs in the non-reentrant case only!
            internal virtual IMessage SpecialMessagePump(int completionSeqNum)
            {
                TAWorkItem work;
                
                BCLDebug.Assert(
                    !_bReEntrant,
                    "This should be used only for non-reentrant case!");
                    
                BCLDebug.Assert(
                    _syncLcid != null,
                    "We expect a top level lcid at this stage!");

                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Special message pump for # " + completionSeqNum);
                while (true)
                {
                    work = null;
                    // Wait for someone to notify us of work or shutdown
                    lock(_completionList)
                    {
                        if (_completionList.Count == 0)
                        {
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMsgPump:WORKER: WAIT()!");
    
                            Monitor.Wait(_completionList); 
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMsgPump:WORKER: woke up!");
                        }
                        
                        work = (TAWorkItem)_completionList[0];
                        _completionList.RemoveAt(0);
                        
                       /* BCLDebug.Assert(
                            _completionList.Count == 0,
                            "Do not expect more than one item ever!");
                            */
                    }
                    // If this is the reply for the callOut, the special message pump's
                    // job is done.
                    if (work.CompletionSeqNum > 0)
                    {                            
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMsgPump: SeqNum = " + work.CompletionSeqNum);

                        if (work.CompletionSeqNum == completionSeqNum)
                        {
                            // request message of the enqueued completion work-item is the reply
                            // of the original call-out.
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMsgPump: Sync->Async call-out returned!");                             
                            IMessage retMsg = work.RequestMessage;
                            lock(work)
                            {
                                Monitor.Pulse(work);
                            }
                            
                            return retMsg;
                        }
                        else
                        {
                            BCLDebug.Assert(
                                work._nextSink!=null,
                                "All other completionSeqNum should correspond to async call-outs!");
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMsgPump: processing reply for AsyncCallOut ");
                            work._replyMsg = work._nextSink.SyncProcessMessage(work.RequestMessage);
                            lock(work)
                            {
                                Monitor.Pulse(work);
                            }
                            
                        }
                    }
                    else
                    {
                        // Else this has to be the logical call we are currently handling 
                        // It has somehow made its way back as an incoming request (p->q->r->p)
                        BCLDebug.Assert(
                            IsKnownLCID(work.RequestMessage),
                            "Do not expect an unknown lcid");

                        BCLDebug.Assert(work.CompletionSeqNum == 0,"work.CompletionSeqNum == 0");
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] SpecialMessagePump: Executing real work nested call-in!");
                        work.Execute();
                        lock(work)
                        {
                            Monitor.Pulse(work); 
                            work._reqMsg = null;
                        }            
                    }
                }
            }
        }
    }
    
    
    //**************************** SERVER SINK ********************************//
    internal class ThreadAffinityServerContextSink 
        : InternalSink, IMessageSink
    {    
        private IMessageSink _nextSink;
        private ThreadAffinityAttribute _prop;
    
        internal ThreadAffinityServerContextSink(ThreadAffinityAttribute prop, IMessageSink nextSink)
        {
            _prop = prop;
            _nextSink = nextSink;
        }
    
        public virtual IMessage SyncProcessMessage(IMessage reqMsg)
        {
            IMessage errMsg = ValidateMessage(reqMsg);
            if (errMsg != null)
            {
                return errMsg;
            }
            
            TAWorkItem work = new TAWorkItem(   
                                    reqMsg, 
                                    null, /* replySink */
                                    _nextSink, 
                                    0); // completionSeqNum


            // If the property is non-reentrant, then we need to check if 
            // we are already executing a top-level call (and if this is a 
            // nested callBack). If that is the case, we queue the work 
            // to the completion list .... otherwise (for new top level calls)
            // we queue the work to the regular workItemQueue.
            bool bNested = _prop.IsNestedCall(reqMsg);

            lock(work)
            {
                if (!bNested)
                {
                    // This is the common case (a fresh top level call)
                    // Use the regular queue to enqueue the work.
                    lock (_prop.WorkItemQueue)
                    {
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Enque New Work (non-nested call-in)");
                        _prop.WorkItemQueue.Enqueue(work);
                        Monitor.Pulse(_prop.WorkItemQueue);
                    }
                }
                else
                {
                    // This is the nested callback case
                    // Use the completionList ... the worker thread
                    // should be waiting on it in the SpecialMessagePump
                    // at this time!
                    BCLDebug.Assert(
                        !_prop.IsReEntrant,
                        "This should not happen for re-entrant contexts");
                        
                    lock (_prop.CompletionList)
                    {
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Enque Nested Call");
                            
                        _prop.CompletionList.Add(work);
                        Monitor.Pulse(_prop.CompletionList);
                    }
                }
                // Wait for the work to be completed
                Monitor.Wait(work);
            }
    
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode() + "] call-in completed!");        
            IMessage replyMsg = work.ReplyMessage;
            work._replyMsg = null;
            return replyMsg;
        }

        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
        {
            IMessage errMsg = ValidateMessage(reqMsg);
            if (errMsg != null)
            {
                if (replySink!=null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {
                TAWorkItem work = new TAWorkItem(
                                            reqMsg,
                                            replySink,
                                            _nextSink,
                                            0); // completionSeqNum
                work.SetAsync();                

                bool bNested = _prop.IsNestedCall(reqMsg);

                if (!bNested)
                {
                    lock(_prop.WorkItemQueue)
                    {                        
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Enque New Work (non-nested call-in)");                    
                        _prop.WorkItemQueue.Enqueue(work);
                        Monitor.Pulse(_prop.WorkItemQueue);
                    }
                }
                else
                {
                    BCLDebug.Assert(
                        !_prop.IsReEntrant,
                        "This should not happen for re-entrant contexts");
                        
                    lock (_prop.CompletionList)
                    {
                        // assert that we deal with only one logical call
                        // at any time
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Enque Nested call to Completion List");                            
                        _prop.CompletionList.Add(work);
                        Monitor.Pulse(_prop.CompletionList);
                    }
                }
            }
            return null;
        }
    
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }
        }
    
#if _DEBUG
        ~ThreadAffinityServerContextSink()
        {            
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ===== Sink::Finalize!");
        }
#endif
    }
    
    //**************************** WORK ITEM ********************************//
    internal class TAWorkItem
    {
        private const int FLG_ASYNC      = 0x0001;
    
        internal IMessage _reqMsg;
        internal IMessage _replyMsg;
        internal IMessageSink _replySink;
        internal IMessageSink _nextSink;
        internal Context _serverContext;
        internal LogicalCallContext _callContext;
        internal int _completionSeqNum;
        internal int _flags;
        //DBG String _forThread;
    
        internal TAWorkItem(IMessage reqMsg, IMessageSink replySink, IMessageSink nextSink, int completionSeqNum)
        {
            _reqMsg = reqMsg;
            _replySink = replySink;
            _nextSink = nextSink;
            _serverContext = Thread.CurrentContext;
            _callContext = CallContext.GetLogicalCallContext();
            _completionSeqNum = completionSeqNum;
            //DBG _forThread = Thread.CurrentThread.Name;
        }
    
        internal virtual IMessage RequestMessage { get { return _reqMsg;} }	
        internal virtual IMessage ReplyMessage { get { return _replyMsg;}}	
        internal virtual int CompletionSeqNum { get { return _completionSeqNum;} }	
    
        internal virtual void SetAsync()
        {
            _flags |= FLG_ASYNC;
        }
        
        internal virtual bool IsAsync()
        {
            return (_flags & FLG_ASYNC) == FLG_ASYNC;
        }
    
        internal virtual void Execute()
        {
            ContextTransitionFrame frame = new ContextTransitionFrame();
            Thread.CurrentThread.EnterContext(_serverContext, ref frame);
            LogicalCallContext oldCallCtx = CallContext.SetLogicalCallContext(_callContext);
            
            if (!IsAsync())
            {
                // Sync case
                // REVIEW: check this assumption for one-way methods!
                _replyMsg = _nextSink.SyncProcessMessage(_reqMsg);
                _serverContext = null;
            }
            else
            {
                // Async case
                // We convert the call to Sync from here since this is 
                // thread affinity!
                // REVIEW: how do we enforce that the next sink will not
                // call AsyncProcMsg instead of Sync?
                if (_nextSink != null)
                {
                    _replyMsg = _nextSink.SyncProcessMessage(_reqMsg);
                }

                // We delegate to the thread pool the job of returning the replyMsg
                // for the async call ... this is so that the ThreadAffinity domain's
                // thread becomes available for other callers.
                WaitCallback threadFunc = new WaitCallback(this.AsyncReply);
                ThreadPool.QueueUserWorkItem(threadFunc);        
            }
            CallContext.SetLogicalCallContext(oldCallCtx);            
            Thread.CurrentThread.ReturnToContext(ref frame);
        }

        internal virtual void AsyncReply(Object stateIgnored)
        {
            ContextTransitionFrame frame = new ContextTransitionFrame();
            Thread.CurrentThread.EnterContext(_serverContext, ref frame);
            LogicalCallContext oldCallCtx = CallContext.SetLogicalCallContext(
                                                            _callContext);
            
            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ThreadPool Thread in AsyncReply!");
            _replySink.SyncProcessMessage(_replyMsg);
            CallContext.SetLogicalCallContext(oldCallCtx);            
            Thread.CurrentThread.ReturnToContext(ref frame);
            _serverContext = null;
        }
             
#if _DEBUG
        ~TAWorkItem()
        {
            //XXX//DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] ##### WorkItem for " + _forThread+" FINALIZE");
        }
#endif
   }
    
    //**************************** CLIENT SINK ********************************//
    
    internal class ThreadAffinityClientContextSink
        : InternalSink, IMessageSink
    {
        internal IMessageSink   _nextSink;
        internal ThreadAffinityAttribute _prop;
    
        internal ThreadAffinityClientContextSink(ThreadAffinityAttribute prop, IMessageSink nextSink)
        {
            _prop = prop;
            _nextSink = nextSink;
        }
        
        /*
        * Implements IMessageSink::SyncProcessMessage
        */
        public virtual IMessage SyncProcessMessage(IMessage reqMsg)
        {
            // This is invoked when a work item being executed
            // makes a SYNCHRONOUS call out of the ThreadAffinity context.

            // We convert the call to Async so the worker thread frees
            // up fast. We provide a ReplySink to intercept the return
            // call on the ReplySink chain.
            
            IMessage errMsg = ValidateMessage(reqMsg);
            if (errMsg != null)
            {
                return errMsg;
            }
            IMessage replyMsg=null;
            
            if (!(reqMsg is IConstructionCallMessage))
            {
                if (!_prop.IsReEntrant)
                {
                    bool bTopLevel = false;
                    LogicalCallContext cctx = 
                        (LogicalCallContext) reqMsg.Properties[Message.CallContextKey];
                                                             
                    String lcid = cctx.RemotingData.LogicalCallID;
                    BCLDebug.Assert(lcid!=null,"Message must have an lcid!");

                    int completionSeqNum = _prop.GetNewCompletionSeqNum();
                    AsyncReplySink mySink = new AsyncReplySink(null, _prop, completionSeqNum);                                  

                    // remember this lcid, we will only allow incoming calls if
                    // their callContext has this lcid!
                    if (_prop._workerData.SyncCallOutLCID == null)
                    {
                        bTopLevel = true;
                        _prop._workerData.SyncCallOutLCID = lcid;
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: TOP LEVEL Sync->AsyncPM Call Out: " + lcid);                        
                    }
                    
                    BCLDebug.Assert(
                        _prop._workerData.SyncCallOutLCID.Equals(lcid),
                        "Context can have only sync-call-out lcid at any time");
                    
                    IMessageCtrl msgCtrl = _nextSink.AsyncProcessMessage(reqMsg, mySink);
                    // Pump messages till we get the reply to this callOut!
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: CallOut: Starting SpecialMessagePump: " + completionSeqNum);

                    replyMsg = _prop._workerData.SpecialMessagePump(completionSeqNum);
                    
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: CallOut: Returned from SpecialMessagePump: " + completionSeqNum);
                    // replyMsg = _nextSink.SyncProcessMessage(reqMsg);
                    
                    if (bTopLevel)
                    {
                        // clear the lcid in the context ... signifying that
                        // the top-level call is done now!
                        _prop._workerData.SyncCallOutLCID = null;     
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: DONE TOP LEVEL Sync->AsyncPM Call Out: " + lcid); 
                    }
                }
                else
                {
                    // If the property is reEntrant ... then we do not worry about
                    // lcid etc ... and just spin up another messagePump that handles
                    // it all
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: Sync->AsyncPM Call Out");
                    
                    int completionSeqNum = _prop.GetNewCompletionSeqNum();
                    AsyncReplySink mySink = new AsyncReplySink(null, _prop, completionSeqNum);                                  
                    IMessageCtrl msgCtrl = _nextSink.AsyncProcessMessage(reqMsg, mySink);
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: Worker returned from AsyncPM call (reply will come later)");
                    // Pump messages till we get the reply to this callOut!
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: CallOut: Starting MessagePump: " + completionSeqNum);
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R: Worker spinning a regular MessagePump for # "+completionSeqNum);
                    replyMsg = _prop._workerData.MessagePump(completionSeqNum);                
                }
            }
            else
            {
                // If it is a constructionCallMessage we skip all of the
                // the magic above (since the terminator sink does not allow
                // async calls for these as of now (9/14/00)
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Allow CTOR Sync Call Out on WorkerThread");
                replyMsg = _nextSink.SyncProcessMessage(reqMsg);
            }         
            return replyMsg;
        }
        
        /*
        * Implements IMessageSink::AsyncProcessMessage
        */
        public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
        {
            IMessage errMsg = ValidateMessage(reqMsg);
            IMessageCtrl msgCtrl = null;

            // This is called when someone makes an ASYNCHRONOUS call out from
            // inside the thread affinity context.

            // Note that we have to provide an interceptor sink whether the domain
            // allows re-entrancy or not. The purpose of the interceptor sink is 
            // to stop the replySink.ProcessMessage call at the domain boundary
            // and queue it to the Worker thread.

            if (errMsg != null)
            {
                if (replySink!=null)
                {
                    replySink.SyncProcessMessage(errMsg);
                }
            }
            else
            {
                if (!_prop.IsReEntrant)
                {                   
                    LogicalCallContext cctx = 
                        (LogicalCallContext) reqMsg.Properties[Message.CallContextKey];
                                                             
                    String lcid = cctx.RemotingData.LogicalCallID;
                    BCLDebug.Assert(lcid!=null,"Message must have an lcid!");

                    BCLDebug.Assert(
                        _prop._workerData.SyncCallOutLCID == null,
                        "Cannot handle async call outs when already in a top-level sync call out");
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Async CallOut: adding to lcidList: " + lcid);                                            
                    _prop._workerData.AsyncCallOutLCIDList.Add(lcid);

                    int completionSeqNum = _prop.GetNewCompletionSeqNum();
                    // AsyncReplySink will remove the lcid added above when the corresponding
                    // reply is received.
                    AsyncReplySink mySink = new AsyncReplySink(replySink, _prop, completionSeqNum);
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR:Async CallOut calling AsyncPM on worker thread");       
                    msgCtrl = _nextSink.AsyncProcessMessage(reqMsg, mySink);
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR:Async CallOut returned from  AsyncPM");       
                }
                else
                {                
                    // We wrap the caller provided replySink into our sink
                    int completionSeqNum = _prop.GetNewCompletionSeqNum();
                    
                    // FUTURE:in this case when the Async call back gets queued,
                    // the Worker thread will have to somehow Peek the queue!
                    AsyncReplySink mySink = new AsyncReplySink(replySink, _prop, completionSeqNum);          

                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R:Async CallOut calling AsyncPM on worker thread");       
        
                    msgCtrl = _nextSink.AsyncProcessMessage(reqMsg, (IMessageSink)mySink);
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R:Async CallOut returned from AsyncPM");       
                }
            }
            return msgCtrl;
        }
    
        /*
        * Implements IMessageSink::NextSink
        */
        public IMessageSink NextSink
        {
            get
            {
                return _nextSink;
            }
        }
    
        internal class AsyncReplySink : IMessageSink
        {
            internal IMessageSink _nextSink;
            internal ThreadAffinityAttribute _prop;
            internal int _completionSeqNum;
            internal bool _bClearLcid;
            
            internal AsyncReplySink(IMessageSink nextSink, ThreadAffinityAttribute prop, int completionSeqNum)
            :   this(nextSink, prop, completionSeqNum, false)
            {
            }
            internal AsyncReplySink(IMessageSink nextSink, ThreadAffinityAttribute prop, int completionSeqNum, bool bClearLcid)
            {
                _nextSink = nextSink;
                _prop = prop;
                _completionSeqNum = completionSeqNum;
                _bClearLcid = bClearLcid;
            }
    
            public virtual IMessage SyncProcessMessage(IMessage reqMsg)
            {
                IMessage errMsg = ValidateMessage(reqMsg);
                if (errMsg != null)
                {
                    return errMsg;
                }

                // Note: this reqMsg is actually the reply for an async process message
                // call someone made out of the thread affinity context
                
                // We handle this as a regular new Sync workItem
                // 1. Create a work item 
    
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] %%%%% AsyncReplySink called %%%%% for # "+_completionSeqNum);
                TAWorkItem work = new TAWorkItem(
                                        reqMsg,
                                        null /* replySink */,
                                        _nextSink,
                                        _completionSeqNum);

                // Determine which list to put the request (i.e. the reply) in
                // (bNested is always false for non-reentrant context)
                bool bNested = _prop.IsNestedCall(reqMsg);
                
                // put the work in queue just like regular Sync work               
               
                lock(work)
                {
                    // FUTURE: the async reply may starve if other requests are ahead in 
                    // the queue.
                    if (_prop.IsReEntrant) 
                    {
                        // For the reEntrant case, the workItemQueue is used
                        // for everything (fresh work and replies)
                        
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] R:Intercepted reply, queued to WQ");
                        lock(_prop.WorkItemQueue)
                        {
                            _prop.WorkItemQueue.Enqueue(work);
                            Monitor.Pulse(_prop.WorkItemQueue);
                        }
                    }
                    else if (reqMsg is IConstructionReturnMessage)
                    {
                        // Special treatment for CTOR msgs (for now!)
                        //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] Intercepted CTOR reply, queued to WQ (special case)");
                        lock(_prop.WorkItemQueue)
                        {
                            _prop.WorkItemQueue.Enqueue(work);
                            Monitor.Pulse(_prop.WorkItemQueue);
                        }

                    }
                    else                    
                    {
                        // If we are non-reEntrant and this is a sync reply 
                        // (i.e. a sync call out just finished) then we use
                        // the completion queue.
                        
                        BCLDebug.Assert(
                            !_prop.IsReEntrant,
                            "This should not happen for re-entrant contexts");

                        // FUTURE ... there is a small race situation here ... we are
                        // using SyncCallOutLCID!=NULL to decide which queue to enqueue
                        // this reply ... but another thread might just have finished 
                        // a SyncCallOut and may be in the process of setting this to 
                        // NULL ... so we will hang because the SpecialMessagePump is 
                        // no more spinning.
                        if (_prop._workerData.SyncCallOutLCID != null)
                        {
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Intercepted reply queuing to CompletionList");                        
                            lock (_prop.CompletionList)
                            {                                    
                                _prop.CompletionList.Add(work);
                                Monitor.Pulse(_prop.CompletionList);
                            }
                        }
                        else
                        {
                            //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: Intercepted reply queuing to WQ");                        
                            lock(_prop.WorkItemQueue)
                            {
                                _prop.WorkItemQueue.Enqueue(work);
                                Monitor.Pulse(_prop.WorkItemQueue);
                            }
                        }
                    }
                    // Wait for the work to be completed
                    Monitor.Wait(work);
                }

                // If this is an async call-out completion 
                // for nonReEntrant case we should remove the lcid from the asyncCalloutList.
                if (bNested && _nextSink!=null)
                {
                    //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] NR: InterceptionSink::SyncPM Removing async call-out lcid: " + ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey]).RemotingData.LogicalCallID);                   
                    _prop._workerData.AsyncCallOutLCIDList.Remove(
                        ((LogicalCallContext)reqMsg.Properties[Message.CallContextKey]).RemotingData.LogicalCallID);
                }
    
                //DBGConsole.WriteLine(Thread.CurrentThread.GetHashCode()+"] %%%%% AsyncReplySink callback done %%%%%");
                // 3. Pick up retMsg from the WorkItem and return
                return work.ReplyMessage;                    
            }
    
            public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
            {
                // The replySink of an async call should be called only synchronously!
                throw new NotSupportedException();
            }
    
            /*
            * Implements IMessageSink::NextSink
            */
            public IMessageSink NextSink
            {
                get
                {
                    return _nextSink;
                }
            }
    
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\urlattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    UrlAttribute.cool
**
** Author:  Tarun Anand (TarunA)
**
** Purpose: Defines an attribute which can be used at the callsite to
**          specify the URL at which the activation will happen.
**
** Date:    March 30, 2000
**
===========================================================*/
namespace System.Runtime.Remoting.Activation {
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Messaging;
    using System.Security.Permissions;	
    using System;
    /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute"]/*' />
    [Serializable]
    public sealed class UrlAttribute : ContextAttribute
    {
        private String url;
        private static String propertyName = "UrlAttribute";

        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.UrlAttribute"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public UrlAttribute(String callsiteURL) :base(propertyName)
        {
            if(null == callsiteURL)
            {
                // Invalid arg
                throw new ArgumentNullException("callsiteURL");
            }
            url = callsiteURL;
        }        
        
        // Object::Equals
        // Override the default implementation which just compares the names
        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.Equals"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public override bool Equals(Object o)
        {
            return (o is IContextProperty) && (o is UrlAttribute) && 
                   (((UrlAttribute)o).UrlValue.Equals(url));
        }

        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.GetHashCode"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public override int GetHashCode()
        {
            return this.url.GetHashCode();
        }
        
        // Override ContextAttribute's implementation of IContextAttribute::IsContextOK
        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.IsContextOK"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public override bool IsContextOK(Context ctx, IConstructionCallMessage msg)
        {
            return false;
        }
    
        // Override ContextAttribute's impl. of IContextAttribute::GetPropForNewCtx
        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.GetPropertiesForNewContext"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public override void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
        {
            // We are not interested in contributing any properties to the
            // new context since the only purpose of this property is to force
            // the creation of the context and the server object inside it at
            // the specified URL.
            return;
        }
        
        /// <include file='doc\URLAttribute.uex' path='docs/doc[@for="UrlAttribute.UrlValue"]/*' />
        public String UrlValue
        {
	    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
            get { return url; }            
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\deserializationeventhandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: DeserializationEventHandler
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The multicast delegate called when the DeserializationEvent is thrown.
**
** Date:  August 16, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {

	[Serializable()]
    internal delegate void DeserializationEventHandler(Object sender);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\__transparentproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    __TransparentProxy.cool
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines Transparent proxy
**
** Date:    Feb 16, 1998
**
===========================================================*/
namespace System.Runtime.Remoting.Proxies {
	using System.Runtime.Remoting;
    // Transparent proxy and Real proxy are vital pieces of the
    // remoting data structures. Transparent proxy magically
    // creates a message that represents a call on it and delegates
    // to the Real proxy to do the real remoting work.
	using System;
    internal sealed class __TransparentProxy {
        // Created inside EE
        private __TransparentProxy() {
           throw new NotSupportedException(Environment.GetResourceString(ResId.NotSupported_Constructor));
        }
        
        // Private members
        private RealProxy _rp;          // Reference to the real proxy
        private Object    _stubData;    // Data used by stubs to decide whether to short circuit calls or not
        private IntPtr _pMT;            // Method table of the class this proxy represents
        private IntPtr _pInterfaceMT;   // Cached interface method table		
        private IntPtr _stub;           // Unmanaged code that decides whether to short circuit calls or not
     
 		// This method should never be called.  Its sole purpose is to shut up the compiler
		//	because it warns about private fields that are never used.  Most of these fields
		//	are used in unmanaged code.
#if _DEBUG
		private int NeverCallThis()
		{
			BCLDebug.Assert(false,"NeverCallThis");
			_rp = null;
			_pMT = new IntPtr(RemotingServices.TrashMemory);
			_pInterfaceMT = new IntPtr(RemotingServices.TrashMemory);
            _stub = new IntPtr(RemotingServices.TrashMemory);
			RealProxy rp = _rp;
			return _pInterfaceMT.ToInt32();
		}
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\remoting\remotingservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemotingServices.cs
**
** Author(s):   Gopal Kakivaya (GopalK)
**              Tarun Anand    (TarunA)
**
** Purpose: Defines various remoting related services such as
**          marshal, unmarshal, connect, wrap, unwrap etc.
**
** Date:    Feb 16, 1999
**
===========================================================*/
namespace System.Runtime.Remoting {
    using System;
    using System.Text;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.IO;
    using System.Reflection;
    using System.Reflection.Cache;
    using System.Runtime.CompilerServices;
    using CultureInfo = System.Globalization.CultureInfo;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Remoting.Lifetime;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Metadata;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Services;
    using RemotingConfigInfo = System.Runtime.Remoting.RemotingConfigHandler.RemotingConfigInfo;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Security.Permissions;

    // Implements various remoting services
    /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices"]/*' />
    public sealed class RemotingServices
    {

        private const BindingFlags LookupAll = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static;
        private const String FieldGetterName = "FieldGetter";
        private const String FieldSetterName = "FieldSetter";
        private const String IsInstanceOfTypeName = "IsInstanceOfType";
        private const String CanCastToXmlTypeName = "CanCastToXmlType";
        private const String InvokeMemberName = "InvokeMember";

        internal static SecurityPermission s_RemotingInfrastructurePermission;
        internal static Assembly s_MscorlibAssembly;
        private static MethodBase s_FieldGetterMB;
        private static MethodBase s_FieldSetterMB;
        private static MethodBase s_IsInstanceOfTypeMB;
        private static MethodBase s_CanCastToXmlTypeMB;
        private static MethodBase s_InvokeMemberMB;

        private static bool s_bRemoteActivationConfigured;

        // have we registered the well known channels
        private static bool s_bRegisteredWellKnownChannels;
        // are we in the middle of registering well known channels
        private static bool s_bInProcessOfRegisteringWellKnownChannels;
        private static Object s_delayLoadChannelLock;

        // Note: This class can be loaded into a new appdomain before the appdomain is fully setup
        // security-wise.  Therefore, I've wrapped all the static initialization into an explicit
        // static class initializer and placed an assert that will terminate any stackwalk before
        // it reaches the appdomain transition.

        static RemotingServices()
        {
            System.Security.CodeAccessPermission.AssertAllPossible();
            s_RemotingInfrastructurePermission= new SecurityPermission(SecurityPermissionFlag.Infrastructure);
            s_MscorlibAssembly = typeof(RemotingServices).Assembly;
            s_FieldGetterMB = null;
            s_FieldSetterMB = null;
            s_bRemoteActivationConfigured = false;
            s_bRegisteredWellKnownChannels = false;
            s_bInProcessOfRegisteringWellKnownChannels = false;
            s_delayLoadChannelLock = new Object();
        }

       //   Private constructor to prevent users from creating instances of
       //   remoting services class.
       //
       //
        private RemotingServices()
        {
        }

        //
        //Native Static Methods
        //

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsTransparentProxy"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern bool IsTransparentProxy(Object proxy);


       //   Check whether the given object's context is the same as
       //   the current context.
       //   
       //
       //
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsObjectOutOfContext"]/*' />
        public static bool IsObjectOutOfContext(Object tp)
        {
            if (!IsTransparentProxy(tp))
            {
                return false;
            }

            RealProxy rp = GetRealProxy(tp);
            Identity id = rp.IdentityObject;
            ServerIdentity serverID = id as ServerIdentity;
            if ((null == serverID) || !(rp is RemotingProxy))
            {
                return true;
            }

            return(Thread.CurrentContext != serverID.ServerContext);
        }


       //   Check whether the given object's app domain is the same as
       //   the current app domain
       //   
       //
       //
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsObjectOutOfAppDomain"]/*' />
        public static bool IsObjectOutOfAppDomain(Object tp)
        {
            return IsClientProxy(tp);        
        } // IsObjectOutOfAppDomain


        internal static bool IsClientProxy(Object obj)
        {
            MarshalByRefObject mbr = obj as MarshalByRefObject;
            if (mbr == null)
                return false;
        
            bool bIsClientProxy = false;
        
            bool fServer;
            Identity id = MarshalByRefObject.GetIdentity(mbr, out fServer);
            // If the identity is null, this is defintely a locally hosted object;
            // otherwise...(see if statement below).
            if (id != null)
            {
                if (!(id is ServerIdentity))
                    bIsClientProxy = true;
            }

            return bIsClientProxy;
        } // IsClientProxy
         

       //   Check whether the given object's process is the same as
       //   the current process
       //   
       //
       //
        // <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsObjectOutOfProcess"]/*' />
        internal static bool IsObjectOutOfProcess(Object tp)
        {
            if (!IsTransparentProxy(tp))
                return false;

            RealProxy rp = GetRealProxy(tp);
            Identity id = rp.IdentityObject;
            if (id is ServerIdentity)
                return false;
            else
            {
                if (null != id)
                {
                    ObjRef objRef = id.ObjectRef;
                    if (objRef != null && objRef.IsFromThisProcess())
                    {
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
                // assume out of process
                return true;
            }
              
        } // IsObjectOutOfProcess

       //   Get the real proxy backing the transparent proxy
       //   
       //
       //
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetRealProxy"]/*' />
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static extern RealProxy GetRealProxy(Object proxy);


       //   Create a transparent proxy given an instance of a real proxy and type
       //
       //
       //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object CreateTransparentProxy(
                                            RealProxy rp,
                                            RuntimeType typeToProxy,
                                            IntPtr stub,
                                            Object stubData);
                                           
        // Note: for each of these calls that take a RuntimeXXX reflection
        // structure, there is a wrapper that takes XXX and throws if it is
        // not a RuntimeXXX. This is to avoid clutter in code where these 
        // methods are called. (48721) Ideally this should have been done
        // as a breaking change to the public APIs that use them!

        internal static Object CreateTransparentProxy(
            RealProxy rp,
            Type typeToProxy,
            IntPtr stub,
            Object stubData)
        {
            RuntimeType rTypeToProxy = typeToProxy as RuntimeType;
            if (rTypeToProxy == null)
                throw new ArgumentException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Argument_WrongType"),
                                "typeToProxy"
                                )
                            );

            return CreateTransparentProxy(
                        rp,
                        rTypeToProxy,
                        stub,
                        stubData);
        }



       //   Allocate an uninitialized object of the given type.
       //   
       //
       //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern MarshalByRefObject AllocateUninitializedObject(
                                                    RuntimeType objectType);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CallDefaultCtor(Object o);


        internal static MarshalByRefObject AllocateUninitializedObject(
            Type objectType)
        {
            RuntimeType rObjectType = objectType as RuntimeType;
            if (rObjectType == null)
                throw new ArgumentException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Argument_WrongType"),
                                "objectType"
                                )
                            );
            return AllocateUninitializedObject(
                        rObjectType);
        }
        
       //   Allocate an Initialized object of the given type.
       //       runs the default constructor
       //
       //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern MarshalByRefObject AllocateInitializedObject(
                                                        RuntimeType objectType);


        internal static MarshalByRefObject AllocateInitializedObject(
            Type objectType)
        {
            RuntimeType rObjectType = objectType as RuntimeType;
            if (rObjectType == null)
                throw new ArgumentException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Argument_WrongType"),
                                "objectType"
                                )
                            );
            return AllocateInitializedObject(
                        rObjectType);
        }


        internal static bool RegisterWellKnownChannels()
        {
            // Any code coming through this method MUST not exit
            //   until the well known channels have been registered
            //   (unless we are reentering in the call to 
            //    RefreshChannelData() while registering a well known
            //    channel).
            if (!s_bRegisteredWellKnownChannels)
            {
                lock (Thread.GetDomain().RemotingData.ConfigLock)
                {
                    if (!s_bRegisteredWellKnownChannels &&
                        !s_bInProcessOfRegisteringWellKnownChannels)
                    {

                        // we set this flag true before registering channels to prevent reentrancy
                        //   when we go to refresh the channel data at the end of the call to
                        //   ChannelServices.RegisterChannel().
                        s_bInProcessOfRegisteringWellKnownChannels = true;
                        CrossAppDomainChannel.RegisterChannel();
                        s_bRegisteredWellKnownChannels = true;
                    }
                }
            }
            return true;
        } // RegisterWellKnownChannels


        internal static void InternalSetRemoteActivationConfigured()
        {
            if (!s_bRemoteActivationConfigured)
            {           
                nSetRemoteActivationConfigured();
                s_bRemoteActivationConfigured = true;
            }
        } // InternalSetRemoteActivationConfigured


        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void nSetRemoteActivationConfigured();


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetSessionIdForMethodMessage"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static String GetSessionIdForMethodMessage(IMethodMessage msg)
        {
            return msg.Uri;
        } // GetSessionIdForMessage

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetLifetimeService"]/*' />
        public static Object GetLifetimeService(MarshalByRefObject obj)
        {
            if(null != obj)
            {
                return obj.GetLifetimeService();
            }
            else
            {
                return null;
            }
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetObjectUri"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static String GetObjectUri(MarshalByRefObject obj)
        {
            // Retrieve the uri for the object. If it doesn't have an identity
            //   we'll just return null (this encompasses the case of an actual
            //   object not having been marshalled yet.

            bool fServer;
            Identity id = MarshalByRefObject.GetIdentity(obj, out fServer);

            if(null != id) 
                return id.URI;
            else
                return null;
        } // GetObjectUri


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.SetObjectUriForMarshal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static void SetObjectUriForMarshal( MarshalByRefObject obj, String uri)
        {
            // if obj is ever Marshal'd it should use this uri. If a uri has
            //   already been assigned to the object, it should throw.
            
            Message.DebugOut("Entered SetObjectUriForMarshal \n");
                    
            Identity idObj = null;
            Identity srvIdObj = null;
            
            bool fServer;
            idObj = MarshalByRefObject.GetIdentity(obj, out fServer);
            srvIdObj = idObj as ServerIdentity;
            
            // Ensure that if we have a transparent proxy then we are not given a remoting
            // proxy. This routine should only be called for objects that
            // live in this AppDomains.
            if ((idObj != null) && 
                (srvIdObj == null)) // <-- means idObj is not a ServerIdentity
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_SetObjectUriForMarshal__ObjectNeedsToBeLocal"));
            }


            if ((idObj != null) && (idObj.URI != null))
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_SetObjectUriForMarshal__UriExists"));
            }
            

            if (idObj == null)
            {
                // obj is not ContextBound
                BCLDebug.Assert(!(obj is ContextBoundObject), "ContextBoundObject's shouldn't get here.");
            
                // Create a new server identity and add it to the
                // table. IdentityHolder will take care of races
                Context serverCtx = null;
                
                serverCtx = Thread.GetDomain().GetDefaultContext();

                BCLDebug.Assert(null != serverCtx, "null != serverCtx");
    
                ServerIdentity serverID = new ServerIdentity(obj, serverCtx, uri);

                // set the identity 
                idObj = obj.__RaceSetServerIdentity(serverID);
                BCLDebug.Assert(idObj == MarshalByRefObject.GetIdentity(obj), "Bad ID state!" );                

                // If our serverID isn't used then someone else marshalled the object
                // before we could set the uri.
                if (idObj != serverID)
                {
                    throw new RemotingException(
                        Environment.GetResourceString(
                            "Remoting_SetObjectUriForMarshal__UriExists"));
                }
            }
            else
            {
                // This is the ContextBoundObject case
                BCLDebug.Assert(obj is ContextBoundObject, "Object should have been a ContextBoundObject.");

                idObj.SetOrCreateURI(uri, true);
            }

            Message.DebugOut("Created ServerIdentity \n");                        
        } // SetObjectUriForMarshal


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Marshal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ObjRef Marshal(MarshalByRefObject Obj)
        {
            return MarshalInternal(Obj, null, null);
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Marshal1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ObjRef Marshal(MarshalByRefObject Obj, String URI)
        {
            return MarshalInternal(Obj, URI, null);
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Marshal2"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.RemotingConfiguration)]
        public static ObjRef Marshal(MarshalByRefObject Obj, String ObjURI, Type RequestedType)
        {
            return MarshalInternal(Obj, ObjURI, RequestedType);
        }

        // Internal flavor without security!
        internal static ObjRef MarshalInternal(MarshalByRefObject Obj, String ObjURI, Type RequestedType)
        {        
            BCLDebug.Trace("REMOTE", "Entered Marshal for URI" +  ObjURI + "\n");

            if (null == Obj)
                return null;

            ObjRef objectRef = null;
            Identity idObj = null;

            idObj = GetOrCreateIdentity(Obj, ObjURI);
            if (RequestedType != null)
            {
                ServerIdentity srvIdObj = idObj as ServerIdentity;
                if (srvIdObj != null)
                {
                    // If more than one thread, marshals with different types the 
                    // results would be non-deterministic, so we just let the last
                    // call win (also allows type to be marshalled a second time
                    // to change the exposed type).
                    srvIdObj.ServerType = RequestedType;
                    srvIdObj.MarshaledAsSpecificType = true;                    
                }
            }

            // If there is no objref associated with the identity then go ahead
            // and create one and stick it back into the identity object

#if _DEBUG
            idObj.AssertValid();
#endif

            BCLDebug.Assert(null != idObj.ObjURI,"null != idObj.ObjURI");

            Message.DebugOut("RemotingServices::Marshal: trying to create objref\n");

            // We should definitely have an identity object at this point of time
            BCLDebug.Assert(null != idObj,"null != idObj");

            // Extract the objref from the identity
            objectRef = idObj.ObjectRef;
            if (null == objectRef)
            {
                Message.DebugOut("RemotingServices::Marshal: really trying to create objref\n");

                if (IsTransparentProxy(Obj))
                {
                    RealProxy realProxy = GetRealProxy(Obj);
                    BCLDebug.Assert(null != realProxy,"null != realProxy");
                    objectRef = realProxy.CreateObjRef(RequestedType);    
                }
                else
                {
                    // Create a new object ref which contains the default information
                    objectRef = Obj.CreateObjRef(RequestedType);
                }

                Message.DebugOut("RemotingServices::Marshal: created objref\n");
                BCLDebug.Assert(null != idObj,"null != idObj");
                BCLDebug.Assert(null != objectRef,"null != objectRef");
                // The ObjectRef property setter will take care of races
                objectRef = idObj.RaceSetObjRef(objectRef);                
            }


            // Retime lease on every marshal on the server side 
            // and extend lease on every marshal on the client side - GopalK
            ServerIdentity srvId = idObj as ServerIdentity;
            if (srvId != null)
            {
                // Ensure that the lease is started soon as the object is 
                // marshaled.
                MarshalByRefObject obj = null;
                // This call forces creation of the lifetime lease sink.
                srvId.GetServerObjectChain(out obj);    

                // Server side ... object being marshaled => give it another
                // full lease
                Lease lease = idObj.Lease;
                if (lease != null)
                {
                    // We always make Identity reference our own Lease though 
                    // the actual object implements its own ILease object. 
                    // This seems completely broken. Further, ILease interface 
                    // should have the activate method.  - GopalK

                    // This lock ensures coordination with the lifetime service
                    // which might have decided to Disconnect the object about
                    // the same time as it is being marshaled
                    lock (lease)
                    {
                        if (lease.CurrentState == LeaseState.Expired)
                        {
                            // Lease.Renew is a no-op if LeaseState==Expired
                            // So we do a full ActivateLease
                            lease.ActivateLease();
                        }
                        else
                        {
                            // Lease is still around. Just increase the time
                            lease.RenewInternal(idObj.Lease.InitialLeaseTime);
                        }
                    }
                }

                // Every marshal should also ensure that the channel data
                // being carried in the objRef reflects the latest data from
                // regisetered channels
                // FUTURE: need to deal with extensible objRefs?
                if (objectRef.ChannelInfo != null)
                {
                    objectRef.ChannelInfo.ChannelData = 
                       ChannelServices.CurrentChannelData;
                }
            }
            else
            {
                /*FUTURE: we need to review the perf implications of this
                // Client side ... proxy being marshaled => give it another
                // extension .. support for middleman case where the current
                // process is only passing an objref on to the actual client
                // process
                ILease lease = idObj.Lease;
                if (lease == null)
                {
                    lease = (ILease)Obj.GetLifetimeService();
                }
                if (lease != null)
                {
                    lease.Renew(lease.RenewOnCallTime);
                }
                */
            }

            // Notify TrackingServices that an object has been marshaled
            // NOTE: This call also keeps the object alive otherwise GC
            // can report it as dead anytime inside this call when it thinks
            // that the object will no longer be referenced, either inside
            // this call or outside.
            /* GopalK: Move it to a place where we call tracking services only 
            when we really marshalled or remarshaled an object */
            TrackingServices.MarshaledObject(Obj, objectRef);                               
            return objectRef;
        }

        // Gets or generates the identity if one is not present and then returns
        // it to the caller.
        private static Identity GetOrCreateIdentity(
            MarshalByRefObject Obj,
            String ObjURI)
        {
            Identity idObj = null;
            if (IsTransparentProxy(Obj))
            {
                Message.DebugOut("Marshaling proxy \n");

                RealProxy realProxy = GetRealProxy(Obj);
                BCLDebug.Assert(null != realProxy,"null != realProxy");

                idObj = realProxy.IdentityObject;
                if(null == idObj)
                {
                    // passing the strongIdentity flag will ensure that a weak
                    // reference to the identity will get converted to a strong
                    // one so as to keep the object alive (and in control of
                    // lifeTimeServices)

                    idObj = IdentityHolder.FindOrCreateServerIdentity(
                                                Obj,
                                                ObjURI,
                                                IdOps.StrongIdentity);

                    idObj.RaceSetTransparentProxy(Obj);
                }

                // At this point of time we should have an identity
                BCLDebug.Assert(null != idObj, "null != idObj");


                ServerIdentity srvID = idObj as ServerIdentity;
                if (srvID != null)
                {
                    // We are marshaling a proxy with a serverIdentity 
                    // associated with it but with no URI generated yet.
                    // For a genuine proxy case we will always have a URI 
                    // AND it will be  a client ID! 
                    // So if we are here this must be a SrvID 
                    // for a ContextBoundObject
                    BCLDebug.Assert(srvID != null && Obj is ContextBoundObject,
                        "This case should only be hit for ContextBoundObjects & ServerIdentity!");
                    Message.DebugOut("Marshal::Looking up server side identity \n");
#if _DEBUG
                    srvID.AssertValid();
#endif

                    // passing the strongIdentity flag will ensure that a weak
                    // reference to the identity will get converted to a strong
                    // one so as to keep the object alive (and in control of
                    // lifeTimeServices)

                    idObj = IdentityHolder.FindOrCreateServerIdentity(
                                srvID.TPOrObject,
                                ObjURI,
                                IdOps.StrongIdentity);

                    // if an objURI was specified we need to make sure that
                    //   the same one was used.
                    if ((null != ObjURI) && 
                        (ObjURI != Identity.RemoveAppNameOrAppGuidIfNecessary(
                                                idObj.ObjURI)))
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_URIExists"));
                    }

                    // We create a unique ID for an object and never 
                    // change it!
                    BCLDebug.Assert(srvID == idObj, "Bad ID Table state!");
                }
                else
                {
                    // We are marshaling a proxy with a (client)Identity associated with it
                    // It must already have a URI.
                    Message.DebugOut("Marshal::Client side identity \n");
                    BCLDebug.Assert(idObj.ObjURI != null, "Client side id without URI!");

                    //
                    // One cannot associate a URI with a proxy generated by us
                    // because either a URI was generated at the server side for the object
                    // it represents or it is a well known object in which case the URI is known.
                    //
                    // For custom proxies this restriction is relaxed because we treat the
                    // transparent proxy as the server object for such cases.
                    //
                    if ((null != ObjURI) && (ObjURI != idObj.ObjURI))
                    {
                        throw new RemotingException(
                            Environment.GetResourceString(
                                "Remoting_URIToProxy"));
                    }
                }

                BCLDebug.Assert(null != idObj.ObjURI,"null != idObj.ObjURI");
            }
            else
            {
                // Find or Add the object identity to the identity table
                Message.DebugOut("Marshaling object \n");

                // passing the strongIdentity flag will ensure that a weak
                // reference to the identity will get converted to a strong
                // one so as to keep the object alive (and in control of
                // lifeTimeServices)

                // The object may have an ID if it was marshaled but its lease
                // timed out.
#if _DEBUG
                ServerIdentity idTmp = 
                    (ServerIdentity) MarshalByRefObject.GetIdentity(Obj);
#endif
                
                                    

                idObj = IdentityHolder.FindOrCreateServerIdentity(
                                            Obj,
                                            ObjURI,
                                            IdOps.StrongIdentity);

                // If the object had an ID to begin with that is the one 
                // we must have set in the table.                                                    
#if _DEBUG
                BCLDebug.Assert(idTmp==null || idTmp == idObj, "Bad ID Table state!");
#endif
            }

            return idObj;
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static void GetObjectData(Object obj, SerializationInfo info, StreamingContext context)
        {
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }
            
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            
            ObjRef or = RemotingServices.MarshalInternal(
                                            (MarshalByRefObject)obj,
                                            null,
                                            null);

            or.GetObjectData(info, context);
        } // GetObjectData

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Unmarshal"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static Object Unmarshal(ObjRef objectRef)
        {
            return InternalUnmarshal(objectRef, null, false);
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Unmarshal1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static Object Unmarshal(ObjRef objectRef, bool fRefine)
        {
            return InternalUnmarshal(objectRef, null, fRefine);
        }


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Connect"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.RemotingConfiguration)]	
        public static Object Connect(Type classToProxy, String url)
        {               
            return Unmarshal(classToProxy, url, null);
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Connect1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.RemotingConfiguration)]	
        public static Object Connect(Type classToProxy, String url, Object data)
        {               
            return Unmarshal(classToProxy, url, data);
        }


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.Disconnect"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static bool Disconnect(MarshalByRefObject obj)
        {
            return Disconnect(obj, true);
        }
        
        internal static bool Disconnect(MarshalByRefObject obj, bool bResetURI)
        {
            BCLDebug.Trace("REMOTE", "RemotingServices.Disconnect ",obj, " for context ", Thread.CurrentContext);
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }

            // We can extract the identity either from the remoting proxy or
            // the server object depending on whether we are in the
            // context/appdomain that the object was created in or outside
            // the context/appdomain.
            bool fServer;
            Identity idrem = MarshalByRefObject.GetIdentity(obj, out fServer);

            // remove the identity entry for this object (if it exists)
            bool fDisconnect = false;
            if(idrem != null) 
            {
                // Disconnect is supported only on the server side currently
                if(idrem is ServerIdentity)
                {
                    // Disconnect is a no op if the object was never marshaled
                    if(idrem.IsInIDTable())
                    {
                        // When a user calls Disconnect we reset the URI but
                        // when lifetime service calls Disconnect we don't
                        IdentityHolder.RemoveIdentity(idrem.URI, bResetURI);
                        fDisconnect = true;
                    }
                }
                else
                {
                    // FUTURE: Look into supporting it on the client side
                    // as well - GopalK
                    throw new RemotingException(
                        Environment.GetResourceString("Remoting_CantDisconnectClientProxy"));
                }

                // Notify TrackingServices that an object has been disconnected
                TrackingServices.DisconnectedObject(obj);
            }

            Message.DebugOut("Disconnect:: returning " + fDisconnect +
                             " for context " + Thread.CurrentContext +
                             "\n");

            return fDisconnect;
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetEnvoyChainForProxy"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj)
        {
            IMessageSink envoyChain = null;

            // Extract the envoy chain only if the object is a proxy
            if(IsObjectOutOfContext(obj))
            {
                RealProxy rp = GetRealProxy(obj);   
                Identity id = rp.IdentityObject;
                if(null != id)
                {
                    envoyChain = id.EnvoyChain;
                }
            }

            return envoyChain;
        }

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetObjRefForProxy"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static ObjRef GetObjRefForProxy(MarshalByRefObject obj)
        {
            ObjRef objRef = null;
            if (!IsTransparentProxy(obj))
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_Proxy_BadType"));
            }
            RealProxy rp = GetRealProxy(obj);
            Identity id = rp.IdentityObject;
            if (null != id)
            {
                objRef = id.ObjectRef;
            }
            return objRef;
        }
        
        internal static Object Unmarshal(Type classToProxy, String url)
        {
            return Unmarshal(classToProxy, url, null);
        }


        internal static Object Unmarshal(Type classToProxy, String url, Object data)
        {           
            if (null == classToProxy)
            {
                throw new ArgumentNullException("classToProxy");
            }

            if (null == url)
            {
                throw new ArgumentNullException("url");
            }

            if (!classToProxy.IsMarshalByRef && !classToProxy.IsInterface)
            {
                throw new RemotingException(
                    Environment.GetResourceString(
                        "Remoting_NotRemotableByReference"));
            }

            BCLDebug.Trace("REMOTE", "RemotingService::Unmarshal for URL" + url + "and for Type" + classToProxy);

            // See if we have already unmarshaled this (wellKnown) url
            Identity idObj = IdentityHolder.ResolveIdentity(url);
            Object proxy = null;
            if (idObj == null 
                || idObj.ChannelSink == null || idObj.EnvoyChain == null)
            {

                String objectURI = null;
                IMessageSink chnlSink = null;
                IMessageSink envoySink = null;
                // Create the envoy and channel sinks
                objectURI = CreateEnvoyAndChannelSinks(url, data, out chnlSink, out envoySink);

                // ensure that we were able to create a channel sink
                if (chnlSink == null)
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_Connect_CantCreateChannelSink"),
                            url));
                }

                // Do not allow Connect() with null objUri (eg. http://localhost/)
                if (objectURI == null)
                {
                    throw new ArgumentException(
                        Environment.GetResourceString(
                            "Argument_InvalidUrl"));

                }

                // GopalK: Return the server object if the object uri is in the IDTable and is of type 
                // ServerIdentity and the object URI starts with application name
                /*
                ServerIdentity srvId = 
                    IdentityHolder.ResolveIdentity(objectURI) as ServerIdentity;
                if (srvId != null 
                    && objectURI.StartsWith(RemotingConfigHandler.ApplicationName))
                {
                    return srvId.ServerObject;
                }
                */
                    

                // Try to find an existing identity or create a new one
                // Note: we create an identity entry hashed with the full url. This
                // means that the same well known object could have multiple
                // identities on the client side if it is connected through urls
                // that have different string representations.

                // GopalK: Eliminate objectURI in the following call
                // Also, we are resetting the envoy and channel sinks on an existing identity
                // as FindOrCreateIdentity can return an existing identity established by an
                // earlier call
                idObj = IdentityHolder.FindOrCreateIdentity(objectURI, url, null);

                // Set the envoy and channel sinks in a thread safe manner
                SetEnvoyAndChannelSinks(idObj, chnlSink, envoySink);                                                
            }

            // Get the proxy represented by the identity object
            proxy = GetOrCreateProxy(classToProxy, idObj);      

            Message.DebugOut("RemotingService::Unmarshal returning ");
    
            return proxy;
        }

        internal static Object Wrap(ContextBoundObject obj)
        {
            return Wrap(obj, null, true);
        }

        internal static Object Wrap(ContextBoundObject obj, Object proxy, bool fCreateSinks)
        {
            Message.DebugOut("Entering Wrap for context " + Thread.CurrentContext + "\n");      

            if ((null != obj) && (!IsTransparentProxy(obj)))
            {
                BCLDebug.Assert(obj.GetType().IsContextful,"objType.IsContextful");
                Message.DebugOut("Wrapping object \n");
                Identity idObj = null;

                if (proxy != null)
                {
                    // We will come here for strictly x-context activations
                    // since a proxy has already been created and supplied 
                    // through the construction message frame (GetThisPtr()).
                    RealProxy rp = GetRealProxy(proxy);
                    if (rp.UnwrappedServerObject == null)
                    {
                        rp.AttachServerHelper(obj);
                    }
                    idObj = MarshalByRefObject.GetIdentity(obj);
                }
                else
                {
                    // Proxy is null when Wrap() is called the second 
                    // time during activation
                    // It also will be null when a ContextBoundObject 
                    // is being activated from a remote client.
                    idObj = IdentityHolder.FindOrCreateServerIdentity(
                                obj,
                                null,
                                IdOps.None);
                }

                //********************WARNING*******************************
                // Always create the proxy before calling out to user code
                // so that any recursive calls by JIT to wrap will return this
                // proxy.
                //**********************************************************
                // Get the proxy represented by the identity object
                proxy = GetOrCreateProxy(idObj, proxy, true);

                // EXTENSIBILITY:
                GetRealProxy(proxy).Wrap();

                if (fCreateSinks)
                {
                    IMessageSink chnlSink = null;
                    IMessageSink envoySink = null;
                    // Create the envoy sinks and channel sink
                    CreateEnvoyAndChannelSinks(obj, null, out chnlSink, out envoySink);

                    // Set the envoy and channel sinks in a thread safe manner
                    SetEnvoyAndChannelSinks(idObj, chnlSink, envoySink);
                }
                
                // This will handle the case where we call Wrap() with 
                // a null proxy for real remote activation of ContextFul types.
                RealProxy rp2 = GetRealProxy(proxy);
                if (rp2.UnwrappedServerObject == null)
                {
                    rp2.AttachServerHelper(obj);
                }
                Message.DebugOut("Leaving Wrap with proxy \n");
                return proxy;
            }
            else
            {
                Message.DebugOut("Leaving Wrap with passed in object\n");

                // Default return value is the object itself
                return obj;
            }
        } // Wrap


        // This relies on the fact that no object uri is allowed to contain a slash
        //   (in some cases, we might want to do something intelligent by parsing
        //    the uri with the right channel, but that isn't possible in all cases).
        internal static String GetObjectUriFromFullUri(String fullUri)
        {
            if (fullUri == null)
                return null;

            int index = fullUri.LastIndexOf('/');
            if (index == -1)
                return fullUri;

            return fullUri.Substring(index + 1);
        } // GetObjectUriFromFullUri
        

       //
       //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object Unwrap(ContextBoundObject obj);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object AlwaysUnwrap(ContextBoundObject obj);


       // This method does the actual work of Ma
       //

        internal static Object InternalUnmarshal(
            ObjRef objectRef, 
            Object proxy,
            bool fRefine)
        {       
            Object obj = null;
            Identity idObj = null;

            Context currContext = Thread.CurrentContext;
            Message.DebugOut("RemotingServices::InternalUnmarshal: <Begin> Current context id: " +  (currContext.ContextID).ToString("x") + "\n");

            // This routine can be supplied a custom objref or an objref
            // generated by us. We do some sanity checking on the objref
            // to make sure that it is valid
            if (!ObjRef.IsWellFormed(objectRef))
            {
                throw new ArgumentException(
                String.Format(
                    Environment.GetResourceString(
                        "Argument_BadObjRef"),
                    "Unmarshal"));
            }

            // If it is a well known objectRef we need to just connect to
            // the URL inside the objectRef.
            if (objectRef.IsWellKnown())
            {
                obj = Unmarshal(
                            typeof(System.MarshalByRefObject),  
                            objectRef.URI);
                // ensure that we cache the objectRef in the ID
                // this contains type-info and we need it for
                // validating casts on the wellknown proxy
                // Note: this code path will be relatively rare ... the case
                // when a well known proxy is passed to a remote call
                // Otherwise it will be wise to another internal flavor of 
                // Unmarshal call that returns the identity as an out param.
                idObj = IdentityHolder.ResolveIdentity(objectRef.URI);
                if (idObj.ObjectRef == null)
                {
                    idObj.RaceSetObjRef(objectRef);                
                }
                return obj;
            }

            Message.DebugOut("RemotingService::InternalUnmarshal IN URI" + objectRef.URI);
            // Get the identity for the URI
            idObj = IdentityHolder.FindOrCreateIdentity(objectRef.URI, null, objectRef);

            currContext = Thread.CurrentContext;
            Message.DebugOut("RemotingServices::Unmarshal: <after FindOrCreateIdentity> Current context id: " +
                             (currContext.ContextID).ToString("x") + "\n");

            // If we successfully completed the above method then we should
            // have an identity object
            BCLDebug.Assert(null != idObj,"null != idObj");


            Message.DebugOut("RemotingService::InternalUnmarshal IN URI" + objectRef.URI);

            Message.DebugOut("RemotingServices::InternalUnmarshal: <Begin> Current context id: " +
                             (currContext.ContextID).ToString("x") + "\n");


            // Check whether we are on the server side or client-side
            ServerIdentity serverID = idObj as ServerIdentity;
            if ( serverID != null )
            {
                Message.DebugOut("RemotingServices::InternalUnmarshal: Unmarshalling ServerIdentity\n");

                // SERVER SIDE
                // We are in the app domain of the server object.
                // If we are in the same context as the server then
                // just return the server object else return the proxy

                currContext = Thread.CurrentContext;
                Message.DebugOut("RemotingServices::InternalUnmarshal: Current context id: " +
                                 (currContext.ContextID).ToString("x") + "\n");
                Message.DebugOut("RemotingServices::InternalUnmarshal: ServerContext id: " +
                                 (serverID.ServerContext.ContextID).ToString("x") + "\n");

                if (!serverID.IsContextBound)
                {
                    BCLDebug.Assert(serverID.ServerType.IsMarshalByRef,
                                    "Object must be at least MarshalByRef in order to be marshaled");
                    if (proxy != null)
                    {
                        throw new ArgumentException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Remoting_BadInternalState"),
                                "A marshal by ref object should not have a proxy in its own AppDomain"));
                    }
                    obj = serverID.TPOrObject;
                }
                else 
                {
                        Message.DebugOut("RemotingServices::InternalUnmarshal: Contexts don't match, returning proxy\n");

                        IMessageSink chnlSink = null;
                        IMessageSink envoySink = null;

                        // Create the envoy sinks and channel sink
                        CreateEnvoyAndChannelSinks(
                            (MarshalByRefObject)serverID.TPOrObject, 
                            null, 
                            out chnlSink, 
                            out envoySink);

                        // Set the envoy and channel sinks in a thread safe manner
                        SetEnvoyAndChannelSinks(idObj, chnlSink, envoySink);

                        // Get or create the proxy and return
                        obj = GetOrCreateProxy(idObj, proxy, true);                                     
                    // This will be a TP                    
                    BCLDebug.Assert(IsTransparentProxy(obj), "Unexpected naked server");                    
                }
            }
            else
            {
                // CLIENT SIDE                          

                Message.DebugOut("RemotingServices::InternalUnmarshal: Unmarshalling Client-side Identity\n");

                IMessageSink chnlSink = null;
                IMessageSink envoySink = null;

                // Create the envoy sinks and channel sink
                if (!objectRef.IsObjRefLite())                
                    CreateEnvoyAndChannelSinks(null, objectRef, out chnlSink, out envoySink);
                else
                    CreateEnvoyAndChannelSinks(objectRef.URI, null, out chnlSink, out envoySink);

                // Set the envoy and channel sinks in a thread safe manner
                SetEnvoyAndChannelSinks(idObj, chnlSink, envoySink);

                if (objectRef.HasProxyAttribute())
                {
                    fRefine = true;
                }

                // Get or create the proxy and return
                obj = GetOrCreateProxy(idObj, proxy, fRefine);
            }

            // Notify TrackingServices that we unmarshaled an object
            TrackingServices.UnmarshaledObject(obj, objectRef);             

            // Return the proxy
            Message.DebugOut("RemotingService::InternalUnmarshl OUT \n");
            return obj;

        }

       //
       //
        private static Object GetOrCreateProxy(
            Identity idObj, Object proxy, bool fRefine)
        {       
            Message.DebugOut("Entering GetOrCreateProxy for given proxy\n");

            // If we are not supplied a proxy then we have to find an existing
            // proxy or create one
            if (null == proxy)
            {
                // Get the type of the server object
                Type serverType;
                ServerIdentity serverID = idObj as ServerIdentity;
                if (null != serverID)
                {
                    serverType = serverID.ServerType; // ServerObject.GetType();
                }
                else
                {
                    BCLDebug.Assert(ObjRef.IsWellFormed(idObj.ObjectRef),
                                    "ObjRef.IsWellFormed(idObj.ObjectRef)");
                    IRemotingTypeInfo serverTypeInfo = idObj.ObjectRef.TypeInfo;

                    // For system generated type info we create the proxy for
                    // object type. Later, when the proxy is cast to the appropriate
                    // type we will update its internal state to refer to the cast type
                    // This way we avoid loading the server type till cast time.
                    //
                    // For type info generated by others we have no choice but to
                    // load the type provided by the typeinfo. Sometimes, we
                    // use this second approach even if the typeinfo has been
                    // generated by us because this saves us an extra checkcast.
                    // A typical example of this usage will be when we are
                    // unmarshaling in parameters. We know that the unmarshal will
                    // be followed by a check cast to ensure that the parameter type
                    // matches the signature type, so we do both in one step.
                    serverType = null;
                    if (((serverTypeInfo is TypeInfo) && !fRefine) ||
                        (serverTypeInfo == null))
                    {
                        serverType = typeof(System.MarshalByRefObject);
                    }
                    else
                    {
                        String typeName = serverTypeInfo.TypeName;
                        if (typeName != null)
                        {
                            String typeNamespace = null;
                            String assemNamespace = null;
                            TypeInfo.ParseTypeAndAssembly(typeName, out typeNamespace, out assemNamespace);


                            Assembly assem = FormatterServices.LoadAssemblyFromStringNoThrow(assemNamespace);

                            if (assem != null)
                            {
                                serverType = assem.GetTypeInternal(typeNamespace, false, false, false);
                            }

                        }

                    }

                    if (null == serverType)
                    {
                        throw new RemotingException(
                            String.Format(
                                Environment.GetResourceString(
                                    "Remoting_BadType"),
                                serverTypeInfo.TypeName));
                    }
                }                        
                Message.DebugOut("Creating Proxy for type " + serverType.FullName + "\n");
                proxy = SetOrCreateProxy(idObj, serverType, null);                                                
            }
            else
            {
                // We have been supplied with a proxy. Set that proxy in
                // the identity object
                // Assert that this the activation case only as this code path is
                // not thread safe otherwise! (We call Wrap to associate an object
                // with its proxy during activation).
                BCLDebug.Assert(
                    ((RemotingProxy)GetRealProxy(proxy)).ConstructorMessage!=null, 
                    "Only expect to be here during activation!");
                proxy = SetOrCreateProxy(idObj, null, proxy);       
            }

            // At this point we should have a non-null transparent proxy
            BCLDebug.Assert(null != proxy,"null != proxy");     
            BCLDebug.Assert(IsTransparentProxy(proxy),"IsTransparentProxy(proxy)");

            Message.DebugOut("Leaving GetOrCreateProxy for given proxy\n");     
            // Return the underlying transparent proxy
            return proxy;
        }

       //
       //
        // This version of GetOrCreateProxy is used for Connect(URI, type)
        private static Object GetOrCreateProxy(Type classToProxy, Identity idObj)
        {       
            Message.DebugOut("Entering GetOrCreateProxy for given class\n");

            Object proxy = idObj.TPOrObject;
            if (null == proxy)
            {
                // Create the  proxy
                proxy = SetOrCreateProxy(idObj, classToProxy, null);
            }
            // proxy from idObj may be non-null if we are doing a Connect
            // under new XXX() ... also if we are connecting to a remote URL 
            // which we previously connected.

            // If we are in the same domain as the server object then we
            // can check for type compatibility of the proxy with the given
            // type. Otherwise, we will defer this check to method call time.
            // If we do not do this now then we run the risk of returning
            // a proxy which is different from the type given.

            // GopalK: This should be eliminated IF we return the server object
            // in the caller to this routine ... basically we need to determine
            // if any channelURI matches the URI portion of a URL ... if so
            // check if ID is ServerID AND applicationNames match ... if so
            // return the ServerObject to Connect-type Unmarshal ... hence we
            // will never get to this point!
            ServerIdentity serverID = idObj as ServerIdentity;
            if (null != serverID)
            {
                // Check for type compatibility
                Type serverType = serverID.ServerType;
                if (!classToProxy.IsAssignableFrom(serverType))
                {
                    throw new InvalidCastException(
                        String.Format(
                            Environment.GetResourceString(
                                "InvalidCast_FromTo"),
                            serverType.FullName,
                            classToProxy.FullName));
                }

            }

            // At this point we should have a non-null transparent proxy
            BCLDebug.Assert(null != proxy && IsTransparentProxy(proxy),"null != proxy && IsTransparentProxy(proxy)");

            Message.DebugOut("Leaving GetOrCreateProxy for given class\n");
            return proxy;       
        }


        private static MarshalByRefObject SetOrCreateProxy(
            Identity idObj, Type classToProxy, Object proxy)

        {
            Message.DebugOut("Entering SetOrCreateProxy for type \n");

            RealProxy realProxy = null;
            // If a proxy has not been supplied create one
            if (null == proxy)
            {
                // Create a remoting proxy
                Message.DebugOut("SetOrCreateProxy::Creating Proxy for " +
                                 classToProxy.FullName + "\n");

                ServerIdentity srvID = idObj as ServerIdentity;
                if (idObj.ObjectRef != null)
                {
                	ProxyAttribute pa = ActivationServices.GetProxyAttribute(classToProxy);                
                	realProxy = pa.CreateProxy(idObj.ObjectRef,
                                           classToProxy,
                                           null,  // REVIEW (null == srvID ? null : srvID.ServerObject),
                                           null); // REVIEW (null == srvID ? null : srvID.ServerContext));				    
				}
                if(null == realProxy)
                {
                    // The custom proxy attribute does not want to create a proxy. We create a default 
                    // proxy in this case.
                    ProxyAttribute defaultProxyAttribute = ActivationServices.DefaultProxyAttribute;
 
                    realProxy = defaultProxyAttribute.CreateProxy(idObj.ObjectRef,
                                                                  classToProxy,
                                                                  null,
                                                                  (null == srvID ? null : 
                                                                                   srvID.ServerContext));
                }
            }
            else
            {
                BCLDebug.Assert(IsTransparentProxy(proxy),"IsTransparentProxy(proxy)");

                // Extract the remoting proxy from the transparent proxy
                Message.DebugOut("SetOrCreateProxy::Proxy already created \n");
                realProxy = GetRealProxy(proxy);
            }

            BCLDebug.Assert(null != realProxy,"null != realProxy");

            // Set the back reference to the identity in the proxy object
            realProxy.IdentityObject = idObj;

            // Set the reference to the proxy in the identity object
            proxy = realProxy.GetTransparentProxy();
            proxy = idObj.RaceSetTransparentProxy(proxy);

            Message.DebugOut("Leaving SetOrCreateProxy\n");
            // return the transparent proxy
            return (MarshalByRefObject)proxy;
        }

        private static void CreateEnvoyAndChannelSinks(
            MarshalByRefObject tpOrObject,
            ObjRef objectRef,
            out IMessageSink chnlSink,
            out IMessageSink envoySink)
        {   

            Message.DebugOut("Creating envoy and channel sinks \n");
            BCLDebug.Assert(    
                ((null != tpOrObject) || (null != objectRef)), 
                "((null != tpOrObject) || (null != objectRef)");

            // Set the out parameters
            chnlSink = null;
            envoySink = null;

            if (null == objectRef)
            {
                // If the objectRef is not present this is a cross context case
                // and we should set the cross context channel sink
                chnlSink = ChannelServices.GetCrossContextChannelSink();                                            

                envoySink = Thread.CurrentContext.CreateEnvoyChain(tpOrObject);
            }
            else
            {
                // Extract the channel from the channel data and name embedded
                // inside the objectRef
                Object[] channelData = objectRef.ChannelInfo.ChannelData;
                if (channelData != null)
                {
                    for (int i = 0; i < channelData.Length; i++)
                    {
                        // Get the first availabe sink           
                        chnlSink = ChannelServices.CreateMessageSink(channelData[i]);
                        if (null != chnlSink)
                        {
                            break;
                        }
                    }

                    
                    // if chnkSink is still null, try to find a channel that can service
                    //   this uri.
                    if (null == chnlSink)
                    {
                        // NOTE: careful! we are calling user code here after holding
                        // the delayLoadChannelLock (channel ctor-s for arbitrary channels
                        // will run while the lock is held).
                        lock (s_delayLoadChannelLock)
                        {
                            // Check once to ensure that noone beat us in a race
                            for (int i = 0; i < channelData.Length; i++)
                            {
                                // Get the first availabe sink
                                chnlSink = ChannelServices.CreateMessageSink(channelData[i]);
                                if (null != chnlSink)
                                {
                                    break;
                                }
                            }

                            
                            if (null == chnlSink)
                            {
                                // We don't have a sink
                                foreach (Object data in channelData)
                                {
                                    String objectURI;
                                    chnlSink = 
                                        RemotingConfigHandler.FindDelayLoadChannelForCreateMessageSink(
                                            null, data, out objectURI);
                                    if (null != chnlSink)
                                        break;
                                }
                            }                                
                        }
                    }
                }

                // Extract the envoy sinks from the objectRef
                if ((null != objectRef.EnvoyInfo) &&
                    (null != objectRef.EnvoyInfo.EnvoySinks))
                {
                    envoySink = objectRef.EnvoyInfo.EnvoySinks;
                }
                else
                {
                    envoySink = EnvoyTerminatorSink.MessageSink;
                }               
            }
        }

        private static String CreateEnvoyAndChannelSinks(String url,
                                                         Object data,
                                                         out IMessageSink chnlSink,
                                                         out IMessageSink envoySink)
        {
            BCLDebug.Assert(null != url,"null != url");
            String objectURI = null;

            objectURI = CreateChannelSink(url, data, out chnlSink);

            envoySink = EnvoyTerminatorSink.MessageSink;

            return objectURI;
        }       

        private static String CreateChannelSink(String url, Object data, out IMessageSink chnlSink)       
        {
            BCLDebug.Assert(null != url,"null != url");
            String objectURI = null;

            chnlSink = ChannelServices.CreateMessageSink(url, data, out objectURI);

            // if chnkSink is still null, try to find a channel that can service this uri.
            if (null == chnlSink)
            {
                lock (s_delayLoadChannelLock)
                {
                    chnlSink = ChannelServices.CreateMessageSink(url, data, out objectURI);
                    if (null == chnlSink)
                    {
                        chnlSink = 
                            RemotingConfigHandler.FindDelayLoadChannelForCreateMessageSink(
                                url, data, out objectURI);
                    }                                
                }                            
            }

            return objectURI;
        } // CreateChannelSinks

        private static void SetEnvoyAndChannelSinks(Identity idObj,
                                                    IMessageSink chnlSink,
                                                    IMessageSink envoySink)
        {
            Message.DebugOut("Setting up envoy and channel sinks \n");
            BCLDebug.Assert(null != idObj,"null != idObj");

            // Decide if we need to set the envoy sink chain            
            if (null == idObj.ChannelSink)
            {            
                if (null != chnlSink)
                {
                    idObj.RaceSetChannelSink(chnlSink);
                }
            }

            // Decide if we need to set the envoy sink chain    
            if (null == idObj.EnvoyChain)
            {
                if (null != envoySink)
                {
                    idObj.RaceSetEnvoyChain(envoySink);
                }
                else
                {
                    throw new RemotingException(
                        String.Format(
                            Environment.GetResourceString(
                                "Remoting_BadInternalState"),
                            "Failed to create an envoy sink for the object"));
                }
            }
        }
        
        // Check whether the transparent proxy backing the real proxy
        // is assignable from the given type.
        private static bool CheckCast(RealProxy rp, Type castType)
        {
            // NOTE: This is the point where JIT_CheckCastClass ultimately
            // lands up in the managed world if the object being cast is
            // a transparent proxy.
            // If we are here, it means that walking the current EEClass 
            // up the chain inside the EE was unable to verify the cast.

            Message.DebugOut("Entered CheckCast for type " + castType);
            bool fCastOK = false;

            BCLDebug.Assert(rp != null, "Shouldn't be called with null real proxy.");

            // Always return true if cast is to System.Object
            if (castType == typeof(Object))
                return true;

            // We do not allow casting to non-interface types that do not extend
            // from System.MarshalByRefObject
            if (!castType.IsInterface && !castType.IsMarshalByRef)
                return false;
                
            // Note: this is a bit of a hack to allow deserialization of WellKnown
            // object refs (in the well known cases, we always return TRUE for
            // interface casts but doing so messes us up in the case when
            // the object manager is trying to resolve object references since
            // it ends up thinking that the proxy we returned needs to be resolved
            // further).
            if (castType != typeof(IObjectReference))
            {
                IRemotingTypeInfo typeInfo = rp as IRemotingTypeInfo;
                if(null != typeInfo)
                {
                    fCastOK = typeInfo.CanCastTo(castType, rp.GetTransparentProxy());
                }
                else
                {
                    // The proxy does not implement IRemotingTypeInfo, so we should
                    //   try to do casting based on the ObjRef type info.
                    Identity id = rp.IdentityObject;
                    if (id != null)
                    {
                        ObjRef objRef = id.ObjectRef;
                        if (objRef != null)
                        {
                            typeInfo = objRef.TypeInfo;
                            if (typeInfo != null)
                            {
                                fCastOK = typeInfo.CanCastTo(castType, rp.GetTransparentProxy());
                            }
                        }
                    }
                }
            }
            
            Message.DebugOut("CheckCast returning " + fCastOK);
            return fCastOK;
        }

        internal static bool ProxyCheckCast(RealProxy rp, Type castType)
        {
            return CheckCast(rp, castType);
        } // ProxyCheckCast

        /*
        **CheckCast
        **Action:  When a proxy to an object is serialized, the MethodTable is only 
        **         expanded on an on-demand basis.  For purely managed operations, this
        **         happens in a transparent fashion.  However, for delegates (and 
        **         potentially other types) we need to force this expansion to happen.
        **Returns: The newly expanded object.  Returns the identity if no expansion is required.
        **Arguments: objToExpand -- The object to be expanded.
        **           type -- the type to which to expand it.
        **Exceptions: None.
        */
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern Object CheckCast(Object objToExpand, Type type);

        internal static GCHandle CreateDelegateInvocation(WaitCallback waitDelegate, Object state)
        {
            Object[] delegateCallToken = new Object[2];
            delegateCallToken[0] = waitDelegate;
            delegateCallToken[1] = state;
            return System.Runtime.InteropServices.GCHandle.Alloc(delegateCallToken);
        }

        internal static void DisposeDelegateInvocation(GCHandle delegateCallToken)
        {
            delegateCallToken.Free();
        }

        internal static Object CreateProxyForDomain(int appDomainId, int defCtxID)
        {
            AppDomain proxy = null;

            ObjRef objRef = CreateDataForDomain(appDomainId, defCtxID);

            // Unmarshal the objref in the old app domain
            proxy = (AppDomain)Unmarshal(objRef);

            return proxy;
        } // CreateProxyForDomain

        internal static ObjRef CreateDataForDomain(int appDomainId, int defCtxID)
        {
            // This is a subroutine of CreateProxyForDomain
            // so we can segregate the object references
            // from different app domains into different frames.  This is
            // important for the app domain leak checking code.

            Message.DebugOut("Creating proxy for domain " + appDomainId + "\n");

            bool bNeedToReset = false;
            ObjRef objRef = null;
	    ContextTransitionFrame frame = new ContextTransitionFrame();
            try
	    {
		try
		{
		    RegisterWellKnownChannels();

		    // Set the current context to the given default Context
		    // (of the new AppDomain).
		    Thread.CurrentThread.EnterContextInternal(null, defCtxID, appDomainId, ref frame);
		    bNeedToReset = true;

		    // Ensure that the well known channels are registered in this domain too
		    RegisterWellKnownChannels();            

		    // Marshal the app domain object
		    objRef = MarshalInternal(
                            Thread.CurrentContext.AppDomain,
                            null,
                            null);

		    // Set the current context to the old context
		    Thread.CurrentThread.ReturnToContext(ref frame);

		    bNeedToReset = false;
		}
		finally
		{
		    // Restore the old app domain
		    if (bNeedToReset)
		    {
			Thread.CurrentThread.ReturnToContext(ref frame);
		    }
		}
	    }
	    catch(Exception)
	    {
		throw;
	    }

            return objRef;
        } // CreateDataForDomain


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetMethodBaseFromMethodMessage"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg)
        {
            MethodBase mb = InternalGetMethodBaseFromMethodMessage(msg);
            if (mb != null)
            {
                if (!mb.DeclaringType.IsPublic || !mb.IsPublic)
                {
                    new ReflectionPermission(
                            ReflectionPermissionFlag.TypeInformation).Demand();
                }
            }
            return mb;
        }

        internal static MethodBase InternalGetMethodBaseFromMethodMessage(IMethodMessage msg)
        {
            if(null == msg)
            {
                return null;
            }
            
            Type t = RemotingServices.InternalGetTypeFromQualifiedTypeName(msg.TypeName);
            if (t == null)
            {
                throw new RemotingException(
                    String.Format(
                        Environment.GetResourceString(
                            "Remoting_BadType"),
                        msg.TypeName));

            }
            
            // Use the signature, type and method name to determine the
            // methodbase via reflection.
            Type[] signature = (Type[])msg.MethodSignature;                     
            return GetMethodBase(msg, t, signature);            
        }
        
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsMethodOverloaded"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static bool IsMethodOverloaded(IMethodMessage msg)
        {
            RemotingMethodCachedData cache = 
                InternalRemotingServices.GetReflectionCachedData(msg.MethodBase);

            return cache.IsOverloaded();            
        } // IsMethodOverloaded
        
        
        private static MethodBase GetMethodBase(IMethodMessage msg, Type t, Type[] signature)
        {
            MethodBase mb = null;
            
            // Get the reflection object depending on whether it is a
            // constructor call or a method call.           
            if((msg is IConstructionCallMessage) ||
               (msg is IConstructionReturnMessage))
            {
                if((null == signature))
                {
                    BCLDebug.Trace("REMOTE", "RemotingServices.MethodBaseFromMethodCallMessage with null sig ", msg.MethodName);        
                    ConstructorInfo[] ci;
                    RuntimeType rt = t as RuntimeType;
                    if (rt == null)
                        ci = t.GetConstructors();
                    else
                        ci = rt.GetConstructorsInternal(BindingFlags.Public | BindingFlags.Instance, false);

                    if(1 != ci.Length)
                    {
                        // There is more than one constructor defined but
                        // we do not have a signature to differentiate between
                        // them.
                                throw new AmbiguousMatchException(
                                    Environment.GetResourceString(
                                        "Remoting_AmbiguousCTOR"));
                    }
                    mb = ci[0];
                }
                else
                {
                    BCLDebug.Trace("REMOTE", "RemotingServices.MethodBaseFromMethodCallMessage with non-null sig ", msg.MethodName, " ", signature.Length);         
                    RuntimeType rt = t as RuntimeType;
                    if (rt == null)
                        mb = t.GetConstructor(signature);
                    else
                        mb = rt.GetConstructorImplInternal(BindingFlags.Public | BindingFlags.Instance,null,CallingConventions.Any, signature, null, false );
                }
            }
            else if((msg is IMethodCallMessage) || (msg is IMethodReturnMessage))
            {
                // We demand reflection permission in the api that calls this
                // for non-public types
                if(null == signature)
                {
                    BCLDebug.Trace("REMOTE", "RemotingServices.MethodBaseFromMethodCallMessage with null sig ", msg.MethodName);        
                    RuntimeType rt = t as RuntimeType;
                    if (rt == null)
                        mb = t.GetMethod(msg.MethodName, RemotingServices.LookupAll);
                    else
                        mb = rt.GetMethodImplInternal(msg.MethodName, RemotingServices.LookupAll, null,CallingConventions.Any, null, null, false);
                }
                else
                {
                    BCLDebug.Trace("REMOTE", "RemotingServices.MethodBaseFromMethodCallMessage with non-null sig ", msg.MethodName, " ", signature.Length);         
                    RuntimeType rt = t as RuntimeType;
                    if (rt == null)
                        mb = t.GetMethod(msg.MethodName, RemotingServices.LookupAll, null, signature, null);
                    else
                        mb = rt.GetMethodImplInternal(msg.MethodName, RemotingServices.LookupAll, null, CallingConventions.Any, signature, null, false);
                }
            
            }       
            
            return mb;
        }   

        internal static bool IsMethodAllowedRemotely(MethodBase method)
        {
	    // MarhsalByRefObject.InvokeMember is allowed to be invoked remotely. It is a wrapper for a com method as represented in managed 
	    // code. The managed code was generated by tlbimpl. A test does not have to be made to make sure that the COM object method is public because
	    // the tlbimpl will only generate methods which can be invoked remotely.
        
            if (s_FieldGetterMB == null || 
                s_FieldSetterMB == null || 
                s_IsInstanceOfTypeMB == null ||
                s_InvokeMemberMB == null ||
                s_CanCastToXmlTypeMB == null)
            {
                System.Security.CodeAccessPermission.AssertAllPossible();
                if (s_FieldGetterMB == null)
                    s_FieldGetterMB = typeof(Object).GetMethod(FieldGetterName,RemotingServices.LookupAll);

                if (s_FieldSetterMB == null)
                    s_FieldSetterMB = typeof(Object).GetMethod(FieldSetterName, RemotingServices.LookupAll);

                if (s_IsInstanceOfTypeMB == null)
                {
                    s_IsInstanceOfTypeMB = 
                        typeof(MarshalByRefObject).GetMethod(
                            IsInstanceOfTypeName, RemotingServices.LookupAll);
                }

                if (s_CanCastToXmlTypeMB == null)
                {
                    s_CanCastToXmlTypeMB = 
                        typeof(MarshalByRefObject).GetMethod(
                            CanCastToXmlTypeName, RemotingServices.LookupAll);
                }

                if (s_InvokeMemberMB == null)
                {
                    s_InvokeMemberMB = 
                        typeof(MarshalByRefObject).GetMethod(
                            InvokeMemberName, RemotingServices.LookupAll);
                }

            }
        
            return 
                method == s_FieldGetterMB ||
                method == s_FieldSetterMB ||
                method == s_IsInstanceOfTypeMB ||
                method == s_InvokeMemberMB ||
                method == s_CanCastToXmlTypeMB;
        }
            
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.IsOneWay"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static bool IsOneWay(MethodBase method)
        {
            if (method == null)
                return false;
                
            RemotingMethodCachedData cache = 
                InternalRemotingServices.GetReflectionCachedData(method);
               
            return cache.IsOneWayMethod();       
        }

        // Given a method base object, see if we can find an async version of the
        //   method on the same class.
        internal static bool FindAsyncMethodVersion(MethodInfo method,
                                                  out MethodInfo beginMethod,
                                                  out MethodInfo endMethod)
        {
            beginMethod = null;
            endMethod = null;

            // determine names of Begin/End versions
            String beginName = "Begin" + method.Name;
            String endName = "End" + method.Name;
        
            // determine parameter lists for Begin/End versions
            ArrayList beginParameters = new ArrayList();
            ArrayList endParameters = new ArrayList();

            Type beginReturnType = typeof(IAsyncResult);
            Type endReturnType = method.ReturnType;

            ParameterInfo[] paramList = method.GetParameters();
            foreach (ParameterInfo param in paramList)
            {
                if (param.IsOut)
                    endParameters.Add(param);
                else
                if (param.ParameterType.IsByRef)
                { 
                    beginParameters.Add(param);
                    endParameters.Add(param);
                }
                else
                {
                    // it's an in parameter
                    beginParameters.Add(param);
                }
            }

            beginParameters.Add(typeof(AsyncCallback));
            beginParameters.Add(typeof(Object));
            endParameters.Add(typeof(IAsyncResult));

            // try to match these signatures with the methods on the type
            Type type = method.DeclaringType;
            MethodInfo[] methods = type.GetMethods();

            foreach (MethodInfo mi in methods)
            {
                ParameterInfo[] parameterList = mi.GetParameters();
            
                // see if return value is IAsyncResult
                if (mi.Name.Equals(beginName) &&
                    (mi.ReturnType == beginReturnType) &&
                    CompareParameterList(beginParameters, parameterList))
                {
                    beginMethod = mi;
                }
                else 
                if (mi.Name.Equals(endName) &&
                    (mi.ReturnType == endReturnType) &&
                    CompareParameterList(endParameters, parameterList))
                {
                    endMethod = mi;
                }
            }

            if ((beginMethod != null) && (endMethod != null))
                return true;
            else
                return false;
        } // FindAsyncMethodVersion

        // Helper function for FindAsyncMethodVersion
        private static bool CompareParameterList(ArrayList params1, ParameterInfo[] params2)
        {
            // params1 contains a list of parameters (and possibly some types which are
            //   assumed to be in parameters)
            // param2 just contains the list of parameters from some method
        
            if (params1.Count != params2.Length)
                return false;

            int co = 0;
            foreach (Object obj in params1)
            {
                ParameterInfo param = params2[co];
            
                ParameterInfo pi = obj as ParameterInfo;
                if (null != pi)
                {
                    if ((pi.ParameterType != param.ParameterType) ||
                        (pi.IsIn != param.IsIn) ||
                        (pi.IsOut != param.IsOut))
                    {
                        return false;
                    }
                }
                else
                if (((Type)obj != param.ParameterType) && param.IsIn)
                    return false;
                co++;
            }
            
            return true;
        } // CompareParameterList
        
        
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.GetServerTypeForUri"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static Type GetServerTypeForUri(String URI)
        {            
            Type svrType = null;

            if(null != URI)
            {
                ServerIdentity srvID = (ServerIdentity)IdentityHolder.ResolveIdentity(URI);

                if(null == srvID)
                {
                    // Check if this a well-known object which needs to be faulted in
                    svrType = RemotingConfigHandler.GetServerTypeForUri(URI);                
                }
                else
                {
                    svrType = srvID.ServerType;
                }

                if (svrType != null && !svrType.IsPublic)
                {
                    new ReflectionPermission(ReflectionPermissionFlag.TypeInformation).Demand();
                }
            }

            return svrType;
        }


        // This method is called after an appdomain is unloaded from the
        // current domain. 
        internal static void DomainUnloaded(Int32 domainID)
        {
            // Remove any client side identities, presumably the driver
            // domain has released all references to proxies in the unloaded
            // domain.
            IdentityHolder.FlushIdentityTable();
            // Remove the cross domain channel sink for the unloaded domain
            CrossAppDomainSink.DomainUnloaded(domainID);
        }

        //  This method is called from the VM and helps the appdomain
        //  folks to get to the server appdomain from a proxy. This is
        //  expected to be called on strictly cross domain proxies.
        //  
        //  This returns the unmanaged context object for the proxy.
        //  We fetch the appDomain out of the context in the VM.
        // This will return NULL (or 0) if the server for the proxy is 
        // not from this process or if the server domain is invalid
        // or if there is not enough information to determine the server
        // context.
        internal static int GetServerContextForProxy(Object tp)
        {
            ObjRef objRef = null;
            bool bSameDomain;
            int domainId;
            return GetServerContextForProxy(
                        tp, 
                        out objRef, 
                        out bSameDomain,
                        out domainId);
        }

        // This returns the domain ID if the proxy is from this process
        // whether or not the domain is valid!
        internal static int GetServerDomainIdForProxy(Object tp)
        {
            ObjRef objRef;
            bool bSameDomain;
            int domainId;
            GetServerContextForProxy(
                tp, 
                out objRef, 
                out bSameDomain,
                out domainId);
            return domainId;
        }

        // This will retrieve the server domain and context id
        internal static void GetServerContextAndDomainIdForProxy(Object tp,
                                                                 out int contextId,
                                                                 out int domainId)
        {
            ObjRef objRef;
            bool bSameDomain;
            contextId = 
                GetServerContextForProxy(
                    tp, 
                    out objRef, 
                    out bSameDomain,
                    out domainId);
        } // GetServerContextAndDomainIdForProxy


        // This is a helper for the methods above.
        // NOTE:: Returns the unmanaged server context for a proxy
        // This is *NOT* the same as "public int Context::ContextID"
        private static int GetServerContextForProxy(
            Object tp, out ObjRef objRef, out bool bSameDomain, out int domainId)
        {
            // Note: the contextId we return from here should be the address 
            // of the unmanaged (VM) context object or NULL.

            int contextId = 0;
            objRef = null;
            bSameDomain = false;
            domainId = 0;
            if (IsTransparentProxy(tp))
            {
                // This is a transparent proxy. Try to obtain the backing
                // RealProxy from it.
                RealProxy rp = GetRealProxy(tp);

                // Get the identity from the realproxy
                Identity id = rp.IdentityObject;
                if(null != id)
                {
                    ServerIdentity serverID = id as ServerIdentity;
                    if (null != serverID)                   
                    {
                        // We are in the app domain of the server
                        bSameDomain = true;
                        contextId = serverID.ServerContext.InternalContextID;
                        domainId = Thread.GetDomain().GetId();
                    }
                    else
                    {
                        // Server is from another app domain
                        // (possibly from another process)
                        objRef = id.ObjectRef;
                        if (objRef != null)
                        {
                            contextId = objRef.GetServerContext(out domainId);
                        }
                        else
                        {
                            // Proxy does not have an associated ObjRef
                            // FUTURE:
                            // This may need revisiting ... eg. WellKnownObject
                            // proxies will not have ObjRefs associated with them
                            
                            //BCLDebug.Assert(false, "Found proxy without an objref");
                            contextId = 0;
                        }   
                    }
                }
                else
                {
                    // This was probably a custom proxy other than RemotingProxy
                    BCLDebug.Assert(
                        !(rp is RemotingProxy), 
                        "!(rp is RemotingProxy)");

                    contextId = Context.DefaultContext.InternalContextID;
                }
            }

            return contextId;
        }

        internal static MarshalByRefObject GetServerObjectForProxy(
            MarshalByRefObject tp)
        {
            ObjRef objRef;
            bool bSameDomain;
            int domainId;
            int contextId = GetServerContextForProxy(
                                tp, 
                                out objRef, 
                                out bSameDomain,
                                out domainId);

            if (contextId == 0)
            {
                return null;
            }
            else if (bSameDomain)
            {
                // same app domain, just return the proxy
                BCLDebug.Assert(
                    tp is ContextBoundObject, 
                    "do not expect a proxy for an MBR type in its domain");
                return tp;
            }
            else
            {
                // The server object is in another app domain
                return null;
            }
        }
                                            
       //   Return the server context of the object provided if the object
       //   was born in the current appdomain, else return null.
       //   
        // NOTE: This returns the managed context object that the server
        // is associated with ... 
        // FUTURE: may be implement this using the above helper making use of 
        // the bSameDomain flag.
        internal static Context GetServerContext(MarshalByRefObject obj)
        {
            Context serverCtx = null;
            
            if(!IsTransparentProxy(obj) && (obj is ContextBoundObject))
            {
                // The object is native to the current context.
                serverCtx = Thread.CurrentContext;
            }
            else
            {
                RealProxy rp = GetRealProxy(obj);
                Identity id = rp.IdentityObject;
                ServerIdentity serverID = id as ServerIdentity;
                if(null != serverID)
                {
                    // The object was born in the current appdomain.
                    // Extract the server context.
                    serverCtx = serverID.ServerContext;
                }
            }
            
            return serverCtx;
        }

       //   Return the actual type of the server object given the proxy
       //   
       //   
        private static Object GetType(Object tp)
        {
            BCLDebug.Assert(IsTransparentProxy(tp), "IsTransparentProxy(tp)");
            
            Type serverType = null;
            
            RealProxy rp = GetRealProxy(tp);
            Identity id = rp.IdentityObject;
            BCLDebug.Assert(!(id is ServerIdentity), "(!id is ServerIdentity)");
            if((null != id) && (null != id.ObjectRef) &&
               (null != id.ObjectRef.TypeInfo))
            {
                IRemotingTypeInfo serverTypeInfo = id.ObjectRef.TypeInfo;
                String typeName = serverTypeInfo.TypeName;
                if (typeName != null)
                {
                    serverType = InternalGetTypeFromQualifiedTypeName(typeName);                
                }                   
            }                   
            
            return serverType;
        }
        

        internal static byte[] MarshalToBuffer(Object o)
        {
            // serialize headers and args together using the binary formatter
            MemoryStream stm = new MemoryStream();
            RemotingSurrogateSelector ss = new RemotingSurrogateSelector();
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.SurrogateSelector = ss;
            fmt.Context = new StreamingContext(StreamingContextStates.Other);
            fmt.Serialize(stm, o, null, false /* No Security check */);

            return stm.GetBuffer();
        }

        internal static Object UnmarshalFromBuffer(byte [] b)
        {
            MemoryStream stm = new MemoryStream(b);
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.AssemblyFormat = System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple; //*******Add this line
            fmt.SurrogateSelector = null;
            fmt.Context = new StreamingContext(StreamingContextStates.Other);
            Object o = fmt.Deserialize(stm, null, false /* No Security check */);
            return o;
        }

        internal static Object UnmarshalReturnMessageFromBuffer(byte [] b, IMethodCallMessage msg)
        {
            MemoryStream stm = new MemoryStream(b);
            BinaryFormatter fmt = new BinaryFormatter();                
            fmt.SurrogateSelector = null;
            fmt.Context = new StreamingContext(StreamingContextStates.Other);
            Object o = fmt.DeserializeMethodResponse(stm, null, (IMethodCallMessage)msg);
             //= fmt.Deserialize(stm, null, false /* No Security check */);
            return o;
        }

		/// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.ExecuteMessage"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]
        public static IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, 
                                                          IMethodCallMessage reqMsg)
		{
            // Argument validation
            if(null == target)
            {
                throw new ArgumentNullException("target");
            }

            RealProxy rp = GetRealProxy(target);

            // Check for context match
            if( rp is RemotingProxy
                &&  !rp.DoContextsMatch() )
            {
                throw new RemotingException(
                    Environment.GetResourceString("Remoting_Proxy_WrongContext"));
            }
            
            // Dispatch the message
			StackBuilderSink dispatcher = new StackBuilderSink(target);

            // dispatch the message
            IMethodReturnMessage retMsg = (IMethodReturnMessage)dispatcher.SyncProcessMessage(reqMsg, 0, true); 		
			
			return retMsg;
        } // ExecuteMessage



        //
        // Methods for mapping and resolving qualified type names
        //   A qualified type name describes the name that we use in the ObjRef and
        //   message TypeName. It consists either of the actual type name or 
        //   "<typeId>:typename" where for now "soap:<soap type name>" is the only
        //   supported alternative. In the future, we may make this type resolution
        //   extensible and publicly exposed.
        //

        // This is used by the cached type data to figure out which type name
        //   to use (this should never be publicly exposed; GetDefaultQualifiedTypeName should,
        //   if anything at all)
        internal static String DetermineDefaultQualifiedTypeName(Type type)
        {
            if (type == null)
                throw new ArgumentNullException("type");
                
            // see if there is an xml type name
            String xmlTypeName = null;
            String xmlTypeNamespace = null;
            if (SoapServices.GetXmlTypeForInteropType(type, out xmlTypeName, out xmlTypeNamespace))
            {
                return "soap:" + xmlTypeName + ", " + xmlTypeNamespace;
            }            

            // there are no special mappings, so use the fully qualified CLR type name
            // FUTURE: Change this to start with "clr:" eventually.
            return type.AssemblyQualifiedName;            
        } // DetermineDefaultQualifiedTypeName


        // retrieves type name from the cache data which uses DetermineDefaultQualifiedTypeName        
        internal static String GetDefaultQualifiedTypeName(Type type)
        {
            RemotingTypeCachedData cache = (RemotingTypeCachedData)
                InternalRemotingServices.GetReflectionCachedData(type);

            return cache.QualifiedTypeName;
        } // GetDefaultQualifiedTypeName


        // Retrieves type based on qualified type names. This does not do security checks
        // so don't expose this publicly (at least not directly). It returns null if the
        // type cannot be loaded.
        internal static Type InternalGetTypeFromQualifiedTypeName(String qualifiedTypeName, bool partialFallback)
        {
            if (qualifiedTypeName == null)
                throw new ArgumentNullException("qualifiedTypeName");     


            // look to see if this is a clr type name
            if (qualifiedTypeName.Length > 4) // length of "clr:"
            {
                if (String.CompareOrdinal(qualifiedTypeName, 0, "clr:", 0, 4) == 0)
                {
                    // strip "clr:" off the front
                    String actualTypeName = qualifiedTypeName.Substring(4);
                    return LoadClrTypeWithPartialBindFallback(actualTypeName, partialFallback);
                }
            }
                    
        
            // look to see if this is a soap type name
            if (qualifiedTypeName.Length > 5) // length of "soap:"
            {
                if (String.CompareOrdinal(qualifiedTypeName, 0, "soap:", 0, 5) == 0)
                {
                    // This is a soap type name. We need to parse it and try to
                    //   find the actual type. Format is "soap:xmlTypeName, xmlTypeNamespace"                    

                    // find comma starting from just past "soap:"
                    int index = qualifiedTypeName.IndexOf(',', 5);
                    if (index == -1)
                        return null;

                    String xmlTypeName = qualifiedTypeName.Substring(5, index - 5);
                    // +2 is to skip the comma and following space
                    String xmlTypeNamespace = 
                        qualifiedTypeName.Substring(index + 2, qualifiedTypeName.Length - (index + 2));

                    Type type = SoapServices.GetInteropTypeFromXmlType(xmlTypeName, xmlTypeNamespace);
                    if (type == null)
                    {
                        // This must be the default encoding of the soap type (or the type wasn't
                        //   preloaded).
                        String typeNamespace;
                        String assemblyName;
                        if (!SoapServices.DecodeXmlNamespaceForClrTypeNamespace(
                                xmlTypeNamespace, 
                                out typeNamespace, out assemblyName))
                        {
                            return null;
                        }

                        String typeName;
                        if ((typeNamespace != null) && (typeNamespace.Length > 0))
                            typeName = typeNamespace + "." + xmlTypeName;
                        else
                            typeName = xmlTypeName;

                        try
                        {
                            String fullTypeName = typeName + ", " + assemblyName;   
                            type = LoadClrTypeWithPartialBindFallback(fullTypeName, true);
                        }
                        catch 
                        {
                            // We ignore errors and will just return null below since the type
                            //   isn't set.
                        }
                    }

                    return type;
                }
            } // if (typeName.Length > 5)


            // There is no prefix, so assume this is a normal CLR type name.
            return LoadClrTypeWithPartialBindFallback(qualifiedTypeName, partialFallback);
        } // InternalGetTypeFromQualifiedTypeName

        internal static Type InternalGetTypeFromQualifiedTypeName(String qualifiedTypeName)
        {
            return InternalGetTypeFromQualifiedTypeName(qualifiedTypeName, true);
        }

        private static Type LoadClrTypeWithPartialBindFallback(String typeName, bool partialFallback)
        {
            // Try to load a type with fully qualified name if partialFallback is not requested
            if (!partialFallback)
            {
                return Type.GetType(typeName, false);
            }
            else
            {
                return Assembly.LoadTypeWithPartialName(typeName, false);
            }
        } // LoadClrTypeWithPartialBindFallback

   
        //
        // end of Methods for mapping and resolving qualified type names
        //


        //
        // These are used by the profiling code to profile remoting.
        //
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool CORProfilerTrackRemoting();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool CORProfilerTrackRemotingCookie();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern bool CORProfilerTrackRemotingAsync();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CORProfilerRemotingClientSendingMessage(out Guid id, bool fIsAsync);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CORProfilerRemotingClientReceivingReply(Guid id, bool fIsAsync);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CORProfilerRemotingServerReceivingMessage(Guid id, bool fIsAsync);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CORProfilerRemotingServerSendingReply(out Guid id, bool fIsAsync);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void CORProfilerRemotingClientInvocationFinished();

        internal const int TrashMemory = unchecked((int)0xdeadbeef);
        
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="RemotingServices.LogRemotingStage"]/*' />
        [System.Diagnostics.Conditional("REMOTING_PERF"), MethodImplAttribute(MethodImplOptions.InternalCall)]
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
        public static extern void LogRemotingStage(int stage);

        internal const int CLIENT_MSG_GEN          = 1;
        internal const int CLIENT_MSG_SINK_CHAIN   = 2;
        internal const int CLIENT_MSG_SER          = 3;
        internal const int CLIENT_MSG_SEND         = 4;
        internal const int SERVER_MSG_RECEIVE      = 5;
        internal const int SERVER_MSG_DESER        = 6;
        internal const int SERVER_MSG_SINK_CHAIN   = 7;
        internal const int SERVER_MSG_STACK_BUILD  = 8;
        internal const int SERVER_DISPATCH         = 9;
        internal const int SERVER_RET_STACK_BUILD  = 10;
        internal const int SERVER_RET_SINK_CHAIN   = 11;
        internal const int SERVER_RET_SER          = 12;
        internal const int SERVER_RET_SEND         = 13;
        internal const int SERVER_RET_END          = 14;
        internal const int CLIENT_RET_RECEIVE      = 15;
        internal const int CLIENT_RET_DESER        = 16;
        internal const int CLIENT_RET_SINK_CHAIN   = 17;
        internal const int CLIENT_RET_PROPAGATION  = 18;
        internal const int CLIENT_END_CALL         = 19;
        internal const int TIMING_DATA_EOF         = 99;

    } // RemotingServices


    /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices"]/*' />
    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]	
    public class InternalRemotingServices
    {

        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices.DebugOutChnl"]/*' />
        [System.Diagnostics.Conditional("_LOGGING")]
        public static void DebugOutChnl(String s)
        {
            // BCLDebug.Trace("REMOTINGCHANNELS", "CHNL:" + s + "\n");
            Message.OutToUnmanagedDebugger("CHNL:"+s+"\n");
            // Console.WriteLine("CHNL:"+s+"\n");
        }


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices.RemotingTrace"]/*' />
        [System.Diagnostics.Conditional("_LOGGING")]                       
        public static void RemotingTrace(params Object[]messages)
        {
                BCLDebug.Trace("REMOTINGCHANNELS",messages);                                                            
        }


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices.RemotingAssert"]/*' />
        [System.Diagnostics.Conditional("_DEBUG")]
        public static void RemotingAssert(bool condition, String message)
        {
                BCLDebug.Assert(condition, message);
        }
        
    
        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices.SetServerIdentity"]/*' />
        [CLSCompliant(false)]
        public static void SetServerIdentity(MethodCall m, Object srvID)
        {
            IInternalMessage im = (IInternalMessage) m;
            im.ServerIdentityObject = (ServerIdentity)srvID;
        }


        
        // access attribute cached on the reflection object
        internal static RemotingMethodCachedData GetReflectionCachedData(MethodBase mi)
        {
            RemotingMethodCachedData cache = null;
            cache = (RemotingMethodCachedData)mi.Cache[CacheObjType.RemotingData];
            if (cache == null)
            {
                cache = new RemotingMethodCachedData(mi);
                mi.Cache[CacheObjType.RemotingData] = cache;
            }
            return cache;
        }// GetCachedRemotingAttribute

        internal static RemotingTypeCachedData GetReflectionCachedData(Type mi)
        {
            RemotingTypeCachedData cache = null;
            cache = (RemotingTypeCachedData)mi.Cache[CacheObjType.RemotingData];
            if (cache == null)
            {
                cache = new RemotingTypeCachedData(mi);
                mi.Cache[CacheObjType.RemotingData] = cache;
            }
            return cache;
        }// GetCachedRemotingAttribute
        
        internal static RemotingCachedData GetReflectionCachedData(MemberInfo mi)
        {
            RemotingCachedData cache = null;
            cache = (RemotingCachedData)mi.Cache[CacheObjType.RemotingData];
            if (cache == null)
            {
                if (mi is MethodBase)
                    cache = new RemotingMethodCachedData(mi);
                else
                    if (mi is Type)
                        cache = new RemotingTypeCachedData(mi);
                    else
                        cache = new RemotingCachedData(mi);

                mi.Cache[CacheObjType.RemotingData] = cache;
            }
            return cache;
        }// GetCachedRemotingAttribute

        internal static RemotingCachedData GetReflectionCachedData(ParameterInfo reflectionObject)
        {                
            RemotingCachedData cache = null;
            cache = (RemotingCachedData)reflectionObject.Cache[CacheObjType.RemotingData];
            if (cache == null)
            {
                cache = new RemotingCachedData(reflectionObject);
                reflectionObject.Cache[CacheObjType.RemotingData] = cache;
            }                    
            
            return cache;
        } // GetCachedRemotingAttribute


        /// <include file='doc\RemotingServices.uex' path='docs/doc[@for="InternalRemotingServices.GetCachedSoapAttribute"]/*' />
        public static SoapAttribute GetCachedSoapAttribute(Object reflectionObject)
        {
            MemberInfo mi = reflectionObject as MemberInfo;
            if (mi != null)
                return GetReflectionCachedData(mi).GetSoapAttribute();
            else
                return GetReflectionCachedData((ParameterInfo)reflectionObject).GetSoapAttribute();
        } // GetCachedSoapAttribute
        
        
    } // InternalRemotingServices
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\ideserializationcallback.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IDeserializationEventListener
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Implemented by any class that wants to indicate that
**          it wishes to receive deserialization events.
**
** Date:  August 16, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {
	using System;
    /// <include file='doc\IDeserializationCallback.uex' path='docs/doc[@for="IDeserializationCallback"]/*' />

    // Interface does not need to be marked with the serializable attribute
    public interface IDeserializationCallback {
        /// <include file='doc\IDeserializationCallback.uex' path='docs/doc[@for="IDeserializationCallback.OnDeserialization"]/*' />
        void OnDeserialization(Object sender);
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\iformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IFormatter;
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The interface for all formatters.
**
** Date:  April 22, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {
	using System.Runtime.Remoting;
	using System;
	using System.IO;

    /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter"]/*' />
    public interface IFormatter {
        /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter.Deserialize"]/*' />
        Object Deserialize(Stream serializationStream);

        /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter.Serialize"]/*' />
        void Serialize(Stream serializationStream, Object graph);


        /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter.SurrogateSelector"]/*' />
        ISurrogateSelector SurrogateSelector {
            get;
            set;
        }

        /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter.Binder"]/*' />
        SerializationBinder Binder {
            get;
            set;
        }

        /// <include file='doc\IFormatter.uex' path='docs/doc[@for="IFormatter.Context"]/*' />
        StreamingContext Context {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Formatter
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The abstract base class for all COM+ Runtime 
**          Serialization Formatters.
**
** Date:  April 22, 1999
**
===========================================================*/


namespace System.Runtime.Serialization {
	using System.Threading;
	using System.Runtime.Remoting;
	using System;
	using System.Collections;
	using System.Reflection;
	using System.IO;
    // This abstract class provides some helper methods for implementing
    // IFormatter.  It will manage queueing objects for serialization
    // (the functionality formerly provided by the IGraphWalker interface)
    // and generating ids on a per-object basis.
    /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter"]/*' />
	 [Serializable,CLSCompliant(false)]
    public abstract class Formatter : IFormatter {
    
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.m_idGenerator"]/*' />
        protected ObjectIDGenerator m_idGenerator;
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.m_objectQueue"]/*' />
        protected Queue m_objectQueue;
    
        // The default constructor instantiates the queue for objects 
        // to be serialized and creates a new instance of the 
        // ObjectIDGenerator.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Formatter"]/*' />
        protected Formatter() {
                m_objectQueue = new Queue();
                m_idGenerator = new ObjectIDGenerator();
        }
    
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Deserialize"]/*' />
        public abstract Object Deserialize(Stream serializationStream);
    
        // This gives back the next object to be serialized.  Objects
        // are returned in a FIFO order based on how they were passed
        // to Schedule.  The id of the object is put into the objID parameter
        // and the Object itself is returned from the function.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.GetNext"]/*' />
        protected virtual Object GetNext(out long objID) {
            bool isNew;
    
            if (m_objectQueue.Count==0) {
                objID=0;
                return null;
            }

            Object obj = m_objectQueue.Dequeue();
            objID = m_idGenerator.HasId(obj, out isNew);
            if (isNew) {
                throw new SerializationException(Environment.GetResourceString("Serialization_NoID"));
            }
            
            return obj;
        }
    
        // Schedules an object for later serialization if it hasn't already been scheduled.
        // We get an ID for obj and put it on the queue for later serialization
        // if this is a new object id.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Schedule"]/*' />
        protected virtual long Schedule(Object obj) {
            bool isNew;
            long id;
    
            if (obj==null) {
                return 0;
            }
    
            id = m_idGenerator.GetId(obj, out isNew);
    
            if (isNew) {
                m_objectQueue.Enqueue(obj);
            }
            return id;
        }
    
    
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Serialize"]/*' />
        public abstract void Serialize(Stream serializationStream, Object graph);
    
        // Writes an array to the stream
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteArray"]/*' />
        protected abstract void WriteArray(Object obj, String name, Type memberType);
        
        // Writes a boolean to the stream.
         /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteBoolean"]/*' />
         protected abstract void WriteBoolean(bool val, String name);
    
        // Writes a byte to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteByte"]/*' />
        protected abstract void WriteByte(byte val, String name);
    
        // Writes a character to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteChar"]/*' />
        protected abstract void WriteChar(char val, String name);
             
        // Writes an instance of DateTime to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteDateTime"]/*' />
        protected abstract void WriteDateTime(DateTime val, String name);
    
        // Writes an instance of Decimal to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteDecimal"]/*' />
        protected abstract void WriteDecimal(Decimal val, String name);
    
        // Writes an instance of Double to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteDouble"]/*' />
        protected abstract void WriteDouble(double val, String name);
    
        // Writes an instance of Int16 to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteInt16"]/*' />
        protected abstract void WriteInt16(short val, String name);
    
        // Writes an instance of Int32 to the stream.
    
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteInt32"]/*' />
        protected abstract void WriteInt32(int val, String name);
    
        // Writes an instance of Int64 to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteInt64"]/*' />
        protected abstract void WriteInt64(long val, String name);
    
        // Writes an object reference to the stream.  Schedules the object with the graph walker
        // to handle the work.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteObjectRef"]/*' />
        protected abstract void WriteObjectRef(Object obj, String name, Type memberType);
    
        // Switches on the type of the member to determine which of the Write* methods
        // to call in order to write this particular member to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteMember"]/*' />
        protected virtual void WriteMember(String memberName, Object data) {

            BCLDebug.Trace("SER", "[Formatter.WriteMember]data: ", data);

            if (data==null) {
                WriteObjectRef(data, memberName, typeof(Object));
                return;
            }

            Type varType = data.GetType();
    
            BCLDebug.Trace("SER", "[Formatter.WriteMember]data is of type: " , varType);

            if (varType==typeof(Boolean)) {
                WriteBoolean(Convert.ToBoolean(data), memberName);
            } else if (varType==typeof(Char)) {
                WriteChar(Convert.ToChar(data), memberName);
            } else if (varType==typeof(SByte)) {
                WriteSByte(Convert.ToSByte(data), memberName);
            } else if (varType==typeof(Byte)) {
                WriteByte(Convert.ToByte(data), memberName);
            } else if (varType==typeof(Int16)) {
                WriteInt16(Convert.ToInt16(data), memberName);
            } else if (varType==typeof(Int32)) {
                WriteInt32(Convert.ToInt32(data), memberName);
            } else if (varType==typeof(Int64)) {
                WriteInt64(Convert.ToInt64(data), memberName);
            } else if (varType==typeof(Single)) {
                WriteSingle(Convert.ToSingle(data), memberName);
            } else if (varType==typeof(Double)) {
                WriteDouble(Convert.ToDouble(data), memberName);
            } else if (varType==typeof(DateTime)) {
                WriteDateTime(Convert.ToDateTime(data), memberName);
            } else if (varType==typeof(Decimal)) {
                WriteDecimal(Convert.ToDecimal(data), memberName);
            } else if (varType==typeof(UInt16)) {
                WriteUInt16(Convert.ToUInt16(data), memberName);
            } else if (varType==typeof(UInt32)) {
                WriteUInt32(Convert.ToUInt32(data), memberName);
            } else if (varType==typeof(UInt64)) {
                WriteUInt64(Convert.ToUInt64(data), memberName);
            } else {
                if (varType.IsArray) {
                    WriteArray(data, memberName, varType);
                } else if (varType.IsValueType) {
                    WriteValueType(data, memberName, varType);
                } else {
                    WriteObjectRef(data, memberName, varType);
                }
            }
        }
            
        // Writes an instance of SByte to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteSByte"]/*' />
        [CLSCompliant(false)]
        protected abstract void WriteSByte(sbyte val, String name);
    
        // Writes an instance of Single to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteSingle"]/*' />
        protected abstract void WriteSingle(float val, String name);
    
        // Writes an instance of TimeSpan to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteTimeSpan"]/*' />
        protected abstract void WriteTimeSpan(TimeSpan val, String name);
    
    
        // Writes an instance of an ushort to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteUInt16"]/*' />
        [CLSCompliant(false)]
        protected abstract void WriteUInt16(ushort val, String name);
    
        // Writes an instance of an uint to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteUInt32"]/*' />
        [CLSCompliant(false)]
        protected abstract void WriteUInt32(uint val, String name);
    
        // Writes an instance of a ulong to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteUInt64"]/*' />
        [CLSCompliant(false)]
        protected abstract void WriteUInt64(ulong val, String name);
    
    
        // Writes a valuetype out to the stream.
        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.WriteValueType"]/*' />
        protected abstract void WriteValueType(Object obj, String name, Type memberType);


        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.SurrogateSelector"]/*' />
        public abstract ISurrogateSelector SurrogateSelector {
            get;
            set;
        }

        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Binder"]/*' />
        public abstract SerializationBinder Binder {
            get;
            set;
        }

        /// <include file='doc\Formatter.uex' path='docs/doc[@for="Formatter.Context"]/*' />
        public abstract StreamingContext Context {
            get;
            set;
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\iformatterconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: IFormatterConverter
**
** Author: Jay Roxe
**
** Purpose: The interface provides the connection between an
** instance of SerializationInfo and the formatter-provided
** class which knows how to parse the data inside the 
** SerializationInfo.
**
** Date: March 26, 2000
**
============================================================*/
namespace System.Runtime.Serialization {
    using System;

    /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter"]/*' />
    [CLSCompliant(false)]
    public interface IFormatterConverter {
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.Convert"]/*' />
        Object Convert(Object value, Type type);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.Convert1"]/*' />
        Object Convert(Object value, TypeCode typeCode);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToBoolean"]/*' />
        bool   ToBoolean(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToChar"]/*' />
        char   ToChar(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToSByte"]/*' />
        sbyte  ToSByte(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToByte"]/*' />
        byte   ToByte(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToInt16"]/*' />
        short  ToInt16(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToUInt16"]/*' />
        ushort ToUInt16(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToInt32"]/*' />
        int    ToInt32(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToUInt32"]/*' />
        uint   ToUInt32(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToInt64"]/*' />
        long   ToInt64(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToUInt64"]/*' />
        ulong  ToUInt64(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToSingle"]/*' />
        float  ToSingle(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToDouble"]/*' />
        double ToDouble(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToDecimal"]/*' />
        Decimal ToDecimal(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToDateTime"]/*' />
        DateTime ToDateTime(Object value);
        /// <include file='doc\IFormatterConverter.uex' path='docs/doc[@for="IFormatterConverter.ToString"]/*' />
        String   ToString(Object value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\iserializable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: ISerializable
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Implemented by any object that needs to control its
**          own serialization.
**
** Date:  April 23, 1999
**
===========================================================*/

namespace System.Runtime.Serialization {
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Security.Permissions;
	using System;
	using System.Reflection;
    /// <include file='doc\ISerializable.uex' path='docs/doc[@for="ISerializable"]/*' />
    public interface ISerializable {
        /// <include file='doc\ISerializable.uex' path='docs/doc[@for="ISerializable.GetObjectData"]/*' />
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        void GetObjectData(SerializationInfo info, StreamingContext context);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatterconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: FormatterConverter
**
** Author: Jay Roxe
**
** Purpose: A base implementation of the IFormatterConverter
**          interface that uses the Convert class and the 
**          IConvertible interface.
**
** Date: March 26, 2000
**
============================================================*/
namespace System.Runtime.Serialization {
    using System;
    using System.Globalization;

    /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter"]/*' />
    public class FormatterConverter : IFormatterConverter {

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.FormatterConverter"]/*' />
        public FormatterConverter() {
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.Convert"]/*' />
        public Object Convert(Object value, Type type) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.Convert1"]/*' />
        public Object Convert(Object value, TypeCode typeCode) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToBoolean"]/*' />
        public bool ToBoolean(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToBoolean(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToChar"]/*' />
        public char   ToChar(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToChar(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToSByte"]/*' />
		[CLSCompliant(false)]
        public sbyte  ToSByte(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToSByte(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToByte"]/*' />
        public byte   ToByte(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToByte(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToInt16"]/*' />
        public short  ToInt16(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToInt16(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToUInt16"]/*' />
        [CLSCompliant(false)]
        public ushort ToUInt16(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToUInt16(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToInt32"]/*' />
        public int    ToInt32(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToInt32(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToUInt32"]/*' />
        [CLSCompliant(false)]
        public uint   ToUInt32(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToUInt32(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToInt64"]/*' />
        public long   ToInt64(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToInt64(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToUInt64"]/*' />
        [CLSCompliant(false)]
        public ulong  ToUInt64(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToUInt64(value, CultureInfo.InvariantCulture);
        } 

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToSingle"]/*' />
        public float  ToSingle(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToSingle(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToDouble"]/*' />
        public double ToDouble(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToDouble(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToDecimal"]/*' />
        public Decimal ToDecimal(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToDecimal(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToDateTime"]/*' />
        public DateTime ToDateTime(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToDateTime(value, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\FormatterConverter.uex' path='docs/doc[@for="FormatterConverter.ToString"]/*' />
        public String   ToString(Object value) {
            if (value==null) {
                throw new ArgumentNullException("value");
            }
            return System.Convert.ToString(value, CultureInfo.InvariantCulture);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\iobjectreference.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: IObjectReference
**
** Author: Jay Roxe (jroxe)
**
** Purpose: Implemented by objects that are actually references
**          to a different object which can't be discovered until
**          this one is completely restored.  During the fixup stage,
**          any object implementing IObjectReference is asked for it's
**          "real" object and that object is inserted into the graph.
**
** Date:  June 16, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {

	using System;
	using System.Security.Permissions;
    /// <include file='doc\IObjectReference.uex' path='docs/doc[@for="IObjectReference"]/*' />
    // Interface does not need to be marked with the serializable attribute
    public interface IObjectReference {
        /// <include file='doc\IObjectReference.uex' path='docs/doc[@for="IObjectReference.GetRealObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]	
        Object GetRealObject(StreamingContext context);
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatterservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: FormatterServices
**
** Author: Jay Roxe
**
** Purpose: Provides some static methods to aid with the implementation
**          of a Formatter for Serialization.
**
** Date: September 27, 1999
**
============================================================*/
namespace System.Runtime.Serialization {
    
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
	using System.Runtime.CompilerServices;
    using StackCrawlMark = System.Threading.StackCrawlMark;
    using System.IO;
    using System.Text;

    /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices"]/*' />
    public sealed class FormatterServices {
    
        internal static Hashtable m_MemberInfoTable = new Hashtable(32);
        private  static bool      m_checkedRegistry       = false;
        private  static bool      m_ignoreSerializationBit = false;
        private  static bool      m_logNonSerializable    = false;
    
        private FormatterServices() {
            throw new NotSupportedException();
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern MemberInfo[] nativeGetSerializableMembers(RuntimeType type, bool bFilterTransient);
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void GetSerializationRegistryValues(out bool checkBit, out bool logNonSerializable);

        private static void WriteNonSerializableMember(Type nonSer) {
            try {
                FileStream stream = new FileStream("C:\\Temp\\NonSerialized", FileMode.Append, FileAccess.Write, FileShare.ReadWrite);
                StreamWriter writer = new StreamWriter(stream);
                writer.WriteLine("Unable to serialize " + nonSer.FullName + " from Module " + nonSer.Module);
                writer.Close();
            } catch (Exception e) {
                //                Console.WriteLine("[WriteNonSerializableMember]Failed with exception ", e)
                BCLDebug.Trace("SER", "[WriteNonSerializableMember]Failed with exception ", e);
            }
        }

        private static bool CheckSerializable(RuntimeType type) {
            if (type.IsSerializable) {
                return true;
            }
            return false;
        }

        private static MemberInfo[] InternalGetSerializableMembers(RuntimeType type, bool excludeNonSerializable) {
            ArrayList allMembers=null;
            MemberInfo[] typeMembers;
            FieldInfo [] typeFields;
            RuntimeType parentType;

            BCLDebug.Assert(type!=null, "[GetAllSerializableMembers]type!=null");
            
            //FUTURE: This works around a miscommunication between the formatters and the infrastructure.
            //When do we need to ask for the members of a type?
            if (type.IsInterface) {
                return new MemberInfo[0];
            }

            if (!m_checkedRegistry) {
                GetSerializationRegistryValues(out m_ignoreSerializationBit, out m_logNonSerializable);
            }

            if (!(CheckSerializable(type))) {
                if (m_logNonSerializable) {
                    WriteNonSerializableMember(type);
                }
                if (!m_ignoreSerializationBit) {
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NonSerType"), type.FullName, type.Module.Assembly.FullName));
                }
            }
          
            //Get all of the serializable members in the class to be serialized.
            typeMembers = nativeGetSerializableMembers(type, excludeNonSerializable);

            //If this class doesn't extend directly from object, walk its hierarchy and 
            //get all of the private and assembly-access fields (e.g. all fields that aren't
            //virtual) and include them in the list of things to be serialized.  
            parentType = (RuntimeType)(type.BaseType);
            if (parentType!=null && parentType!=typeof(Object)) {
                Type[] parentTypes = null;
                int parentTypeCount = 0;
                bool classNamesUnique = GetParentTypes(parentType, out parentTypes, out parentTypeCount);
                if (parentTypeCount > 0){
                    allMembers = new ArrayList();
                    for (int i = 0; i < parentTypeCount;i++){
                        parentType = (RuntimeType)parentTypes[i];
                        if (!CheckSerializable(parentType)) {
                            if (m_logNonSerializable) {
                                WriteNonSerializableMember(parentType);
                            }
                            if (!m_ignoreSerializationBit) {
                                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NonSerType"), parentType.FullName, parentType.Module.Assembly.FullName));
                            }
                        }

                        typeFields = ((RuntimeType)parentType).InternalGetFields(BindingFlags.Instance | BindingFlags.NonPublic, false);
                        String typeName = classNamesUnique ? parentType.Name : parentType.FullName;
                        foreach (FieldInfo field in typeFields) {
                            if (!excludeNonSerializable || !field.IsNotSerialized) {
                                allMembers.Add(new SerializationFieldInfo((RuntimeFieldInfo)field, typeName));
                            }
                        }
                    }
                    //If we actually found any new MemberInfo's, we need to create a new MemberInfo array and
                    //copy all of the members which we've found so far into that.
                    if (allMembers!=null && allMembers.Count>0) {
                        MemberInfo[] membersTemp = new MemberInfo[allMembers.Count + typeMembers.Length];
                        Array.Copy(typeMembers, membersTemp, typeMembers.Length);
                        allMembers.CopyTo(membersTemp, typeMembers.Length);
                        typeMembers = membersTemp;
                    }
                }
            }
            return typeMembers;
        }

        static bool GetParentTypes(Type parentType, out Type[] parentTypes, out int parentTypeCount){
            //Check if there are any dup class names. Then we need to include as part of
            //typeName to prefix the Field names in SerializationFieldInfo
            /*out*/ parentTypes = null;
            /*out*/ parentTypeCount = 0;
            bool unique = true;
            for(Type t1 = parentType;t1 != typeof(object); t1 = t1.BaseType){
                if (t1.IsInterface) continue;
                string t1Name = t1.Name;
                for(int i=0;unique && i<parentTypeCount;i++){
                    string t2Name = parentTypes[i].Name;
                    if (t2Name.Length == t1Name.Length && t2Name[0] == t1Name[0] && t1Name == t2Name){
                        unique = false;
                        break;
                    }
                }
                //expand array if needed
                if (parentTypes == null || parentTypeCount == parentTypes.Length){
                    Type[] tempParentTypes = new Type[Math.Max(parentTypeCount*2, 12)];
                    if (parentTypes != null)
                        Array.Copy(parentTypes, 0, tempParentTypes, 0, parentTypeCount);
                    parentTypes = tempParentTypes;
                }
                parentTypes[parentTypeCount++] = t1;
            }
            return unique;
        }

        // Get all of the Serializable members for a particular class.  For all practical intents and
        // purposes, this is the non-transient, non-static members (fields and properties).  In order to
        // be included, properties must have both a getter and a setter.  N.B.: A class
        // which implements ISerializable or has a serialization surrogate may not use all of these members
        // (or may have additional members).
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.GetSerializableMembers"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static MemberInfo[] GetSerializableMembers(Type type) {
            return GetSerializableMembers(type, new StreamingContext(StreamingContextStates.All));
        }

        // Get all of the Serializable Members for a particular class.  If we're not cloning, this is all
        // non-transient, non-static fields.  If we are cloning, include the transient fields as well since
        // we know that we're going to live inside of the same context.
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.GetSerializableMembers1"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context) {
            MemberInfo[] members;
    
            if (type==null) {
                throw new ArgumentNullException("type");
            }

            if (!(type is RuntimeType)) {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_InvalidType"), type.ToString()));
            }
    
            MemberHolder mh = new MemberHolder(type, context);
    
            //If we've already gathered the members for this type, just return them.
            if ((members=(MemberInfo[])m_MemberInfoTable[mh])!=null) {
                return members;
            }
            
            lock (typeof(FormatterServices)) {
                //If we've already gathered the members for this type, just return them.
                if ((members=(MemberInfo[])m_MemberInfoTable[mh])!=null) {
                    return members;
                }

                //If we're not cloning, get all of the non-transient members.  If we are cloning, then we know that
                //we're going to live inside of the same context, so copy the transient members as well.
                if (context.State==StreamingContextStates.Clone) {
                    members = InternalGetSerializableMembers((RuntimeType)type, false);
                } else {
                    members = InternalGetSerializableMembers((RuntimeType)type, true);
                }
            
                m_MemberInfoTable[mh] = members;
            }
    
            return members;
        }
        
        static Type[] advancedTypes = new Type[]{
            typeof(System.Runtime.Remoting.ObjRef),
            typeof(System.DelegateSerializationHolder),
            typeof(System.Runtime.Remoting.IEnvoyInfo),
            typeof(System.Runtime.Remoting.Lifetime.ISponsor),
        };
  
        public static void CheckTypeSecurity(Type t,  TypeFilterLevel securityLevel) {            
            if (securityLevel == TypeFilterLevel.Low){
                for(int i=0;i<advancedTypes.Length;i++){
                    if (advancedTypes[i].IsAssignableFrom(t))
                        throw new SecurityException(String.Format(Environment.GetResourceString("Serialization_TypeSecurity"), advancedTypes[i].FullName, t.FullName));
                }                  
            } 
        }
    
        // Gets a new instance of the object.  The entire object is initalized to 0 and no 
        // constructors have been run. **THIS MEANS THAT THE OBJECT MAY NOT BE IN A STATE
        // CONSISTENT WITH ITS INTERNAL REQUIREMENTS** This method should only be used for
        // deserialization when the user intends to immediately populate all fields.  This method
        // will not create an unitialized string because it is non-sensical to create an empty
        // instance of an immutable type.
        //
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.GetUninitializedObject"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static Object GetUninitializedObject(Type type) {
            if (type==null) {
                throw new ArgumentNullException("type");
            }
    
            if (!(type is RuntimeType)) {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_InvalidType"), type.ToString()));
            }
                        
            return nativeGetUninitializedObject((RuntimeType)type);
        }
                                                                                                                                      
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static Object GetSafeUninitializedObject(Type type) {
             if (type==null) {
                throw new ArgumentNullException("type");
            }
    
            if (!(type is RuntimeType)) {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_InvalidType"), type.ToString()));
            }
            
            if (type == typeof(System.Runtime.Remoting.Messaging.ConstructionCall) || 
                type == typeof(System.Runtime.Remoting.Messaging.LogicalCallContext) ||
                type == typeof(System.Runtime.Remoting.Contexts.SynchronizationAttribute))
                 return nativeGetUninitializedObject((RuntimeType)type);                                    
                                                                                                           
            try {                            
                return nativeGetSafeUninitializedObject((RuntimeType)type);                    
            }
            catch(SecurityException e) {                
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Security"),  type.FullName), e);
            }                                        
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Object nativeGetSafeUninitializedObject(RuntimeType type);
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern Object nativeGetUninitializedObject(RuntimeType type);

        internal static void SerializationSetValue(MemberInfo fi, Object target, Object value) {
            BCLDebug.Assert(fi is RuntimeFieldInfo || fi is SerializationFieldInfo, 
                            "[SerializationSetValue]fi is RuntimeFieldInfo || fi is SerializationFieldInfo.  Contact JRoxe if you see this assert.");
            RuntimeFieldInfo rfi = fi as RuntimeFieldInfo;
            if (rfi != null) {
                rfi.InternalSetValue(target, value, (BindingFlags)0, Type.DefaultBinder, null, false, true);
            } else {
                ((SerializationFieldInfo)fi).InternalSetValue(target, value, (BindingFlags)0, Type.DefaultBinder, null, false, true);
            }
        }

        internal static void SerializationSetValueDirect(FieldInfo fi, TypedReference target, Object value) {
            BCLDebug.Assert(fi is RuntimeFieldInfo, "[SerializationSetValue]fi is RuntimeFieldInfo.  Contact JRoxe if you see this assert.");
            ((RuntimeFieldInfo)fi).SetValueDirectImpl(target, value, false);
        }
    
        // Fill in the members of obj with the data contained in data.
        // Returns the number of members populated.
        //
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.PopulateObjectMembers"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static Object PopulateObjectMembers(Object obj, MemberInfo[] members, Object[] data) {
            MemberInfo mi;
    
            BCLDebug.Trace("SER", "[PopulateObjectMembers]Enter.");
            

            if (obj==null) {
                throw new ArgumentNullException("obj");
            }

            if (members==null) {
                throw new ArgumentNullException("members");
            }

            if (data==null) {
                throw new ArgumentNullException("data");
            }

            if (members.Length!=data.Length) {
                throw new ArgumentException(Environment.GetResourceString("Argument_DataLengthDifferent"));
            }

            for (int i=0; i<members.Length; i++) {
                mi = members[i];
    
                if (mi==null) {
                    throw new ArgumentNullException("members", String.Format(Environment.GetResourceString("ArgumentNull_NullMember"), i));
                }
    
    
                //If we find an empty, it means that the value was never set during deserialization.
                //This is either a forward reference or a null.  In either case, this may break some of the
                //invariants mantained by the setter, so we'll do nothing with it for right now.
                if (data[i]!=null) {
                    if (mi.MemberType==MemberTypes.Field) {
                        SerializationSetValue(mi, obj, data[i]);
                    } else {
                        throw new SerializationException(Environment.GetResourceString("Serialization_UnknownMemberInfo"));
                    }

                    BCLDebug.Trace("SER", "[PopulateObjectMembers]\tType:", obj.GetType(), "\tMember:", 
                                   members[i].Name, " with member type: ", ((FieldInfo)members[i]).FieldType);
                }
                //Console.WriteLine("X");
            }
            
            BCLDebug.Trace("SER", "[PopulateObjectMembers]Leave.");

            return obj;
        }
    
        // Extracts the data from obj.  members is the array of members which we wish to
        // extract (must be FieldInfos or PropertyInfos).  For each supplied member, extract the matching value and
        // return it in a Object[] of the same size.
        //
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.GetObjectData"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        public static Object[] GetObjectData(Object obj, MemberInfo[] members) {
    
            if (obj==null) {
                throw new ArgumentNullException("obj");
            }
    
            if (members==null) {
                throw new ArgumentNullException("members");
            }
            
            int numberOfMembers = members.Length;
    
            Object[] data = new Object[numberOfMembers];
            MemberInfo mi;
    
            for (int i=0; i<numberOfMembers; i++) {
                mi=members[i];
    
                if (mi==null) {
                    throw new ArgumentNullException("members", String.Format(Environment.GetResourceString("ArgumentNull_NullMember"), i));
                }
    
                if (mi.MemberType==MemberTypes.Field) {
                    BCLDebug.Assert(mi is RuntimeFieldInfo || mi is SerializationFieldInfo,
                                    "[FormatterServices.GetObjectData]mi is RuntimeFieldInfo || mi is SerializationFieldInfo.  Contact JRoxe if you see this assert.");
                    RuntimeFieldInfo rfi = mi as RuntimeFieldInfo;
                    if (rfi != null) {
                        data[i] = rfi.InternalGetValue(obj, false);
                    } else {
                        data[i] = ((SerializationFieldInfo)mi).InternalGetValue(obj, false);
                    }
                } else {
                    throw new SerializationException(Environment.GetResourceString("Serialization_UnknownMemberInfo"));
                }
            }
    
            return data;
        }

        
        /*=============================GetTypeFromAssembly==============================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        /// <include file='doc\FormatterServices.uex' path='docs/doc[@for="FormatterServices.GetTypeFromAssembly"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)]
        [ReflectionPermissionAttribute(SecurityAction.LinkDemand, TypeInformation=true)]
        public static Type GetTypeFromAssembly(Assembly assem, String name) {
            if (assem==null)
                throw new ArgumentNullException("assem");
                                            
            return assem.GetTypeInternal(name, false, false, false);
        }
    
        /*============================LoadAssemblyFromString============================
        **Action: Loads an assembly from a given string.  The current assembly loading story
        **        is quite confusing.  If the assembly is in the fusion cache, we can load it
        **        using the stringized-name which we transmitted over the wire.  If that fails,
        **        we try for a lookup of the assembly using the simple name which is the first
        **        part of the assembly name.  If we can't find it that way, we'll return null
        **        as our failure result.
        **Returns: The loaded assembly or null if it can't be found.
        **Arguments: assemblyName -- The stringized assembly name.
        **Exceptions: None
        ==============================================================================*/
        internal static Assembly LoadAssemblyFromString(String assemblyName) {
            //
            // Try using the stringized assembly name to load from the fusion cache.
            //
            BCLDebug.Trace("SER", "[LoadAssemblyFromString]Looking for assembly: ", assemblyName);
            Assembly found = Assembly.Load(assemblyName);            
            return found;
        }
        internal static Assembly LoadAssemblyFromStringNoThrow(String assemblyName) {
            try {                
                return LoadAssemblyFromString(assemblyName);
            }
            catch (Exception e){
                BCLDebug.Trace("SER", "[LoadAssemblyFromString]", e.ToString());
            }
            return null;
        }                                                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\isurrogateselector.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: ISurrogateSelector
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A user-supplied class for doing the type to surrogate
**          mapping.
**
** Date:  April 23, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {

	using System.Runtime.Remoting;
	using System.Security.Permissions;
	using System;
    /// <include file='doc\ISurrogateSelector.uex' path='docs/doc[@for="ISurrogateSelector"]/*' />
    public interface ISurrogateSelector {
        /// <include file='doc\ISurrogateSelector.uex' path='docs/doc[@for="ISurrogateSelector.ChainSelector"]/*' />
        // Interface does not need to be marked with the serializable attribute
        // Specifies the next ISurrogateSelector to be examined for surrogates if the current
        // instance doesn't have a surrogate for the given type and assembly in the given context.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        void ChainSelector(ISurrogateSelector selector);
        /// <include file='doc\ISurrogateSelector.uex' path='docs/doc[@for="ISurrogateSelector.GetSurrogate"]/*' />
    
        // Returns the appropriate surrogate for the given type in the given context.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);
        /// <include file='doc\ISurrogateSelector.uex' path='docs/doc[@for="ISurrogateSelector.GetNextSelector"]/*' />
    
    
        // Return the next surrogate in the chain. Returns null if no more exist.
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        ISurrogateSelector GetNextSelector();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\iserializationsurrogate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: ISurrogate
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The interface implemented by an object which
**          supports surrogates.
**
** Date:  April 23, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Security.Permissions;
	using System;
	using System.Reflection;
    /// <include file='doc\ISerializationSurrogate.uex' path='docs/doc[@for="ISerializationSurrogate"]/*' />
    public interface ISerializationSurrogate {
        /// <include file='doc\ISerializationSurrogate.uex' path='docs/doc[@for="ISerializationSurrogate.GetObjectData"]/*' />
    // Interface does not need to be marked with the serializable attribute
        // Returns a SerializationInfo completely populated with all of the data needed to reinstantiate the
        // the object at the other end of serialization.  
        //
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        void GetObjectData(Object obj, SerializationInfo info, StreamingContext context);
        /// <include file='doc\ISerializationSurrogate.uex' path='docs/doc[@for="ISerializationSurrogate.SetObjectData"]/*' />
    
        // Reinflate the object using all of the information in data.  The information in
        // members is used to find the particular field or property which needs to be set.
        // 
	[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        Object SetObjectData(Object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\memberholder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: MemberHolder
**
** Author: Jay Roxe
**
** Purpose: This is a lightweight class designed to hold the members 
**          and StreamingContext for a particular class.
**
** Date: February 18, 2000
**
============================================================*/
namespace System.Runtime.Serialization {

	using System.Runtime.Remoting;
	using System;
	using System.Reflection;
	[Serializable()]
    internal class MemberHolder {
        internal MemberInfo[] members = null;
        internal Type memberType;
        internal StreamingContext context;
        
        internal MemberHolder(Type type, StreamingContext ctx) {
            memberType = type;
            context = ctx;
        }
    
        public override int GetHashCode() {
            return memberType.GetHashCode();
        }
    
        public override bool Equals(Object obj) {
            if (!(obj is MemberHolder)) {
                return false;
            }
            
            MemberHolder temp = (MemberHolder)obj;
    
            if (temp.memberType==memberType && temp.context.State == context.State) {
                return true;
            }
            
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\objectidgenerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: ObjectIDGenerator
**
** Author: Jay Roxe (jroxe)
**
** Purpose: ObjectIDGenerator is a simple id generator that keeps track of 
** objects with a hashtable.
**
** Date:  April 23, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {
	using System;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;

    /// <include file='doc\ObjectIDGenerator.uex' path='docs/doc[@for="ObjectIDGenerator"]/*' />
	[Serializable()]
    public class ObjectIDGenerator {
    
        private const int numbins = 4;
    
        internal int m_currentCount;
        internal int m_currentSize;
        internal long []m_ids;
        internal Object []m_objs;
        
        // Table of prime numbers to use as hash table sizes. Each entry is the
        // smallest prime number larger than twice the previous entry.
        private static readonly int[] sizes = {
            5, 11, 29, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437,
            102877, 205759, 411527, 823117, 1646237, 3292489, 6584983};
    
        // Constructs a new ObjectID generator, initalizing all of the necessary variables.
        /// <include file='doc\ObjectIDGenerator.uex' path='docs/doc[@for="ObjectIDGenerator.ObjectIDGenerator"]/*' />
        public ObjectIDGenerator() {
            m_currentCount=1;
            m_currentSize = sizes[0];
            m_ids = new long[m_currentSize*numbins];
            m_objs = new Object[m_currentSize*numbins];
        }
    
        // Determines where element obj lives, or should live, 
        // within the table. It calculates the hashcode and searches all of the
        // bins where the given object could live.  If it's not found within the bin, 
        // we rehash and go look for it in another bin.  If we find the object, we
        // set found to true and return it's position.  If we can't find the object,
        // we set found to false and return the position where the object should be inserted.
        //
        private int FindElement(Object obj, int hashcode, out bool found) {
            //This double-hashing algorithm is recomended by CLR, pg 236.
            //We're hosed if somebody rehashes the table while we're doing the lookup, but that's
            //generally true for most of these operations.
            int hashIncrement = (1+((hashcode&0x7FFFFFFF)%(m_currentSize-2)));        
            do {
                int pos = ((hashcode&0x7FFFFFFF)%m_currentSize)*numbins;

                for (int i=pos; i<pos+numbins; i++) {
                    if (m_objs[i]==null) {
                        found=false;
                        return i;
                    }
                    if (m_objs[i]==obj) {
                        found=true;
                        return i;
                    }
                }
                hashcode+=hashIncrement;
                //the seemingly infinite loop must be revisited later. Currently it is assumed that
                //always the array will be expanded (Rehash) when it is half full
            }while(true);
        }
    
    
        // Gets the id for a particular object, generating one if needed.  GetID calls
        // FindElement to find out where the object lives or should live.  If we didn't
        // find the element, we generate an object id for it and insert the pair into the
        // table.  We return an Int64 for the object id.  The out parameter firstTime
        // is set to true if this is the first time that we have seen this object.
        //
        /// <include file='doc\ObjectIDGenerator.uex' path='docs/doc[@for="ObjectIDGenerator.GetId"]/*' />
        public virtual long GetId(Object obj, out bool firstTime) {
            bool found;
            long foundID;
            
            if (obj==null) {
                throw new ArgumentNullException("obj", Environment.GetResourceString("ArgumentNull_Obj"));
            }

            int pos = FindElement(obj, obj.GetHashCode(), out found);
    
            //We pull out foundID so that rehashing doesn't cause us to lose track of the id that we just found.
            if (!found) {
    
                BCLDebug.Trace("SER", "[ObjectIDGenerator.GetID] Adding objectid: ", (m_currentCount), " and hash code: ", 
                               obj.GetHashCode(), " at pos: ", pos, " Type: ", obj, "IsTransparentProxy: ",
                               System.Runtime.Remoting.RemotingServices.IsTransparentProxy(obj));
    
                //We didn't actually find the object, so we should need to insert it into
                //the array and assign it an object id.
                m_objs[pos]=obj;
                m_ids[pos]=m_currentCount++;
                foundID=m_ids[pos]; 
                if (m_currentCount > (m_currentSize*numbins)/2) {
                    Rehash();
                }
            } else {
                BCLDebug.Trace("SER", "[ObjectIDGenerator.GetID] Found objectid: ", (m_ids[pos]), " with hashcode: ", obj.GetHashCode(), " Type: ", obj);
                foundID = m_ids[pos];
            }
            firstTime = !found;
    
            return foundID;
        }
    
        // Checks to see if obj has already been assigned an id.  If it has,
        // we return that id, otherwise we return 0.
        // 
        /// <include file='doc\ObjectIDGenerator.uex' path='docs/doc[@for="ObjectIDGenerator.HasId"]/*' />
        public virtual long HasId(Object obj, out bool firstTime) {
            bool found;
    
            if (obj==null) {
                throw new ArgumentNullException("obj", Environment.GetResourceString("ArgumentNull_Obj"));
            }
    
            int pos = FindElement(obj, obj.GetHashCode(), out found);
            if (found) {
                firstTime = false;
                return m_ids[pos];
            }
            firstTime=true;
            return 0;
        }
    
        // Rehashes the table by finding the next larger size in the list provided,
        // allocating two new arrays of that size and rehashing all of the elements in
        // the old arrays into the new ones.  Expensive but necessary.
        //
        private void Rehash() {
            int i,pos;
            long [] newIds;
            long [] oldIds;
            Object[] newObjs;
            Object[] oldObjs;
            bool found;
            int currSize;
    
            for (i=0, currSize=m_currentSize; i<sizes.Length && sizes[i]<=currSize; i++);
            if (i==sizes.Length) {
                //We just walked off the end of the array, what would you like to do now?
                //We're pretty much hosed at this point, so just keep going.
                throw new SerializationException(Environment.GetResourceString("Serialization_TooManyElements"));
            }
            m_currentSize = sizes[i];
    
            newIds = new long[m_currentSize*numbins];
            newObjs = new Object[m_currentSize*numbins];
    
            oldIds = m_ids;
            oldObjs = m_objs;
    
            m_ids = newIds;
            m_objs = newObjs;
            
            for (int j=0; j<oldObjs.Length; j++) {
                if (oldObjs[j]!=null) {
                    pos = FindElement(oldObjs[j], oldObjs[j].GetHashCode(), out found);
                    m_objs[pos]=oldObjs[j];
                    m_ids[pos] = oldIds[j];
                }
            }
        }
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\serializationinfoenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: SerializationInfoEnumerator
**
** Author: Jay Roxe
**
** Purpose: A formatter-friendly mechanism for walking all of
** the data in a SerializationInfo.  Follows the IEnumerator 
** mechanism from Collections.
**
** Date: March 26, 2000
**
============================================================*/
namespace System.Runtime.Serialization {
    using System;
    using System.Collections;

    //
    // The tuple returned by SerializationInfoEnumerator.Current.
    //
    /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationEntry"]/*' />
    public struct SerializationEntry {
        private Type   m_type;
        private Object m_value;
        private String m_name;

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationEntry.Value"]/*' />
        public Object Value {
            get {
                return m_value;
            }
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationEntry.Name"]/*' />
        public String Name {
            get {
                return m_name;
            }
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationEntry.ObjectType"]/*' />
        public Type ObjectType {
            get {
                return m_type;
            }
        }

        internal SerializationEntry(String entryName, Object entryValue, Type entryType) {
            m_value = entryValue;
            m_name = entryName;
            m_type = entryType;
        }
    }

    //
    // A simple enumerator over the values stored in the SerializationInfo.
    // This does not snapshot the values, it just keeps pointers to the 
    // member variables of the SerializationInfo that created it.
    //
    /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator"]/*' />
    public sealed class SerializationInfoEnumerator : IEnumerator {
        String[] m_members;
        Object[] m_data;
        Type[]   m_types;
        int      m_numItems;
        int      m_currItem;
        bool     m_current;

        internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems) {
            BCLDebug.Assert(members!=null, "[SerializationInfoEnumerator.ctor]members!=null");
            BCLDebug.Assert(info!=null, "[SerializationInfoEnumerator.ctor]info!=null");
            BCLDebug.Assert(types!=null, "[SerializationInfoEnumerator.ctor]types!=null");
            BCLDebug.Assert(numItems>=0, "[SerializationInfoEnumerator.ctor]numItems>=0");
            BCLDebug.Assert(members.Length>=numItems, "[SerializationInfoEnumerator.ctor]members.Length>=numItems");
            BCLDebug.Assert(info.Length>=numItems, "[SerializationInfoEnumerator.ctor]info.Length>=numItems");
            BCLDebug.Assert(types.Length>=numItems, "[SerializationInfoEnumerator.ctor]types.Length>=numItems");

            m_members = members;
            m_data = info;
            m_types = types;
            //The MoveNext semantic is much easier if we enforce that [0..m_numItems] are valid entries
            //in the enumerator, hence we subtract 1.
            m_numItems = numItems-1;
            m_currItem = -1;
            m_current = false;
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.MoveNext"]/*' />
        public bool MoveNext() {
            if (m_currItem<m_numItems) {
                m_currItem++;
                m_current = true;
            } else {
                m_current = false;
            }
            return m_current;
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.IEnumerator.Current"]/*' />
        /// <internalonly/>
        Object IEnumerator.Current { //Actually returns a SerializationEntry
            get {
                if (m_current==false) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                }
                return (Object)(new SerializationEntry(m_members[m_currItem], m_data[m_currItem], m_types[m_currItem]));
            }
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.Current"]/*' />
        public SerializationEntry Current { //Actually returns a SerializationEntry
            get {
                if (m_current==false) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                }
                return (new SerializationEntry(m_members[m_currItem], m_data[m_currItem], m_types[m_currItem]));
            }
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.Reset"]/*' />
        public void Reset() {
            m_currItem = -1;
            m_current = false;
        }

        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.Name"]/*' />
        public String Name {
            get {
                if (m_current==false) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                }
                return m_members[m_currItem];
            }
        }
        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.Value"]/*' />
        public Object Value {
            get {
                if (m_current==false) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                }
                return m_data[m_currItem];
            }
        }
        /// <include file='doc\SerializationInfoEnumerator.uex' path='docs/doc[@for="SerializationInfoEnumerator.ObjectType"]/*' />
        public Type ObjectType {
            get {
                if (m_current==false) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_EnumOpCantHappen"));
                }
                return m_types[m_currItem];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\serializationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SerializationException
**
** Author: Jay Roxe
**
** Purpose: Thrown when something goes wrong during serialization or 
**          deserialization.
**
** Date: May 11, 1999
**
=============================================================================*/

namespace System.Runtime.Serialization {
    
	using System;
	using System.Runtime.Serialization;

    /// <include file='doc\SerializationException.uex' path='docs/doc[@for="SerializationException"]/*' />
    [Serializable] public class SerializationException : SystemException {
    	
    	private static String _nullMessage = Environment.GetResourceString("Arg_SerializationException");
    	
        // Creates a new SerializationException with its message 
        // string set to a default message.
        /// <include file='doc\SerializationException.uex' path='docs/doc[@for="SerializationException.SerializationException"]/*' />
        public SerializationException() 
            : base(_nullMessage) {
    		SetErrorCode(__HResults.COR_E_SERIALIZATION);
        }
    	
        /// <include file='doc\SerializationException.uex' path='docs/doc[@for="SerializationException.SerializationException1"]/*' />
        public SerializationException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_SERIALIZATION);
        }

        /// <include file='doc\SerializationException.uex' path='docs/doc[@for="SerializationException.SerializationException2"]/*' />
        public SerializationException(String message, Exception innerException) : base (message, innerException) {
    		SetErrorCode(__HResults.COR_E_SERIALIZATION);
        }

        /// <include file='doc\SerializationException.uex' path='docs/doc[@for="SerializationException.SerializationException3"]/*' />
        protected SerializationException(SerializationInfo info, StreamingContext context) : base (info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\serializationbinder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Interface: SerializationBinder
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The base class of serialization binders.
**
** Date:  Jan 4, 2000
**
===========================================================*/
namespace System.Runtime.Serialization {
	using System;

    /// <include file='doc\SerializationBinder.uex' path='docs/doc[@for="SerializationBinder"]/*' />
	[Serializable]
    public abstract class SerializationBinder {

        /// <include file='doc\SerializationBinder.uex' path='docs/doc[@for="SerializationBinder.BindToType"]/*' />
        public abstract Type BindToType(String assemblyName, String typeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\serializationfieldinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: SerializationFieldInfo
**
** Author: Jay Roxe
**
** Purpose: Provides a methods of representing imaginary fields
** which are unique to serialization.  In this case, what we're
** representing is the private members of parent classes.  We
** aggregate the RuntimeFieldInfo associated with this member 
** and return a managled form of the name.  The name that we
** return is .parentname.fieldname
**
** Date: April 6, 2000
**
============================================================*/
using System;
using System.Reflection;
using System.Globalization;

namespace System.Runtime.Serialization {

    internal sealed class SerializationFieldInfo : FieldInfo {

        internal static readonly char   FakeNameSeparatorChar   = '+';
        internal static readonly String FakeNameSeparatorString = "+";

        private RuntimeFieldInfo m_field;
        private String           m_serializationName;

        internal SerializationFieldInfo(RuntimeFieldInfo field, String namePrefix) {
            BCLDebug.Assert(field!=null,      "[SerializationFieldInfo.ctor]field!=null");
            BCLDebug.Assert(namePrefix!=null, "[SerializationFieldInfo.ctor]namePrefix!=null");
            
            m_field = field;
            m_serializationName = String.Concat(namePrefix, FakeNameSeparatorString, m_field.Name);
        }

        //
        // MemberInfo methods
        //
        public override String Name {
            get {
                return m_serializationName;
            }
        }

        public override Type DeclaringType {
            get {
                return m_field.DeclaringType;
            }
        }

        public override Type ReflectedType {
            get {
                return m_field.ReflectedType;
            }
        }

        public override Object[] GetCustomAttributes(bool inherit) {
            return m_field.GetCustomAttributes(inherit);
        }

        public override Object[] GetCustomAttributes(Type attributeType, bool inherit) {
            return m_field.GetCustomAttributes(attributeType, inherit);
        }

        public override bool IsDefined(Type attributeType, bool inherit) {
            return m_field.IsDefined(attributeType, inherit);
        }

        //
        // FieldInfo methods
        //
        public override Type FieldType {
            get {
                return m_field.FieldType;
            }
        }
        
        public override Object GetValue(Object obj) {
            return m_field.GetValue(obj);
        }

        internal Object InternalGetValue(Object obj, bool requiresAccessCheck) {
            return m_field.InternalGetValue(obj, requiresAccessCheck);
        }

        public override void SetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture) {
            m_field.SetValue(obj, value, invokeAttr, binder, culture);
        }

        internal void InternalSetValue(Object obj, Object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture, bool requiresAccessCheck, bool isBinderDefault) {
            m_field.InternalSetValue(obj, value, invokeAttr, binder, culture, requiresAccessCheck, isBinderDefault);
        }

        public override RuntimeFieldHandle FieldHandle {
            get {
                return m_field.FieldHandle;
            }
        }

        public override FieldAttributes Attributes {
            get {
                return m_field.Attributes;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\streamingcontext.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** ValueType: StreamingContext
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A value type indicating the source or destination of our streaming.
**
** Date:  April 23, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {

	using System.Runtime.Remoting;
	using System;
    /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext"]/*' />
    [Serializable]
    public struct StreamingContext {
        internal Object m_additionalContext;
        internal StreamingContextStates m_state;
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.StreamingContext"]/*' />
        public StreamingContext(StreamingContextStates state) 
            : this (state, null) {
        }
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.StreamingContext1"]/*' />
        public StreamingContext(StreamingContextStates state, Object additional) {
            m_state = state;
            m_additionalContext = additional;
        }
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.Context"]/*' />
        public Object Context {
            get { return m_additionalContext; }
        }
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is StreamingContext)) {
                return false;
            }
            if (((StreamingContext)obj).m_additionalContext == m_additionalContext &&
                ((StreamingContext)obj).m_state == m_state) {
                return true;
            } 
            return false;
        }
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)m_state;
        }
    
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContext.State"]/*' />
        public StreamingContextStates State {
            get { return m_state; } 
        }
    }
    
    /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates"]/*' />
    [Serializable, Flags]
    public enum StreamingContextStates {
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.CrossProcess"]/*' />
        CrossProcess=0x01,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.CrossMachine"]/*' />
        CrossMachine=0x02,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.File"]/*' />
        File        =0x04,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.Persistence"]/*' />
        Persistence =0x08,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.Remoting"]/*' />
        Remoting    =0x10,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.Other"]/*' />
        Other       =0x20,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.Clone"]/*' />
        Clone       =0x40,
        /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.CrossAppDomain"]/*' />
        CrossAppDomain =0x80,
            /// <include file='doc\StreamingContext.uex' path='docs/doc[@for="StreamingContextStates.All"]/*' />
        All         =0xFF,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\surrogateselector.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: SurrogateSelector
**
** Author: Jay Roxe (jroxe)
**
** Purpose: A user-supplied class for doing the type to surrogate
**          mapping.
**
** Date:  April 23, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {

	using System.Runtime.Remoting;
	using System;
	using System.Collections;
	using System.Security.Permissions;
    /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector"]/*' />
    public class SurrogateSelector : ISurrogateSelector {
        
        internal SurrogateHashtable m_surrogates;
        internal ISurrogateSelector m_nextSelector;
    
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.SurrogateSelector"]/*' />
        public SurrogateSelector() {
            m_surrogates = new SurrogateHashtable(32);
        }
    
        // Adds a surrogate to the list of surrogates checked.
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.AddSurrogate"]/*' />
        public virtual void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate) {
            if (type==null) {
                throw new ArgumentNullException("type");
            }
            if (surrogate==null) {
                throw new ArgumentNullException("surrogate");
            }
    
            SurrogateKey key = new SurrogateKey(type, context);
            m_surrogates.Add(key, surrogate);  // Hashtable does duplicate checking.
        }
    
        private static bool HasCycle(ISurrogateSelector selector) {
            ISurrogateSelector head;
            ISurrogateSelector tail;
            
            BCLDebug.Assert(selector!=null, "[HasCycle]selector!=null");


            head = selector;
            tail = selector;

            while (head!=null) {
                head = head.GetNextSelector();
                if (head==null) {
                    return true;
                }
                if (head==tail) {
                    return false;
                }
                head = head.GetNextSelector();
                tail = tail.GetNextSelector();

                if (head==tail) {
                    return false;
                }
            }

            return true;
            
        }

        // Adds another selector to check if we don't have  match within this selector.
        // The logic is:"Add this onto the list as the first thing that you check after yourself."
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.ChainSelector"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        public virtual void ChainSelector(ISurrogateSelector selector) {
            ISurrogateSelector temp;
            ISurrogateSelector tempCurr;
            ISurrogateSelector tempPrev;
            ISurrogateSelector tempEnd;
            
            if (selector==null) {
                throw new ArgumentNullException("selector");
            }
    
            //
            // Verify that we don't try and add ourself twice.
            //
            if (selector==this) {
                throw new SerializationException(Environment.GetResourceString("Serialization_DuplicateSelector"));
            }
            
            //
            // Verify that the argument doesn't contain a cycle.
            //
            if (!HasCycle(selector)) {
                throw new ArgumentException(Environment.GetResourceString("Serialization_SurrogateCycleInArgument"), "selector");
            }

            //
            // Check for a cycle that would lead back to this.  We find the end of the list that we're being asked to 
            // insert for use later.
            //
            tempCurr = selector.GetNextSelector();
            tempEnd = selector;
            while (tempCurr!=null && tempCurr!=this) {
                tempEnd = tempCurr;
                tempCurr = tempCurr.GetNextSelector();
            }
            if (tempCurr==this) {
                throw new ArgumentException(Environment.GetResourceString("Serialization_SurrogateCycle"), "selector");
            }

            //
            // Check for a cycle later in the list which would be introduced by this insertion.
            //
            tempCurr = selector;
            tempPrev = selector;
            while(tempCurr!=null) {
                if (tempCurr==tempEnd) {
                    tempCurr = this.GetNextSelector();
                } else {
                    tempCurr = tempCurr.GetNextSelector();
                }
                if (tempCurr==null) {
                    break;
                }
                if (tempCurr==tempPrev) {
                    throw new ArgumentException(Environment.GetResourceString("Serialization_SurrogateCycle"), "selector");
                }

                if (tempCurr==tempEnd) {
                    tempCurr = this.GetNextSelector();
                } else {
                    tempCurr = tempCurr.GetNextSelector();
                }


                if (tempPrev==tempEnd) {
                    tempPrev = this.GetNextSelector();
                } else {                    
                    tempPrev = tempPrev.GetNextSelector();
                }
                if (tempCurr==tempPrev) {
                    throw new ArgumentException(Environment.GetResourceString("Serialization_SurrogateCycle"), "selector");
                }
            }

            //
            // Add the new selector and it's entire chain of selectors as the next thing that
            // we check.  
            //
            temp = m_nextSelector;
            m_nextSelector = selector;
            if (temp!=null) {
                tempEnd.ChainSelector(temp);
            }
        }
    
        // Get the next selector on the chain of selectors.
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.GetNextSelector"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        public virtual ISurrogateSelector GetNextSelector() {
            return m_nextSelector;
        }
    
        // Gets the surrogate for a particular type.  If this selector can't
        // provide a surrogate, it checks with all of it's children before returning null.
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.GetSurrogate"]/*' />
        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
        public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector) {
            if (type==null) {
                throw new ArgumentNullException("type");
            }
    
            selector = this;
    
            SurrogateKey key = new SurrogateKey(type, context);
            ISerializationSurrogate temp = (ISerializationSurrogate)m_surrogates[key];
            if (temp!=null) {
                return temp;
            }
            if (m_nextSelector!=null) {
                return m_nextSelector.GetSurrogate(type, context, out selector);
            }
            return null;
        }
        
        // Removes the surrogate associated with a given type.  Does not
        // check chained surrogates.  
        /// <include file='doc\SurrogateSelector.uex' path='docs/doc[@for="SurrogateSelector.RemoveSurrogate"]/*' />
        public virtual void RemoveSurrogate(Type type, StreamingContext context) {
            if (type==null) {
                throw new ArgumentNullException("type");
            }
            
    
            SurrogateKey key = new SurrogateKey(type, context);
            m_surrogates.Remove(key);
        }
    }
    
    //This is a pretty useless wrapper at the moment.  Expand it to include
    //a notion of the StreamingContext.
	[Serializable()]
    internal class SurrogateKey {
        internal Type m_type;
        internal StreamingContext m_context;
    
        internal SurrogateKey(Type type, StreamingContext context) {
            m_type = type;
            m_context = context;
        }
    
        public override int GetHashCode() {
            return m_type.GetHashCode();
        }
    }

    // Subclass to override KeyEquals.
    class SurrogateHashtable : Hashtable {
        internal SurrogateHashtable(int size):base(size){
            ;
        }
        // Must return true if the context to serialize for (givenContext)
        // is a subset of the context for which the serialization selector is provided (presentContext)
        // Note: This is done by overriding KeyEquals rather than overriding Equals() in the SurrogateKey
        // class because Equals() method must be commutative. 
    	protected override bool KeyEquals(Object item, Object key){
            SurrogateKey givenValue = (SurrogateKey)item;
            SurrogateKey presentValue = (SurrogateKey)key;
            return presentValue.m_type == givenValue.m_type &&
                   (presentValue.m_context.m_state & givenValue.m_context.m_state) == givenValue.m_context.m_state &&
                   presentValue.m_context.Context == givenValue.m_context.Context;
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\ifieldinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
 /*============================================================
 **
 ** Class: IFieldInfo
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Interface For Returning FieldNames and FieldTypes
 **
 ** Date:  October 6, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters {

	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System.Security.Permissions;
	using System;

    /// <include file='doc\IFieldInfo.uex' path='docs/doc[@for="IFieldInfo"]/*' />
    public interface IFieldInfo
    {
		/// <include file='doc\IFieldInfo.uex' path='docs/doc[@for="IFieldInfo.FieldNames"]/*' />
    	// Name of parameters, if null the default param names will be used
		String[] FieldNames 
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
		    get;
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
		    set;
		}
		/// <include file='doc\IFieldInfo.uex' path='docs/doc[@for="IFieldInfo.FieldTypes"]/*' />
		Type[] FieldTypes 
		{
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
		    get;
		    [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter)] 		
		    set;
		}		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\isoapmessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
 /*============================================================
 **
 ** Class: ISoapMessage
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Interface For Soap Method Call
 **
 ** Date:  October 6, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters {

    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Runtime.Remoting.Messaging;    
    using System;
    // Used to specify a call record to either the binary or xml serializer
    // The call record can be transmitted as the SOAP Top record which contains
    // a method name instead of an object name as the Top record's element name
    /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage"]/*' />
    public interface ISoapMessage
    {
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.ParamNames"]/*' />
        // Name of parameters, if null the default param names will be used

        String[] ParamNames {get; set;}
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.ParamValues"]/*' />
    
        // Parameter Values
        Object[] ParamValues {get; set;}
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.ParamTypes"]/*' />

        // Parameter Types
        Type[] ParamTypes {get; set;}        
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.MethodName"]/*' />
    
        // MethodName
        String MethodName {get; set;}
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.XmlNameSpace"]/*' />

        // MethodName XmlNameSpace
        String XmlNameSpace {get; set;}
        /// <include file='doc\ISoapMessage.uex' path='docs/doc[@for="ISoapMessage.Headers"]/*' />

        // Headers
        Header[] Headers {get; set;}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\objectmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: ObjectManager
**
** Author: Jay Roxe
**
** Purpose: 
**
** Date: 
**
============================================================*/
namespace System.Runtime.Serialization {
	using System;
	using System.Collections;
	using System.Diagnostics;
	using System.Reflection;
	using System.Reflection.Cache;
	using System.Runtime.Remoting;
    using System.Security.Permissions;
    using System.Security;
	using System.Runtime.Remoting.Messaging;

    /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager"]/*' />
    public class ObjectManager {
        private const int DefaultInitialSize=16;
        private const int MaxArraySize=0x1000; //MUST BE A POWER OF 2!
        private const int ArrayMask = MaxArraySize-1;
        private const int MaxReferenceDepth = 100;
        
        private DeserializationEventHandler m_onDeserializationHandler;
        private static Type[] SIConstructorTypes;
    
        internal ObjectHolder []    m_objects;
        internal ObjectHolderList   m_specialFixupObjects; //This is IObjectReference, ISerializable, or has a Surrogate.
        internal long               m_fixupCount;
        internal ISurrogateSelector m_selector;
        internal StreamingContext   m_context;
    
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.ObjectManager"]/*' />
        public ObjectManager(ISurrogateSelector selector, StreamingContext context) : this(selector, context, true) {
        }

        internal ObjectManager(ISurrogateSelector selector, StreamingContext context, bool checkSecurity) {
            if (checkSecurity) {
                CodeAccessPermission.DemandInternal(PermissionType.SecuritySerialization);          
            }
            m_fixupCount=0;
            m_objects = new ObjectHolder[DefaultInitialSize];
            m_specialFixupObjects = null;
            m_selector = selector;
            m_context = context;
        }

    
        private bool CanCallGetType(Object obj) {
            if (RemotingServices.IsTransparentProxy(obj)) {
                return false;
            }
            return true;
        }

        internal ObjectHolderList SpecialFixupObjects {
            get {
                if (m_specialFixupObjects==null) {
                    m_specialFixupObjects = new ObjectHolderList();
                }
                return m_specialFixupObjects;
            }
        }
    
        static ObjectManager() {
            SIConstructorTypes = new Type[2];
            SIConstructorTypes[0] = typeof(SerializationInfo);
            SIConstructorTypes[1] = typeof(StreamingContext);
        }

        /*==================================FindObject==================================
        **Action: An internal-only function to find the object with id <CODE>objectID</CODE>.
        **This function does no error checking, it assumes that all of that has been done already.
        **Returns: The ObjectHolder for <CODE>objectID</CODE> or null if it doesn't exist.
        **Arguments: objectID -- The objectID of the Object for which we're searching.
        **Exceptions: None.  This is internal only.  
        **Callers should verify that objectID is greater than 0.
        ==============================================================================*/
        internal ObjectHolder FindObjectHolder(long objectID) {
            BCLDebug.Assert(objectID>0,"objectID>0");
    
            //The  index of the bin in which we live is rightmost n bits of the objectID.
            int index = (int)(objectID & ArrayMask);
            if (index>=m_objects.Length) {
                return null;
            }
    
            //Find the bin in which we live.
            ObjectHolder temp = m_objects[index]; 
    
            //Walk the chain in that bin.  Return the ObjectHolder if we find it, otherwise
            //return null.
            while (temp!=null) { 
                if (temp.m_id==objectID) {
                    return temp;
                }
                temp = temp.m_next;
            }
            return temp;
        }


        internal ObjectHolder FindOrCreateObjectHolder(long objectID) {
            ObjectHolder holder;
            holder = FindObjectHolder(objectID);
            if (holder==null) {
                holder = new ObjectHolder(objectID);
                AddObjectHolder(holder);
            }
            return holder;
        }

    
        /*===============================AddObjectHolder================================
        **Action: Add the provided ObjectHolder to collection of ObjectHolders. 
        **        Enlarges the collection as appropriate.
        **Returns: void
        **Arguments: holder The ObjectHolder to be added.
        **Exceptions: Internal only.  Caller should verify that <CODE>holder</CODE> is 
        **            not null.
        ==============================================================================*/
        private void AddObjectHolder(ObjectHolder holder) {
    
            BCLDebug.Assert(holder!=null,"holder!=null");
            BCLDebug.Trace("SER", "[AddObjectHolder]Adding ObjectHolder with id: ", holder.m_id, " Current Bins: ", m_objects.Length);
            BCLDebug.Assert(holder.m_id>=0,"holder.m_id>=0");
    
            //If the id that we need to place is greater than our current length, and less
            //than the maximum allowable size of the array.  We need to double the size
            //of the array.  If the array has already reached it's maximum allowable size,
            //we chain elements off of the buckets.
            if (holder.m_id>=m_objects.Length && m_objects.Length != MaxArraySize) {
                int newSize=MaxArraySize;
    
                if (holder.m_id<(MaxArraySize/2)) {
                    newSize = (m_objects.Length * 2);
    
                    //Keep doubling until we're larger than our target size.
                    //We could also do this with log operations, but that would
                    //be slower than the brute force approach.
                    while (newSize<=holder.m_id && newSize<MaxArraySize) {
                        newSize*=2;
                    }
                    
                    if (newSize>MaxArraySize) {
                        newSize=MaxArraySize;
                    }
                }
    
                BCLDebug.Trace("SER", "[AddObjectHolder]Reallocating m_objects to have ", newSize, " bins");
                ObjectHolder[] temp = new ObjectHolder[newSize];
                Array.Copy(m_objects, temp, m_objects.Length);
                m_objects = temp;
            }
                
            //Find the bin in which we live and make this new element the first element in the bin.
            int index = (int)(holder.m_id & ArrayMask);
            BCLDebug.Trace("SER", "[AddObjectHolder]Trying to put an object in bin ", index);
    
            ObjectHolder tempHolder = m_objects[index]; 
            holder.m_next = tempHolder;
            m_objects[index] = holder;
        }
    
        private bool GetCompletionInfo(FixupHolder fixup, out ObjectHolder holder, out Object member, bool bThrowIfMissing) {
    
            //Set the member id (String or MemberInfo) for the member being fixed up.
            member = fixup.m_fixupInfo;
    
            //Find the object required for the fixup.  Throw if we can't find it.
            holder = FindObjectHolder(fixup.m_id);
            BCLDebug.Trace("SER", "[ObjectManager.GetCompletionInfo]Getting fixup info for: ", fixup.m_id);

            // CompletelyFixed is our poorly named property which indicates if something requires a SerializationInfo fixup
            // or is an incomplete object reference.  We have this particular branch to handle valuetypes which implement
            // ISerializable.  In that case, we can't do any fixups on them later, so we need to delay the fixups further.
            if (!holder.CompletelyFixed) {
                if (holder.ObjectValue!=null && holder.ObjectValue is ValueType) {
                    BCLDebug.Trace("SER", "[ObjectManager.GetCompletionInfo]ValueType implementing ISerializable.  Delaying fixup.");
                    SpecialFixupObjects.Add(holder);
                    return false;
                }
            }

            if (holder==null || holder.IsIncompleteObjectReference || holder.ObjectValue==null) {
                if (bThrowIfMissing) {
                    BCLDebug.Trace("SER", "[GetCompletionInfo]Unable to find fixup for: ", fixup.m_id);
                    BCLDebug.Trace("SER", "[GetCompletionInfo]Holder: ", ((holder==null)?"<null>":"Non Null"));
                    BCLDebug.Trace("SER", "[GetCompletionInfo]IsIncomplete: ", (holder.IsIncompleteObjectReference));
                    BCLDebug.Trace("SER", "[GetCompletionInfo]Object: ", ((holder.ObjectValue==null)?"<null>":"Non Null"));
                    if (holder==null) {
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NeverSeen"), fixup.m_id));
                    }
                    if (holder.IsIncompleteObjectReference) {
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_IORIncomplete"), fixup.m_id));
                    }
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectNotSupplied"), fixup.m_id));
                }
                return false;
            }
            return true;
        }
    
        private void FixupSpecialObject(ObjectHolder holder) {
            ISurrogateSelector uselessSelector=null;

            BCLDebug.Assert(holder.RequiresSerInfoFixup,"[ObjectManager.FixupSpecialObject]holder.HasSurrogate||holder.HasISerializable");
            if (holder.HasSurrogate) {
                ISerializationSurrogate surrogate = holder.Surrogate;
                BCLDebug.Assert(surrogate!=null,"surrogate!=null");
                object returnValue = surrogate.SetObjectData(holder.ObjectValue, holder.SerializationInfo, m_context, uselessSelector);
                if (returnValue != null)
                    holder.SetObjectValue(returnValue, this);
            } else {
                //Set the object data 
                BCLDebug.Assert(holder.ObjectValue is ISerializable,"holder.m_object is ISerializable");
                BCLDebug.Trace("SER","[ObjectManager.FixupSpecialObject]Fixing up ISerializable object ",holder.ObjectValue," with id ",holder.m_id);
                CompleteISerializableObject(holder.ObjectValue, holder.SerializationInfo, m_context);
            }
            //Clear anything that we know that we're not going to need.
            holder.SerializationInfo=null;
            holder.RequiresSerInfoFixup = false;

            // For value types, fixups would have been done. So the newly fixed object must be copied
            // to its container.
            if (holder.RequiresValueTypeFixup && holder.ValueTypeFixupPerformed){
                DoValueTypeFixup(null, holder, holder.ObjectValue);
            }
            DoNewlyRegisteredObjectFixups(holder);
        }
        

        /*============================ResolveObjectReference============================
        **Action:Unfortunately, an ObjectReference could actually be a reference to another
        **       object reference and we don't know how far we have to tunnel until we can find the real object.  While
        **       we're still getting instances of IObjectReference back and we're still getting new objects, keep calling
        **       GetRealObject.  Once we've got the new object, take care of all of the fixups
        **       that we can do now that we've got it.
        ==============================================================================*/
        private bool ResolveObjectReference(ObjectHolder holder) {
            Object tempObject;
            BCLDebug.Assert(holder.IsIncompleteObjectReference,"holder.IsIncompleteObjectReference");

            //In the pathological case, an Object implementing IObjectReference could return a reference
            //to a different object which implements IObjectReference.  This makes us vulnerable to a 
            //denial of service attack and stack overflow.  If the depthCount becomes greater than
            //MaxReferenceDepth, we'll throw a SerializationException.
            int depthCount = 0;
            
            //We wrap this in a try/catch block to handle the case where we're trying to resolve a chained
            //list of object reference (e.g. an IObjectReference can't resolve itself without some information
            //that's currently missing from the graph).  We'll catch the NullReferenceException and come back
            //and try again later.  The downside of this scheme is that if the object actually needed to throw
            //a NullReferenceException, it's being caught and turned into a SerializationException with a
            //fairly cryptic message.
            try {
                do {
                    tempObject = holder.ObjectValue;
                    BCLDebug.Trace("SER", "[ResolveObjectReference]ID: ", holder.m_id);
                    BCLDebug.Trace("SER", "[ResolveObjectReference]HasISerializable: ", holder.HasISerializable);
                    holder.SetObjectValue(((IObjectReference)(holder.ObjectValue)).GetRealObject(m_context), this);
                    //The object didn't yet have enough information to resolve the reference, so we'll
                    //return false and the graph walker should call us back again after more objects have
                    //been resolved.
                    //@Consider[JRoxe]: What do we do if the IObjectReference really does want to put a null in the graph?
                    //Possibility: An object with insufficient state could throw a SerializationException.
                    if (holder.ObjectValue==null) {
                        holder.SetObjectValue(tempObject, this);
                        BCLDebug.Trace("SER", "Object: ", holder.m_id, " did NOT have enough information to resolve the IObjectReference.");
                        return false;
                    }
                    if (depthCount++==MaxReferenceDepth) {
                        throw new SerializationException(Environment.GetResourceString("Serialization_TooManyReferences"));
                    }
                } while ((holder.ObjectValue is IObjectReference) && (tempObject!=holder.ObjectValue));
            } catch (NullReferenceException) {
                BCLDebug.Trace("SER", "[ResolveObjectReference]Caught exception trying to call GetRealObject.");
                return false;
            }
    
            BCLDebug.Trace("SER", "Object: ", holder.m_id, " resolved the IObjectReference.");
            holder.IsIncompleteObjectReference=false;
            DoNewlyRegisteredObjectFixups(holder);
            return true;
        }


        /*===============================DoValueTypeFixup===============================
        **Action:
        **Returns:
        **Arguments:
        ** memberToFix -- the member in the object contained in holder being fixed up.
        ** holder -- the ObjectHolder for the object (a value type in this case) being completed.
        ** value  -- the data to set into the field.
        **Exceptions:
        ==============================================================================*/
        private bool DoValueTypeFixup(FieldInfo memberToFix, ObjectHolder holder, Object value) {

            TypedReference typedRef;
            FieldInfo[] fieldsTemp=new FieldInfo[4]; 
            FieldInfo[] fields=null;
            int   currentFieldIndex=0;
            int[] arrayIndex = null;
            ValueTypeFixupInfo currFixup=null;
            Object fixupObj=holder.ObjectValue;
            ObjectHolder originalHolder = holder;

            BCLDebug.Assert(holder!=null, "[TypedReferenceBuilder.ctor]holder!=null");
            BCLDebug.Assert(holder.RequiresValueTypeFixup, "[TypedReferenceBuilder.ctor]holder.RequiresValueTypeFixup");
            
            //In order to get a TypedReference, we need to get a list of all of the FieldInfos to 
            //create the path from our outermost containing object down to the actual field which
            //we'd like to set.  This loop is used to build up that list.
            while (holder.RequiresValueTypeFixup) {
                BCLDebug.Trace("SER", "[DoValueTypeFixup] valueType fixsite = ", holder.ObjectValue, " fixobj=",value);

                //Enlarge the array if required (this is actually fairly unlikely as it would require that we
                //be nested more than 4 deep.
                if (currentFieldIndex>=fieldsTemp.Length) {
                    FieldInfo[] temp = new FieldInfo[fieldsTemp.Length * 2];
                    Array.Copy(fieldsTemp, temp, fieldsTemp.Length);
                    fieldsTemp = temp;
                }

                //Get the fixup information.  If we have data for our parent field, add it to our list
                //and continue the walk up to find the next outermost containing object.  We cache the 
                //object that we have.  In most cases, we could have just grabbed it after this loop finished.
                //However, if the outermost containing object is an array, we need the object one further
                //down the chain, so we have to do a lot of caching.
                currFixup = holder.ValueFixup;
                fixupObj = holder.ObjectValue;  //Save the most derived 
                if (currFixup.ParentField!=null) {
                    fieldsTemp[currentFieldIndex] = currFixup.ParentField;
                    ObjectHolder tempHolder = FindObjectHolder(currFixup.ContainerID);
                    if (tempHolder.ObjectValue == null) {
                        break;
                    }
                    holder = tempHolder;
                    currentFieldIndex++;
                } else {
                    //If we find an index into an array, save that information.
                    BCLDebug.Assert(currFixup.ParentIndex!=null, "[ObjectManager.DoValueTypeFixup]currFixup.ParentIndex!=null");
                    holder = FindObjectHolder(currFixup.ContainerID); //find the array to fix.
                    arrayIndex = currFixup.ParentIndex;
                    if (holder.ObjectValue==null) {
                        break;
                    }
                    break;
                }
            }

            //If the outermost container isn't an array, we need to grab it.  Otherwise, we just need to hang onto
            //the boxed object that we already grabbed.  We'll assign the boxed object back into the array as the
            //last step.
            if (!(holder.ObjectValue is Array) && holder.ObjectValue!=null) {
                fixupObj = holder.ObjectValue;
                BCLDebug.Assert(fixupObj!=null, "[ObjectManager.DoValueTypeFixup]FixupObj!=null");
            }
            
//              //We thought that the valuetype had already been placed into it's parent, but when we started
//              //walking the track, we discovered a null, so that's clearly impossible.  At this point, revert
//              //to just poking it into the most boxed version that we can.
//              if (fixupObj==null) {
//                  fixupObj = originalHolder.ObjectValue;
//                  FormatterServices.SerializationSetValue(memberToFix, fixupObj, value);
//                  return true;
//              }

            if (currentFieldIndex!=0) {

                //MakeTypedReference requires an array of exactly the correct size that goes from the outermost object
                //in to the innermost field.  We currently have an array of arbitrary size that goes from the innermost
                //object outwards.  We create an array of the right size and do the copy.
                fields = new FieldInfo[currentFieldIndex];
                for (int i=0; i<currentFieldIndex; i++) {
                    fields[i] = fieldsTemp[(currentFieldIndex - 1 - i)];
                }
                
                BCLDebug.Assert(fixupObj!=null, "[ObjectManager.DoValueTypeFixup]fixupObj!=null");
                DumpValueTypeFixup(fixupObj, fields, memberToFix, value);
                //Make the TypedReference and use it to set the value.
                typedRef = TypedReference.MakeTypedReference(fixupObj, fields);
                if (memberToFix != null)
                    ((RuntimeFieldInfo)memberToFix).SetValueDirectImpl(typedRef, value, false);
                else
                    TypedReference.SetTypedReference(typedRef, value);
            } else if (memberToFix != null){
                DumpValueTypeFixup(fixupObj, null, memberToFix, value);
                FormatterServices.SerializationSetValue(memberToFix, fixupObj, value);
            }
            
            //If we have an array index, it means that our outermost container was an array.  We don't have
            //any way to build a TypedReference into an array, so we'll use the array functions to set the value.
            //@Consider: We potentially end up doing multiple sets if we have to do multiple fixups in the value type.
            //What's the best way to avoid this?
            if (arrayIndex!=null && holder.ObjectValue!=null) {
                ((Array)(holder.ObjectValue)).SetValue(fixupObj, arrayIndex);
            }
            
            return true;
        }



        
        [Conditional("SER_LOGGING")]
        void DumpValueTypeFixup(object obj, FieldInfo[] intermediateFields, FieldInfo memberToFix, object value){
            System.Text.StringBuilder sb = new System.Text.StringBuilder("  " + obj);
            if (intermediateFields != null)
            for(int i=0;i<intermediateFields.Length;i++){
                sb.Append("."+intermediateFields[i].Name);
            }
            sb.Append("."+memberToFix.Name+"="+value);
			BCLDebug.Trace("SER", sb.ToString());
        }


        /*================================CompleteObject================================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        internal void CompleteObject(ObjectHolder holder, bool bObjectFullyComplete) {
            FixupHolderList fixups=holder.m_missingElements;
            FixupHolder currentFixup;
            SerializationInfo si;
            Object fixupInfo=null;
            ObjectHolder tempObjectHolder=null;
            int fixupsPerformed=0;
            
            BCLDebug.Assert(holder!=null,"[ObjectManager.CompleteObject]holder.m_object!=null");
            if (holder.ObjectValue==null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_MissingObject", holder.m_id));
            }
    
            if (fixups==null) {
                return;
            }
            //If either one of these conditions is true, we need to update the data in the
            //SerializationInfo before calling SetObjectData.
            if (holder.HasSurrogate || holder.HasISerializable) {
                si = holder.m_serInfo;

                if (si==null) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_InvalidFixupDiscovered"));
                }

                BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Complete object ", holder.m_id, " of SI Type: ", si.FullTypeName);
                //Walk each of the fixups and complete the name-value pair in the SerializationInfo.
                if (fixups!=null) {
                    for (int i=0; i<fixups.m_count; i++) {
                        if (fixups.m_values[i]==null) {
                            continue;
                        }
                        BCLDebug.Assert(fixups.m_values[i].m_fixupType==FixupHolder.DelayedFixup,"fixups.m_values[i].m_fixupType==FixupHolder.DelayedFixup");
                        if (GetCompletionInfo(fixups.m_values[i], out tempObjectHolder, out fixupInfo, bObjectFullyComplete)) {
                            //Walk the SerializationInfo and find the member needing completion.  All we have to do
                            //at this point is set the member into the Object
                            BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Updating object ", holder.m_id, " with object ", tempObjectHolder.m_id);
                            Object holderValue = tempObjectHolder.ObjectValue;
                            if (CanCallGetType(holderValue)) {
                                si.UpdateValue((String)fixupInfo, holderValue, holderValue.GetType());
                            } else {
                                si.UpdateValue((String)fixupInfo, holderValue, typeof(MarshalByRefObject));
                            }
                            //Decrement our total number of fixups left to do.
                            fixupsPerformed++;
                            fixups.m_values[i]=null;
                            if (!bObjectFullyComplete) {
                                holder.DecrementFixupsRemaining(this);
                                tempObjectHolder.RemoveDependency(holder.m_id);
                            }
                        }
                    }
                }
              
            } else {
                BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Non-ISerializableObject: ", holder.m_id);
                for (int i=0; i<fixups.m_count; i++) {
                    currentFixup = fixups.m_values[i];
                    if (currentFixup==null) {
                        continue;
                    }
                    BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Getting fixup info for object: ", currentFixup.m_id);
                    if (GetCompletionInfo(currentFixup, out tempObjectHolder, out fixupInfo, bObjectFullyComplete)) {
                        BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Fixing up: ", currentFixup.m_id);
                        //There are two types of fixups that we could be doing: array or member.  
                        //Delayed Fixups should be handled by the above branch.
                        switch(currentFixup.m_fixupType) {
                        case FixupHolder.ArrayFixup:
                            BCLDebug.Assert(holder.ObjectValue is Array,"holder.ObjectValue is Array");
                            if (holder.RequiresValueTypeFixup) {
                                throw new SerializationException(Environment.GetResourceString("Serialization_ValueTypeFixup"));
                            } else {
                                ((Array)(holder.ObjectValue)).SetValue(tempObjectHolder.ObjectValue, ((int[])fixupInfo));
                            }
                            break;
                        case FixupHolder.MemberFixup:
                            BCLDebug.Assert(fixupInfo is MemberInfo,"fixupInfo is MemberInfo");
                            //Fixup the member directly.
                            MemberInfo tempMember = (MemberInfo)fixupInfo;
                            if (tempMember.MemberType==MemberTypes.Field) {
                                BCLDebug.Trace("SER", "[ObjectManager.CompleteObject]Fixing member: ", tempMember.Name, " in object ", holder.m_id,
                                               " with object ", tempObjectHolder.m_id);

                                // If we have a valuetype that's been boxed to an object and requires a fixup,
                                // there are two possible states:
                                // (a)The valuetype has never been fixed up into it's container.  In this case, we should
                                // just fix up the boxed valuetype.  The task of pushing that valuetype into it's container
                                // will be handled later.  This case is handled by the else clause of the following statement.
                                // (b)The valuetype has already been inserted into it's container.  In that case, we need
                                // to go through the more complicated path laid out in DoValueTypeFixup. We can tell that the
                                // valuetype has already been inserted into it's container because we set ValueTypeFixupPerformed
                                // to true when we do this.
                                if (holder.RequiresValueTypeFixup && holder.ValueTypeFixupPerformed) {
                                    if (!DoValueTypeFixup((FieldInfo)tempMember, holder, tempObjectHolder.ObjectValue)) {
                                        throw new SerializationException(Environment.GetResourceString("Serialization_PartialValueTypeFixup"));
                                    }
                                } else {
                                    FormatterServices.SerializationSetValue(tempMember, holder.ObjectValue, tempObjectHolder.ObjectValue);
                                }
                                if (tempObjectHolder.RequiresValueTypeFixup) {
                                    tempObjectHolder.ValueTypeFixupPerformed = true;
                                }
                            } else {
                                throw new SerializationException(Environment.GetResourceString("Serialization_UnableToFixup"));
                            }
                            break;
                        default:
                            throw new SerializationException(Environment.GetResourceString("Serialization_UnableToFixup"));
                        }
                        //Decrement our total number of fixups left to do.
                        fixupsPerformed++;
                        fixups.m_values[i]=null;
                        if (!bObjectFullyComplete) {
                            holder.DecrementFixupsRemaining(this);
                            tempObjectHolder.RemoveDependency(holder.m_id);
                        }
                    }
                }
            }

            m_fixupCount-=fixupsPerformed;

            if (fixups.m_count==fixupsPerformed) {
                holder.m_missingElements=null;
            }
        }

        
        /*========================DoNewlyRegisteredObjectFixups=========================
        **Action:  This is called immediately after we register a new object.  Walk that objects
        **         dependency list (if it has one) and decrement the counters on each object for
        **         the number of unsatisfiable references.  If the count reaches 0, go ahead
        **         and process the object.
        **Returns: void
        **Arguments: dependencies The list of dependent objects
        **Exceptions: None.
        ==============================================================================*/
        private void DoNewlyRegisteredObjectFixups(ObjectHolder holder) {
            ObjectHolder temp;
            
            if (holder.IsIncompleteObjectReference) {
                BCLDebug.Trace("SER","[ObjectManager.DoNewlyRegisteredObjectFixups]Object is an Incomplete Object Reference.  Exiting.");
                return;
            }

            LongList dependencies = holder.DependentObjects;

            //If we don't have any dependencies, we're done.
            if (dependencies==null) {
                BCLDebug.Trace("SER", "[DoNewlyRegisteredObjectFixups]Exiting with no dependencies");
                return;
            }
            
            //Walk all of the dependencies and decrement the counter on each of uncompleted objects.
            //If one of the counters reaches 0, all of it's fields have been completed and we should
            //go take care of its fixups.
            BCLDebug.Trace("SER", "[ObjectManager.DoNewlyRegisteredObjectFixups]Object has ", dependencies.Count, " fixups registered");
            dependencies.StartEnumeration();
            while (dependencies.MoveNext()) {
                temp = FindObjectHolder(dependencies.Current);
                BCLDebug.Trace("SER", "[ObjectManager.DoNewlyRegisteredObjectFixups]Doing a fixup on object: ", temp.m_id);
                BCLDebug.Assert(temp.DirectlyDependentObjects>0,"temp.m_missingElementsRemaining>0");
                temp.DecrementFixupsRemaining(this);
                if (((temp.DirectlyDependentObjects))==0) {
                    BCLDebug.Trace("SER", "[DoNewlyRegisteredObjectFixups]Doing fixup for object ", temp.m_id);
                    BCLDebug.Trace("SER", "[DoNewlyRegisteredObjectFixups]ObjectValue ", ((temp.ObjectValue==null)?"<null>":temp.ObjectValue));
                    // If this is null, we have the case where a fixup was registered for a child, the object 
                    // required by the fixup was provided, and the object to be fixed hasn't yet been seen.  
                    if (temp.ObjectValue!=null) {
                        CompleteObject(temp, true);
                    } else {
                        temp.MarkForCompletionWhenAvailable();
                    }
                }
            }
            BCLDebug.Trace("SER", "[ObjectManager.DoNewlyRegisteredObjectFixups]Exiting.");
        }
        
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.GetObject"]/*' />
        public virtual Object GetObject(long objectID) {
            if (objectID<=0) {
                throw new ArgumentOutOfRangeException("objectID", Environment.GetResourceString("ArgumentOutOfRange_ObjectID"));
            }
    
            //Find the bin in which we're interested.  IObjectReference's shouldn't be returned -- the graph
            //needs to link to the objects to which they refer, not to the references themselves.
            ObjectHolder holder = FindObjectHolder(objectID);
    
            BCLDebug.Trace("SER", "GetObject. objectID: ", objectID);

            if (holder==null || (holder.IsIncompleteObjectReference)) { 
                BCLDebug.Trace("SER", "GetObject. holder: null or IncompleteObjectReference");
                return null;
            }
            
            BCLDebug.Trace("SER", "GetObject. holder contains: ", ((holder.ObjectValue==null)?"<null>":holder.ObjectValue));
            return holder.ObjectValue;
        }

        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RegisterObject"]/*' />
        public virtual void RegisterObject(Object obj, long objectID) {
            RegisterObject(obj, objectID, null,0,null);
        }
    

        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RegisterObject1"]/*' />
        public void RegisterObject(Object obj, long objectID, SerializationInfo info) {
            RegisterObject(obj, objectID, info, 0, null);
        }


        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RegisterObject2"]/*' />
        public void RegisterObject(Object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member) {
            RegisterObject(obj, objectID, info, idOfContainingObj, member, null);
        }


        internal void RegisterString(String obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member) 
        {
            ObjectHolder temp;
            BCLDebug.Assert(member == null || member is FieldInfo, "RegisterString - member is FieldInfo");
            BCLDebug.Assert((FindObjectHolder(objectID) == null), "RegisterString - FindObjectHolder(objectID) == null");

            temp = new ObjectHolder(obj, objectID, info, null, idOfContainingObj, (FieldInfo)member, null);
            AddObjectHolder(temp);
            return;
        }

        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RegisterObject3"]/*' />
        public void RegisterObject(Object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, int[] arrayIndex) {
            ObjectHolder temp;
            ISerializationSurrogate surrogate = null;
            ISurrogateSelector useless;
    
            if (obj==null) {
                throw new ArgumentNullException("obj");
            }
            if (objectID<=0) {
                throw new ArgumentOutOfRangeException("objectID", Environment.GetResourceString("ArgumentOutOfRange_ObjectID"));
            }

            if (member!=null && !(member is RuntimeFieldInfo) && !(member is SerializationFieldInfo)) {
                throw new SerializationException(Environment.GetResourceString("Serialization_UnknownMemberInfo"));
            }
    
            if (m_selector != null)
            {
                Type selectorType=null;
                if (CanCallGetType(obj)) {
                    selectorType = obj.GetType();
                } else {
                    selectorType = typeof(MarshalByRefObject);
                }

                BCLDebug.Trace("SER", "[ObjectManager.RegisterObject]ID: ", objectID, "\tType: ", selectorType, "\tValue: ", obj);
    
                //If we need a surrogate for this object, lets find it now.
                surrogate = m_selector.GetSurrogate(selectorType, m_context, out useless);
            }

            //The object is interested in DeserializationEvents so lets register it.
            if (obj is IDeserializationCallback) {
                DeserializationEventHandler d = new DeserializationEventHandler(((IDeserializationCallback)obj).OnDeserialization);
                AddOnDeserialization(d);
            }
    
            //Formatter developers may cache and reuse arrayIndex in their code.
            //So that we don't get bitten by this, take a copy up front.
            if (arrayIndex!=null) {
              arrayIndex = (int[])arrayIndex.Clone();
            }
            
            temp = FindObjectHolder(objectID);
            //This is the first time which we've seen the object, we need to create a new holder.
            if (temp==null) { 
                BCLDebug.Trace("SER", "[ObjectManager.RegisterObject]Adding a new object holder for ", objectID, "\tValueType: ", obj.GetType());
                
                temp = new ObjectHolder(obj, objectID, info, surrogate, idOfContainingObj, (FieldInfo)member, arrayIndex);
                AddObjectHolder(temp);
                if (temp.RequiresDelayedFixup) {
                    SpecialFixupObjects.Add(temp);   
                }
                return;
            } 
            
            //If the object isn't null, we've registered this before.  Not good.
            if (temp.ObjectValue!=null) {
                throw new SerializationException(Environment.GetResourceString("Serialization_RegisterTwice"));
            }
            
            //Complete the data in the ObjectHolder
            temp.UpdateData(obj, info, surrogate, idOfContainingObj, (FieldInfo)member, arrayIndex, this);

            // The following case will only be true when somebody has registered a fixup on an object before
            // registering the object itself.  I don't believe that most well-behaved formatters will do this,
            // but we need to allow it anyway.  We will walk the list of fixups which have been recorded on 
            // the new object and fix those that we can.  Because the user could still register later fixups
            // on this object, we won't call any implementations of ISerializable now.  If that's required,
            // it will have to be handled by the code in DoFixups.
            // README README: We have to do the UpdateData before 
            if (temp.DirectlyDependentObjects>0) {
                CompleteObject(temp, false);
            }

            if (temp.RequiresDelayedFixup) {
                BCLDebug.Trace("SER", "[ObjectManager.RegisterObject]Tracking incomplete objref for element: ", temp.m_id);
                SpecialFixupObjects.Add(temp);   
            } 

            if (temp.CompletelyFixed) {
                //Here's where things get tricky.  If this isn't an instance of IObjectReference, we need to walk it's fixup 
                //chain and decrement the counters on anything that has reached 0.  Once we've notified all of the dependencies,
                //we can simply clear the list of dependent objects.
                BCLDebug.Trace("SER", "[ObjectManager.RegisterObject]Calling DoNewlyRegisteredObjectFixups for element: ", temp.m_id);
                DoNewlyRegisteredObjectFixups(temp);
                temp.DependentObjects=null;
            }
            BCLDebug.Trace("SER", "[ObjectManager.RegisterObject]Exiting.");
        }

        /*=========================CompleteISerializableObject==========================
        **Action: Completes an object implementing ISerializable.  This will involve calling that
        **        objects constructor which takes an instance of ISerializable and a StreamingContext.
        **Returns: void.
        **Arguments: Obj     --  The object to be completed.
        **           info    --  The SerializationInfo containing all info for obj.
        **           context --  The streaming context in which the serialization is taking place.
        **Exceptions: ArgumentNullException if obj is null
        **            ArgumentException if obj does not implement ISerializable.
        ==============================================================================*/
        internal void CompleteISerializableObject(Object obj, SerializationInfo info, StreamingContext context) {
            RuntimeConstructorInfo constInfo = null;


            if (obj==null) {
                throw new ArgumentNullException("obj");
            }
            
            if (!(obj is ISerializable)) {
                throw new ArgumentException(Environment.GetResourceString("Serialization_NotISer"));
            }

            Type t = obj.GetType();
            try {
                constInfo = GetConstructor(t);
            } catch (Exception e) {
                BCLDebug.Trace("SER", "[CompleteISerializableObject]Unable to get constructor for: ", t);
                BCLDebug.Trace("SER", "[CompleteISerializableObject]Stack trace was: ", e);
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ConstructorNotFound"), t));
            }

            constInfo.SerializationInvoke(obj, info, context);
        }

        
        /*================================GetConstructor================================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        internal static RuntimeConstructorInfo GetConstructor(Type t) {
            BCLDebug.Assert(t!=null, "[GetConstructor]t!=null");
            BCLDebug.Assert(t is RuntimeType, "[GetConstructor]t is RuntimeType");
            RuntimeConstructorInfo ci;

            if ((ci=(RuntimeConstructorInfo)t.Cache[CacheObjType.ConstructorInfo])==null) {
                RuntimeType rt = (RuntimeType)t;
                ci = (RuntimeConstructorInfo)rt.GetConstructorImplInternal(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Any, SIConstructorTypes, null, false);
                if (ci==null) {
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ConstructorNotFound"), t.FullName));
                }
                t.Cache[CacheObjType.ConstructorInfo] = ci;
            }

            return ci;
        }

        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.DoFixups"]/*' />
        public virtual void DoFixups() {
            ObjectHolder temp;
            int fixupCount=-1;
            
            BCLDebug.Trace("SER", "[ObjectManager.DoFixups]Entering");

            //The first thing that we need to do is fixup all of the objects which implement
            //IObjectReference.  This is complicated by the fact that we need to deal with IReferenceObjects 
            //objects that have a reference to an object implementing IObjectReference.  We continually
            //walk over the list of objects until we've completed all of the object references or until
            //we can't resolve any more (which may happen if we have two objects implementing IObjectReference
            //which have a circular dependency on each other).  We don't explicitly catch the later case here,
            //it will be caught when we try to do the rest of the fixups and discover that we have some that
            //can't be completed.
            while (fixupCount!=0) {
                fixupCount=0;
                //Walk all of the IObjectReferences and ensure that they've been properly completed.
                ObjectHolderListEnumerator fixupObjectsEnum = SpecialFixupObjects.GetFixupEnumerator();
                while (fixupObjectsEnum.MoveNext()) {
                    temp = fixupObjectsEnum.Current;
                    if (temp.ObjectValue == null) {
                        BCLDebug.Trace("SER", "[ObjectManager.DoFixups]Object with id: ", temp.m_id, " not found.");
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectNotSupplied"), temp.m_id));
                    }
                    BCLDebug.Trace("SER", "[ObjectManager.DoFixups]Looking at object with id: ", temp.m_id, " which has ", 
                                   temp.TotalDependentObjects, " Total Dependent Fixups, but only ", 
                                   (temp.DependentObjects==null)?0:temp.DependentObjects.Count, 
                                   " directly dependent objects. Has it been fixed? ", temp.CompletelyFixed);
                    if (temp.TotalDependentObjects==0) {
                        if (temp.RequiresSerInfoFixup) {
                            FixupSpecialObject(temp);
                            fixupCount++;
                        } else if (!temp.IsIncompleteObjectReference) {
                            CompleteObject(temp, true);
                        }
                        
                        if (temp.IsIncompleteObjectReference && ResolveObjectReference(temp)) {
                            fixupCount++;
                        } 
                    }
                }
            }
            
            BCLDebug.Assert(m_fixupCount>=0,"[ObjectManager.DoFixups]m_fixupCount>=0");
    
            //If our count is 0, we're done and should just return
            if (m_fixupCount==0) {
                BCLDebug.Trace("SER", "[ObjectManager.DoFixups]All fixups completed.  We don't need to walk the list.");
                return;
            }
    
            //If our count isn't 0, we had at least one case where an object referenced another object twice.
            //Walk the entire list until the count is 0 or until we find an object which we can't complete.
            BCLDebug.Trace("SER", "[ObjectManager.DoFixups]Remaining object length is: ", m_objects.Length);
            for (int i=0; i<m_objects.Length; i++) {
                temp = m_objects[i];
                while (temp!=null) {
                    if (temp.TotalDependentObjects>0 /*|| temp.m_missingElements!=null*/) {
                        BCLDebug.Trace("SER", "[ObjectManager.DoFixups]Doing a delayed fixup on object ", temp.m_id);
                        CompleteObject(temp, true);
                    }
                    temp = temp.m_next;
                }
                if (m_fixupCount==0) {
                    return;
                }
            }

            BCLDebug.Assert(false, "[ObjectManager.DoFixups]We should never get here.  Fixup counting is incorrect.");
            throw new SerializationException(Environment.GetResourceString("Serialization_IncorrectNumberOfFixups"));
        }

        /*================================RegisterFixup=================================
        **Action: Do the actual grunt work of recording a fixup and registering the dependency.
        **        Create the necessary ObjectHolders and use them to do the addition.
        **Returns: void
        **Arguments: fixup -- The FixupHolder to be added.
        **           objectToBeFixed -- The id of the object requiring the fixup.
        **           objectRequired -- The id of the object required to do the fixup.
        **Exceptions: None.  This is internal-only, so all checking should have been done by this time.
        ==============================================================================*/
        private void RegisterFixup(FixupHolder fixup, long objectToBeFixed, long objectRequired) {
            //Record the fixup with the object that needs it.
            ObjectHolder ohToBeFixed = FindOrCreateObjectHolder(objectToBeFixed);
            ObjectHolder ohRequired;
            
            if (ohToBeFixed.RequiresSerInfoFixup && fixup.m_fixupType == FixupHolder.MemberFixup) {
                throw new SerializationException(Environment.GetResourceString("Serialization_InvalidFixupType"));
            }

            //Add the fixup to the list.
            ohToBeFixed.AddFixup(fixup, this);
    
            //Find the object on which we're dependent and note the dependency.
            //These dependencies will be processed when the object is supplied.
            ohRequired = FindOrCreateObjectHolder(objectRequired);
            
            ohRequired.AddDependency(objectToBeFixed);

            m_fixupCount++;
        }
    
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RecordFixup"]/*' />
        public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired) {
    
            //Verify our arguments
            if (objectToBeFixed<=0 || objectRequired<=0) {
                throw new ArgumentOutOfRangeException(((objectToBeFixed<=0)?"objectToBeFixed":"objectRequired"),
                                                      Environment.GetResourceString("Serialization_IdTooSmall"));
            }

            if (member==null) {
                throw new ArgumentNullException("member");
            }

            if (!(member is RuntimeFieldInfo) && !(member is SerializationFieldInfo)) {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_InvalidType"), member.GetType().ToString()));
            }

    
            BCLDebug.Trace("SER", "RecordFixup.  ObjectToBeFixed: ", objectToBeFixed, "\tMember: ", member.Name, "\tRequiredObject: ", objectRequired);
    
            //Create a new fixup holder
            FixupHolder fixup = new FixupHolder(objectRequired, member, FixupHolder.MemberFixup);
    
            RegisterFixup(fixup, objectToBeFixed, objectRequired);
        }
    
    
        /*==============================RecordDelayedFixup==============================
        **Action:
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RecordDelayedFixup"]/*' />
        public virtual void RecordDelayedFixup(long objectToBeFixed, String memberName, long objectRequired) {
            //Verify our arguments
            if (objectToBeFixed<=0 || objectRequired<=0) {
                throw new ArgumentOutOfRangeException(((objectToBeFixed<=0)?"objectToBeFixed":"objectRequired"),
                                                      Environment.GetResourceString("Serialization_IdTooSmall"));
            }
    
            if (memberName==null) {
                throw new ArgumentNullException("memberName");
            }
    
            BCLDebug.Trace("SER", "RecordDelayedFixup.  ObjectToBeFixed: ", objectToBeFixed, "\tMember: ", memberName, "\tRequiredObject: ", objectRequired);
    
            //Create a new fixup holder
            FixupHolder fixup = new FixupHolder(objectRequired, memberName, FixupHolder.DelayedFixup);
    
            RegisterFixup(fixup, objectToBeFixed, objectRequired);
        }
    
        /*===========================RecordArrayElementFixup============================
        **Action: 
        **Returns:
        **Arguments:
        **Exceptions:
        ==============================================================================*/
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RecordArrayElementFixup"]/*' />
        public virtual void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired) {
            int[] indexArray = new int[1];
            indexArray[0]=index;
    
            BCLDebug.Trace("SER", "RecordArrayElementFixup.  ObjectToBeFixed: ", arrayToBeFixed, "\tIndex: ", index, "\tRequiredObject: ", objectRequired);
    
            RecordArrayElementFixup(arrayToBeFixed, indexArray, objectRequired);
        }
    
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RecordArrayElementFixup1"]/*' />
        public virtual void RecordArrayElementFixup(long arrayToBeFixed, int[] indices, long objectRequired) {
            //Verify our arguments
            if (arrayToBeFixed<=0 || objectRequired<=0) {
                throw new ArgumentOutOfRangeException(((arrayToBeFixed<=0)?"objectToBeFixed":"objectRequired"),
                                                      Environment.GetResourceString("Serialization_IdTooSmall"));
            }
    
            if (indices==null) {
                throw new ArgumentNullException("indices");
            }
    
            BCLDebug.Trace("SER", "RecordArrayElementFixup.  ArrayToBeFixed: ", arrayToBeFixed, "\tRequiredObject: ", objectRequired);
            FixupHolder fixup = new FixupHolder(objectRequired, indices, FixupHolder.ArrayFixup);
            RegisterFixup(fixup, arrayToBeFixed, objectRequired);
        }
    
    
        /*==========================RaiseDeserializationEvent===========================
        **Action:Raises the deserialization event to any registered object which implements 
        **       IDeserializationCallback.  
        **Returns: void
        **Arguments: none
        **Exceptions: None
        ==============================================================================*/
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RaiseDeserializationEvent"]/*' />
        public virtual void RaiseDeserializationEvent() {
            if (m_onDeserializationHandler!=null) {
                m_onDeserializationHandler(null);
            }
        }
    
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.AddOnDeserialization"]/*' />
        internal virtual void AddOnDeserialization(DeserializationEventHandler handler) {
            m_onDeserializationHandler = (DeserializationEventHandler)Delegate.Combine(m_onDeserializationHandler, handler);
        }
    
        /// <include file='doc\ObjectManager.uex' path='docs/doc[@for="ObjectManager.RemoveOnDeserialization"]/*' />
        internal virtual void RemoveOnDeserialization(DeserializationEventHandler handler) {
            m_onDeserializationHandler = (DeserializationEventHandler)Delegate.Remove(m_onDeserializationHandler, handler);
        }
    }
    
	[Serializable()]
    internal class ObjectHolder {
        internal const int INCOMPLETE_OBJECT_REFERENCE = 0x0001;
        internal const int HAS_ISERIALIZABLE           = 0x0002;
        internal const int HAS_SURROGATE               = 0x0004;
        internal const int REQUIRES_VALUETYPE_FIXUP    = 0x0008;
        internal const int REQUIRES_DELAYED_FIXUP      = HAS_ISERIALIZABLE | HAS_SURROGATE | INCOMPLETE_OBJECT_REFERENCE;
        internal const int SER_INFO_FIXED              = 0x4000;
        internal const int VALUETYPE_FIXUP_PERFORMED   = 0x8000;
    
        private  Object m_object;
        internal long   m_id;
        private  int    m_missingElementsRemaining;
        private  int    m_missingDecendents;
        internal SerializationInfo m_serInfo;
        internal ISerializationSurrogate m_surrogate;
        internal FixupHolderList m_missingElements;
        internal LongList m_dependentObjects;
        internal ObjectHolder m_next;
        internal int  m_flags;
        private  bool m_markForFixupWhenAvailable;
        private  ValueTypeFixupInfo m_valueFixup;
    
        internal ObjectHolder(long objID) 
            : this(null, objID, null, null, 0, null, null) {
        }
    
        internal ObjectHolder(Object obj, long objID, SerializationInfo info, 
                              ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, int[] arrayIndex) {
            BCLDebug.Assert(objID>=0,"objID>=0");
            
            m_object=obj; //May be null;
            m_id=objID;
    
            m_flags=0;
            m_missingElementsRemaining=0;
            m_missingDecendents = 0;
            m_dependentObjects=null;
            m_next=null;
            
            m_serInfo = info;
            m_surrogate = surrogate;
            m_markForFixupWhenAvailable = false;


            if (idOfContainingObj!=0 && ((field!=null && field.FieldType.IsValueType) || arrayIndex!=null)) {
                if (idOfContainingObj == objID) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_ParentChildIdentical"));
                }

                m_valueFixup = new ValueTypeFixupInfo(idOfContainingObj, field, arrayIndex);
            }

            SetFlags();
        }
    
        internal ObjectHolder(String obj, long objID, SerializationInfo info, 
                              ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, int[] arrayIndex) {
            BCLDebug.Assert(objID>=0,"objID>=0");
            
            m_object=obj; //May be null;
            m_id=objID;
    
            m_flags=0;
            m_missingElementsRemaining=0;
            m_missingDecendents = 0;
            m_dependentObjects=null;
            m_next=null;
            
            m_serInfo = info;
            m_surrogate = surrogate;
            m_markForFixupWhenAvailable = false;

            if (idOfContainingObj!=0 && arrayIndex!=null) {
                m_valueFixup = new ValueTypeFixupInfo(idOfContainingObj, field, arrayIndex);
            }

            if (m_valueFixup!=null) {
                m_flags|=REQUIRES_VALUETYPE_FIXUP;
            }
        }

        private void IncrementDescendentFixups(int amount) {
            m_missingDecendents+=amount;
        }
        
        internal void DecrementFixupsRemaining(ObjectManager manager) {
            m_missingElementsRemaining--;
            
            if (RequiresValueTypeFixup) {
                UpdateDescendentDependencyChain(-1, manager);
            }
        }

        /*===============================RemoveDependency===============================
        **Action: Removes a dependency of the object represented in this holder.
        **        This is normally the result of the dependency having been filled when
        **        the object is going to be only partially completed.  If we plan to fully
        **        update the object, we do not take the work to do this.
        **Returns: void.
        **Arguments: id -- The id of the object for which to remove the dependency.
        **Exceptions: None, error handling through asserts.
        ==============================================================================*/
        internal void RemoveDependency(long id) {
            BCLDebug.Assert(m_dependentObjects!=null, "[ObjectHolder.RemoveDependency]m_dependentObjects!=null");
            BCLDebug.Assert(id>=0, "[ObjectHolder.RemoveDependency]id>=0");
            m_dependentObjects.RemoveElement(id);
        }

        /*===================================AddFixup===================================
        **Action: Note a fixup that has to be done before this object can be completed.
        **        Fixups are things that need to happen when other objects in the graph 
        **        are added.  Dependencies are things that need to happen when this object
        **        is added.
        **Returns: void
        **Arguments: fixup -- The fixup holder containing enough information to complete the fixup.
        **Exceptions: None.
        ==============================================================================*/
        internal virtual void AddFixup(FixupHolder fixup, ObjectManager manager) {
            if (m_missingElements==null) {
                m_missingElements = new FixupHolderList();
            }
            m_missingElements.Add(fixup);
            m_missingElementsRemaining++;
            
            if (RequiresValueTypeFixup) {
                UpdateDescendentDependencyChain(1, manager);
            }
        }
            
        /*==========================UpdateTotalDependencyChain==========================
        **Action: Updates the total list of dependencies to account for a fixup being added
        **        or completed in a child value class.  This will update all value classes
        **        containing that child and the object which contains all of them.  
        **Returns: void
        **Arguments: amount -- the amount by which to increment (or decrement) the dependency chain.
        **           manager -- The ObjectManager used to lookup other objects up the chain.
        **Exceptions: None.  Asserts only.
        ==============================================================================*/
        private void UpdateDescendentDependencyChain(int amount, ObjectManager manager) {
            ObjectHolder holder = this;
            
            //This loop walks one more object up the chain than there are valuetypes.  This
            //is because we need to increment the TotalFixups in the holders as well.
            do {
                holder = manager.FindOrCreateObjectHolder(holder.ContainerID);
                BCLDebug.Trace("SER", "[ObjectManager.UpdateDescendentDependencyChain]Looking for holder with id: ", holder.ContainerID);
                BCLDebug.Assert(holder!=null, "[ObjectHolder.UpdateTotalDependencyChain]holder!=null");
                holder.IncrementDescendentFixups(amount);
            } while (holder.RequiresValueTypeFixup);
        }
    
        /*================================AddDependency=================================
        **Action: Note an object which is dependent on the one which will be contained in
        **        this ObjectHolder.  Dependencies should only be added if the object hasn't
        **        yet been added.  NB: An incomplete object counts as having no object.
        **Returns: void
        **Arguments: dependentObject -- the id of the object which is dependent on this object being provided.
        **Exceptions: None.
        ==============================================================================*/
        internal virtual void AddDependency(long dependentObject) {
            if (m_dependentObjects==null) {
                m_dependentObjects = new LongList();
            }
            m_dependentObjects.Add(dependentObject);
        }
    
       
        /*==================================UpdateData==================================
        **Action: Update the data in the object holder.  This should be called when the object
        **        is finally registered.  Presumably the ObjectHolder was created to track 
        **        some dependencies or preregistered fixups and we now need to actually record the
        **        object and other associated data.  We take this opportunity to set the flags
        **        so that we can do some faster processing in the future.
        **Returns: void
        **Arguments: obj -- The object being held by this object holder. (This should no longer be null).
        **           info --The SerializationInfo associated with this object, only required if we're doing delayed fixups.
        **           surrogate -- The surrogate handling this object.  May be null.
        **           idOfContainer -- The id of the object containing this one if this is a valuetype.
        **           member -- the MemberInfo of this object's position in it's container if this is a valuetype.
        **           manager -- the ObjectManager being used to track these ObjectHolders.
        **Exceptions: None. Asserts only.
        ==============================================================================*/
        internal virtual void UpdateData(Object obj, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainer, FieldInfo field, int[] arrayIndex, ObjectManager manager) {
            BCLDebug.Assert(obj!=null,"obj!=null");
            BCLDebug.Assert(m_id>0,"m_id>0");
    
            //Record the fields that we can.
            SetObjectValue(obj, manager);
            m_serInfo = info;
            m_surrogate = surrogate;

            if (idOfContainer!=0 && ((field!=null && field.FieldType.IsValueType) || arrayIndex!=null)) {
                if (idOfContainer == m_id) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_ParentChildIdentical"));
                }
                m_valueFixup = new ValueTypeFixupInfo(idOfContainer, field, arrayIndex);
            }

            SetFlags();
            
            if (RequiresValueTypeFixup) {
                UpdateDescendentDependencyChain(m_missingElementsRemaining, manager);
            }
        }
    
        internal void MarkForCompletionWhenAvailable() {
            m_markForFixupWhenAvailable = true;
        }


        /*===================================SetFlags===================================
        **Action: An internal-only routine to set the flags based upon the data contained in 
        **        the ObjectHolder
        **Returns: Void
        **Arguments: None
        **Exceptions: None
        ==============================================================================*/
        internal virtual void SetFlags() {
            if (m_object is IObjectReference) {
                m_flags|=INCOMPLETE_OBJECT_REFERENCE;
            }
    
            if (m_surrogate!=null) {
                m_flags|=HAS_SURROGATE;
            } else if (m_object is ISerializable) {
                m_flags|=HAS_ISERIALIZABLE;
            }
            
            if (m_valueFixup!=null) {
                m_flags|=REQUIRES_VALUETYPE_FIXUP;
            }
        }
    
        internal virtual bool IsIncompleteObjectReference {
            get { return (m_flags & INCOMPLETE_OBJECT_REFERENCE)!=0; }
            set { 
                if (value) {
                    m_flags|=INCOMPLETE_OBJECT_REFERENCE;
                } else {
                    m_flags&=~INCOMPLETE_OBJECT_REFERENCE;
                }
            }
        }
    
        internal virtual bool RequiresDelayedFixup {
            get { return (m_flags & REQUIRES_DELAYED_FIXUP)!=0; }
        }

        internal bool RequiresValueTypeFixup {
            get { return (m_flags & REQUIRES_VALUETYPE_FIXUP)!=0; }
        }

        // ValueTypes which require fixups are initially handed to the ObjectManager
        // as boxed objects.  When they're still boxed objects, we should just do fixups
        // on them like we would any other object.  As soon as they're pushed into their
        // containing object we set ValueTypeFixupPerformed to true and have to go through
        // a more complicated path to set fixed up valuetype objects.
        // We check whether or not there are any dependent objects. 
        internal bool ValueTypeFixupPerformed {
            get { 
                BCLDebug.Trace("SER", "[ObjectManager.ValueTypeFixupPerformed]Flags: ", m_flags & VALUETYPE_FIXUP_PERFORMED);
                BCLDebug.Trace("SER", "[ObjectManager.ValueTypeFixupPerformed]DependentObjects: ", (m_dependentObjects==null)?"<null>":m_dependentObjects.Count.ToString());
                return ( ((m_flags & VALUETYPE_FIXUP_PERFORMED)!=0)|| 
                        (m_object!=null && ((m_dependentObjects==null) || m_dependentObjects.Count==0))); }
            set { 
                if (value) {
                    m_flags|=VALUETYPE_FIXUP_PERFORMED;
                }
            }
        }
                

        internal bool HasISerializable {
            get {
                return (m_flags & HAS_ISERIALIZABLE)!=0;
            }
            set {
                if (value) {
                    m_flags|=HAS_ISERIALIZABLE;
                } else {
                    m_flags&=~HAS_ISERIALIZABLE;
                }
            }
        }                
    
        internal virtual bool HasSurrogate {
            get { return (m_flags & HAS_SURROGATE)!=0; }
            set {
                if (value) {
                    m_flags|=HAS_SURROGATE;
                } else {
                    m_flags&=~HAS_SURROGATE;
                }
            }
        }


        internal int DirectlyDependentObjects {
            get {
                return m_missingElementsRemaining;
            }
        }

        internal int DependentDecendents {
            get {
                return m_missingDecendents;
            }
        }

        internal int TotalDependentObjects {
            get {
                return m_missingElementsRemaining + m_missingDecendents;
            }
        }

        internal Object ObjectValue {
            get {
                return m_object;
            }
        }

        internal void SetObjectValue(Object obj, ObjectManager manager) {
            m_object = obj;
            if (m_markForFixupWhenAvailable) {
                manager.CompleteObject(this, true);
            }
        }
        
        internal SerializationInfo SerializationInfo {
            get {
                return m_serInfo;
            }
 
            set {
                m_serInfo = value;
            }
        }

        internal ISerializationSurrogate Surrogate {
            get {
                return m_surrogate;
            }
        }
        
        internal LongList DependentObjects {
            get {
                return m_dependentObjects;
            } 
            set {
                m_dependentObjects = value;
            }
        }

        internal bool RequiresSerInfoFixup {
            get {
                if (((m_flags & HAS_SURROGATE)==0) && ((m_flags & HAS_ISERIALIZABLE)==0)) {
                    return false;
                }

                return (m_flags & SER_INFO_FIXED)==0;
            }
            set {
                if (!value) {
                    m_flags|=SER_INFO_FIXED;
                } else {
                    m_flags&=~SER_INFO_FIXED;
                }
            }
        }                

        internal ValueTypeFixupInfo ValueFixup {
            get {
                return m_valueFixup;
            }
        }

        internal bool CompletelyFixed {
            get {
                return (!RequiresSerInfoFixup && !IsIncompleteObjectReference);
            }
        }
        
        internal long ContainerID {
            get {
                if (m_valueFixup!=null) {
                    return m_valueFixup.ContainerID;
                }
                return 0;
            }
        }
    }    
    
	[Serializable()]
    internal class FixupHolder {
        internal const int ArrayFixup=0x1;
        internal const int MemberFixup=0x2;
        internal const int DelayedFixup=0x4;
    
        internal long   m_id;
        internal Object m_fixupInfo; //This is either an array index, a String, or a MemberInfo
        internal int    m_fixupType;
        
        internal FixupHolder(long id, Object fixupInfo, int fixupType) {
            BCLDebug.Assert(id>0,"id>0");
            BCLDebug.Assert(fixupInfo!=null,"fixupInfo!=null");
            BCLDebug.Assert(fixupType==ArrayFixup || fixupType == MemberFixup || fixupType==DelayedFixup,"fixupType==ArrayFixup || fixupType == MemberFixup || fixupType==DelayedFixup");
            
            m_id = id;
            m_fixupInfo = fixupInfo;
            m_fixupType = fixupType;
        }
    }
    
	[Serializable()]
    internal class FixupHolderList {
        internal const int InitialSize = 2;

        internal FixupHolder[] m_values;
        internal int m_count;
    
        internal FixupHolderList() : this(InitialSize) {
        }
    
        internal FixupHolderList(int startingSize) {
            m_count=0;
            m_values = new FixupHolder[startingSize];
        }
    
        internal virtual void Add(long id, Object fixupInfo) {
            if (m_count==m_values.Length) {
                EnlargeArray();
            }
            m_values[m_count].m_id=id;
            m_values[m_count++].m_fixupInfo = fixupInfo;
        }
    
        internal virtual void Add(FixupHolder fixup) {
            if (m_count==m_values.Length) {
                EnlargeArray();
            }
            m_values[m_count++]=fixup;
        }        
        
        internal int Count {
            get {
                return m_count+1;
            }
        }

    
        private void EnlargeArray() {
            int newLength = m_values.Length*2;
            if (newLength<0) {
                if (newLength==Int32.MaxValue) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_TooManyElements"));
                }
                newLength=Int32.MaxValue;
            }
    
            FixupHolder[] temp = new FixupHolder[newLength];
            Array.Copy(m_values, temp, m_count);
            m_values=temp;
        }
    
    
    }
    
	[Serializable()]
    internal class LongList {
        private const int InitialSize = 2;

        private long [] m_values;
        private int m_count; //The total number of valid items still in the list;
        private int m_totalItems; //The total number of allocated entries.  
                                  //This includes space for items which have been marked as deleted.
        private int m_currentItem; //Used when doing an enumeration over the list.
    
        //
        // An m_currentItem of -1 indicates that the enumeration hasn't been started.
        // An m_values[xx] of -1 indicates that the item has been deleted.
        //
        internal LongList() : this(InitialSize) {
        }
    
        internal LongList(int startingSize) {
            m_count=0;
            m_totalItems = 0;
            m_values = new long[startingSize];
        }
        
        internal void Add(long value) {
            if (m_totalItems==m_values.Length) {
                EnlargeArray();
            }
            m_values[m_totalItems++]=value;
            m_count++;
        }
    
        internal int Count {
            get {
                return m_count;
            }
        }

        internal void StartEnumeration() {
            m_currentItem = -1;
        }

        internal bool MoveNext() {
            while (++m_currentItem < m_totalItems && m_values[m_currentItem]==-1) {
            }
            if (m_currentItem==m_totalItems) {
                return false;
            }
            return true;
        }

        internal long Current {
            get {
                BCLDebug.Assert(m_currentItem!=-1, "[LongList.Current]m_currentItem!=-1");
                BCLDebug.Assert(m_values[m_currentItem]!=-1, "[LongList.Current]m_values[m_currentItem]!=-1");
                return m_values[m_currentItem];
            }
        }

        internal bool RemoveElement(long value) {
            int i;
            for (i=0; i<m_totalItems; i++) {
                if (m_values[i]==value) 
                    break;
            }
            if (i==m_totalItems) {
                return false;
            }
            m_values[i] = -1;
            return true;
        }
             
        private void EnlargeArray() {
            BCLDebug.Trace("SER", "[LongList.EnlargeArray]Enlarging array of size ", m_values.Length);
            int newLength = m_values.Length*2;
            if (newLength<0) {
                if (newLength==Int32.MaxValue) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_TooManyElements"));
                }
                newLength=Int32.MaxValue;
            }
    
            long[] temp = new long[newLength];
            Array.Copy(m_values, temp, m_count);
            m_values = temp;
        }
    }
    
	[Serializable()]    
    internal class ObjectHolderList {
        internal const int DefaultInitialSize = 8;
        
        internal ObjectHolder[] m_values;
        internal int m_count;
    
        internal ObjectHolderList() 
            : this(DefaultInitialSize) {
        }
    
        internal ObjectHolderList(int startingSize) {
            BCLDebug.Assert(startingSize>0 && startingSize<0x1000,"startingSize>0 && startingSize<0x1000");
        
            m_count =0;
            m_values = new ObjectHolder[startingSize];
        }
    
        internal virtual void Add(ObjectHolder value) {
            if (m_count==m_values.Length) {
                EnlargeArray();
            }
            m_values[m_count++]=value;
        }
    

        internal ObjectHolderListEnumerator GetFixupEnumerator() {
            return new ObjectHolderListEnumerator(this, true);
        }

        private void EnlargeArray() {
            BCLDebug.Trace("SER", "[ObjectHolderList.EnlargeArray]Enlarging array of size ", m_values.Length);
            int newLength = m_values.Length*2;
            if (newLength<0) {
                if (newLength==Int32.MaxValue) {
                    throw new SerializationException(Environment.GetResourceString("Serialization_TooManyElements"));
                }
                newLength=Int32.MaxValue;
            }
    
            ObjectHolder[] temp = new ObjectHolder[newLength];
            Array.Copy(m_values, temp, m_count);
            m_values = temp;
        }

        internal int Version {
            get {
                return m_count;
            }
        }

        internal int Count {
            get {
                return m_count;
            }
        }
    }

    internal class ObjectHolderListEnumerator {
        bool m_isFixupEnumerator;
        ObjectHolderList m_list;
        int m_startingVersion;
        int m_currPos;

        internal ObjectHolderListEnumerator(ObjectHolderList list, bool isFixupEnumerator) {
            BCLDebug.Assert(list!=null, "[ObjectHolderListEnumerator.ctor]list!=null");
            m_list = list;
            m_startingVersion = m_list.Version;
            m_currPos=-1;
            m_isFixupEnumerator = isFixupEnumerator;
        }

        internal bool MoveNext() {
            BCLDebug.Assert(m_startingVersion==m_list.Version, "[ObjectHolderListEnumerator.MoveNext]m_startingVersion==m_list.Version");
            if (m_isFixupEnumerator) {
                while (++m_currPos < m_list.Count && m_list.m_values[m_currPos].CompletelyFixed) {
                }
                if (m_currPos==m_list.Count) {
                    return false;
                }
                return true;
            } else {
                m_currPos++;
                if (m_currPos==m_list.Count) {
                    return false;
                }
                return true;
            }
        }

        internal ObjectHolder Current {
            get {
                BCLDebug.Assert(m_currPos!=-1, "[ObjectHolderListEnumerator.Current]m_currPos!=-1");
                BCLDebug.Assert(m_currPos<m_list.Count, "[ObjectHolderListEnumerator.Current]m_currPos<m_list.Count");
                BCLDebug.Assert(m_startingVersion==m_list.Version, "[ObjectHolderListEnumerator.Current]m_startingVersion==m_list.Version");
                return m_list.m_values[m_currPos];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\serializationinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  SerializationInfo
**
** Author: Jay Roxe (jroxe)
**
** Purpose: The structure for holding all of the data needed
**          for object serialization and deserialization.
**
** Date:  April 22, 1999
**
===========================================================*/
namespace System.Runtime.Serialization {
    
    using System;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;

    /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo"]/*' />
    public sealed class SerializationInfo {
        private const int defaultSize = 4;
        
        internal String[]     m_members;
        internal Object[]     m_data;
        internal Type[]       m_types;
        internal String       m_fullTypeName;
        internal int          m_currMember;
        internal String       m_assemName;
        internal IFormatterConverter m_converter;
        
        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.SerializationInfo"]/*' />
        [CLSCompliant(false)]
        public SerializationInfo(Type type, IFormatterConverter converter) {
            if (null==type) {
                throw new ArgumentNullException("type");
            }

            if (converter==null) {
                throw new ArgumentNullException("converter");
            }
            
            
            m_fullTypeName = type.FullName;
            m_assemName = type.Module.Assembly.FullName;
            BCLDebug.Assert(m_fullTypeName!=null, "[SerializationInfo.ctor]m_fullTypeName!=null");
            BCLDebug.Assert(m_assemName!=null, "[SerializationInfo.ctor]m_assemName!=null");
            
            m_members= new String[defaultSize];
            m_data   = new Object[defaultSize]; 
            m_types  = new Type[defaultSize];

            m_converter = converter;
            
            m_currMember = 0;

        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.FullTypeName"]/*' />
        public String FullTypeName {
            get {
                return m_fullTypeName;
            }
            set {
                if (null==value) {
                    throw new ArgumentNullException("value");
                }
                m_fullTypeName = value;
            }
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AssemblyName"]/*' />
        public String AssemblyName {
            get {
                return m_assemName;
            }

            set {
                if (null==value) {
                    throw new ArgumentNullException("value");
                }
                m_assemName = value;
            }
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.SetType"]/*' />
        public void SetType(Type type) {
            if (type==null) {
                throw new ArgumentNullException("type");
            }
            m_fullTypeName = type.FullName;
            m_assemName = type.Module.Assembly.FullName;
            BCLDebug.Assert(m_fullTypeName!=null, "[SerializationInfo.ctor]m_fullTypeName!=null");
            BCLDebug.Assert(m_assemName!=null, "[SerializationInfo.ctor]m_assemName!=null");
        }


        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.MemberCount"]/*' />
        public int MemberCount {
            get {
                return m_currMember;
            }
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetEnumerator"]/*' />
        public SerializationInfoEnumerator GetEnumerator() {
            return new SerializationInfoEnumerator(m_members, m_data, m_types, m_currMember);
        }


        private void ExpandArrays() {
            int newSize;
            BCLDebug.Assert(m_members.Length == m_currMember, "[SerializationInfo.ExpandArrays]m_members.Length == m_currMember");

            newSize = (m_currMember * 2);

            //
            // In the pathological case, we may wrap
            //
            if (newSize<m_currMember) {
                if (Int32.MaxValue>m_currMember) {
                    newSize = Int32.MaxValue;
                }
            }

            //
            // Allocate more space and copy the data
            //
            String[] newMembers = new String[newSize];
            Object[] newData    = new Object[newSize];
            Type[]   newTypes   = new Type[newSize];

            Array.Copy(m_members, newMembers, m_currMember);
            Array.Copy(m_data, newData, m_currMember);
            Array.Copy(m_types, newTypes, m_currMember);

            //
            // Assign the new arrys back to the member vars.
            //
            m_members = newMembers;
            m_data    = newData;
            m_types   = newTypes;
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue"]/*' />
        public void AddValue(String name, Object value, Type type) {
            if (null==name) {
                throw new ArgumentNullException("name");
            }

            if (null==type) {
                throw new ArgumentNullException("type");
            }

            //
            // Walk until we find a member by the same name or until
            // we reach the end.  If we find a member by the same name,
            // throw.
            for (int i=0; i<m_currMember; i++) {
                if (m_members[i].Equals(name)) {
                    BCLDebug.Trace("SER", "[SerializationInfo.AddValue]Tried to add ", name, " twice to the SI.");
                    
                    throw new SerializationException(Environment.GetResourceString("Serialization_SameNameTwice"));
                }
            }
            
            AddValue(name, value, type, m_currMember);

        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue1"]/*' />
        public void AddValue(String name, Object value) {
            if (null==value) {
                AddValue(name, value, typeof(Object));
            } else {
                AddValue(name, value, value.GetType());
            }
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue2"]/*' />
        public void AddValue(String name, bool value) {
            AddValue(name, (Object)value, typeof(bool));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue3"]/*' />
        public void AddValue(String name, char value) {
            AddValue(name, (Object)value, typeof(char));
        }
		

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue4"]/*' />
		[CLSCompliant(false)]
        public void AddValue(String name, sbyte value) {
            AddValue(name, (Object)value, typeof(sbyte));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue5"]/*' />
        public void AddValue(String name, byte value) {
            AddValue(name, (Object)value, typeof(byte));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue6"]/*' />
        public void AddValue(String name, short value) {
            AddValue(name, (Object)value, typeof(short));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue7"]/*' />
		[CLSCompliant(false)]
        public void AddValue(String name, ushort value) {
            AddValue(name, (Object)value, typeof(ushort));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue8"]/*' />
        public void AddValue(String name, int value) {
            AddValue(name, (Object)value, typeof(int));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue9"]/*' />
		[CLSCompliant(false)]
        public void AddValue(String name, uint value) {
            AddValue(name, (Object)value, typeof(uint));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue10"]/*' />
        public void AddValue(String name, long value) {
            AddValue(name, (Object)value, typeof(long));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue11"]/*' />
		[CLSCompliant(false)]
        public void AddValue(String name, ulong value) {
            AddValue(name, (Object)value, typeof(ulong));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue12"]/*' />
        public void AddValue(String name, float value) {
            AddValue(name, (Object)value, typeof(float));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue13"]/*' />
        public void AddValue(String name, double value) {
            AddValue(name, (Object)value, typeof(double));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue14"]/*' />
        public void AddValue(String name, decimal value) {
            AddValue(name, (Object)value, typeof(decimal));
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.AddValue15"]/*' />
        public void AddValue(String name, DateTime value) {
            AddValue(name, (Object)value, typeof(DateTime));
        }

        internal void AddValue(String name, Object value, Type type, int index) {
            //
            // If we need to expand the arrays, do so.
            //
            if (index>=m_members.Length) {
                ExpandArrays();
            }
            
            //
            // Add the data and then advance the counter.
            //
            m_members[index] = name;
            m_data[index]    = value;
            m_types[index]   = type;
            m_currMember++;
        }

        /*=================================UpdateValue==================================
        **Action: Finds the value if it exists in the current data.  If it does, we replace
        **        the values, if not, we append it to the end.  This is useful to the 
        **        ObjectManager when it's performing fixups, but shouldn't be used by 
        **        clients.  Exposing out this functionality would allow children to overwrite
        **        their parent's values.
        **Returns: void
        **Arguments: name  -- the name of the data to be updated.
        **           value -- the new value.
        **           type  -- the type of the data being added.
        **Exceptions: None.  All error checking is done with asserts.
        ==============================================================================*/
        internal void UpdateValue(String name, Object value, Type type) {
            BCLDebug.Assert(null!=name,  "[SerializationInfo.UpdateValue]name!=null");
            BCLDebug.Assert(null!=value, "[SerializationInfo.UpdateValue]value!=null");
            BCLDebug.Assert(null!=type,  "[SerializationInfo.UpdateValue]type!=null");
            
            int index = FindElement(name);
            if (index<0) {
                AddValue(name, value, type, m_currMember);
            } else {
                m_members[index] = name;
                m_data[index]    = value;
                m_types[index]   = type;
            }

        }

        private int FindElement (String name) {
            if (null==name) {
                throw new ArgumentNullException("name");
            }
            BCLDebug.Trace("SER", "[SerializationInfo.FindElement]Looking for ", name, " CurrMember is: ", m_currMember);
            for (int i=0; i<m_currMember; i++) {
                BCLDebug.Assert(m_members[i]!=null, "[SerializationInfo.FindElement]Null Member in String array.");
                if (m_members[i].Equals(name)) {
                    return i;
                }
            }
            return -1;
        }

        /*==================================GetElement==================================
        **Action: Use FindElement to get the location of a particular member and then return
        **        the value of the element at that location.  The type of the member is
        **        returned in the foundType field.
        **Returns: The value of the element at the position associated with name.
        **Arguments: name -- the name of the element to find.
        **           foundType -- the type of the element associated with the given name.
        **Exceptions: None.  FindElement does null checking and throws for elements not 
        **            found.
        ==============================================================================*/
        private Object GetElement(String name, out Type foundType) {
            int index = FindElement(name);
            if (index==-1) {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NotFound"), name));
            }

            BCLDebug.Assert(index < m_data.Length, "[SerializationInfo.GetElement]index<m_data.Length");
            BCLDebug.Assert(index < m_types.Length,"[SerializationInfo.GetElement]index<m_types.Length");

            foundType = m_types[index];
            BCLDebug.Assert(foundType!=null, "[SerializationInfo.GetElement]foundType!=null");
            return m_data[index];
        }

        //
        // The user should call one of these getters to get the data back in the 
        // form requested.  
        //

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetValue"]/*' />
        public Object   GetValue(String name, Type type) {
            Type foundType;
            Object value;
            
            if (null==type) {
                throw new ArgumentNullException("type");
            }

            value = GetElement(name, out foundType);
            if (RemotingServices.IsTransparentProxy(value)) {
                RealProxy proxy = RemotingServices.GetRealProxy(value);
                if (RemotingServices.ProxyCheckCast(proxy, type))
                    return value;
            } else if (foundType==type || type.IsAssignableFrom(foundType) || value==null) {
                return value;
            }

            BCLDebug.Assert(m_converter!=null, "[SerializationInfo.GetValue]m_converter!=null");

            return m_converter.Convert(value, type);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetBoolean"]/*' />
        public bool GetBoolean(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(bool)) {
                return (bool)value;
            }
            return m_converter.ToBoolean(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetChar"]/*' />
        public char     GetChar(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(char)) {
                return (char)value;
            }
            return m_converter.ToChar(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetSByte"]/*' />
		[CLSCompliant(false)]
        public sbyte    GetSByte(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(sbyte)) {
                return (sbyte)value;
            }
            return m_converter.ToSByte(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetByte"]/*' />
        public byte     GetByte(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(byte)) {
                return (byte)value;
            }
            return m_converter.ToByte(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetInt16"]/*' />
        public short    GetInt16(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(short)) {
                return (short)value;
            }
            return m_converter.ToInt16(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetUInt16"]/*' />
		[CLSCompliant(false)]
        public ushort   GetUInt16(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(ushort)) {
                return (ushort)value;
            }
            return m_converter.ToUInt16(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetInt32"]/*' />
        public int      GetInt32(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(int)) {
                return (int)value;
            }
            return m_converter.ToInt32(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetUInt32"]/*' />
		[CLSCompliant(false)]
        public uint     GetUInt32(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(uint)) {
                return (uint)value;
            }
            return m_converter.ToUInt32(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetInt64"]/*' />
        public long     GetInt64(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(long)) {
                return (long)value;
            }
            return m_converter.ToInt64(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetUInt64"]/*' />
		[CLSCompliant(false)]
        public ulong    GetUInt64(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(ulong)) {
                return (ulong)value;
            }
            return m_converter.ToUInt64(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetSingle"]/*' />
        public float    GetSingle(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(float)) {
                return (float)value;
            }
            return m_converter.ToSingle(value);
        }


        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetDouble"]/*' />
        public double   GetDouble(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(double)) {
                return (double)value;
            }
            return m_converter.ToDouble(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetDecimal"]/*' />
        public decimal GetDecimal(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(decimal)) {
                return (decimal)value;
            }
            return m_converter.ToDecimal(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetDateTime"]/*' />
        public DateTime GetDateTime(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(DateTime)) {
                return (DateTime)value;
            }
            return m_converter.ToDateTime(value);
        }

        /// <include file='doc\SerializationInfo.uex' path='docs/doc[@for="SerializationInfo.GetString"]/*' />
        public String   GetString(String name) {
            Type foundType;
            Object value;
            
            value = GetElement(name, out foundType);
            if (foundType == typeof(String) || value==null) {
                return (String)value;
            }
            return m_converter.ToString(value);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\sertrace.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SerTrace
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Routine used for Debugging
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters {
	using System;	
	using System.Runtime.Serialization;
	using System.Security.Permissions;
	using System.Reflection;
    using System.Diagnostics;

	// To turn on tracing the set registry
	// HKEY_CURRENT_USER -> Software -> Microsoft -> .NETFramework
	// new DWORD value ManagedLogFacility 0x32 where
	// 0x2 is System.Runtime.Serialization
	// 0x10 is Binary Formatter
	// 0x20 is Soap Formatter
	//
	// Turn on Logging in the jitmgr


    // remoting Wsdl logging
    /// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalRM"]/*' />
    /// <internalonly/>
    [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x00000000000000000400000000000000", Name="System.Runtime.Remoting" )]
    public sealed class InternalRM
    {
		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalRM.InfoSoap"]/*' />
        /// <internalonly/>
		[System.Diagnostics.Conditional("_LOGGING")]
		public static void InfoSoap(params Object[]messages)
		{
			BCLDebug.Trace("SOAP", messages);
		}

        //[System.Diagnostics.Conditional("_LOGGING")]		
		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalRM.SoapCheckEnabled"]/*' />
        /// <internalonly/>
		public static bool SoapCheckEnabled()
        {
                return BCLDebug.CheckEnabled("SOAP");
        }
    }

	/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST"]/*' />
    /// <internalonly/>
    [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293", Name="System.Runtime.Serialization.Formatters.Soap" )]
	public sealed class InternalST
	{
		private InternalST()
		{
		}

		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.InfoSoap"]/*' />
        /// <internalonly/>
		[System.Diagnostics.Conditional("_LOGGING")]
		public static void InfoSoap(params Object[]messages)
		{
			BCLDebug.Trace("SOAP", messages);
		}

        //[System.Diagnostics.Conditional("_LOGGING")]		
		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.SoapCheckEnabled"]/*' />
        /// <internalonly/>
		public static bool SoapCheckEnabled()
        {
                return BCLDebug.CheckEnabled("Soap");
        }

		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.Soap"]/*' />
        /// <internalonly/>
		[System.Diagnostics.Conditional("SER_LOGGING")]		
		public static void Soap(params Object[]messages)
		{
			if (!(messages[0] is String))
				messages[0] = (messages[0].GetType()).Name+" ";
			else
				messages[0] = messages[0]+" ";				

			BCLDebug.Trace("SOAP",messages);								
		}

		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.SoapAssert"]/*' />
        /// <internalonly/>
		[System.Diagnostics.Conditional("_DEBUG")]		
		public static void SoapAssert(bool condition, String message)
		{
			BCLDebug.Assert(condition, message);
		}

		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.SerializationSetValue"]/*' />
        /// <internalonly/>
		public static void SerializationSetValue(FieldInfo fi, Object target, Object value)
		{
                        if ( fi == null)
                            throw new ArgumentNullException("fi");
                        
                        if (target == null)
                            throw new ArgumentNullException("target");
                        
                        if (value == null)
                            throw new ArgumentNullException("value");
                        
                        FormatterServices.SerializationSetValue(fi, target, value);
                }

		/// <include file='doc\SerTrace.uex' path='docs/doc[@for="InternalST.LoadAssemblyFromString"]/*' />
        /// <internalonly/>
		public static Assembly LoadAssemblyFromString(String assemblyString)
		{
			return FormatterServices.LoadAssemblyFromString(assemblyString);
		}
	}

	internal sealed class SerTrace
	{
		internal SerTrace()
		{
		}

		[Conditional("_LOGGING")]
		internal static void InfoLog(params Object[]messages)
		{
			BCLDebug.Trace("BINARY", messages);
		}

		[Conditional("SER_LOGGING")]			
		internal static void Log(params Object[]messages)
		{
			if (!(messages[0] is String))
				messages[0] = (messages[0].GetType()).Name+" ";
			else
				messages[0] = messages[0]+" ";								
			BCLDebug.Trace("BINARY",messages);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\commonenums.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: FormatterEnums
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Soap XML Formatter Enums
 **
 ** Date:  August 23, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters {
	using System.Threading;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System;
    // Enums which specify options to the XML and Binary formatters
    // These will be public so that applications can use them
    /// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterTypeStyle"]/*' />
	[Serializable]
    public enum FormatterTypeStyle
    {
    	/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterTypeStyle.TypesWhenNeeded"]/*' />
    	TypesWhenNeeded = 0, // Types are outputted only for Arrays of Objects, Object Members of type Object, and ISerializable non-primitive value types
    	/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterTypeStyle.TypesAlways"]/*' />
    	TypesAlways = 0x1, // Types are outputted for all Object members and ISerialiable object members.
		/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterTypeStyle.XsdString"]/*' />
		XsdString = 0x2     // Strings are outputed as xsd rather then SOAP-ENC strings. No string ID's are transmitted
    }

	/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterAssemblyStyle"]/*' />
	[Serializable]
	public enum FormatterAssemblyStyle
	{
		/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterAssemblyStyle.Simple"]/*' />
		Simple = 0,
		/// <include file='doc\CommonEnums.uex' path='docs/doc[@for="FormatterAssemblyStyle.Full"]/*' />
		Full = 1,
	}
    
    public enum TypeFilterLevel {
        Low = 0x2,
        Full = 0x3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\valuetypefixupinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class: ValueTypeFixupInfo
**
** Author: Jay Roxe
**
** Purpose: Information about an object required to do a value-type
** fixup.  This includes the id of the containing object and the
** member info (if the containing body is an object or value type) 
** or the array indices (if the containing body is an array.)
**
** Date: August 30, 2000
**
============================================================*/
namespace System.Runtime.Serialization {
    using System.Reflection;

    internal class ValueTypeFixupInfo {

        //The id of the containing body.  This could be a regular
        //object, another value type, or an array.  For obvious reasons,
        //the containing body can never have both a FieldInfo and 
        //an array index.
        private long m_containerID;

        //The FieldInfo into the containing body.  This will only 
        //apply if the containing body is a field info or another
        //value type.
        private FieldInfo m_parentField;
        
        //The array index of the index into the parent.  This will only
        //apply if the containing body is an array.
        private int[] m_parentIndex;
        
        public ValueTypeFixupInfo(long containerID, FieldInfo member, int[] parentIndex) {
            
            BCLDebug.Trace("SER", "[ValueTypeFixupInfo.ctor]Creating a VTFI with Container ID: ", containerID, " and MemberInfo ", member);

            if (containerID==0 && member==null) {
                m_containerID = containerID;
                m_parentField = member;
                m_parentIndex = parentIndex;
            }

            //If both member and arrayIndex are null, we don't have enough information to create
            //a tunnel to do the fixup.
            if (member==null && parentIndex==null) {
                throw new ArgumentException(Environment.GetResourceString("Argument_MustSupplyParent"));
            }

            //If the member isn't null, we know that they supplied a MemberInfo as the parent.  This means
            //that the arrayIndex must be null because we can't have a FieldInfo into an array. 
            if (member!=null) {
                if (parentIndex!=null) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_MemberAndArray"));
                }
                       
                if (((((FieldInfo)member).FieldType).IsValueType) && containerID==0) {
                    throw new ArgumentException(Environment.GetResourceString("Argument_MustSupplyContainer"));
                }
            } 

            m_containerID=containerID;
            m_parentField = (FieldInfo)member;
            m_parentIndex = parentIndex;
        }

        public long ContainerID { 
            get {
                return m_containerID;
            }
        }

        public FieldInfo ParentField {
            get {
                return m_parentField;
            }
        }

        public int[] ParentIndex {
            get {
                return m_parentIndex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\soapfault.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapFault
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Specifies information for a Soap Fault
 **
 ** Date:  June 27, 2000
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters
{
	using System;
	using System.Runtime.Serialization;
	using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata;
    using System.Globalization;

	//* Class holds soap fault information

	/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault"]/*' />
	[Serializable, SoapType(Embedded=true)]	
	public sealed class SoapFault : ISerializable
	{
		String faultCode;
		String faultString;
		String faultActor;
		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.detail"]/*' />
		[SoapField(Embedded=true)] Object detail;

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.SoapFault1"]/*' />
		public SoapFault()
		{
		}

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.SoapFault"]/*' />
		public SoapFault(String faultCode, String faultString, String faultActor, ServerFault serverFault)
		{
			this.faultCode = faultCode;
			this.faultString = faultString;
			this.faultActor = faultActor;
			this.detail = serverFault;
		}

		internal SoapFault(SerializationInfo info, StreamingContext context)
		{
			SerializationInfoEnumerator siEnum = info.GetEnumerator();		

			while(siEnum.MoveNext())
			{
				String name = siEnum.Name;
				Object value = siEnum.Value;
				SerTrace.Log(this, "SetObjectData enum ",name," value ",value);
				if (String.Compare(name, "faultCode", true, CultureInfo.InvariantCulture) == 0)
				{
					int index = ((String)value).IndexOf(':');
					if (index > -1)
						faultCode = ((String)value).Substring(++index);
					else
						faultCode = (String)value;
				}
				else if (String.Compare(name, "faultString", true, CultureInfo.InvariantCulture) == 0)
					faultString = (String)value;
				else if (String.Compare(name, "faultActor", true, CultureInfo.InvariantCulture) == 0)
					faultActor = (String)value;
				else if (String.Compare(name, "detail", true, CultureInfo.InvariantCulture) == 0)
					detail = value;
			}
		}

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.GetObjectData"]/*' />
		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("faultcode", "SOAP-ENV:"+faultCode);
			info.AddValue("faultstring", faultString);
			if (faultActor != null)
				info.AddValue("faultactor", faultActor);
			info.AddValue("detail", detail, typeof(Object));
		}

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.FaultCode"]/*' />
		public String FaultCode
		{
			get {return faultCode;}
			set { faultCode = value;}
		}

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.FaultString"]/*' />
		public String FaultString
		{
			get {return faultString;}
			set { faultString = value;}
		}


		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.FaultActor"]/*' />
		public String FaultActor
		{
			get {return faultActor;}
			set { faultActor = value;}
		}


		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="SoapFault.Detail"]/*' />
		public Object Detail
		{
			get {return detail;}
			set {detail = value;}
		}
	}

	/// <include file='doc\SoapFault.uex' path='docs/doc[@for="ServerFault"]/*' />
	[Serializable, SoapType(Embedded=true)]
	public sealed class ServerFault
	{
		String exceptionType;
		String message;
		String stackTrace;
        Exception exception;

        internal ServerFault(Exception exception)
        {
            this.exception = exception;
            //this.exceptionType = exception.GetType().AssemblyQualifiedName;
            //this.message = exception.Message;
        }

		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="ServerFault.ServerFault"]/*' />
		public ServerFault(String exceptionType, String message, String stackTrace)
		{
			this.exceptionType = exceptionType;
			this.message = message;
			this.stackTrace = stackTrace;
		}


		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="ServerFault.ExceptionType"]/*' />
		public String ExceptionType
		{
			get {return exceptionType;}
			set { exceptionType = value;}
		}
		
		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="ServerFault.ExceptionMessage"]/*' />
		public String ExceptionMessage
		{
			get {return message;}
			set { message = value;}
		}


		/// <include file='doc\SoapFault.uex' path='docs/doc[@for="ServerFault.StackTrace"]/*' />
		public String StackTrace
		{
			get {return stackTrace;}
			set {stackTrace = value;}
		}

        internal Exception Exception
        {
			get {return exception;}
			set {exception = value;}
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\soapmessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SoapMessage
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Interface For Soap Method Call
 **
 ** Date:  October 6, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters {
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;
    using System;
    // Class is used to return the call object for a SOAP call.
    // This is used when the top SOAP object is a fake object, it contains
    // a method name as the element name instead of the object name.
    /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage"]/*' />
   [Serializable()]
    public class SoapMessage : ISoapMessage
    {
        internal String[] paramNames;
        internal Object[] paramValues;
        internal Type[] paramTypes;
        internal String methodName;
        internal String xmlNameSpace;
        internal Header[] headers;
        
        // Name of parameters, if null the default param names will be used
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.ParamNames"]/*' />
        public String[] ParamNames
        {
            get {return paramNames;}
            set {paramNames = value;}
        }    
        
        // Parameter Values
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.ParamValues"]/*' />
        public Object[] ParamValues
        {
            get {return paramValues;}
            set {paramValues = value;}
        }

        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.ParamTypes"]/*' />
        public Type[] ParamTypes
        {
            get {return paramTypes;}
            set {paramTypes = value;}            
        }

        // MethodName
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.MethodName"]/*' />
        public String MethodName
        {
            get {return methodName;}
            set {methodName = value;}
        }

        // MethodName XmlNameSpace
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.XmlNameSpace"]/*' />
        public String XmlNameSpace
        {
            get {return xmlNameSpace;}
            set {xmlNameSpace = value;}
        }

        // Headers
        /// <include file='doc\SoapMessage.uex' path='docs/doc[@for="SoapMessage.Headers"]/*' />
        public Header[] Headers
        {
            get {return headers;}
            set {headers = value;}
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryenums.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: BinaryEnums
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Soap XML Formatter Enums
 **
 ** Date:  August 23, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Binary
{
	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
	using System;
    // BinaryHeaderEnum is the first byte on binary records
    // (except for primitive types which do not have a header)
    [Serializable]
	enum BinaryHeaderEnum
    {
    	SerializedStreamHeader = 0,
    	Object = 1,
		ObjectWithMap = 2,
		ObjectWithMapAssemId = 3,
		ObjectWithMapTyped = 4,
		ObjectWithMapTypedAssemId = 5,
		ObjectString = 6,
		Array = 7,
		MemberPrimitiveTyped = 8,
		MemberReference = 9,
		ObjectNull = 10,
		MessageEnd = 11,
		Assembly = 12,
        ObjectNullMultiple256 = 13,
        ObjectNullMultiple = 14,
        ArraySinglePrimitive = 15,
        ArraySingleObject = 16,
        ArraySingleString = 17,
        CrossAppDomainMap = 18,
        CrossAppDomainString = 19,
        CrossAppDomainAssembly = 20,
        MethodCall = 21,
        MethodReturn = 22,
	}

	// BinaryTypeEnum is used specify the type on the wire.
	// Additional information is transmitted with Primitive and Object types
    [Serializable]
	enum BinaryTypeEnum
	{
		Primitive = 0,
		String = 1,
		Object = 2,	
		ObjectUrt = 3,
		ObjectUser = 4,
        ObjectArray = 5,
        StringArray = 6,
        PrimitiveArray = 7,
	}

    [Serializable]
	internal enum BinaryArrayTypeEnum
	{
		Single = 0,
		Jagged = 1,
		Rectangular = 2,
		SingleOffset = 3,
		JaggedOffset = 4,
		RectangularOffset = 5,		
	}

    // Enums are for internal use by the XML and Binary Serializers
    // They will eventually signed to restrict there use

	// Formatter Enums
    [Serializable]
	internal enum InternalSerializerTypeE
	{
		Soap = 1,
		Binary = 2,
	}

	// Writer Enums
    [Serializable]
	internal enum InternalElementTypeE
	{
		ObjectBegin = 0,
		ObjectEnd = 1,
		Member = 2,
	}

	// ParseRecord Enums
    [Serializable]
	internal enum InternalParseTypeE
	{
		Empty = 0,
		SerializedStreamHeader = 1,
		Object = 2,
		Member = 3,
		ObjectEnd = 4,
		MemberEnd = 5,
		Headers = 6,
		HeadersEnd = 7,
		SerializedStreamHeaderEnd = 8,
		Envelope = 9,
		EnvelopeEnd = 10,
		Body = 11,
		BodyEnd = 12,
	}


    [Serializable]
	internal enum InternalObjectTypeE
	{
		Empty = 0,
		Object = 1,
		Array = 2,
	}


    [Serializable]
	internal enum InternalObjectPositionE
	{
		Empty = 0,
		Top = 1,
		Child = 2,
		Headers = 3,
	}

    [Serializable]
	internal enum InternalArrayTypeE
	{
		Empty = 0,
		Single = 1,
		Jagged = 2,
		Rectangular = 3,
		Base64 = 4,
	}

    [Serializable]
	internal enum InternalMemberTypeE
	{
		Empty = 0,
		Header = 1,
		Field = 2,
		Item = 3,
	}

    [Serializable]
	internal enum InternalMemberValueE
	{
		Empty = 0,
		InlineValue = 1,
		Nested = 2,
		Reference = 3,
		Null = 4,
	}

	// XML Parse Enum
    [Serializable]
	internal enum InternalParseStateE
	{
		Initial = 0,
		Object = 1,
		Member = 2,
		MemberChild = 3,
	}

	// Data Type Enums
    [Serializable]
	internal enum InternalPrimitiveTypeE
	{
		Invalid = 0,
		Boolean = 1,
		Byte = 2,
		Char = 3,
		Currency = 4,
		Decimal = 5,
		Double = 6,
		Int16 = 7,
		Int32 = 8,
		Int64 = 9,
		SByte = 10,
		Single = 11,
		TimeSpan = 12,
		DateTime = 13,
		UInt16 = 14,
		UInt32 = 15,
		UInt64 = 16,

        // Used in only for MethodCall or MethodReturn header
        Null = 17,
        String = 18,
	}

    [Serializable, Flags]
    internal enum MessageEnum
    {
        NoArgs = 0x1,
        ArgsInline = 0x2,
        ArgsIsArray = 0x4,
        ArgsInArray = 0x8,
        NoContext = 0x10,
        ContextInline = 0x20,
        ContextInArray = 0x40,
        MethodSignatureInArray = 0x80,
        PropertyInArray = 0x100,
        NoReturnValue = 0x200,
        ReturnValueVoid = 0x400,
        ReturnValueInline = 0x800,
        ReturnValueInArray = 0x1000,
        ExceptionInArray = 0x2000,
    }


	// ValueType Fixup Enum
    [Serializable]
	enum ValueFixupEnum
	{
		Empty = 0,
		Array = 1,
		Header = 2,
		Member = 3,
	}

	// name space
    [Serializable]
	internal enum InternalNameSpaceE
	{
		None = 0,
		Soap = 1,
		XdrPrimitive = 2,
		XdrString = 3,
		UrtSystem = 4,
		UrtUser = 5,
		UserNameSpace = 6,
		MemberName = 7,
		Interop = 8,
		CallElement = 9
	}

    [Serializable]
	internal enum SoapAttributeType
	{
		None = 0x0,
		SchemaType = 0x1,
		Embedded = 0x2,
		XmlElement = 0x4,
		XmlAttribute = 0x8
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binarymethodmessage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Runtime.Serialization.Formatters.Binary
{
    using System;
    using System.Collections;
    using System.Runtime.Remoting.Messaging;
    using System.Reflection;


    [Serializable()]     
    internal sealed class BinaryMethodCallMessage
    {
        Object[] _inargs = null;
        String[] _inargsName = null;
        //String _uri = null;
        String _methodName = null;
        String _typeName = null;
        Object _methodSignature = null;

        Object[] _args = null;
        String[] _argsName = null;
        bool _hasVarArgs = false;
        LogicalCallContext _logicalCallContext = null;
        MethodBase _methodBase = null;

        Object[] _properties = null;

        internal BinaryMethodCallMessage(String uri, String methodName, String typeName, Object[] args, Object methodSignature, LogicalCallContext callContext, Object[] properties)
        {
            _methodName = methodName;
            _typeName = typeName;
            //_uri = uri;
            if (args == null)
                args = new Object[0];

            _inargs = args;
            _args = args;
            _methodSignature = methodSignature;
            if (callContext == null)
                _logicalCallContext = new LogicalCallContext();
            else
                _logicalCallContext = callContext;

            _properties = properties;

        }

        public int InArgCount 
        {
            get {return _inargs.Length;}
        }

        public String GetInArgName(int index)
        {
            return _inargsName[index];
        }

        public Object GetInArg(int argNum)
        {
            return _inargs[argNum];
        }

        public Object[] InArgs
        {
            get {return _inargs;}
        }

        //IMessage
        /*
        public String Uri
        {
            get {return _uri;}
        }
        */

        public String MethodName
        {
            get {return _methodName;}
        }

        public String TypeName
        {
            get {return _typeName;}
        }

        public Object MethodSignature
        {
            get {return _methodSignature;}
        }


        public int ArgCount
        {
            get {return _args.Length;}
        }

        public String GetArgName(int index)
        {
            return _argsName[index];
        }

        public Object GetArg(int argNum)
        {
            return _args[argNum];
        }

        public Object[] Args
        {
            get {return _args;}
        }


        public bool HasVarArgs
        {
            get {return _hasVarArgs;}
        }

        public LogicalCallContext LogicalCallContext
        {
            get {return _logicalCallContext;}
        }

        // This is never actually put on the wire, it is
        // simply used to cache the method base after it's
        // looked up once.
        public MethodBase MethodBase
        {
            get {return _methodBase;}
        }

        public bool HasProperties
        {
            get {return (_properties != null);}
        }

        internal void PopulateMessageProperties(IDictionary dict)
        {
            foreach (DictionaryEntry de in _properties)
            {
                dict[de.Key] = de.Value;
            }
        }

    }


    [Serializable()]     
    internal class BinaryMethodReturnMessage
    {
        Object[] _outargs = null;
        String[] _outargsName = null;
        Exception _exception = null;
        Object _returnValue = null;

        //String _uri = null;
        String _methodName = null;
        String _typeName = null;
        String _methodSignature = null;
        Object[] _args = null;
        String[] _argsName = null;
        bool _hasVarArgs = false;
        LogicalCallContext _logicalCallContext = null;
        MethodBase _methodBase = null;

        Object[] _properties = null;

        internal BinaryMethodReturnMessage(Object returnValue, Object[] args, Exception e, LogicalCallContext callContext, Object[] properties)
        {
            _returnValue = returnValue;
            if (args == null)
                args = new Object[0];

            _outargs = args;
            _args= args;
            _exception = e;

            if (callContext == null)
                _logicalCallContext = new LogicalCallContext();
            else
                _logicalCallContext = callContext;
            
            _properties = properties;
        }

        public int OutArgCount
        {
            get {return _outargs.Length;}
        }

        public String GetOutArgName(int index)
        {
            return _outargsName[index];
        }

        public Object GetOutArg(int argNum)
        {
            return _outargs[argNum];
        }

        public Object[]  OutArgs
        {
            get {return _outargs;}
        }


        public Exception Exception
        {
            get {return _exception;}
        }

        public Object  ReturnValue
        {
            get {return _returnValue;}
        }


        //IMessage
        /*
        public String Uri
        {
            get {return _uri;}
        }
        */

        public String MethodName
        {
            get {return _methodName;}
        }

        public String TypeName
        {
            get {return _typeName;}
        }

        public Object MethodSignature
        {
            get {return _methodSignature;}
        }

        public int ArgCount
        {
            get {return _args.Length;}
        }

        public String GetArgName(int index)
        {
            return _argsName[index];
        }

        public Object GetArg(int argNum)
        {
            return _args[argNum];
        }

        public Object[] Args
        {
            get {return _args;}
        }

        public bool HasVarArgs
        {
            get {return _hasVarArgs;}
        }

        public LogicalCallContext LogicalCallContext
        {
            get {return _logicalCallContext;}
        }

        // This is never actually put on the wire, it is
        // simply used to cache the method base after it's
        // looked up once.
        public MethodBase MethodBase
        {
            get {return _methodBase;}
        }
        public bool HasProperties
        {
            get {return (_properties != null);}
        }

        internal void PopulateMessageProperties(IDictionary dict)
        {
            foreach (DictionaryEntry de in _properties)
            {
                dict[de.Key] = de.Value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryconverter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: Converter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Hexify and bin.base64 conversions
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Binary {

    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Text;
    using System.Security.Permissions;

    sealed internal class Converter
    {
        private Converter()
        {
        }


        private static int primitiveTypeEnumLength = 17; //Number of PrimitiveTypeEnums

        // The following section are utilities to read and write XML types

        internal static InternalPrimitiveTypeE ToCode(Type type)
        {
            SerTrace.Log("Converter", "ToCode Type Entry ",type);           
            InternalPrimitiveTypeE code;
            /*
            if (type == typeofDateTime)
                code = InternalPrimitiveTypeE.DateTime;
            else if (type == typeofTimeSpan)
                code = InternalPrimitiveTypeE.TimeSpan;
            else if (type == typeofDecimal)
                code = InternalPrimitiveTypeE.Decimal;
                */
            if (type != null && !type.IsPrimitive)
            {
                if (type == typeofDateTime)
                    code = InternalPrimitiveTypeE.DateTime;
                else if (type == typeofTimeSpan)
                    code = InternalPrimitiveTypeE.TimeSpan;
                else if (type == typeofDecimal)
                    code = InternalPrimitiveTypeE.Decimal;
                else
                    code = InternalPrimitiveTypeE.Invalid;
            }
            else
                code = ToPrimitiveTypeEnum(Type.GetTypeCode(type));

            SerTrace.Log("Converter", "ToCode Exit " , ((Enum)code).ToString());
            return code;
        }




        internal static bool IsWriteAsByteArray(InternalPrimitiveTypeE code)
        {
            bool isWrite = false;

            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                case InternalPrimitiveTypeE.Char:
                case InternalPrimitiveTypeE.Byte:
                case InternalPrimitiveTypeE.Double:
                case InternalPrimitiveTypeE.Int16:
                case InternalPrimitiveTypeE.Int32:
                case InternalPrimitiveTypeE.Int64:
                case InternalPrimitiveTypeE.SByte:
                case InternalPrimitiveTypeE.Single:
                case InternalPrimitiveTypeE.UInt16:
                case InternalPrimitiveTypeE.UInt32:
                case InternalPrimitiveTypeE.UInt64:
                    isWrite = true;
                    break;
            }
            return isWrite;
        }

        internal static int TypeLength(InternalPrimitiveTypeE code)
        {
            int length  = 0;

            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                    length = 1;
                    break;
                case InternalPrimitiveTypeE.Char:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.Byte:
                    length = 1;
                    break;                  
                case InternalPrimitiveTypeE.Double:
                    length = 8;
                    break;                  
                case InternalPrimitiveTypeE.Int16:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.Int32:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.Int64:
                    length = 8;
                    break;                  
                case InternalPrimitiveTypeE.SByte:
                    length = 1;
                    break;                  
                case InternalPrimitiveTypeE.Single:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.UInt16:
                    length = 2;
                    break;                  
                case InternalPrimitiveTypeE.UInt32:
                    length = 4;
                    break;                  
                case InternalPrimitiveTypeE.UInt64:
                    length = 8;
                    break;                  
            }
            return length;
        }


        internal static InternalNameSpaceE GetNameSpaceEnum(InternalPrimitiveTypeE code, Type type, WriteObjectInfo objectInfo, out String typeName)
        {
            SerTrace.Log("Converter", "GetNameSpaceEnum Entry ",((Enum)code).ToString()," type ",type);                 
            InternalNameSpaceE nameSpaceEnum = InternalNameSpaceE.None;
            typeName = null;

            if (code != InternalPrimitiveTypeE.Invalid)
            {
                switch (code)
                {
                    case InternalPrimitiveTypeE.Boolean:
                    case InternalPrimitiveTypeE.Char:
                    case InternalPrimitiveTypeE.Byte:
                    case InternalPrimitiveTypeE.Double:
                    case InternalPrimitiveTypeE.Int16:
                    case InternalPrimitiveTypeE.Int32:
                    case InternalPrimitiveTypeE.Int64:
                    case InternalPrimitiveTypeE.SByte:
                    case InternalPrimitiveTypeE.Single:
                    case InternalPrimitiveTypeE.UInt16:
                    case InternalPrimitiveTypeE.UInt32:
                    case InternalPrimitiveTypeE.UInt64:
                    case InternalPrimitiveTypeE.DateTime:
                    case InternalPrimitiveTypeE.TimeSpan:
                        nameSpaceEnum = InternalNameSpaceE.XdrPrimitive;
                        typeName = "System."+ToComType(code);                       
                        break;

                    case InternalPrimitiveTypeE.Decimal:
                        nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                        typeName = "System."+ToComType(code);
                        break;
                }
            }

            if ((nameSpaceEnum == InternalNameSpaceE.None) && (type != null))
            {
                if (type == typeofString)
                    nameSpaceEnum = InternalNameSpaceE.XdrString;
                else
                {
                    if (objectInfo == null)
                    {
                        typeName = type.FullName;
                        if (type.Module.Assembly == urtAssembly)
                            nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                        else
                            nameSpaceEnum = InternalNameSpaceE.UrtUser;                     
                    }
                    else
                    {
                        typeName = objectInfo.GetTypeFullName();
                        if (objectInfo.GetAssemblyString().Equals(urtAssemblyString))
                            nameSpaceEnum = InternalNameSpaceE.UrtSystem;
                        else
                            nameSpaceEnum = InternalNameSpaceE.UrtUser;
                    }
                }
            }

            SerTrace.Log("Converter", "GetNameSpaceEnum Exit ", ((Enum)nameSpaceEnum).ToString()," typeName ",typeName);                                
            return nameSpaceEnum;
        }

        // Returns a COM runtime type associated with the type  code

        internal static Type ToArrayType(InternalPrimitiveTypeE code)
        {
            SerTrace.Log("Converter", "ToType Entry ", ((Enum)code).ToString());
            if (arrayTypeA == null)
                InitArrayTypeA();
            SerTrace.Log("Converter", "ToType Exit ", ((arrayTypeA[(int)code] == null)?"null ":arrayTypeA[(int)code].Name));                
            return arrayTypeA[(int)code];
        }


        private static Type[] typeA;

        private static void InitTypeA()
        {
            Type[] typeATemp = new Type[primitiveTypeEnumLength];
            typeATemp[(int)InternalPrimitiveTypeE.Invalid] = null;
            typeATemp[(int)InternalPrimitiveTypeE.Boolean] = typeofBoolean;
            typeATemp[(int)InternalPrimitiveTypeE.Byte] = typeofByte;
            typeATemp[(int)InternalPrimitiveTypeE.Char] = typeofChar;
            typeATemp[(int)InternalPrimitiveTypeE.Decimal] = typeofDecimal;
            typeATemp[(int)InternalPrimitiveTypeE.Double] = typeofDouble;
            typeATemp[(int)InternalPrimitiveTypeE.Int16] = typeofInt16;
            typeATemp[(int)InternalPrimitiveTypeE.Int32] = typeofInt32;
            typeATemp[(int)InternalPrimitiveTypeE.Int64] = typeofInt64;
            typeATemp[(int)InternalPrimitiveTypeE.SByte] = typeofSByte;
            typeATemp[(int)InternalPrimitiveTypeE.Single] = typeofSingle;
            typeATemp[(int)InternalPrimitiveTypeE.TimeSpan] = typeofTimeSpan;
            typeATemp[(int)InternalPrimitiveTypeE.DateTime] = typeofDateTime;
            typeATemp[(int)InternalPrimitiveTypeE.UInt16] = typeofUInt16;
            typeATemp[(int)InternalPrimitiveTypeE.UInt32] = typeofUInt32;
            typeATemp[(int)InternalPrimitiveTypeE.UInt64] = typeofUInt64;
            typeA = typeATemp;
        }


        private static Type[] arrayTypeA;

        private static void InitArrayTypeA()
        {
            Type[] arrayTypeATemp = new Type[primitiveTypeEnumLength];
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Invalid] = null;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Boolean] = typeofBooleanArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Byte] = typeofByteArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Char] = typeofCharArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Decimal] = typeofDecimalArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Double] = typeofDoubleArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Int16] = typeofInt16Array;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Int32] = typeofInt32Array;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Int64] = typeofInt64Array;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.SByte] = typeofSByteArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.Single] = typeofSingleArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.TimeSpan] = typeofTimeSpanArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.DateTime] = typeofDateTimeArray;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.UInt16] = typeofUInt16Array;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.UInt32] = typeofUInt32Array;
            arrayTypeATemp[(int)InternalPrimitiveTypeE.UInt64] = typeofUInt64Array;
            arrayTypeA = arrayTypeATemp;
        }


        // Returns a COM runtime type associated with the type  code

        internal static Type ToType(InternalPrimitiveTypeE code)
        {
            SerTrace.Log("Converter", "ToType Entry ", ((Enum)code).ToString());
            if (typeA == null)
                InitTypeA();
            SerTrace.Log("Converter", "ToType Exit ", ((typeA[(int)code] == null)?"null ":typeA[(int)code].Name));              
            return typeA[(int)code];
        }




        internal static Array CreatePrimitiveArray(InternalPrimitiveTypeE code, int length)
        {
            Array array = null;
            switch (code)
            {
                case InternalPrimitiveTypeE.Boolean:
                    array = new Boolean[length];
                    break;
                case InternalPrimitiveTypeE.Byte:
                    array = new Byte[length];
                    break;
                case InternalPrimitiveTypeE.Char:
                    array = new Char[length];
                    break;
                case InternalPrimitiveTypeE.Decimal:
                    array = new Decimal[length];
                    break;
                case InternalPrimitiveTypeE.Double:
                    array = new Double[length];
                    break;
                case InternalPrimitiveTypeE.Int16:
                    array = new Int16[length];
                    break;
                case InternalPrimitiveTypeE.Int32:
                    array = new Int32[length];
                    break;
                case InternalPrimitiveTypeE.Int64:
                    array = new Int64[length];
                    break;
                case InternalPrimitiveTypeE.SByte:
                    array = new SByte[length];
                    break;
                case InternalPrimitiveTypeE.Single:
                    array = new Single[length];
                    break;
                case InternalPrimitiveTypeE.TimeSpan:
                    array = new TimeSpan[length];
                    break;
                case InternalPrimitiveTypeE.DateTime:
                    array = new DateTime[length];
                    break;
                case InternalPrimitiveTypeE.UInt16:
                    array = new UInt16[length];
                    break;
                case InternalPrimitiveTypeE.UInt32:
                    array = new UInt32[length];
                    break;
                case InternalPrimitiveTypeE.UInt64:
                    array = new UInt64[length];
                    break;
            }
            return array;
        }

        internal static bool IsPrimitiveArray(Type type, out Object typeInformation)
        {
            typeInformation = null;
            bool bIsPrimitive = true;

            if (type == typeofBooleanArray)
                typeInformation = InternalPrimitiveTypeE.Boolean;
            else if (type == typeofByteArray)
                typeInformation = InternalPrimitiveTypeE.Byte;
            else if (type == typeofCharArray)
                typeInformation = InternalPrimitiveTypeE.Char;
            else if (type == typeofDoubleArray)
                typeInformation = InternalPrimitiveTypeE.Double;
            else if (type == typeofInt16Array)
                typeInformation = InternalPrimitiveTypeE.Int16;
            else if (type == typeofInt32Array)
                typeInformation = InternalPrimitiveTypeE.Int32;
            else if (type == typeofInt64Array)
                typeInformation = InternalPrimitiveTypeE.Int64;
            else if (type == typeofSByteArray)
                typeInformation = InternalPrimitiveTypeE.SByte;
            else if (type == typeofSingleArray)
                typeInformation = InternalPrimitiveTypeE.Single;
            else if (type == typeofUInt16Array)
                typeInformation = InternalPrimitiveTypeE.UInt16;
            else if (type == typeofUInt32Array)
                typeInformation = InternalPrimitiveTypeE.UInt32;
            else if (type == typeofUInt64Array)
                typeInformation = InternalPrimitiveTypeE.UInt64;
            else
                bIsPrimitive = false;
            return bIsPrimitive;
        }


        private static String[] valueA;

        private static void InitValueA()
        {
            String[] valueATemp = new String[primitiveTypeEnumLength];
            valueATemp[(int)InternalPrimitiveTypeE.Invalid] = null;
            valueATemp[(int)InternalPrimitiveTypeE.Boolean] = "Boolean";
            valueATemp[(int)InternalPrimitiveTypeE.Byte] = "Byte";
            valueATemp[(int)InternalPrimitiveTypeE.Char] = "Char";
            valueATemp[(int)InternalPrimitiveTypeE.Decimal] = "Decimal";
            valueATemp[(int)InternalPrimitiveTypeE.Double] = "Double";
            valueATemp[(int)InternalPrimitiveTypeE.Int16] = "Int16";
            valueATemp[(int)InternalPrimitiveTypeE.Int32] = "Int32";
            valueATemp[(int)InternalPrimitiveTypeE.Int64] = "Int64";
            valueATemp[(int)InternalPrimitiveTypeE.SByte] = "SByte";
            valueATemp[(int)InternalPrimitiveTypeE.Single] = "Single";
            valueATemp[(int)InternalPrimitiveTypeE.TimeSpan] = "TimeSpan";
            valueATemp[(int)InternalPrimitiveTypeE.DateTime] = "DateTime";
            valueATemp[(int)InternalPrimitiveTypeE.UInt16] = "UInt16";
            valueATemp[(int)InternalPrimitiveTypeE.UInt32] = "UInt32";
            valueATemp[(int)InternalPrimitiveTypeE.UInt64] = "UInt64";
            valueA = valueATemp;
        }

        // Returns a String containg a COM+ runtime type associated with the type code

        internal static String ToComType(InternalPrimitiveTypeE code)
        {
            SerTrace.Log("Converter", "ToComType Entry ", ((Enum)code).ToString());

            if (valueA == null)
                InitValueA();

            SerTrace.Log("Converter", "ToComType Exit ",((valueA[(int)code] == null)?"null":valueA[(int)code]));                

            return valueA[(int)code];
        }

        private static TypeCode[] typeCodeA;

        private static void InitTypeCodeA()
        {
            TypeCode[] typeCodeATemp = new TypeCode[primitiveTypeEnumLength];
            typeCodeATemp[(int)InternalPrimitiveTypeE.Invalid] = TypeCode.Object;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Boolean] = TypeCode.Boolean;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Byte] = TypeCode.Byte;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Char] = TypeCode.Char;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Decimal] = TypeCode.Decimal;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Double] = TypeCode.Double;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Int16] = TypeCode.Int16;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Int32] = TypeCode.Int32;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Int64] = TypeCode.Int64;
            typeCodeATemp[(int)InternalPrimitiveTypeE.SByte] = TypeCode.SByte;
            typeCodeATemp[(int)InternalPrimitiveTypeE.Single] = TypeCode.Single;
            typeCodeATemp[(int)InternalPrimitiveTypeE.TimeSpan] = TypeCode.Object;
            typeCodeATemp[(int)InternalPrimitiveTypeE.DateTime] = TypeCode.DateTime;
            typeCodeATemp[(int)InternalPrimitiveTypeE.UInt16] = TypeCode.UInt16;
            typeCodeATemp[(int)InternalPrimitiveTypeE.UInt32] = TypeCode.UInt32;
            typeCodeATemp[(int)InternalPrimitiveTypeE.UInt64] = TypeCode.UInt64;
			typeCodeA = typeCodeATemp;
        }

        // Returns a System.TypeCode from a InternalPrimitiveTypeE
        internal static TypeCode ToTypeCode(InternalPrimitiveTypeE code)
        {
            if (typeCodeA == null)
                InitTypeCodeA();
            return typeCodeA[(int)code];
        }


        private static InternalPrimitiveTypeE[] codeA;

        private static void InitCodeA()
        {
            InternalPrimitiveTypeE[] codeATemp = new InternalPrimitiveTypeE[19];
            codeATemp[(int)TypeCode.Empty] = InternalPrimitiveTypeE.Invalid;
            codeATemp[(int)TypeCode.Object] = InternalPrimitiveTypeE.Invalid;
            codeATemp[(int)TypeCode.DBNull] = InternalPrimitiveTypeE.Invalid;                   
            codeATemp[(int)TypeCode.Boolean] = InternalPrimitiveTypeE.Boolean;
            codeATemp[(int)TypeCode.Char] = InternalPrimitiveTypeE.Char;
            codeATemp[(int)TypeCode.SByte] = InternalPrimitiveTypeE.SByte;
            codeATemp[(int)TypeCode.Byte] = InternalPrimitiveTypeE.Byte;
            codeATemp[(int)TypeCode.Int16] = InternalPrimitiveTypeE.Int16;
            codeATemp[(int)TypeCode.UInt16] = InternalPrimitiveTypeE.UInt16;
            codeATemp[(int)TypeCode.Int32] = InternalPrimitiveTypeE.Int32;
            codeATemp[(int)TypeCode.UInt32] = InternalPrimitiveTypeE.UInt32;
            codeATemp[(int)TypeCode.Int64] = InternalPrimitiveTypeE.Int64;
            codeATemp[(int)TypeCode.UInt64] = InternalPrimitiveTypeE.UInt64;
            codeATemp[(int)TypeCode.Single] = InternalPrimitiveTypeE.Single;
            codeATemp[(int)TypeCode.Double] = InternalPrimitiveTypeE.Double;
            codeATemp[(int)TypeCode.Decimal] = InternalPrimitiveTypeE.Decimal;
            codeATemp[(int)TypeCode.DateTime] = InternalPrimitiveTypeE.DateTime;
            codeATemp[17] = InternalPrimitiveTypeE.Invalid;
            codeATemp[(int)TypeCode.String] = InternalPrimitiveTypeE.Invalid;  
			codeA = codeATemp;                                     
        }

        // Returns a InternalPrimitiveTypeE from a System.TypeCode
        internal static InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode)
        {
            if (codeA == null)
                InitCodeA();
            return codeA[(int)typeCode];
        }

        // Translates a string into an Object
        internal static Object FromString(String value, InternalPrimitiveTypeE code)
        {
            Object var;
            SerTrace.Log( "Converter", "FromString Entry ",value," " , ((Enum)code).ToString());                
            // InternalPrimitiveTypeE needs to be a primitive type
            BCLDebug.Assert((code != InternalPrimitiveTypeE.Invalid), "[Converter.FromString]!InternalPrimitiveTypeE.Invalid ");
            if (code != InternalPrimitiveTypeE.Invalid)
                var = Convert.ChangeType(value, ToTypeCode(code), CultureInfo.InvariantCulture);
            else
                var = value;
            SerTrace.Log( "Converter", "FromString Exit "+((var == null)?"null":var+" var type "+((var==null)?"<null>":var.GetType().ToString())));
            return var;
        }

        internal static Type typeofISerializable = typeof(ISerializable);
        internal static Type typeofString = typeof(String);
        internal static Type typeofConverter = typeof(Converter);
        internal static Type typeofBoolean = typeof(Boolean);
        internal static Type typeofByte = typeof(Byte);
        internal static Type typeofChar = typeof(Char);
        internal static Type typeofDecimal = typeof(Decimal);
        internal static Type typeofDouble = typeof(Double);
        internal static Type typeofInt16 = typeof(Int16);
        internal static Type typeofInt32 = typeof(Int32);
        internal static Type typeofInt64 = typeof(Int64);
        internal static Type typeofSByte = typeof(SByte);
        internal static Type typeofSingle = typeof(Single);
        internal static Type typeofTimeSpan = typeof(TimeSpan);
        internal static Type typeofDateTime = typeof(DateTime);
        internal static Type typeofUInt16 = typeof(UInt16);
        internal static Type typeofUInt32 = typeof(UInt32);
        internal static Type typeofUInt64 = typeof(UInt64);
        internal static Type typeofObject = typeof(Object);

        internal static Type typeofSystemVoid = typeof(void);
        internal static Assembly urtAssembly = Assembly.GetAssembly(typeofString);
        internal static String urtAssemblyString = urtAssembly.FullName;

        // Arrays
        internal static Type typeofTypeArray = typeof(System.Type[]);
        internal static Type typeofObjectArray = typeof(System.Object[]);
        internal static Type typeofStringArray = typeof(System.String[]);
        internal static Type typeofBooleanArray = typeof(Boolean[]);
        internal static Type typeofByteArray = typeof(Byte[]);
        internal static Type typeofCharArray = typeof(Char[]);
        internal static Type typeofDecimalArray = typeof(Decimal[]);
        internal static Type typeofDoubleArray = typeof(Double[]);
        internal static Type typeofInt16Array = typeof(Int16[]);
        internal static Type typeofInt32Array = typeof(Int32[]);
        internal static Type typeofInt64Array = typeof(Int64[]);
        internal static Type typeofSByteArray = typeof(SByte[]);
        internal static Type typeofSingleArray = typeof(Single[]);
        internal static Type typeofTimeSpanArray = typeof(TimeSpan[]);
        internal static Type typeofDateTimeArray = typeof(DateTime[]);
        internal static Type typeofUInt16Array = typeof(UInt16[]);
        internal static Type typeofUInt32Array = typeof(UInt32[]);
        internal static Type typeofUInt64Array = typeof(UInt64[]);
        internal static Type typeofMarshalByRefObject = typeof(System.MarshalByRefObject);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryformatterwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: BinaryWriter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Writes primitive values to a stream
 **
 ** Date:  July 11, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Binary {

	using System;
	using System.Collections;
	using System.IO;
	using System.Reflection;
	using System.Text;
    using System.Globalization;
	using System.Runtime.Serialization.Formatters;
	using System.Configuration.Assemblies;
	using System.Threading;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;	

	internal sealed class __BinaryWriter
	{
		internal Stream sout;
		internal FormatterTypeStyle formatterTypeStyle;
		internal Hashtable objectMapTable;
		internal ObjectWriter objectWriter = null;
		internal BinaryWriter dataWriter = null;

		internal int m_nestedObjectCount;
        private int nullCount = 0; //Count of consecutive array nulls 

		// Constructor
		internal __BinaryWriter(Stream sout, ObjectWriter objectWriter, FormatterTypeStyle formatterTypeStyle)
		{
			SerTrace.Log( this, "BinaryWriter ");		
			this.sout = sout;
			this.formatterTypeStyle = formatterTypeStyle;
            this.objectWriter = objectWriter;
			m_nestedObjectCount = 0;
			dataWriter = new BinaryWriter(sout, Encoding.UTF8);
		}

		internal void WriteBegin()
		{
			BCLDebug.Trace("BINARY", "\n%%%%%BinaryWriterBegin%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
		}

		internal void WriteEnd()
		{
			BCLDebug.Trace("BINARY", "\n%%%%%BinaryWriterEnd%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");			
			dataWriter.Flush();
		}

		// Methods to write a value onto the stream
		internal void WriteBoolean(Boolean value)
		{
			dataWriter.Write(value);
		}

		internal void WriteByte(Byte value)
		{
			dataWriter.Write(value);
		}

		private void WriteBytes(Byte[] value)
		{
			dataWriter.Write(value);			
		}

		private void WriteBytes(byte[] byteA, int offset, int size)
		{
			dataWriter.Write(byteA, offset, size);
		}

		internal void WriteChar(Char value)
		{
			dataWriter.Write(value);			
		}

		internal void WriteChars(Char[] value)
		{
			dataWriter.Write(value);			
		}

		
		internal void WriteDecimal(Decimal value)
		{
			WriteString(value.ToString(CultureInfo.InvariantCulture));
		}

		internal void WriteSingle(Single value)
		{
			dataWriter.Write(value);
		}	

		internal void WriteDouble(Double value)
		{
			dataWriter.Write(value);			
		}

		internal void WriteInt16(Int16 value)
		{
			dataWriter.Write(value);			
		}

		internal void WriteInt32(Int32 value)
		{
			dataWriter.Write(value);			
		}

		internal void WriteInt64(Int64 value)
		{
			dataWriter.Write(value);			
		}

		[CLSCompliant(false)]
		internal void WriteSByte(SByte value)
		{
			WriteByte((Byte)value);
		}

		internal void WriteString(String value)
		{
			dataWriter.Write(value);
		}

		internal void WriteTimeSpan(TimeSpan value)
		{
			WriteInt64(value.Ticks);
		}

		internal void WriteDateTime(DateTime value)
		{
			WriteInt64(value.Ticks);
		}

		[CLSCompliant(false)]
		internal void WriteUInt16(UInt16 value)
		{
			dataWriter.Write(value);
		}

		[CLSCompliant(false)]
		internal void WriteUInt32(UInt32 value)
		{
			dataWriter.Write(value);
		}

		[CLSCompliant(false)]
		internal void WriteUInt64(UInt64 value)
		{
			dataWriter.Write(value);
		}

		internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo)
		{
		}

		internal void WriteSerializationHeaderEnd()
		{
			MessageEnd record = new MessageEnd();
			record.Dump(sout);
			record.Write(this);		
		}

		// Methods to write Binary Serialization Record onto the stream, a record is composed of primitive types

		internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion)
		{
			SerializationHeaderRecord record = new SerializationHeaderRecord(BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion);
			record.Dump();
			record.Write(this);
		}


        internal BinaryMethodCall binaryMethodCall;
        internal void WriteMethodCall()
        {
            if (binaryMethodCall == null)
                binaryMethodCall = new BinaryMethodCall();

            binaryMethodCall.Dump();
            binaryMethodCall.Write(this);
        }

        internal Object[] WriteCallArray(String uri, String methodName, String typeName, Object[] args, Object methodSignature, Object callContext, Object[] properties)
        {
            if (binaryMethodCall == null)
                binaryMethodCall = new BinaryMethodCall();
            return binaryMethodCall.WriteArray(uri, methodName, typeName, args, methodSignature, callContext, properties);
        }

        internal BinaryMethodReturn binaryMethodReturn;
        internal void WriteMethodReturn()
        {
            if (binaryMethodReturn == null)
                binaryMethodReturn = new BinaryMethodReturn();
            binaryMethodReturn.Dump();
            binaryMethodReturn.Write(this);
        }

        internal Object[] WriteReturnArray(Object returnValue, Object[] args, Exception exception, Object callContext, Object[] properties)
        {
            if (binaryMethodReturn == null)
                binaryMethodReturn = new BinaryMethodReturn();
            return binaryMethodReturn.WriteArray(returnValue, args, exception, callContext, properties);
        }

		internal BinaryObject binaryObject;
		internal BinaryObjectWithMap binaryObjectWithMap;
		internal BinaryObjectWithMapTyped binaryObjectWithMapTyped;
        //internal BinaryCrossAppDomainMap crossAppDomainMap;

		internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, String[] memberNames, Type[] memberTypes, WriteObjectInfo[] memberObjectInfos)
		{
            InternalWriteItemNull();
			int assemId;
			nameInfo.Dump("WriteObject nameInfo");
			typeNameInfo.Dump("WriteObject typeNameInfo");									

			int objectId = (int)nameInfo.NIobjectId;

			//if (objectId < 0)
			//	objectId = --m_nestedObjectCount;

			if (objectId > 0)
			{
				BCLDebug.Trace("BINARY", "-----Top Level Object-----");			
			}

			String objectName = null;
			if (objectId < 0)
			{
				// Nested Object
				objectName = typeNameInfo.NIname;
			}
			else
			{
				// Non-Nested
				objectName = nameInfo.NIname;
			}
			SerTrace.Log( this, "WriteObject objectName ",objectName);

            if (objectMapTable == null)
                objectMapTable = new Hashtable();

			ObjectMapInfo objectMapInfo = (ObjectMapInfo)objectMapTable[objectName];

             if (objectMapInfo != null && objectMapInfo.isCompatible(numMembers, memberNames, memberTypes))
			{
				// Object
				if (binaryObject == null)
					binaryObject = new BinaryObject();			
				binaryObject.Set(objectId, objectMapInfo.objectId);
				binaryObject.Dump();
				binaryObject.Write(this);
			}
			else if (!typeNameInfo.NItransmitTypeOnObject)
			{

                /*
                if (objectWriter.IsCrossAppDomain())
                {
                    if (crossAppDomainMap == null)
                        crossAppDomainMap = new BinaryCrossAppDomainMap();
                    BinaryObjectWithMap cbinaryObjectWithMap = new BinaryObjectWithMap();

                    // BCL types are not placed into table
                    assemId = (int)typeNameInfo.NIassemId;
                    cbinaryObjectWithMap.Set(objectId, objectName, numMembers, memberNames, assemId);
                    crossAppDomainMap.crossAppDomainArrayIndex = objectWriter.CrossAppDomainArrayAdd(cbinaryObjectWithMap);
                    crossAppDomainMap.Dump();
                    cbinaryObjectWithMap.Dump();
                    crossAppDomainMap.Write(this);
                }
                else
                {
                */
                    // ObjectWithMap
                    if (binaryObjectWithMap == null)
                        binaryObjectWithMap = new BinaryObjectWithMap();

                    // BCL types are not placed into table
                    assemId = (int)typeNameInfo.NIassemId;
                    binaryObjectWithMap.Set(objectId, objectName, numMembers, memberNames, assemId);

                    binaryObjectWithMap.Dump();
                    binaryObjectWithMap.Write(this);
                    if (objectMapInfo == null)
                        objectMapTable.Add(objectName, new ObjectMapInfo(objectId, numMembers, memberNames, memberTypes));
                //}
			}
			else
			{
				// ObjectWithMapTyped
				BinaryTypeEnum[] binaryTypeEnumA = new BinaryTypeEnum[numMembers];
				Object[] typeInformationA = new Object[numMembers];
				int[] assemIdA = new int[numMembers];
				for (int i=0; i<numMembers; i++)
				{
					Object typeInformation = null;

					binaryTypeEnumA[i] = BinaryConverter.GetBinaryTypeInfo(memberTypes[i], memberObjectInfos[i], null, objectWriter, out typeInformation, out assemId);
					typeInformationA[i] = typeInformation;
					assemIdA[i] = assemId;
					SerTrace.Log( this, "WriteObject ObjectWithMapTyped memberNames "
								 ,memberNames[i],", memberType ",memberTypes[i]," binaryTypeEnum ",((Enum)binaryTypeEnumA[i]).ToString()
								 ,", typeInformation ",typeInformationA[i]," assemId ",assemIdA[i]);
				}

/*
                if (objectWriter.IsCrossAppDomain())
                {
                    if (crossAppDomainMap == null)
                        crossAppDomainMap = new BinaryCrossAppDomainMap();

                     BinaryObjectWithMapTyped cbinaryObjectWithMapTyped = new BinaryObjectWithMapTyped();			

                    // BCL types are not placed in table
                    assemId = (int)typeNameInfo.NIassemId;				
                    cbinaryObjectWithMapTyped.Set(objectId, objectName, numMembers,memberNames, binaryTypeEnumA, typeInformationA, assemIdA, assemId);
                    crossAppDomainMap.crossAppDomainArrayIndex = objectWriter.CrossAppDomainArrayAdd(cbinaryObjectWithMapTyped);
                    crossAppDomainMap.Dump();
                    cbinaryObjectWithMapTyped.Dump();
                    crossAppDomainMap.Write(this);
                }
                else
                {
                */
                    if (binaryObjectWithMapTyped == null)
                        binaryObjectWithMapTyped = new BinaryObjectWithMapTyped();			

                    // BCL types are not placed in table
                    assemId = (int)typeNameInfo.NIassemId;				
                    binaryObjectWithMapTyped.Set(objectId, objectName, numMembers,memberNames, binaryTypeEnumA, typeInformationA, assemIdA, assemId);

                    binaryObjectWithMapTyped.Dump();
                    binaryObjectWithMapTyped.Write(this);
                    if (objectMapInfo == null)
                        objectMapTable.Add(objectName, new ObjectMapInfo(objectId, numMembers, memberNames, memberTypes));				
                //}
			}
		}

		internal BinaryObjectString binaryObjectString;
		internal BinaryCrossAppDomainString binaryCrossAppDomainString;

		internal void WriteObjectString(int objectId, String value)
		{
            InternalWriteItemNull();

            if (objectWriter.IsCrossAppDomain())
            {
                if (binaryCrossAppDomainString == null)
                    binaryCrossAppDomainString = new BinaryCrossAppDomainString();			
                binaryCrossAppDomainString.Set(objectId, objectWriter.CrossAppDomainArrayAdd(value));
                binaryCrossAppDomainString.Dump();
                binaryCrossAppDomainString.Write(this);

            }
            else
            {
                if (binaryObjectString == null)
                    binaryObjectString = new BinaryObjectString();			
                binaryObjectString.Set(objectId, value);
                binaryObjectString.Dump();
                binaryObjectString.Write(this);
            }
		}

		internal BinaryArray binaryArray;

		internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array)
		{
            InternalWriteItemNull();
			arrayNameInfo.Dump("WriteSingleArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteSingleArray arrayElemTypeNameInfo");

			BinaryArrayTypeEnum binaryArrayTypeEnum;
			Int32[] lengthA = new Int32[1];
			lengthA[0] = length;			
			Int32[] lowerBoundA = null;
			Object typeInformation = null;

			if (lowerBound == 0)
			{
				binaryArrayTypeEnum = BinaryArrayTypeEnum.Single;
			}
			else
			{
				binaryArrayTypeEnum = BinaryArrayTypeEnum.SingleOffset;
				lowerBoundA = new Int32[1];
				lowerBoundA[0] = lowerBound;
			}
			
			int assemId;
			
			BinaryTypeEnum binaryTypeEnum = BinaryConverter.GetBinaryTypeInfo(arrayElemTypeNameInfo.NItype, objectInfo, arrayElemTypeNameInfo.NIname, objectWriter, out typeInformation, out assemId);			

			if (binaryArray == null)
				binaryArray = new BinaryArray();			
			binaryArray.Set((int)arrayNameInfo.NIobjectId, (int)1, lengthA, lowerBoundA, binaryTypeEnum, typeInformation, binaryArrayTypeEnum, assemId);

			if (arrayNameInfo.NIobjectId >0)
			{
				BCLDebug.Trace("BINARY", "-----Top Level Object-----");			
			}
			binaryArray.Dump();

			binaryArray.Write(this);

			if (Converter.IsWriteAsByteArray(arrayElemTypeNameInfo.NIprimitiveTypeEnum) && (lowerBound == 0))
			{
				//array is written out as an array of bytes
				if (arrayElemTypeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Byte)
					WriteBytes((Byte[])array);
				else if (arrayElemTypeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Char)
					WriteChars((char[])array);
				else
					WriteArrayAsBytes(array, Converter.TypeLength(arrayElemTypeNameInfo.NIprimitiveTypeEnum));
			}
		}

		byte[] byteBuffer = null;
		int chunkSize = 4096;

		private void WriteArrayAsBytes(Array array, int typeLength)
		{
            InternalWriteItemNull();
			int byteLength = array.Length*typeLength;
			int arrayOffset = 0;
			if (byteBuffer == null)
				byteBuffer = new byte[chunkSize];

			while(arrayOffset < array.Length)
			{
				int numArrayItems = Math.Min(chunkSize/typeLength, array.Length-arrayOffset);
				int bufferUsed = numArrayItems*typeLength;
				Buffer.InternalBlockCopy(array, arrayOffset*typeLength, byteBuffer, 0, bufferUsed);
				WriteBytes(byteBuffer, 0, bufferUsed);
				arrayOffset += numArrayItems;
			}
		}
		

		internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound)
		{
			arrayNameInfo.Dump("WriteRectangleArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteRectangleArray arrayElemTypeNameInfo");
            InternalWriteItemNull();
			BinaryArrayTypeEnum binaryArrayTypeEnum;
			Int32[] lengthA = new Int32[1];
			lengthA[0] = length;			
			Int32[] lowerBoundA = null;
			Object typeInformation = null;
			int assemId = 0;

			if (lowerBound == 0)
			{
				binaryArrayTypeEnum = BinaryArrayTypeEnum.Jagged;
			}
			else
			{
				binaryArrayTypeEnum = BinaryArrayTypeEnum.JaggedOffset;
				lowerBoundA = new Int32[1];
				lowerBoundA[0] = lowerBound;				
			}

			BinaryTypeEnum binaryTypeEnum = BinaryConverter.GetBinaryTypeInfo(arrayElemTypeNameInfo.NItype, objectInfo, arrayElemTypeNameInfo.NIname, objectWriter, out typeInformation, out assemId);						

			if (binaryArray == null)
				binaryArray = new BinaryArray();			
			binaryArray.Set((int)arrayNameInfo.NIobjectId, (int)1, lengthA, lowerBoundA, binaryTypeEnum, typeInformation, binaryArrayTypeEnum, assemId);

			if (arrayNameInfo.NIobjectId >0)
			{
				BCLDebug.Trace("BINARY", "-----Top Level Object-----");			
			}
			binaryArray.Dump();

			binaryArray.Write(this);
		}

		internal void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, int[] lengthA, int[] lowerBoundA)
		{
			arrayNameInfo.Dump("WriteRectangleArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteRectangleArray arrayElemTypeNameInfo");			
            InternalWriteItemNull();

			BinaryArrayTypeEnum binaryArrayTypeEnum = BinaryArrayTypeEnum.Rectangular;			
			Object typeInformation = null;
			int assemId = 0;
			BinaryTypeEnum binaryTypeEnum = BinaryConverter.GetBinaryTypeInfo(arrayElemTypeNameInfo.NItype, objectInfo, arrayElemTypeNameInfo.NIname, objectWriter, out typeInformation, out assemId);									

			if (binaryArray == null)
				binaryArray = new BinaryArray();

			for (int i=0; i<rank; i++)
			{
				if (lowerBoundA[i] != 0)
				{
					binaryArrayTypeEnum = BinaryArrayTypeEnum.RectangularOffset;
					break;
				}

			}

			binaryArray.Set((int)arrayNameInfo.NIobjectId, rank, lengthA, lowerBoundA, binaryTypeEnum, typeInformation, binaryArrayTypeEnum, assemId);

			if (arrayNameInfo.NIobjectId >0)
			{
				BCLDebug.Trace("BINARY", "-----Top Level Object-----");				
			}
			binaryArray.Dump();

			binaryArray.Write(this);
		}


		internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Byte[] byteA)						
		{
			arrayNameInfo.Dump("WriteObjectByteArray arrayNameInfo");
			arrayElemTypeNameInfo.Dump("WriteObjectByteArray arrayElemTypeNameInfo");
            InternalWriteItemNull();
			WriteSingleArray(memberNameInfo, arrayNameInfo, objectInfo, arrayElemTypeNameInfo, length, lowerBound, byteA);
		}

		internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
		internal MemberPrimitiveTyped memberPrimitiveTyped;

		internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, Object value)
		{
			SerTrace.Log("BinaryWriter", "Write Member memberName ",memberNameInfo.NIname,", value ",value);
			memberNameInfo.Dump("WriteMember memberNameInfo");
			typeNameInfo.Dump("WriteMember typeNameInfo");
            InternalWriteItemNull();
            InternalPrimitiveTypeE typeInformation = typeNameInfo.NIprimitiveTypeEnum;

			// Writes Members with primitive values

			if (memberNameInfo.NItransmitTypeOnMember)
			{
				if (memberPrimitiveTyped == null)
					memberPrimitiveTyped = new MemberPrimitiveTyped();			
				memberPrimitiveTyped.Set((InternalPrimitiveTypeE)typeInformation, value);

				if (memberNameInfo.NIisArrayItem)
				{
					BCLDebug.Trace("BINARY",  "-----item-----");				
				}
				else
				{
					BCLDebug.Trace("BINARY","-----",memberNameInfo.NIname,"-----");					
				}
				memberPrimitiveTyped.Dump();

				memberPrimitiveTyped.Write(this);
			}
			else
			{
				if (memberPrimitiveUnTyped == null)
					memberPrimitiveUnTyped = new MemberPrimitiveUnTyped();			
				memberPrimitiveUnTyped.Set(typeInformation, value);

				if (memberNameInfo.NIisArrayItem)
				{
					BCLDebug.Trace("BINARY", "-----item-----");				
				}
				else
				{
					BCLDebug.Trace("BINARY", "-----",memberNameInfo.NIname,"-----");				
				}
				memberPrimitiveUnTyped.Dump();

				memberPrimitiveUnTyped.Write(this);

			}
		}

		internal ObjectNull objectNull;


		internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo)
		{
			typeNameInfo.Dump("WriteNullMember typeNameInfo");
            InternalWriteItemNull();
			if (objectNull == null)
				objectNull = new ObjectNull();			

			if (memberNameInfo.NIisArrayItem)
			{
				BCLDebug.Trace("BINARY",  "-----item-----");
			}
			else
			{
                objectNull.SetNullCount(1);
				BCLDebug.Trace("BINARY", "-----",memberNameInfo.NIname,"-----");			
                objectNull.Dump();
                objectNull.Write(this);
                nullCount = 0;
            }
		}

		internal MemberReference memberReference;

		internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef)
		{
            InternalWriteItemNull();
			if (memberReference == null)
				memberReference = new MemberReference();			
			memberReference.Set(idRef);

			if (memberNameInfo.NIisArrayItem)
			{
				BCLDebug.Trace("BINARY", "-----item-----");
			}
			else
			{
				BCLDebug.Trace("BINARY", "-----",memberNameInfo.NIname,"-----");
			}
			memberReference.Dump();

			memberReference.Write(this);
		}

		internal void WriteMemberNested(NameInfo memberNameInfo)
		{
            InternalWriteItemNull();
			if (memberNameInfo.NIisArrayItem)
			{
				BCLDebug.Trace("BINARY", "-----item-----");	  
			}
			else
			{
				BCLDebug.Trace("BINARY", "-----",memberNameInfo.NIname,"-----");
			}
		}

		internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, String value)
		{
            InternalWriteItemNull();
			if (memberNameInfo.NIisArrayItem)
			{
				BCLDebug.Trace("BINARY", "-----item-----");								
			}
			else
			{
				BCLDebug.Trace("BINARY", "-----",memberNameInfo.NIname,"-----");
			}
			WriteObjectString((int)typeNameInfo.NIobjectId, value);					
		}

		internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, Object value)
		{
            InternalWriteItemNull();
			WriteMember(itemNameInfo, typeNameInfo, value);
		}

		internal void WriteNullItem(NameInfo itemNameInfo, NameInfo typeNameInfo)
        {
           nullCount++;
           InternalWriteItemNull();
        }

		internal void WriteDelayedNullItem()
		{
            nullCount++;
		}

        internal void WriteItemEnd()
        {
            InternalWriteItemNull();
        }

        private void InternalWriteItemNull()
        {
            if (nullCount > 0)
            {
                if (objectNull == null)
                    objectNull = new ObjectNull();
                objectNull.SetNullCount(nullCount);
                BCLDebug.Trace("BINARY",  "-----item-----");
                objectNull.Dump();
                objectNull.Write(this);
                nullCount = 0;
            }
        }

		internal void WriteItemObjectRef(NameInfo nameInfo, int idRef)
		{
            InternalWriteItemNull();
			WriteMemberObjectRef(nameInfo, idRef);
		}


		internal BinaryAssembly binaryAssembly;
        internal BinaryCrossAppDomainAssembly crossAppDomainAssembly;

		internal void WriteAssembly(String typeFullName, Type type, String assemblyString, int assemId, bool isNew, bool isInteropType)
		{
			SerTrace.Log( this,"WriteAssembly type ",type,", id ",assemId,", name ", assemblyString,", isNew ",isNew);
			//If the file being tested wasn't built as an assembly, then we're going to get null back
			//for the assembly name.  This is very unfortunate.
            InternalWriteItemNull();
			if (assemblyString==null)
			{
				assemblyString=String.Empty;
			}

			if (isNew)
			{
                if (objectWriter.IsCrossAppDomain())
                {
                    if (crossAppDomainAssembly == null)
                        crossAppDomainAssembly = new BinaryCrossAppDomainAssembly();
                    crossAppDomainAssembly.Set(assemId, objectWriter.CrossAppDomainArrayAdd(assemblyString));
                    crossAppDomainAssembly.Dump();
                    crossAppDomainAssembly.Write(this);

                }
                else
                {
                    if (binaryAssembly == null)
                        binaryAssembly = new BinaryAssembly();
                    binaryAssembly.Set(assemId, assemblyString);
                    binaryAssembly.Dump();
                    binaryAssembly.Write(this);
                }
			}
		}

		// Method to write a value onto a stream given its primitive type code
		internal void WriteValue(InternalPrimitiveTypeE code, Object value)
		{
			SerTrace.Log( this, "WriteValue Entry ",((Enum)code).ToString()," " , ((value==null)?"<null>":value.GetType().ToString()) , " ",value);

			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					WriteBoolean(Convert.ToBoolean(value));
					break;
				case InternalPrimitiveTypeE.Byte:
					WriteByte(Convert.ToByte(value));
					break;
				case InternalPrimitiveTypeE.Char:
					WriteChar(Convert.ToChar(value));			
					break;
				case InternalPrimitiveTypeE.Double:
					WriteDouble(Convert.ToDouble(value));
					break;
				case InternalPrimitiveTypeE.Int16:
					WriteInt16(Convert.ToInt16(value));
					break;
				case InternalPrimitiveTypeE.Int32:
					WriteInt32(Convert.ToInt32(value));
					break;
				case InternalPrimitiveTypeE.Int64:
					WriteInt64(Convert.ToInt64(value));			
					break;
				case InternalPrimitiveTypeE.SByte:
					WriteSByte(Convert.ToSByte(value));
					break;
				case InternalPrimitiveTypeE.Single:
					WriteSingle(Convert.ToSingle(value));			
					break;
				case InternalPrimitiveTypeE.UInt16:
					WriteUInt16(Convert.ToUInt16(value));						
					break;
				case InternalPrimitiveTypeE.UInt32:
					WriteUInt32(Convert.ToUInt32(value));									
					break;
				case InternalPrimitiveTypeE.UInt64:
					WriteUInt64(Convert.ToUInt64(value));												
					break;
				case InternalPrimitiveTypeE.Decimal:
					WriteDecimal(Convert.ToDecimal(value));					
					break;
				case InternalPrimitiveTypeE.TimeSpan:
					WriteTimeSpan((TimeSpan)value);										
					break;
				case InternalPrimitiveTypeE.DateTime:
					WriteDateTime((DateTime)value);															
					break;
				default:
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeCode"),((Enum)code).ToString()));
			}
			SerTrace.Log( this, "Write Exit ");
		}
	}

	internal sealed class ObjectMapInfo
	{
		internal int objectId;
		int numMembers;
		String[] memberNames;
		Type[] memberTypes;
		
		internal ObjectMapInfo(int objectId, int numMembers, String[] memberNames, Type[] memberTypes)
		{
			this.objectId = objectId;
			this.numMembers = numMembers;
			this.memberNames = memberNames;
			this.memberTypes = memberTypes;
		}

		internal bool isCompatible(int numMembers, String[] memberNames, Type[] memberTypes)
		{
			bool result = true;
			if (this.numMembers == numMembers)
			{
				for (int i=0; i<numMembers; i++)
				{
					if (!(this.memberNames[i].Equals(memberNames[i])))
					{
						  result = false;
						  break;
					}
					if ((memberTypes != null) && (this.memberTypes[i] != memberTypes[i]))
					{
						result = false;
						break;
					}
				}
			}
			else
				result = false;
			return result;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: BinaryFormatter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Soap XML Formatter
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Binary {
    
	using System;
	using System.IO;
	using System.Reflection;
	using System.Globalization;
	using System.Collections;
	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
	using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter"]/*' />
    sealed public class BinaryFormatter : IRemotingFormatter
    {
    
    	internal ISurrogateSelector m_surrogates;
    	internal StreamingContext m_context;
        internal SerializationBinder m_binder;
    	//internal FormatterTypeStyle m_typeFormat = FormatterTypeStyle.TypesWhenNeeded;
        internal FormatterTypeStyle m_typeFormat = FormatterTypeStyle.TypesAlways; // For version resiliency, always put out types
		internal FormatterAssemblyStyle m_assemblyFormat = FormatterAssemblyStyle.Full;
        internal TypeFilterLevel m_securityLevel = TypeFilterLevel.Full;
        internal Object[] m_crossAppDomainArray = null;

    	// Property which specifies how types are serialized,
    	// FormatterTypeStyle Enum specifies options
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.TypeFormat"]/*' />
    	public FormatterTypeStyle TypeFormat
    	{
    		get {return m_typeFormat;}
    		set {m_typeFormat = value;}
    	}

    	// Property which specifies how types are serialized,
    	// FormatterAssemblyStyle Enum specifies options
		/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.AssemblyFormat"]/*' />
		public FormatterAssemblyStyle AssemblyFormat
		{
			get {return m_assemblyFormat;}
			set {m_assemblyFormat = value;}
		}	
		
    
    	// Property which specifies the security level of formatter
    	// TypeFilterLevel Enum specifies options
		/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.FilterLevel"]/*' />
        [System.Runtime.InteropServices.ComVisible(false)]
		public TypeFilterLevel FilterLevel
		{
			get {return m_securityLevel;}
			set {m_securityLevel = value;}
		}	
		
        /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.SurrogateSelector"]/*' />
        public ISurrogateSelector SurrogateSelector {
            get { return m_surrogates;  }
            set { m_surrogates = value; }
        }

        /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Binder"]/*' />
        public SerializationBinder Binder {
            get { return m_binder; }
            set { m_binder = value; } 
        }

        /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Context"]/*' />
        public StreamingContext Context {
            get { return m_context;  } 
            set { m_context = value; } 
        }

        // For a StreamingContext.CrossAppDomain 
        // After Serialization the Formatter will set to an array of all the interned objects which will be smuggled across the appdomain
        // The caller to Deserialization will set to the array of all interned objects.
        internal Object[] CrossAppDomainArray {
            get { return m_crossAppDomainArray;  } 
            set { m_crossAppDomainArray = value; } 
        }
    
    	// Constructor
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.BinaryFormatter"]/*' />
    	public BinaryFormatter()
    	{    
    		m_surrogates = null;
    		m_context = new StreamingContext(StreamingContextStates.All);
    	}
    
    	// Constructor
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.BinaryFormatter1"]/*' />
    	public BinaryFormatter(ISurrogateSelector selector, StreamingContext context) {   
    		m_surrogates = selector;
    		m_context = context;
    	}
    
    
    
    	// Deserialize the stream into an object graph.
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Deserialize"]/*' />
    	public Object Deserialize(Stream serializationStream)
    	{
    		return Deserialize(serializationStream, null);
    	}

    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Deserialize2"]/*' />
    	internal Object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck)
    	{
    		return Deserialize(serializationStream, null, fCheck, null);
    	}


    
    	// Deserialize the stream into an object graph.
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Deserialize1"]/*' />
    	public Object Deserialize(Stream serializationStream, HeaderHandler handler) {
            return Deserialize(serializationStream, handler, true, null);
        }
                         
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.DeserializeMethodResponse"]/*' />
    	public Object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage) {
            return Deserialize(serializationStream, handler, true, methodCallMessage);
        }

        [
        SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter),
        System.Runtime.InteropServices.ComVisible(false)
        ]
        /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.UnsafeDeserialize"]/*' />       
        public Object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler) {
            return Deserialize(serializationStream, handler, false, null);
        }
        
        [
        SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.SerializationFormatter),
        System.Runtime.InteropServices.ComVisible(false)
        ]
        /// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.UnsafeDeserializeMethodResponse"]/*' />       
        public Object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage) {
            return Deserialize(serializationStream, handler, false, methodCallMessage);
        }         

    	// Deserialize the stream into an object graph.
    	internal Object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, IMethodCallMessage methodCallMessage) {
            if (serializationStream==null) {
				throw new ArgumentNullException("serializationStream", String.Format(Environment.GetResourceString("ArgumentNull_WithParamName"),serializationStream));
            }

			if (serializationStream.CanSeek && (serializationStream.Length == 0))
				throw new SerializationException(Environment.GetResourceString("Serialization_Stream"));

    		SerTrace.Log(this, "Deserialize Entry");
    		InternalFE formatterEnums = new InternalFE();
    		formatterEnums.FEtypeFormat = m_typeFormat;
    		formatterEnums.FEserializerTypeEnum = InternalSerializerTypeE.Binary;
			formatterEnums.FEassemblyFormat = m_assemblyFormat;    		
			formatterEnums.FEsecurityLevel = m_securityLevel;    		
    		ObjectReader sor = new ObjectReader(serializationStream, m_surrogates, m_context, formatterEnums, m_binder);
            sor.crossAppDomainArray = m_crossAppDomainArray;
    		return sor.Deserialize(handler, new __BinaryParser(serializationStream, sor), fCheck, methodCallMessage);
    	}
    
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Serialize"]/*' />
    	public void Serialize(Stream serializationStream,Object graph)
    	{
    		Serialize(serializationStream, graph, null);
    	}
    
    	// Commences the process of serializing the entire graph.  All of the data (in the appropriate format
    	// is emitted onto the stream).
    	/// <include file='doc\BinaryFormatter.uex' path='docs/doc[@for="BinaryFormatter.Serialize1"]/*' />
    	public void Serialize(Stream serializationStream, Object graph, Header[] headers)
        {
            Serialize(serializationStream, graph, headers, true);
        }

    	// Commences the process of serializing the entire graph.  All of the data (in the appropriate format
    	// is emitted onto the stream).
    	internal void Serialize(Stream serializationStream, Object graph, Header[] headers, bool fCheck)
    	{
            if (serializationStream==null) {
				throw new ArgumentNullException("serializationStream", String.Format(Environment.GetResourceString("ArgumentNull_WithParamName"),serializationStream));				
            }
    		SerTrace.Log(this, "Serialize Entry");
    		
    		InternalFE formatterEnums = new InternalFE();
    		formatterEnums.FEtypeFormat = m_typeFormat;
    		formatterEnums.FEserializerTypeEnum = InternalSerializerTypeE.Binary;
			formatterEnums.FEassemblyFormat = m_assemblyFormat;    
    		ObjectWriter sow = new ObjectWriter(serializationStream, m_surrogates, m_context, formatterEnums);
    		__BinaryWriter binaryWriter = new __BinaryWriter(serializationStream, sow, m_typeFormat); 
    		sow.Serialize(graph, headers, binaryWriter, fCheck);
            m_crossAppDomainArray = sow.crossAppDomainArray;
    	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binarycommonclasses.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: CommonBinaryClasses
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: utility classes
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Binary{

    using System;
    using System.IO;
    using System.Runtime.Serialization.Formatters;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;
    using System.Runtime.Remoting.Messaging;

    // Routines to convert between the runtime type and the type as it appears on the wire
    internal sealed class BinaryConverter
    {

        // From the type create the BinaryTypeEnum and typeInformation which describes the type on the wire

        internal static BinaryTypeEnum GetBinaryTypeInfo(Type type, WriteObjectInfo objectInfo, String typeName, ObjectWriter objectWriter, out Object typeInformation, out int assemId)
        {
            SerTrace.Log("BinaryConverter", "GetBinaryTypeInfo Entry type ",type,", typeName ",typeName," objectInfo "+objectInfo);     
            BinaryTypeEnum binaryTypeEnum;

            assemId = 0;
            typeInformation = null;

            if (type == Converter.typeofString)
                binaryTypeEnum = BinaryTypeEnum.String;
            else if (((objectInfo == null) || ((objectInfo != null) && !objectInfo.isSi))
                     && (type == Converter.typeofObject))
            {
                // If objectInfo.Si then can be a surrogate which will change the type
                binaryTypeEnum = BinaryTypeEnum.Object;
            }
            else if (type == Converter.typeofStringArray)
                binaryTypeEnum = BinaryTypeEnum.StringArray;
            else if (type == Converter.typeofObjectArray)
                binaryTypeEnum = BinaryTypeEnum.ObjectArray;
            else if (Converter.IsPrimitiveArray(type, out typeInformation))
                binaryTypeEnum = BinaryTypeEnum.PrimitiveArray;
            else
            {
                InternalPrimitiveTypeE primitiveTypeEnum = objectWriter.ToCode(type);
                switch (primitiveTypeEnum)
                {
                    case InternalPrimitiveTypeE.Invalid:
                        String assembly = null;
                        if (objectInfo == null)
                        {
                            assembly = type.Module.Assembly.FullName;
                            typeInformation = type.FullName;
                        }
                        else
                        {
                            assembly = objectInfo.GetAssemblyString();
                            typeInformation = objectInfo.GetTypeFullName();
                        }

                        if (assembly.Equals(Converter.urtAssemblyString))
                        {
                            binaryTypeEnum = BinaryTypeEnum.ObjectUrt;
                            assemId = 0;
                        }
                        else
                        {
                            binaryTypeEnum = BinaryTypeEnum.ObjectUser;
                            BCLDebug.Assert(objectInfo!=null, "[BinaryConverter.GetBinaryTypeInfo]objectInfo null for user object");
                            assemId = (int)objectInfo.assemId;
                            if (assemId == 0)
                                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyId"),typeInformation));
                        }
                        break;
                    default:
                        binaryTypeEnum = BinaryTypeEnum.Primitive;
                        typeInformation = primitiveTypeEnum;
                        break;
                }
            }

            SerTrace.Log( "BinaryConverter", "GetBinaryTypeInfo Exit ",((Enum)binaryTypeEnum).ToString(),", typeInformation ",typeInformation," assemId ",assemId);             
            return binaryTypeEnum;
        }


        // Used for non Si types when Parsing
        internal static BinaryTypeEnum GetParserBinaryTypeInfo(Type type, out Object typeInformation)
        {
            SerTrace.Log("BinaryConverter", "GetParserBinaryTypeInfo Entry type ",type);        
            BinaryTypeEnum binaryTypeEnum;
            typeInformation = null;

            if (type == Converter.typeofString)
                binaryTypeEnum = BinaryTypeEnum.String;
            else if (type == Converter.typeofObject)
                binaryTypeEnum = BinaryTypeEnum.Object;
            else if (type == Converter.typeofObjectArray)
                binaryTypeEnum = BinaryTypeEnum.ObjectArray;
            else if (type == Converter.typeofStringArray)
                binaryTypeEnum = BinaryTypeEnum.StringArray;
            else if (Converter.IsPrimitiveArray(type, out typeInformation))
                binaryTypeEnum = BinaryTypeEnum.PrimitiveArray;
            else
            {
                InternalPrimitiveTypeE primitiveTypeEnum = Converter.ToCode(type);
                switch (primitiveTypeEnum)
                {
                    case InternalPrimitiveTypeE.Invalid:
                        if (Assembly.GetAssembly(type) == Converter.urtAssembly)
                            binaryTypeEnum = BinaryTypeEnum.ObjectUrt;
                        else
                            binaryTypeEnum = BinaryTypeEnum.ObjectUser;

                        typeInformation = type.FullName;
                        break;
                    default:
                        binaryTypeEnum = BinaryTypeEnum.Primitive;
                        typeInformation = primitiveTypeEnum;
                        break;
                }
            }

            SerTrace.Log( "BinaryConverter", "GetParserBinaryTypeInfo Exit ",((Enum)binaryTypeEnum).ToString(),", typeInformation ",typeInformation);               
            return binaryTypeEnum;
        }

        // Writes the type information on the wire
        internal static void WriteTypeInfo(BinaryTypeEnum binaryTypeEnum, Object typeInformation, int assemId, __BinaryWriter sout)
        {
            SerTrace.Log( "BinaryConverter", "WriteTypeInfo Entry  ",((Enum)binaryTypeEnum).ToString()," ",typeInformation," assemId ",assemId);

            switch (binaryTypeEnum)
            {
                case BinaryTypeEnum.Primitive:
                case BinaryTypeEnum.PrimitiveArray:
                    BCLDebug.Assert(typeInformation!=null, "[BinaryConverter.WriteTypeInfo]typeInformation!=null");
                    sout.WriteByte((Byte)((InternalPrimitiveTypeE)typeInformation));                    
                    break;
                case BinaryTypeEnum.String:
                case BinaryTypeEnum.Object:
                case BinaryTypeEnum.StringArray:
                case BinaryTypeEnum.ObjectArray:
                    break;                    
                case BinaryTypeEnum.ObjectUrt:
                    BCLDebug.Assert(typeInformation!=null, "[BinaryConverter.WriteTypeInfo]typeInformation!=null");
                    sout.WriteString(typeInformation.ToString());
                    break;
                case BinaryTypeEnum.ObjectUser:                             
                    BCLDebug.Assert(typeInformation!=null, "[BinaryConverter.WriteTypeInfo]typeInformation!=null");
                    sout.WriteString(typeInformation.ToString());
                    sout.WriteInt32(assemId);
                    break;                    
                default:
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeWrite"),((Enum)binaryTypeEnum).ToString()));
            }
            SerTrace.Log( "BinaryConverter", "WriteTypeInfo Exit");
        }

        // Reads the type information from the wire
        internal static Object ReadTypeInfo(BinaryTypeEnum binaryTypeEnum, __BinaryParser input, out int assemId)
        {
            SerTrace.Log( "BinaryConverter", "ReadTypeInfo Entry  ",((Enum)binaryTypeEnum).ToString());
            Object var = null;
            int readAssemId = 0;

            switch (binaryTypeEnum)
            {
                case BinaryTypeEnum.Primitive:
                case BinaryTypeEnum.PrimitiveArray:
                    var = (InternalPrimitiveTypeE)input.ReadByte();
                    break;
                case BinaryTypeEnum.String:
                case BinaryTypeEnum.Object:
                case BinaryTypeEnum.StringArray:
                case BinaryTypeEnum.ObjectArray:
                    break;                    
                case BinaryTypeEnum.ObjectUrt:
                    var = input.ReadString();                   
                    break;
                case BinaryTypeEnum.ObjectUser:
                    var = input.ReadString();
                    readAssemId = input.ReadInt32();
                    break;                    
                default:
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeRead"),((Enum)binaryTypeEnum).ToString()));                 
            }
            SerTrace.Log( "BinaryConverter", "ReadTypeInfo Exit  ",var," assemId ",readAssemId);
            assemId = readAssemId;
            return var;
        }

        // Given the wire type information, returns the actual type and additional information
        internal static void TypeFromInfo(BinaryTypeEnum binaryTypeEnum,
                                          Object typeInformation,
                                          ObjectReader objectReader,
                                          BinaryAssemblyInfo assemblyInfo,
                                          out InternalPrimitiveTypeE primitiveTypeEnum,
                                          out String typeString,
                                          out Type type,
                                          out bool isVariant)
        {
            SerTrace.Log( "BinaryConverter", "TypeFromInfo Entry  ",((Enum)binaryTypeEnum).ToString());

            isVariant = false;
            primitiveTypeEnum = InternalPrimitiveTypeE.Invalid;
            typeString = null;
            type = null;

            switch (binaryTypeEnum)
            {
                case BinaryTypeEnum.Primitive:
                    primitiveTypeEnum = (InternalPrimitiveTypeE)typeInformation;                    
                    typeString = Converter.ToComType(primitiveTypeEnum);
                    type = Converter.ToType(primitiveTypeEnum);
                    break;
                case BinaryTypeEnum.String:
                    //typeString = "System.String";
                    type = Converter.typeofString;
                    break;
                case BinaryTypeEnum.Object:
                    //typeString = "System.Object";
                    type = Converter.typeofObject;
                    isVariant = true; 
                    break;
                case BinaryTypeEnum.ObjectArray:
                    //typeString = "System.Object[]";
                    type = Converter.typeofObjectArray;
                    break;
                case BinaryTypeEnum.StringArray:
                    //typeString = "System.String[]";
                    type = Converter.typeofStringArray;
                    break;
                case BinaryTypeEnum.PrimitiveArray:
                    primitiveTypeEnum = (InternalPrimitiveTypeE)typeInformation;                    
                    type = Converter.ToArrayType(primitiveTypeEnum);
                    break;
                case BinaryTypeEnum.ObjectUser:
                case BinaryTypeEnum.ObjectUrt:
                    if (typeInformation != null)
                    {
                        typeString = typeInformation.ToString();
                        type = objectReader.GetType(assemblyInfo, typeString);
                        // Temporary for backward compatibility
                        if (type == Converter.typeofObject)
                            isVariant = true;
                    }
                    break;
                default:
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeRead"),((Enum)binaryTypeEnum).ToString()));                                     
            }

            SerTrace.Log( "BinaryConverter", "TypeFromInfo Exit  "
                          ,((Enum)primitiveTypeEnum).ToString(),",typeString ",Util.PString(typeString)
                          ,", type ",Util.PString(type),", isVariant ",isVariant);      

        }

        // Used to write type type on the record dump
        internal static String TypeInfoTraceString(Object typeInformation)
        {
            String traceString = null;
            if (typeInformation == null)
                traceString = "(Null)";
            else if (typeInformation is String)
                traceString = "(UTF)";
            else
                traceString = "(Byte)";
            return traceString;
        }


    }

    internal sealed class IOUtil
    {
        internal static bool FlagTest(MessageEnum flag, MessageEnum target)
        {
            if ((flag & target) == target)
                return true;
            else
                return false;
        }

        internal static void WriteStringWithCode(String value, __BinaryWriter sout)
        {
            if (value == null)
                sout.WriteByte((Byte)InternalPrimitiveTypeE.Null);
            else
            {
                sout.WriteByte((Byte)InternalPrimitiveTypeE.String);
                sout.WriteString(value);
            }
        }

        internal static void WriteWithCode(Type type, Object value, __BinaryWriter sout)
        {
            if (type == null)
                sout.WriteByte((Byte)InternalPrimitiveTypeE.Null);
            else if (type == Converter.typeofString)
                WriteStringWithCode((String)value, sout);
            else
            {
                InternalPrimitiveTypeE code = Converter.ToCode(type);
                sout.WriteByte((Byte)code);
                sout.WriteValue(code, value);
            }
        }

        internal static Object ReadWithCode(__BinaryParser input)
        {
             InternalPrimitiveTypeE code = (InternalPrimitiveTypeE)input.ReadByte();
             if (code == InternalPrimitiveTypeE.Null)
                 return null;
             else if (code == InternalPrimitiveTypeE.String)
                 return input.ReadString();
             else
                 return input.ReadValue(code);
        }

        internal static Object[] ReadArgs(__BinaryParser input)
        {
            int length = input.ReadInt32();
            Object[] args = new Object[length];
            for (int i=0; i<length; i++)
                args[i] = ReadWithCode(input);
            return args;
        }

    }


    internal sealed class BinaryUtil
    {
        [Conditional("_LOGGING")]                               
        public static void NVTraceI(String name, String value)
        {
            if (BCLDebug.CheckEnabled("BINARY"))
                BCLDebug.Trace("BINARY", "  ",name, " = ", value);
        }

        // Traces an name value pair
        [Conditional("_LOGGING")]                                       
        public static void NVTraceI(String name, Object value)
        {
            if (BCLDebug.CheckEnabled("BINARY"))
                BCLDebug.Trace("BINARY", "  ",name, " = ", value);
        }
    }


    // Interface for Binary Records.
    internal interface IStreamable
    {
        void Read(__BinaryParser input);
        void Write(__BinaryWriter sout);
        void Dump();
    }

    internal sealed class BinaryAssemblyInfo
    {
        internal String assemblyString;
        private Assembly assembly;


        internal BinaryAssemblyInfo(String assemblyString)
        {
            this.assemblyString = assemblyString;
        }

        internal BinaryAssemblyInfo(String assemblyString, Assembly assembly)
        {
            this.assemblyString = assemblyString;
            this.assembly = assembly;
        }

        internal Assembly GetAssembly()
        {
            if (assembly == null)
            {
                assembly = FormatterServices.LoadAssemblyFromStringNoThrow(assemblyString);
                if (assembly == null)
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyNotFound"),assemblyString));
            }
            return assembly;
        }
    }

    // The Following classes read and write the binary records
    internal sealed class SerializationHeaderRecord : IStreamable
    {
        internal Int32 binaryFormatterMajorVersion = 1;
        internal Int32 binaryFormatterMinorVersion = 0;
        internal BinaryHeaderEnum binaryHeaderEnum;
        internal Int32 topId;
        internal Int32 headerId;
        internal Int32 majorVersion;
        internal Int32 minorVersion;

        internal SerializationHeaderRecord()
        {
        }

        internal SerializationHeaderRecord(BinaryHeaderEnum binaryHeaderEnum, Int32 topId, Int32 headerId, Int32 majorVersion, Int32 minorVersion)
        {
            this.binaryHeaderEnum = binaryHeaderEnum;
            this.topId = topId;
            this.headerId = headerId;
            this.majorVersion = majorVersion;
            this.minorVersion = minorVersion;
        }

        public  void Write(__BinaryWriter sout)
        {
            majorVersion = binaryFormatterMajorVersion;
            minorVersion = binaryFormatterMinorVersion;
            sout.WriteByte((Byte)binaryHeaderEnum);
            sout.WriteInt32(topId);
            sout.WriteInt32(headerId);
            sout.WriteInt32(binaryFormatterMajorVersion);
            sout.WriteInt32(binaryFormatterMinorVersion);      
        }


        public  void Read(__BinaryParser input)
        {
            // binaryHeaderEnum has already been read
            binaryHeaderEnum = (BinaryHeaderEnum)input.ReadByte();
            topId = input.ReadInt32();
            headerId = input.ReadInt32();
            majorVersion = input.ReadInt32();
            minorVersion = input.ReadInt32();  
            if (majorVersion > binaryFormatterMajorVersion)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Version"),binaryFormatterMajorVersion+"."+binaryFormatterMinorVersion, majorVersion+"."+minorVersion));

        }

        public  void Dump()
        {
            DumpInternal();
        }


        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY", "*****SerializationHeaderRecord*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                BinaryUtil.NVTraceI("topId (Int32)", topId);
                BinaryUtil.NVTraceI("headerId (Int32)", headerId);
                BinaryUtil.NVTraceI("majorVersion (Int32)", majorVersion);
                BinaryUtil.NVTraceI("minorVersion (Int32)", minorVersion);
                BCLDebug.Trace("BINARY","***********************************");
            }
        }
    }


    internal sealed class BinaryAssembly : IStreamable
    {
        internal Int32 assemId;
        internal String assemblyString;

        internal BinaryAssembly()
        {
        }


        internal void Set(Int32 assemId, String assemblyString)
        {
            SerTrace.Log( this, "BinaryAssembly Set ",assemId," ",assemblyString);      
            this.assemId = assemId;
            this.assemblyString = assemblyString;
        }


        public void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.Assembly);
            sout.WriteInt32(assemId);
            sout.WriteString(assemblyString);
        }

        public void Read(__BinaryParser input)
        {
            assemId = input.ReadInt32();
            assemblyString = input.ReadString();
        }

        public void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryAssembly*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "Assembly");
                BinaryUtil.NVTraceI("assemId (Int32)", assemId);        
                BinaryUtil.NVTraceI("Assembly (UTF)", assemblyString);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal sealed class BinaryCrossAppDomainAssembly : IStreamable
    {
        internal Int32 assemId;
        internal Int32 assemblyIndex;

        internal BinaryCrossAppDomainAssembly()
        {
        }


        internal void Set(Int32 assemId, Int32 assemblyIndex)
        {
            SerTrace.Log( this, "BinaryAssembly Set ",assemId," ",assemblyIndex);       
            this.assemId = assemId;
            this.assemblyIndex = assemblyIndex;
        }


        public void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.CrossAppDomainAssembly);
            sout.WriteInt32(assemId);
            sout.WriteInt32(assemblyIndex);
        }

        public void Read(__BinaryParser input)
        {
            assemId = input.ReadInt32();
            assemblyIndex = input.ReadInt32();
        }

        public void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryCrossAppDomainAssembly*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "CrossAppDomainAssembly");
                BinaryUtil.NVTraceI("assemId (Int32)", assemId);        
                BinaryUtil.NVTraceI("assemblyIndex (Int32)", assemblyIndex);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }


    internal sealed class BinaryObject : IStreamable
    {
        internal Int32 objectId;
        internal Int32 mapId;

        internal BinaryObject()
        {
        }

        internal  void Set(Int32 objectId, Int32 mapId)
        {
            SerTrace.Log( this, "BinaryObject Set ",objectId," ",mapId);        
            this.objectId = objectId;
            this.mapId = mapId;
        }


        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.Object);
            sout.WriteInt32(objectId);
            sout.WriteInt32(mapId);
        }

        public  void Read(__BinaryParser input)
        {
            objectId = input.ReadInt32();
            mapId = input.ReadInt32();
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryObject*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "Object");
                BinaryUtil.NVTraceI("objectId (Int32)", objectId);      
                BinaryUtil.NVTraceI("mapId (Int32)", mapId);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal sealed class BinaryMethodCall
    {
        String uri;
        String methodName;
        String typeName;
        Object[] args;
        Object methodSignature;
        Object callContext;
        String scallContext;
        Object properties;
        Type[] argTypes;
        bool bArgsPrimitive = true;
        MessageEnum messageEnum;
        Object[] callA;

        // If the argument list contains only primitive or strings it is written out as part of the header
        // if not the args are written out as a separate array
        internal Object[] WriteArray(String uri, String methodName, String typeName, Object[] args, Object methodSignature, Object callContext, Object[] properties)
        {
            this.uri = uri;
            this.methodName = methodName;
            this.typeName = typeName;
            this.args = args;
            this.methodSignature = methodSignature;
            this.callContext = callContext;
            this.properties = properties;

            int arraySize = 0;
            if (args == null || args.Length == 0)
                messageEnum = MessageEnum.NoArgs;
            else
            {
                argTypes = new Type[args.Length];
                // Check if args are all string or primitives
                bArgsPrimitive = true;
                for (int i =0; i<args.Length; i++)
                {
                    if (args[i] != null)
                    {
                        argTypes[i] = args[i].GetType();
                        if (!(argTypes[i].IsPrimitive || argTypes[i] == Converter.typeofString))
                        {
                            bArgsPrimitive = false;
                            break;
                        }
                    }
                }


                if (bArgsPrimitive)
                    messageEnum = MessageEnum.ArgsInline;
                else
                {
                    arraySize++;
                    messageEnum = MessageEnum.ArgsInArray;
                }
            }


            if (methodSignature != null)
            {
                arraySize++;
                messageEnum |= MessageEnum.MethodSignatureInArray;
            }

            if (callContext == null)
                messageEnum |= MessageEnum.NoContext;
            else if (callContext is String)
                messageEnum |= MessageEnum.ContextInline;
            else
            {
                arraySize++;
                messageEnum |= MessageEnum.ContextInArray;
            }

            if (properties != null)
            {
                arraySize++;
                messageEnum |= MessageEnum.PropertyInArray;
            }

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray) && arraySize == 1)
            {
                messageEnum ^= MessageEnum.ArgsInArray;
                messageEnum |= MessageEnum.ArgsIsArray;
                return args;
            }


            if (arraySize > 0)
            {
                int arrayPosition = 0;
                callA = new Object[arraySize];
                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray))
                    callA[arrayPosition++] = args;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.MethodSignatureInArray))
                    callA[arrayPosition++] = methodSignature;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInArray))
                    callA[arrayPosition++] = callContext;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.PropertyInArray))
                    callA[arrayPosition] = properties;

                 return callA;
            }
            else
                return null;
        }

        internal void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.MethodCall);
            sout.WriteInt32((Int32)messageEnum);
            //IOUtil.WriteStringWithCode(uri, sout);
            IOUtil.WriteStringWithCode(methodName, sout);
            IOUtil.WriteStringWithCode(typeName, sout);
            if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
                IOUtil.WriteStringWithCode((String)callContext, sout);

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
            {
                sout.WriteInt32(args.Length);
                for (int i=0; i<args.Length; i++)
                {
                    IOUtil.WriteWithCode(argTypes[i], args[i], sout);
                }

            }
        }

        internal void Read(__BinaryParser input)
        {
             messageEnum = (MessageEnum)input.ReadInt32();
             //uri = (String)IOUtil.ReadWithCode(input);
             methodName = (String)IOUtil.ReadWithCode(input);
             typeName = (String)IOUtil.ReadWithCode(input);

             if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
             {
                 scallContext = (String)IOUtil.ReadWithCode(input);
                 LogicalCallContext lcallContext = new LogicalCallContext();
                 lcallContext.RemotingData.LogicalCallID = scallContext;
                 callContext = lcallContext;
             }

             if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
                 args = IOUtil.ReadArgs(input);
        }

        internal IMethodCallMessage ReadArray(Object[] callA, Object handlerObject)
        {
            /*
            if (callA.Length != 7)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                */

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsIsArray))
            {
                args = callA;
            }
            else
            {
                int arrayPosition = 0;
                
                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray))
                {
                    if (callA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    args = (Object[])callA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.MethodSignatureInArray))
                {
                    if (callA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    methodSignature = callA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInArray))
                {
                    if (callA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    callContext = callA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.PropertyInArray))
                {
                    if (callA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    properties = callA[arrayPosition++];
                }
            }

            return new MethodCall(handlerObject, new BinaryMethodCallMessage(uri, methodName, typeName, args, methodSignature, (LogicalCallContext)callContext, (Object[])properties));
        }

        internal void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryMethodCall*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "MethodCall");
                BinaryUtil.NVTraceI("messageEnum (Int32)", ((Enum)messageEnum).ToString());
                //BinaryUtil.NVTraceI("uri",uri);
                BinaryUtil.NVTraceI("methodName",methodName);
                BinaryUtil.NVTraceI("typeName",typeName);
                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
                {
                    if (callContext is String)
                        BinaryUtil.NVTraceI("callContext", (String)callContext);   
                    else
                        BinaryUtil.NVTraceI("callContext", scallContext);   
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
                {
                    BinaryUtil.NVTraceI("args Length", args.Length);
                    for (int i=0; i<args.Length; i++)
                    {
                        BinaryUtil.NVTraceI("arg["+i+"]", args[i]);
                    }
                }

                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal sealed class BinaryMethodReturn : IStreamable
    {
        Object returnValue;
        Object[] args;
        Exception exception;
        Object callContext;
        String scallContext;
        Object properties;
        Type[] argTypes;
        bool bArgsPrimitive = true;
        MessageEnum messageEnum;
        Object[] callA;
        Type returnType;

        internal BinaryMethodReturn()
        {
        }

        // If the argument list contains only primitive or strings it is written out as part of the header
        // if not the args are written out as a separate array
        internal Object[] WriteArray(Object returnValue, Object[] args, Exception exception, Object callContext, Object[] properties)
        {
            SerTrace.Log(this, "WriteArray returnValue ",returnValue, "exception ", exception, " callContext ",callContext," properties ", properties);

            this.returnValue = returnValue;
            this.args = args;
            this.exception = exception;
            this.callContext = callContext;
            this.properties = properties;

            int arraySize = 0;
            if (args == null || args.Length == 0)
                messageEnum = MessageEnum.NoArgs;
            else
            {
                argTypes = new Type[args.Length];

                // Check if args are all string or primitives

                bArgsPrimitive = true;
                for (int i =0; i<args.Length; i++)
                {
                    if (args[i] != null)
                    {
                        argTypes[i] = args[i].GetType();
                        if (!(argTypes[i].IsPrimitive || argTypes[i] == Converter.typeofString))
                        {
                            bArgsPrimitive = false;
                            break;
                        }
                    }
                }

                if (bArgsPrimitive)
                    messageEnum = MessageEnum.ArgsInline;
                else
                {
                    arraySize++;
                    messageEnum = MessageEnum.ArgsInArray;
                }
            }


            if (returnValue == null)
                messageEnum |= MessageEnum.NoReturnValue;
            else if (returnValue.GetType() == typeof(void))
                messageEnum |= MessageEnum.ReturnValueVoid;
            else
            {
                returnType = returnValue.GetType();
                if (returnType.IsPrimitive || returnType == Converter.typeofString)
                    messageEnum |= MessageEnum.ReturnValueInline;
                else
                {
                    arraySize++;
                    messageEnum |= MessageEnum.ReturnValueInArray;
                }
            }

            if (exception != null)
            {
                arraySize++;
                messageEnum |= MessageEnum.ExceptionInArray;
            }

            if (callContext == null)
                messageEnum |= MessageEnum.NoContext;
            else if (callContext is String)
                messageEnum |= MessageEnum.ContextInline;
            else
            {
                arraySize++;
                messageEnum |= MessageEnum.ContextInArray;
            }

            if (properties != null)
            {
                arraySize++;
                messageEnum |= MessageEnum.PropertyInArray;
            }

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray) && (arraySize == 1))
            {
                messageEnum ^= MessageEnum.ArgsInArray;
                messageEnum |= MessageEnum.ArgsIsArray;
                return args;
            }

            if (arraySize > 0)
            {
                int arrayPosition = 0;
                callA = new Object[arraySize];
                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray))
                    callA[arrayPosition++] = args;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueInArray))
                    callA[arrayPosition++] = returnValue;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ExceptionInArray))
                    callA[arrayPosition++] = exception;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInArray))
                    callA[arrayPosition++] = callContext;

                if (IOUtil.FlagTest(messageEnum, MessageEnum.PropertyInArray))
                    callA[arrayPosition] = properties;

                 return callA;
            }
            else
                return null;
        }


        public void Write(__BinaryWriter sout) 
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.MethodReturn);
            sout.WriteInt32((Int32)messageEnum);

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueInline))
            {
                IOUtil.WriteWithCode(returnType, returnValue, sout);
            }

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
                IOUtil.WriteStringWithCode((String)callContext, sout);

            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
            {
                sout.WriteInt32(args.Length);
                for (int i=0; i<args.Length; i++)
                {
                    IOUtil.WriteWithCode(argTypes[i], args[i], sout);
                }
            }
        }

        public void Read(__BinaryParser input)
        {
             messageEnum = (MessageEnum)input.ReadInt32();

             if (IOUtil.FlagTest(messageEnum, MessageEnum.NoReturnValue))
                 returnValue = null;
             else if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueVoid))
             {
                 returnValue = FormatterServices.GetUninitializedObject(Converter.typeofSystemVoid);            
             }
             else if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueInline))
                 returnValue = IOUtil.ReadWithCode(input);

             if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
             {
                 scallContext = (String)IOUtil.ReadWithCode(input);
                 LogicalCallContext lcallContext = new LogicalCallContext();
                 lcallContext.RemotingData.LogicalCallID = scallContext;
                 callContext = lcallContext;
             }

             if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
                 args = IOUtil.ReadArgs(input);
        }

        internal IMethodReturnMessage ReadArray(Object[] returnA, IMethodCallMessage methodCallMessage, Object handlerObject)
        {
            if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsIsArray))
            {
                args = returnA;
            }
            else
            {
                int arrayPosition = 0;
                    
                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInArray))
                {
                    if (returnA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    args = (Object[])returnA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueInArray))
                {
                    if (returnA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    returnValue = returnA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ExceptionInArray))
                {
                    if (returnA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    exception = (Exception)returnA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInArray))
                {
                   if (returnA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    callContext = returnA[arrayPosition++];
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.PropertyInArray))
                {
                    if (returnA.Length < arrayPosition)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Method")));
                    properties = returnA[arrayPosition++];
                }
            }
            return new MethodResponse(methodCallMessage, handlerObject,  new BinaryMethodReturnMessage(returnValue, args, exception, (LogicalCallContext)callContext, (Object[])properties));
        }

        public void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryMethodReturn*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "MethodReturn");
                BinaryUtil.NVTraceI("messageEnum (Int32)", ((Enum)messageEnum).ToString());

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ReturnValueInline))
                    BinaryUtil.NVTraceI("returnValue", returnValue);

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ContextInline))
                {
                    if (callContext is String)
                        BinaryUtil.NVTraceI("callContext", (String)callContext);   
                    else
                        BinaryUtil.NVTraceI("callContext", scallContext);   
                }

                if (IOUtil.FlagTest(messageEnum, MessageEnum.ArgsInline))
                {
                    BinaryUtil.NVTraceI("args Length", args.Length);
                    for (int i=0; i<args.Length; i++)
                    {
                        BinaryUtil.NVTraceI("arg["+i+"]", args[i]);
                    }
                }

                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }



    internal sealed class BinaryObjectString : IStreamable
    {
        internal Int32 objectId;
        internal String value;

        internal BinaryObjectString()
        {
        }

        internal  void Set(Int32 objectId, String value)
        {
            SerTrace.Log(this, "BinaryObjectString set ",objectId," ",value);
            this.objectId = objectId;
            this.value = value;
        }   


        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.ObjectString);
            sout.WriteInt32(objectId);
            sout.WriteString(value);
        }

        public  void Read(__BinaryParser input)
        {
            objectId = input.ReadInt32();
            value = input.ReadString();
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryObjectString*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "ObjectString");
                BinaryUtil.NVTraceI("objectId (Int32)", objectId);              
                BinaryUtil.NVTraceI("value (UTF)", value);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal sealed class BinaryCrossAppDomainString : IStreamable
    {
        internal Int32 objectId;
        internal Int32 value;

        internal BinaryCrossAppDomainString()
        {
        }

        internal  void Set(Int32 objectId, Int32 value)
        {
            SerTrace.Log(this, "BinaryCrossAppDomainString set ",objectId," ",value);
            this.objectId = objectId;
            this.value = value;
        }   


        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.CrossAppDomainString);
            sout.WriteInt32(objectId);
            sout.WriteInt32(value);
        }

        public  void Read(__BinaryParser input)
        {
            objectId = input.ReadInt32();
            value = input.ReadInt32();
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryCrossAppDomainString*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "CrossAppDomainString");
                BinaryUtil.NVTraceI("objectId (Int32)", objectId);              
                BinaryUtil.NVTraceI("value (Int32)", value);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal sealed class BinaryCrossAppDomainMap : IStreamable
    {
        internal Int32 crossAppDomainArrayIndex;

        internal BinaryCrossAppDomainMap()
        {
        }

        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.CrossAppDomainMap);
            sout.WriteInt32(crossAppDomainArrayIndex);
        }

        public  void Read(__BinaryParser input)
        {
            crossAppDomainArrayIndex = input.ReadInt32();
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryCrossAppDomainMap*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "CrossAppDomainMap");
                BinaryUtil.NVTraceI("crossAppDomainArrayIndex (Int32)", crossAppDomainArrayIndex);              
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }


    internal sealed class MemberPrimitiveTyped : IStreamable
    {
        internal InternalPrimitiveTypeE primitiveTypeEnum;
        internal Object value;

        internal MemberPrimitiveTyped()
        {
        }

        internal void Set(InternalPrimitiveTypeE primitiveTypeEnum, Object value)
        {
            SerTrace.Log(this, "MemberPrimitiveTyped Set ",((Enum)primitiveTypeEnum).ToString()," ",value);
            this.primitiveTypeEnum = primitiveTypeEnum;
            this.value = value;
        }   


        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.MemberPrimitiveTyped);
            sout.WriteByte((Byte)primitiveTypeEnum); //pdj
            sout.WriteValue(primitiveTypeEnum, value);
        }

        public  void Read(__BinaryParser input)
        {
            primitiveTypeEnum = (InternalPrimitiveTypeE)input.ReadByte(); //PDJ
            value = input.ReadValue(primitiveTypeEnum);     
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****MemberPrimitiveTyped*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "MemberPrimitiveTyped");
                BinaryUtil.NVTraceI("primitiveTypeEnum (Byte)", ((Enum)primitiveTypeEnum).ToString());
                BinaryUtil.NVTraceI("value ("+ Converter.ToComType(primitiveTypeEnum)+")", value);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }


    internal sealed class BinaryObjectWithMap : IStreamable
    {
        internal BinaryHeaderEnum binaryHeaderEnum;
        internal Int32 objectId;
        internal String name;
        internal Int32 numMembers;
        internal String[] memberNames;
        internal Int32 assemId;   

        internal BinaryObjectWithMap()
        {
        }

        internal BinaryObjectWithMap(BinaryHeaderEnum binaryHeaderEnum)
        {
            this.binaryHeaderEnum = binaryHeaderEnum;
        }

        /*
        internal BinaryObjectWithMap Copy()
        {
        BinaryObjectWithMap newBOWM = new BinaryObjectWithMap(binaryHeaderEnum);
        String[] newMemberNames = new String[numMembers];
        Array.Copy(memberNames, newMemberNames, numMembers);
        newBOWM.Set(objectId, name, numMembers, newMemberNames, assemId);
        return newBOWM;
        }
*/

        internal  void Set(Int32 objectId, String name, Int32 numMembers, String[] memberNames, Int32 assemId)
        {
            SerTrace.Log(this, "BinaryObjectWithMap Set ",objectId," assemId ",assemId," ",Util.PString(name)," numMembers ",numMembers);
            this.objectId = objectId;
            this.name = name;
            this.numMembers = numMembers;
            this.memberNames = memberNames;
            this.assemId = assemId;

            if (assemId > 0)
                binaryHeaderEnum = BinaryHeaderEnum.ObjectWithMapAssemId;
            else
                binaryHeaderEnum = BinaryHeaderEnum.ObjectWithMap;

        }

        public  void Write(__BinaryWriter sout)
        {

            sout.WriteByte((Byte)binaryHeaderEnum);
            sout.WriteInt32(objectId);
            sout.WriteString(name);
            sout.WriteInt32(numMembers);
            for (int i=0; i<numMembers; i++)
                sout.WriteString(memberNames[i]);
            if (assemId > 0)
                sout.WriteInt32(assemId);
        }

        public  void Read(__BinaryParser input)
        {
            objectId = input.ReadInt32();
            name = input.ReadString();
            numMembers = input.ReadInt32();
            memberNames = new String[numMembers];
            for (int i=0; i<numMembers; i++)
            {
                memberNames[i] = input.ReadString();
                SerTrace.Log(this, "BinaryObjectWithMap Read ",i," ",memberNames[i]);
            }

            if (binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapAssemId)
            {
                assemId = input.ReadInt32();
            }
        }


        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryObjectWithMap*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                BinaryUtil.NVTraceI("objectId (Int32)", objectId);
                BinaryUtil.NVTraceI("name (UTF)", name);
                BinaryUtil.NVTraceI("numMembers (Int32)", numMembers);
                for (int i=0; i<numMembers; i++)
                    BinaryUtil.NVTraceI("memberNames (UTF)", memberNames[i]);
                if (binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapAssemId)
                    BinaryUtil.NVTraceI("assemId (Int32)", assemId);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }


    internal  sealed class BinaryObjectWithMapTyped : IStreamable
    {
        internal BinaryHeaderEnum binaryHeaderEnum;     
        internal Int32 objectId;
        internal String name;
        internal Int32 numMembers;
        internal String[] memberNames;
        internal BinaryTypeEnum[] binaryTypeEnumA;
        internal Object[] typeInformationA;
        internal Int32[] memberAssemIds;
        internal Int32 assemId;     


        internal BinaryObjectWithMapTyped()
        {
        }

        internal BinaryObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum)
        {
            this.binaryHeaderEnum = binaryHeaderEnum;
        }

        /*
        internal BinaryObjectWithMapTyped Copy()
        {
        BinaryObjectWithMapTyped newBOWM = new BinaryObjectWithMapTyped(binaryHeaderEnum);

        String[] newMemberNames = new String[numMembers];
        Array.Copy(memberNames, newMemberNames, numMembers);
        BinaryTypeEnum[] newBinaryTypeEnumA = new BinaryTypeEnum[binaryTypeEnumA.Length];
        Array.Copy(binaryTypeEnumA, newBinaryTypeEnumA, binaryTypeEnumA.Length);
        Object[] newTypeInformationA = new Object[typeInformationA.Length];
        Array.Copy(typeInformationA, newTypeInformationA, typeInformationA.Length);
        Int32[] newMemberAssemIds = new Int32[memberAssemIds.Length];
        Array.Copy(memberAssemIds, newMemberAssemIds, memberAssemIds.Length);

        newBOWM.Set(objectId, name, numMembers, newMemberNames, newBinaryTypeEnumA, newTypeInformationA, newMemberAssemIds, assemId);
        return newBOWM;
        }
*/


        internal  void Set(Int32 objectId, String name, Int32 numMembers, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, Int32 assemId)
        {
            SerTrace.Log(this, "BinaryObjectWithMapTyped Set ",objectId," assemId ",assemId," ",name," numMembers ",numMembers);
            this.objectId = objectId;
            this.assemId = assemId;         
            this.name = name;
            this.numMembers = numMembers;
            this.memberNames = memberNames;
            this.binaryTypeEnumA = binaryTypeEnumA;
            this.typeInformationA = typeInformationA;
            this.memberAssemIds = memberAssemIds;
            this.assemId = assemId;

            if (assemId > 0)
                binaryHeaderEnum = BinaryHeaderEnum.ObjectWithMapTypedAssemId;
            else
                binaryHeaderEnum = BinaryHeaderEnum.ObjectWithMapTyped;             
        }


        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)binaryHeaderEnum);         
            sout.WriteInt32(objectId);
            sout.WriteString(name);
            sout.WriteInt32(numMembers);
            for (int i=0; i<numMembers; i++)
                sout.WriteString(memberNames[i]);
            for (int i=0; i<numMembers; i++)
                sout.WriteByte((Byte)binaryTypeEnumA[i]);
            for (int i=0; i<numMembers; i++)
                //if (binaryTypeEnumA[i] != BinaryTypeEnum.ObjectUrt && binaryTypeEnumA[i] != BinaryTypeEnum.ObjectUser)
                    BinaryConverter.WriteTypeInfo(binaryTypeEnumA[i], typeInformationA[i], memberAssemIds[i], sout);

            if (assemId > 0)
                sout.WriteInt32(assemId);

        }

        public  void Read(__BinaryParser input)
        {
            // binaryHeaderEnum has already been read
            objectId = input.ReadInt32();
            name = input.ReadString();
            numMembers = input.ReadInt32();
            memberNames = new String[numMembers];
            binaryTypeEnumA = new BinaryTypeEnum[numMembers];
            typeInformationA = new Object[numMembers];
            memberAssemIds = new Int32[numMembers];
            for (int i=0; i<numMembers; i++)
                memberNames[i] = input.ReadString();
            for (int i=0; i<numMembers; i++)
                binaryTypeEnumA[i] = (BinaryTypeEnum)input.ReadByte();
            for (int i=0; i<numMembers; i++)
                if (binaryTypeEnumA[i] != BinaryTypeEnum.ObjectUrt && binaryTypeEnumA[i] != BinaryTypeEnum.ObjectUser)
                    typeInformationA[i] = BinaryConverter.ReadTypeInfo(binaryTypeEnumA[i], input, out memberAssemIds[i]);
                else
                    BinaryConverter.ReadTypeInfo(binaryTypeEnumA[i], input, out memberAssemIds[i]);
            
            if (binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapTypedAssemId)
            {
                assemId = input.ReadInt32();                
            }
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****BinaryObjectWithMapTyped*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                BinaryUtil.NVTraceI("objectId (Int32)", objectId);          
                BinaryUtil.NVTraceI("name (UTF)", name);
                BinaryUtil.NVTraceI("numMembers (Int32)", numMembers);
                for (int i=0; i<numMembers; i++)
                    BinaryUtil.NVTraceI("memberNames (UTF)", memberNames[i]);
                for (int i=0; i<numMembers; i++)
                    BinaryUtil.NVTraceI("binaryTypeEnum("+i+") (Byte)", ((Enum)binaryTypeEnumA[i]).ToString());
                for (int i=0; i<numMembers; i++)
                    if ((binaryTypeEnumA[i] == BinaryTypeEnum.Primitive) || 
                        (binaryTypeEnumA[i] == BinaryTypeEnum.PrimitiveArray) || 
                        (binaryTypeEnumA[i] == BinaryTypeEnum.ObjectUrt) || 
                        (binaryTypeEnumA[i] == BinaryTypeEnum.ObjectUser))
                    {
                        BinaryUtil.NVTraceI("typeInformation("+i+") "+BinaryConverter.TypeInfoTraceString(typeInformationA[i]), typeInformationA[i]);
                        if (binaryTypeEnumA[i] == BinaryTypeEnum.ObjectUser)
                            BinaryUtil.NVTraceI("memberAssemId("+i+") (Int32)", memberAssemIds[i]);
                    }
                    /*
                    for (int i=0; i<numMembers; i++)
                    {
                    if (binaryTypeEnumA[i] == BinaryTypeEnum.ObjectUser)
                    BinaryUtil.NVTraceI("memberAssemId("+i+") (Int32)", memberAssemIds[i]);
                    }
*/
                if (binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapTypedAssemId)
                    BinaryUtil.NVTraceI("assemId (Int32)", assemId);
                BCLDebug.Trace("BINARY","****************************");
            }
        }

    }


    internal  sealed class BinaryArray : IStreamable
    {
        internal Int32 objectId;
        internal Int32 rank;
        internal Int32[] lengthA;
        internal Int32[] lowerBoundA;
        internal BinaryTypeEnum binaryTypeEnum;
        internal Object typeInformation;
        internal int assemId = 0;

        private BinaryHeaderEnum binaryHeaderEnum;
        internal BinaryArrayTypeEnum binaryArrayTypeEnum;

        internal BinaryArray()
        {
            SerTrace.Log( this, "BinaryArray Constructor 1 ");
        }

        // Read constructor
        internal BinaryArray(BinaryHeaderEnum binaryHeaderEnum)
        {
            SerTrace.Log( this, "BinaryArray Constructor 2 ",   ((Enum)binaryHeaderEnum).ToString());
            this.binaryHeaderEnum = binaryHeaderEnum;
        }


        internal void Set(Int32 objectId, Int32 rank, Int32[] lengthA, Int32[] lowerBoundA, BinaryTypeEnum binaryTypeEnum, Object typeInformation, BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId)
        {
            SerTrace.Log( this, "BinaryArray Set objectId ",objectId," rank ",rank," ",((Enum)binaryTypeEnum).ToString(),", assemId ",assemId);
            this.objectId = objectId;
            this.binaryArrayTypeEnum = binaryArrayTypeEnum;
            this.rank = rank;
            this.lengthA = lengthA;
            this.lowerBoundA = lowerBoundA;
            this.binaryTypeEnum = binaryTypeEnum;
            this.typeInformation = typeInformation;
            this.assemId = assemId;
            binaryHeaderEnum = BinaryHeaderEnum.Array;

            if (binaryArrayTypeEnum == BinaryArrayTypeEnum.Single)
            {
                if (binaryTypeEnum == BinaryTypeEnum.Primitive)
                    binaryHeaderEnum = BinaryHeaderEnum.ArraySinglePrimitive;
                else if (binaryTypeEnum == BinaryTypeEnum.String)
                    binaryHeaderEnum = BinaryHeaderEnum.ArraySingleString;
                else if (binaryTypeEnum == BinaryTypeEnum.Object)
                    binaryHeaderEnum = BinaryHeaderEnum.ArraySingleObject;
            }
            SerTrace.Log( this, "BinaryArray Set Exit ",((Enum)binaryHeaderEnum).ToString());
        }


        public  void Write(__BinaryWriter sout)
        {
            SerTrace.Log( this, "Write");
            switch (binaryHeaderEnum)
            {
                case BinaryHeaderEnum.ArraySinglePrimitive:
                    sout.WriteByte((Byte)binaryHeaderEnum);
                    sout.WriteInt32(objectId);
                    sout.WriteInt32(lengthA[0]);
                    sout.WriteByte((Byte)((InternalPrimitiveTypeE)typeInformation));
                    break;
                case BinaryHeaderEnum.ArraySingleString:
                    sout.WriteByte((Byte)binaryHeaderEnum);
                    sout.WriteInt32(objectId);
                    sout.WriteInt32(lengthA[0]);
                    break;
                case BinaryHeaderEnum.ArraySingleObject:
                    sout.WriteByte((Byte)binaryHeaderEnum);
                    sout.WriteInt32(objectId);
                    sout.WriteInt32(lengthA[0]);
                    break;
                default:
                    sout.WriteByte((Byte)binaryHeaderEnum);
                    sout.WriteInt32(objectId);
                    sout.WriteByte((Byte)binaryArrayTypeEnum);
                    sout.WriteInt32(rank);
                    for (int i=0; i<rank; i++)
                        sout.WriteInt32(lengthA[i]);
                    if ((binaryArrayTypeEnum == BinaryArrayTypeEnum.SingleOffset) ||
                        (binaryArrayTypeEnum == BinaryArrayTypeEnum.JaggedOffset) ||
                        (binaryArrayTypeEnum == BinaryArrayTypeEnum.RectangularOffset))
                    {
                        for (int i=0; i<rank; i++)
                            sout.WriteInt32(lowerBoundA[i]);
                    }
                    sout.WriteByte((Byte)binaryTypeEnum);
                    BinaryConverter.WriteTypeInfo(binaryTypeEnum, typeInformation, assemId, sout);
                    break;
            }

        }

        public  void Read(__BinaryParser input)
        {
            switch (binaryHeaderEnum)
            {
                case BinaryHeaderEnum.ArraySinglePrimitive:
                    objectId = input.ReadInt32();
                    lengthA = new int[1];
                    lengthA[0] = input.ReadInt32();
                    binaryArrayTypeEnum = BinaryArrayTypeEnum.Single;
                    rank = 1;
                    lowerBoundA = new Int32[rank];
                    binaryTypeEnum = BinaryTypeEnum.Primitive;
                    typeInformation = (InternalPrimitiveTypeE)input.ReadByte();
                    break;
                case BinaryHeaderEnum.ArraySingleString:
                    objectId = input.ReadInt32();
                    lengthA = new int[1];
                    lengthA[0] = (int)input.ReadInt32();
                    binaryArrayTypeEnum = BinaryArrayTypeEnum.Single;
                    rank = 1;
                    lowerBoundA = new Int32[rank];
                    binaryTypeEnum = BinaryTypeEnum.String;
                    typeInformation = null;
                    break;
                case BinaryHeaderEnum.ArraySingleObject:
                    objectId = input.ReadInt32();
                    lengthA = new int[1];
                    lengthA[0] = (int)input.ReadInt32();
                    binaryArrayTypeEnum = BinaryArrayTypeEnum.Single;
                    rank = 1;
                    lowerBoundA = new Int32[rank];
                    binaryTypeEnum = BinaryTypeEnum.Object;
                    typeInformation = null;
                    break;
                default:
                    objectId = input.ReadInt32();
                    binaryArrayTypeEnum = (BinaryArrayTypeEnum)input.ReadByte();
                    rank = input.ReadInt32();
                    lengthA = new Int32[rank];
                    lowerBoundA = new Int32[rank];
                    for (int i=0; i<rank; i++)
                        lengthA[i] = input.ReadInt32();         
                    if ((binaryArrayTypeEnum == BinaryArrayTypeEnum.SingleOffset) ||
                        (binaryArrayTypeEnum == BinaryArrayTypeEnum.JaggedOffset) ||
                        (binaryArrayTypeEnum == BinaryArrayTypeEnum.RectangularOffset))
                    {
                        for (int i=0; i<rank; i++)
                            lowerBoundA[i] = input.ReadInt32();
                    }
                    binaryTypeEnum = (BinaryTypeEnum)input.ReadByte();
                    typeInformation = BinaryConverter.ReadTypeInfo(binaryTypeEnum, input, out assemId);
                    break;
            }
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                switch (binaryHeaderEnum)
                {
                    case BinaryHeaderEnum.ArraySinglePrimitive:
                        BCLDebug.Trace("BINARY","*****ArraySinglePrimitive*****");
                        BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                        BinaryUtil.NVTraceI("objectId (Int32)", objectId);                              
                        BinaryUtil.NVTraceI("length (Int32)", lengthA[0]);
                        BinaryUtil.NVTraceI("InternalPrimitiveTypeE (Byte)", ((Enum)typeInformation).ToString());
                        BCLDebug.Trace("BINARY","****************************");
                        break;
                    case BinaryHeaderEnum.ArraySingleString:
                        BCLDebug.Trace("BINARY","*****ArraySingleString*****");
                        BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                        BinaryUtil.NVTraceI("objectId (Int32)", objectId);
                        BinaryUtil.NVTraceI("length (Int32)", lengthA[0]);
                        BCLDebug.Trace("BINARY","****************************");
                        break;
                    case BinaryHeaderEnum.ArraySingleObject:
                        BCLDebug.Trace("BINARY","*****ArraySingleObject*****");
                        BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                        BinaryUtil.NVTraceI("objectId (Int32)", objectId);
                        BinaryUtil.NVTraceI("length (Int32)", lengthA[0]);
                        BCLDebug.Trace("BINARY","****************************");
                        break;
                    default:
                        BCLDebug.Trace("BINARY","*****BinaryArray*****");
                        BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)binaryHeaderEnum).ToString());
                        BinaryUtil.NVTraceI("objectId (Int32)", objectId);                              
                        BinaryUtil.NVTraceI("binaryArrayTypeEnum (Byte)", ((Enum)binaryArrayTypeEnum).ToString());              
                        BinaryUtil.NVTraceI("rank (Int32)", rank);
                        for (int i=0; i<rank; i++)
                            BinaryUtil.NVTraceI("length (Int32)", lengthA[i]);
                        if ((binaryArrayTypeEnum == BinaryArrayTypeEnum.SingleOffset) ||
                            (binaryArrayTypeEnum == BinaryArrayTypeEnum.JaggedOffset) ||
                            (binaryArrayTypeEnum == BinaryArrayTypeEnum.RectangularOffset))
                        {
                            for (int i=0; i<rank; i++)
                                BinaryUtil.NVTraceI("lowerBound (Int32)", lowerBoundA[i]);
                        }
                        BinaryUtil.NVTraceI("binaryTypeEnum (Byte)", ((Enum)binaryTypeEnum).ToString());
                        if ((binaryTypeEnum == BinaryTypeEnum.Primitive) || 
                            (binaryTypeEnum == BinaryTypeEnum.PrimitiveArray) || 
                            (binaryTypeEnum == BinaryTypeEnum.ObjectUrt) || 
                            (binaryTypeEnum == BinaryTypeEnum.ObjectUser))
                            BinaryUtil.NVTraceI("typeInformation "+BinaryConverter.TypeInfoTraceString(typeInformation), typeInformation);
                        if (binaryTypeEnum == BinaryTypeEnum.ObjectUser)
                            BinaryUtil.NVTraceI("assemId (Int32)", assemId);
                        BCLDebug.Trace("BINARY","****************************");
                        break;
                }
            }
        }
    }

    internal sealed class MemberPrimitiveUnTyped : IStreamable
    {
        // Used for members with primitive values and types are needed

        internal InternalPrimitiveTypeE typeInformation;
        internal Object value;

        internal MemberPrimitiveUnTyped()
        {
        }

        internal  void Set(InternalPrimitiveTypeE typeInformation, Object value)
        {
            SerTrace.Log( this, "MemberPrimitiveUnTyped Set typeInformation ",typeInformation," value ",value);
            this.typeInformation = typeInformation;
            this.value = value;
        }

        internal  void Set(InternalPrimitiveTypeE typeInformation)
        {
            SerTrace.Log(this, "MemberPrimitiveUnTyped  Set ",typeInformation);
            this.typeInformation = typeInformation;
        }



        public  void Write(__BinaryWriter sout)
        {
            sout.WriteValue(typeInformation, value);
        }

        public  void Read(__BinaryParser input)
        {
            //binaryHeaderEnum = input.ReadByte(); already read
            value = input.ReadValue(typeInformation);
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                String typeString = Converter.ToComType(typeInformation);
                BCLDebug.Trace("BINARY","*****MemberPrimitiveUnTyped*****");
                BinaryUtil.NVTraceI("value ("+typeString+")", value);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }


    internal  sealed class MemberReference : IStreamable
    {
        internal Int32 idRef;

        internal MemberReference()
        {
        }

        internal  void Set(Int32 idRef)
        {
            SerTrace.Log( this, "MemberReference Set ",idRef);
            this.idRef = idRef;
        }

        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.MemberReference);
            sout.WriteInt32(idRef);
        }

        public  void Read(__BinaryParser input)
        {
            //binaryHeaderEnum = input.ReadByte(); already read
            idRef = input.ReadInt32();
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****MemberReference*****");       
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", ((Enum)BinaryHeaderEnum.MemberReference).ToString());        
                BinaryUtil.NVTraceI("idRef (Int32)", idRef);
                BCLDebug.Trace("BINARY","****************************");
            }
        }
    }

    internal  sealed class ObjectNull : IStreamable
    {
        internal int nullCount;

        internal ObjectNull()
        {
        }

        internal void SetNullCount(int nullCount)
        {
            this.nullCount = nullCount;
        }

        public  void Write(__BinaryWriter sout)
        {
            if (nullCount == 1)
            {
                sout.WriteByte((Byte)BinaryHeaderEnum.ObjectNull);
            }
            else if (nullCount < 256)
            {
                sout.WriteByte((Byte)BinaryHeaderEnum.ObjectNullMultiple256);
                sout.WriteByte((Byte)nullCount);
                //Console.WriteLine("Write nullCount "+nullCount);
            }
            else
            {
                sout.WriteByte((Byte)BinaryHeaderEnum.ObjectNullMultiple);
                sout.WriteInt32(nullCount);                
                //Console.WriteLine("Write nullCount "+nullCount);
            }
        }


        public  void Read(__BinaryParser input)
        {
            Read(input, BinaryHeaderEnum.ObjectNull);
        }

        public  void Read(__BinaryParser input, BinaryHeaderEnum binaryHeaderEnum)
        {
            //binaryHeaderEnum = input.ReadByte(); already read
            switch (binaryHeaderEnum)
            {
                case BinaryHeaderEnum.ObjectNull:
                    nullCount = 1;
                    break;
                case BinaryHeaderEnum.ObjectNullMultiple256:
                    nullCount = input.ReadByte();
                    //Console.WriteLine("Read nullCount "+nullCount);
                    break;
                case BinaryHeaderEnum.ObjectNullMultiple:
                    nullCount = input.ReadInt32();
                    //Console.WriteLine("Read nullCount "+nullCount);
                    break;
            }
        }

        public  void Dump()
        {
            DumpInternal();
        }

        [Conditional("_LOGGING")]
        private void DumpInternal()
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****ObjectNull*****");
                if (nullCount == 1)
                {
                    BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "ObjectNull");
                }
                else if (nullCount < 256)
                {
                    BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "ObjectNullMultiple256");
                    BinaryUtil.NVTraceI("nullCount (Byte)", nullCount);
                }
                else
                {
                    BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "ObjectNullMultiple");
                    BinaryUtil.NVTraceI("nullCount (Int32)", nullCount);
                }

                BCLDebug.Trace("BINARY","********************");
            }
        }
    }

    internal sealed class MessageEnd : IStreamable
    {

        internal MessageEnd()
        {
        }

        public  void Write(__BinaryWriter sout)
        {
            sout.WriteByte((Byte)BinaryHeaderEnum.MessageEnd);
        }

        public  void Read(__BinaryParser input)
        {
            //binaryHeaderEnum = input.ReadByte(); already read
        }

        public  void Dump()
        {
            DumpInternal(null);
        }

        public  void Dump(Stream sout)
        {
            DumpInternal(sout);
        }

        [Conditional("_LOGGING")]
        private void DumpInternal(Stream sout)
        {
            if (BCLDebug.CheckEnabled("BINARY"))
            {
                BCLDebug.Trace("BINARY","*****MessageEnd*****");
                BinaryUtil.NVTraceI("binaryHeaderEnum (Byte)", "MessageEnd");
                long length = -1;
                if (sout != null && sout.CanSeek)
                {
                    length = sout.Length;
                    BinaryUtil.NVTraceI("Total Message Length in Bytes ", length);
                }
                BCLDebug.Trace("BINARY","********************");
            }
        }
    }


    // When an ObjectWithMap or an ObjectWithMapTyped is read off the stream, an ObjectMap class is created
    // to remember the type information. 
    internal sealed class ObjectMap
    {
        internal String objectName;
        internal Type objectType;

        internal BinaryTypeEnum[] binaryTypeEnumA;
        internal Object[] typeInformationA;
        internal Type[] memberTypes;
        internal String[] memberNames;
        internal ReadObjectInfo objectInfo;
        internal bool isInitObjectInfo = true;
        internal ObjectReader objectReader = null;
        internal Int32 objectId;
        internal BinaryAssemblyInfo assemblyInfo;

        internal ObjectMap(String objectName, Type objectType, String[] memberNames, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo)
        {
            SerTrace.Log( this, "Constructor 1 objectName ",objectName, ", objectType ",objectType);                            
            this.objectName = objectName;
            this.objectType = objectType;
            this.memberNames = memberNames;
            this.objectReader = objectReader;
            this.objectId = objectId;
            this.assemblyInfo = assemblyInfo;

            objectInfo = objectReader.CreateReadObjectInfo(objectType);
            memberTypes = objectInfo.GetMemberTypes(memberNames); 

            binaryTypeEnumA = new BinaryTypeEnum[memberTypes.Length];
            typeInformationA = new Object[memberTypes.Length];

            for (int i=0; i<memberTypes.Length; i++)
            {
                Object typeInformation = null;
                BinaryTypeEnum binaryTypeEnum = BinaryConverter.GetParserBinaryTypeInfo(memberTypes[i], out typeInformation);
                binaryTypeEnumA[i] = binaryTypeEnum;
                typeInformationA[i] = typeInformation;
            }
        }

        internal ObjectMap(String objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, int[] memberAssemIds, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)
        {
            SerTrace.Log( this, "Constructor 2 objectName ",objectName);
            this.objectName = objectName;
            this.memberNames = memberNames;
            this.binaryTypeEnumA = binaryTypeEnumA;
            this.typeInformationA = typeInformationA;
            this.objectReader = objectReader;
            this.objectId = objectId;
            this.assemblyInfo = assemblyInfo;

            if (assemblyInfo == null)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Assembly"),objectName));

            objectType = objectReader.GetType(assemblyInfo, objectName);

            memberTypes = new Type[memberNames.Length];

            for (int i=0; i<memberNames.Length; i++)
            {
                InternalPrimitiveTypeE primitiveTypeEnum;
                String typeString;
                Type type;
                bool isVariant;

                BinaryConverter.TypeFromInfo(binaryTypeEnumA[i], typeInformationA[i], objectReader, (BinaryAssemblyInfo)assemIdToAssemblyTable[memberAssemIds[i]],
                                             out primitiveTypeEnum, out typeString, out type, out isVariant);
                //if (type == null)
                //    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeResolved"),objectName+" "+memberNames[i]+" "+typeInformationA[i]));
                memberTypes[i] = type;
            }

            objectInfo = objectReader.CreateReadObjectInfo(objectType, memberNames, null);
            if (!objectInfo.isSi)
                objectInfo.GetMemberTypes(memberNames);  // Check version match
        }

        internal ReadObjectInfo CreateObjectInfo(ref SerializationInfo si, ref Object[] memberData)
        {
            if (isInitObjectInfo)
            {
                isInitObjectInfo = false;
                objectInfo.InitDataStore(ref si, ref memberData);
                return objectInfo;
            }
            else
            {
                objectInfo.PrepareForReuse();
                objectInfo.InitDataStore(ref si, ref memberData);
                return objectInfo;
            }
        }


        // No member type information
        internal static ObjectMap Create(String name, Type objectType, String[] memberNames, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo)
        {
            return new ObjectMap(name, objectType, memberNames, objectReader, objectId, assemblyInfo);
        }

        // Member type information 
        internal static ObjectMap Create(String name, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, int[] memberAssemIds, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)
        {
            return new ObjectMap(name, memberNames, binaryTypeEnumA, typeInformationA, memberAssemIds, objectReader, objectId, assemblyInfo, assemIdToAssemblyTable);           
        }
    }

    // For each object or array being read off the stream, an ObjectProgress object is created. This object
    // keeps track of the progress of the parsing. When an object is being parsed, it keeps track of
    // the object member being parsed. When an array is being parsed it keeps track of the position within the
    // array.
    internal sealed class ObjectProgress : ITrace
    {
        internal static int opRecordIdCount = 1;
        internal int opRecordId;


        // Control
        internal bool isInitial;
        internal int count; //Progress count
        internal BinaryTypeEnum expectedType = BinaryTypeEnum.ObjectUrt;
        internal Object expectedTypeInformation = null;

        internal String name;
        internal InternalObjectTypeE objectTypeEnum = InternalObjectTypeE.Empty;
        internal InternalMemberTypeE memberTypeEnum;
        internal InternalMemberValueE memberValueEnum;
        internal Type dtType;   

        // Array Information
        internal int numItems;
        internal BinaryTypeEnum binaryTypeEnum;
        internal Object typeInformation;
        internal int nullCount;

        // Member Information
        internal int memberLength;
        internal BinaryTypeEnum[] binaryTypeEnumA;
        internal Object[] typeInformationA;
        internal String[] memberNames;
        internal Type[] memberTypes;

        // ParseRecord
        internal ParseRecord pr = new ParseRecord();


        internal ObjectProgress()
        {
            Counter();
        }

        [Conditional("SER_LOGGING")]                                    
        private void Counter()
        {
            lock(this) {
                opRecordId = opRecordIdCount++;
                if (opRecordIdCount > 1000)
                    opRecordIdCount = 1;
            }
        }

        internal void Init()
        {
            isInitial = false;
            count = 0;
            expectedType = BinaryTypeEnum.ObjectUrt;
            expectedTypeInformation = null;

            name = null;
            objectTypeEnum = InternalObjectTypeE.Empty;
            memberTypeEnum = InternalMemberTypeE.Empty;
            memberValueEnum = InternalMemberValueE.Empty;
            dtType = null;  

            // Array Information
            numItems = 0;
            nullCount = 0;
            //binaryTypeEnum
            typeInformation = null;

            // Member Information
            memberLength = 0;
            binaryTypeEnumA = null;
            typeInformationA = null;
            memberNames = null;
            memberTypes = null;

            pr.Init();
        }

        //Array item entry of nulls has a count of nulls represented by that item. The first null has been 
        // incremented by GetNext, the rest of the null counts are incremented here
        internal void ArrayCountIncrement(int value)
        {
            count += value;
        }

        // Specifies what is to parsed next from the wire.
        internal bool GetNext(out BinaryTypeEnum outBinaryTypeEnum, out Object outTypeInformation)  
        {
            //@CoolPort
            //Initialize the out params up here.
            //Investigate to see if there's a more efficient way.
            outBinaryTypeEnum = BinaryTypeEnum.Primitive;
            outTypeInformation = null;

            SerTrace.Log( this, "GetNext Entry");
            Dump();

            if (objectTypeEnum == InternalObjectTypeE.Array)
            {
                SerTrace.Log( this, "GetNext Array");                   
                // Array
                if (count == numItems)
                    return false;
                else
                {
                    outBinaryTypeEnum =  binaryTypeEnum;
                    outTypeInformation = typeInformation;
                    if (count == 0)
                        isInitial = false;
                    count++;
                    SerTrace.Log( this, "GetNext Array Exit ",((Enum)outBinaryTypeEnum).ToString()," ",outTypeInformation);                                 
                    return true;
                }
            }
            else
            {
                // Member
                SerTrace.Log( this, "GetNext Member");                              
                if ((count == memberLength) && (!isInitial))
                    return false;
                else
                {
                    outBinaryTypeEnum = binaryTypeEnumA[count];
                    outTypeInformation = typeInformationA[count];
                    if (count == 0)
                        isInitial = false;
                    name = memberNames[count];
                    if (memberTypes == null)
                    {
                        SerTrace.Log( this, "GetNext memberTypes = null");
                    }
                    dtType = memberTypes[count];
                    count++;
                    SerTrace.Log( this, "GetNext Member Exit ",((Enum)outBinaryTypeEnum).ToString()," ",outTypeInformation," memberName ",name);                    
                    return true;
                }
            }
        }

        // Get a String describing the ObjectProgress Record
        public  String Trace()
        {
            return "ObjectProgress "+opRecordId+" name "+Util.PString(name)+" expectedType "+((Enum)expectedType).ToString();
        }

        // Dump contents of record

        [Conditional("SER_LOGGING")]                            
        internal  void Dump()
        {
            try
            {
                SerTrace.Log("ObjectProgress Dump ");
                Util.NVTrace("opRecordId", opRecordId);
                Util.NVTrace("isInitial", isInitial);
                Util.NVTrace("count", count);
                Util.NVTrace("expectedType", ((Enum)expectedType).ToString());
                Util.NVTrace("expectedTypeInformation", expectedTypeInformation);
                SerTrace.Log("ParseRecord Information");
                Util.NVTrace("name", name);
                Util.NVTrace("objectTypeEnum",((Enum)objectTypeEnum).ToString());
                Util.NVTrace("memberTypeEnum",((Enum)memberTypeEnum).ToString());
                Util.NVTrace("memberValueEnum",((Enum)memberValueEnum).ToString());
                if (dtType != null)
                    Util.NVTrace("dtType", dtType.ToString());
                SerTrace.Log("Array Information");
                Util.NVTrace("numItems", numItems);
                Util.NVTrace("binaryTypeEnum",((Enum)binaryTypeEnum).ToString());
                Util.NVTrace("typeInformation", typeInformation);
                SerTrace.Log("Member Information");
                Util.NVTrace("memberLength", memberLength);
                if (binaryTypeEnumA != null)
                {
                    for (int i=0; i<memberLength; i++)
                        Util.NVTrace("binaryTypeEnumA",((Enum)binaryTypeEnumA[i]).ToString());
                }
                if (typeInformationA != null)
                {
                    for (int i=0; i<memberLength; i++)
                        Util.NVTrace("typeInformationA", typeInformationA[i]);
                }
                if (memberNames != null)
                {
                    for (int i=0; i<memberLength; i++)
                        Util.NVTrace("memberNames", memberNames[i]);
                }
                if (memberTypes != null)
                {
                    for (int i=0; i<memberLength; i++)
                        Util.NVTrace("memberTypes", memberTypes[i].ToString());
                }
            }
            catch (Exception e)
            {
                BCLDebug.Log("[ObjectProgress.Dump]Unable to Dump Object Progress.");
                BCLDebug.Log("[ObjectProgress.Dump]Error: "+e);
            }
        }
    }

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryobjectwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: ObjectWriter
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Serializes an object graph into XML in SOAP format
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Binary
{    
    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;        
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Security;
    using System.Diagnostics;

    internal sealed  class ObjectWriter
    {
        private Queue m_objectQueue;
        private ObjectIDGenerator m_idGenerator;
        private int m_currentId;

        private Stream m_stream;
        private ISurrogateSelector m_surrogates;
        private StreamingContext m_context;
        private __BinaryWriter serWriter;

        private long topId;
        private String topName = null;
        private Header[] headers;

        private InternalFE formatterEnums;

        private SerObjectInfoInit serObjectInfoInit = null;

        private IFormatterConverter m_formatterConverter;

        // Default header name space
        private String headerNameSpaceName = "h";
        private String headerNameSpace = "urn:schemas-microsoft-com:urtdisplay.v1";

        internal Object[] crossAppDomainArray = null;
        internal ArrayList internalCrossAppDomainArray = null;


        // XMLObjectWriter Constructor
        internal ObjectWriter(Stream stream, ISurrogateSelector selector, StreamingContext context,InternalFE formatterEnums)
        {
            if (stream==null)
            {
                throw new ArgumentNullException("stream", Environment.GetResourceString("ArgumentNull_Stream"));                
            }

            m_currentId = 1;
            m_stream=stream;
            m_surrogates = selector;
            m_context = context;
            this.formatterEnums = formatterEnums;
            SerTrace.InfoLog(
                            formatterEnums.FEtypeFormat +" "+
                            ((Enum)formatterEnums.FEserializerTypeEnum));


        }

        // Commences the process of serializing the entire graph.
        // initialize the graph walker.
        internal void Serialize(Object graph, Header[] inHeaders, __BinaryWriter serWriter, bool fCheck)
        {
            SerTrace.Log( this, "Serialize Entry 2 ",graph,((headers == null)?" no headers ": "headers "));

            if (fCheck)
            {
                CodeAccessPermission.DemandInternal(PermissionType.SecuritySerialization);          
            }

            if (graph == null)
                throw new ArgumentNullException("graph",Environment.GetResourceString("ArgumentNull_Graph"));

            if (serWriter == null)
                throw new ArgumentNullException("serWriter",String.Format(Environment.GetResourceString("ArgumentNull_WithParamName"), "serWriter"));

            this.serWriter = serWriter;
            this.headers = inHeaders;

            SerTrace.Log( this, "Serialize New SerializedTypeTable");
            serWriter.WriteBegin();
            long headerId = 0;
            Object obj;
            long objectId;
            bool isNew;
            bool bMethodCall = false;
            bool bMethodReturn = false;

            // Special case IMethodCallMessage and IMethodReturnMessage for performance
            IMethodCallMessage mess = graph as IMethodCallMessage;
            if (mess != null)
            {
                bMethodCall = true;
                graph = WriteMethodCall(mess);
            }
            else
            {
                IMethodReturnMessage mr = graph as IMethodReturnMessage;
                if (mr != null)
                {
                    bMethodReturn = true;
                    graph = WriteMethodReturn(mr);
                }
            }

            if (graph == null)
            {
                WriteSerializedStreamHeader(topId, headerId);

                if (bMethodCall)
                    serWriter.WriteMethodCall();
                else if (bMethodReturn)
                    serWriter.WriteMethodReturn();

                serWriter.WriteSerializationHeaderEnd();
                serWriter.WriteEnd();
                return;
            }

            // allocations if methodCall or methodResponse and no graph
            m_idGenerator = new ObjectIDGenerator();
            m_objectQueue = new Queue();
            m_formatterConverter = new FormatterConverter();
            serObjectInfoInit = new SerObjectInfoInit();        

            if (IsCrossAppDomain())
            {
                //internalCrossAppDomainArray = new SizedArray(100);
                internalCrossAppDomainArray = new ArrayList(100);
            }

            topId = InternalGetId(graph, false, null, out isNew);

            if (headers != null)
                headerId = InternalGetId(headers, false, null, out isNew);
            else
                headerId = -1;

            WriteSerializedStreamHeader(topId, headerId);


            if (bMethodCall)
                serWriter.WriteMethodCall();
            else if (bMethodReturn)
                serWriter.WriteMethodReturn();


            SerTrace.Log( this, "Serialize Schedule 0");

            // Write out SerializedStream header
            if ((headers != null) && (headers.Length > 0))
                m_objectQueue.Enqueue(headers);                 

            if (graph != null)
                m_objectQueue.Enqueue(graph);
            
            while ((obj = GetNext(out objectId))!=null)
            {
                SerTrace.Log( this, "Serialize GetNext ",obj);
                WriteObjectInfo objectInfo = null;

                // GetNext will return either an object or a WriteObjectInfo. 
                // A WriteObjectInfo is returned if this object was member of another object
                if (obj is WriteObjectInfo)
                {
                    SerTrace.Log( this, "Serialize GetNext recognizes WriteObjectInfo");
                    objectInfo = (WriteObjectInfo)obj;
                }
                else
                {
                    objectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter);
                    objectInfo.assemId = GetAssemblyId(objectInfo);
                }


                objectInfo.objectId = objectId;
                NameInfo typeNameInfo = TypeToNameInfo(objectInfo);
                Write(objectInfo, typeNameInfo, typeNameInfo);
                PutNameInfo(typeNameInfo);
                objectInfo.ObjectEnd();
            }

            serWriter.WriteSerializationHeaderEnd();
            serWriter.WriteEnd();

            if (IsCrossAppDomain())
            {
                crossAppDomainArray = internalCrossAppDomainArray.ToArray();
            }
            SerTrace.Log( this, "Serialize Exit ");
        }

        private Object[] WriteMethodCall(IMethodCallMessage mcm)
        {
            // In header
            String uri = mcm.Uri;
            String methodName = mcm.MethodName;
            String typeName = mcm.TypeName;

            // Optional
            Object methodSignature = null;
            Object callContext = null;
            Object[] properties = null;

            // args
            Object[] args = mcm.Args;

            IInternalMessage iim = mcm as IInternalMessage;

            // user properties (everything but special entries)
            if ((iim == null) || iim.HasProperties())
                properties = StoreUserPropertiesForMethodMessage(mcm);

            // handle method signature
            if (mcm.MethodSignature != null && RemotingServices.IsMethodOverloaded(mcm))
                methodSignature = mcm.MethodSignature;

            // handle call context
            LogicalCallContext lcc = mcm.LogicalCallContext;
            if (lcc == null)
            {
                callContext = null;
            }
            else if (lcc.HasInfo)
                callContext = lcc;
            else
            {
                // just smuggle the call id string
                callContext = lcc.RemotingData.LogicalCallID;
            }

            return serWriter.WriteCallArray(uri, methodName, typeName, args, methodSignature, callContext, properties);
        }


        private Object[] WriteMethodReturn(IMethodReturnMessage mrm)
        {
            Object    returnValue = mrm.ReturnValue;
            Object[]  args = mrm.Args;
            Exception exception = mrm.Exception;
            Object callContext;
            Object[] properties = null;

            ReturnMessage retMsg = mrm as ReturnMessage;

            // user properties (everything but special entries)
            if ((retMsg == null) || retMsg.HasProperties())
                properties = StoreUserPropertiesForMethodMessage(mrm);

            // handle call context
            LogicalCallContext lcc = mrm.LogicalCallContext;
            if (lcc == null)
            {
                callContext = null;
            }
            else if (lcc.HasInfo)
                callContext = lcc;
            else
            {
                // just smuggle the call id string
                callContext = lcc.RemotingData.LogicalCallID;
            }

           return serWriter.WriteReturnArray(returnValue, args, exception, callContext, properties);
        }

        // returns number of entries added to argsToSerialize
        private static Object[] StoreUserPropertiesForMethodMessage(IMethodMessage msg)
        {
            ArrayList argsToSerialize = null;
            IDictionary properties = msg.Properties;

            if (properties == null)
                return null;

            MessageDictionary dict = properties as MessageDictionary;
            if (dict != null)
            {
                if (dict.HasUserData())
                {
                    int co = 0;
                    foreach (DictionaryEntry entry in dict.InternalDictionary)
                    {
                        if (argsToSerialize == null)
                            argsToSerialize = new ArrayList();
                        argsToSerialize.Add(entry);
                        co++;
                    }

                    return argsToSerialize.ToArray();
                }
                else
                {
                    return null;
                }
            }
            else
            {
                // Future: For now, I just copy everything over. In the future,
                //   I should exclude special headers such as __Uri, as those
                //   are transferred through other means.
                int co = 0;
                foreach (DictionaryEntry entry in properties)
                {
                    if (argsToSerialize == null)
                        argsToSerialize = new ArrayList();
                    argsToSerialize.Add(entry);
                    co++;
                }

                if (argsToSerialize != null)
                    return argsToSerialize.ToArray();
                else
                    return null;
            }

        } // StoreUserPropertiesForMethodMessage


        bool bIsCrossAppDomain = false;
        bool bIsCrossAppDomainInit = false;
        internal bool IsCrossAppDomain()
        {
            /*
            if (!bIsCrossAppDomainInit)
            {
                bIsCrossAppDomain = (m_context.State == StreamingContextStates.CrossAppDomain);
                bIsCrossAppDomainInit = true;
            }
            return bIsCrossAppDomain;
            */
            // Always return false for now, so that smuggling is turned off.
            return false;
        }

        internal int CrossAppDomainArrayAdd(Object obj)
        {
            BCLDebug.Assert(IsCrossAppDomain(), 
                            "[System.Runtime.Serialization.Formatters.BinaryObjectWriter StreamingContext is not crossAppDomainArray]");
            internalCrossAppDomainArray.Add(obj);
            return internalCrossAppDomainArray.Count-1;

        }


        // Writes a given object to the stream.
        private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo)
        {       
            SerTrace.Log( this, "Write 1 Entry objectInfo ",objectInfo,", memberNameInfo ",memberNameInfo,", typeNameInfo ",typeNameInfo);
            memberNameInfo.Dump("Write memberNameInfo");
            typeNameInfo.Dump("Write typeNameInfo");
            Object obj = objectInfo.obj;
            if (obj==null)
                throw new ArgumentNullException("objectInfo.obj", Environment.GetResourceString("ArgumentNull_Obj"));

            SerTrace.Log( this, "Write 1 objectInfo obj ",objectInfo.obj," objectId ", objectInfo.objectId, " objectType ", objectInfo.objectType);
            Type objType = objectInfo.objectType;
            long objectId = objectInfo.objectId;


            SerTrace.Log( this, "Write 1 ",obj," ObjectId ",objectId);

            if (objType == Converter.typeofString)
            {
                // Top level String
                memberNameInfo.NIobjectId = objectId;
                serWriter.WriteObjectString((int)objectId, obj.ToString());
            }
            else
            {

                if (objectInfo.isArray)
                {
                    WriteArray(objectInfo, memberNameInfo, null); 
                }
                else
                {
                    String[] memberNames;
                    Type[] memberTypes;
                    Object[] memberData;

                    objectInfo.GetMemberInfo(out memberNames, out memberTypes, out memberData);

                    // Only Binary needs to transmit types for ISerializable because the binary formatter transmits the types in URT format.
                    // Soap transmits all types as strings, so it is up to the ISerializable object to convert the string back to its URT type
                    if (objectInfo.isSi || CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))
                    {
                        SerTrace.Log( this, "Write 1 TransmitOnObject ");
                        memberNameInfo.NItransmitTypeOnObject = true;
                        memberNameInfo.NIisParentTypeOnObject = true;
                        typeNameInfo.NItransmitTypeOnObject = true;
                        typeNameInfo.NIisParentTypeOnObject = true;                                             
                    }

                    WriteObjectInfo[] memberObjectInfos = new WriteObjectInfo[memberNames.Length];

                    // Get assembly information
                    // Binary Serializer, assembly names need to be
                    // written before objects are referenced.
                    // GetAssemId here will write out the
                    // assemblyStrings at the right Binary
                    // Serialization object boundary.
                    for (int i=0; i<memberTypes.Length; i++)
                    {
                        Type type;
                        if (memberTypes[i] != null)
                            type = memberTypes[i];
                        else if (memberData[i] != null)
                            type = GetType(memberData[i]);
                        else
                            type = Converter.typeofObject;

                        SerTrace.Log( this, "Write 1 member type ",type);
                        InternalPrimitiveTypeE code = ToCode(type);
                        if ((code == InternalPrimitiveTypeE.Invalid) &&
                            (type != Converter.typeofString))
                        {
                            SerTrace.Log( this, "Write 1 Create ObjectInfo ", memberTypes[i], " memberData ",memberData[i]);
                            if (memberData[i] != null)
                            {
                                memberObjectInfos[i] =
                                WriteObjectInfo.Serialize
                                (
                                memberData[i],
                                m_surrogates,
                                m_context,
                                serObjectInfoInit,
                                m_formatterConverter
                                );                                    
                                memberObjectInfos[i].assemId = GetAssemblyId(memberObjectInfos[i]);
                            }
                            else
                            {
                                memberObjectInfos[i] =
                                WriteObjectInfo.Serialize
                                (
                                memberTypes[i],
                                m_surrogates,
                                m_context,
                                serObjectInfoInit,
                                m_formatterConverter
                                );
                                memberObjectInfos[i].assemId = GetAssemblyId(memberObjectInfos[i]);
                            }
                        }
                    }
                    Write(objectInfo, memberNameInfo, typeNameInfo, memberNames, memberTypes, memberData, memberObjectInfos);
                    SerTrace.Log( this, "Write 1 ",obj," type ",GetType(obj));     
                }
            }
            SerTrace.Log( this, "Write 1 Exit ",obj);       
        }

        // Writes a given object to the stream.
        private void Write(WriteObjectInfo objectInfo,   
                           NameInfo memberNameInfo,          
                           NameInfo typeNameInfo,            
                           String[] memberNames,             
                           Type[] memberTypes,               
                           Object[] memberData,              
                           WriteObjectInfo[] memberObjectInfos)
        {
            SerTrace.Log( this, "Write 2 Entry obj ",objectInfo.obj,". objectId ",objectInfo.objectId,", objType ",typeNameInfo.NIname,", memberName ",memberNameInfo.NIname,", memberType ",typeNameInfo.NIname);

            int numItems = memberNames.Length;
            NameInfo topNameInfo = null;

            if (memberNameInfo != null)
            {
                SerTrace.Log( this, "Write 2 ObjectBegin, memberName ",memberNameInfo.NIname);
                memberNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObject(memberNameInfo, typeNameInfo, numItems, memberNames, memberTypes, memberObjectInfos);
            }
            else if ((objectInfo.objectId == topId) && (topName != null))
            {
                SerTrace.Log( this, "Write 2 ObjectBegin, topId method name ",topName);
                topNameInfo = MemberToNameInfo(topName);
                topNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObject(topNameInfo, typeNameInfo, numItems, memberNames, memberTypes, memberObjectInfos);
            }
            else
            {
                if (objectInfo.objectType != Converter.typeofString)
                {
                    SerTrace.Log( this, "Write 2 ObjectBegin, default ", typeNameInfo.NIname);
                    typeNameInfo.NIobjectId = objectInfo.objectId;
                    serWriter.WriteObject(typeNameInfo, null, numItems, memberNames, memberTypes, memberObjectInfos);
                }
            }

            if (memberNameInfo.NIisParentTypeOnObject)
            {
                memberNameInfo.NItransmitTypeOnObject = true;
                memberNameInfo.NIisParentTypeOnObject = false;
            }
            else
                memberNameInfo.NItransmitTypeOnObject = false;


            // Write members
            for (int i=0; i<numItems; i++)
            {
                WriteMemberSetup(objectInfo, memberNameInfo, typeNameInfo, memberNames[i], memberTypes[i], memberData[i], memberObjectInfos[i]);
            }

            if (memberNameInfo != null)
            {
                memberNameInfo.NIobjectId = objectInfo.objectId;
                serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo);
            }
            else if ((objectInfo.objectId == topId) && (topName != null))
            {
                serWriter.WriteObjectEnd(topNameInfo, typeNameInfo);
                PutNameInfo(topNameInfo);
            }
            else
            {
                if (objectInfo.objectType != Converter.typeofString)
                {
                    String objectName = objectInfo.GetTypeFullName();
                    serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo);                       
                }
            }

            SerTrace.Log( this, "Write 2 Exit");
        }

        private void WriteMemberSetup(WriteObjectInfo objectInfo,        
                                      NameInfo memberNameInfo,           
                                      NameInfo typeNameInfo,             
                                      String memberName,             
                                      Type memberType,               
                                      Object memberData,                 
                                      WriteObjectInfo memberObjectInfo
                                     )
        {
            NameInfo newMemberNameInfo = MemberToNameInfo(memberName);
            // newMemberNameInfo contains the member type

            if (memberObjectInfo != null)
                newMemberNameInfo.NIassemId = memberObjectInfo.assemId;
            newMemberNameInfo.NItype = memberType;

            // newTypeNameInfo contains the data type
            NameInfo newTypeNameInfo = null;
            if (memberObjectInfo == null)
            {
                newTypeNameInfo = TypeToNameInfo(memberType);
            }
            else
            {
                newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
            }

            newMemberNameInfo.NItransmitTypeOnObject = memberNameInfo.NItransmitTypeOnObject;
            newMemberNameInfo.NIisParentTypeOnObject = memberNameInfo.NIisParentTypeOnObject;               
            WriteMembers(newMemberNameInfo, newTypeNameInfo, memberData, objectInfo, typeNameInfo, memberObjectInfo);
            PutNameInfo(newMemberNameInfo);
            PutNameInfo(newTypeNameInfo);
        }


        // Writes the members of an object
        private void WriteMembers(NameInfo memberNameInfo,
                                  NameInfo memberTypeNameInfo,
                                  Object   memberData,
                                  WriteObjectInfo objectInfo,
                                  NameInfo typeNameInfo,
                                  WriteObjectInfo memberObjectInfo
                                 )
        {
            SerTrace.Log( this, "WriteMembers Entry memberType: ",memberTypeNameInfo.NIname," memberName: ",memberNameInfo.NIname," data: ",memberData," objectId: ",objectInfo.objectId, " Container object ",objectInfo.obj, " memberObjectinfo ",memberObjectInfo);
            Type memberType = memberNameInfo.NItype;
            bool assignUniqueIdToValueType = false;

            // Types are transmitted for a member as follows:
            // The member is of type object
            // The member object of type is ISerializable and
            //  Binary - Types always transmitted.

            if (memberType == Converter.typeofObject)
            {
                memberTypeNameInfo.NItransmitTypeOnMember  = true;
                memberNameInfo.NItransmitTypeOnMember  = true;              
            }

            if (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways) || (objectInfo.isSi))
            {
                memberTypeNameInfo.NItransmitTypeOnObject  = true;
                memberNameInfo.NItransmitTypeOnObject  = true;
                memberNameInfo.NIisParentTypeOnObject = true;
            }

            if (CheckForNull(objectInfo, memberNameInfo, memberTypeNameInfo, memberData))
            {
                return;
            }

            Object outObj = memberData;
			Type outType = null;

            // If member type does not equal data type, transmit type on object.
            if (memberTypeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Invalid)
			{
                outType = GetType(outObj);
                if (memberType != outType)
                {
                    memberTypeNameInfo.NItransmitTypeOnMember  = true;
                    memberNameInfo.NItransmitTypeOnMember  = true;    
                }
            }

            if (memberType == Converter.typeofObject)
            {
                assignUniqueIdToValueType = true;
                memberType = GetType(memberData);
                if (memberObjectInfo == null)
                    TypeToNameInfo(memberType, memberTypeNameInfo);
                else
                    TypeToNameInfo(memberObjectInfo, memberTypeNameInfo);                   
                SerTrace.Log( this, "WriteMembers memberType Object, actual memberType ",memberType);                                                                               
            }

            if (memberObjectInfo != null && memberObjectInfo.isArray)
            {
                // Array
                SerTrace.Log( this, "WriteMembers IsArray");

                long arrayId = 0;
				if (outType == null)
					outType = GetType(outObj);
                // outObj is an array. It can never be a value type..
                arrayId = Schedule(outObj, false, null, memberObjectInfo);
                if (arrayId > 0)
                {
                    // Array as object
                    SerTrace.Log( this, "WriteMembers Schedule 3");
                    memberNameInfo.NIobjectId = arrayId;
                    WriteObjectRef(memberNameInfo, arrayId); 
                }
                else
                {
                    // Nested Array
                    serWriter.WriteMemberNested(memberNameInfo);

                    memberObjectInfo.objectId = arrayId;
                    memberNameInfo.NIobjectId = arrayId;
                    WriteArray(memberObjectInfo, memberNameInfo, memberObjectInfo);
                    objectInfo.ObjectEnd();

                }
                SerTrace.Log( this, "WriteMembers Array Exit ");
                return;
            }

            if (!WriteKnownValueClass(memberNameInfo, memberTypeNameInfo, memberData))
            {
                SerTrace.Log( this, "WriteMembers Object ",memberData);

                // Value or NO_ID, need to explicitly check for IsValue because a top level
                // value class has an objectId of 1
                /*
                if (memberType.IsValueType)
                {
                    SerTrace.Log( this, "WriteMembers Value Type or NO_ID parameter");

                    bool isNew;
                    memberObjectInfo.objectId = InternalGetId(outObj, assignUniqueIdToValueType, memberType, out isNew) ;
                    NameInfo newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
                    newTypeNameInfo.NIobjectId = memberObjectInfo.objectId;
                    Write( memberObjectInfo, memberNameInfo, newTypeNameInfo);
                    PutNameInfo(newTypeNameInfo);
                    memberObjectInfo.ObjectEnd();
                }
                else
                */
                {
                    SerTrace.Log( this, "WriteMembers Schedule 4 ", outType, " memberInfo ",memberObjectInfo);
					if (outType == null)
						outType = GetType(outObj);
                    long memberObjectId = Schedule(outObj, assignUniqueIdToValueType, outType, memberObjectInfo);
                    if (memberObjectId < 0)
                    {
                        // Nested object
                        SerTrace.Log( this, "WriteMembers Nesting");

                        memberObjectInfo.objectId = memberObjectId;
                        NameInfo newTypeNameInfo = TypeToNameInfo(memberObjectInfo);
                        newTypeNameInfo.NIobjectId = memberObjectId;
                        Write(memberObjectInfo, memberNameInfo, newTypeNameInfo);
                        PutNameInfo(newTypeNameInfo);
                        memberObjectInfo.ObjectEnd();
                    }
                    else
                    {
                        // Object reference
                        memberNameInfo.NIobjectId = memberObjectId;
                        WriteObjectRef(memberNameInfo, memberObjectId); 
                    }
                }
            }

            SerTrace.Log( this, "WriteMembers Exit ");
        }

        // Writes out an array
        private void WriteArray(WriteObjectInfo objectInfo, NameInfo memberNameInfo, WriteObjectInfo memberObjectInfo)          
        {
            SerTrace.Log( this, "WriteArray Entry ",objectInfo.obj," ",objectInfo.objectId);

            bool isAllocatedMemberNameInfo = false;
            if (memberNameInfo == null)
            {
                memberNameInfo = TypeToNameInfo(objectInfo);
                isAllocatedMemberNameInfo = true;
            }

            memberNameInfo.NIisArray = true;

            long objectId = objectInfo.objectId;
            memberNameInfo.NIobjectId = objectInfo.objectId;

            // Get array type
            System.Array array = (System.Array)objectInfo.obj;
            //Type arrayType = array.GetType();
            Type arrayType = objectInfo.objectType;         

            // Get type of array element 
            Type arrayElemType = arrayType.GetElementType();
            WriteObjectInfo arrayElemObjectInfo = null;
            if (!arrayElemType.IsPrimitive)
            {
                arrayElemObjectInfo = WriteObjectInfo.Serialize(arrayElemType, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter);
                arrayElemObjectInfo.assemId = GetAssemblyId(arrayElemObjectInfo);
            }


            NameInfo arrayElemTypeNameInfo = null;
            if (arrayElemObjectInfo == null)
                arrayElemTypeNameInfo = TypeToNameInfo(arrayElemType);
            else
                arrayElemTypeNameInfo = TypeToNameInfo(arrayElemObjectInfo);
            arrayElemTypeNameInfo.NIisArray = arrayElemTypeNameInfo.NItype.IsArray;

            NameInfo arrayNameInfo = memberNameInfo;
            arrayNameInfo.NIobjectId = objectId;
            arrayNameInfo.NIisArray = true;
            arrayElemTypeNameInfo.NIobjectId = objectId;
            arrayElemTypeNameInfo.NItransmitTypeOnMember = memberNameInfo.NItransmitTypeOnMember;
            arrayElemTypeNameInfo.NItransmitTypeOnObject = memberNameInfo.NItransmitTypeOnObject;
            arrayElemTypeNameInfo.NIisParentTypeOnObject = memberNameInfo.NIisParentTypeOnObject;

            // Get rank and length information
            int rank = array.Rank;
            int[] lengthA = new int[rank];
            int[] lowerBoundA = new int[rank];
            int[] upperBoundA = new int[rank];                  
            for (int i=0; i<rank; i++)
            {
                lengthA[i] = array.GetLength(i);
                lowerBoundA[i] = array.GetLowerBound(i);
                upperBoundA[i] = array.GetUpperBound(i);                            
            }

            InternalArrayTypeE arrayEnum;

            if (arrayElemTypeNameInfo.NIisArray)
            {
                if (rank == 1)
                    arrayEnum = InternalArrayTypeE.Jagged;
                else
                    arrayEnum = InternalArrayTypeE.Rectangular;
            }
            else if (rank == 1)
                arrayEnum = InternalArrayTypeE.Single;
            else
                arrayEnum = InternalArrayTypeE.Rectangular;

            arrayElemTypeNameInfo.NIarrayEnum = arrayEnum;

            SerTrace.Log( this, "WriteArray ArrayInfo type ",arrayType," rank ",rank);


            // Byte array
            if ((arrayElemType == Converter.typeofByte) && (rank == 1) && (lowerBoundA[0] == 0))
            {
                serWriter.WriteObjectByteArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0], (byte[])array);
                return;
            }

            if (arrayElemType == Converter.typeofObject)
            {
                memberNameInfo.NItransmitTypeOnMember = true;
                arrayElemTypeNameInfo.NItransmitTypeOnMember = true;
            }

            if (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))
            {
                memberNameInfo.NItransmitTypeOnObject = true;
                arrayElemTypeNameInfo.NItransmitTypeOnObject = true;                
            }

            if (arrayEnum == InternalArrayTypeE.Single)
            {
                // Single Dimensional array
                SerTrace.Log( this, "WriteArray ARRAY_SINGLE ");

                // BinaryFormatter array of primitive types is written out in the WriteSingleArray statement
                // as a byte buffer
                serWriter.WriteSingleArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0], array);

                if (!(Converter.IsWriteAsByteArray(arrayElemTypeNameInfo.NIprimitiveTypeEnum) && (lowerBoundA[0] == 0)))
                {
                    Object[] objectA = null;
                    if (!arrayElemType.IsValueType)
                    {
                        // Non-primitive type array					
                        objectA = (Object[])array;
                    }

                    int upperBound = upperBoundA[0]+1;
                    for (int i = lowerBoundA[0]; i < upperBound; i++)
                    {
                        if (objectA == null)
                            WriteArrayMember(objectInfo, arrayElemTypeNameInfo, array.GetValue(i));
                        else
                            WriteArrayMember(objectInfo, arrayElemTypeNameInfo, objectA[i]);
                    }
                    serWriter.WriteItemEnd();
                }
            }
            else if (arrayEnum == InternalArrayTypeE.Jagged)
            {
                // Jagged Array
                SerTrace.Log( this, "WriteArray ARRAY_JAGGED");

                arrayNameInfo.NIobjectId = objectId;

                serWriter.WriteJaggedArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, lengthA[0], lowerBoundA[0]);

                Object[] objectA = (Object[])array;
                for (int i = lowerBoundA[0]; i < upperBoundA[0]+1; i++)
                {
                    WriteArrayMember(objectInfo, arrayElemTypeNameInfo, objectA[i]);
                }
                serWriter.WriteItemEnd();
            }
            else
            {
                // Rectangle Array
                // Get the length for all the ranks
                SerTrace.Log( this, "WriteArray ARRAY_RECTANGLE");                      

                arrayNameInfo.NIobjectId = objectId;
                serWriter.WriteRectangleArray(memberNameInfo, arrayNameInfo, arrayElemObjectInfo, arrayElemTypeNameInfo, rank, lengthA, lowerBoundA);

                IndexTraceMessage("WriteArray Rectangle  ", lengthA);

                // Check for a length of zero
                bool bzero = false;
                for (int i=0; i<rank; i++)
                {
                    if (lengthA[i] == 0)
                    {
                        bzero = true;
                        break;
                    }
                }

                if (!bzero)
                    WriteRectangle(objectInfo, rank, lengthA, array, arrayElemTypeNameInfo, lowerBoundA);
                serWriter.WriteItemEnd();
            }

            serWriter.WriteObjectEnd(memberNameInfo, arrayNameInfo); 

            PutNameInfo(arrayElemTypeNameInfo);
            if (isAllocatedMemberNameInfo)
                PutNameInfo(memberNameInfo);

            SerTrace.Log( this, "WriteArray Exit ");
        }

        // Writes out an array element
        private void WriteArrayMember(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, Object data)
        {
            SerTrace.Log( this, "WriteArrayMember ",data," baseArrayName ",arrayElemTypeNameInfo.NIname);

            arrayElemTypeNameInfo.NIisArrayItem = true;

            if (CheckForNull(objectInfo, arrayElemTypeNameInfo, arrayElemTypeNameInfo, data))
                return;

            NameInfo actualTypeInfo = null;

            Type dataType = null;

            bool isObjectOnMember = false;

            if (arrayElemTypeNameInfo.NItransmitTypeOnMember)
                isObjectOnMember = true;

            if (!isObjectOnMember && !arrayElemTypeNameInfo.IsSealed)
            {
                dataType = GetType(data);
                if (arrayElemTypeNameInfo.NItype != dataType)
                    isObjectOnMember = true;
            }

            if (isObjectOnMember)
            {
                // Object array, need type of member
                if (dataType == null)
                    dataType = GetType(data);
                actualTypeInfo = TypeToNameInfo(dataType);
                actualTypeInfo.NItransmitTypeOnMember = true;
                actualTypeInfo.NIobjectId = arrayElemTypeNameInfo.NIobjectId;
                actualTypeInfo.NIassemId = arrayElemTypeNameInfo.NIassemId;
                actualTypeInfo.NIisArrayItem = true;
            }
            else
            {
                actualTypeInfo = arrayElemTypeNameInfo;
                actualTypeInfo.NIisArrayItem = true;
            }

            if (!WriteKnownValueClass(arrayElemTypeNameInfo, actualTypeInfo, data))
            {
                Object obj = data;
                bool assignUniqueIdForValueTypes = false;
                if (arrayElemTypeNameInfo.NItype == Converter.typeofObject)
                    assignUniqueIdForValueTypes = true;

                long arrayId = Schedule(obj, assignUniqueIdForValueTypes, actualTypeInfo.NItype);
                arrayElemTypeNameInfo.NIobjectId = arrayId;
                actualTypeInfo.NIobjectId = arrayId;
                if (arrayId < 1)
                {
                        WriteObjectInfo newObjectInfo = WriteObjectInfo.Serialize(obj, m_surrogates, m_context, serObjectInfoInit, m_formatterConverter);
                        newObjectInfo.objectId = arrayId;
                        if (!assignUniqueIdForValueTypes)
                            newObjectInfo.assemId = actualTypeInfo.NIassemId; 
                        else
                            newObjectInfo.assemId = GetAssemblyId(newObjectInfo);
                        SerTrace.Log( this, "WriteArrayMembers nested");
                        NameInfo typeNameInfo = TypeToNameInfo(newObjectInfo);
                        typeNameInfo.NIobjectId = arrayId;
                        newObjectInfo.objectId = arrayId;
                        Write(newObjectInfo, actualTypeInfo, typeNameInfo);

                        newObjectInfo.ObjectEnd();
                }
                else
                {
                    serWriter.WriteItemObjectRef(arrayElemTypeNameInfo, (int)arrayId);
                }

            }
            if (arrayElemTypeNameInfo.NItransmitTypeOnMember)
                PutNameInfo(actualTypeInfo);
        }


        // Iterates over a Rectangle array, for each element of the array invokes WriteArrayMember

        private void WriteRectangle(WriteObjectInfo objectInfo, int rank, int[] maxA, System.Array array, NameInfo arrayElemNameTypeInfo, int[] lowerBoundA)
        {
            IndexTraceMessage("WriteRectangle  Entry "+rank, maxA);
            int[] currentA = new int[rank];
            int[] indexMap = null;
            bool isLowerBound = false;
            if (lowerBoundA != null)
            {
                for (int i=0; i<rank; i++)
                {
                    if (lowerBoundA[i] != 0)
                        isLowerBound = true;
                }
            }
            if (isLowerBound)
                indexMap = new int[rank];

            bool isLoop = true;
            while (isLoop)
            {
                isLoop = false;
                if (isLowerBound)
                { 
                    for (int i=0; i<rank; i++)
                    {
                        indexMap[i] = currentA[i]+lowerBoundA[i];
                    }

                    WriteArrayMember(objectInfo, arrayElemNameTypeInfo, array.GetValue(indexMap));
                }
                else
                    WriteArrayMember(objectInfo, arrayElemNameTypeInfo, array.GetValue(currentA));          
                for (int irank = rank-1; irank>-1; irank--)
                {
                    // Find the current or lower dimension which can be incremented.
                    if (currentA[irank] < maxA[irank]-1)
                    {
                        // The current dimension is at maximum. Increase the next lower dimension by 1
                        currentA[irank]++;
                        if (irank < rank-1)
                        {
                            // The current dimension and higher dimensions are zeroed.
                            for (int i = irank+1; i<rank; i++)
                                currentA[i] = 0;
                        }
                        isLoop = true;
                        break;                  
                    }

                }
            }
            SerTrace.Log( this, "WriteRectangle  Exit ");
        }

        // Traces a message with an array of int
        [Conditional("SER_LOGGING")]                            
        private void IndexTraceMessage(String message, int[] index)
        {
            StringBuilder sb = new StringBuilder(10);
            sb.Append("[");     
            for (int i=0; i<index.Length; i++)
            {
                sb.Append(index[i]);
                if (i != index.Length -1)
                    sb.Append(",");
            }
            sb.Append("]");             
            SerTrace.Log( this, message+" ",sb.ToString());
        }


        // This gives back the next object to be serialized.  Objects
        // are returned in a FIFO order based on how they were passed
        // to Schedule.  The id of the object is put into the objID parameter
        // and the Object itself is returned from the function.
        private Object GetNext(out long objID)
        {
            SerTrace.Log( this, "GetNext Entry ");      
            bool isNew;

            //The Queue is empty here.  We'll throw if we try to dequeue the empty queue.
            if (m_objectQueue.Count==0)
            {
                objID=0;
                SerTrace.Log( this, "GetNext Exit null");
                return null;
            }

            Object obj = m_objectQueue.Dequeue();
            Object realObj = null;

            // A WriteObjectInfo is queued if this object was a member of another object
            SerTrace.Log( this, "GetNext ",obj);
            if (obj is WriteObjectInfo)
            {
                SerTrace.Log( this, "GetNext recognizes WriteObjectInfo");
                realObj = ((WriteObjectInfo)obj).obj;
            }
            else
                realObj = obj;
            objID = m_idGenerator.HasId(realObj, out isNew);
            if (isNew)
            {
                SerTrace.Log( this, "Object " , realObj , " has never been assigned an id.");
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjNoID"),realObj));                                                    
            }

            SerTrace.Log( this, "GetNext Exit "+objID," ",realObj);             

            return obj;
        }

        Object previousObj = null;
        long previousId = 0;
        // If the type is a value type, we dont attempt to generate a unique id, unless its a boxed entity
        // (in which case, there might be 2 references to the same boxed obj. in a graph.)
        // "assignUniqueIdToValueType" is true, if the field type holding reference to "obj" is Object.
        private long InternalGetId(Object obj, bool assignUniqueIdToValueType, Type type, out bool isNew)
        {
            if (obj == previousObj)
            {
                // very good for stupid benchmarks
                isNew = false;
                return previousId;
            }
            m_idGenerator.m_currentCount = m_currentId;
            if (type != null && type.IsValueType)
            {
                if (!assignUniqueIdToValueType)
                {
                    isNew = false;
                    return -1 * m_currentId++;
                }
            }
            m_currentId++;
            long retId = m_idGenerator.GetId(obj, out isNew);
            previousObj = obj;
            previousId = retId;
            return retId;
        }


        // Schedules an object for later serialization if it hasn't already been scheduled.
        // We get an ID for obj and put it on the queue for later serialization
        // if this is a new object id.

        private long Schedule(Object obj, bool assignUniqueIdToValueType, Type type)
        {
            return Schedule(obj, assignUniqueIdToValueType, type, null);
        }

        private long Schedule(Object obj, bool assignUniqueIdToValueType, Type type, WriteObjectInfo objectInfo)
        {
            SerTrace.Log( this, "Schedule Entry obj ",obj," type ", type, " objectInfo ",objectInfo);

            bool isNew;
            long id;

            if (obj==null)
            {
                SerTrace.Log(this, "Schedule Obj Null, id = 0 ");
                return 0;
            }

            id = InternalGetId(obj, assignUniqueIdToValueType, type, out isNew);           

            if (isNew && id > 0)
            {
                if (objectInfo == null)
                    m_objectQueue.Enqueue(obj);
                else
                    m_objectQueue.Enqueue(objectInfo);

            }

            SerTrace.Log( this, "Schedule Exit, id: ",id," isNew: ",isNew);     
            return id;
        }


        // Determines if a type is a primitive type, if it is it is written

        private bool WriteKnownValueClass(NameInfo memberNameInfo, NameInfo typeNameInfo, Object data) 
        {
            SerTrace.Log( this, "WriteKnownValueClass Entry ",typeNameInfo.NIname," ",data," ",memberNameInfo.NIname);
            memberNameInfo.Dump("WriteKnownValueClass memberNameInfo");         
            typeNameInfo.Dump("WriteKnownValueClass typeNameInfo");

            if (typeNameInfo.NItype == Converter.typeofString)
            {
                WriteString(memberNameInfo, typeNameInfo, data);
            }
            else
            {
                if (typeNameInfo.NIprimitiveTypeEnum == InternalPrimitiveTypeE.Invalid)
                {
                    SerTrace.Log( this, "WriteKnownValueClass Exit false");                     
                    return false;
                }
                else
                {
                    if (typeNameInfo.NIisArray) // null if an array
                        serWriter.WriteItem(memberNameInfo, typeNameInfo, data);
                    else
                    {
                        serWriter.WriteMember(memberNameInfo, typeNameInfo, data);
                    }
                }
            }

            SerTrace.Log( this, "WriteKnownValueClass Exit true");
            return true;
        }


        // Writes an object reference to the stream.
        private void WriteObjectRef(NameInfo nameInfo, long objectId)
        {
            SerTrace.Log( this, "WriteObjectRef Entry ",nameInfo.NIname," ",objectId);
            serWriter.WriteMemberObjectRef(nameInfo, (int)objectId);

            SerTrace.Log( this, "WriteObjectRef Exit ");
        }



        // Writes a string into the XML stream
        private void WriteString(NameInfo memberNameInfo, NameInfo typeNameInfo, Object stringObject)
        {
            SerTrace.Log( this, "WriteString stringObject ",stringObject," memberName ",memberNameInfo.NIname);
            bool isFirstTime = true;

            long stringId = -1;

            if (!CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.XsdString))
                stringId= InternalGetId(stringObject, false, null, out isFirstTime);

            typeNameInfo.NIobjectId = stringId;
            SerTrace.Log( this, "WriteString stringId ",stringId," isFirstTime ",isFirstTime);

            if ((isFirstTime) || (stringId < 0))
                serWriter.WriteMemberString(memberNameInfo, typeNameInfo, (String)stringObject);
            else
                WriteObjectRef(memberNameInfo, stringId);
        }

        // Writes a null member into the stream
        private bool CheckForNull(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, Object data)
        {
            SerTrace.Log( this, "CheckForNull Entry data ",Util.PString(data),", memberType ",Util.PString(typeNameInfo.NItype));
            bool isNull = false;

            if (data == null) // || Convert.IsDBNull(data)
                isNull = true;

            // Optimization, Null members are only written for Binary
            if ((isNull) && (((formatterEnums.FEserializerTypeEnum == InternalSerializerTypeE.Binary)) ||
                             memberNameInfo.NIisArrayItem ||
                             memberNameInfo.NItransmitTypeOnObject ||
                             memberNameInfo.NItransmitTypeOnMember ||
                             objectInfo.isSi ||
                             (CheckTypeFormat(formatterEnums.FEtypeFormat, FormatterTypeStyle.TypesAlways))))
            {
                SerTrace.Log( this, "CheckForNull Write");

                if (typeNameInfo.NIisArrayItem)
                {
                    if (typeNameInfo.NIarrayEnum == InternalArrayTypeE.Single)
                        serWriter.WriteDelayedNullItem();
                    else
                        serWriter.WriteNullItem(memberNameInfo, typeNameInfo);
                }

                else
                    serWriter.WriteNullMember(memberNameInfo, typeNameInfo);
            }
            SerTrace.Log( this, "CheckForNull Exit ",isNull);
            return isNull;
        }


        // Writes the SerializedStreamHeader
        private void WriteSerializedStreamHeader(long topId, long headerId)
        {
            serWriter.WriteSerializationHeader((int)topId, (int)headerId, 1, 0);
        }


        // Transforms a type to the serialized string form. URT Primitive types are converted to XMLData Types
        private NameInfo TypeToNameInfo(Type type, WriteObjectInfo objectInfo, InternalPrimitiveTypeE code, NameInfo nameInfo)
        {
            SerTrace.Log( this, "TypeToNameInfo Entry type ",type,", objectInfo ",objectInfo,", code ", ((Enum)code).ToString());
            if (nameInfo == null)
                nameInfo = GetNameInfo();
            else
                nameInfo.Init();

			if (code == InternalPrimitiveTypeE.Invalid)
			{
				if (objectInfo != null)
                {
                    nameInfo.NIname = objectInfo.GetTypeFullName();
                    nameInfo.NIassemId = objectInfo.assemId;                    
                }
			}
            nameInfo.NIprimitiveTypeEnum = code; 
            nameInfo.NItype = type;

            SerTrace.Log( this, "TypeToNameInfo Exit ",type, " typeName "+nameInfo.NIname);
            return nameInfo;            
        }

        private NameInfo TypeToNameInfo(Type type)
        {
            return TypeToNameInfo(type, null, ToCode(type), null);
        }

        private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo)
        {
            return TypeToNameInfo(objectInfo.objectType, objectInfo, ToCode(objectInfo.objectType), null);
        }

        private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, NameInfo nameInfo)
        {
            return TypeToNameInfo(objectInfo.objectType, objectInfo, ToCode(objectInfo.objectType), nameInfo);
        }

        private void TypeToNameInfo(Type type, NameInfo nameInfo)
        {
            TypeToNameInfo(type, null, ToCode(type), nameInfo);
        }


        // Transforms an Array to the serialized string form.

        private NameInfo ArrayTypeToNameInfo(WriteObjectInfo objectInfo, out NameInfo arrayElemTypeNameInfo)
        {
            SerTrace.Log( this, "ArrayTypeToNameInfo Entry ",objectInfo.objectType);

            NameInfo arrayNameInfo = TypeToNameInfo(objectInfo);
            arrayElemTypeNameInfo = TypeToNameInfo(objectInfo.objectType.GetElementType());
            arrayElemTypeNameInfo.NIisArray = arrayElemTypeNameInfo.NItype.IsArray;

            SerTrace.Log( this, "ArrayTypeToNameInfo Exit array ",arrayNameInfo.NIname," element ",arrayElemTypeNameInfo.NIname);           
            return arrayNameInfo;
        }

        private NameInfo MemberToNameInfo(String name)
        {
            NameInfo memberNameInfo = GetNameInfo();
            memberNameInfo.NIname = name;
            return memberNameInfo;
        }

        Type previousType = null;
        InternalPrimitiveTypeE previousCode = InternalPrimitiveTypeE.Invalid;
        internal InternalPrimitiveTypeE ToCode(Type type)
        {
            if (previousType == type)
            {
                return previousCode;
            }
            else
            {
                InternalPrimitiveTypeE code = Converter.ToCode(type);
                if (code != InternalPrimitiveTypeE.Invalid)
                {
                    previousType = type;
                    previousCode = code;
                }
                return code;
            }
        }


        private Hashtable assemblyToIdTable = null;
        private long GetAssemblyId(WriteObjectInfo objectInfo)
        {
            //use objectInfo to get assembly string with new criteria
            SerTrace.Log( this, "GetAssemblyId Entry ",objectInfo.objectType," isSi ",objectInfo.isSi);
            if (assemblyToIdTable == null)
                assemblyToIdTable = new Hashtable(5);

            long assemId = 0;
            bool isNew = false;
            String assemblyString = objectInfo.GetAssemblyString();
            String serializedAssemblyString = assemblyString;
            if (assemblyString.Length == 0)
            {
                assemId = 0;
            }
            else if (assemblyString.Equals(Converter.urtAssemblyString))
            {
                // Urt type is an assemId of 0. No assemblyString needs
                // to be sent 
                SerTrace.Log( this, "GetAssemblyId urt Assembly String ");
                assemId = 0;
            }
            else
            {
                // Assembly needs to be sent
                // Need to prefix assembly string to separate the string names from the
                // assemblyName string names. That is a string can have the same value
                // as an assemblyNameString, but it is serialized differently

                if (assemblyToIdTable.ContainsKey(assemblyString))
                {
                    assemId = (long)assemblyToIdTable[assemblyString];
                    isNew = false;
                }
                else
                {
                    assemId = InternalGetId("___AssemblyString___"+assemblyString, false, null, out isNew);
                    assemblyToIdTable[assemblyString] = assemId;
                }

                if ((assemblyString != null) && (formatterEnums.FEassemblyFormat == FormatterAssemblyStyle.Simple))
                {
                    // Use only the simple assembly name (not version or strong name)
                    int index = assemblyString.IndexOf(',');
                    if (index > 0)
                        serializedAssemblyString = assemblyString.Substring(0, index);
                }
                serWriter.WriteAssembly(objectInfo.GetTypeFullName(), objectInfo.objectType, serializedAssemblyString, (int)assemId, isNew, false);
            }

            SerTrace.Log( this, "GetAssemblyId Exit id ",assemId," isNew ",isNew," assemblyString ",serializedAssemblyString);
            return assemId;
        }

        private Type GetType(Object obj)
        {
            Type type = null;
            if (RemotingServices.IsTransparentProxy(obj))
                type = Converter.typeofMarshalByRefObject;
            else
                type = obj.GetType();
            return type;
        }


        private SerStack niPool = new SerStack("NameInfo Pool");

        private NameInfo GetNameInfo()
        {
            NameInfo nameInfo = null;

            if (!niPool.IsEmpty())
            {
                nameInfo = (NameInfo)niPool.Pop();
                nameInfo.Init();
            }
            else
                nameInfo = new NameInfo();

            return nameInfo;
        }

        private bool CheckTypeFormat(FormatterTypeStyle test, FormatterTypeStyle want)
        {
            return(test & want) == want;
        }

        private void PutNameInfo(NameInfo nameInfo)
        {
            niPool.Push(nameInfo);
        }
    }
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryobjectinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: SerObjectInfo
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Holds information about an objects Members
 **
 ** Date:  September 29, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Binary
{
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;

    // This class contains information about an object. It is used so that
    // the rest of the Formatter routines can use a common interface for
    // a normal object, an ISerializable object, and a surrogate object
    //
    // The methods in this class are for the internal use of the Formatters.
    // There use will be restricted when signing is supported for assemblies
    internal sealed class WriteObjectInfo
    {
        internal int objectInfoId;

        internal Object obj;
        internal Type objectType;

        internal bool isSi = false;
        internal bool isNamed = false;
        internal bool isTyped = false;
		internal bool isArray = false;

        internal SerializationInfo si = null;

        internal SerObjectInfoCache cache = null;

        internal Object[] memberData = null;
        internal ISerializationSurrogate serializationSurrogate = null;

        internal StreamingContext context;

        internal SerObjectInfoInit serObjectInfoInit = null;

        // Writing and Parsing information
        internal long objectId;
        internal long assemId;

        internal WriteObjectInfo()
        {
        }

        internal void ObjectEnd()
        {
            SerTrace.Log( this, objectInfoId," objectType ",objectType," ObjectEnd");                                                                           
            PutObjectInfo(serObjectInfoInit, this);
        }

        private void InternalInit()
        {
            SerTrace.Log( this, objectInfoId," objectType ",objectType," InternalInit");                                                                                        
            obj = null;
            objectType = null;
            isSi = false;
            isNamed = false;
            isTyped = false;
            isArray = false;
            si = null;
            cache = null;
            memberData = null;

            // Writing and Parsing information
            objectId = 0;
            assemId = 0;
        }


        internal static WriteObjectInfo Serialize(Object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter)
        {
            WriteObjectInfo soi = GetObjectInfo(serObjectInfoInit);

            soi.InitSerialize(obj, surrogateSelector, context, serObjectInfoInit, converter);
            return soi;
        }

        // Write constructor
        internal void InitSerialize(Object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter)
        {
            SerTrace.Log( this, objectInfoId," Constructor 1 ",obj);        
            this.context = context;
            this.obj = obj;
            this.serObjectInfoInit = serObjectInfoInit;
            ISurrogateSelector surrogateSelectorTemp;

            if (RemotingServices.IsTransparentProxy(obj))
                objectType = Converter.typeofMarshalByRefObject;
            else
                objectType = obj.GetType();

            if (objectType.IsArray)
            {
				isArray = true;
                InitNoMembers();
                return;
            }

            SerTrace.Log( this, objectInfoId," Constructor 1 trace 2");

            if (surrogateSelector != null && (serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp)) != null)
            {
                SerTrace.Log( this, objectInfoId," Constructor 1 trace 3");         
                si = new SerializationInfo(objectType, converter);
                if (!objectType.IsPrimitive)
                    serializationSurrogate.GetObjectData(obj, si, context);
                InitSiWrite();
            }
            else if (obj is ISerializable)
            {
                if (!objectType.IsSerializable) {
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NonSerType"), 
                                                                   objectType.FullName, objectType.Module.Assembly.FullName));
                }
                si = new SerializationInfo(objectType, converter);
                ((ISerializable)obj).GetObjectData(si, context);
                SerTrace.Log( this, objectInfoId," Constructor 1 trace 4 ISerializable "+objectType);                       
                InitSiWrite();
            }
            else
            {
                SerTrace.Log(this, objectInfoId," Constructor 1 trace 5");
                InitMemberInfo();
            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpMemberInfo()
        {
            for (int i=0; i<cache.memberInfos.Length; i++)
            {
                SerTrace.Log( this, objectInfoId," Constructor 1 memberInfos data ",cache.memberInfos[i].Name," ",memberData[i]);

            }
        }

        internal static WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter)
        {
            WriteObjectInfo soi = GetObjectInfo(serObjectInfoInit);         
            soi.InitSerialize(objectType, surrogateSelector, context, serObjectInfoInit, converter);
            return soi;         
        }

        // Write Constructor used for array types or null members
        internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter)
        {

            SerTrace.Log( this, objectInfoId," Constructor 2 ",objectType);     

            this.objectType = objectType;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;

            if (objectType.IsArray)
            {
                InitNoMembers();
                return;         
            }

            ISurrogateSelector surrogateSelectorTemp = null;

            if (surrogateSelector!=null)
                serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp);

            if (serializationSurrogate != null)
            {
                isSi = true;
            }
            else if (objectType == Converter.typeofObject)
            {
            }
            else if (Converter.typeofISerializable.IsAssignableFrom(objectType))
                isSi = true;

            if (isSi)
            {
                si = new SerializationInfo(objectType, converter);
                cache = new SerObjectInfoCache();
                cache.fullTypeName = si.FullTypeName;
                cache.assemblyString = si.AssemblyName;
            }
            else
            {
                InitMemberInfo();
            }

            SerTrace.Log( this,objectInfoId," ", objectType," InitSerialize Exit ",isSi);       
        }


        private void InitSiWrite()
        {
            SerTrace.Log( this, objectInfoId," InitSiWrite Entry ");

            SerializationInfoEnumerator siEnum = null;
            isSi = true;        
            siEnum = si.GetEnumerator();
            int infoLength = 0;

            infoLength = si.MemberCount;

            int count = infoLength;

            // For ISerializable cache cannot be saved because each object instance can have different values
            // BinaryWriter only puts the map on the wire if the ISerializable map cannot be reused.
            cache = new SerObjectInfoCache();
            cache.memberNames = new String[count];
            cache.memberTypes = new Type[count];
            memberData = new Object[count];

            cache.fullTypeName = si.FullTypeName;
            cache.assemblyString = si.AssemblyName;
            siEnum = si.GetEnumerator();
            for (int i=0; siEnum.MoveNext(); i++)
            {
                cache.memberNames[i] = siEnum.Name;
                cache.memberTypes[i] = siEnum.ObjectType;
                memberData[i] = siEnum.Value;
                SerTrace.Log( this,objectInfoId+" ",objectType," InitSiWrite ",cache.memberNames[i]," Type ",cache.memberTypes[i]," data ",memberData[i]);                          
            }

            isNamed = true;
            isTyped = false;
            SerTrace.Log(this, objectInfoId," InitSiWrite Exit ");      
        }

        private void InitNoMembers()
        {
            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }
        }

        private void InitMemberInfo()
        {
            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo Entry");


            cache = (SerObjectInfoCache)serObjectInfoInit.seenBeforeTable[objectType];
            if (cache == null)
            {
                SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo new cache");
                cache = new SerObjectInfoCache();
                cache.memberInfos = FormatterServices.GetSerializableMembers(objectType, context);
                int count = cache.memberInfos.Length;
                cache.memberNames = new String[count];
                cache.memberTypes = new Type[count];

                // Calculate new arrays
                for (int i=0; i<count; i++)
                {
                    cache.memberNames[i] = cache.memberInfos[i].Name;
                    cache.memberTypes[i] = GetMemberType(cache.memberInfos[i]);
                    SerTrace.Log( this, objectInfoId," InitMemberInfo name ",cache.memberNames[i],", type ",cache.memberTypes[i],", memberInfoType ",cache.memberInfos[i].GetType());                   
                }
                cache.fullTypeName = objectType.FullName;
                cache.assemblyString = objectType.Module.Assembly.FullName;
                serObjectInfoInit.seenBeforeTable.Add(objectType, cache);
            }

            if (obj != null)
            {
                memberData = FormatterServices.GetObjectData(obj, cache.memberInfos);
                DumpMemberInfo();
            }

            isTyped = true;
            isNamed = true;
            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo Exit");                        
        }


        // Return type name for the object.  

        internal  String GetTypeFullName()
        {
            SerTrace.Log( this,objectInfoId," ", objectType," GetTypeFullName isSi ",isSi, " "+cache.fullTypeName);
            return cache.fullTypeName;
        }

        internal  String GetAssemblyString()
        {
            SerTrace.Log( this,objectInfoId," ", objectType," GetAssemblyString Entry isSi ",isSi, " ",cache.assemblyString);
            return cache.assemblyString;
        }


        // Retrieves the member type from the MemberInfo

        internal  Type GetMemberType(MemberInfo objMember)
        {
            Type objectType = null;

            if (objMember is FieldInfo)
            {
                objectType = ((FieldInfo)objMember).FieldType;
                SerTrace.Log( this, objectInfoId," ", "GetMemberType FieldInfo ",objectType);               
            }
            else if (objMember is PropertyInfo)
            {
                objectType = ((PropertyInfo)objMember).PropertyType;
                SerTrace.Log( this,objectInfoId," ", "GetMemberType PropertyInfo ",objectType);                             
            }
            else
            {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_SerMemberInfo"),objMember.GetType()));
            }

            return objectType;
        }

        // Return the information about the objects members

        internal  void GetMemberInfo(out String[] outMemberNames, out Type[] outMemberTypes, out Object[] outMemberData)
        {
            outMemberNames = cache.memberNames;
            outMemberTypes = cache.memberTypes;
            outMemberData = memberData;

            if (isSi)
            {
                if (!isNamed)
                    throw new SerializationException(Environment.GetResourceString("Serialization_ISerializableMemberInfo"));
            }
        }

        private static WriteObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
        {
            WriteObjectInfo objectInfo = null;

            if (!serObjectInfoInit.oiPool.IsEmpty())
            {
                objectInfo = (WriteObjectInfo)serObjectInfoInit.oiPool.Pop();
                objectInfo.InternalInit();
                //SerTrace.Log( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo from pool");
            }
            else
            {
                objectInfo = new WriteObjectInfo();
                objectInfo.objectInfoId = serObjectInfoInit.objectInfoIdCount++;                        
                //SerTrace.Log( "GetObjectInfo",objectInfo.objectInfoId," GetObjectInfo new not from pool");				
            }

            return objectInfo;
        }

        private static void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, WriteObjectInfo objectInfo)
        {
            serObjectInfoInit.oiPool.Push(objectInfo);
            //SerTrace.Log( "PutObjectInfo",objectInfo.objectInfoId," PutObjectInfo to pool");							
        }
    }

    internal sealed class ReadObjectInfo
    {
        internal int objectInfoId;
        internal static int readObjectInfoCounter = 1;

        internal Type objectType;


        internal ObjectManager objectManager;

        internal int count;

        internal bool isSi = false;
        internal bool isNamed = false;
        internal bool isTyped = false;
        internal bool bSimpleAssembly = false;

        internal SerObjectInfoCache cache;

        internal String[] wireMemberNames;   
        internal Type[] wireMemberTypes;

        private int lastPosition = 0;

        internal ISurrogateSelector surrogateSelector = null;
        internal ISerializationSurrogate serializationSurrogate = null;

        internal StreamingContext context;


        // Si Read
        internal ArrayList memberTypesList;

        internal SerObjectInfoInit serObjectInfoInit = null;

        internal IFormatterConverter formatterConverter;

        internal ReadObjectInfo()
        {
        }

        internal void ObjectEnd()
        {
            SerTrace.Log( this, objectInfoId," objectType ",objectType," ObjectEnd");                                                                           
        }

        private void InternalInit()
        {
            SerTrace.Log( this, objectInfoId," objectType ",objectType," InternalInit");                                                                                        
            objectType = null;
            count = 0;
            isSi = false;
            isNamed = false;
            isTyped = false;
            wireMemberNames = null;
            wireMemberTypes = null;
            cache = null;
            lastPosition = 0;

            // Si Read
            if (memberTypesList != null)
            {
                memberTypesList.Clear();
            }

        }

        internal void PrepareForReuse()
        {
            lastPosition = 0;
        }

        internal static ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
        {
            ReadObjectInfo soi = GetObjectInfo(serObjectInfoInit);          
            soi.Init(objectType, surrogateSelector, context, objectManager, serObjectInfoInit, converter, bSimpleAssembly);
            return soi;
        }


        // Read Constructor
        internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
        {

            SerTrace.Log( this, objectInfoId," Constructor 3 ",objectType);     

            this.objectType = objectType;
            this.objectManager = objectManager;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;
            this.formatterConverter = converter;
            this.bSimpleAssembly = bSimpleAssembly;

            InitReadConstructor(objectType, surrogateSelector, context);
        }

        internal static ReadObjectInfo Create(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
        {
            ReadObjectInfo soi = GetObjectInfo(serObjectInfoInit);                      
            soi.Init(objectType, memberNames,memberTypes, surrogateSelector, context, objectManager, serObjectInfoInit, converter, bSimpleAssembly);
            return soi;
        }

        // Read Constructor
        internal void Init(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly)
        {
            SerTrace.Log( this,objectInfoId, " Constructor 5 ",objectType);                     
            this.objectType = objectType;
            this.objectManager = objectManager;
            this.wireMemberNames = memberNames;
            this.wireMemberTypes = memberTypes;
            this.context = context;
            this.serObjectInfoInit = serObjectInfoInit;     
            this.formatterConverter = converter;
            this.bSimpleAssembly = bSimpleAssembly;
            if (memberNames != null)
                isNamed = true;
            if (memberTypes != null)
                isTyped = true;

            InitReadConstructor(objectType, surrogateSelector, context);                
        }

        private void InitReadConstructor(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context)
        {
            SerTrace.Log( this,objectInfoId," ", objectType," InitReadConstructor Entry ",objectType);

            if (objectType.IsArray)
            {
                InitNoMembers();
                return;         
            }

            ISurrogateSelector surrogateSelectorTemp = null;

            if (surrogateSelector!=null)
                serializationSurrogate = surrogateSelector.GetSurrogate(objectType, context, out surrogateSelectorTemp);

            if (serializationSurrogate != null)
            {
                isSi = true;
            }
            else if (objectType == Converter.typeofObject)
            {
            }
            else if (Converter.typeofISerializable.IsAssignableFrom(objectType))
                isSi = true;

            if (isSi)
            {
                InitSiRead();
            }
            else
            {
                InitMemberInfo();
            }
            SerTrace.Log( this,objectInfoId," ", objectType," InitReadConstructor Exit ",isSi);     
        }

        private void InitSiRead()
        {
            if (memberTypesList != null)
            {
                memberTypesList = new ArrayList(20);
            }
        }

        private void InitNoMembers()
        {
            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo new cache");
            cache = new SerObjectInfoCache();
            cache.fullTypeName = objectType.FullName;
            cache.assemblyString = objectType.Module.Assembly.FullName;
        }

        private void InitMemberInfo()
        {
            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo Entry");

            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo new cache");
            cache = new SerObjectInfoCache();
            cache.memberInfos = FormatterServices.GetSerializableMembers(objectType, context);
            count = cache.memberInfos.Length;
            cache.memberNames = new String[count];
            cache.memberTypes = new Type[count];

            // Calculate new arrays
            for (int i=0; i<count; i++)
            {
                cache.memberNames[i] = cache.memberInfos[i].Name;
                cache.memberTypes[i] = GetMemberType(cache.memberInfos[i]);
                SerTrace.Log( this, objectInfoId," InitMemberInfo name ",cache.memberNames[i],", type ",cache.memberTypes[i],", memberInfoType ",cache.memberInfos[i].GetType());                   
            }
            cache.fullTypeName = objectType.FullName;
            cache.assemblyString = objectType.Module.Assembly.FullName;

            isTyped = true;
            isNamed = true;
            SerTrace.Log( this,objectInfoId," ", objectType," InitMemberInfo Exit");                        
        }


        // Get the memberInfo for a memberName
        internal  MemberInfo GetMemberInfo(String name)
        {
            SerTrace.Log( this,objectInfoId," ", objectType," GetMemberInfo Entry ",name);              
            if (isSi)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_MemberInfo"),objectType+" "+name));
            if (cache.memberInfos == null)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_NoMemberInfo"),objectType+" "+name));
            return cache.memberInfos[Position(name)];
        }

        // Get the ObjectType for a memberName
        internal  Type GetType(String name)
        {
            SerTrace.Log( this,objectInfoId," ", objectType," GetType Entry ",name);                
            Type type = null;
            if (isTyped)
                type = cache.memberTypes[Position(name)];
            else
                type = (Type)memberTypesList[Position(name)];

            if (type == null)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ISerializableTypes"),objectType+" "+name));

            SerTrace.Log( this,objectInfoId," ", objectType," GetType Exit ",type);                     
            return type;
        }


        // Adds the value for a memberName
        internal  void AddValue(String name, Object value, ref SerializationInfo si, ref Object[] memberData)
        {
            SerTrace.Log( this,objectInfoId," ", objectType," AddValue ",name," ",value," isSi ",isSi);                     
            if (isSi)
            {
                si.AddValue(name, value);
            }
            else
            {
                //                Console.WriteLine("Calling add value for " + name + " with value " + value);
                int position = Position(name);
                memberData[position] = value;
            }
        }

        internal void InitDataStore(ref SerializationInfo si, ref Object[] memberData)
        {
            if (isSi)
            {
                if (si == null)
                    si = new SerializationInfo(objectType, formatterConverter);
            }
            else
            {
                if (memberData == null)
                    memberData = new Object[cache.memberNames.Length];
            }
        }

        // Records an objectId in a member when the actual object for that member is not yet known
        internal  void RecordFixup(long objectId, String name, long idRef)
        {

            if (isSi)
            {
                SerTrace.Log( this,objectInfoId," ", objectType, " RecordFixup  RecordDelayedFixup objectId ",objectId," name ",name," idRef ",idRef," isSi ",isSi);
                objectManager.RecordDelayedFixup(objectId, name, idRef);
            }
            else
            {
                SerTrace.Log( this,objectInfoId," ", objectType," RecordFixup  objectId ",objectId," name ",name," idRef ",idRef," isSi ",isSi);                                            
                objectManager.RecordFixup(objectId, cache.memberInfos[Position(name)], idRef);
            }
        }


        // Fills in the values for an object
        internal  void PopulateObjectMembers(Object obj, Object[] memberData)
        {
            SerTrace.Log( this,objectInfoId," ", objectType," PopulateObjectMembers  isSi ",isSi);
            if (!isSi && memberData != null)
            {
                DumpPopulate(cache.memberInfos, memberData);

                FormatterServices.PopulateObjectMembers(obj, cache.memberInfos, memberData);
            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpPopulate(MemberInfo[] memberInfos, Object[] memberData)
        {
            for (int i=0; i<memberInfos.Length; i++)
            {
                SerTrace.Log( this,objectInfoId," ", objectType," PopulateObjectMembers ",memberInfos[i].Name," ",memberData[i]);

            }
        }

        [Conditional("SER_LOGGING")]                    
        private void DumpPopulateSi()
        {
            //SerTrace.Log( this,objectInfoId," ", objectType," PopulateObjectMembers SetObjectData, ISerializable obj ");
            //SerializationInfoEnumerator siEnum = si.GetEnumerator();
            //for (int i=0; siEnum.MoveNext(); i++)
            //{
            //    SerTrace.Log( this,objectInfoId," ",objectType," Populate Si ",siEnum.Name," ",siEnum.Value);
            //}
        }

        // Specifies the position in the memberNames array of this name

        private int Position(String name)
        {
            SerTrace.Log( this, objectInfoId," Position ",lastPosition," ",name);
            if (cache.memberNames[lastPosition].Equals(name))
            {
                return lastPosition;
            }
            else if ((++lastPosition < cache.memberNames.Length) && (cache.memberNames[lastPosition].Equals(name)))
            {
                return lastPosition;
            }
            else
            {
                // Search for name
                SerTrace.Log( this, objectInfoId," Position miss search for name "+name);
                for (int i=0; i<cache.memberNames.Length; i++)
                {
                    if (cache.memberNames[i].Equals(name))
                    {
                        lastPosition = i;
                        return lastPosition;
                    }
                }

                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Position"),objectType+" "+name));   
            }
        }

        // Return the member Types in order of memberNames
        internal  Type[] GetMemberTypes(String[] inMemberNames)
        {
            if (isSi)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ISerializableTypes"),objectType));

            BCLDebug.Assert(cache!=null, "[ReadObjectInfo::GetMemberTypes] cache!=null");

            if (cache.memberTypes == null)
            {
                cache.memberTypes = new Type[count];
                for (int i = 0; i<count; i++)
                    cache.memberTypes[i] = GetMemberType(cache.memberInfos[i]);
            }

            if (inMemberNames.Length != cache.memberInfos.Length && !bSimpleAssembly) {
                throw new SerializationException(Environment.GetResourceString("Serialization_WrongNumberOfMembers", 
                                                                               objectType, cache.memberInfos.Length, inMemberNames.Length));
            }

            Type[] outMemberTypes = new Type[inMemberNames.Length];

            bool isFound = false;

            for (int i=0; i<inMemberNames.Length; i++)
            {
                if (inMemberNames[i].Equals(cache.memberInfos[i].Name))
                    outMemberTypes[i] = cache.memberTypes[i];
                else
                {
                    // MemberNames on wire in different order then memberInfos returned by reflection
                    isFound = false;
                    for (int j=0; j<cache.memberInfos.Length; j++)
                    {
                        if (inMemberNames[i].Equals(cache.memberInfos[j].Name))
                        {
                            outMemberTypes[i] = cache.memberTypes[j];
                            SerTrace.Log( this,objectInfoId," ", objectType," GetMemberTypes memberName ",inMemberNames[i]," ",i," memberTypes ",outMemberTypes[j]," ",j);
                            isFound = true;
                            break;
                        }
                    }
                    if (!isFound)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Position"),objectType));
                }
            }
            return outMemberTypes;
        }

        // Retrieves the member type from the MemberInfo
        internal  Type GetMemberType(MemberInfo objMember)
        {
            Type objectType = null;

            if (objMember is FieldInfo)
            {
                objectType = ((FieldInfo)objMember).FieldType;
                SerTrace.Log( this, objectInfoId," ", "GetMemberType FieldInfo ",objectType);               
            }
            else if (objMember is PropertyInfo)
            {
                objectType = ((PropertyInfo)objMember).PropertyType;
                SerTrace.Log( this,objectInfoId," ", "GetMemberType PropertyInfo ",objectType);                             
            }
            else
            {
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_SerMemberInfo"),objMember.GetType()));
            }

            return objectType;
        }


        private static ReadObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit)
        {
            ReadObjectInfo roi =  new ReadObjectInfo();
            roi.objectInfoId = readObjectInfoCounter++;
            return roi;
        }

    }


    internal sealed class SerObjectInfoInit
    {
        internal Hashtable seenBeforeTable = new Hashtable();
        internal int objectInfoIdCount = 1;
        internal SerStack oiPool = new SerStack("SerObjectInfo Pool");      
    }

    internal sealed class SerObjectInfoCache
    {
        internal String fullTypeName = null;
        internal String assemblyString = null;
        internal MemberInfo[] memberInfos = null;
        internal String[] memberNames = null;   
        internal Type[] memberTypes = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\codeaccesspermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security
{
	using System.IO;
        using System.Threading;
	using System.Security;
	using System.Security.Util;
	using System.Security.Permissions;
	using System.Collections;
	using System.Text;
	using System;
	using IUnrestrictedPermission = System.Security.Permissions.IUnrestrictedPermission;

    /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission"]/*' />
    [Serializable, SecurityPermissionAttribute( SecurityAction.InheritanceDemand, ControlEvidence = true, ControlPolicy = true )]
    abstract public class CodeAccessPermission
        : IPermission, ISecurityEncodable, IStackWalk
    {
        [System.Diagnostics.Conditional( "_DEBUG" )]
        internal static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "d:\\com99\\src\\bcl\\debug.txt";
#endif  
        private static CodeAccessPermission[] commonSecObj = null;

        // Static methods for manipulation of stack
        
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.RevertAssert"]/*' />
        public static void RevertAssert()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.RevertAssert(ref stackMark);
            }
        }

        internal static void RevertAssertAllPossible()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.RevertAssertAllPossible(ref stackMark);
            }
        }
    
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.RevertDeny"]/*' />
        public static void RevertDeny()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.RevertDeny(ref stackMark);
            }
        }
    
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.RevertPermitOnly"]/*' />
        public static void RevertPermitOnly()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            
           if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.RevertPermitOnly(ref stackMark);
            }
        }
    
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.RevertAll"]/*' />
        public static void RevertAll()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.RevertAll(ref stackMark);
            }
        }
 
        //
        // Standard implementation of IPermission methods for
        // code-access permissions.
        //
    
        // COOLPORT: removed final from function signature
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Demand"]/*' />
        // Mark this method as requiring a security object on the caller's frame
        // so the caller won't be inlined (which would mess up stack crawling).
        [DynamicSecurityMethodAttribute()]
        public void Demand()
        {
            CodeAccessSecurityEngine icase = 
                SecurityManager.GetCodeAccessSecurityEngine();

            if (icase != null && !this.IsSubsetOf( null ))
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCallersCaller;
                icase.Check(this, ref stackMark);
            }
        }
    

        [DynamicSecurityMethodAttribute()]
        internal static void DemandInternal(PermissionType permissionType)
        {
            CodeAccessSecurityEngine codeAccessSE = 
                (CodeAccessSecurityEngine) SecurityManager.GetCodeAccessSecurityEngine();

            if (commonSecObj == null)
            {
                // These correspond to SharedPermissionObjects in security.h, that is instances of commonly needed
                // permissions. From managed code, we regularly need Serialization and reflection emit permission.
                // The enum which acts as index into this array is same in EE and BCL. Thats why first 5 entries are null.

                // There is no synchronization on this call since the worse thing
                // that happens is that we create it multiple times (assuming that
                // assignment is atomic).

                commonSecObj =
                    new CodeAccessPermission[] {
                        null,   // Unmanaged code access permission
                        null,   // Skip verification permission
                        null,   // Reflection type info permission
                        null,   // Assert permission
                        null,   // Reflection member access permission
                        new SecurityPermission(SecurityPermissionFlag.SerializationFormatter),               
                        new ReflectionPermission(ReflectionPermissionFlag.ReflectionEmit)
                    };
            }

            BCLDebug.Assert(commonSecObj[(int)permissionType] != null,"Uninitialized commonSecObj in CodeAccessPermission");

            if (codeAccessSE != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCallersCaller;
                codeAccessSE.Check(commonSecObj[(int)permissionType], ref stackMark, permissionType);
            }
        }

        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor

        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Assert"]/*' />
        [DynamicSecurityMethodAttribute()]
        public void Assert()
        {
            CodeAccessSecurityEngine icase = SecurityManager.GetCodeAccessSecurityEngine();
            if (icase != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                icase.Assert(this, ref stackMark);
            }
        }

        [DynamicSecurityMethodAttribute()]
        static internal void AssertAllPossible()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.AssertAllPossible(ref stackMark);
            }
        }
    
        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor

        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Deny"]/*' />
        [DynamicSecurityMethodAttribute()]
        public void Deny()
        {
            CodeAccessSecurityEngine icase = SecurityManager.GetCodeAccessSecurityEngine();
            if (icase != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                icase.Deny(this, ref stackMark);
            }
        }
        
        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor

        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.PermitOnly"]/*' />
        [DynamicSecurityMethodAttribute()]
        public void PermitOnly()
        {
            CodeAccessSecurityEngine icase = SecurityManager.GetCodeAccessSecurityEngine();
            if (icase != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                icase.PermitOnly(this, ref stackMark);
            }
        }

        // IPermission interfaces

        // We provide a default implementation of Union here.
        // Any permission that doesn't provide its own representation 
        // of Union will get this one and trigger CompoundPermission
        // We can take care of simple cases here...

        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Union"]/*' />
        public virtual IPermission Union(IPermission other) {
            // The other guy could be null
            if (other == null) return(this.Copy());
            
            // otherwise we don't support it.
            throw new NotSupportedException(Environment.GetResourceString( "NotSupported_SecurityPermissionUnion" ));
        }
        
        static internal SecurityElement CreatePermissionElement( IPermission perm )
        {
            SecurityElement root = new SecurityElement( "IPermission" );
            XMLUtil.AddClassAttribute( root, perm.GetType() );
            root.AddAttribute( "version", "1" );
            return root;
        }
        
        static internal void ValidateElement( SecurityElement elem, IPermission perm )
        {
            if (elem == null)
                throw new ArgumentNullException( "elem" );
                
            if (!XMLUtil.IsPermissionElement( perm, elem ))
                throw new ArgumentException( Environment.GetResourceString( "Argument_NotAPermissionElement"));
                
            String version = elem.Attribute( "version" );
            
            if (version != null && !version.Equals( "1" ))
                throw new ArgumentException( Environment.GetResourceString( "Argument_InvalidXMLBadVersion") );
        }    
            
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.ToXml"]/*' />
        abstract public SecurityElement ToXml();
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.FromXml"]/*' />
        abstract public void FromXml( SecurityElement elem );
            
        //
        // Unimplemented interface methods 
        // (as a reminder only)
        //
    
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.ToString"]/*' />
        public override String ToString()
        {
            return ToXml().ToString();
        }

        //
        // HELPERS FOR IMPLEMENTING ABSTRACT METHODS
        //
    
        //
        // Protected helper
        //
    
        internal bool VerifyType(IPermission perm)
        {
            // if perm is null, then obviously not of the same type
            if ((perm == null) || (perm.GetType() != this.GetType())) {
                return(false);
            } else {
                return(true);
            }
        }

        //
        // Check callback
        //
    
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.CheckDemand"]/*' />
        internal void CheckDemand(CodeAccessPermission demand)
        {
            if (demand == null)
                return;
    
	#if _DEBUG	     
			if (debug)
			{
				DEBUG_OUT( "demand = " + demand.GetType().ToString() + " this = " + this.GetType().ToString() );
			}
	#endif

            BCLDebug.Assert( demand.GetType().Equals( this.GetType() ), "CheckDemand not defined for permissions of different type" );
		        
            if (!demand.IsSubsetOf( this ))
                throw new SecurityException( String.Format( Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName ), demand.GetType(), demand.ToXml().ToString() );
        }
        
    
        // The IPermission Interface
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Copy"]/*' />
        public abstract IPermission Copy();
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.Intersect"]/*' />
        public abstract IPermission Intersect(IPermission target);
        /// <include file='doc\CodeAccessPermission.uex' path='docs/doc[@for="CodeAccessPermission.IsSubsetOf"]/*' />
        public abstract bool IsSubsetOf(IPermission target);
  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryobjectreader.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: ObjectReader
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: DeSerializes Binary Wire format
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/

namespace System.Runtime.Serialization.Formatters.Binary {

    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Messaging;    
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Security;
    using System.Diagnostics;

    internal sealed class ObjectReader
    {

        // System.Serializer information
        internal Stream m_stream;
        internal ISurrogateSelector m_surrogates;
        internal StreamingContext m_context;
        internal ObjectManager m_objectManager;
        internal InternalFE formatterEnums;
        internal SerializationBinder m_binder;

        // Top object and headers
        internal long topId;
        internal bool bSimpleAssembly = false;
        internal Object handlerObject;
        internal Object topObject;
        internal Header[] headers;
        internal HeaderHandler handler;
        internal SerObjectInfoInit serObjectInfoInit;
        internal IFormatterConverter m_formatterConverter;

        // Stack of Object ParseRecords
        internal SerStack stack;

        // ValueType Fixup Stack
        private SerStack valueFixupStack;

        // Cross AppDomain
        internal Object[] crossAppDomainArray; //Set by the BinaryFormatter

        //MethodCall and MethodReturn are handled special for perf reasons
        private bool bMethodCall;
        private bool bMethodReturn;
        private bool bFullDeserialization;
        private BinaryMethodCall binaryMethodCall;
        private BinaryMethodReturn binaryMethodReturn;

        private Exception deserializationSecurityException;
        private static FileIOPermission sfileIOPermission = new FileIOPermission(PermissionState.Unrestricted);

        private SerStack ValueFixupStack
        {
            get {
                if (valueFixupStack == null)
                    valueFixupStack = new SerStack("ValueType Fixup Stack");
                return valueFixupStack;
            }
        }
        internal void SetMethodCall(BinaryMethodCall binaryMethodCall)
        {
            bMethodCall = true;
            this.binaryMethodCall = binaryMethodCall;
        }

        internal void SetMethodReturn(BinaryMethodReturn binaryMethodReturn)
        {
            bMethodReturn = true;
            this.binaryMethodReturn = binaryMethodReturn;
        }


        internal ObjectReader(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder)
        {
            SerTrace.Log( this, "Constructor ISurrogateSelector ",((selector == null)?"null selector ":"selector present"));                    

            if (stream==null)
            {
                throw new ArgumentNullException("stream", Environment.GetResourceString("ArgumentNull_Stream"));
            }

            m_stream=stream;
            m_surrogates = selector;
            m_context = context;
            m_binder =  binder;
            this.formatterEnums = formatterEnums;

            //SerTrace.Log( this, "Constructor formatterEnums.FEtopObject ",formatterEnums.FEtopObject);

        }

        bool bIsCrossAppDomain = false;
        bool bIsCrossAppDomainInit = false;
        private bool IsCrossAppDomain()
        {
            /*
            if (!bIsCrossAppDomainInit)
            {
                bIsCrossAppDomain = (m_context.State == StreamingContextStates.CrossAppDomain);
                bIsCrossAppDomainInit = true;
            }
            return bIsCrossAppDomain;
            */
            // Always return false for now, so that smuggling is turned off.
            return false;
        }

        // Deserialize the stream into an object graph.
        internal Object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, IMethodCallMessage methodCallMessage)
        {

            SerTrace.Log( this, "Deserialize Entry handler", handler);

            BCLDebug.Assert((IsCrossAppDomain() && (crossAppDomainArray != null))
                            || (!IsCrossAppDomain()),
                             "[System.Runtime.Serialization.Formatters.BinaryObjectReader missing crossAppDomainArray]");

            bFullDeserialization = false;
            bMethodCall = false;
            bMethodReturn = false;
            topObject = null;
            topId = 0;
            bSimpleAssembly =  (formatterEnums.FEassemblyFormat == FormatterAssemblyStyle.Simple);

            if (serParser == null)
                throw new ArgumentNullException("serParser", String.Format(Environment.GetResourceString("ArgumentNull_WithParamName"), serParser));

            if (fCheck)
            {
                try{
                    CodeAccessPermission.DemandInternal(PermissionType.SecuritySerialization);          
                }catch(Exception e)
                {
                    deserializationSecurityException = e;
                }
            }

            this.handler = handler;

            if (bFullDeserialization)
            {
                // Reinitialize
                m_objectManager = new ObjectManager(m_surrogates, m_context, false);
                serObjectInfoInit = new SerObjectInfoInit();
            }


            // Will call back to ParseObject, ParseHeader for each object found
            serParser.Run();

            SerTrace.Log( this, "Deserialize Finished Parsing DoFixups");

            if (bFullDeserialization)
                m_objectManager.DoFixups();


            if (!bMethodCall && !bMethodReturn)
            {
                if (topObject == null)
                    throw new SerializationException(Environment.GetResourceString("Serialization_TopObject"));

                //if topObject has a surrogate then the actual object may be changed during special fixup
                //So refresh it using topID.
                if (HasSurrogate(topObject)  && topId != 0)//Not yet resolved
                    topObject = m_objectManager.GetObject(topId);

                if (topObject is IObjectReference)
								{									
									topObject = ((IObjectReference)topObject).GetRealObject(m_context);
								}
            }

            SerTrace.Log( this, "Deserialize Exit ",topObject);

            if (bFullDeserialization)
                m_objectManager.RaiseDeserializationEvent();

            // Return the headers if there is a handler
            if (handler != null)
            {
                handlerObject = handler(headers);
            }

            if (bMethodCall)
            {
                Object[] methodCallArray = topObject as Object[];
                topObject = binaryMethodCall.ReadArray(methodCallArray, handlerObject);
            }
            else if (bMethodReturn)
            {
                Object[] methodReturnArray = topObject as Object[];
                topObject = binaryMethodReturn.ReadArray(methodReturnArray, methodCallMessage, handlerObject);
            }

            return topObject;
        }

        private bool HasSurrogate(object obj){
            if (m_surrogates == null)
                return false;
            ISurrogateSelector notUsed;
            return m_surrogates.GetSurrogate(obj.GetType(), m_context, out notUsed) != null;
        }

        private void InitFullDeserialization()
        {
            bFullDeserialization = true;
            stack = new SerStack("ObjectReader Object Stack");

            m_objectManager = new ObjectManager(m_surrogates, m_context, false);
            if (m_formatterConverter == null)
                m_formatterConverter = new FormatterConverter();
        }

        internal Object CrossAppDomainArray(int index)
        {
            BCLDebug.Assert((IsCrossAppDomain()),
                             "[System.Runtime.Serialization.Formatters.BinaryObjectReader StreamingContextState not CrossAppDomain]");
            BCLDebug.Assert((index < crossAppDomainArray.Length),
                             "[System.Runtime.Serialization.Formatters.BinaryObjectReader index out of range for CrossAppDomainArray]");
            return crossAppDomainArray[index];
        }

        internal ReadObjectInfo CreateReadObjectInfo(Type objectType)
        {
            return ReadObjectInfo.Create(objectType, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, bSimpleAssembly);
        }

        internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, Type[] memberTypes)
        {
            return ReadObjectInfo.Create(objectType, memberNames, memberTypes, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, bSimpleAssembly);
        }


        // Main Parse routine, called by the XML Parse Handlers in XMLParser and also called internally to
        internal void Parse(ParseRecord pr)
        {
            SerTrace.Log( this, "Parse");
            stack.Dump();
            pr.Dump();

            switch (pr.PRparseTypeEnum)
            {
                case InternalParseTypeE.SerializedStreamHeader:
                    ParseSerializedStreamHeader(pr);
                    break;
                case InternalParseTypeE.SerializedStreamHeaderEnd:
                    ParseSerializedStreamHeaderEnd(pr);
                    break;                  
                case InternalParseTypeE.Object:
                    ParseObject(pr);
                    break;
                case InternalParseTypeE.ObjectEnd:
                    ParseObjectEnd(pr);
                    break;
                case InternalParseTypeE.Member:
                    ParseMember(pr);
                    break;
                case InternalParseTypeE.MemberEnd:
                    ParseMemberEnd(pr);
                    break;
                case InternalParseTypeE.Body:
                case InternalParseTypeE.BodyEnd:
                case InternalParseTypeE.Envelope:
                case InternalParseTypeE.EnvelopeEnd:
                    break;
                case InternalParseTypeE.Empty:
                default:
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_XMLElement"), pr.PRname));                  

            }
        }


        // Styled ParseError output
        private void ParseError(ParseRecord processing, ParseRecord onStack)
        {
            SerTrace.Log( this, " ParseError ",processing," ",onStack);
            throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ParseError"),onStack.PRname+" "+((Enum)onStack.PRparseTypeEnum) + " "+processing.PRname+" "+((Enum)processing.PRparseTypeEnum)));                               
        }

        // Parse the SerializedStreamHeader element. This is the first element in the stream if present
        private void ParseSerializedStreamHeader(ParseRecord pr)
        {
            SerTrace.Log( this, "SerializedHeader ",pr);
            stack.Push(pr);
        }

        // Parse the SerializedStreamHeader end element. This is the last element in the stream if present
        private void ParseSerializedStreamHeaderEnd(ParseRecord pr)
        {
            SerTrace.Log( this, "SerializedHeaderEnd ",pr);
            stack.Pop();
        }

        private bool IsRemoting {
            get {
                //return (m_context.State & (StreamingContextStates.Persistence|StreamingContextStates.File|StreamingContextStates.Clone)) == 0;
                return (bMethodCall || bMethodReturn);
            }
        }
        
        internal void CheckSecurity(ParseRecord pr)
         {
            InternalST.SoapAssert(pr!=null, "[BinaryObjectReader.CheckSecurity]pr!=null");
            Type t = pr.PRdtType;
            if (t != null){
                if( IsRemoting){
                    if (typeof(MarshalByRefObject).IsAssignableFrom(t))
                        throw new ArgumentException(String.Format(Environment.GetResourceString("Serialization_MBRAsMBV"), t.FullName));
                    FormatterServices.CheckTypeSecurity(t, formatterEnums.FEsecurityLevel);
                }
            }

            //If we passed the security check, they can do whatever they'd like,
            //so we'll just short-circuit this.
            if (deserializationSecurityException==null) {
                return;
            }

            // BaseTypes and Array of basetypes allowed

            if (t != null)
            {
                if (t.IsPrimitive || t == Converter.typeofString)
                    return;

                if (typeof(Enum).IsAssignableFrom(t))
                    return;

                if (t.IsArray)
                {
                    Type type = t.GetElementType();
                    if (type.IsPrimitive || type == Converter.typeofString)
                        return;
                }
            }

            throw deserializationSecurityException;
        }

        // New object encountered in stream
        private void ParseObject(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseObject Entry ");

            if (!bFullDeserialization)
                InitFullDeserialization();

            if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                topId = pr.PRobjectId;

            if (pr.PRparseTypeEnum == InternalParseTypeE.Object)
            {
                stack.Push(pr); // Nested objects member names are already on stack
            }

            if (pr.PRobjectTypeEnum == InternalObjectTypeE.Array)
            {
                ParseArray(pr);
                SerTrace.Log( this, "ParseObject Exit, ParseArray ");
                return;
            }

            if (pr.PRdtType == null)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TopObjectInstantiate"),pr.PRname));

            if (pr.PRdtType == Converter.typeofString)
            {
                // String as a top level object
                if (pr.PRvalue != null)
                {
                    pr.PRnewObj = pr.PRvalue;
                    if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                    {
                        SerTrace.Log( this, "ParseObject String as top level, Top Object Resolved");
                        topObject = pr.PRnewObj;
                        //stack.Pop();
                        return;
                    }
                    else
                    {
                        SerTrace.Log( this, "ParseObject  String as an object");
                        stack.Pop();                        
                        RegisterObject(pr.PRnewObj, pr, (ParseRecord)stack.Peek());                         
                        return;
                    }
                }
                else
                {
                    // xml Doesn't have the value until later
                    return;
                }
            }
            else {
                if (IsRemoting && formatterEnums.FEsecurityLevel != TypeFilterLevel.Full)
                    pr.PRnewObj = FormatterServices.GetSafeUninitializedObject(pr.PRdtType);                                 
                else
                    pr.PRnewObj = FormatterServices.GetUninitializedObject(pr.PRdtType);                                                                
            }

            if (pr.PRnewObj == null)
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TopObjectInstantiate"),pr.PRdtType));

            if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                SerTrace.Log( this, "ParseObject  Top Object Resolved ",pr.PRnewObj.GetType());
                topObject = pr.PRnewObj;
            }

            if (pr.PRobjectInfo == null)
                pr.PRobjectInfo = ReadObjectInfo.Create(pr.PRdtType, m_surrogates, m_context, m_objectManager, serObjectInfoInit, m_formatterConverter, bSimpleAssembly);

            CheckSecurity(pr);
            SerTrace.Log( this, "ParseObject Exit ");       
        }

        // End of object encountered in stream
        private void ParseObjectEnd(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseObjectEnd Entry ",pr.Trace());
            ParseRecord objectPr = (ParseRecord)stack.Peek();
            if (objectPr == null)
                objectPr = pr;


            //BCLDebug.Assert(objectPr != null, "[System.Runtime.Serialization.Formatters.ParseObjectEnd]objectPr != null");

            SerTrace.Log( this, "ParseObjectEnd objectPr ",objectPr.Trace());

            if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                SerTrace.Log( this, "ParseObjectEnd Top Object dtType ",objectPr.PRdtType);
                if (objectPr.PRdtType == Converter.typeofString)
                {
                    SerTrace.Log( this, "ParseObjectEnd Top String");
                    objectPr.PRnewObj = objectPr.PRvalue;
                    topObject = objectPr.PRnewObj;
                    return;
                }
            }

            stack.Pop();
            ParseRecord parentPr = (ParseRecord)stack.Peek();

            if (objectPr.PRobjectTypeEnum == InternalObjectTypeE.Array)
            {
                if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                {
                    SerTrace.Log( this, "ParseObjectEnd  Top Object (Array) Resolved");
                    topObject = objectPr.PRnewObj;
                }

                SerTrace.Log( this, "ParseArray  RegisterObject ",objectPr.PRobjectId," ",objectPr.PRnewObj.GetType());
                RegisterObject(objectPr.PRnewObj, objectPr, parentPr);                  

                return;
            }

            objectPr.PRobjectInfo.PopulateObjectMembers(objectPr.PRnewObj, objectPr.PRmemberData);

            // Registration is after object is populated
            if ((!objectPr.PRisRegistered) && (objectPr.PRobjectId > 0))
            {
                SerTrace.Log( this, "ParseObject Register Object ",objectPr.PRobjectId," ",objectPr.PRnewObj.GetType());
                RegisterObject(objectPr.PRnewObj, objectPr, parentPr);
            }
            
            if (objectPr.PRisValueTypeFixup)
            {
                SerTrace.Log( this, "ParseObjectEnd  ValueTypeFixup ",objectPr.PRnewObj.GetType());
                ValueFixup fixup = (ValueFixup)ValueFixupStack.Pop(); //Value fixup
                fixup.Fixup(objectPr, parentPr);  // Value fixup

            }

            if (objectPr.PRobjectPositionEnum == InternalObjectPositionE.Top)
            {
                SerTrace.Log( this, "ParseObjectEnd  Top Object Resolved ",objectPr.PRnewObj.GetType());
                topObject = objectPr.PRnewObj;

            }

            objectPr.PRobjectInfo.ObjectEnd();

            SerTrace.Log( this, "ParseObjectEnd  Exit ",objectPr.PRnewObj.GetType()," id: ",objectPr.PRobjectId);       
        }



        // Array object encountered in stream
        private void ParseArray(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseArray Entry");

            long genId = pr.PRobjectId;

            if (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64)
            {
                SerTrace.Log( this, "ParseArray bin.base64 ",pr.PRvalue.Length," ",pr.PRvalue);
                // ByteArray
                if (pr.PRvalue.Length > 0)
                    pr.PRnewObj = Convert.FromBase64String(pr.PRvalue);
                else
                    pr.PRnewObj = new Byte[0];

                if (stack.Peek() == pr)
                {
                    SerTrace.Log( this, "ParseArray, bin.base64 has been stacked");
                    stack.Pop();
                }
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                    topObject = pr.PRnewObj;

                ParseRecord parentPr = (ParseRecord)stack.Peek();                                           

                // Base64 can be registered at this point because it is populated
                SerTrace.Log( this, "ParseArray  RegisterObject ",pr.PRobjectId," ",pr.PRnewObj.GetType());
                RegisterObject(pr.PRnewObj, pr, parentPr);

            }
            else if ((pr.PRnewObj != null) && Converter.IsWriteAsByteArray(pr.PRarrayElementTypeCode))
            {
                // Primtive typed Array has already been read
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Top)
                    topObject = pr.PRnewObj;

                ParseRecord parentPr = (ParseRecord)stack.Peek();                                           

                // Primitive typed array can be registered at this point because it is populated
                SerTrace.Log( this, "ParseArray  RegisterObject ",pr.PRobjectId," ",pr.PRnewObj.GetType());
                RegisterObject(pr.PRnewObj, pr, parentPr);
            }
            else if ((pr.PRarrayTypeEnum == InternalArrayTypeE.Jagged) || (pr.PRarrayTypeEnum == InternalArrayTypeE.Single))
            {
                // Multidimensional jagged array or single array
                SerTrace.Log( this, "ParseArray Before Jagged,Simple create ",pr.PRarrayElementType," ",pr.PRlengthA[0]);
                bool bCouldBeValueType = true;
                if ((pr.PRlowerBoundA == null) || (pr.PRlowerBoundA[0] == 0))
                {
                    if (pr.PRarrayElementType == Converter.typeofString)
                    {
                        pr.PRobjectA = new String[pr.PRlengthA[0]];
                        pr.PRnewObj = pr.PRobjectA;
                        bCouldBeValueType = false;
                    }
                    else if (pr.PRarrayElementType == Converter.typeofObject)
                    {
                        pr.PRobjectA = new Object[pr.PRlengthA[0]];
                        pr.PRnewObj = pr.PRobjectA;
                        bCouldBeValueType = false;
                    }
                    else
                        pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA[0]);
                    pr.PRisLowerBound = false;
                }
                else
                {
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA, pr.PRlowerBoundA);
                    pr.PRisLowerBound = true;
                }

                if (pr.PRarrayTypeEnum == InternalArrayTypeE.Single)
                {
                    if (!pr.PRisLowerBound && (Converter.IsWriteAsByteArray(pr.PRarrayElementTypeCode)))
                    {
                        pr.PRprimitiveArray = new PrimitiveArray(pr.PRarrayElementTypeCode, (Array)pr.PRnewObj);
                    }
                    else if (bCouldBeValueType)
                    {
                        if (!pr.PRarrayElementType.IsValueType && !pr.PRisLowerBound)
                            pr.PRobjectA = (Object[])pr.PRnewObj;
                    }
                }

                SerTrace.Log( this, "ParseArray Jagged,Simple Array ",pr.PRnewObj.GetType());

                // For binary, headers comes in as an array of header objects
                if (pr.PRobjectPositionEnum == InternalObjectPositionE.Headers)
                {
                    SerTrace.Log( this, "ParseArray header array");
                    headers = (Header[])pr.PRnewObj;
                }

                pr.PRindexMap = new int[1];

            }
            else if (pr.PRarrayTypeEnum == InternalArrayTypeE.Rectangular)
            {
                // Rectangle array

                pr.PRisLowerBound = false;
                if (pr.PRlowerBoundA != null)
                {
                    for (int i=0; i<pr.PRrank; i++)
                    {
                        if (pr.PRlowerBoundA[i] != 0)
                            pr.PRisLowerBound = true;
                    }
                }


                if (!pr.PRisLowerBound)
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA);
                else
                    pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA, pr.PRlowerBoundA);

                SerTrace.Log( this, "ParseArray Rectangle Array ",pr.PRnewObj.GetType()," lower Bound ",pr.PRisLowerBound);

                // Calculate number of items
                int sum = 1;
                for (int i=0; i<pr.PRrank; i++)
                {
                    sum = sum*pr.PRlengthA[i];
                }
                pr.PRindexMap = new int[pr.PRrank];
                pr.PRrectangularMap = new int[pr.PRrank];
                pr.PRlinearlength = sum;
            }
            else
                throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ArrayType"),((Enum)pr.PRarrayTypeEnum)));                               

            CheckSecurity(pr);
            SerTrace.Log( this, "ParseArray Exit");     
        }


        // Builds a map for each item in an incoming rectangle array. The map specifies where the item is placed in the output Array Object

        private void NextRectangleMap(ParseRecord pr)
        {
            // For each invocation, calculate the next rectangular array position
            // example
            // indexMap 0 [0,0,0]
            // indexMap 1 [0,0,1]
            // indexMap 2 [0,0,2]
            // indexMap 3 [0,0,3]
            // indexMap 4 [0,1,0]       
            for (int irank = pr.PRrank-1; irank>-1; irank--)
            {
                // Find the current or lower dimension which can be incremented.
                if (pr.PRrectangularMap[irank] < pr.PRlengthA[irank]-1)
                {
                    // The current dimension is at maximum. Increase the next lower dimension by 1
                    pr.PRrectangularMap[irank]++;
                    if (irank < pr.PRrank-1)
                    {
                        // The current dimension and higher dimensions are zeroed.
                        for (int i = irank+1; i<pr.PRrank; i++)
                            pr.PRrectangularMap[i] = 0;
                    }
                    Array.Copy(pr.PRrectangularMap, pr.PRindexMap, pr.PRrank);              
                    break;                  
                }

            }
        }


        // Array object item encountered in stream
        private void ParseArrayMember(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseArrayMember Entry");
            ParseRecord objectPr = (ParseRecord)stack.Peek();


            // Set up for inserting value into correct array position
            if (objectPr.PRarrayTypeEnum == InternalArrayTypeE.Rectangular)
            {

                if (objectPr.PRmemberIndex > 0)
                    NextRectangleMap(objectPr); // Rectangle array, calculate position in array
                if (objectPr.PRisLowerBound)
                {
                    for (int i=0; i<objectPr.PRrank; i++)
                    {
			objectPr.PRindexMap[i] = objectPr.PRrectangularMap[i] + objectPr.PRlowerBoundA[i];
                    }
                }
            }
            else
            {
                if (!objectPr.PRisLowerBound)
                {
                        objectPr.PRindexMap[0] = objectPr.PRmemberIndex; // Zero based array
                }
                else
                    objectPr.PRindexMap[0] = objectPr.PRlowerBoundA[0]+objectPr.PRmemberIndex; // Lower Bound based array
            }
            IndexTraceMessage("ParseArrayMember isLowerBound "+objectPr.PRisLowerBound+" indexMap  ", objectPr.PRindexMap);     

            // Set Array element according to type of element

            if (pr.PRmemberValueEnum == InternalMemberValueE.Reference)
            {
                // Object Reference

                // See if object has already been instantiated
                Object refObj = m_objectManager.GetObject(pr.PRidRef);
                if (refObj == null)
                {
                    // Object not instantiated
                    // Array fixup manager
                    IndexTraceMessage("ParseArrayMember Record Fixup  "+objectPr.PRnewObj.GetType(), objectPr.PRindexMap);
                    int[] fixupIndex = new int[objectPr.PRrank];
                    Array.Copy(objectPr.PRindexMap, 0, fixupIndex, 0, objectPr.PRrank);

                    SerTrace.Log( this, "ParseArrayMember RecordArrayElementFixup objectId ",objectPr.PRobjectId," idRef ",pr.PRidRef);                                                         
                    m_objectManager.RecordArrayElementFixup(objectPr.PRobjectId, fixupIndex, pr.PRidRef);
                }
                else
                {
                    IndexTraceMessage("ParseArrayMember SetValue ObjectReference "+objectPr.PRnewObj.GetType()+" "+refObj, objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = refObj;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(refObj, objectPr.PRindexMap); // Object has been instantiated
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                //Set up dtType for ParseObject
                SerTrace.Log( this, "ParseArrayMember Nested ");
                if (pr.PRdtType == null)
                {
                    pr.PRdtType = objectPr.PRarrayElementType;
                }

                ParseObject(pr);
                stack.Push(pr);

                if ((objectPr.PRarrayElementType.IsValueType) && (pr.PRarrayElementTypeCode == InternalPrimitiveTypeE.Invalid))
                {
                    SerTrace.Log( "ParseArrayMember ValueType ObjectPr ",objectPr.PRnewObj," index ",objectPr.PRmemberIndex);
                    pr.PRisValueTypeFixup = true; //Valuefixup
                    ValueFixupStack.Push(new ValueFixup((Array)objectPr.PRnewObj, objectPr.PRindexMap)); //valuefixup
                }
                else
                {
                    SerTrace.Log( "ParseArrayMember SetValue Nested, memberIndex ",objectPr.PRmemberIndex);
                    IndexTraceMessage("ParseArrayMember SetValue Nested ContainerObject "+objectPr.PRnewObj.GetType()+" "+objectPr.PRnewObj+" item Object "+pr.PRnewObj+" index ", objectPr.PRindexMap);

                    stack.Dump();               
                    SerTrace.Log( "ParseArrayMember SetValue Nested ContainerObject objectPr ",objectPr.Trace());
                    SerTrace.Log( "ParseArrayMember SetValue Nested ContainerObject pr ",pr.Trace());

                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = pr.PRnewObj;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(pr.PRnewObj, objectPr.PRindexMap);
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.InlineValue)
            {
                if ((objectPr.PRarrayElementType == Converter.typeofString) || (pr.PRdtType == Converter.typeofString))
                {
                    // String in either a string array, or a string element of an object array
                    ParseString(pr, objectPr);
                    IndexTraceMessage("ParseArrayMember SetValue String "+objectPr.PRnewObj.GetType()+" "+pr.PRvalue, objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = (Object)pr.PRvalue;
                    else
                        ((Array)objectPr.PRnewObj).SetValue((Object)pr.PRvalue, objectPr.PRindexMap);
                }
                else if (objectPr.PRisArrayVariant)
                {
                    // Array of type object
                    if (pr.PRkeyDt == null)
                        throw new SerializationException(Environment.GetResourceString("Serialization_ArrayTypeObject"));

                    Object var = null;

                    if (pr.PRdtType == Converter.typeofString)
                    {
                        ParseString(pr, objectPr);
                        var = pr.PRvalue;
                    }
                    else if (pr.PRdtTypeCode == InternalPrimitiveTypeE.Invalid)
                    {
                        // Not nested and invalid, so it is an empty object
                        if (IsRemoting && formatterEnums.FEsecurityLevel != TypeFilterLevel.Full)
                            var = FormatterServices.GetSafeUninitializedObject(pr.PRdtType);                                 
                        else
                            var = FormatterServices.GetUninitializedObject(pr.PRdtType);                      
                    }
                    else
                    {
                        if (pr.PRvarValue != null)
                            var = pr.PRvarValue;
                        else
                            var = Converter.FromString(pr.PRvalue, pr.PRdtTypeCode);
                    }
                    IndexTraceMessage("ParseArrayMember SetValue variant or Object "+objectPr.PRnewObj.GetType()+" var "+var+" indexMap ", objectPr.PRindexMap);
                    if (objectPr.PRobjectA != null)
                        objectPr.PRobjectA[objectPr.PRindexMap[0]] = var;
                    else
                        ((Array)objectPr.PRnewObj).SetValue(var, objectPr.PRindexMap); // Primitive type
                }
                else
                {
                    // Primitive type
                    if (objectPr.PRprimitiveArray != null)
                    {
                        // Fast path for Soap primitive arrays. Binary was handled in the BinaryParser
                        objectPr.PRprimitiveArray.SetValue(pr.PRvalue, objectPr.PRindexMap[0]);
                    }
                    else
                    {

                        Object var = null;
                        if (pr.PRvarValue != null)
                            var = pr.PRvarValue;
                        else
                            var = Converter.FromString(pr.PRvalue, objectPr.PRarrayElementTypeCode);
                        SerTrace.Log( this, "ParseArrayMember SetValue Primitive pr.PRvalue "+var," elementTypeCode ",((Enum)objectPr.PRdtTypeCode));
                        IndexTraceMessage("ParseArrayMember SetValue Primitive "+objectPr.PRnewObj.GetType()+" var: "+var+" varType "+var.GetType(), objectPr.PRindexMap);
                        if (objectPr.PRobjectA != null)
                        {
                            SerTrace.Log( this, "ParseArrayMember SetValue Primitive predefined array "+objectPr.PRobjectA.GetType());
                            objectPr.PRobjectA[objectPr.PRindexMap[0]] = var;
                        }
                        else
                            ((Array)objectPr.PRnewObj).SetValue(var, objectPr.PRindexMap); // Primitive type   
                        SerTrace.Log( this, "ParseArrayMember SetValue Primitive after");
                    }
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Null)
            {
                SerTrace.Log( "ParseArrayMember Null item ",pr.PRmemberIndex," nullCount ",pr.PRnullCount);
                objectPr.PRmemberIndex += pr.PRnullCount-1; //also incremented again below
            }
            else
                ParseError(pr, objectPr);

            SerTrace.Log( "ParseArrayMember increment memberIndex ",objectPr.PRmemberIndex," ",objectPr.Trace());               
            objectPr.PRmemberIndex++;
            SerTrace.Log( "ParseArrayMember Exit");     
        }

        private void ParseArrayMemberEnd(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseArrayMemberEnd");
            // If this is a nested array object, then pop the stack
            if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                ParseObjectEnd(pr);
            }
        }


        // Object member encountered in stream
        private void ParseMember(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseMember Entry ");


            ParseRecord objectPr = (ParseRecord)stack.Peek();
            String objName = null;
            if (objectPr != null)
                objName = objectPr.PRname;

            SerTrace.Log( this, "ParseMember ",objectPr.PRobjectId," ",pr.PRname);
            SerTrace.Log( this, "ParseMember objectPr ",objectPr.Trace());
            SerTrace.Log( this, "ParseMember pr ",pr.Trace());

            switch (pr.PRmemberTypeEnum)
            {
                case InternalMemberTypeE.Item:
                    ParseArrayMember(pr);
                    return;
                case InternalMemberTypeE.Field:
                    break;
            }


            //if ((pr.PRdtType == null) && !objectPr.PRobjectInfo.isSi)
            if ((pr.PRdtType == null) && objectPr.PRobjectInfo.isTyped)
            {
                SerTrace.Log( this, "ParseMember pr.PRdtType null and not isSi");
                pr.PRdtType = objectPr.PRobjectInfo.GetType(pr.PRname);

                if (pr.PRdtType == null)
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeResolved"), objectPr.PRnewObj+" "+pr.PRname));

                pr.PRdtTypeCode = Converter.ToCode(pr.PRdtType);
            }

            if (pr.PRmemberValueEnum == InternalMemberValueE.Null)
            {
                // Value is Null
                SerTrace.Log( this, "ParseMember null member: ",pr.PRname);
                SerTrace.Log( this, "AddValue 1");
                objectPr.PRobjectInfo.AddValue(pr.PRname, null, ref objectPr.PRsi, ref objectPr.PRmemberData);
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
            {
                SerTrace.Log( this, "ParseMember Nested Type member: ",pr.PRname," objectPr.PRnewObj ",objectPr.PRnewObj);
                ParseObject(pr);
                stack.Push(pr);
                SerTrace.Log( this, "AddValue 2 ",pr.PRnewObj," is value type ",pr.PRnewObj.GetType().IsValueType);

                if ((pr.PRobjectInfo != null) && (pr.PRobjectInfo.objectType.IsValueType))
                {
                    SerTrace.Log( "ParseMember ValueType ObjectPr ",objectPr.PRnewObj," memberName  ",pr.PRname," nested object ",pr.PRnewObj);
                    pr.PRisValueTypeFixup = true; //Valuefixup
                    ValueFixupStack.Push(new ValueFixup(objectPr.PRnewObj, pr.PRname, objectPr.PRobjectInfo));//valuefixup
                }
                else
                {
                    SerTrace.Log( this, "AddValue 2A ");
                    objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRnewObj, ref objectPr.PRsi, ref objectPr.PRmemberData);
                }
            }
            else if (pr.PRmemberValueEnum == InternalMemberValueE.Reference)
            {
                SerTrace.Log( this, "ParseMember Reference Type member: ",pr.PRname);           
                // See if object has already been instantiated
                Object refObj = m_objectManager.GetObject(pr.PRidRef);
                if (refObj == null)
                {
                    SerTrace.Log( this, "ParseMember RecordFixup: ",pr.PRname);
                    SerTrace.Log( this, "AddValue 3");                  
                    objectPr.PRobjectInfo.AddValue(pr.PRname, null, ref objectPr.PRsi, ref objectPr.PRmemberData);
                    objectPr.PRobjectInfo.RecordFixup(objectPr.PRobjectId, pr.PRname, pr.PRidRef); // Object not instantiated
                }
                else
                {
                    SerTrace.Log( this, "ParseMember Referenced Object Known ",pr.PRname," ",refObj);
                    SerTrace.Log( this, "AddValue 5");              
                    objectPr.PRobjectInfo.AddValue(pr.PRname, refObj, ref objectPr.PRsi, ref objectPr.PRmemberData);
                }
            }

            else if (pr.PRmemberValueEnum == InternalMemberValueE.InlineValue)
            {
                // Primitive type or String
                SerTrace.Log( this, "ParseMember primitive or String member: ",pr.PRname);

                if (pr.PRdtType == Converter.typeofString)
                {
                    ParseString(pr, objectPr);
                    SerTrace.Log( this, "AddValue 6");              
                    objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvalue, ref objectPr.PRsi, ref objectPr.PRmemberData);  
                }
                else if (pr.PRdtTypeCode == InternalPrimitiveTypeE.Invalid)
                {
                    // The member field was an object put the value is Inline either  bin.Base64 or invalid
                    if (pr.PRarrayTypeEnum == InternalArrayTypeE.Base64)
                    {
                        SerTrace.Log( this, "AddValue 7");                  
                        objectPr.PRobjectInfo.AddValue(pr.PRname, Convert.FromBase64String(pr.PRvalue), ref objectPr.PRsi, ref objectPr.PRmemberData);                                    
                    }
                    else if (pr.PRdtType == Converter.typeofObject)
                        throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeMissing"), pr.PRname));
                    else
                    {
                        SerTrace.Log( this, "Object Class with no memberInfo data  Member "+pr.PRname+" type "+pr.PRdtType);

                        ParseString(pr, objectPr); // Register the object if it has an objectId
                        // Object Class with no memberInfo data
                        // only special case where AddValue is needed?
                        if (pr.PRdtType == Converter.typeofSystemVoid)
                        {
                            SerTrace.Log( this, "AddValue 9");
                            objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRdtType, ref objectPr.PRsi, ref objectPr.PRmemberData);
                        }
                        else if (objectPr.PRobjectInfo.isSi)
                        {
                            // ISerializable are added as strings, the conversion to type is done by the
                            // ISerializable object
                            SerTrace.Log( this, "AddValue 10");
                            objectPr.PRobjectInfo.AddValue(pr.PRname, pr.PRvalue, ref objectPr.PRsi, ref objectPr.PRmemberData);                          
                        }
                    }
                }
                else
                {
                    Object var = null;
                    if (pr.PRvarValue != null)
                        var = pr.PRvarValue;
                    else
                        var = Converter.FromString(pr.PRvalue, pr.PRdtTypeCode);
                    // Not a string, convert the value
                    SerTrace.Log( this, "ParseMember Converting primitive and storing");
                    stack.Dump();
                    SerTrace.Log( this, "ParseMember pr "+pr.Trace());
                    SerTrace.Log( this, "ParseMember objectPr ",objectPr.Trace());

                    SerTrace.Log( this, "AddValue 11");                 
                    objectPr.PRobjectInfo.AddValue(pr.PRname, var, ref objectPr.PRsi, ref objectPr.PRmemberData);             
                }
            }
            else
                ParseError(pr, objectPr);
        }

        // Object member end encountered in stream
        private void ParseMemberEnd(ParseRecord pr)
        {
            SerTrace.Log( this, "ParseMemberEnd");
            switch (pr.PRmemberTypeEnum)
            {
                case InternalMemberTypeE.Item:
                    ParseArrayMemberEnd(pr);
                    return;
                case InternalMemberTypeE.Field:
                    if (pr.PRmemberValueEnum == InternalMemberValueE.Nested)
                        ParseObjectEnd(pr);
                    break;
                default:
                    ParseError(pr, (ParseRecord)stack.Peek());
                    break;
            }
        }

        // Processes a string object by getting an internal ID for it and registering it with the objectManager
        private void ParseString(ParseRecord pr, ParseRecord parentPr)
        {
            SerTrace.Log( this, "ParseString Entry ",pr.PRobjectId," ",pr.PRvalue," ",pr.PRisRegistered);
            // Process String class
            if ((!pr.PRisRegistered) && (pr.PRobjectId > 0))
            {
                SerTrace.Log( this, "ParseString  RegisterObject ",pr.PRvalue," ",pr.PRobjectId);                           
                // String is treated as an object if it has an id
                //m_objectManager.RegisterObject(pr.PRvalue, pr.PRobjectId);
                RegisterObject(pr.PRvalue, pr, parentPr, true);
            }
        }


        private void RegisterObject(Object obj, ParseRecord pr, ParseRecord objectPr)
        {
            RegisterObject(obj, pr, objectPr, false);
        }

        private void RegisterObject(Object obj, ParseRecord pr, ParseRecord objectPr, bool bIsString)
        {
            if (!pr.PRisRegistered)
            {
                pr.PRisRegistered = true;

                SerializationInfo si = null;
                long parentId = 0;
                MemberInfo memberInfo = null;
                int[] indexMap = null;

                if (objectPr != null)
                {
                    indexMap = objectPr.PRindexMap;
                    parentId = objectPr.PRobjectId;                 

                    if (objectPr.PRobjectInfo != null)
                    {
                        if (!objectPr.PRobjectInfo.isSi)
                        {
                            // ParentId is only used if there is a memberInfo

                            memberInfo = objectPr.PRobjectInfo.GetMemberInfo(pr.PRname);
                        }
                    }
                }
                // SerializationInfo is always needed for ISerialization                        
                si = pr.PRsi;

                SerTrace.Log( this, "RegisterObject 0bj ",obj," objectId ",pr.PRobjectId," si ", si," parentId ",parentId," memberInfo ",memberInfo, " indexMap "+indexMap);
                if (bIsString)
                    m_objectManager.RegisterString((String)obj, pr.PRobjectId, si, parentId, memberInfo); 
                else
                    m_objectManager.RegisterObject(obj, pr.PRobjectId, si, parentId, memberInfo, indexMap); 
            }
        }


        // Assigns an internal ID associated with the binary id number

        // Older formatters generate ids for valuetypes using a different counter than ref types. Newer ones use
        // a single counter, only value types have a negative value. Need a way to handle older formats.
        private const int THRESHOLD_FOR_VALUETYPE_IDS = Int32.MaxValue;
        private bool bOldFormatDetected = false;
        private IntSizedArray   valTypeObjectIdTable;

        internal long GetId(long objectId)
        {

            if (!bFullDeserialization)
                InitFullDeserialization();


            if (objectId > 0)
                return objectId;
            
            if (bOldFormatDetected || objectId == -1)
            {
                // Alarm bells. This is an old format. Deal with it.
                bOldFormatDetected = true;
                if (valTypeObjectIdTable == null)
                    valTypeObjectIdTable = new IntSizedArray();

                long tempObjId = 0;
                if ((tempObjId = valTypeObjectIdTable[(int)objectId]) == 0)
                {
                    tempObjId = THRESHOLD_FOR_VALUETYPE_IDS + objectId;
                    valTypeObjectIdTable[(int)objectId] = (int)tempObjId;
                }
                return tempObjId;
            }
            return -1 * objectId;
        }


        // Trace which includes a single dimensional int array
        [Conditional("SER_LOGGING")]                        
        private void IndexTraceMessage(String message, int[] index)
        {
            StringBuilder sb = new StringBuilder(10);
            sb.Append("[");     
            for (int i=0; i<index.Length; i++)
            {
                sb.Append(index[i]);
                if (i != index.Length -1)
                    sb.Append(",");
            }
            sb.Append("]");             
            SerTrace.Log( this, message," ",sb.ToString());
        }

        internal Type Bind(String assemblyString, String typeString)
        {
            Type type = null;
            if (m_binder != null && !IsInternalType(assemblyString, typeString))
                type = m_binder.BindToType(assemblyString, typeString);
            if (type == null)
                type= FastBindToType(assemblyString, typeString);

            return type;
        }
        private bool IsInternalType(string assemblyString, string typeString){
            return (assemblyString == Converter.urtAssemblyString) &&
                   ((typeString == "System.DelegateSerializationHolder") ||
                    (typeString == "System.UnitySerializationHolder") ||
                    (typeString == "System.MemberInfoSerializationHolder"));
        }

        internal class TypeNAssembly
        {
            public Type type;
            public String assemblyName;
        }

        NameCache typeCache = new NameCache();
        internal Type FastBindToType(String assemblyName, String typeName)
        {
            Type type = null;

            TypeNAssembly entry = (TypeNAssembly)typeCache.GetCachedValue(typeName);

            if (entry == null || entry.assemblyName != assemblyName)
            {
                Assembly assm = null;
                if (bSimpleAssembly)
                {
                    try {
                        sfileIOPermission.Assert();
                        try {                    
                            assm = Assembly.LoadWithPartialName(assemblyName);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    catch(Exception e){
                        SerTrace.Log( this, "FastBindTypeType ",e.ToString());
                    }
                }
                else {
                    try
                    {
                        sfileIOPermission.Assert();
                        try {                    
                            assm = Assembly.Load(assemblyName);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                    catch (Exception e)
                    {
                        SerTrace.Log( this, "FastBindTypeType ",e.ToString());
                    }
                }
                if (assm == null)
                    return null;

                type = FormatterServices.GetTypeFromAssembly(assm, typeName);

                if (type == null)
                    return null;

                entry = new TypeNAssembly();
                entry.type = type;
                entry.assemblyName = assemblyName;
                typeCache.SetCachedValue(entry);
            }
           return entry.type;
        }


        private String previousAssemblyString;
        private String previousName;
        private Type previousType;
        //private int hit;
        internal Type GetType(BinaryAssemblyInfo assemblyInfo, String name)
        {
            //Console.WriteLine("Get Type "+name+" "+assemblyInfo.assemblyString);
            Type objectType = null;

            if (((previousName != null) && (previousName.Length == name.Length) && (previousName.Equals(name))) &&
                ((previousAssemblyString != null) && (previousAssemblyString.Length == assemblyInfo.assemblyString.Length) &&(previousAssemblyString.Equals(assemblyInfo.assemblyString))))
            {
                objectType = previousType;
                //Console.WriteLine("Hit "+(++hit)+" "+objectType);
            }
            else
            {
                objectType = Bind(assemblyInfo.assemblyString, name);
                if (objectType == null)
                    objectType = FormatterServices.GetTypeFromAssembly(assemblyInfo.GetAssembly(), name);

                if (objectType == null)
                    throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeResolved"), name+", "+assemblyInfo.assemblyString));
                previousAssemblyString = assemblyInfo.assemblyString;
                previousName = name;
                previousType = objectType;
            }
            //Console.WriteLine("name "+name+" assembly"+assemblyInfo.assemblyString+" objectType "+objectType);
            return objectType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\attributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

[assembly:System.Security.AllowPartiallyTrustedCallersAttribute()]
namespace System.Security
{
    // DynamicSecurityMethodAttribute:
    //  Indicates that calling the target method requires space for a security
    //  object to be allocated on the callers stack. This attribute is only ever
    //  set on certain security methods defined within mscorlib.
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="DynamicSecurityMethodAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false )] 
    sealed internal class DynamicSecurityMethodAttribute : System.Attribute
    {
    }

    // SuppressUnmanagedCodeSecurityAttribute:
    //  Indicates that the target P/Invoke method(s) should skip the per-call
    //  security checked for unmanaged code permission.
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="SuppressUnmanagedCodeSecurityAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false )] 
    sealed public class SuppressUnmanagedCodeSecurityAttribute : System.Attribute
    {
    }

    // UnverifiableCodeAttribute:
    //  Indicates that the target module contains unverifiable code.
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="UnverifiableCodeAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Module, AllowMultiple = true, Inherited = false )] 
    sealed public class UnverifiableCodeAttribute : System.Attribute
    {
    }

    // AllowPartiallyTrustedCallersAttribute:
    //  Indicates that the Assembly is secure and can be used by untrusted
    //  and semitrusted clients
    //  For v.1, this is valid only on Assemblies, but could be expanded to 
    //  include Module, Method, class
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="AllowPartiallyTrustedCallersAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false )] 
    sealed public class AllowPartiallyTrustedCallersAttribute : System.Attribute
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="AllowPartiallyTrustedCallersAttribute.AllowPartiallyTrustedCallersAttribute"]/*' />
        public AllowPartiallyTrustedCallersAttribute () { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryutilclasses.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: CommonClasses
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: utility classes
 **
 ** Date:  June 10, 1999
 **
 ===========================================================*/


// All classes and methods in here are only for the internal use by the XML and Binary Formatters.
// They are public so that the XMLFormatter can address them. Eventually they will
// be signed so that they can't be used by external applications.

namespace System.Runtime.Serialization.Formatters.Binary
{    
	using System;
	using System.Collections;
	using System.Reflection;
	using System.Text;
    using System.Globalization;
	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Messaging;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
    using System.Diagnostics;

	// The ParseRecord class holds the parsed XML information. There is a
	// ParsedRecord for each XML Element
	internal sealed class ParseRecord : ITrace
	{
		internal static int parseRecordIdCount = 1;


		internal int PRparseRecordId = 0;

		// Enums
		internal InternalParseTypeE PRparseTypeEnum = InternalParseTypeE.Empty;
		internal InternalObjectTypeE PRobjectTypeEnum = InternalObjectTypeE.Empty;
		internal InternalArrayTypeE PRarrayTypeEnum = InternalArrayTypeE.Empty;
		internal InternalMemberTypeE PRmemberTypeEnum = InternalMemberTypeE.Empty;
		internal InternalMemberValueE PRmemberValueEnum = InternalMemberValueE.Empty;
		internal InternalObjectPositionE PRobjectPositionEnum = InternalObjectPositionE.Empty;

		// Object
		internal String PRname;

		// Value
		internal String PRvalue;
		internal Object PRvarValue;

		// dt attribute
		internal String PRkeyDt;
		internal Type PRdtType;
		internal InternalPrimitiveTypeE PRdtTypeCode;
		internal bool PRisVariant = false; // Used by Binary
		internal bool PRisEnum = false;

		// Object ID
		internal long PRobjectId;

		// Reference ID
		internal long PRidRef;

		// Array

		// Array Element Type
		internal String PRarrayElementTypeString;
		internal Type PRarrayElementType;
		internal bool PRisArrayVariant = false;
		internal InternalPrimitiveTypeE PRarrayElementTypeCode;

		// Parsed array information
		internal int PRrank;
		internal int[] PRlengthA;
		internal int[] PRpositionA;
		internal int[] PRlowerBoundA;
		internal int[] PRupperBoundA;

		// Array map for placing array elements in array
		internal int[] PRindexMap; 
		internal int PRmemberIndex;
		internal int PRlinearlength;
		internal int[] PRrectangularMap;
		internal bool	PRisLowerBound;

		// SerializedStreamHeader information
		internal long PRtopId;
		internal long PRheaderId;


		// MemberInfo accumulated during parsing of members

		internal ReadObjectInfo PRobjectInfo;

		// ValueType Fixup needed
		internal bool PRisValueTypeFixup = false;

		// Created object
		internal Object PRnewObj;
		internal Object[] PRobjectA; //optimization, will contain object[]
		internal PrimitiveArray PRprimitiveArray; // for Primitive Soap arrays, optimization
		internal bool PRisRegistered; // Used when registering nested classes
        internal Object[] PRmemberData; // member data is collected here before populating
        internal SerializationInfo  PRsi;

        internal int PRnullCount; // Count of consecutive nulls within an array


		internal ParseRecord()
		{
			Counter();
		}

		[Conditional("SER_LOGGING")]
		private void Counter()
		{
			// The counter is used to test parseRecord identity
			lock(typeof(ParseRecord))
			{
				PRparseRecordId = parseRecordIdCount++;
			}

		}


		// Get a String describing the ParseRecord
		// ITrace 
		public String Trace()
		{
			return "ParseRecord"+PRparseRecordId+" ParseType "+ ((Enum)PRparseTypeEnum).ToString() +" name "+PRname+" keyDt "+Util.PString(PRkeyDt);
		}

		// Initialize ParseRecord. Called when reusing.
		internal void Init()
		{
			// Enums
			PRparseTypeEnum = InternalParseTypeE.Empty;
			PRobjectTypeEnum = InternalObjectTypeE.Empty;
			PRarrayTypeEnum = InternalArrayTypeE.Empty;
			PRmemberTypeEnum = InternalMemberTypeE.Empty;
			PRmemberValueEnum = InternalMemberValueE.Empty;
			PRobjectPositionEnum = InternalObjectPositionE.Empty;

			// Object
			PRname = null;

			// Value
			PRvalue = null;

			// dt attribute
			PRkeyDt = null;
			PRdtType = null;
			PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			PRisEnum = false;			

			// Object ID
			PRobjectId = 0;

			// Reference ID
			PRidRef = 0;

			// Array

			// Array Element Type
			PRarrayElementTypeString = null;
			PRarrayElementType = null;
			PRisArrayVariant = false;
			PRarrayElementTypeCode = InternalPrimitiveTypeE.Invalid;


			// Parsed array information
			PRrank = 0;
			PRlengthA = null;
			PRpositionA = null;
			PRlowerBoundA = null;
			PRupperBoundA = null;		

			// Array map for placing array elements in array
			PRindexMap = null;
			PRmemberIndex = 0;
			PRlinearlength = 0;
			PRrectangularMap = null;
			PRisLowerBound = false;

			// SerializedStreamHeader information
			PRtopId = 0;
			PRheaderId = 0;

			// ValueType Fixup needed
			PRisValueTypeFixup = false;

			PRnewObj = null;
			PRobjectA = null;
			PRprimitiveArray = null;			
			PRobjectInfo = null;
			PRisRegistered = false;
            PRmemberData = null;
            PRsi = null;

            PRnullCount = 0;
		}

		internal ParseRecord Copy()
		{

			ParseRecord newPr = new ParseRecord();
			// Enums
			newPr.PRparseTypeEnum = PRparseTypeEnum;
			newPr.PRobjectTypeEnum = PRobjectTypeEnum;
			newPr.PRarrayTypeEnum = PRarrayTypeEnum;
			newPr.PRmemberTypeEnum = PRmemberTypeEnum;
			newPr.PRmemberValueEnum = PRmemberValueEnum;
			newPr.PRobjectPositionEnum = PRobjectPositionEnum;

			// Object
			newPr.PRname = PRname;

			// Value
			newPr.PRvalue = PRvalue;


			// dt attribute
			newPr.PRkeyDt = PRkeyDt;
			newPr.PRdtType = PRdtType;
			newPr.PRdtTypeCode = PRdtTypeCode;
			newPr.PRisEnum = PRisEnum;			

			// Object ID
			newPr.PRobjectId = PRobjectId;

			// Reference ID
			newPr.PRidRef = PRidRef;

			// Array

			// Array Element Type
			newPr.PRarrayElementTypeString = PRarrayElementTypeString;
			newPr.PRarrayElementType = PRarrayElementType;
			newPr.PRisArrayVariant = PRisArrayVariant;
			newPr.PRarrayElementTypeCode = PRarrayElementTypeCode;


			// Parsed array information
			newPr.PRrank = PRrank;
			newPr.PRlengthA = PRlengthA;
			newPr.PRpositionA = PRpositionA;
			newPr.PRlowerBoundA = PRlowerBoundA;
			newPr.PRupperBoundA = PRupperBoundA;		

			// Array map for placing array elements in array
			newPr.PRindexMap = PRindexMap;
			newPr.PRmemberIndex = PRmemberIndex;
			newPr.PRlinearlength = PRlinearlength;
			newPr.PRrectangularMap = PRrectangularMap;
			newPr.PRisLowerBound = PRisLowerBound;

			// SerializedStreamHeader information
			newPr.PRtopId = PRtopId;
			newPr.PRheaderId = PRheaderId;

			// ValueType Fixup needed
			newPr.PRisValueTypeFixup = PRisValueTypeFixup;

			newPr.PRnewObj = PRnewObj;
			newPr.PRobjectA = PRobjectA;
			newPr.PRprimitiveArray = PRprimitiveArray;
			newPr.PRobjectInfo = PRobjectInfo;
			newPr.PRisRegistered = PRisRegistered;
            newPr.PRnullCount = PRnullCount;
            newPr.PRmemberData = PRmemberData;
            newPr.PRsi = PRsi;

			return newPr;
		}		


		// Dump ParseRecord. 
		[Conditional("SER_LOGGING")]								
		internal void Dump()
		{
			SerTrace.Log("ParseRecord Dump ",PRparseRecordId);
			SerTrace.Log("Enums");
			Util.NVTrace("ParseType",((Enum)PRparseTypeEnum).ToString());
			Util.NVTrace("ObjectType",((Enum)PRobjectTypeEnum).ToString());
			Util.NVTrace("ArrayType",((Enum)PRarrayTypeEnum).ToString());
			Util.NVTrace("MemberType",((Enum)PRmemberTypeEnum).ToString());
			Util.NVTrace("MemberValue",((Enum)PRmemberValueEnum).ToString());
			Util.NVTrace("ObjectPosition",((Enum)PRobjectPositionEnum).ToString());
			SerTrace.Log("Basics");		
			Util.NVTrace("Name",PRname);
			Util.NVTrace("Value ",PRvalue);
			Util.NVTrace("varValue ",PRvarValue);
			if (PRvarValue != null)
				Util.NVTrace("varValue type",PRvarValue.GetType());				

			Util.NVTrace("keyDt",PRkeyDt);
			Util.NVTrace("dtType",PRdtType);
			Util.NVTrace("code",((Enum)PRdtTypeCode).ToString());
			Util.NVTrace("objectID",PRobjectId);
			Util.NVTrace("idRef",PRidRef);
			Util.NVTrace("isEnum",PRisEnum);			
			SerTrace.Log("Array ");
			Util.NVTrace("arrayElementTypeString",PRarrayElementTypeString);
			Util.NVTrace("arrayElementType",PRarrayElementType);
			Util.NVTrace("arrayElementTypeCode",((Enum)PRarrayElementTypeCode).ToString());		
			Util.NVTrace("isArrayVariant",PRisArrayVariant);
			Util.NVTrace("rank",PRrank);
			Util.NVTrace("dimensions", Util.PArray(PRlengthA));
			Util.NVTrace("position", Util.PArray(PRpositionA));
			Util.NVTrace("lowerBoundA", Util.PArray(PRlowerBoundA));
			Util.NVTrace("upperBoundA", Util.PArray(PRupperBoundA));		
			SerTrace.Log("Header ");		
            Util.NVTrace("nullCount", PRnullCount);

			SerTrace.Log("New Object");
			if (PRnewObj != null)
				Util.NVTrace("newObj", PRnewObj);
		}
	}

	internal interface ITrace
	{
		String Trace();
	}


	// Implements a stack used for parsing

	internal sealed class SerStack
	{
		internal Object[] objects = new Object[5];
		internal String stackId;
		internal int top = -1;
		internal int next = 0;

		internal SerStack()
		{
			stackId = "System";
		}

		internal SerStack(String stackId) {
			this.stackId = stackId;
		}

		// Push the object onto the stack
		internal void Push(Object obj) {
			SerTrace.Log(this, "Push ",stackId," ",((obj is ITrace)?((ITrace)obj).Trace():""));									
			if (top == (objects.Length -1)) {
				IncreaseCapacity();
			}
			objects[++top] = obj;		
		}

		// Pop the object from the stack
		internal Object Pop() {
			if (top < 0)
				return null;

			Object obj = objects[top];
			objects[top--] = null;
			SerTrace.Log(this, "Pop ",stackId," ",((obj is ITrace)?((ITrace)obj).Trace():""));			
			return obj;
		}

		internal void IncreaseCapacity() {
			int size = objects.Length * 2;
			Object[] newItems = new Object[size];
			Array.Copy(objects, 0, newItems, 0, objects.Length);
			objects = newItems;
		}

		// Gets the object on the top of the stack
		internal Object Peek() {
			if (top < 0)
				return null;		
			SerTrace.Log(this, "Peek ",stackId," ",((objects[top] is ITrace)?((ITrace)objects[top]).Trace():""));			
			return objects[top];
		}

		// Gets the second entry in the stack.
		internal Object PeekPeek() {
			if (top < 1)
				return null;
			SerTrace.Log(this, "PeekPeek ",stackId," ",((objects[top - 1] is ITrace)?((ITrace)objects[top - 1]).Trace():""));									
			return objects[top - 1];		
		}

		// The number of entries in the stack
		internal int Count() {
			return top + 1; 
		}

		// The number of entries in the stack
		internal bool IsEmpty() {
			if (top > 0) 
				return false;
			else
				return true;
		}

		[Conditional("SER_LOGGING")]								
		internal void Dump()
		{
			for (int i=0; i<Count(); i++)
			{
				Object obj = objects[i];
				SerTrace.Log(this, "Stack Dump ",stackId," "+((obj is ITrace)?((ITrace)obj).Trace():""));										
			}
		}
	}


	// Implements a Growable array

	internal sealed class SizedArray
	{
		internal Object[] objects = null;
        internal Object[] negObjects = null;

        internal SizedArray()
        {
            objects = new Object[16];
            negObjects = new Object[4];
        }

        internal SizedArray(int length)
        {
            objects = new Object[length];
        }

        internal Object this[int index] 
        {
            get 
            {
                if (index < 0)
                {
                    if (-index > negObjects.Length - 1)
                        return null;
                    return negObjects[-index];
                }
                else
                {
                    if (index > objects.Length - 1)
                        return null;
                    return objects[index];
                }
            }
            set
            {
                if (index < 0)
                {
                    if (-index > negObjects.Length-1 )
                    {
                        IncreaseCapacity(index);
                    }
                    negObjects[-index] = value;

                }
                else
                {
                    if (index > objects.Length-1 )
                    {
                        IncreaseCapacity(index);
                    }
                    if (objects[index] != null)
                    {
                        Console.WriteLine("SizedArray Setting a non-zero "+index+" "+value);
                    }
                    objects[index] = value;
                }
            }
        }

		internal void IncreaseCapacity(int index)
         {
             try
             {
                 if (index < 0)
                 {
                     int size = Math.Max(negObjects.Length * 2, (-index)+1);
                     Object[] newItems = new Object[size];
                     Array.Copy(negObjects, 0, newItems, 0, negObjects.Length);
                     negObjects = newItems;
                 }
                 else
                 {
                     int size = Math.Max(objects.Length * 2, index+1);
                     Object[] newItems = new Object[size];
                     Array.Copy(objects, 0, newItems, 0, objects.Length);
                     objects = newItems;
                 }
             }catch(Exception)
             {
                 throw new SerializationException(Environment.GetResourceString("Serialization_CorruptedStream"));   
             }
        }

        internal void Clear()
        {
            for (int i=0; i<objects.Length; i++)
                objects[i] = 0;

            for (int i=0; i<negObjects.Length; i++)
                negObjects[i] = 0;
        }
	}

	internal sealed class IntSizedArray
	{
		internal int[] objects = new int[16];
        internal int[] negObjects = new int[4];

        internal int this[int index] 
        {
            get 
            {
                if (index < 0)
                {
                    if (-index > negObjects.Length-1 )
                        return 0;
                    return negObjects[-index];
                }
                else
                {
                    if (index > objects.Length-1 )
                        return 0;
                    return objects[index];
                }
            }
            set
            {
                if (index < 0)
                {
                    if (-index > negObjects.Length-1 )
                    {
                        IncreaseCapacity(index);
                    }
                    negObjects[-index] = value;

                }
                else
                {
                    if (index > objects.Length-1 )
                    {
                        IncreaseCapacity(index);
                    }
                    objects[index] = value;
                }
            }
        }

		internal void IncreaseCapacity(int index)
         {
             try
             {
                 if (index < 0)
                 {
                     int size = Math.Max(negObjects.Length * 2, (-index)+1);
                     int[] newItems = new int[size];
                     Array.Copy(negObjects, 0, newItems, 0, negObjects.Length);
                     negObjects = newItems;
                 }
                 else
                 {
                     int size = Math.Max(objects.Length * 2, index+1);
                     int[] newItems = new int[size];
                     Array.Copy(objects, 0, newItems, 0, objects.Length);
                     objects = newItems;
                 }
             }catch(Exception)
             {
                 throw new SerializationException(Environment.GetResourceString("Serialization_CorruptedStream"));   
             }
		}

        internal void Clear()
        {
            for (int i=0; i<objects.Length; i++)
                objects[i] = 0;

            for (int i=0; i<negObjects.Length; i++)
                negObjects[i] = 0;
        }
	}

    internal sealed class NameCacheEntry
    {
        internal String name;
        internal Object value;
    }

    internal sealed class NameCache
    {
        private const int MAX_CACHE_ENTRIES =353; // Needs to be a prime number
        static NameCacheEntry[] nameCache = new NameCacheEntry[MAX_CACHE_ENTRIES];

        int probe = 0;
        String name = null;

        internal Object GetCachedValue(String name)
        {
            this.name = name;
            probe = Math.Abs(name.GetHashCode())%MAX_CACHE_ENTRIES;
            NameCacheEntry entry = nameCache[probe];
            if (entry == null)
            {
                entry = new NameCacheEntry();
                entry.name = name;
                return null;
            }
            else if (entry.name == name)
            {
                return entry.value;
            }
            else
                return null;
        }

        internal void SetCachedValue(Object value)
        {
            NameCacheEntry entry = new NameCacheEntry();
            entry.name = name;
            entry.value = value;
            nameCache[probe] = entry;
        }
    }


	// Utilities
	internal sealed class Util
	{

		// Replaces a null string with an empty string
		internal static String PString(String value)
		{
			if (value == null)
				return "";
			else
				return value;
		}

		// Converts an object to a string and checks for nulls

		internal static String PString(Object value)
		{
			if (value == null)
				return "";
			else
				return value.ToString();
		}

		// Converts a single int array to a string

		internal static String PArray(int[] array)
		{
			if (array != null)
			{
				StringBuilder sb = new StringBuilder(10);
				sb.Append("[");		
				for (int i=0; i<array.Length; i++)
				{
					sb.Append(array[i]);
					if (i != array.Length -1)
						sb.Append(",");
				}
				sb.Append("]");
				return sb.ToString();
			}
			else
				return "";
		}


		// Traces an name value pair

		[Conditional("SER_LOGGING")]								
		internal static void NVTrace(String name, String value)
		{
			SerTrace.Log("  "+name+((value == null)?" = null":" = "+value));
		}

		// Traces an name value pair
		[Conditional("SER_LOGGING")]										
		internal static void NVTrace(String name, Object value)
		{
			SerTrace.Log("  "+name+((value == null)?" = null":" = "+value.ToString()));			
		}

		// Traces an name value pair

		[Conditional("_LOGGING")]								
		internal static void NVTraceI(String name, String value)
		{
			BCLDebug.Trace("Binary", "  "+name+((value == null)?" = null":" = "+value));			
		}

		// Traces an name value pair
		[Conditional("_LOGGING")]										
		internal static void NVTraceI(String name, Object value)
		{
			BCLDebug.Trace("Binary", "  "+name+((value == null)?" = null":" = "+value.ToString()));			
		}

	}


	// Used to fixup value types. Only currently used for valuetypes which are array items.
	internal sealed class ValueFixup : ITrace
	{
		internal ValueFixupEnum valueFixupEnum = ValueFixupEnum.Empty;
		internal Array arrayObj;
		internal int[] indexMap;
		internal Object header = null;
		internal Object memberObject;
		internal static MemberInfo valueInfo;
		internal ReadObjectInfo objectInfo;
		internal String memberName;

		internal ValueFixup(Array arrayObj, int[] indexMap)
		{
			SerTrace.Log(this, "Array Constructor ",arrayObj);										
			valueFixupEnum = ValueFixupEnum.Array;
			this.arrayObj = arrayObj;
			this.indexMap = indexMap;
		}

		internal ValueFixup(Object memberObject, String memberName, ReadObjectInfo objectInfo)
		{
			SerTrace.Log(this, "Member Constructor ",memberObject);												
			valueFixupEnum = ValueFixupEnum.Member;
			this.memberObject = memberObject;
			this.memberName = memberName;
			this.objectInfo = objectInfo;
		}

		internal void Fixup(ParseRecord record, ParseRecord parent) {
            Object obj = record.PRnewObj;
			SerTrace.Log(this, "Fixup ",obj," ",((Enum)valueFixupEnum).ToString());

			switch(valueFixupEnum)
			{
				case ValueFixupEnum.Array:
					arrayObj.SetValue(obj, indexMap);
					break;
				case ValueFixupEnum.Header:
					Type type = typeof(Header);
					if (valueInfo == null)
					{
						MemberInfo[] valueInfos = type.GetMember("Value");
						if (valueInfos.Length != 1)
							throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_HeaderReflection"),valueInfos.Length));																				
						valueInfo = valueInfos[0];
					}
					FormatterServices.SerializationSetValue(valueInfo, header, obj);
					break;
				case ValueFixupEnum.Member:
					SerTrace.Log(this, "Fixup Member new object value ",obj," memberObject ",memberObject);

                    if (objectInfo.isSi) {
                        SerTrace.Log(this, "Recording a fixup on member: ", memberName, 
                                     " in object id", parent.PRobjectId, " Required Object ", record.PRobjectId);
                        objectInfo.objectManager.RecordDelayedFixup(parent.PRobjectId, memberName, record.PRobjectId);
//                          Console.WriteLine("SerializationInfo: Main Object ({0}): {1}. SubObject ({2}): {3}", parent.PRobjectId,
//                                            objectInfo.obj, record.PRobjectId, obj);
                    } else {
                        MemberInfo memberInfo = objectInfo.GetMemberInfo(memberName);
                        SerTrace.Log(this, "Recording a fixup on member:", memberInfo, " in object id ", 
                                     parent.PRobjectId," Required Object", record.PRobjectId);
                        objectInfo.objectManager.RecordFixup(parent.PRobjectId, memberInfo, record.PRobjectId);
//                          Console.WriteLine("MemberFixup: Main Object({0}): {1}. SubObject({2}): {3}", parent.PRobjectId,
//                                            objectInfo.obj.GetType(), record.PRobjectId, obj.GetType());

                    }
					break;
			}
		}

		public String Trace()
		{
			return "ValueFixup"+((Enum)valueFixupEnum).ToString();
		}
	}

	// Class used to transmit Enums from the XML and Binary Formatter class to the ObjectWriter and ObjectReader class
	internal sealed class InternalFE
	{
		internal FormatterTypeStyle FEtypeFormat;
		internal FormatterAssemblyStyle FEassemblyFormat;
		internal TypeFilterLevel FEsecurityLevel;
		internal InternalSerializerTypeE FEserializerTypeEnum;
	}


	internal sealed class NameInfo
	{
		internal String NIFullName; // Name from SerObjectInfo.GetType
		internal long NIobjectId;
		internal long NIassemId;
		internal InternalPrimitiveTypeE NIprimitiveTypeEnum = InternalPrimitiveTypeE.Invalid;
		internal Type NItype;
		internal bool NIisSealed;
		internal bool NIisArray;
		internal bool NIisArrayItem;
		internal bool NItransmitTypeOnObject;
		internal bool NItransmitTypeOnMember;
		internal bool NIisParentTypeOnObject;
        internal InternalArrayTypeE NIarrayEnum;

		private static int count;

		internal NameInfo()
		{
			//Counter();
		}

		[Conditional("SER_LOGGING")]
		private void Counter()
		{
			lock(typeof(NameInfo))
			{
				//NIid = count++;
			}
		}

		internal void Init()
		{
			NIFullName = null;
			NIobjectId = 0;
			NIassemId = 0;
			NIprimitiveTypeEnum = InternalPrimitiveTypeE.Invalid;
			NItype = null;
			NIisSealed = false;
			NItransmitTypeOnObject = false;
			NItransmitTypeOnMember = false;
			NIisParentTypeOnObject = false;
			NIisArray = false;
			NIisArrayItem = false;
            NIarrayEnum = InternalArrayTypeE.Empty;
            NIsealedStatusChecked = false;
		}

		[Conditional("SER_LOGGING")]
		internal void Dump(String value)
		{
			Util.NVTrace("name", NIFullName);
			Util.NVTrace("objectId", NIobjectId);
			Util.NVTrace("assemId", NIassemId);
			Util.NVTrace("primitiveTypeEnum", ((Enum)NIprimitiveTypeEnum).ToString());
			Util.NVTrace("type", NItype);
			Util.NVTrace("isSealed", NIisSealed);			
			Util.NVTrace("transmitTypeOnObject", NItransmitTypeOnObject);
			Util.NVTrace("transmitTypeOnMember", NItransmitTypeOnMember);
			Util.NVTrace("isParentTypeOnObject", NIisParentTypeOnObject);				
			Util.NVTrace("isArray", NIisArray);
			Util.NVTrace("isArrayItem", NIisArrayItem);
			Util.NVTrace("arrayEnum", ((Enum)NIarrayEnum).ToString());
		}

        private bool NIsealedStatusChecked = false;
        public bool IsSealed
        {
            get {
                if (!NIsealedStatusChecked)
                {
                    NIisSealed = NItype.IsSealed;
                    NIsealedStatusChecked = true;
                }
                return NIisSealed;
            }
        }

        public String NIname
        {
            get {
                if (this.NIFullName == null)
                    this.NIFullName = NItype.FullName;

                return this.NIFullName;
            }
            set {
                this.NIFullName = value;
            }
        }
	}

	internal sealed class PrimitiveArray
	{
		InternalPrimitiveTypeE code;
		Boolean[] booleanA = null;
		Char[] charA = null;
		Double[] doubleA = null;
		Int16[] int16A = null;
		Int32[] int32A = null;
		Int64[] int64A = null;
		SByte[] sbyteA = null;
		Single[] singleA = null;
		UInt16[] uint16A = null;
		UInt32[] uint32A = null;
		UInt64[] uint64A = null;


		internal PrimitiveArray(InternalPrimitiveTypeE code, Array array)
		{
			Init(code, array);
		}

		internal void Init(InternalPrimitiveTypeE code, Array array)
		{
			this.code = code;
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					booleanA = (Boolean[])array;
					break;
				case InternalPrimitiveTypeE.Char:
					charA = (Char[])array;
					break;					
				case InternalPrimitiveTypeE.Double:
					doubleA = (Double[])array;
					break;					
				case InternalPrimitiveTypeE.Int16:
					int16A = (Int16[])array;
					break;					
				case InternalPrimitiveTypeE.Int32:
					int32A = (Int32[])array;
					break;					
				case InternalPrimitiveTypeE.Int64:
					int64A = (Int64[])array;
					break;					
				case InternalPrimitiveTypeE.SByte:
					sbyteA = (SByte[])array;
					break;					
				case InternalPrimitiveTypeE.Single:
					singleA = (Single[])array;
					break;					
				case InternalPrimitiveTypeE.UInt16:
					uint16A = (UInt16[])array;
					break;					
				case InternalPrimitiveTypeE.UInt32:
					uint32A = (UInt32[])array;
					break;					
				case InternalPrimitiveTypeE.UInt64:
					uint64A = (UInt64[])array;
					break;
			}
		}

		internal String GetValue(int index)
		{
			String value = null;
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					value =  (booleanA[index]).ToString();
					break;
				case InternalPrimitiveTypeE.Char:
					if (charA[index] == Char.MinValue)
						value = "_0x00_";
					else
						value =  Char.ToString(charA[index]);
					break;					
				case InternalPrimitiveTypeE.Double:
					value =  (doubleA[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int16:
					value =  (int16A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int32:
					value =  (int32A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Int64:
					value =  (int64A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.SByte:
					value =  (sbyteA[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.Single:
					value =  (singleA[index]).ToString(CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt16:
					value =  (uint16A[index]).ToString(CultureInfo.InvariantCulture);
					break;
				case InternalPrimitiveTypeE.UInt32:
					value =  (uint32A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
				case InternalPrimitiveTypeE.UInt64:
					value =  (uint64A[index]).ToString(CultureInfo.InvariantCulture);
					break;					
			}
			return value;
		}

		internal void SetValue(String value, int index)
		{
			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					booleanA[index] = Boolean.Parse(value);
					break;
				case InternalPrimitiveTypeE.Char:
					if ((value[0] == '_') && (value.Equals("_0x00_")))
						charA[index] = Char.MinValue;
					else
						charA[index] = Char.Parse(value);
					break;					
				case InternalPrimitiveTypeE.Double:
					doubleA[index] = Double.Parse(value);										
					break;					
				case InternalPrimitiveTypeE.Int16:
					int16A[index] = Int16.Parse(value);															
					break;					
				case InternalPrimitiveTypeE.Int32:
					int32A[index] = Int32.Parse(value);																				
					break;					
				case InternalPrimitiveTypeE.Int64:
					int64A[index] = Int64.Parse(value);																									
					break;					
				case InternalPrimitiveTypeE.SByte:
					sbyteA[index] = SByte.Parse(value);
					break;					
				case InternalPrimitiveTypeE.Single:
					singleA[index] = Single.Parse(value);
					break;
				case InternalPrimitiveTypeE.UInt16:
					uint16A[index] = UInt16.Parse(value);
					break;
				case InternalPrimitiveTypeE.UInt32:
					uint32A[index] = UInt32.Parse(value);					
					break;					
				case InternalPrimitiveTypeE.UInt64:
					uint64A[index] = UInt64.Parse(value);					
					break;					
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\icodeaccesssecurityengine.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    
    using System;
    using System.Threading;

    internal interface ICodeAccessSecurityEngine
    {
    	void Check(CodeAccessPermission cap, ref StackCrawlMark stackMark);
    	
    	void CheckImmediate(CodeAccessPermission cap, ref StackCrawlMark stackMark);
        
        void Check(PermissionSet permSet, ref StackCrawlMark stackMark);
        
        void CheckImmediate(PermissionSet permSet, ref StackCrawlMark stackMark);
        
    	void Assert(CodeAccessPermission cap, ref StackCrawlMark stackMark);
    	
    	void Deny(CodeAccessPermission cap, ref StackCrawlMark stackMark);
    	
    	void PermitOnly(CodeAccessPermission cap, ref StackCrawlMark stackMark);
    	
    	//boolean IsGranted(CodeAccessPermission cap);
        //  Not needed, although it might be useful to have:
        //    boolean IsGranted(CodeAccessPermission cap, Object obj);
    	
    	PermissionListSet GetCompressedStack(ref StackCrawlMark stackMark);
        
        PermissionSet GetPermissions(Object cl, out PermissionSet denied);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\ipermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IPermission.cool
//
// Defines the interface that all Permission objects must support.
// 

namespace System.Security
{

    /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission"]/*' />
    public interface IPermission : ISecurityEncodable
    {
        // NOTE: The constants that used to be defined here were moved to 
        // PermissionsEnum.cool due to CLS restrictions.

        // The integrity of the security system depends on a means to
        // copy objects so that references to sensitive objects are not
        // exposed outside of the runtime. Thus, all permissions must
        // implement Copy.
        // 
        // Makes an exact copy of the Permission.
        /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission.Copy"]/*' />
        IPermission Copy();

        /*
         * Methods to support the Installation, Registration, others... PolicyEngine
         */
    
        // Policy decisions and runtime mechanisms (for example, Deny)
        // require a means to retrieve shared state between two
        // permissions. If there is no shared state between two
        // instances, then the method should return null.
        // 
        // Could think of the method as GetCommonState,
        // but leave it as Intersect to avoid gratuitous name changes.
        // 
        // Returns a new permission with the permission-defined intersection
        // of the two permissions. The intersection is generally defined as
        // privilege parameters that are included by both 'this' and 'target'.
        // Returns null if 'target' is null or is of wrong type.
        // 
        /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission.Intersect"]/*' />
        IPermission Intersect(IPermission target);

        // The runtime policy manager also requires a means of combining the
        // state contained within two permissions of the same type in a logical OR
        // construct.  (The Union of two permission of different type is not defined, 
        // except when one of the two is a CompoundPermission of internal type equal
        // to the type of the other permission.)
        //
        // @param target Permission operand
        //

        /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission.Union"]/*' />
        IPermission Union(IPermission target);

        // IsSubsetOf defines a standard mechanism for determining
        // relative safety between two permission demands of the same type.
        // If one demand x demands no more than some other demand y, then
        // x.IsSubsetOf(y) should return true. In this case, if the
        // demand for y is satisfied, then it is possible to assume that
        // the demand for x would also be satisfied under the same
        // circumstances. On the other hand, if x demands something that y
        // does not, then x.IsSubsetOf(y) should return false; the fact
        // that x is satisfied by the current security context does not
        // also imply that the demand for y will also be satisfied.
        // 
        // Returns true if 'this' Permission allows no more access than the
        // argument.
        // 
        /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission.IsSubsetOf"]/*' />
        bool IsSubsetOf(IPermission target);

        // The Demand method is the fundamental part of the IPermission
        // interface from a component developer's perspective. The
        // permission represents the demand that the developer wants
        // satisfied, and Demand is the means to invoke the demand.
        // For each type of permission, the mechanism to verify the
        // demand will be different. However, to the developer, all
        // permissions invoke that mechanism through the Demand interface.
        // Mark this method as requiring a security object on the caller's frame
        // so the caller won't be inlined (which would mess up stack crawling).
        /// <include file='doc\IPermission.uex' path='docs/doc[@for="IPermission.Demand"]/*' />
        [DynamicSecurityMethodAttribute()]
        void Demand();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\isecurityencodable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ISecurityEncodable.cool
//
// All encodable security classes that support encoding need to
// implement this interface
//

namespace System.Security  {
    
    using System;
    using System.Security.Util;
    
    
    /// <include file='doc\ISecurityEncodable.uex' path='docs/doc[@for="ISecurityEncodable"]/*' />
    public interface ISecurityEncodable
    {
        /// <include file='doc\ISecurityEncodable.uex' path='docs/doc[@for="ISecurityEncodable.ToXml"]/*' />
        SecurityElement ToXml();
        /// <include file='doc\ISecurityEncodable.uex' path='docs/doc[@for="ISecurityEncodable.FromXml"]/*' />
    
        void FromXml( SecurityElement e );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\ievidencefactory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IEvidenceFactory.cool
//

namespace System.Security {
    using System.Runtime.Remoting;
    using System;
    using System.Security.Policy;
    /// <include file='doc\IEvidenceFactory.uex' path='docs/doc[@for="IEvidenceFactory"]/*' />
    public interface IEvidenceFactory
    {
        /// <include file='doc\IEvidenceFactory.uex' path='docs/doc[@for="IEvidenceFactory.Evidence"]/*' />
        Evidence Evidence
        {
            get;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\isecuritypolicyencodable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ISecurityPolicyEncodable.cool
//
// All encodable security classes that support encoding need to
// implement this interface
//

namespace System.Security  {
    
    using System;
    using System.Security.Util;
    using System.Security.Policy;
    
    
    /// <include file='doc\ISecurityPolicyEncodable.uex' path='docs/doc[@for="ISecurityPolicyEncodable"]/*' />
    public interface ISecurityPolicyEncodable
    {
        /// <include file='doc\ISecurityPolicyEncodable.uex' path='docs/doc[@for="ISecurityPolicyEncodable.ToXml"]/*' />
        SecurityElement ToXml( PolicyLevel level );
        /// <include file='doc\ISecurityPolicyEncodable.uex' path='docs/doc[@for="ISecurityPolicyEncodable.FromXml"]/*' />
    
        void FromXml( SecurityElement e, PolicyLevel level );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\runtime\serialization\formatters\binary\binaryparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** Class: BinaryParser
 **
 ** Author: Peter de Jong (pdejong)
 **
 ** Purpose: Parses Binary Stream
 **
 ** Date:  September 14, 1999
 **
 ===========================================================*/


namespace System.Runtime.Serialization.Formatters.Binary {

	using System;
	using System.IO;
	using System.Collections;
	using System.Reflection;
    using System.Globalization;
	using System.Runtime.Serialization.Formatters;
	using System.Threading;
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
    using System.Text;

	internal sealed  class __BinaryParser
	{
		internal ObjectReader objectReader;
		internal Stream input;
		internal long topId;
		internal long headerId;
		internal SizedArray objectMapIdTable;
		internal SizedArray assemIdToAssemblyTable;	// Used to hold assembly information		
		internal SerStack stack = new SerStack("ObjectProgressStack");

		internal BinaryTypeEnum expectedType = BinaryTypeEnum.ObjectUrt;
		internal Object expectedTypeInformation;
		internal ParseRecord PRS;

        private BinaryAssemblyInfo systemAssemblyInfo;
		private BinaryReader dataReader;

		private SerStack opPool;		

		internal __BinaryParser(Stream stream, ObjectReader objectReader)
		{
			input = stream;
			this.objectReader = objectReader;
			dataReader = new BinaryReader(input, new UTF8Encoding(false, true));
		}

        internal BinaryAssemblyInfo SystemAssemblyInfo
        {
            get {
                if (systemAssemblyInfo == null)
                    systemAssemblyInfo = new BinaryAssemblyInfo(Converter.urtAssemblyString, Converter.urtAssembly);
                return systemAssemblyInfo;
            }
        }
        
        internal SizedArray ObjectMapIdTable
        {
            get {
                if (objectMapIdTable == null)
                    objectMapIdTable = new SizedArray();
                return objectMapIdTable;
            }
        }
        
        internal SizedArray AssemIdToAssemblyTable
        {
            get {
                if (assemIdToAssemblyTable == null)
                    assemIdToAssemblyTable = new SizedArray(2);
                return assemIdToAssemblyTable;
            }
        }

        internal ParseRecord prs
        {
            get{
                if (PRS == null)
                    PRS = new ParseRecord();
                return PRS; 
            }
        }
        
		/*
		 * Parse the input
		 * Reads each record from the input stream. If the record is a primitive type (A number)
		 *  then it doesn't have a BinaryHeaderEnum byte. For this case the expected type
		 *  has been previously set to Primitive
		 * @internalonly
		 */ 	
		internal void Run()
		{
			try
			{			
				bool isLoop = true;
				ReadBegin();
				ReadSerializationHeaderRecord();
				while(isLoop)
				{
					SerTrace.Log( this, "Run loop ",((Enum)expectedType).ToString());
					BinaryHeaderEnum binaryHeaderEnum = BinaryHeaderEnum.Object;
					switch(expectedType)
					{
						case BinaryTypeEnum.ObjectUrt:
						case BinaryTypeEnum.ObjectUser:
						case BinaryTypeEnum.String:
                        case BinaryTypeEnum.Object:
                        case BinaryTypeEnum.ObjectArray:
                        case BinaryTypeEnum.StringArray:
                        case BinaryTypeEnum.PrimitiveArray:
							Byte inByte = dataReader.ReadByte();
							binaryHeaderEnum = (BinaryHeaderEnum)inByte;
                            //Console.WriteLine("Beginning of loop "+((Enum)binaryHeaderEnum).ToString());
							switch(binaryHeaderEnum)
							{
                                case BinaryHeaderEnum.Assembly:
                                case BinaryHeaderEnum.CrossAppDomainAssembly:
									ReadAssembly(binaryHeaderEnum);
									break;
								case BinaryHeaderEnum.Object:
									ReadObject();
									break;
                                case BinaryHeaderEnum.CrossAppDomainMap:
                                    ReadCrossAppDomainMap();
                                    break;
								case BinaryHeaderEnum.ObjectWithMap:
                                case BinaryHeaderEnum.ObjectWithMapAssemId:
									ReadObjectWithMap(binaryHeaderEnum);
									break;
								case BinaryHeaderEnum.ObjectWithMapTyped:
								case BinaryHeaderEnum.ObjectWithMapTypedAssemId:
									ReadObjectWithMapTyped(binaryHeaderEnum);									
									break;
								case BinaryHeaderEnum.MethodCall:
								case BinaryHeaderEnum.MethodReturn:
									ReadMethodObject(binaryHeaderEnum);									
									break;
                                case BinaryHeaderEnum.ObjectString:
                                case BinaryHeaderEnum.CrossAppDomainString:
									ReadObjectString(binaryHeaderEnum);
									break;
                                case BinaryHeaderEnum.Array:
                                case BinaryHeaderEnum.ArraySinglePrimitive:
                                case BinaryHeaderEnum.ArraySingleObject:
								case BinaryHeaderEnum.ArraySingleString:
									ReadArray(binaryHeaderEnum);
									break;
								case BinaryHeaderEnum.MemberPrimitiveTyped:
									ReadMemberPrimitiveTyped();
									break;																
								case BinaryHeaderEnum.MemberReference:
									ReadMemberReference();
									break;
                                case BinaryHeaderEnum.ObjectNull:
                                case BinaryHeaderEnum.ObjectNullMultiple256:
								case BinaryHeaderEnum.ObjectNullMultiple:
									ReadObjectNull(binaryHeaderEnum);
									break;
								case BinaryHeaderEnum.MessageEnd:
									isLoop = false;
									ReadMessageEnd();
									ReadEnd();
									break;
								default:
									throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_BinaryHeader"),inByte));
							}
							break;
						case BinaryTypeEnum.Primitive:
							ReadMemberPrimitiveUnTyped();
							break;
						default:
							throw new SerializationException(Environment.GetResourceString("Serialization_TypeExpected"));

					}

					// If an assembly is encountered, don't advance
					// object Progress, 
					if (binaryHeaderEnum != BinaryHeaderEnum.Assembly)
					{
						// End of parse loop.
						bool isData = false;
						// Set up loop for next iteration.
						// If this is an object, and the end of object has been reached, then parse object end.
						while(!isData)
						{
							ObjectProgress op = (ObjectProgress)stack.Peek();
							if (op == null)
							{
								// No more object on stack, then the next record is a top level object
								SerTrace.Log( this, "Run loop op null, top level object");						
								expectedType = BinaryTypeEnum.ObjectUrt;
								expectedTypeInformation = null;
								isData = true;
							}
							else
							{
								SerTrace.Log( this, "Run loop op not null, continue object");
								// Find out what record is expected next
								isData = op.GetNext(out op.expectedType, out op.expectedTypeInformation);
								expectedType = op.expectedType;
								expectedTypeInformation = op.expectedTypeInformation;
								SerTrace.Log( this, "Run loop opName ",op.name,", expectedType ",((Enum)expectedType).ToString()," expectedTypeInformation, ",expectedTypeInformation);

								SerTrace.Log( this, "Run ",isData);		
								if (!isData)
								{
									// No record is expected next, this is the end of an object or array
									SerTrace.Log( this, "Run End of Object ");
									stack.Dump();

                                    prs.Init();
									if (op.memberValueEnum == InternalMemberValueE.Nested)
									{
										// Nested object
										prs.PRparseTypeEnum = InternalParseTypeE.MemberEnd;
										prs.PRmemberTypeEnum = op.memberTypeEnum;
										prs.PRmemberValueEnum = op.memberValueEnum;
										objectReader.Parse(prs);
									}
									else
									{
										// Top level object
										prs.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;
										prs.PRmemberTypeEnum = op.memberTypeEnum;
										prs.PRmemberValueEnum = op.memberValueEnum;								
										objectReader.Parse(prs);
									}
									stack.Pop();
									PutOp(op);
								}
							}
						}
					}
				}
			}
			catch(EndOfStreamException)
			{

				// EOF should never be thrown since there is a MessageEnd record to stop parsing
				BCLDebug.Trace("BINARY", "\n*****EOF*************************\n");
				throw new SerializationException(Environment.GetResourceString("Serialization_StreamEnd"));				
			}
		}


		internal void ReadBegin()
		{
			BCLDebug.Trace("BINARY", "\n%%%%%BinaryReaderBegin%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
		}

		internal void ReadEnd()
		{
			BCLDebug.Trace("BINARY","\n%%%%%BinaryReaderEnd%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
		}

		/*
		 * Primitive Reads from Stream
		 * @internalonly
		 */

		internal bool ReadBoolean()
		{
			return dataReader.ReadBoolean();
		}

		internal Byte ReadByte()
		{
			return dataReader.ReadByte();
		}

		internal Byte[] ReadBytes(int length)
		{
			return dataReader.ReadBytes(length);
		}

        // Note: this method does a blocking read!
		internal void ReadBytes(byte[] byteA, int offset, int size)
		{
            while (size > 0) {
                int n = dataReader.Read(byteA, offset, size);
                if (n == 0)
                    __Error.EndOfFile();
                offset += n;
                size -= n;
            }
		}

		internal Char ReadChar()
		{
			return dataReader.ReadChar();
		}

		internal Char[] ReadChars(int length)
		{
			return dataReader.ReadChars(length);			
		}		

		internal Decimal ReadDecimal()
		{
			return Decimal.Parse(dataReader.ReadString(), CultureInfo.InvariantCulture);
		}

		internal Single ReadSingle()
		{
			return dataReader.ReadSingle();
		}	

		internal Double ReadDouble()
		{
			return dataReader.ReadDouble();
		}

		internal Int16 ReadInt16()
		{
			return dataReader.ReadInt16();
		}

		internal Int32 ReadInt32()
		{
			return dataReader.ReadInt32();
		}

		internal Int64 ReadInt64()
		{
			return dataReader.ReadInt64();
		}

		internal SByte ReadSByte()
		{
			return (SByte)ReadByte();
		}

		internal String ReadString()
		{
		return dataReader.ReadString();
		}

		internal TimeSpan ReadTimeSpan()
		{
			return new TimeSpan(ReadInt64());
		}

		internal DateTime ReadDateTime()
		{
			return new DateTime(ReadInt64());
		}

		internal UInt16 ReadUInt16()
		{
			return dataReader.ReadUInt16();			
		}

		internal UInt32 ReadUInt32()
		{
			return dataReader.ReadUInt32();			
		}

		internal UInt64 ReadUInt64()
		{
			return dataReader.ReadUInt64();			
		}


		// Binary Stream Record Reads
		internal void ReadSerializationHeaderRecord()
		{
			SerTrace.Log( this, "ReadSerializationHeaderRecord");
			SerializationHeaderRecord record = new SerializationHeaderRecord();
			record.Read(this);
			record.Dump();
			this.topId = (record.topId > 0 ? objectReader.GetId(record.topId) : record.topId);
            this.headerId = (record.headerId > 0 ? objectReader.GetId(record.headerId) : record.headerId);
		}

		internal void ReadAssembly(BinaryHeaderEnum binaryHeaderEnum)
		{
			SerTrace.Log( this, "ReadAssembly");
			BinaryAssembly record = new BinaryAssembly();
            if (binaryHeaderEnum == BinaryHeaderEnum.CrossAppDomainAssembly)
            {
                BinaryCrossAppDomainAssembly crossAppDomainAssembly = new BinaryCrossAppDomainAssembly();
                crossAppDomainAssembly.Read(this);
                crossAppDomainAssembly.Dump();
                record.assemId = crossAppDomainAssembly.assemId;
                record.assemblyString = objectReader.CrossAppDomainArray(crossAppDomainAssembly.assemblyIndex) as String;
                if (record.assemblyString == null)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_CrossAppDomainError"),"String", crossAppDomainAssembly.assemblyIndex));                    

            }
            else
            {
                record.Read(this);
                record.Dump();
            }

			AssemIdToAssemblyTable[record.assemId] = new BinaryAssemblyInfo(record.assemblyString);
		}

        internal void ReadMethodObject(BinaryHeaderEnum binaryHeaderEnum)
        {
			SerTrace.Log( this, "ReadMethodObject");
            if (binaryHeaderEnum == BinaryHeaderEnum.MethodCall)
            {
                BinaryMethodCall record = new BinaryMethodCall();
                record.Read(this);
                record.Dump();
                objectReader.SetMethodCall(record);
            }
            else
            {
                BinaryMethodReturn record = new BinaryMethodReturn();
                record.Read(this);
                record.Dump();
                objectReader.SetMethodReturn(record);
            }
		}
		

        private BinaryObject binaryObject;

        private void ReadObject()
        {
            SerTrace.Log( this, "ReadObject");

            if (binaryObject == null)
			    binaryObject = new BinaryObject();
			binaryObject.Read(this);
			binaryObject.Dump();

			ObjectMap objectMap = (ObjectMap)ObjectMapIdTable[binaryObject.mapId];
			if (objectMap == null)
				throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Map"),binaryObject.mapId));				

			ObjectProgress op = GetOp();
			ParseRecord pr = op.pr;
			stack.Push(op);

			op.objectTypeEnum = InternalObjectTypeE.Object;
			op.binaryTypeEnumA = objectMap.binaryTypeEnumA;
			op.memberNames = objectMap.memberNames;
			op.memberTypes = objectMap.memberTypes;
			op.typeInformationA = objectMap.typeInformationA;
			op.memberLength = op.binaryTypeEnumA.Length;
			ObjectProgress objectOp = (ObjectProgress)stack.PeekPeek();
			if ((objectOp == null) || (objectOp.isInitial))
			{
				// Non-Nested Object
				SerTrace.Log( this, "ReadObject non-nested ");				
				op.name = objectMap.objectName;
				pr.PRparseTypeEnum = InternalParseTypeE.Object;
				op.memberValueEnum = InternalMemberValueE.Empty;			
			}
			else
			{
				// Nested Object
				SerTrace.Log( this, "ReadObject nested ");								
				pr.PRparseTypeEnum = InternalParseTypeE.Member;
				pr.PRmemberValueEnum = InternalMemberValueE.Nested;
				op.memberValueEnum = InternalMemberValueE.Nested;

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						pr.PRname = objectOp.name;						
						pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
						op.memberTypeEnum = InternalMemberTypeE.Field;
						break;
					case InternalObjectTypeE.Array:
						pr.PRmemberTypeEnum = InternalMemberTypeE.Item;
						op.memberTypeEnum = InternalMemberTypeE.Item;					
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Map"),((Enum)objectOp.objectTypeEnum).ToString()));										
				}
			}


			pr.PRobjectId = objectReader.GetId((long)binaryObject.objectId);
			SerTrace.Log( this, "ReadObject binaryObject.objectId ",pr.PRobjectId);							
			pr.PRobjectInfo = objectMap.CreateObjectInfo(ref pr.PRsi, ref pr.PRmemberData);

			if (pr.PRobjectId == topId)
				pr.PRobjectPositionEnum = InternalObjectPositionE.Top;

			pr.PRobjectTypeEnum = InternalObjectTypeE.Object;		
			pr.PRkeyDt = objectMap.objectName;
			pr.PRdtType = objectMap.objectType;
			pr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			objectReader.Parse(pr);
		}

        internal void ReadCrossAppDomainMap()
        {
			SerTrace.Log( this, "ReadObjectWithCrossAppDomainMap");
			BinaryCrossAppDomainMap record = new BinaryCrossAppDomainMap();
			record.Read(this);
			record.Dump();
            Object mapObject = objectReader.CrossAppDomainArray(record.crossAppDomainArrayIndex);
            BinaryObjectWithMap binaryObjectWithMap = mapObject as BinaryObjectWithMap;
            if (binaryObjectWithMap != null)
            {
                binaryObjectWithMap.Dump();
                ReadObjectWithMap(binaryObjectWithMap);
            }
            else
            {
                BinaryObjectWithMapTyped binaryObjectWithMapTyped = mapObject as BinaryObjectWithMapTyped;
                if (binaryObjectWithMapTyped != null)
                {
                    binaryObjectWithMapTyped.Dump();
                    ReadObjectWithMapTyped(binaryObjectWithMapTyped);
                }
                else 
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_CrossAppDomainError"),"BinaryObjectMap", mapObject));
            }
        }


        private BinaryObjectWithMap bowm;

        internal void ReadObjectWithMap(BinaryHeaderEnum binaryHeaderEnum)
        {
            SerTrace.Log( this, "ReadObjectWithMap");
            if (bowm == null)
			    bowm = new BinaryObjectWithMap(binaryHeaderEnum);
            else
                bowm.binaryHeaderEnum = binaryHeaderEnum;
            bowm.Read(this);
            bowm.Dump();
            ReadObjectWithMap(bowm);
        }

        private void ReadObjectWithMap(BinaryObjectWithMap record)
        {
			BinaryAssemblyInfo assemblyInfo = null;
			ObjectProgress op = GetOp();
			ParseRecord pr = op.pr;
			stack.Push(op);


			if (record.binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapAssemId)
			{
				if (record.assemId < 1)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Assembly"),record.name));

				assemblyInfo = ((BinaryAssemblyInfo)AssemIdToAssemblyTable[record.assemId]);

				if (assemblyInfo == null)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_Assembly"),record.assemId+" "+record.name));					
				SerTrace.Log( this, "ReadObjectWithMap  lookup assemIdToAssembly assemId ",record.assemId," assembly ",assemblyInfo.assemblyString);				
			}
			else if (record.binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMap)
			{

				assemblyInfo = SystemAssemblyInfo; //Urt assembly
			}

		    Type objectType = objectReader.GetType(assemblyInfo, record.name);
			
			ObjectMap objectMap = ObjectMap.Create(record.name, objectType, record.memberNames, objectReader, record.objectId, assemblyInfo);
			ObjectMapIdTable[record.objectId] = objectMap;

			op.objectTypeEnum = InternalObjectTypeE.Object;		
			op.binaryTypeEnumA = objectMap.binaryTypeEnumA;
			op.typeInformationA = objectMap.typeInformationA;		
			op.memberLength = op.binaryTypeEnumA.Length;
			op.memberNames = objectMap.memberNames;
			op.memberTypes = objectMap.memberTypes;

			ObjectProgress objectOp = (ObjectProgress)stack.PeekPeek();

			if ((objectOp == null) || (objectOp.isInitial))
			{
				// Non-Nested Object
				op.name = record.name;
				pr.PRparseTypeEnum = InternalParseTypeE.Object;
				op.memberValueEnum = InternalMemberValueE.Empty;									

			}
			else
			{
				// Nested Object
				pr.PRparseTypeEnum = InternalParseTypeE.Member;
				pr.PRmemberValueEnum = InternalMemberValueE.Nested;
				op.memberValueEnum = InternalMemberValueE.Nested;						

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						pr.PRname = objectOp.name;						
						pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
						op.memberTypeEnum = InternalMemberTypeE.Field;					
						break;
					case InternalObjectTypeE.Array:
						pr.PRmemberTypeEnum = InternalMemberTypeE.Item;
						op.memberTypeEnum = InternalMemberTypeE.Field;					
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectTypeEnum"),((Enum)objectOp.objectTypeEnum).ToString()));						
				}

			}
			pr.PRobjectTypeEnum = InternalObjectTypeE.Object;
			pr.PRobjectId = objectReader.GetId((long)record.objectId);
			pr.PRobjectInfo = objectMap.CreateObjectInfo(ref pr.PRsi, ref pr.PRmemberData);

			if (pr.PRobjectId == topId)
				pr.PRobjectPositionEnum = InternalObjectPositionE.Top;

			pr.PRkeyDt = record.name;
			pr.PRdtType = objectMap.objectType;
			pr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			objectReader.Parse(pr);
		}

        private BinaryObjectWithMapTyped bowmt;

        internal void ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum)		
        {
            SerTrace.Log( this, "ReadObjectWithMapTyped");
            if (bowmt == null)
                bowmt = new BinaryObjectWithMapTyped(binaryHeaderEnum);
            else
                bowmt.binaryHeaderEnum = binaryHeaderEnum;
            bowmt.Read(this);
            bowmt.Dump();
            ReadObjectWithMapTyped(bowmt);
        }

        private void ReadObjectWithMapTyped(BinaryObjectWithMapTyped record)
        {
			BinaryAssemblyInfo assemblyInfo = null;
			ObjectProgress op = GetOp();
			ParseRecord pr = op.pr;
			stack.Push(op);

			if (record.binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapTypedAssemId)
			{
				if (record.assemId < 1)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyId"),record.name));

				assemblyInfo = (BinaryAssemblyInfo)AssemIdToAssemblyTable[record.assemId];
				if (assemblyInfo == null)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyId"),record.assemId+" "+record.name));					

				SerTrace.Log( this, "ReadObjectWithMapTyped  lookup assemIdToAssembly assemId ",record.assemId," assembly ",assemblyInfo.assemblyString);								
			}
			else if (record.binaryHeaderEnum == BinaryHeaderEnum.ObjectWithMapTyped)
			{
				assemblyInfo = SystemAssemblyInfo; // Urt assembly
			}

			ObjectMap objectMap = ObjectMap.Create(record.name, record.memberNames, record.binaryTypeEnumA, record.typeInformationA, record.memberAssemIds, objectReader, record.objectId, assemblyInfo, AssemIdToAssemblyTable);
			ObjectMapIdTable[record.objectId] = objectMap;
			op.objectTypeEnum = InternalObjectTypeE.Object;
			op.binaryTypeEnumA = objectMap.binaryTypeEnumA;
			op.typeInformationA = objectMap.typeInformationA;				
			op.memberLength = op.binaryTypeEnumA.Length;
			op.memberNames = objectMap.memberNames;
			op.memberTypes = objectMap.memberTypes;

			ObjectProgress objectOp = (ObjectProgress)stack.PeekPeek();

			if ((objectOp == null) || (objectOp.isInitial))
			{
				// Non-Nested Object
				op.name = record.name;
				pr.PRparseTypeEnum = InternalParseTypeE.Object;
				op.memberValueEnum = InternalMemberValueE.Empty;						
			}
			else
			{
				// Nested Object
				pr.PRparseTypeEnum = InternalParseTypeE.Member;
				pr.PRmemberValueEnum = InternalMemberValueE.Nested;
				op.memberValueEnum = InternalMemberValueE.Nested;			

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						pr.PRname = objectOp.name;						
						pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
						op.memberTypeEnum = InternalMemberTypeE.Field;					
						break;
					case InternalObjectTypeE.Array:
						pr.PRmemberTypeEnum = InternalMemberTypeE.Item;
						op.memberTypeEnum = InternalMemberTypeE.Item;					
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectTypeEnum"),((Enum)objectOp.objectTypeEnum).ToString()));
				}

			}

			pr.PRobjectTypeEnum = InternalObjectTypeE.Object;
			pr.PRobjectInfo = objectMap.CreateObjectInfo(ref pr.PRsi, ref pr.PRmemberData);
			pr.PRobjectId = objectReader.GetId((long)record.objectId);				
			if (pr.PRobjectId == topId)
				pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
			pr.PRkeyDt = record.name;
			pr.PRdtType = objectMap.objectType;
			pr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			objectReader.Parse(pr);
		}

		internal BinaryObjectString objectString;
        internal BinaryCrossAppDomainString crossAppDomainString;

		private void ReadObjectString(BinaryHeaderEnum binaryHeaderEnum)
		{
			SerTrace.Log( this, "ReadObjectString");

            if (objectString == null)
                objectString = new BinaryObjectString();

            if (binaryHeaderEnum == BinaryHeaderEnum.ObjectString)
            {
                objectString.Read(this);
                objectString.Dump();
            }
            else
            {
                if (crossAppDomainString == null)
                    crossAppDomainString = new BinaryCrossAppDomainString();
                crossAppDomainString.Read(this);
                crossAppDomainString.Dump();
                objectString.value = objectReader.CrossAppDomainArray(crossAppDomainString.value) as String;
                if (objectString.value == null)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_CrossAppDomainError"),"String", crossAppDomainString.value));                    

                objectString.objectId = crossAppDomainString.objectId;
            }

			prs.Init();
			prs.PRparseTypeEnum = InternalParseTypeE.Object;
			prs.PRobjectId = objectReader.GetId(objectString.objectId);

			if (prs.PRobjectId == topId)
				prs.PRobjectPositionEnum = InternalObjectPositionE.Top;

			prs.PRobjectTypeEnum = InternalObjectTypeE.Object;

			ObjectProgress objectOp = (ObjectProgress)stack.Peek();

			prs.PRvalue = objectString.value;
			prs.PRkeyDt = "System.String";
			prs.PRdtType = Converter.typeofString;
			prs.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;
			prs.PRvarValue = objectString.value; //Need to set it because ObjectReader is picking up value from variant, not pr.PRvalue

			if (objectOp == null)
			{
				// Top level String
				SerTrace.Log( this, "ReadObjectString, Non-Nested");			
				prs.PRparseTypeEnum = InternalParseTypeE.Object;
				prs.PRname = "System.String";
			}
			else
			{
				// Nested in an Object

				SerTrace.Log( this, "ReadObjectString, Nested");
				prs.PRparseTypeEnum = InternalParseTypeE.Member;
				prs.PRmemberValueEnum = InternalMemberValueE.InlineValue;

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						prs.PRname = objectOp.name;
						prs.PRmemberTypeEnum = InternalMemberTypeE.Field;
						break;
					case InternalObjectTypeE.Array:					
						prs.PRmemberTypeEnum = InternalMemberTypeE.Item;
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectTypeEnum"),((Enum)objectOp.objectTypeEnum).ToString()));						
				}

			}

			objectReader.Parse(prs);
		}



		internal MemberPrimitiveTyped memberPrimitiveTyped;

		private void ReadMemberPrimitiveTyped()
		{
			SerTrace.Log( this, "ReadObjectPrimitive");

            if (memberPrimitiveTyped == null)
                memberPrimitiveTyped = new MemberPrimitiveTyped();

			memberPrimitiveTyped.Read(this);
			memberPrimitiveTyped.Dump();

			prs.PRobjectTypeEnum = InternalObjectTypeE.Object; //Get rid of 
			ObjectProgress objectOp = (ObjectProgress)stack.Peek();

			prs.Init();
			prs.PRvarValue = memberPrimitiveTyped.value;
			prs.PRkeyDt = Converter.ToComType(memberPrimitiveTyped.primitiveTypeEnum);
			prs.PRdtType = Converter.ToType(memberPrimitiveTyped.primitiveTypeEnum);
			prs.PRdtTypeCode = memberPrimitiveTyped.primitiveTypeEnum;

			if (objectOp == null)
			{
				// Top level boxed primitive
				SerTrace.Log( this, "ReadObjectPrimitive, Non-Nested");			
				prs.PRparseTypeEnum = InternalParseTypeE.Object;
				prs.PRname = "System.Variant";
			}
			else
			{
				// Nested in an Object
				SerTrace.Log( this, "ReadObjectPrimitive, Nested");

				prs.PRparseTypeEnum = InternalParseTypeE.Member;
				prs.PRmemberValueEnum = InternalMemberValueE.InlineValue;

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						prs.PRname = objectOp.name;
						prs.PRmemberTypeEnum = InternalMemberTypeE.Field;
						break;
					case InternalObjectTypeE.Array:
						prs.PRmemberTypeEnum = InternalMemberTypeE.Item;
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectTypeEnum"),((Enum)objectOp.objectTypeEnum).ToString()));												
				}
			}

			objectReader.Parse(prs);
		}


		private void ReadArray(BinaryHeaderEnum binaryHeaderEnum)
		{
			BinaryAssemblyInfo assemblyInfo = null;
			SerTrace.Log( this, "ReadArray ");
			BinaryArray record = new BinaryArray(binaryHeaderEnum);
			record.Read(this);
			record.Dump();

			SerTrace.Log( this, "Read 1 ",((Enum)binaryHeaderEnum).ToString());

			if (record.binaryTypeEnum == BinaryTypeEnum.ObjectUser)
			{
				if (record.assemId < 1)
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_AssemblyId"),record.typeInformation));

				assemblyInfo = (BinaryAssemblyInfo)AssemIdToAssemblyTable[record.assemId];
				SerTrace.Log( this, "ReadArray  lookup assemIdToAssembly assemId ",record.assemId," assembly ",assemblyInfo.assemblyString);								
			}
			else 
				assemblyInfo = SystemAssemblyInfo; //Urt assembly

			ObjectProgress op = GetOp();
			ParseRecord pr = op.pr;

			op.objectTypeEnum = InternalObjectTypeE.Array;
			op.binaryTypeEnum = record.binaryTypeEnum;
			op.typeInformation = record.typeInformation;

			ObjectProgress objectOp = (ObjectProgress)stack.PeekPeek();
			if ((objectOp == null) || (record.objectId > 0))
			{
				// Non-Nested Object
				op.name = "System.Array";
				pr.PRparseTypeEnum = InternalParseTypeE.Object;
				op.memberValueEnum = InternalMemberValueE.Empty;									
			}
			else
			{
				// Nested Object			
				pr.PRparseTypeEnum = InternalParseTypeE.Member;
				pr.PRmemberValueEnum = InternalMemberValueE.Nested;
				op.memberValueEnum = InternalMemberValueE.Nested;						

				switch(objectOp.objectTypeEnum)
				{
					case InternalObjectTypeE.Object:
						pr.PRname = objectOp.name;									
						pr.PRmemberTypeEnum = InternalMemberTypeE.Field;
						op.memberTypeEnum = InternalMemberTypeE.Field;					
						pr.PRkeyDt = objectOp.name;
						pr.PRdtType = objectOp.dtType;
						break;
					case InternalObjectTypeE.Array:
						pr.PRmemberTypeEnum = InternalMemberTypeE.Item;
						op.memberTypeEnum = InternalMemberTypeE.Item;					
						break;
					default:
						throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ObjectTypeEnum"),((Enum)objectOp.objectTypeEnum).ToString()));												
				}
			}


			pr.PRobjectId = objectReader.GetId((long)record.objectId);
			if (pr.PRobjectId == topId)
				pr.PRobjectPositionEnum = InternalObjectPositionE.Top;
			else if ((headerId > 0) &&(pr.PRobjectId == headerId))
				pr.PRobjectPositionEnum = InternalObjectPositionE.Headers; // Headers are an array of header objects
			else
				pr.PRobjectPositionEnum = InternalObjectPositionE.Child;

			pr.PRobjectTypeEnum = InternalObjectTypeE.Array;

			BinaryConverter.TypeFromInfo(record.binaryTypeEnum, record.typeInformation, objectReader, assemblyInfo,
										 out pr.PRarrayElementTypeCode, out pr.PRarrayElementTypeString,
										 out pr.PRarrayElementType, out pr.PRisArrayVariant);

			pr.PRdtTypeCode = InternalPrimitiveTypeE.Invalid;


			pr.PRrank = record.rank;
			pr.PRlengthA = record.lengthA;
			pr.PRlowerBoundA = record.lowerBoundA;
			bool isPrimitiveArray = false;

			switch(record.binaryArrayTypeEnum)
			{
				case BinaryArrayTypeEnum.Single:
				case BinaryArrayTypeEnum.SingleOffset:					
					op.numItems = record.lengthA[0];
					pr.PRarrayTypeEnum = InternalArrayTypeE.Single;
					if (Converter.IsWriteAsByteArray(pr.PRarrayElementTypeCode) &&
						 (record.lowerBoundA[0] == 0))
					{
						isPrimitiveArray = true;
						ReadArrayAsBytes(pr);
					}
					break;
				case BinaryArrayTypeEnum.Jagged:
				case BinaryArrayTypeEnum.JaggedOffset:					
					op.numItems = record.lengthA[0];
					pr.PRarrayTypeEnum = InternalArrayTypeE.Jagged;					
					break;
				case BinaryArrayTypeEnum.Rectangular:
				case BinaryArrayTypeEnum.RectangularOffset:					
					int arrayLength = 1;
					for (int i=0; i<record.rank; i++)
						arrayLength = arrayLength*record.lengthA[i];
					op.numItems = arrayLength;
					pr.PRarrayTypeEnum = InternalArrayTypeE.Rectangular;										
					break;
				default:
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_ArrayType"),((Enum)record.binaryArrayTypeEnum).ToString()));
			}

			if (!isPrimitiveArray)
				stack.Push(op);
			else
			{
				PutOp(op);
			}

			SerTrace.Log( this, "ReadArray ",((Enum)record.binaryArrayTypeEnum).ToString()," length ",op.numItems);				
			objectReader.Parse(pr);

			if (isPrimitiveArray)
			{
				pr.PRparseTypeEnum = InternalParseTypeE.ObjectEnd;
				objectReader.Parse(pr);
			}
		}

		private byte[] byteBuffer;
		private const int chunkSize = 4096;
		
		private void ReadArrayAsBytes(ParseRecord pr)
		{
			if (pr.PRarrayElementTypeCode == InternalPrimitiveTypeE.Byte)
				pr.PRnewObj = ReadBytes(pr.PRlengthA[0]);
			else if (pr.PRarrayElementTypeCode == InternalPrimitiveTypeE.Char)
				pr.PRnewObj = ReadChars(pr.PRlengthA[0]);
			else
			{
				int typeLength = Converter.TypeLength(pr.PRarrayElementTypeCode);

				pr.PRnewObj = Converter.CreatePrimitiveArray(pr.PRarrayElementTypeCode, pr.PRlengthA[0]);

				//pr.PRnewObj = Array.CreateInstance(pr.PRarrayElementType, pr.PRlengthA[0]);
                BCLDebug.Assert((pr.PRnewObj != null),"[BinaryParser expected a Primitive Array]");

				Array array = (Array)pr.PRnewObj;
				int arrayOffset = 0;
				if (byteBuffer == null)
					byteBuffer = new byte[chunkSize];

				while(arrayOffset < array.Length)
				{
					int numArrayItems = Math.Min(chunkSize/typeLength, array.Length-arrayOffset);
					int bufferUsed = numArrayItems*typeLength;
					ReadBytes(byteBuffer, 0, bufferUsed);
					Buffer.InternalBlockCopy(byteBuffer, 0, array, arrayOffset*typeLength, bufferUsed);
					arrayOffset += numArrayItems;
				}
			}
		}

		internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;

		private void ReadMemberPrimitiveUnTyped()
		{
			SerTrace.Log( this, "ReadMemberPrimitiveUnTyped ");		
			ObjectProgress objectOp = (ObjectProgress)stack.Peek();
            if (memberPrimitiveUnTyped == null)
                memberPrimitiveUnTyped = new MemberPrimitiveUnTyped();
			memberPrimitiveUnTyped.Set((InternalPrimitiveTypeE)expectedTypeInformation);
			memberPrimitiveUnTyped.Read(this);
			memberPrimitiveUnTyped.Dump();

			prs.Init();
			prs.PRvarValue = memberPrimitiveUnTyped.value;

			prs.PRdtTypeCode = (InternalPrimitiveTypeE)expectedTypeInformation;
			prs.PRdtType = Converter.ToType(prs.PRdtTypeCode);
			prs.PRparseTypeEnum = InternalParseTypeE.Member;
			prs.PRmemberValueEnum = InternalMemberValueE.InlineValue;

			if (objectOp.objectTypeEnum == InternalObjectTypeE.Object)
			{
				prs.PRmemberTypeEnum = InternalMemberTypeE.Field;
				prs.PRname = objectOp.name;
			}
			else
				prs.PRmemberTypeEnum = InternalMemberTypeE.Item;			

			objectReader.Parse(prs);
		}


		internal MemberReference memberReference;

		private void ReadMemberReference()
		{
			SerTrace.Log( this, "ReadMemberReference ");
            
            if (memberReference == null)
                memberReference = new MemberReference();
			memberReference.Read(this);
			memberReference.Dump();

			ObjectProgress objectOp = (ObjectProgress)stack.Peek();

			prs.Init();
			prs.PRidRef = objectReader.GetId((long)memberReference.idRef);
			prs.PRparseTypeEnum = InternalParseTypeE.Member;
			prs.PRmemberValueEnum = InternalMemberValueE.Reference;

			if (objectOp.objectTypeEnum == InternalObjectTypeE.Object)
			{
				prs.PRmemberTypeEnum = InternalMemberTypeE.Field;
				prs.PRname = objectOp.name;
				prs.PRdtType = objectOp.dtType;
			}
			else
				prs.PRmemberTypeEnum = InternalMemberTypeE.Item;


			objectReader.Parse(prs);
		}

		internal ObjectNull objectNull;

		private void ReadObjectNull(BinaryHeaderEnum binaryHeaderEnum)
		{
			SerTrace.Log( this, "ReadObjectNull ");

            if (objectNull == null)
                objectNull = new ObjectNull();

			objectNull.Read(this, binaryHeaderEnum);
			objectNull.Dump();

			ObjectProgress objectOp = (ObjectProgress)stack.Peek();

			prs.Init();
			prs.PRparseTypeEnum = InternalParseTypeE.Member;
			prs.PRmemberValueEnum = InternalMemberValueE.Null;

			if (objectOp.objectTypeEnum == InternalObjectTypeE.Object)
			{
				prs.PRmemberTypeEnum = InternalMemberTypeE.Field;
				prs.PRname = objectOp.name;
				prs.PRdtType = objectOp.dtType;			
			}
			else
			{
				prs.PRmemberTypeEnum = InternalMemberTypeE.Item;
                prs.PRnullCount = objectNull.nullCount; 
                //only one null position has been incremented by GetNext
                //The position needs to be reset for the rest of the nulls
                objectOp.ArrayCountIncrement(objectNull.nullCount-1); 
			}
            objectReader.Parse(prs);
		}

		internal static MessageEnd messageEnd;

		private void ReadMessageEnd()
		{
			SerTrace.Log( this, "ReadMessageEnd ");

            if (messageEnd == null)
                messageEnd = new MessageEnd();

			messageEnd.Read(this);

			messageEnd.Dump();

			if (!stack.IsEmpty())
			{
				SerTrace.Log( this, "ReadMessageEnd  Stack not empty ");
				stack.Dump();
				throw new SerializationException(Environment.GetResourceString("Serialization_StreamEnd"));
			}
		}


		// ReadValue from stream using InternalPrimitiveTypeE code
		internal Object ReadValue(InternalPrimitiveTypeE code)
		{
			SerTrace.Log( this, "ReadValue ",((Enum)code).ToString());
			Object var = null;

			switch(code)
			{
				case InternalPrimitiveTypeE.Boolean:
					var = ReadBoolean();
					break;
				case InternalPrimitiveTypeE.Byte:
					var = ReadByte();
					break;
				case InternalPrimitiveTypeE.Char:
					var = ReadChar();			
					break;
				case InternalPrimitiveTypeE.Double:
					var = ReadDouble();
					break;
				case InternalPrimitiveTypeE.Int16:
					var = ReadInt16();
					break;
				case InternalPrimitiveTypeE.Int32:
					var = ReadInt32();
					break;
				case InternalPrimitiveTypeE.Int64:
					var = ReadInt64();			
					break;
				case InternalPrimitiveTypeE.SByte:
					var = ReadSByte();
					break;
				case InternalPrimitiveTypeE.Single:
					var = ReadSingle();			
					break;
				case InternalPrimitiveTypeE.UInt16:
					var = ReadUInt16();						
					break;
				case InternalPrimitiveTypeE.UInt32:
					var = ReadUInt32();									
					break;
				case InternalPrimitiveTypeE.UInt64:
					var = ReadUInt64();												
					break;
				case InternalPrimitiveTypeE.Decimal:
					var = ReadDecimal();					
					break;
				case InternalPrimitiveTypeE.TimeSpan:
					var = ReadTimeSpan();										
					break;
				case InternalPrimitiveTypeE.DateTime:
					var = ReadDateTime();															
					break;
				default:
					throw new SerializationException(String.Format(Environment.GetResourceString("Serialization_TypeCode"),((Enum)code).ToString()));
			}
			SerTrace.Log( "ReadValue Exit ",var);
			return var;
		}

		private ObjectProgress GetOp()
		{
			ObjectProgress op = null;

			if (opPool != null && !opPool.IsEmpty())
			{
				op = (ObjectProgress)opPool.Pop();
				op.Init();
			}
			else
				op = new ObjectProgress();

			return op;
		}

		private void PutOp(ObjectProgress op)
		{
            if (opPool == null)
                opPool = new SerStack("opPool");
			opPool.Push(op);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\framesecuritydescriptor.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
	using System.Text;
	using System.Runtime.CompilerServices;
    //FrameSecurityDescriptor.cool
    //
    // Internal use only.
    // DO NOT DOCUMENT
    //
	using System;
	[Serializable()]
    sealed internal class FrameSecurityDescriptor : System.Object
    {
		//COOLPORT: Commenting this out to disable warning
        //private int                 m_flags; // currently unused
    
    	/*	EE looks up the following three fields using the field names.
    	*	If the names are ever changed, make corresponding changes to constants 
    	*	defined in COMSecurityRuntime.cpp	
    	*/
        private PermissionSet       m_assertions;
        private PermissionSet       m_denials;
        private PermissionSet       m_restriction;
        private bool                m_assertAllPossible;
        
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern void IncrementOverridesCount();
		[MethodImplAttribute(MethodImplOptions.InternalCall)]
		private static extern void DecrementOverridesCount();

        // Default constructor.
        internal FrameSecurityDescriptor()
        {
            //m_flags = 0;
        }
    
        internal FrameSecurityDescriptor Copy()
        {
            FrameSecurityDescriptor desc = new FrameSecurityDescriptor();
            if (this.m_assertions != null)
                desc.m_assertions = this.m_assertions.Copy();

            if (this.m_denials != null)
                desc.m_denials = this.m_denials.Copy();

            if (this.m_restriction != null)
                desc.m_restriction = this.m_restriction.Copy();

            desc.m_assertAllPossible = this.m_assertAllPossible;

            return desc;
        }
        
        //-----------------------------------------------------------+
        // H E L P E R
        //-----------------------------------------------------------+
        
        private PermissionSet CreateSingletonSet(IPermission perm)
        {
            PermissionSet permSet = new PermissionSet(false);
            permSet.AddPermission(perm.Copy());
            return permSet;
        }
    
        //-----------------------------------------------------------+
        // A S S E R T
        //-----------------------------------------------------------+
    
        internal void SetAssert(IPermission perm)
        {
            m_assertions = CreateSingletonSet(perm);
        }
        
        internal void SetAssert(PermissionSet permSet)
        {
            m_assertions = permSet.Copy();
        }
        
        internal PermissionSet GetAssertions()
        {
            return m_assertions;
        }

        internal void SetAssertAllPossible()
        {
            m_assertAllPossible = true;
        }

        internal bool GetAssertAllPossible()
        {
            return m_assertAllPossible;
        }
        
        //-----------------------------------------------------------+
        // D E N Y
        //-----------------------------------------------------------+
    
        internal void SetDeny(IPermission perm)
        {
			IncrementOverridesCount();
            m_denials = CreateSingletonSet(perm);
        }
        
        internal void SetDeny(PermissionSet permSet)
        {
			IncrementOverridesCount();
            m_denials = permSet.Copy();
        }
    
        internal PermissionSet GetDenials()
        {
            return m_denials;
        }
        
        //-----------------------------------------------------------+
        // R E S T R I C T
        //-----------------------------------------------------------+
    
        internal void SetPermitOnly(IPermission perm)
        {
            m_restriction = CreateSingletonSet(perm);
            
            // This increment should be the last operation in this method.
            // If placed earlier, CreateSingletonSet might trigger a security check, which will try to update the overrides count
            // But m_restriction would not be updated yet, so it'll reset override count to zero, which is wrong.
			IncrementOverridesCount();
        }
        
        internal void SetPermitOnly(PermissionSet permSet)
        {
            // permSet must not be null
            m_restriction = permSet.Copy();
            
            // This increment should be the last operation in this method.
            // If placed earlier, permSet.Copy might trigger a security check, which will try to update the overrides count
            // But m_restriction would not be updated yet, so it'll reset override count to zero, which is wrong.
			IncrementOverridesCount();
        }
        
        internal PermissionSet GetPermitOnly()
        {
            return m_restriction;
        }
        
        //-----------------------------------------------------------+
        // R E V E R T
        //-----------------------------------------------------------+
    
        internal void RevertAssert()
        {
            m_assertions = null;
        }
        
        internal void RevertAssertAllPossible()
        {
            m_assertAllPossible = false;
        }

        internal void RevertDeny()
        {
			if (m_denials != null)
				DecrementOverridesCount();
            m_denials = null;
        }
        
        internal void RevertPermitOnly()
        {
			if (m_restriction != null)
				DecrementOverridesCount();
            m_restriction = null;
        }

        internal void RevertAll()
        {
            RevertAssert();
            RevertAssertAllPossible();
			RevertDeny();
			RevertPermitOnly();
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\codeaccesssecurityengine.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    using System;
    using System.Threading;
    using System.Security.Util;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.Reflection;
    using System.Globalization;

    // Used in DemandInternal, to remember the result of previous demands
    // KEEP IN SYNC WITH DEFINITIONS IN SECURITY.H
        [Serializable]
    internal enum PermissionType
    {
        SecurityUnmngdCodeAccess    = 0x00,     // Used in EE
        SecuritySkipVerification    = 0x01,     // Used in EE
        ReflectionTypeInfo          = 0x02,     // Used in EE
        SecurityAssert              = 0x03, // Used in EE
        ReflectionMemberAccess      = 0x04, // Used in EE       
        SecuritySerialization       = 0x05,
        ReflectionEmit              = 0x06,
        FullTrust                   = 0x07, // Used in EE
        SecurityBindingRedirects    = 0x08,
        DefaultFlag                 = unchecked((int)0xFFFFFFFF)
    }

    internal class CodeAccessSecurityEngine
    {
        private const int DeepCheckCount       = -1;
        private const int ImmediateCheckCount  =  1;
    
        internal static SecurityPermission AssertPermission; 
        internal static PermissionToken AssertPermissionToken; 

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern PermissionListSet GetDomainPermissionListSet(out int status, Object demand, int capOrSet, PermissionType permType);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern PermissionListSet UpdateDomainPermissionListSet(out int status);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void UpdateOverridesCount(ref StackCrawlMark stackMark);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool GetResult(PermissionType whatPermission, out int timeStamp);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern void SetResult(PermissionType whatPermission, int timeStamp);

        // KEEP IN SYNC WITH DEFINITIONS IN SECURITY.H
        private const int CONTINUE          = 1;
        private const int NEED_UPDATED_PLS  = 2;
        private const int OVERRIDES_FOUND   = 3;
        private const int FULLY_TRUSTED     = 4;
        private const int MULTIPLE_DOMAINS  = 5;
        private const int BELOW_THRESHOLD   = 6;
        private const int PLS_IS_BUSY       = 7;
        private const int NEED_STACKWALK    = 8;
                private const int DEMAND_PASSES     = 9;
        private const int SECURITY_OFF      = 10;

        private const int CHECK_CAP         = 1;
        private const int CHECK_SET         = 2;

        [System.Diagnostics.Conditional( "_DEBUG" )]
        private static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    System.Text.StringBuilder sb = new System.Text.StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "d:\\foo\\debug.txt";
#endif  
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InitSecurityEngine();
        
        internal CodeAccessSecurityEngine()
        {
            InitSecurityEngine();
            AssertPermission = new SecurityPermission(SecurityPermissionFlag.Assertion);
            AssertPermissionToken = PermissionToken.GetToken(AssertPermission);
        }
        
        private static void CheckTokenBasedSetHelper( bool ignoreGrants,
                                                      TokenBasedSet grants,
                                                      TokenBasedSet denied,
                                                      TokenBasedSet demands )
        {
            if (demands == null)
                return;

            TokenBasedSetEnumerator enumerator = (TokenBasedSetEnumerator)demands.GetEnum();
            
            while (enumerator.MoveNext())
            {
                CodeAccessPermission demand = (CodeAccessPermission)enumerator.Current;
                int index = enumerator.GetCurrentIndex();

                if (demand != null)
                {
                    try
                    {
                        // Check to make sure the permission was granted, unless we are supposed
                        // to ignore grants.
                    
                        if (!ignoreGrants)
                        {
                            CodeAccessPermission grant
                                = grants != null ? (CodeAccessPermission)grants.GetItem(index) : null;
                            if (grant != null)
                            {
                                grant.CheckDemand(demand);
                            }
                            else
                            {
                                if (!demand.IsSubsetOf( null ))
                                    throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                            }
                        }
                    
                        // Check to make sure our permission was not denied.
                
                        if (denied != null)
                        {
                            CodeAccessPermission deny
                                = (CodeAccessPermission)denied.GetItem(index);
                            if (deny != null && deny.Intersect(demand) != null)
                                throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                        }
                    }
                    catch (Exception e)
                    {
                        // Any exception besides a security exception in this code means that
                        // a permission was unable to properly handle what we asked of it.
                        // We will define this to mean that the demand failed.
                        
                        if (e is SecurityException)
                            throw e;
                        else
                            throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                    }                                
                }
            }
        }
        
        private static void LazyCheckSetHelper( PermissionSet demands, IntPtr asmSecDesc )
        {
            if (demands.CanUnrestrictedOverride() == 1)
                return;

            PermissionSet grants;
            PermissionSet denied;

            _GetGrantedPermissionSet( asmSecDesc, out grants, out denied );

            CheckSetHelper( grants, denied, demands );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void _GetGrantedPermissionSet(IntPtr secDesc, 
                                                           out PermissionSet grants,
                                                           out PermissionSet denied );


        private static void CheckSetHelper(PermissionSet grants,
                                           PermissionSet denied,
                                           PermissionSet demands)
        {

    #if _DEBUG
            if (debug)
            {
                DEBUG_OUT("Granted: ");
                DEBUG_OUT(grants.ToXml().ToString());
                DEBUG_OUT("Denied: ");
                DEBUG_OUT(denied!=null ? denied.ToXml().ToString() : "<null>");
                DEBUG_OUT("Demanded: ");
                DEBUG_OUT(demands!=null ? demands.ToXml().ToString() : "<null>");
            }
    #endif

            if (demands == null || demands.IsEmpty())
                return;  // demanding the empty set always passes.

            if (grants == null)
            {
                throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
            }
            
            if (!grants.IsUnrestricted() || (denied != null))
            {
                if (demands.IsUnrestricted())
                {
                    throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"), grants, denied);
                }
                
                if (denied != null && denied.IsUnrestricted() && demands.m_unrestrictedPermSet.GetCount() != 0)
                    throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));

                CheckTokenBasedSetHelper( grants.IsUnrestricted(), grants.m_unrestrictedPermSet, denied != null ? denied.m_unrestrictedPermSet : null, demands.m_unrestrictedPermSet );
            }
            
            CheckTokenBasedSetHelper( false, grants.m_normalPermSet, denied != null ? denied.m_normalPermSet : null, demands.m_normalPermSet );
        }
                
        private static void CheckHelper(PermissionSet grantedSet,
                                        PermissionSet deniedSet,
                                        CodeAccessPermission demand, 
                                        PermissionToken permToken)
        {
    #if _DEBUG
            if (debug)
            {
                DEBUG_OUT("Granted: ");
                DEBUG_OUT(grantedSet.ToXml().ToString());
                DEBUG_OUT("Denied: ");
                DEBUG_OUT(deniedSet!=null ? deniedSet.ToXml().ToString() : "<null>");
                DEBUG_OUT("Demanded: ");
                DEBUG_OUT(demand.ToString());
            }
    #endif
            
            if (permToken == null)
                permToken = PermissionToken.GetToken(demand);

            // If PermissionSet is null, then module does not have Permissions... Fail check.
            
            try
            {
                if (grantedSet == null)
                {
                    throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
                } 
                else if (!grantedSet.IsUnrestricted() || !(demand is IUnrestrictedPermission))
                {
                    // If we aren't unrestricted, there is a denied set, or our permission is not of the unrestricted
                    // variety, we need to do the proper callback.
                
                    BCLDebug.Assert(demand != null,"demand != null");
                    
                    // Find the permission of matching type in the permission set.
                    
                    CodeAccessPermission grantedPerm = 
                                (CodeAccessPermission)grantedSet.GetPermission(permToken);
                                
                    // If there isn't a matching permission in the set and our demand is not a subset of null (i.e. empty)
                    // then throw an exception.
                                
                    if (grantedPerm == null)
                    {
                        if (!demand.IsSubsetOf( null ))
                            throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                        else
                            return;
                    }
                    
                    // Call the check demand for our permission.
                    
                    grantedPerm.CheckDemand(demand);
                }
                
                
                // Make the sure the permission is not denied.
    
                if (deniedSet != null)
                {
                    CodeAccessPermission deniedPerm = 
                        (CodeAccessPermission)deniedSet.GetPermission(permToken);
                    if (deniedPerm != null)
                    {
                        if (deniedPerm.Intersect(demand) != null)
                        {
        #if _DEBUG
                            if (debug)
                                DEBUG_OUT( "Permission found in denied set" );
        #endif
                            throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                        }
                    }

                    if (deniedSet.IsUnrestricted() && (demand is IUnrestrictedPermission))
                        throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                }
            }
            catch (Exception e)
            {
                // Any exception besides a security exception in this code means that
                // a permission was unable to properly handle what we asked of it.
                // We will define this to mean that the demand failed.
                        
                if (e is SecurityException)
                    throw e;
                else
                    throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
            }

            
            DEBUG_OUT( "Check passed" );

        }

        internal static void GetZoneAndOriginHelper( PermissionSet grantSet, PermissionSet deniedSet, ArrayList zoneList, ArrayList originList )
        {
            ZoneIdentityPermission zone = (ZoneIdentityPermission)grantSet.GetPermission( typeof( ZoneIdentityPermission ) );
            UrlIdentityPermission url = (UrlIdentityPermission)grantSet.GetPermission( typeof( UrlIdentityPermission ) );

            if (zone != null)
                zoneList.Add( zone.SecurityZone );

            if (url != null)
                originList.Add( url.Url );
        }

        internal void GetZoneAndOrigin( ref StackCrawlMark mark, out ArrayList zone, out ArrayList origin )
        {
            zone = new ArrayList();
            origin = new ArrayList();

            GetZoneAndOriginInternal( zone, origin, ref mark, DeepCheckCount );
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void GetZoneAndOriginInternal(ArrayList zoneList, 
                                  ArrayList originList, 
                                  ref StackCrawlMark stackMark, 
                                  int checkFrames );

    
        internal static void CheckAssembly( Assembly asm, CodeAccessPermission demand )
        {
            BCLDebug.Assert( asm != null, "Must pass in a good assembly" );
            BCLDebug.Assert( demand != null, "Must pass in a good demand" );

            PermissionSet granted, denied;

            asm.nGetGrantSet( out granted, out denied );

            CheckHelper( granted, denied, demand, PermissionToken.GetToken(demand) );
        }

        internal static void CheckAssembly( Assembly asm, PermissionSet permSet )
        {
            BCLDebug.Assert( asm != null, "Must pass in a good assembly" );
            BCLDebug.Assert( permSet != null, "Must pass in a good permset" );

            PermissionSet granted, denied;

            asm.nGetGrantSet( out granted, out denied );

            CheckSetHelper( granted, denied, permSet );
        }

    
        // Check - Used to initiate a code-access security check.
        // This method invokes a stack walk after skipping to the frame
        // referenced by stackMark.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void Check(PermissionToken permToken, 
                                  CodeAccessPermission demand, 
                                  ref StackCrawlMark stackMark, 
                                  int checkFrames,
                                  int unrestrictedOverride );
        
        // true - Check passes
        // false - Check may fail, do a stackwalk
                // It may look like we dont need three arguments here, but this is being done to 
                // avoid "is instance of" checks and casting
        private bool PreCheck(  CodeAccessPermission permObj, 
                                PermissionSet permSetObj, 
                                int capOrSet, 
                                ref StackCrawlMark stackMark,
                                PermissionType permType)
        {
            //return false;
            int status=0;
            PermissionListSet psl;
            if (capOrSet == CHECK_CAP)
                psl = GetDomainPermissionListSet(out status, permObj, capOrSet, permType);
            else
                psl = GetDomainPermissionListSet(out status, permSetObj, capOrSet, permType);

            if (status == NEED_UPDATED_PLS)
                psl = UpdateDomainPermissionListSet(out status);

                        if (status == DEMAND_PASSES || status == SECURITY_OFF)
                                return true;

            if (status == FULLY_TRUSTED)
            {
                if (capOrSet == CHECK_CAP)
                {
                    if (permObj is IUnrestrictedPermission)
                        return true;
                }
                else
                {
                    if (permSetObj.CanUnrestrictedOverride() == 1)
                        return true;
                }
            }

            if (status == CONTINUE || status == FULLY_TRUSTED)
                        {
                if (capOrSet == CHECK_CAP)
                    return psl.CheckDemandNoThrow( permObj );
                else
                    return psl.CheckSetDemandNoThrow( permSetObj );
                        }

            if (status == PLS_IS_BUSY)
                return false;

            if (status == BELOW_THRESHOLD) 
                return false;

            if (status == MULTIPLE_DOMAINS)
                return false;

            if (status == OVERRIDES_FOUND)
            {
                UpdateOverridesCount(ref stackMark); 
                return false;
            }

            if (status == NEED_STACKWALK)
                return false;
                
            BCLDebug.Assert(false,"Unexpected status from GetDomainPermissionListSet");
            return false;
        }

        internal virtual void Check(CodeAccessPermission cap, ref StackCrawlMark stackMark)
        {

            if (PreCheck(cap, null, CHECK_CAP, ref stackMark, PermissionType.DefaultFlag) == true)
                return;

            Check(PermissionToken.GetToken(cap),
                  cap,
                  ref stackMark,
                  DeepCheckCount,
                  (cap is IUnrestrictedPermission) ? 1 : 0);
        }
        
        // This is a special version of Check that knows whats the permission being demanded.
        // We first check if we know the result from last time, if not do the regular thing
        // Looks similar to COMCodeAccessSecurityEngine::SpecialDemand in the EE
        internal virtual void Check(CodeAccessPermission cap, ref StackCrawlMark stackMark, PermissionType permType)
        {

            int timeStamp = 0;

            if (GetResult(permType, out timeStamp) == true)
                return;

            if (PreCheck(cap, null, CHECK_CAP, ref stackMark, permType) == true)
            {
                SetResult(permType, timeStamp);
                return;
            }

            Check(PermissionToken.GetToken(cap),
                  cap,
                  ref stackMark,
                  DeepCheckCount,
                  (cap is IUnrestrictedPermission) ? 1 : 0);
        }
        
        internal virtual void CheckImmediate(CodeAccessPermission cap, ref StackCrawlMark stackMark)
        {
            if (PreCheck(cap, null, CHECK_CAP, ref stackMark, PermissionType.DefaultFlag) == true)
                return;

            Check(PermissionToken.GetToken(cap),
                  cap,
                  ref stackMark,
                  ImmediateCheckCount,
                  (cap is IUnrestrictedPermission) ? 1 : 0);
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void CheckSet(PermissionSet permSet,
                                     ref StackCrawlMark stackMark,
                                     int checkFrames,
                                     int unrestrictedOverride );
        
        internal virtual void Check(PermissionSet permSet, ref StackCrawlMark stackMark)
        {
            if (PreCheck(null, permSet, CHECK_SET, ref stackMark, PermissionType.DefaultFlag) == true)
                return;

            CheckSet(permSet,
                     ref stackMark,
                     DeepCheckCount,
                     permSet.CanUnrestrictedOverride() );
        }
        
        internal virtual void CheckImmediate(PermissionSet permSet, ref StackCrawlMark stackMark)
        {
            if (PreCheck(null, permSet, CHECK_SET, ref stackMark, PermissionType.DefaultFlag) == true)
                return;

            CheckSet(permSet,
                     ref stackMark,
                     ImmediateCheckCount,
                     permSet.CanUnrestrictedOverride() );
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern FrameSecurityDescriptor CheckNReturnSO(PermissionToken permToken, 
                                                                    CodeAccessPermission demand, 
                                                                    ref StackCrawlMark stackMark,
                                                                    int unrestrictedOverride, 
                                                                    int create );

        internal virtual void Assert(CodeAccessPermission cap, ref StackCrawlMark stackMark)
        {
            // Make sure the caller of assert has the permission to assert
            //WARNING: The placement of the call here is just right to check
            //         the appropriate frame.
            
            // Note: if the "AssertPermission" is not a permission that implements IUnrestrictedPermission
            // you need to change the last parameter to a zero.
            
            FrameSecurityDescriptor secObj = CheckNReturnSO(AssertPermissionToken,
                                                            AssertPermission,
                                                            ref stackMark,
                                                            1,
                                                            1 );
            
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                    // Security: REQ_SQ flag is missing. Bad compiler ?
                    // This can happen when you create delegates over functions that need the REQ_SQ 
                    throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetAssertions() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetAssert(cap);
            }
        }
    
        internal virtual void Deny(CodeAccessPermission cap, ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj =
                SecurityRuntime.GetSecurityObjectForFrame(ref stackMark, true);
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                    // Security: REQ_SQ flag is missing. Bad compiler ?
                    // This can happen when you create delegates over functions that need the REQ_SQ 
                    throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetDenials() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetDeny(cap);
            }            BCLDebug.Assert(secObj != null,"Failure in CodeAccessSecurityEngine.Deny() - secObj != null");
        }
        
        internal virtual void PermitOnly(CodeAccessPermission cap, ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj =
                SecurityRuntime.GetSecurityObjectForFrame(ref stackMark, true);
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                    // Security: REQ_SQ flag is missing. Bad compiler ?
                    // This can happen when you create delegates over functions that need the REQ_SQ 
                   throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetPermitOnly() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetPermitOnly(cap);
            }
        }
        
        //
        // GET COMPRESSED STACK
        //
        
        /*
         * Stack compression helpers
         */
        
        private 
        static bool StackCompressWalkHelper(PermissionListSet compressedStack,
                                               bool skipGrants,
                                               PermissionSet grantedPerms,
                                               PermissionSet deniedPerms,
                                               FrameSecurityDescriptor frameInfo)
        {
            if (!skipGrants)
            {
                if (!compressedStack.AppendPermissions(grantedPerms,
                                                       PermissionList.MatchChecked))
                    return false;
                if (deniedPerms != null && !compressedStack.AppendPermissions(deniedPerms,
                                                                              PermissionList.MatchDeny))
                    return false;
            }
            
            if (frameInfo != null)
            {
                PermissionSet set = frameInfo.GetPermitOnly();

                if (set != null)
                {
                    if (!compressedStack.AppendPermissions( set, PermissionList.MatchPermitOnly ))
                        return false;
                }

                set = frameInfo.GetDenials();

                if (set != null)
                {
                    if (!compressedStack.AppendPermissions( set, PermissionList.MatchDeny ))
                        return false;
                }

                set = frameInfo.GetAssertions();

                if (set != null)
                {
                    if (!compressedStack.AppendPermissions( set, PermissionList.MatchAssert ))
                        return false;
                }
            }
            
            return true;
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static PermissionListSet GetCompressedStackN(ref StackCrawlMark stackMark);
        
        internal virtual PermissionListSet GetCompressedStack(ref StackCrawlMark stackMark)
        {
            PermissionListSet permListSet = GetCompressedStackN(ref stackMark);
            return permListSet;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static IntPtr GetDelayedCompressedStack(ref StackCrawlMark stackMark);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern static void ReleaseDelayedCompressedStack( IntPtr compressedStack );
   
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern PermissionSet GetPermissionsP(Object obj, out PermissionSet denied);
        
        internal virtual PermissionSet GetPermissions(Object obj, out PermissionSet denied)
        {
            // We need to deep copy the returned permission sets to avoid the caller
            // tampering with the originals.
            PermissionSet internalGranted, internalDenied;
            internalGranted = GetPermissionsP(obj, out internalDenied);
        
            if (internalDenied != null)
                denied = internalDenied.Copy();
            else
                denied = null;
            return internalGranted.Copy();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\isecurityruntime.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    using System;
    using System.Threading;
    internal interface ISecurityRuntime
    {
    	void Assert(PermissionSet permSet, ref StackCrawlMark stackMark);
    	
    	void Deny(PermissionSet permSet, ref StackCrawlMark stackMark);
    	
    	void PermitOnly(PermissionSet permSet, ref StackCrawlMark stackMark);
        
        void RevertAssert(ref StackCrawlMark stackMark);
    
        void RevertDeny(ref StackCrawlMark stackMark);
    
        void RevertPermitOnly(ref StackCrawlMark stackMark);
    
        void RevertAll(ref StackCrawlMark stackMark);
    
        PermissionSet GetDeclaredPermissions(Object cl, int type);
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\istackwalk.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IStackWalk.cool
//

namespace System.Security
{

	/// <include file='doc\IStackWalk.uex' path='docs/doc[@for="IStackWalk"]/*' />
	public interface IStackWalk
	{
        /// <include file='doc\IStackWalk.uex' path='docs/doc[@for="IStackWalk.Assert"]/*' />
        [DynamicSecurityMethodAttribute()]
        void Assert();
        /// <include file='doc\IStackWalk.uex' path='docs/doc[@for="IStackWalk.Demand"]/*' />
        
        void Demand();
        /// <include file='doc\IStackWalk.uex' path='docs/doc[@for="IStackWalk.Deny"]/*' />
        
        [DynamicSecurityMethodAttribute()]
        void Deny();
        /// <include file='doc\IStackWalk.uex' path='docs/doc[@for="IStackWalk.PermitOnly"]/*' />
        
        [DynamicSecurityMethodAttribute()]
        void PermitOnly();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\namedpermissionset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  NamedPermissionSet.cool
//
//  Extends PermissionSet to allow an associated name and description
//

namespace System.Security {
    
	using System;
	using System.Security.Util;
	using PermissionState = System.Security.Permissions.PermissionState;
	using System.Runtime.Serialization;
    /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet"]/*' />
    [Serializable]
    public sealed class NamedPermissionSet : PermissionSet
    {
        // The name of this PermissionSet
        private String m_name;
        
        // The description of this PermissionSet
        private String m_description;
        
        internal NamedPermissionSet()
            : base()
        {
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.NamedPermissionSet"]/*' />
        public NamedPermissionSet( String name )
            : base()
        {
            CheckName( name );
            m_name = name;
        }
        
        internal NamedPermissionSet( String name, bool unrestricted)
            : base( unrestricted )
        {
            CheckName( name );
            m_name = name;
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.NamedPermissionSet1"]/*' />
        public NamedPermissionSet( String name, PermissionState state)
            : base( state )
        {
            CheckName( name );
            m_name = name;
        }
        
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.NamedPermissionSet2"]/*' />
        public NamedPermissionSet( String name, PermissionSet permSet )
            : base( permSet )
        {
            CheckName( name );
            m_name = name;
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.NamedPermissionSet3"]/*' />
        public NamedPermissionSet( NamedPermissionSet permSet )
            : base( permSet )
        {
            m_name = permSet.m_name;
            m_description = permSet.m_description;
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.Name"]/*' />
        public String Name {
            get { return m_name; }
            set { CheckName( value ); m_name = value; }
        }
    
        private static void CheckName( String name )
        {
            if (name == null || name.Equals( "" ))
                throw new ArgumentException( Environment.GetResourceString( "Argument_NPMSInvalidName" ));
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.Description"]/*' />
        public String Description {
            get { return m_description; }
            set { m_description = value; }
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.Copy"]/*' />
        public override PermissionSet Copy()
        {
            return new NamedPermissionSet( this );
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.Copy1"]/*' />
        public NamedPermissionSet Copy( String name )
        {
            NamedPermissionSet set = new NamedPermissionSet( this );
            set.Name = name;
            return set;
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement elem = base.ToXml();
            
            if (m_name != null && !m_name.Equals( "" ))
            {
                elem.AddAttribute( "Name", SecurityElement.Escape( m_name ) );
            }
            
            if (m_description != null && !m_description.Equals( "" ))
            {
                elem.AddAttribute( "Description", SecurityElement.Escape( m_description ) );
            }
            
            return elem;
        }
        
        internal SecurityElement ToXmlNameOnly()
        {
            SecurityElement elem = new SecurityElement("PermissionSet");
            elem.AddAttribute("class", this.GetType().FullName);
            elem.AddAttribute("version", "1" );
            if (m_name != null && !m_name.Equals( "" ))
            {
                elem.AddAttribute( "Name", SecurityElement.Escape( m_name ) );
            }
            return elem;
        }
        
        /// <include file='doc\NamedPermissionSet.uex' path='docs/doc[@for="NamedPermissionSet.FromXml"]/*' />
        public override void FromXml(SecurityElement et)
        {
            bool fullyLoaded;
            FromXml( et, false, out fullyLoaded );
        }


        internal override void FromXml( SecurityElement et, bool policyLoad, out bool fullyLoaded )
        {
            if (et == null)
                throw new ArgumentNullException( "et" );
        
            String elem;
            
            elem = et.Attribute( "Name" );
            m_name = elem == null ? null : elem;

            elem = et.Attribute( "Description" );
            m_description = elem == null ? "" : elem;

            base.FromXml( et, policyLoad, out fullyLoaded );
        }

        internal void FromXmlNameOnly( SecurityElement et )
        {
            // This function gets only the name for the permission set, ignoring all other info.

            String elem;

            elem = et.Attribute( "Name" );
            m_name = elem == null ? null : elem;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissionlist.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.Security {
    
    using System;
    using System.Text;
    using System.Security.Util;
    using System.Runtime.Remoting.Activation;
    using PermissionState = System.Security.Permissions.PermissionState;
    using IUnrestrictedPermission = System.Security.Permissions.IUnrestrictedPermission;
    using System.Collections;

    // A PermissionList is a list of permissions of a single type.
    // It is a specialized data structure for managing Assertions, Denials,
    // and stack compressions.
    [Serializable]
    internal class PermissionList
    {
        public const int MatchNone     = 0; // must be first in enumeration
        public const int MatchAssert   = 1;
        public const int MatchDeny     = 2;
        public const int MatchPermitOnly = 3;
        public const int MatchChecked  = 4; // must be last
        
        private String GetStringForType(int type)
        {
            switch (type)
            {
            case MatchChecked:
                return "Check";
                
            case MatchDeny:
                return "Deny";
                
            case MatchAssert:
                return "Assert";
                
            case MatchNone:
                return "None";
    
            case MatchPermitOnly:
                return "PermitOnly";
    
            default:
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidFlag"));
            }
        }
        
        internal PListNode m_head = null;
        internal PListNode m_last = null;
        internal int       m_cElt;
    
        // Default constructor. Make an empty list.
        public PermissionList()
        {
            m_cElt = 0;
        }
    
        // Copy the nodes of the first list. Note that the
        // list gets new nodes, but the Permissions aren't deep
        // copied. As long as we never directly expose a list,
        // and if the Permissions are treated as read only,
        // then this is OK.
        public PermissionList(PermissionList permList)
        
            : this() {
            if (permList == null || permList.m_head == null)
                return;
    
            // Assign head to a copy of the first node
            m_head = new PListNode(permList.m_head);
    
            // Use m_last to traverse list starting from head
            m_last = m_head;
    
            // While m_last isn't really the last, continue to
            // make copies of the original nodes that m_last.next points to.\
            // When we're done, m_last points to last of the copies.
            while (m_last.next != null)
            {
                m_last.next = new PListNode(m_last.next);
                m_last.next.prev = m_last;
                m_last = m_last.next;
            }
            
            // Copy how many elements there are.
            m_cElt = permList.m_cElt;
        }
    
        // Copies the list. The nodes are copied, but the Permissions in
        // the nodes are not.
        public virtual PermissionList Copy()
        {
            return new PermissionList(this);
        }
    
        // Makes a copy of the list and a deep copy of all the permissions.
        public virtual PermissionList DeepPermissionCopy()
        {
            PermissionList nlist = new PermissionList();
            if (m_head == null)
                return nlist;
            
            nlist.m_head = new PListNode(m_head.perm == null ? null : (CodeAccessPermission)m_head.perm.Copy(), m_head.type, m_head.next, m_head.prev);
            nlist.m_last = nlist.m_head;
            while (nlist.m_last.next != null)
            {
                nlist.m_last.next = new PListNode(nlist.m_last.next.perm == null ?
                                                  null :
                                                  (CodeAccessPermission)nlist.m_last.next.perm.Copy(),
                                                  nlist.m_last.next.type,
                                                  nlist.m_last.next.next,
                                                  nlist.m_last);
                nlist.m_last = nlist.m_last.next;
            }
            
            nlist.m_cElt = m_cElt;
            return nlist;
        }
        
        // Given a demand, check the list to see if it "matches" anything.
        public virtual void CheckDemand(CodeAccessPermission demand)
        {
            Exception exception;

            CheckDemandInternal( demand, true, out exception );

            if (exception != null)
            {
                throw exception;
            }
        }

        internal bool CheckDemandInternal(CodeAccessPermission demand)
        {
            Exception exception;

            return CheckDemandInternal( demand, false, out exception );
        }

        internal bool CheckDemandInternal(CodeAccessPermission demand, bool createException, out Exception exception)
        {
            BCLDebug.Assert(m_head != null,"m_head != null");
            for (PListNode pnext = m_head; pnext != null; pnext = pnext.next)
            {
                if (pnext.perm == null)
                {
                    // If this is a grant set or a permit only, then we should fail since null indicates the empty permission.
                    if (pnext.type == MatchChecked || pnext.type == MatchPermitOnly)
                    {
                        BCLDebug.Assert( !demand.IsSubsetOf( null ), "By the time we get here, demands that are subsets of null should have been terminated" );
                        if (createException)
                            exception = new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName));
                        else
                            exception = PermissionListSet.GetStaticException();
                        return false;
                    }
                    
                    // If this is a deny, then we should fail since null indicates the unrestricted permission.
                    if (pnext.type == MatchDeny)
                    {
                        if (createException)
                            exception = new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName));
                        else
                            exception = PermissionListSet.GetStaticException();
                        return false;
                    }

                    // If this is an assert, then we should return success and terminate the stack walk since
                    // null indicates the unrestricted permission.
                    if (pnext.type == MatchAssert)
                    {
                        exception = null;
                        return false;
                    }

                    // If this is anything else, then we should act confused.
                    // This case is unexpected.
                    BCLDebug.Assert( false, "This case should never happen" );
                    exception = new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_InvalidState" ) );
                    return false;
                }
                
                CodeAccessPermission cap = pnext.perm;
                switch (pnext.type)
                {
                case MatchChecked:
                case MatchPermitOnly:
                    if (!demand.IsSubsetOf(cap))
                    {
                        if (createException)
                            exception = new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName));
                        else
                            exception = PermissionListSet.GetStaticException();
                        return false;
                    }
                    break;
                case MatchAssert:
                    if (demand.IsSubsetOf(cap))
                    {
                        exception = null;
                        return false;
                    }
                    break;
                case MatchDeny:
                    if (demand.Intersect(cap) != null)
                    {
                        if (createException)
                            exception = new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName));
                        else
                            exception = PermissionListSet.GetStaticException();
                        return false;
                    }
                    break;
                default:
                    // Illegal entry
                    exception = new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_InvalidState" ) );
                    return false;
                }
            }

            exception = null;
            return true;
        }
       
        // Adds a Permission to the end of the list.
        // 
        public virtual void AppendPermission(CodeAccessPermission perm, int type)
        {
            if (type <= MatchNone || type > MatchChecked)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidMatchType"));
            
            if (m_head == null)
            {
                m_head = new PListNode(perm, type, null, null);
                m_last = m_head;
            }
            else
            {
                m_last.next = new PListNode(perm, type, null, m_last);
                m_last = m_last.next;
            }
            m_cElt++;
        }
        
        public virtual void AppendPermissionAndCompress(CodeAccessPermission perm, int type)
        {
            if (m_head == null)
            {
                BCLDebug.Assert( false, "You should not try to append and compress until there is atleast one other entry" );
                throw new InvalidOperationException( Environment.GetResourceString( "InvalidOperation_InvalidState" ) );
            }
            
            if (type == MatchChecked)
            {
                PListNode current = m_last;

                while (current != null)
                {
                    if (current.type == MatchChecked)
                    {
                        if (current.perm == null)
                            return;

                        if (perm == null)
                        {
                            current.perm = null;
                            return;
                        }

                        try
                        {
                            if (perm.IsSubsetOf( current.perm ) &&
                                current.perm.IsSubsetOf( perm ))
                                return;
                        }
                        catch (Exception)
                        {
                            // It is ok to catch and ignore exceptions here because
                            // it only means that we'll continue to iterate and worst-
                            // case add a new PListNode for the parameter perm instance.
                        }
                    }

                    current = current.prev;
                }
            }
    
            // If we get here, then add normally.
            m_last.next = new PListNode(perm, type, null, m_last);
            m_last = m_last.next;
            m_cElt++;
        }

        
        // Appends a PermissionList to the current list.
        // NOTE: Since AppendList does not make a copy of the parameter before
        // appending it, operations on the newly formed list also side-effect
        // the parameter. If this is not desired, make a copy of the parameter
        // before calling AppendList.
        public virtual void AppendList(PermissionList permList)
        {
            // Check for null
            if (permList == null)
                return;
    
            // If current list is empty, then DO NOT
            // append list, possibly adding Permissions!
            if (m_head == null)
            {
                return;
            }
            // Append list only if the last element of the current list does
            // not guarantee a failed check, thus stopping a walk.
            else if (! (m_last.type == MatchChecked && m_last.perm == null))
            {
                // Make sure there is something in the target
                // list to append.
                if (permList.m_head != null)
                {
                    // Stick the head of the target list to the end of
                    // the current list...
                    m_last.next = permList.m_head;
                    
                    // The new last is the last of the target list...
                    m_last = permList.m_last;
                    
                    // Add up the elements.
                    m_cElt += permList.m_cElt;
                }
            }
        }
        
        public virtual void AppendStack(PermissionList permList)
        {
            // Check for null
            if (permList == null)
                return;
            
            // If current list is empty, then DO NOT
            // append list, possibly adding Permissions!
            if (m_head == null)
            {
                return;
            }
            else
            {
                // Make sure there is something in the target
                // list to append.
                if (permList.m_head != null)
                {
                    // If the last element of the current list and the first element of the
                    // appended list are both of type MatchChecked, then we can merge the
                    // entries together using intersect to conserve the number of entries
                    // in the final list.
                    if (m_last.type == MatchChecked && permList.m_head.type == MatchChecked)
                    {
                        // If the entries are non-null, then call Intersect.
                        if (m_last.perm != null && permList.m_head.perm != null)
                        {
                            m_last.perm = (CodeAccessPermission) m_last.perm.Intersect(permList.m_head.perm);
                        }
                        else
                        {
                            m_last.perm = null;
                        }
                        
                        // If the last element is now null, then don't bother appending
                        // anything more. Also,
                        // if the combined element was the only element in the appended list,
                        // then there is nothing further to append. So, only do work to append
                        // if the m_head.next is non-null.
                        if (m_last.perm != null && permList.m_head.next != null)
                        {
                            // Stick the element after the head of the target list
                            // to the end of the current list...
                            m_last.next = permList.m_head.next;
                            
                            // The new last is the last element of the target list...
                            m_last = permList.m_last;
                            
                            // The new count is is the sum minus 1 to account for the
                            // merge performed above.
                            m_cElt += (permList.m_cElt - 1);
                        }
                    }
                    // Otherwise, append the list only if the last element is not a
                    // guaranteed failure during a stack walk: the type is Normal and
                    // it is null.
                    else if (! (m_last.type == MatchChecked && m_last.perm == null))
                    {
                        // Stick the head of the target list to the end of
                        // the current list...
                        m_last.next = permList.m_head;
                        
                        // The new last is the last of the target list...
                        m_last = permList.m_last;
                        
                        // Add up the elements.
                        m_cElt += permList.m_cElt;
                    }
                }
            }
        }
        
        // Returns true if there is nothing in the list.
        public virtual bool IsEmpty()
        {
            return (m_cElt == 0);
        }
    
        // Returns a count of the number of elements in the list.
        public virtual int GetCount()
        {
            return m_cElt;
        }
        
        public override String ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("[" + System.Environment.NewLine);
    
            PListNode pNext = m_head;
            while (pNext != null)
            {
                sb.Append("(");
                sb.Append(GetStringForType(pNext.type));
                sb.Append("," + System.Environment.NewLine);
    
                if (pNext.perm == null)
                    sb.Append("null");
                else
                    sb.Append(pNext.perm.ToString());
    
                sb.Append(")" + System.Environment.NewLine);
                
                pNext = pNext.next;
            }
            
            sb.Append("]");
            return sb.ToString();
        }
    }
    
    [Serializable]
    internal class PListNode
    {
        internal CodeAccessPermission perm;   
        internal int         type;   // MatchAssert, MatchDeny, or MatchChecked
        internal PListNode   next;
        internal PListNode   prev;
    
        internal PListNode(PListNode plnode)
        
            : this(plnode.perm, plnode.type, plnode.next, plnode.prev) {
        }
    
        internal PListNode(CodeAccessPermission perm, int type, PListNode next, PListNode prev)
        {
            this.perm  = perm;
            this.type  = type;
            this.next  = next;
            this.prev  = prev;
        }
    }

    internal class PermissionListEnumerator : IEnumerator
    {
        internal PermissionList m_list;
        internal PListNode m_current;

        internal PermissionListEnumerator( PermissionList list )
        {
            m_list = list;
            Reset();
        }

        public void Reset()
        {
            if (m_list == null)
            {
                m_current = null;
            }
            else
            {
                m_current = new PListNode( null, 0, m_list.m_head, null );
            }
        }

        public virtual bool MoveNext()
        {
            if (m_current == null)
                return false;

            m_current = m_current.next;

            if (m_current == null)
                return false;

            return true;
        }

        public Object Current
        {
            get
            {
                return m_current;
            }
        }
    }

        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissionsetenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    //PermissionSetEnumerator.cool
    
	using System;
	using TokenBasedSetEnumerator = System.Security.Util.TokenBasedSetEnumerator;
    internal class PermissionSetEnumerator : TokenBasedSetEnumerator
    {
        private bool m_first;
        internal PermissionSet m_permSet;
        
        internal PermissionSetEnumerator(PermissionSet permSet)
            : base(permSet.m_unrestrictedPermSet)
        {
            m_first = true;
            m_permSet = permSet;
        }
        
        public override bool MoveNext()
        {
            if (!base.MoveNext())
            {
                if (m_first)
                {
                    this.SetData(m_permSet.m_normalPermSet);
                    m_first = false;
                    return base.MoveNext();
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
        
        public virtual IPermission GetNextPermission()
        {
            if (MoveNext())
                return (IPermission) Current;
            else
                return null;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissionlistset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

/*============================================================
**
** Class:  PermissionListSet
**
** Purpose:
**
**  The PermissionListSet structure manages a compressed version of security
**  stack information.
**  The next diagram depicts how the PermissionListSet structure is used to
**  represent a compressed version of the security stack information.
**
**
**       Compressed stack (PermissionListSet)
**        |   |   |
**        |   |   +-- Unrestricted state (boolean)
**        |   |   |
**        |   |   +-- Stack modifier state (enum)
**        |   |
**        |   +-- Code-access check sequence for unrestricted PermissionToken 0 (PermissionList)
**        |   |
**        |   +-- Code-access check sequence for unrestricted PermissionToken 1 (PermissionList)
**        |   |
**        |   +-- ...
**        |   :
**        |   :
**        |
**        +-- Code-access check sequence for normal PermissionToken 0 (PermissionList)
**        |
**        +-- Code-access check sequence for normal PermissionToken 1 (PermissionList)
**        |
**        +-- ...
**        :
**        :
**
**  Each entry in the check sequence contains a flag indicating what type of check
**  the entry represents. The type can be an "assert", "deny", "permit only", or a
**  normal ("checked") security check. The unrestricted state is used to determine
**  how empty check sequences in the set of unrestricted permissions should be treated.
**  If the non-unrestricted state, an empty list means that the corresponding permission
**  is not granted anywhere on the stack. Unrestricted means that, so far during the
**  compression, all frames have been "unrestricted". In this case, the lack of a check
**  sequence for a particular permission does not result in failure. It implies that any
**  check for that permission should pass. In the case that the compressed stack
**  remains in an unrestricted state, the PermissionLists are used only to
**  maintain assertions and denials. These lists still must be checked to ensure
**  that assertions and denials fire as expected.  The unrestricted state does not
**  alter the behavior for normal permissions (similar to PermissionSet).  The stack
**  modifier state is used to track the presence of unrestricted stack modifiers on the
**  callstack.  It is used to determine the behavior of a demand if the PermissionList
**  for that permission type does not predetermine an action.  In addition, it is used
**  in the merge semantics of PermissionListSets to determine where merging needs to
**  take place.  See the function definitions below for more details.
**  
**
** Date:  April 6, 1998
** 
===========================================================*/
namespace System.Security {
    using System.Text;
    using System;
    using System.Security.Util;
    using System.Collections;
    using System.Security.Permissions;

    [Serializable]
    internal enum PermissionListSetState
    {
        None = 0x0,
        UnrestrictedAssert = 0x1,
        UnrestrictedDeny = 0x2,
    };

    [Serializable]
    sealed internal class PermissionListSet
    {
        internal TokenBasedSet m_unrestrictedPermSet;
        internal TokenBasedSet m_normalPermSet;
        internal bool          m_unrestricted;
        internal PermissionListSetState m_state;

        private static SecurityException staticSecurityException = null;

        public PermissionListSet()
        {
            Reset();
        }
        
        public PermissionListSet(PermissionListSet permListSet)
        {
            if (permListSet == null)
            {
                Reset();
                return;
            }
            
            m_unrestrictedPermSet = new TokenBasedSet(permListSet.m_unrestrictedPermSet);
    
            // Now deep copy all permission lists in set.
            // Note that this DOES deep copy permissions in the list.
            for (int i = 0; i <= m_unrestrictedPermSet.GetMaxUsedIndex(); i++)
            {
                PermissionList plist = (PermissionList)m_unrestrictedPermSet.GetItem(i);
                if (plist != null)
                {
                    m_unrestrictedPermSet.SetItem(i, plist.Copy());
                }
            }
            
            m_normalPermSet = new TokenBasedSet(permListSet.m_normalPermSet);
            
            // Now deep copy all permission lists in set.
            // Note that this DOES deep copy permissions in the list.
            for (int i = 0; i <= m_normalPermSet.GetMaxUsedIndex(); i++)
            {
                PermissionList plist = (PermissionList)m_normalPermSet.GetItem(i);
                if (plist != null)
                {
                    m_normalPermSet.SetItem(i, plist.Copy());
                }
            }        
            
            m_unrestricted = permListSet.m_unrestricted;
            m_state = permListSet.m_state;
        }
        
        // Reinitializes all state in PermissionSet.
        public void Reset()
        {
            if (m_unrestrictedPermSet == null)
                m_unrestrictedPermSet = new TokenBasedSet( 12, 4 );
            else
                m_unrestrictedPermSet.Reset();
            
            if (m_normalPermSet == null)
                m_normalPermSet = new TokenBasedSet( 6, 4 );
            else
                m_normalPermSet.Reset();
            
            // By default, the PermissionListSet is unrestricted. Why?
            // At the start, having nothing on the stack should indicate success.
            // Once the first non-unrestricted grant is appended to the set,
            // then the PermissionListSet will become non-unrestricted.
            m_unrestricted = true;
            m_state = PermissionListSetState.None;
        }
        
        public bool IsUnrestricted()
        {
            return m_unrestricted;
        }
    
        public bool IsEmpty()
        {
            return m_unrestrictedPermSet.IsEmpty() && m_normalPermSet.IsEmpty();
        }
        
        // Returns number of elements in set.
        public int GetCount()
        {
            return m_unrestrictedPermSet.GetCount() + m_normalPermSet.GetCount();
        }
        
        // NOTE: this function is for test only. do not doc
        public int GetStorageLength()
        {
            return m_unrestrictedPermSet.GetStorageLength() + m_normalPermSet.GetStorageLength();
        }
        
        public PermissionList FindPermissionList(Type permClass)
        {
            BCLDebug.Assert(permClass != null, "permClass != null");
            
            return FindPermissionList(PermissionToken.GetToken(permClass));
        }
        
        internal PermissionList FindPermissionList(PermissionToken permToken)
        {
            BCLDebug.Assert(permToken != null, "permToken != null");
            
            return FindPermissionList(permToken.m_index, permToken.m_isUnrestricted);
        }
        
        internal PermissionList FindPermissionList(int i, bool unrestricted)
        {
			if (unrestricted)
				return (PermissionList)m_unrestrictedPermSet.GetItem( i );
			else
				return (PermissionList)m_normalPermSet.GetItem( i );
        }
    
        
        private PermissionList GetListForToken(PermissionToken permToken, bool create)
        {
            TokenBasedSet permSet;
            
            BCLDebug.Assert(permToken != null, "permToken != null");
            
            if (permToken.m_isUnrestricted)
                permSet = m_unrestrictedPermSet;
            else
                permSet = m_normalPermSet;
            
            PermissionList plist = (PermissionList)permSet.GetItem(permToken.m_index);
            if (plist == null && create)
            {
                plist = new PermissionList();
                permSet.SetItem(permToken.m_index, plist);
            }
            
            return plist;
        }
        
        internal static SecurityException GetStaticException()
        {
            if (staticSecurityException == null)
                staticSecurityException = new SecurityException(Environment.GetResourceString("Security_GenericNoType") );

            return staticSecurityException;
        }
        
        internal bool CheckDemandInternal(CodeAccessPermission demand, PermissionToken permToken, bool createException, out Exception exception)
        {
            BCLDebug.Assert(demand != null, "demand != null");
            BCLDebug.Assert(permToken != null, "permToken != null");
            
            // First, find if there is a permission list of this type.

            PermissionList permList = FindPermissionList(permToken);
                
            if (permList != null)
            {
                // If so, check against it to determine our action.

                bool cont = permList.CheckDemandInternal(demand, createException, out exception);

                // We don't record modifiers for the unrestricted permission set in the
                // individual lists.  Therefore, permList.CheckDemandInternal may say
                // that we have to continue the stackwalk, but we know better.

                if (cont && permToken.m_isUnrestricted)
                {
                    if ((m_state & PermissionListSetState.UnrestrictedDeny) != 0)
                    {
                        if (createException)
                            exception = new SecurityException(String.Format( Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName ) );
                        else
                            exception = GetStaticException();
                        return false;
                    }
                    else
                    {
                        cont = cont && ((m_state & PermissionListSetState.UnrestrictedAssert) == 0);
                    }
                }

                return cont;
            }
#if _DEBUG
            // Let's check to make sure we always pass demands for empty permissions.

            else if (demand.IsSubsetOf( null ))
            {
                BCLDebug.Assert( false, "We should pick of empty demands before this point" );
                exception = null;
                return true;
            }
#endif
            // If the permission is not unrestricted, the lack of a permission list
            // denotes that no frame on the stack granted this permission, and therefore
            // we pass back the failure condition.

            else if (!permToken.m_isUnrestricted)
            {
                if (createException)
                    exception = new SecurityException(String.Format( Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName ) );
                else
                    exception = GetStaticException();
                return false;
            }

            // If this permission list set is not unrestricted and there is no unrestricted assert
            // then the lack of a permission list denotes that no frame on the stack granted
            // this permission, and therefore we pass back the failure condition.  If there is
            // an unrestricted assert, then we pass back success and terminate the stack walk.

            else if (!this.IsUnrestricted())
            {
                if (createException)
                    exception = new SecurityException(String.Format( Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName ) );
                else
                    exception = GetStaticException();
                return false;
            }
            
            // If we made it all the way through, that means that we are in the unrestricted
            // state and that this permission is encompassed in that.  If we have an unrestricted
            // assert, we are done with the state walk (return false), otherwise keep going.

            exception = null;
            return (m_state & PermissionListSetState.UnrestrictedAssert) == 0;
        }

        public bool CheckDemand(CodeAccessPermission demand)
        {
            Exception exception;

            PermissionToken permToken = null;
            if (demand != null)
                permToken = PermissionToken.GetToken(demand);
            
            bool cont = CheckDemandInternal(demand, permToken, true, out exception);

            if (exception != null)
            {
                throw exception;
            }
            
            return cont;               
        }

        internal bool CheckDemand(CodeAccessPermission demand, PermissionToken permToken)
        {
            Exception exception;

            bool cont = CheckDemandInternal( demand, permToken, true, out exception );

            if (exception != null)
            {
                throw exception;
            }

            return cont;
        }

        internal bool CheckDemandNoThrow(CodeAccessPermission demand)
        {
            PermissionToken permToken = null;
            if (demand != null)
                permToken = PermissionToken.GetToken(demand);
            
            return CheckDemandNoThrow(demand, permToken);
        }

        internal bool CheckDemandNoThrow(CodeAccessPermission demand, PermissionToken permToken)
        {
            Exception exception;

            CheckDemandInternal( demand, permToken, false, out exception );

            return (exception == null);
        }

        private static bool CheckTokenBasedSets( TokenBasedSet thisSet, TokenBasedSet permSet, bool unrestricted, PermissionListSetState state, bool createException, out Exception exception, bool bNeedAlteredSet, out TokenBasedSet alteredSet )
        {
            alteredSet = null;

            // If the set is empty, there is no reason to walk the
            // stack.

            if (permSet == null || permSet.FastIsEmpty())
            {
                if (bNeedAlteredSet)
                    alteredSet = new TokenBasedSet( 1, 4 );
                exception = null;
                return false;
            }

            int permMaxIndex = permSet.GetMaxUsedIndex();
            
            // Make a quick check to see if permSet definitely contains permissions that this set doesn't
            
            if (permMaxIndex > thisSet.GetMaxUsedIndex())
            {
                // The only way we don't want to throw an exception is
                // if we are unrestricted.  Then, if we don't want to throw
                // an exception we may want to terminate the stack walk
                // based on an unrestricted assert.

                if (unrestricted)
                {
                    if (((state & PermissionListSetState.UnrestrictedAssert) != 0))
                    {
                        if (bNeedAlteredSet)
                            alteredSet = new TokenBasedSet( 1, 4 );
                        exception = null;
                        return false;
                    }
                    else
                    {
                        exception = null;
                        return true;
                    }
                }
                else
                {
                    if (createException)
                        exception = new SecurityException(Environment.GetResourceString("Security_GenericNoType") );
                    else
                        exception = GetStaticException();
                    return false;
                }
            }


            bool continueStackWalk = false;
            
            // We know that checking to <permMaxIndex> is sufficient because of above check
            for (int i = 0; i <= permMaxIndex; i++)
            {
                Object obj = permSet.GetItem(i);
                
                if (obj != null)
                {
                    CodeAccessPermission cap = (CodeAccessPermission)obj;

                    PermissionList permList = (PermissionList)thisSet.GetItem(i);
                    
                    if (permList != null)
                    {
                        bool tempContinue = permList.CheckDemandInternal(cap, createException, out exception);

                        if (exception != null)
                            return false;

                        if (tempContinue)
                        {
                            // If we are supposed to continue the stack walk but there is an unrestricted
                            // deny, then we should fail.

                            if (((state & PermissionListSetState.UnrestrictedDeny) != 0) && (cap is IUnrestrictedPermission))
                            {
                                if (createException)
                                    exception = new SecurityException(String.Format( Environment.GetResourceString("Security_Generic"), cap.GetType().AssemblyQualifiedName ) );
                                else
                                    exception = GetStaticException();
                                return false;
                            }

                            continueStackWalk = true;
                        }
                        else if (((state & PermissionListSetState.UnrestrictedAssert) == 0) && (cap is IUnrestrictedPermission))
                        {
                            // We only want to build the altered set if we don't have an
                            // unrestricted assert because we know if we have an unrestricted
                            // assert and we don't throw an exception that the stackwalk should
                            // include no unrestricted permissions.

                            if (bNeedAlteredSet)
                            {
                                if (alteredSet == null)
                                    alteredSet = CopyTokenBasedSet( permSet );

                                alteredSet.SetItem( i, null );
                            }
                        }
                    }
                    else
                    {
                        if (!unrestricted)
                        {
                            if (createException)
                                exception = new SecurityException(String.Format( Environment.GetResourceString("Security_Generic"), cap.GetType().AssemblyQualifiedName ) );
                            else
                                exception = GetStaticException();
                            return false;
                        }
                    }
                }
            }

            exception = null;
            return continueStackWalk;
        }

        public bool CheckSetDemandInternal(PermissionSet permSet, out Exception exception)
        {
            PermissionSet alteredSet;

            return CheckSetDemandInternal( permSet, true, out exception, true, out alteredSet );
        }

        public bool CheckSetDemandInternal(PermissionSet permSet, bool createException, out Exception exception, bool bNeedAlteredSet, out PermissionSet alteredSet)
        {
            alteredSet = null;

            BCLDebug.Assert(permSet != null, "permSet != null");
            
            // If the compressed stack is not unrestricted and the demand is
            // then we just throw an exception.
            if (!this.m_unrestricted && permSet.IsUnrestricted())
            {
                if (createException)
                    exception = new SecurityException(Environment.GetResourceString("Security_GenericNoType") );
                else
                    exception = GetStaticException();
                return false;
            }
            
            
            TokenBasedSet normalAlteredSet = null;
            TokenBasedSet unrestrictedAlteredSet = null;

            // Check the "normal" permissions since we always know we have to check them.

            bool normalContinue = CheckTokenBasedSets( this.m_normalPermSet, permSet.m_normalPermSet, false, PermissionListSetState.None, createException, out exception, bNeedAlteredSet, out normalAlteredSet );

            if (exception != null)
            {
                return false;
            }
            
            bool unrestrictedContinue = CheckTokenBasedSets( this.m_unrestrictedPermSet, permSet.m_unrestrictedPermSet, m_unrestricted, m_state, createException, out exception, bNeedAlteredSet, out unrestrictedAlteredSet );

            if (exception != null)
            {
                return false;
            }

            if ((m_state & PermissionListSetState.UnrestrictedAssert) != 0)
            {
                // If we are unrestricted, we want to terminate the stack walk based
                // on us having an unrestricted assert.

                if (bNeedAlteredSet)
                    unrestrictedAlteredSet = new TokenBasedSet( 1, 4 );
                unrestrictedContinue = false;
            }

            if (normalContinue || unrestrictedContinue)
            {
                if (!bNeedAlteredSet)
                    return true;

                // If we need to continue, let's build the altered set.  We only
                // need to do this if 1) our original demand is not unrestricted
                // and 2) if we have altered token based sets.

                if (!permSet.IsUnrestricted())
                {
                    if (normalAlteredSet != null || unrestrictedAlteredSet != null)
                    {
                        alteredSet = new PermissionSet( false );

                        if (normalAlteredSet != null)
                            alteredSet.m_normalPermSet = normalAlteredSet;
                        else
                            alteredSet.m_normalPermSet = CopyTokenBasedSet( permSet.m_normalPermSet );

                        if (unrestrictedAlteredSet != null)
                            alteredSet.m_unrestrictedPermSet = unrestrictedAlteredSet;
                        else
                            alteredSet.m_unrestrictedPermSet = CopyTokenBasedSet( permSet.m_unrestrictedPermSet );

                        if (alteredSet.IsEmpty())
                            return false;
                    }
                }

                return true;
            }
            else
            {
                return false;
            }
        }
            
        public bool CheckSetDemandNoThrow(PermissionSet permSet)
        {
            Exception exception;
            PermissionSet alteredSet;

            CheckSetDemandInternal( permSet, false, out exception, false, out alteredSet );

            return (exception == null);
        }

        public bool CheckSetDemand(PermissionSet permSet)
        {
            Exception exception;

            bool cont = CheckSetDemandInternal( permSet, out exception );

            if (exception != null)
            {
                throw exception;
            }

            return cont;
                
        }

        public bool CheckSetDemand(PermissionSet permSet, out PermissionSet alteredSet )
        {
            Exception exception;

            bool cont = CheckSetDemandInternal( permSet, true, out exception, true, out alteredSet );

            if (exception != null)
            {
                throw exception;
            }

            return cont;
        }

        public static TokenBasedSet CopyTokenBasedSet( TokenBasedSet set )
        {
            if (set == null || set.GetCount() == 0)
                return null;

            int maxIndex = set.GetMaxUsedIndex();

            TokenBasedSet copySet = new TokenBasedSet( maxIndex + 1, 4 );

            for (int i = 0; i <= maxIndex; ++i)
            {
                Object obj = set.GetItem( i );

                if (obj == null)
                    copySet.SetItem( i, null );
                else if (obj is IPermission)
                    copySet.SetItem( i, ((IPermission)obj).Copy() );
                else if (obj is PermissionList)
                    copySet.SetItem( i, ((PermissionList)obj).Copy() );
                else
                {
                    BCLDebug.Assert( false, "CopyTokenBasedSet can only be used for IPermission and PermissionList based TokenBasedSets" );
                    copySet.SetItem( i, obj );
                }
            }

            return copySet;
        }
           
        
        public void AddPermission(CodeAccessPermission perm, int type)
        {
            //BCLDebug.Assert(type == MatchAssert || type == MatchDeny, "type == MatchAssert || type == MatchDeny");
            
            // can't get token if perm is null
            if (perm == null)
                return;
            
            PermissionToken permToken = PermissionToken.GetToken(perm);
            PermissionList plist = GetListForToken(permToken, true);
            plist.AppendPermission(perm, type);
        }
        
        public PermissionList RemovePermissionList(Type type)
        {
            if (type == null)
                return null;
                
            return RemovePermissionList(PermissionToken.GetToken(type));
        }
        
        internal PermissionList RemovePermissionList(PermissionToken permToken)
        {
            if (permToken.m_isUnrestricted)
                return (PermissionList)m_unrestrictedPermSet.RemoveItem(permToken.m_index);
            else
                return (PermissionList)m_normalPermSet.RemoveItem(permToken.m_index);
        }
        
        // Returns a deep copy
        public PermissionListSet Copy()
        {
            return new PermissionListSet(this);
        }
        
        public IEnumerator GetEnum()
        {
            return new PermissionListSetEnumerator(this);
        }

        /*
         * Helpers designed for stack compression
         */
        
        private void NullTerminateRest(int startIndex, int action)
        {
            for (int i = startIndex; i <= m_unrestrictedPermSet.GetMaxUsedIndex(); i++)
            {
                PermissionList plist = (PermissionList)m_unrestrictedPermSet.GetItem(i);
                if (plist != null)
                    plist.AppendPermissionAndCompress(null, action);
            }
        }
        
        // Called when it is determined that the stack walk
        // should fail at the current point in the stack.
        private void TerminateSet( int action )
        {
            NullTerminateRest(0, action);
        }
        
        private void AppendTokenBasedSets( TokenBasedSet thisSet, TokenBasedSet permSet, int type, bool unrestricted )
        {
            int thisMaxIndex = thisSet.GetMaxUsedIndex();
            int permMaxIndex = permSet == null ? 0 : permSet.GetMaxUsedIndex();
            int maxIndex = thisMaxIndex > permMaxIndex ? thisMaxIndex : permMaxIndex;
            
            // Loop over the relevant indexes...
            for (int i = 0; i <= maxIndex; i++)
            {
                PermissionList plist = (PermissionList)thisSet.GetItem(i);
                CodeAccessPermission cap = permSet == null ? null : (CodeAccessPermission)permSet.GetItem(i);
                
                if (plist == null)
                {
                    if (this.m_unrestricted)
                    {
                        switch (type)
                        {
                        case PermissionList.MatchChecked:
                        case PermissionList.MatchPermitOnly:
                            plist = new PermissionList();
                            plist.AppendPermission(cap, type);
                            thisSet.SetItem( i, plist );
                            break;
                        
                        case PermissionList.MatchDeny:
                        case PermissionList.MatchAssert:
                            if (cap != null)
                            {
                                plist = new PermissionList();
                                plist.AppendPermission(cap, type);
                                thisSet.SetItem( i, plist );
                            }
                            break;
                        
                        default:
                            throw new ArgumentException(Environment.GetResourceString( "Argument_InvalidPermissionListType" ));
                        }
                    }
                }
                else
                {                    
                    // A list already exists. All lists should have at least
                    // one element in them.
    
                    // Normally, only append if the permission is not null.
                    // However, if the type is Checked, then make sure the
                    // list is terminated with a permission, null or not.
                    switch (type)
                    {
                    case PermissionList.MatchChecked:
                    case PermissionList.MatchPermitOnly:
                        plist.AppendPermissionAndCompress(cap, type);
                        break;
                            
                    case PermissionList.MatchDeny:
                    case PermissionList.MatchAssert:
                        if (cap != null)
                            plist.AppendPermissionAndCompress(cap, type);
                        break;
                            
                    default:
                        throw new ArgumentException(Environment.GetResourceString( "Argument_InvalidPermissionListType" ));
                    }
                }
            }
        }
            
        
        // Returns true if it is necessary to continue compression,
        // or false if there is no value in continuing.
        public bool AppendPermissions(PermissionSet permSet, int type)
        {
            if (permSet == null)
            {
                // The null permission set has no meaning accept for the case of
                // PermitOnly and Checked where it will make all demands fail (except
                // demands for empty permissions). 
                
                if (type == PermissionList.MatchChecked || type == PermissionList.MatchPermitOnly)
                {
                    TerminateSet( type );
                    m_unrestricted = false;
                    return false;
                }

                return true;
            }
            
            if (((m_state & (PermissionListSetState.UnrestrictedAssert | PermissionListSetState.UnrestrictedDeny)) == 0))
            {
                if (permSet.IsUnrestricted())
                {
                    switch (type)
                    {
                    case PermissionList.MatchDeny:
                        m_state |= PermissionListSetState.UnrestrictedDeny;
                        m_unrestricted = false;
                        TerminateSet( type );
                        break;

                    case PermissionList.MatchAssert:
                        m_state |= PermissionListSetState.UnrestrictedAssert;
                        TerminateSet( type );
                        break;
                    
                    case PermissionList.MatchPermitOnly:
                    case PermissionList.MatchChecked:
                        break;
                    
                    default:
                        throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionListType"));
                    }
                }
                else
                {
                    // Handle the "unrestricted" permissions.
                
                    AppendTokenBasedSets( this.m_unrestrictedPermSet, permSet.m_unrestrictedPermSet, type, true );
                
                    if (type != PermissionList.MatchAssert && type != PermissionList.MatchDeny)
                        m_unrestricted = false;
                }
            }
            
            // Handle the "normal" permissions
            
            AppendTokenBasedSets( this.m_normalPermSet, permSet.m_normalPermSet, type, false );
            
            return true;
        }

		private void AppendStackHelper( TokenBasedSet thisSet, TokenBasedSet permSet, bool unrestrictedThisSet, bool unrestrictedPermSet, bool unrestricted )
		{
            int maxThis = thisSet.GetMaxUsedIndex();
            int maxPerm = permSet.GetMaxUsedIndex();
            
            int maxIndex = maxThis > maxPerm ? maxThis : maxPerm;
            
            for (int i = 0; i <= maxIndex; i++)
            {
                PermissionList plist = (PermissionList)thisSet.GetItem(i);
                PermissionList appendList = (PermissionList)permSet.GetItem(i);
                if (plist != null)
                {
                    if (appendList != null)
                    {
                        // This call will not add the permission if the list is
                        // empty, or if the last element is a normal check with
                        // a null Permission. Let the method take care of it...
                        plist.AppendStack(appendList.Copy());
                    }
                    else
                    {
                        // Nothing on the compressed stack for this index,
                        // so terminate current list.
                        if (!unrestrictedPermSet)
                        {
                            plist.AppendPermissionAndCompress( null, PermissionList.MatchChecked );
                        }
                    }
                }
                else if (unrestrictedThisSet && appendList != null)
                {
                    thisSet.SetItem(i, appendList.Copy());
                }
            }
        }
    
        public void AppendStack(PermissionListSet permListSet)
        {
            if (permListSet == null)
                return;
            
            AppendStackHelper( this.m_normalPermSet, permListSet.m_normalPermSet, false, false, false );

            if (((m_state & (PermissionListSetState.UnrestrictedAssert | PermissionListSetState.UnrestrictedDeny)) == 0))
            {
                AppendStackHelper( this.m_unrestrictedPermSet, permListSet.m_unrestrictedPermSet, this.m_unrestricted, permListSet.m_unrestricted, true );
                m_state = m_state | permListSet.m_state;

                // The new list set is unrestricted only if both were previously.
                m_unrestricted = m_unrestricted && permListSet.m_unrestricted;
            }

        }

        internal void GetZoneAndOrigin( ArrayList zoneList, ArrayList originList )
        {
            PermissionList zone = this.FindPermissionList( typeof( ZoneIdentityPermission ) );
            PermissionList url = this.FindPermissionList( typeof( UrlIdentityPermission ) );

            IEnumerator enumerator;

            enumerator = new PermissionListEnumerator( zone );

            while (enumerator.MoveNext())
            {
                PListNode node = (PListNode)enumerator.Current;

                if (node.type == PermissionList.MatchChecked && node.perm != null)
                {
                    zoneList.Add( ((ZoneIdentityPermission)node.perm).SecurityZone );
                }
            }
        
            enumerator = new PermissionListEnumerator( url );

            while (enumerator.MoveNext())
            {
                PListNode node = (PListNode)enumerator.Current;

                if (node.type == PermissionList.MatchChecked && node.perm != null)
                {
                    originList.Add( ((UrlIdentityPermission)node.perm).Url );
                }
            }
        }
               
        
        public override String ToString()
        {
            StringBuilder sb = new StringBuilder(30);
            sb.Append("[" + System.Environment.NewLine);
            sb.Append("Unrestricted: ");
            sb.Append(m_unrestricted).Append(System.Environment.NewLine + System.Environment.NewLine);
            
            PermissionListSetEnumerator plsEnum = (PermissionListSetEnumerator)this.GetEnum();
            while (plsEnum.MoveNext())
            {
                sb.Append(plsEnum.Current.ToString());
                sb.Append(System.Environment.NewLine);
            }
            
            sb.Append("]");
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissionlistsetenumerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    //PermissionListSetEnumerator.cool
	using System;
    internal class PermissionListSetEnumerator : System.Security.Util.TokenBasedSetEnumerator
    {
        private bool m_first;
        internal PermissionListSet m_permListSet;
        
        internal PermissionListSetEnumerator(PermissionListSet permListSet)
        
            : base(permListSet.m_unrestrictedPermSet) {
            m_first = true;
            m_permListSet = permListSet;
        }
        
        public override bool MoveNext()
        {
            if (!base.MoveNext())
            {
                if (m_first)
                {
                    this.SetData(m_permListSet.m_normalPermSet);
                    m_first = false;
                    return base.MoveNext();
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissiontoken.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    using System;
    using System.Security.Util;
    using Hashtable = System.Collections.Hashtable;
    using System.Runtime.Remoting.Activation;
    using System.Security.Permissions;
    using System.Reflection;
    using System.Collections;

    [Serializable]
    internal sealed class PermissionToken
    {
        private static readonly PermissionTokenFactory s_theTokenFactory = SharedStatics.Security_PermissionTokenFactory;
        
        internal int    m_index;
        internal bool   m_isUnrestricted;
        
                private static ReflectionPermission s_reflectPerm = null;
    
        internal PermissionToken(int index, bool isUnrestricted)
        {
            m_index = index;
            m_isUnrestricted = isUnrestricted;
        }
        
        public static PermissionToken GetToken(Type cls)
        {
            if (cls == null)
                return null;
            
            if (cls.GetInterface( "System.Security.Permissions.IBuiltInPermission" ) != null)
            {
                            if (s_reflectPerm == null)
                                s_reflectPerm = new ReflectionPermission(PermissionState.Unrestricted);
                            s_reflectPerm.Assert();
                MethodInfo method = cls.GetMethod( "GetTokenIndex", BindingFlags.Static | BindingFlags.NonPublic );
                BCLDebug.Assert( method != null, "IBuiltInPermission types should have a static method called 'GetTokenIndex'" );
                return s_theTokenFactory.BuiltInGetToken( (int)method.Invoke( null, null ), null, cls );
            }             
            else
            {
                return s_theTokenFactory.GetToken(cls, null);
            }
        }
        
        public static PermissionToken GetToken(IPermission perm)
        {
            if (perm == null)
                return null;
    
            IBuiltInPermission ibPerm = perm as IBuiltInPermission;

            if (ibPerm != null)
                return s_theTokenFactory.BuiltInGetToken( ibPerm.GetTokenIndex(), perm, null );
            else
                return s_theTokenFactory.GetToken(perm.GetType(), perm);
        }
        
        public static PermissionToken FindToken( Type cls )
        {
            if (cls == null)
                return null;
             
            if (cls.GetInterface( "System.Security.Permissions.IBuiltInPermission" ) != null)
            {
                            if (s_reflectPerm == null)
                                s_reflectPerm = new ReflectionPermission(PermissionState.Unrestricted);
                            s_reflectPerm.Assert();
                MethodInfo method = cls.GetMethod( "GetTokenIndex", BindingFlags.Static | BindingFlags.NonPublic );
                BCLDebug.Assert( method != null, "IBuiltInPermission types should have a static method called 'GetTokenIndex'" );
                return s_theTokenFactory.BuiltInGetToken( (int)method.Invoke( null, null ), null, cls );
            }             
            else
            {
                return s_theTokenFactory.FindToken( cls );
            }
        }
   
    }
    
    // Package access only
    internal class PermissionTokenFactory
    {
        // NOTE: if you add a new built-in permission, you will need to update
        // these numbers.
        internal const int NUM_BUILTIN_UNRESTRICTED = BuiltInPermissionIndex.NUM_BUILTIN_UNRESTRICTED;
        internal const int NUM_BUILTIN_NORMAL = BuiltInPermissionIndex.NUM_BUILTIN_NORMAL;

        internal int       m_normalIndex;
        internal int       m_unrestrictedIndex;
        internal Hashtable m_tokenTable;

        // We keep an array of tokens for our built-in permissions.
        // This is ordered in terms of unrestricted perms first, normals
        // second.  Of course, all the ordering is based on the individual
        // permissions sticking to the deal, so we do some simple boundary
        // checking but mainly leave it to faith.

        internal PermissionToken[] m_builtIn;

        static internal bool m_unloadRegistered = false;
    
        private const String s_unrestrictedPermissionInferfaceName = "System.Security.Permissions.IUnrestrictedPermission";                                                                       
    
        internal PermissionTokenFactory( int size )
        {
            m_builtIn = new PermissionToken[NUM_BUILTIN_NORMAL + NUM_BUILTIN_UNRESTRICTED];

            for (int i = 0; i < NUM_BUILTIN_NORMAL + NUM_BUILTIN_UNRESTRICTED; ++i)
            {
                m_builtIn[i] = null;
            }

            m_normalIndex = NUM_BUILTIN_NORMAL;
            m_unrestrictedIndex = NUM_BUILTIN_UNRESTRICTED;
            m_tokenTable = new Hashtable( size );
        }
        
        internal PermissionToken FindToken( Type cls )
        {
            return (PermissionToken)m_tokenTable[cls];
        }
        
        internal PermissionToken GetToken(Type cls, IPermission perm)
        {
            Object tok = null;
            tok = m_tokenTable[cls]; // Assumes asynchronous lookups are safe
            if (tok == null)
            {
                lock (this)
                {
                    tok = m_tokenTable[cls]; // Make sure it wasn't just added
                    if (tok == null)
                    {
                        if (!m_unloadRegistered)
                        {
                            AppDomain.CurrentDomain.DomainUnload += new EventHandler(UnloadHandler);
                            m_unloadRegistered = true;
                        }

                        if (perm != null)
                        {
                            if (perm is System.Security.Permissions.IUnrestrictedPermission)
                                tok = new PermissionToken( m_unrestrictedIndex++, true );
                            else
                                tok = new PermissionToken( m_normalIndex++, false );
                        }
                        else
                        {
                            if (cls.GetInterface(s_unrestrictedPermissionInferfaceName) != null)
                                tok = new PermissionToken( m_unrestrictedIndex++, true );
                            else
                                tok = new PermissionToken( m_normalIndex++, false );
                        }                           
                        m_tokenTable.Add(cls, tok);
                    }
                }
            }
            return (PermissionToken)tok;
        }

        internal PermissionToken BuiltInGetToken( int index, IPermission perm, Type cls )
        {
            BCLDebug.Assert( index >= 0 && index < NUM_BUILTIN_UNRESTRICTED + NUM_BUILTIN_NORMAL,
                             "Built-in permissions must provide a valid index" );

            PermissionToken token = m_builtIn[index];

            if (token == null)
            {
                bool unrestricted = perm != null ? perm is IUnrestrictedPermission : cls.GetInterface( "System.Security.Permissions.IUnrestrictedPermission" ) != null;
                int realIndex = (unrestricted ? index : index - NUM_BUILTIN_UNRESTRICTED);

                token = new PermissionToken( realIndex, unrestricted );
                m_builtIn[index] = token;

#if _DEBUG
                // Do a few sanity checks to make sure we haven't truly messed things up.
                if (unrestricted)
                {
                    BCLDebug.Assert( index >= 0 && index < NUM_BUILTIN_UNRESTRICTED,
                                     "Invalid index for an unrestricted permission" );
                }
                else
                {
                    BCLDebug.Assert( index >= NUM_BUILTIN_UNRESTRICTED && index < NUM_BUILTIN_UNRESTRICTED + NUM_BUILTIN_NORMAL,
                                     "Invalid index for a normal permission" );
                }
#endif
            }

            return token;
        }

        internal void UnloadHandler(Object sender, EventArgs e)
        {
            IDictionaryEnumerator enumerator = m_tokenTable.GetEnumerator();

            while (enumerator.MoveNext())
            {
                Type key = (Type)enumerator.Key;

                if (AppDomain.CurrentDomain.IsTypeUnloading( key ))
                {
                    m_tokenTable.Remove( key );
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\policymanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  PolicyManager
//
//  The Runtime policy manager.  Maintains a set of IdentityMapper objects that map 
//  inbound evidence to groups.  Resolves an identity into a set of permissions
//

namespace System.Security {
    using System;
    using System.Security.Util;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Reflection;
    using System.Globalization;
    using System.Text;
    using System.Runtime.Serialization.Formatters.Binary;
        using System.Threading;
        using System.Runtime.CompilerServices;
    
    internal class PolicyManager
    {
        [System.Diagnostics.Conditional( "_DEBUG" )]
        internal static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "c:\\tests\\current\\asp\\t1\\debug.txt";
#endif  
        internal IList m_levels;
        
        public PolicyManager()
        {
            m_levels = ArrayList.Synchronized( new ArrayList( 4 ) );
            
            InitData();
        }

        internal void InitData()
        {
            if (Config.MachineDirectory == null)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_SecurityPolicyConfig" ) );

            String enterpriseConfig = Config.MachineDirectory + "enterprisesec.config";
            String machineConfig = Config.MachineDirectory + "security.config";

            String userConfig;
            if (Config.UserDirectory == null)
                userConfig = Config.MachineDirectory + "defaultusersecurity.config";
            else
                userConfig = Config.UserDirectory + "security.config";

            if (enterpriseConfig == null ||
                machineConfig == null ||
                userConfig == null)
            {
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_SecurityPolicyConfig" ) );
            }

            bool generateQuickCacheOnLoad;

            generateQuickCacheOnLoad = ((Config.InitData( ConfigId.EnterprisePolicyLevel, enterpriseConfig, enterpriseConfig + ".cch" ) & ConfigRetval.CacheFile) == 0);
            m_levels.Add( new PolicyLevel( "Enterprise", ConfigId.EnterprisePolicyLevel, false, generateQuickCacheOnLoad ) );
            generateQuickCacheOnLoad = ((Config.InitData( ConfigId.MachinePolicyLevel, machineConfig, machineConfig + ".cch" ) & ConfigRetval.CacheFile) == 0);
            m_levels.Add( new PolicyLevel( "Machine", ConfigId.MachinePolicyLevel, true, generateQuickCacheOnLoad ) );
            generateQuickCacheOnLoad = ((Config.InitData( ConfigId.UserPolicyLevel, userConfig, userConfig + ".cch" ) & ConfigRetval.CacheFile) == 0);
            m_levels.Add( new PolicyLevel( "User", ConfigId.UserPolicyLevel, false, generateQuickCacheOnLoad ) );
        }
        
        internal void AddLevel( PolicyLevel level )
        {
            m_levels.Add( new PolicyLevel( level ) );
        }
        
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.ControlPolicy)]
        public IEnumerator PolicyHierarchy()
        {
            return m_levels.GetEnumerator();
        }
        
        public PermissionSet Resolve(Evidence evidence, PermissionSet request)
        {
#if _DEBUG    
            if (debug)
            {
                DEBUG_OUT("PolicyManager::Resolve");
                IEnumerator evidenceEnumerator = evidence.GetEnumerator();
                DEBUG_OUT("Evidence:");
                while (evidenceEnumerator.MoveNext())
                {
                    Object obj = evidenceEnumerator.Current;
                    if (obj is Site)
                    {
                        DEBUG_OUT( ((Site)obj).ToXml().ToString() );
                    }
                    else if (obj is Zone)
                    {
                        DEBUG_OUT( ((Zone)obj).ToXml().ToString() );
                    }
                    else if (obj is Url)
                    {
                        DEBUG_OUT( ((Url)obj).ToXml().ToString() );
                    }
                    else if (obj is Publisher)
                    {
                        DEBUG_OUT( ((Publisher)obj).ToXml().ToString() );
                    }
                    else if (obj is StrongName)
                    {
                        DEBUG_OUT( ((StrongName)obj).ToXml().ToString() );
                    }
                    else if (obj is PermissionRequestEvidence)
                    {
                        DEBUG_OUT( ((PermissionRequestEvidence)obj).ToXml().ToString() );
                    }
                }
            }
#endif

            // We set grant to null to represent "AllPossible"

            PermissionSet grant = null;
            PolicyStatement policy;
            PolicyLevel currentLevel = null;

            IEnumerator levelEnumerator = m_levels.GetEnumerator();
            
            char[] serializedEvidence = MakeEvidenceArray( evidence, false );
            int count = evidence.Count;

            bool testApplicationLevels = false;
            
            while (levelEnumerator.MoveNext())
            {
                currentLevel = (PolicyLevel)levelEnumerator.Current;
                policy = currentLevel.Resolve( evidence, count, serializedEvidence );

                // If the grant is "AllPossible", the intersection is just the other permission set.
                // Otherwise, do an inplace intersection (since we know we can alter the grant set since
                // it is a copy of the first policy statement's permission set).
                
                if (grant == null)
                {
                    grant = policy.PermissionSet;
                }
                else
                {
                    // An exception somewhere in here means that a permission
                    // failed some operation.  This simply means that it will be
                    // dropped from the grant set which is safe operation that
                    // can be ignored.
                
                    try
                    {
                        grant.InplaceIntersect( policy.GetPermissionSetNoCopy() );
                    }
                    catch (Exception)
                    {
                    }
                }
                    
    #if _DEBUG        
                if (debug)
                {
                    DEBUG_OUT( "Level = " + currentLevel.Label );
                    DEBUG_OUT( "policy =\n" + policy.ToXml().ToString() );
                    DEBUG_OUT( "grant so far =\n" + grant.ToXml().ToString() );
                }
    #endif

                if (grant.IsEmpty())
                {
                    break;
                }
                else if ((policy.Attributes & PolicyStatementAttribute.LevelFinal) == PolicyStatementAttribute.LevelFinal)
                {
                    if (!currentLevel.Label.Equals( "AppDomain" ))
                    {
                        testApplicationLevels = true;
                    }

                    break;
                }
            }

            if (testApplicationLevels)
            {
                PolicyLevel appDomainLevel = null;

                for (int i = m_levels.Count - 1; i >= 0; --i)
                {
                    currentLevel = (PolicyLevel)m_levels[i];

                    if (currentLevel.Label.Equals( "AppDomain" ))
                    {
                        appDomainLevel = currentLevel;
                        break;
                    }
                }

                if (appDomainLevel != null)
                {
                    policy = appDomainLevel.Resolve( evidence, count, serializedEvidence );

                    grant.InplaceIntersect( policy.GetPermissionSetNoCopy() );
                }
            }
           
           
    #if _DEBUG        
            if (debug)
            {
                DEBUG_OUT( "granted =\n" + grant.ToString() );
                DEBUG_OUT( "request =\n" + (request != null ? request.ToString() : "<null>") );
                DEBUG_OUT( "awarded =\n" + (request != null ? grant.Intersect( request ).ToString() : grant.ToString()) );
            } 
    #endif
           
            try
            {
                if(request != null)
                    grant.InplaceIntersect( request );
            }
            catch (Exception)
            {
            }
    
    #if _DEBUG
            if (debug) {
                DEBUG_OUT("granted after intersect w/ request =\n" + grant.ToString());
            }
    #endif
    
            // Each piece of evidence can possibly create an identity permission that we
            // need to add to our grant set.  Therefore, for all pieces of evidence that
            // implement the IIdentityPermissionFactory interface, ask it for its
            // adjoining identity permission and add it to the grant.
    
            IEnumerator enumerator = evidence.GetHostEnumerator();
            while (enumerator.MoveNext())
            {
                try
                {
                    Object obj = enumerator.Current;
                    IIdentityPermissionFactory factory = obj as IIdentityPermissionFactory;
                    if (factory != null)
                    {
                        IPermission perm = factory.CreateIdentityPermission( evidence );
                        
                        if (perm != null)
                        {
                            grant.AddPermission( perm );
                        }
                    }
                }
                catch (Exception)
                {
                }
            }
            
    #if _DEBUG
            if (debug)
            {
                DEBUG_OUT( "awarded with identity =\n" + grant.ToString() );
            }
    #endif
            return grant;
        }
                
        public IEnumerator ResolveCodeGroups( Evidence evidence )
        {
            ArrayList accumList = new ArrayList();
            IEnumerator levelEnumerator = m_levels.GetEnumerator();

            while (levelEnumerator.MoveNext())
            {
                CodeGroup temp = ((PolicyLevel)levelEnumerator.Current).ResolveMatchingCodeGroups( evidence );
                if (temp != null)
                {
                    accumList.Add( temp );
                }
            }
            
            return accumList.GetEnumerator( 0, accumList.Count );
        }

        public void Save()
        {
            EncodeLevel( "Enterprise" );
            EncodeLevel( "Machine" );
            EncodeLevel( "User" );
        }
     
        private void EncodeLevel( String label )
        {
            for (int i = 0; i < m_levels.Count; ++i)
            {
                PolicyLevel currentLevel = (PolicyLevel)m_levels[i];
    
                if (currentLevel.Label.Equals( label ))
                {
                    EncodeLevel( currentLevel );
                    return;
                }
            }
            
        }

        internal static void EncodeLevel( PolicyLevel level )
        {
            SecurityElement elConf = new SecurityElement( "configuration" );
            SecurityElement elMscorlib = new SecurityElement( "mscorlib" );
            SecurityElement elSecurity = new SecurityElement( "security" );
            SecurityElement elPolicy = new SecurityElement( "policy" );
                    
            elConf.AddChild( elMscorlib );
            elMscorlib.AddChild( elSecurity );
            elSecurity.AddChild( elPolicy );
            elPolicy.AddChild( level.ToXml() );
                    
            try
            {
                MemoryStream stream = new MemoryStream( 24576 ); 
            
                StreamWriter writer = new StreamWriter( stream, new UTF8Encoding(false) );
                
                Encoding encoding = level.Encoding;

                if (encoding == null)
                    encoding = writer.Encoding;
                
                SecurityElement format = new SecurityElement( "xml" );
                format.m_type = SecurityElementType.Format;
                format.AddAttribute( "version", "1.0" );
                format.AddAttribute( "encoding", encoding.WebName );
                writer.Write( format.ToString() );
                writer.Flush();
                writer = new StreamWriter( stream, encoding );
            
                writer.Write( elConf.ToString() );
                        
                writer.Flush();

                // Write out the new config.

                if (!Config.SaveData( level.ConfigId, stream.GetBuffer(), 0, (int)stream.Length ))
                {
                    throw new PolicyException( String.Format( Environment.GetResourceString( "Policy_UnableToSave" ), level.Label ) );
                }
            }
            catch (Exception e)
            {
                if (e is PolicyException)
                    throw e;
                else
                    throw new PolicyException( String.Format( Environment.GetResourceString( "Policy_UnableToSave" ), level.Label ), e );
            }

            Config.ResetCacheData( level.ConfigId );

            try
            {
                if (CanUseQuickCache( level.RootCodeGroup ))
                {
                    Config.SetQuickCache( level.ConfigId, GenerateQuickCache( level ) );
                }
            }
            catch (Exception)
            {
            }

        }

        // Here is the managed portion of the QuickCache code.  It
        // is mainly concerned with detecting whether it is valid
        // for us to use the quick cache, and then calculating the
        // proper mapping of partial evidence to partial mapping.
        //
        // The choice of the partial evidence sets is fairly arbitrary
        // and in this case is tailored to give us meaningful
        // results from default policy.
        //
        // The choice of whether or not we can use the quick cache
        // is far from arbitrary.  There are a couple conditions that must
        // be true for the QuickCache to produce valid result.  These
        // are:
        // 
        // * equivalent evidence objects must produce the same
        //   grant set (i.e. it must be independent of time of day,
        //   space on the harddisk, other "external" factors, and
        //   cannot be random).
        //
        // * evidence must be used positively (i.e. if evidence A grants
        //   permission X, then evidence A+B must grant at least permission
        //   X).
        //
        // In particular for our implementation, this means that we
        // limit the classes that can be used by policy to just
        // the ones defined within mscorlib and that there are
        // no Exclusive bits set on any code groups.

        internal static bool CanUseQuickCache( CodeGroup group )
        {
            ArrayList list = new ArrayList();

            list.Add( group );

            for (int i = 0; i < list.Count; ++i)
            {
                group = (CodeGroup)list[i];

                NetCodeGroup netGroup = group as NetCodeGroup;
                UnionCodeGroup unionGroup = group as UnionCodeGroup;
                FirstMatchCodeGroup firstGroup = group as FirstMatchCodeGroup;
                FileCodeGroup fileGroup = group as FileCodeGroup;

                if (netGroup != null)
                {
                    if (!TestPolicyStatement( netGroup.PolicyStatement ))
                        return false;
                }
                else if (unionGroup != null)
                {
                    if (!TestPolicyStatement( unionGroup.PolicyStatement ))
                        return false;
                }
                else if (firstGroup != null)
                {
                    if (!TestPolicyStatement( firstGroup.PolicyStatement ))
                        return false;
                }
                else if (fileGroup != null)
                {
                    if (!TestPolicyStatement( fileGroup.PolicyStatement ))
                        return false;
                }
                else
                {
                    return false;
                }
            
                IMembershipCondition cond = group.MembershipCondition;

                if (cond != null && !(cond is IConstantMembershipCondition))
                {
                    return false;
                }

                IList children = group.Children;

                if (children != null && children.Count > 0)
                {
                    IEnumerator enumerator = children.GetEnumerator();

                    while (enumerator.MoveNext())
                    {
                        list.Add( enumerator.Current );
                    }
                }
            }

            return true;
        }

        private static bool TestPolicyStatement( PolicyStatement policy )
        {
            if (policy == null)
                return true;

            return (policy.Attributes & PolicyStatementAttribute.Exclusive) == 0;
        }

        internal static QuickCacheEntryType GenerateQuickCache( PolicyLevel level )
        {
            QuickCacheEntryType[] ExecutionMap = new QuickCacheEntryType[]
                { QuickCacheEntryType.ExecutionZoneMyComputer,
                  QuickCacheEntryType.ExecutionZoneIntranet,
                  QuickCacheEntryType.ExecutionZoneInternet,
                  QuickCacheEntryType.ExecutionZoneTrusted,
                  QuickCacheEntryType.ExecutionZoneUntrusted };

            QuickCacheEntryType[] UnmanagedMap = new QuickCacheEntryType[]
                { QuickCacheEntryType.UnmanagedZoneMyComputer,
                  QuickCacheEntryType.UnmanagedZoneIntranet,
                  QuickCacheEntryType.UnmanagedZoneInternet,
                  QuickCacheEntryType.UnmanagedZoneTrusted,
                  QuickCacheEntryType.UnmanagedZoneUntrusted };

            QuickCacheEntryType[] BindingRedirectMap = new QuickCacheEntryType[]
                { QuickCacheEntryType.BindingRedirectsZoneMyComputer,
                  QuickCacheEntryType.BindingRedirectsZoneIntranet,
                  QuickCacheEntryType.BindingRedirectsZoneInternet,
                  QuickCacheEntryType.BindingRedirectsZoneTrusted,
                  QuickCacheEntryType.BindingRedirectsZoneUntrusted };

            QuickCacheEntryType[] SkipVerificationMap = new QuickCacheEntryType[]
                { QuickCacheEntryType.SkipVerificationZoneMyComputer,
                  QuickCacheEntryType.SkipVerificationZoneIntranet,
                  QuickCacheEntryType.SkipVerificationZoneInternet,
                  QuickCacheEntryType.SkipVerificationZoneTrusted,
                  QuickCacheEntryType.SkipVerificationZoneUntrusted };

            QuickCacheEntryType[] FullTrustMap = new QuickCacheEntryType[]
                { QuickCacheEntryType.FullTrustZoneMyComputer,
                  QuickCacheEntryType.FullTrustZoneIntranet,
                  QuickCacheEntryType.FullTrustZoneInternet,
                  QuickCacheEntryType.FullTrustZoneTrusted,
                  QuickCacheEntryType.FullTrustZoneUntrusted };

            QuickCacheEntryType accumulator = (QuickCacheEntryType)0;

            SecurityPermission execPerm = new SecurityPermission( SecurityPermissionFlag.Execution );
            SecurityPermission unmanagedPerm = new SecurityPermission( SecurityPermissionFlag.UnmanagedCode );
            SecurityPermission skipVerifPerm = new SecurityPermission( SecurityPermissionFlag.SkipVerification );
            SecurityPermission bindingRedirectPerm = new SecurityPermission( SecurityPermissionFlag.BindingRedirects );

            Evidence noEvidence = new Evidence();

            PermissionSet policy = null;
            
            try
            {
                policy = level.Resolve( noEvidence ).PermissionSet;

                if (policy.Contains( execPerm ))
                    accumulator |= QuickCacheEntryType.ExecutionAll;

                if (policy.Contains( unmanagedPerm ))
                    accumulator |= QuickCacheEntryType.UnmanagedAll;

                if (policy.Contains( skipVerifPerm ))
                    accumulator |= QuickCacheEntryType.SkipVerificationAll;

                if (policy.Contains( bindingRedirectPerm ))
                    accumulator |= QuickCacheEntryType.BindingRedirectsAll;

                if (policy.IsUnrestricted())
                    accumulator |= QuickCacheEntryType.FullTrustAll;
            }
            catch (PolicyException)
            {
            }

            Array zones = Enum.GetValues( typeof( SecurityZone ) );

            for (int i = 0; i < zones.Length; ++i)
            {
                if (((SecurityZone)zones.GetValue( i )) == SecurityZone.NoZone)
                    continue;

                Evidence zoneEvidence = new Evidence();
                zoneEvidence.AddHost( new Zone( (SecurityZone)zones.GetValue( i ) ) );

                PermissionSet zonePolicy = null;
                
                try
                {
                    zonePolicy = level.Resolve( zoneEvidence ).PermissionSet;

                    if (zonePolicy.Contains( execPerm ))
                        accumulator |= ExecutionMap[i];

                    if (zonePolicy.Contains( unmanagedPerm ))
                        accumulator |= UnmanagedMap[i];

                    if (zonePolicy.Contains( skipVerifPerm ))
                        accumulator |= SkipVerificationMap[i];

                    if (zonePolicy.Contains( bindingRedirectPerm ))
                        accumulator |= BindingRedirectMap[i];

                    if (zonePolicy.IsUnrestricted())
                        accumulator |= FullTrustMap[i];
                }
                catch (PolicyException)
                {
                }
            }

            return accumulator;
        }

        internal static char[] MakeEvidenceArray( Evidence evidence, bool verbose )
        {
                        // We only support caching on our built-in evidence types (excluding hash b/c it would
                        // make our caching scheme just match up the same assembly from the same location which
                        // doesn't gain us anything).

            IEnumerator enumerator = evidence.GetEnumerator();
            int requiredLength = 0;

            while (enumerator.MoveNext())
            {
                IBuiltInEvidence obj = enumerator.Current as IBuiltInEvidence;

                if (obj == null)
                    return null;

                requiredLength += obj.GetRequiredSize(verbose);
            }

            enumerator.Reset();

            char[] buffer = new char[requiredLength];

            int position = 0;

            while (enumerator.MoveNext())
            {   
                position = ((IBuiltInEvidence)enumerator.Current).OutputToBuffer( buffer, position, verbose );
            }

            return buffer;
        }
        
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int _DebugOut( String file, String message );
                                                      
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\securityexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: SecurityException
**
** Author: Paul Kromann (paulkr)
**
** Purpose: Exception class for security
**
** Date: March 22, 1998
**
=============================================================================*/

namespace System.Security {
    using System.Security;
    using System;
    using System.Runtime.Serialization;
    using System.Security.Permissions;

    /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException"]/*' />
    [Serializable] public class SecurityException : SystemException {

        [NonSerialized] private Type permissionType;
        private String permissionState;
        private String grantedSet;
        private String refusedSet;

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException"]/*' />
        public SecurityException() 
            : base(Environment.GetResourceString("Arg_SecurityException")) {
            SetErrorCode(__HResults.COR_E_SECURITY);
        }
    
        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException1"]/*' />
        public SecurityException(String message) 
            : base(message)
        {
            SetErrorCode(__HResults.COR_E_SECURITY);
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException2"]/*' />
        public SecurityException(String message, Type type ) 
            : base(message)
        {
            SetErrorCode(__HResults.COR_E_SECURITY);
            permissionType = type;
        }

        internal SecurityException( PermissionSet grantedSetObj, PermissionSet refusedSetObj )
            : base(Environment.GetResourceString("Arg_SecurityException")) {
            SetErrorCode(__HResults.COR_E_SECURITY);
            if (grantedSetObj != null)
                grantedSet = grantedSetObj.ToXml().ToString();
            if (refusedSetObj != null)
                refusedSet = refusedSetObj.ToXml().ToString();
        }
    
        internal SecurityException( String message, PermissionSet grantedSetObj, PermissionSet refusedSetObj )
            : base(message) {
            SetErrorCode(__HResults.COR_E_SECURITY);
            if (grantedSetObj != null)
                grantedSet = grantedSetObj.ToXml().ToString();
            if (refusedSetObj != null)
                refusedSet = refusedSetObj.ToXml().ToString();
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException4"]/*' />
        public SecurityException(String message, Type type, String state ) 
            : base(message)
        {
    		SetErrorCode(__HResults.COR_E_SECURITY);
            permissionType = type;
            permissionState = state;
        }

    
        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException3"]/*' />
        public SecurityException(String message, Exception inner) 
            : base(message, inner) {
    		SetErrorCode(__HResults.COR_E_SECURITY);
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.SecurityException5"]/*' />
        protected SecurityException(SerializationInfo info, StreamingContext context) : base (info, context) {
            if (info==null)
                throw new ArgumentNullException("info");

            try
            {
                permissionState = (String)info.GetValue("PermissionState",typeof(String));
            }
            catch (Exception)
            {
                permissionState = null;
            }
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.PermissionType"]/*' />
        public Type PermissionType
        {
            get
            {
                return permissionType;
            }
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.PermissionState"]/*' />
        public String PermissionState
        {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get
            {
                return permissionState;
            }
        }

        internal void SetPermissionState( String state )
        {
            permissionState = state;
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.GrantSet"]/*' />
        public String GrantedSet
        {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get
            {
                return grantedSet;
            }
        }

        internal void SetGrantedSet( String grantedSetStr )
        {
            grantedSet = grantedSetStr;
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.DeniedSet"]/*' />
        public String RefusedSet
        {
            [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlEvidence | SecurityPermissionFlag.ControlPolicy)]
            get
            {
                return refusedSet;
            }
        }

        internal void SetRefusedSet( String refusedSetStr )
        {
            refusedSet = refusedSetStr;
        }


        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.ToString"]/*' />
        public override String ToString() 
        {
            String RetVal=base.ToString();

            try
            {
                if (PermissionState!=null)
                {
                    // Note: in this function we purposely call to
                    // the properties and not the fields because
                    // we want to do the security checks and only
                    // print out the information if the caller
                    // passes the appropriate check.
 
                    if (RetVal==null)
                        RetVal=" ";
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.GetResourceString( "Security_State" );
                    RetVal+=" " + Environment.NewLine;
                    RetVal+=PermissionState;
                }
                if (GrantedSet!=null)
                {
                    if (RetVal==null)
                        RetVal=" ";
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.GetResourceString( "Security_GrantedSet" );
                    RetVal+=Environment.NewLine;
                    RetVal+=GrantedSet;
                }
                if (RefusedSet!=null)
                {
                    if (RetVal==null)
                        RetVal=" ";
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.NewLine;
                    RetVal+=Environment.GetResourceString( "Security_RefusedSet" );
                    RetVal+=Environment.NewLine;
                    RetVal+=RefusedSet;
                }
            }
            catch(SecurityException)
            {
            }
            return RetVal;
        }

        /// <include file='doc\SecurityException.uex' path='docs/doc[@for="SecurityException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }

            base.GetObjectData( info, context );

            try
            {
                info.AddValue("PermissionState", PermissionState, typeof(String));
            }
            catch (SecurityException)
            {
            }
        }
            
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\securityruntime.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    //SecurityEngine.cool
	using System;
        using System.Threading;
	using System.Reflection;
	using System.Collections;
	using System.Runtime.CompilerServices;
	using SecurityPermission = System.Security.Permissions.SecurityPermission;
	using IUnrestrictedPermission = System.Security.Permissions.IUnrestrictedPermission;

    internal class SecurityRuntime
    {
        private static void DEBUG_OUT( String str )
        {
#if _DEBUG
            if (debug)
            {
                if (to_file)
                    PolicyManager._DebugOut( file, str+"\n" );
                else
                    Console.WriteLine( str );
             }
#endif             
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "d:\\tests\\diskio\\debug.txt";
#endif  
        internal SecurityRuntime()
        {
            InitSecurityRuntime();
        }
        
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void InitSecurityRuntime();
    
        
        // Returns the security object for the caller of the method containing
        // 'stackMark' on its frame.
        //
        // THE RETURNED OBJECT IS THE LIVE RUNTIME OBJECT. BE CAREFUL WITH IT!
        //
        // Internal only, do not doc.
        // 
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern 
        FrameSecurityDescriptor GetSecurityObjectForFrame(ref StackCrawlMark stackMark,
                                                          bool create);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern 
        void SetSecurityObjectForFrame(ref StackCrawlMark stackMark,
                                       FrameSecurityDescriptor desc);

        
        // Constants used to return status to native
        private const bool StackContinue  = true;
        private const bool StackHalt      = false;
        
        // Returns the number of negative overrides(deny/permitonly) in this secDesc
        private static int OverridesHelper(FrameSecurityDescriptor secDesc)
        {
            PermissionSet permSet;
            int count = 0;
            
            permSet = secDesc.GetPermitOnly();
            if (permSet != null)
                count++;
            permSet = secDesc.GetDenials();
            if (permSet != null)
                count++;
            return count;
        }

        private static bool FrameDescSetHelper(FrameSecurityDescriptor secDesc,
                                               PermissionSet demandSet,
                                               out PermissionSet alteredDemandSet)
        {
            PermissionSet permSet;

            // In the common case we are not going to alter the demand set, so just to
            // be safe we'll set it to null up front.
            
            // There's some oddness in here to deal with exceptions.  The general idea behind
            // this is that we need some way of dealing with custom permissions that may not
            // handle all possible scenarios of Union(), Intersect(), and IsSubsetOf() properly
            // (they don't support it, throw null reference exceptions, etc.).
            
            alteredDemandSet = null;

            // An empty demand always succeeds.
            if (demandSet == null || demandSet.IsEmpty())
                return StackHalt;
            
            // In the case of permit only, we define an exception to be failure of the check
            // and therefore we throw a security exception.
            
            try
            {
                permSet = secDesc.GetPermitOnly();
                if (permSet != null)
                {
                    if (!demandSet.IsSubsetOf(permSet))
                    {
                        throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
                    }
                }
            }
            catch (Exception)
            {
                throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
            }
                
            // In the case of denial, we define an exception to be failure of the check
            // and therefore we throw a security exception.
                
            try
            {
                permSet = secDesc.GetDenials();

    #if _DEBUG
                if (debug)
                {
                    DEBUG_OUT("Checking Denials");
                    DEBUG_OUT("denials set =\n" + permSet.ToXml().ToString() );
                    DEBUG_OUT("demandSet =\n" + demandSet.ToXml().ToString() );
                }
    #endif

                if (permSet != null)
                {
                    PermissionSet intersection = demandSet.Intersect(permSet);
            
                    if (intersection != null && !intersection.IsEmpty())
                    {
                        throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
                    }
                }
            }
            catch (Exception)
            {
                throw new SecurityException(Environment.GetResourceString("Security_GenericNoType"));
            }
            
            // The assert case is more complex.  Since asserts have the ability to "bleed through"
            // (where part of a demand is handled by an assertion, but the rest is passed on to
            // continue the stackwalk), we need to be more careful in handling the "failure" case.
            // Therefore, if an exception is thrown in performing any operation, we make sure to keep
            // that permission in the demand set thereby continuing the demand for that permission
            // walking down the stack.
            
            if (secDesc.GetAssertAllPossible())
            {
                return StackHalt;
            }        
            
            permSet = secDesc.GetAssertions();
            if (permSet != null)
            {
                // If this frame asserts a superset of the demand set we're done
                
                try
                {
                    if (demandSet.IsSubsetOf( permSet ))
                        return StackHalt;
                }
                catch (Exception)
                {
                }
                
                // Determine whether any of the demand set asserted.  We do this by
                // copying the demand set and removing anything in it that is asserted.
                    
                if (!permSet.IsUnrestricted())
                {
                    PermissionSetEnumerator enumerator = (PermissionSetEnumerator)demandSet.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        IPermission perm
                            = (IPermission)enumerator.Current;
                        int i = enumerator.GetCurrentIndex();
                        if (perm != null)
                        {
                            bool unrestricted = perm is System.Security.Permissions.IUnrestrictedPermission;
                            IPermission assertPerm
                                = (IPermission)permSet.GetPermission(i, unrestricted);
                            
                            bool removeFromAlteredDemand = false;
                            try
                            {
                                removeFromAlteredDemand = perm.IsSubsetOf(assertPerm);
                            }
                            catch (Exception)
                            {
                            }
                        
                            if (removeFromAlteredDemand)
                            {
                                if (alteredDemandSet == null)
                                    alteredDemandSet = demandSet.Copy();
                                alteredDemandSet.RemovePermission(i, unrestricted);
                            }                        
                        
                        }
                    }
                }
            }
            
            return StackContinue;
        }

        // Returns true to continue, or false to halt
        private static bool FrameDescHelper(FrameSecurityDescriptor secDesc,
                                               IPermission demand, 
                                               PermissionToken permToken)
        {
            PermissionSet permSet;
            
            // If the demand is null, there is no need to continue
            if (demand == null || demand.IsSubsetOf( null ))
                return StackHalt;
                
            // NOTE: See notes about exceptions and exception handling in FrameDescSetHelper 
            
            // Check Reduction
            
            try
            {
                permSet = secDesc.GetPermitOnly();
                if (permSet != null)
                {
                    IPermission perm = permSet.GetPermission(demand);
    #if _DEBUG
                    if (debug)
                    {
                        DEBUG_OUT("Checking PermitOnly");
                        DEBUG_OUT("permit only set =\n" + permSet.ToXml().ToString() );
                        DEBUG_OUT("demand =\n" + ((CodeAccessPermission)demand).ToXml().ToString() );
                    }
    #endif
            
                    // If the permit only set does not contain the demanded permission, throw a security exception
                    
                    if (perm == null)
                    {
                        if(!(demand is IUnrestrictedPermission && permSet.IsUnrestricted()))
                            throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                    }
                    else
                    {
                        if (!demand.IsSubsetOf( perm ))
                            throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                    }
                }
            }
            catch (Exception)
            {
                throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
            }
            
            
            // Check Denials
            
            try
            {
                permSet = secDesc.GetDenials();
                if (permSet != null)
                {
    #if _DEBUG
                    if (debug)
                    {
                        DEBUG_OUT("Checking Denials");
                        DEBUG_OUT("denied set =\n" + permSet.ToXml().ToString() );
                    }
    #endif
                    IPermission perm = permSet.GetPermission(demand);
                    
                    // If the deny set does contain the demanded permission, throw a security exception
            
                    if ((perm != null && perm.Intersect( demand ) != null) || (demand is IUnrestrictedPermission && permSet.IsUnrestricted()))
                        throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
                }
            }
            catch (Exception)
            {
                throw new SecurityException(String.Format(Environment.GetResourceString("Security_Generic"), demand.GetType().AssemblyQualifiedName), demand.GetType(), demand.ToXml().ToString());
            }                
    
            if (secDesc.GetAssertAllPossible())
            {
                return StackHalt;
            }        
    
            try
            {
                permSet = secDesc.GetAssertions();
                // Check Assertions
                if (permSet != null)
                {
    #if _DEBUG
                    if (debug)
                        DEBUG_OUT("Checking Assertions");
    #endif
            
                    IPermission perm = permSet.GetPermission(demand);
                
                    // If the assert set does contain the demanded permission, halt the stackwalk
            
                    if ((perm != null && (demand.IsSubsetOf( perm )) || (demand is IUnrestrictedPermission && permSet.IsUnrestricted())))
                    {
    #if _DEBUG
                        if (debug)
                            DEBUG_OUT("Assert halting stackwalk");
    #endif                       
                        return StackHalt;
                    }
                }
            }
            catch (Exception)
            {
            }
            
            return StackContinue;
        }
        
        //
        // API for PermissionSets
        //
        
        public virtual void Assert(PermissionSet permSet, ref StackCrawlMark stackMark)
        {
            // Note: if the "AssertPermission" is not a permission that implements IUnrestrictedPermission
            // you need to change the fourth parameter to a zero.
            FrameSecurityDescriptor secObj = CodeAccessSecurityEngine.CheckNReturnSO(
                                                CodeAccessSecurityEngine.AssertPermissionToken,
                                                CodeAccessSecurityEngine.AssertPermission,
                                                ref stackMark,
                                                1,
                                                1 );
    
            BCLDebug.Assert(secObj != null || !SecurityManager.SecurityEnabled,"Failure in SecurityRuntime.Assert() - secObj != null");
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                // Security: REQ_SQ flag is missing. Bad compiler ?
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetAssertions() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetAssert(permSet);
            }
        }
    
        internal virtual void AssertAllPossible(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj =
                SecurityRuntime.GetSecurityObjectForFrame(ref stackMark, true);
    
            BCLDebug.Assert(secObj != null || !SecurityManager.SecurityEnabled,"Failure in SecurityRuntime.AssertAllPossible() - secObj != null");
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                    // Security: REQ_SQ flag is missing. Bad compiler ?
                    throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetAssertAllPossible())
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetAssertAllPossible();
            }
        }
    
        public virtual void Deny(PermissionSet permSet, ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj =
                SecurityRuntime.GetSecurityObjectForFrame(ref stackMark, true);
    
            BCLDebug.Assert(secObj != null || !SecurityManager.SecurityEnabled,"Failure in SecurityRuntime.Deny() - secObj != null");
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                // Security: REQ_SQ flag is missing. Bad compiler ?
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetDenials() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetDeny(permSet);
            }
        }
    
        public virtual void PermitOnly(PermissionSet permSet, ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj =
                SecurityRuntime.GetSecurityObjectForFrame(ref stackMark, true);
    
            BCLDebug.Assert(secObj != null || !SecurityManager.SecurityEnabled,"Failure in SecurityRuntime.PermitOnly() - secObj != null");
            if (secObj == null)
            {
                if (SecurityManager.SecurityEnabled)
                // Security: REQ_SQ flag is missing. Bad compiler ?
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
            }
            else
            {
                if (secObj.GetPermitOnly() != null)
                    throw new SecurityException( Environment.GetResourceString( "Security_MustRevertOverride" ) );

                secObj.SetPermitOnly(permSet);
            }
        }
    
        //
        // Revert API
        //
        
        public virtual void RevertAssert(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj = GetSecurityObjectForFrame(ref stackMark, false);
            if (secObj != null)
            {
                secObj = secObj.Copy();
                secObj.RevertAssert();
                SetSecurityObjectForFrame(ref stackMark, secObj);
            }
            else if (SecurityManager.SecurityEnabled)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
        }

        public virtual void RevertAssertAllPossible(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj = GetSecurityObjectForFrame(ref stackMark, false);
            if (secObj != null)
            {
                secObj = secObj.Copy();
                secObj.RevertAssertAllPossible();
                SetSecurityObjectForFrame(ref stackMark, secObj);
            }
            else if (SecurityManager.SecurityEnabled)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
        }
        
        public virtual void RevertDeny(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj = GetSecurityObjectForFrame(ref stackMark, false);
            if (secObj != null)
            {
                secObj = secObj.Copy();
                secObj.RevertDeny();
                SetSecurityObjectForFrame(ref stackMark, secObj);
            }
            else if (SecurityManager.SecurityEnabled)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
        }
        
        public virtual void RevertPermitOnly(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj = GetSecurityObjectForFrame(ref stackMark, false);
            if (secObj != null)
            {
                secObj = secObj.Copy();
                secObj.RevertPermitOnly();
                SetSecurityObjectForFrame(ref stackMark, secObj);
            }
            else if (SecurityManager.SecurityEnabled)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
        }
        
        public virtual void RevertAll(ref StackCrawlMark stackMark)
        {
            FrameSecurityDescriptor secObj = GetSecurityObjectForFrame(ref stackMark, false);
            if (secObj != null)
            {
                secObj = secObj.Copy();
                secObj.RevertAll();
                SetSecurityObjectForFrame(ref stackMark, secObj);
            }
            else if (SecurityManager.SecurityEnabled)
                throw new ExecutionEngineException( Environment.GetResourceString( "ExecutionEngine_MissingSecurityDescriptor" ) );
        }
        
    
        // GetDeclaredPermissions
        // Returns a deep copy to classes declared permissions.
        public virtual PermissionSet GetDeclaredPermissions(Object obj, int action)
        {
            PermissionSet ps = GetDeclaredPermissionsP(obj, action);
            return ps.Copy();
        }
    
        // GetPermissions 
        // Gets the permissions for the given class.
        // This method must NOT BE EXPOSED TO THE PUBLIC.
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern PermissionSet GetDeclaredPermissionsP(Object obj, int action);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\securityelement.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
//
// CLASS:    SecurityElement.cs
//
// AUTHOR:   Christian Caron (t-ccaron) and Gregory D. Fee (gregfee)
//
// PURPOSE:  Represent an XML element 
// 
// DATE:     15 Feb 2000
// 
//---------------------------------------------------------------------------

namespace System.Security
{
    using System;
    using System.Collections;
    using System.Security.Util;
    using System.Text;
    using System.Globalization;

    internal enum SecurityElementType
    {
        Regular = 0,
        Format = 1,
        Comment = 2
    }


    /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement"]/*' />
    [Serializable]
    sealed public class SecurityElement
    {
        internal String  m_strTag;
        internal String  m_strText;
        internal ArrayList m_lChildren;
        internal ArrayList m_lAttributes;
        internal SecurityElementType m_type = SecurityElementType.Regular;
        
        private static readonly char[] s_tagIllegalCharacters = new char[] { ' ', '<', '>' };
        private static readonly char[] s_textIllegalCharacters = new char[] { '<', '>' };
        private static readonly char[] s_valueIllegalCharacters = new char[] { '<', '>', '\"' };
        private const String s_strIndent = "   ";

        private static readonly SecurityStringPair[] s_escapePairs = new SecurityStringPair[]
            {
                new SecurityStringPair( "<", "&lt;" ),
                new SecurityStringPair( ">", "&gt;" ),
                new SecurityStringPair( "\"", "&quot;" ),
                new SecurityStringPair( "\'", "&apos;" ),
                new SecurityStringPair( "&", "&amp;" )
            };

        private static readonly char[] s_escapeChars = new char[] { '<', '>', '\"', '\'', '&' };


        
        //-------------------------- Constructors ---------------------------
        
        internal SecurityElement()
        {
        }
        
        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.SecurityElement"]/*' />
        public SecurityElement( String tag )
        {
            if (tag == null)
                throw new ArgumentNullException( "tag" );
        
            if (!IsValidTag( tag ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementTag" ), tag ) );
        
            m_strTag = tag;
            m_strText = null;
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.SecurityElement1"]/*' />
        public SecurityElement( String tag, String text )
        {
            if (tag == null)
                throw new ArgumentNullException( "tag" );
        
            if (!IsValidTag( tag ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementTag" ), tag ) );

            if (text != null && !IsValidText( text ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementText" ), text ) );
        
            m_strTag = tag;
            m_strText = text;
        }
    
        //-------------------------- Properties -----------------------------

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Tag"]/*' />
        public String Tag
        {
            get
            {
                return m_strTag;
            }
            
            set
            {
                if (value == null)
                    throw new ArgumentNullException( "Tag" );
        
                if (!IsValidTag( value ))
                    throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementTag" ), value ) );
            
                m_strTag = value;
            }
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Attributes"]/*' />
        public System.Collections.Hashtable Attributes
        {
            get
            {
                if (m_lAttributes == null || m_lAttributes.Count == 0)
                {
                    return null;
                }
                else
                {
                    System.Collections.Hashtable hashtable = new System.Collections.Hashtable( m_lAttributes.Count );
                    
                    IEnumerator enumerator = m_lAttributes.GetEnumerator();
                    
                    while (enumerator.MoveNext())
                    {
                        SecurityStringPair pair = (SecurityStringPair)enumerator.Current;
                        
                        hashtable.Add( pair.m_strAttributeName, pair.m_strAttributeValue );
                    }
                    
                    return hashtable;
                }
            }
            
            set
            {
                if (value == null || value.Count == 0)
                {
                    m_lAttributes = null;
                }
                else
                {
                    ArrayList list = new ArrayList( value.Count );
                    
                    System.Collections.IDictionaryEnumerator enumerator = (System.Collections.IDictionaryEnumerator)value.GetEnumerator();
                    
                    while (enumerator.MoveNext())
                    {
                        String attrName = (String)enumerator.Key;
                        String attrValue = (String)enumerator.Value;
                    
                        if (!IsValidAttributeName( attrName ))
                            throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementName" ), (String)enumerator.Current ) );
                        
                        if (!IsValidAttributeValue( attrValue ))
                            throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementValue" ), (String)enumerator.Value ) );
                    
                        list.Add( new SecurityStringPair( attrName, attrValue ) );
                    }
                    
                    m_lAttributes = list;
                }
            }
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Text"]/*' />
        public String Text
        {
            get
            {
                return Unescape( m_strText );
            }
            
            set
            {
                if (value == null)
                {
                    m_strText = null;
                }
                else
                {
                    if (!IsValidText( value ))
                        throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementTag" ), value ) );
                        
                    m_strText = value;
                }
            }
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Children"]/*' />
        public ArrayList Children
        {
            get
            {
                return m_lChildren;
            }
            
            set
            {
                if (value != null)
                {
                    IEnumerator enumerator = value.GetEnumerator();
                    
                    while (enumerator.MoveNext())
                    {
                        if (enumerator.Current == null)
                            throw new ArgumentException( Environment.GetResourceString( "ArgumentNull_Child" ) );
                    }
                }
            
                m_lChildren = value;
            }
        }
     
        //-------------------------- Public Methods -----------------------------
        
        internal void AddAttributeSafe( String name, String value )
        {
            if (m_lAttributes == null)
            {
                m_lAttributes = new ArrayList( 4 );
            }
            else
            {
                IEnumerator enumerator = m_lAttributes.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    if (String.Equals(((SecurityStringPair)enumerator.Current).m_strAttributeName, name))
                        throw new ArgumentException( Environment.GetResourceString( "Argument_AttributeNamesMustBeUnique" ) );
                }
            }
        
            m_lAttributes.Add( new SecurityStringPair( name, value ) );
        }        
        
        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.AddAttribute"]/*' />
        public void AddAttribute( String name, String value )
        {   
            if (name == null)
                throw new ArgumentNullException( "name" );
                
            if (value == null)
                throw new ArgumentNullException( "value" );
        
            if (!IsValidAttributeName( name ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementName" ), name ) );
                
            if (!IsValidAttributeValue( value ))
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Argument_InvalidElementValue" ), value ) );
        
            AddAttributeSafe( name, value );
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.AddChild"]/*' />
        public void AddChild( SecurityElement child )
        {   
            if (child == null)
                throw new ArgumentNullException( "child" );
        
            if (m_lChildren == null)
                m_lChildren = new ArrayList( 4 );
                
            m_lChildren.Add( child );
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Equal"]/*' />
        public bool Equal( SecurityElement other )
        {
            if (other == null)
                return false;
        
            // Check if the tags are the same
            if (!String.Equals(m_strTag, other.m_strTag))
                return false;

            // Check if the text is the same
            if (!String.Equals(m_strText, other.m_strText))
                return false;

            // Check if the attributes are the same and appear in the same
            // order.
            
            // Maybe we can get away by only checking the number of attributes
            if (m_lAttributes == null || other.m_lAttributes == null)
            {
                if (m_lAttributes != other.m_lAttributes)
                    return false;
            }
            else {
				if (m_lAttributes.Count != other.m_lAttributes.Count)
					return false;

				// Okay, we'll need to go through each one of them
				IEnumerator lhs = m_lAttributes.GetEnumerator();
				IEnumerator rhs = other.m_lAttributes.GetEnumerator();

				SecurityStringPair attr1, attr2;
				while (lhs.MoveNext())
				{
					rhs.MoveNext();
					attr1 = (SecurityStringPair)lhs.Current;
					attr2 = (SecurityStringPair)rhs.Current;
					
					// Sanity check
					if (attr1 == null || attr2 == null)
						return false;
                
					if (!String.Equals(attr1.m_strAttributeName, attr2.m_strAttributeName) || !String.Equals(attr1.m_strAttributeValue, attr2.m_strAttributeValue))
						return false;
				}
			}

            // Finally we must check the child and make sure they are
            // equal and in the same order
            
            // Maybe we can get away by only checking the number of children
            if (m_lChildren == null || other.m_lChildren == null) 
			{
				if (m_lChildren != other.m_lChildren)
	                return false;
			} 
			else {
				if (m_lChildren.Count != other.m_lChildren.Count)
					return false;

				// Okay, we'll need to go through each one of them
				IEnumerator lhs = m_lChildren.GetEnumerator();
				IEnumerator rhs = other.m_lChildren.GetEnumerator();

				SecurityElement e1, e2;
				while (lhs.MoveNext())
				{
					rhs.MoveNext();
					e1 = (SecurityElement)lhs.Current;
					e2 = (SecurityElement)rhs.Current;       
					if (e1 == null || !e1.Equal(e2))                
						return false;
				}
			}

            return true;
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.IsValidTag"]/*' />
        public static bool IsValidTag( String tag )
        {
            if (tag == null)
                return false;
                
            return tag.IndexOfAny( s_tagIllegalCharacters ) == -1;
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.IsValidText"]/*' />
        public static bool IsValidText( String text )
        {
            if (text == null)
                return false;
                
            return text.IndexOfAny( s_textIllegalCharacters ) == -1;
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.IsValidAttributeName"]/*' />
        public static bool IsValidAttributeName( String name )
        {
            return IsValidTag( name );
        }
        
        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.IsValidAttributeValue"]/*' />
        public static bool IsValidAttributeValue( String value )
        {
            if (value == null)
                return false;
                
            return value.IndexOfAny( s_valueIllegalCharacters ) == -1;
        }

        private static String GetEscapeSequence( char c )
        {
            for (int i = 0; i < s_escapePairs.Length; ++i)
            {
                if (s_escapePairs[i].m_strAttributeName[0] == c)
                    return s_escapePairs[i].m_strAttributeValue;
            }

            BCLDebug.Assert( false, "Unable to find escape sequence for this character" );
            return c.ToString();
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Escape"]/*' />
        public static String Escape( String str )
        {
            if (str == null)
                return null;

            StringBuilder sb = null;

            String temp = str;
            int index;

            do
            {
                index = temp.IndexOfAny( s_escapeChars );

                if (index == -1)
                {
                    if (sb == null)
                        return str;
                    else
                    {
                        sb.Append( temp );
                        return sb.ToString();
                    }
                }
                else
                {
                    if (sb == null)
                        sb = new StringBuilder();                    

                    sb.Append( temp.Substring( 0, index ) );
                    sb.Append( GetEscapeSequence( temp[index] ) );

                    temp = temp.Substring( index + 1 );
                }
            }
            while (true);

            // C# reports a warning if I leave this in, but I still kinda want to just in case.
            // BCLDebug.Assert( false, "If you got here, the execution engine or compiler is really confused" );
            // return str;
        }

        private static String GetUnescapeSequence( String str, int index, out int newIndex )
        {
            int maxCompareLength = str.Length - index;

            for (int i = 0; i < s_escapePairs.Length; ++i)
            {
                int length = s_escapePairs[i].m_strAttributeValue.Length;

                if (length <= maxCompareLength && String.Compare( s_escapePairs[i].m_strAttributeValue, 0, str, index, s_escapePairs[i].m_strAttributeValue.Length, false, CultureInfo.InvariantCulture) == 0)
                {
                    newIndex = index + s_escapePairs[i].m_strAttributeValue.Length;
                    return s_escapePairs[i].m_strAttributeName;
                }
            }

            newIndex = index + 1;
            return str[index].ToString();
        }
            

        private static String Unescape( String str )
        {
            if (str == null)
                return null;

            StringBuilder sb = null;

            String temp = str;
            int index;
            int newIndex;

            do
            {
                index = temp.IndexOf( '&' );

                if (index == -1)
                {
                    if (sb == null)
                        return str;
                    else
                    {
                        sb.Append( temp );
                        return sb.ToString();
                    }
                }
                else
                {
                    if (sb == null)
                        sb = new StringBuilder();

                    sb.Append( temp.Substring( 0, index ) );
                    sb.Append( GetUnescapeSequence( temp, index, out newIndex ) );

                    temp = temp.Substring( newIndex );
                }
            }
            while (true);

            // C# reports a warning if I leave this in, but I still kinda want to just in case.
            // BCLDebug.Assert( false, "If you got here, the execution engine or compiler is really confused" );
            // return str;
        }


        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.ToString"]/*' />
        public override String ToString ()
        {
            return ToString( "" );              
        }
        
        private String ToString( String indent )
        {
            StringBuilder sb = new StringBuilder();

            // First add the indent
            
            sb.Append( indent );                       
            
            // Add in the opening bracket and the tag.
            
            sb.Append( "<" );

            switch (m_type)
            {
                case SecurityElementType.Format:
                    sb.Append( "?" );
                    break;

                case SecurityElementType.Comment:
                    sb.Append( "!--" );
                    break;

                default:
                    break;
            }

            sb.Append( m_strTag );
            
            // If there are any attributes, plop those in.
            
            if (m_lAttributes != null && m_lAttributes.Count > 0)
            {
                sb.Append( " " );

                for (int i = 0; i < m_lAttributes.Count; ++i)
                {
                    SecurityStringPair pair = (SecurityStringPair)m_lAttributes[i];
                    
                    sb.Append( pair.m_strAttributeName );
                    sb.Append( "=\"" );
                    sb.Append( pair.m_strAttributeValue );
                    sb.Append( "\"" );

                    if (i != m_lAttributes.Count - 1)
                    {
                        if (m_type == SecurityElementType.Regular)
                        {
                            sb.Append( Environment.NewLine );
                            sb.Append( indent );
                            sb.Append( ' ', m_strTag.Length + 2 );
                        }
                        else
                        {
                            sb.Append( " " );
                        }
                    }
                }
            }
            
            if (m_strText == null && (m_lChildren == null || m_lChildren.Count == 0))
            {
                // If we are a single tag with no children, just add the end of tag text.
    
                switch (m_type)
                {
                    case SecurityElementType.Comment:
                        sb.Append( " -->" );
                        break;

                    case SecurityElementType.Format:
                        sb.Append( " ?>" );
                        break;

                    default:
                        sb.Append( "/>" );
                        break;
                }
                sb.Append( Environment.NewLine );
            }
            else
            {
                // Close the current tag.
            
                sb.Append( ">" );
                
                // Output the text
                
                sb.Append( m_strText );
                
                // Output any children.
                
                if (m_lChildren != null)
                {
                    sb.Append( Environment.NewLine );
                
                    String childIndent = indent + s_strIndent;
                
                    IEnumerator enumerator = m_lChildren.GetEnumerator();
                    
                    while (enumerator.MoveNext())
                    {
                        sb.Append( ((SecurityElement)enumerator.Current).ToString( childIndent ) );
                    }

                    // In the case where we have children, the close tag will not be on the same line as the
                    // opening tag, so we need to indent.

                    sb.Append( indent );
                }
                
                // Output the closing tag
                
                sb.Append( "</" );
                sb.Append( m_strTag );
                sb.Append( ">" );
                sb.Append( Environment.NewLine );
            }
            
            return sb.ToString();
        }
                
                

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.Attribute"]/*' />
        public String Attribute( String name )
        {
            if (name == null)
                throw new ArgumentNullException( "name" );
                
            // Note: we don't check for validity here because an
            // if an invalid name is passed we simply won't find it.
        
            if (m_lAttributes == null)
                return null;
        
            SecurityStringPair attr;
            IEnumerator enumerator = m_lAttributes.GetEnumerator();
            
            // Go through all the attribute and see if we know about
            // the one we are asked for
            while (enumerator.MoveNext())
            {
                attr = (SecurityStringPair)enumerator.Current;
                
                if (attr != null && String.Equals(attr.m_strAttributeName, name))
                    return Unescape( (String)attr.m_strAttributeValue );
            }

            // In the case where we didn't find it, we are expected to
            // return null
            return null;
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.SearchForChildByTag"]/*' />
        public SecurityElement SearchForChildByTag( String tag )
        {
            // Go through all the children and see if we can
            // find the one are are asked for (matching tags)

            if (tag == null)
                throw new ArgumentNullException( "tag" );
                
            // Note: we don't check for a valid tag here because
            // an invalid tag simply won't be found.    
                
            if (m_lChildren == null)
                return null;

            IEnumerator enumerator = m_lChildren.GetEnumerator();

            while (enumerator.MoveNext())
            {
                SecurityElement current = (SecurityElement)enumerator.Current;
            
                if (current != null && String.Equals(current.Tag, tag))
                    return current;
            }

            return null;
        }
        
        internal String SearchForValueOfParam( String tag )
        {
            SecurityElement el = SearchForChildByTag( tag );
            
            if (el != null)
            {
                if (el.Text == null)
                    return "True";
                else
                    return Unescape( el.Text );
            }
            else
                return null;
        }

        internal String SearchForTextOfLocalName(String strLocalName) 
        {
            // Search on each child in order and each
            // child's child, depth-first
            
            if (strLocalName == null)
                throw new ArgumentNullException( "strLocalName" );
                
            // Note: we don't check for a valid tag here because
            // an invalid tag simply won't be found.    
            
            // First we check this.
			
			if (m_strTag == null) return null;            
            if (m_strTag.Equals( strLocalName ) || m_strTag.EndsWith( ":" + strLocalName ))
                return Unescape( m_strText );
                
            if (m_lChildren == null)
                return null;

            IEnumerator enumerator = m_lChildren.GetEnumerator();

            while (enumerator.MoveNext())
            {
                String current = ((SecurityElement)enumerator.Current).SearchForTextOfLocalName( strLocalName );
            
                if (current != null)
                    return current;
            }

            return null;            
        }

        /// <include file='doc\SecurityElement.uex' path='docs/doc[@for="SecurityElement.SearchForTextOfTag"]/*' />
        public String SearchForTextOfTag( String tag )
        {
            // Search on each child in order and each
            // child's child, depth-first
            
            if (tag == null)
                throw new ArgumentNullException( "tag" );
                
            // Note: we don't check for a valid tag here because
            // an invalid tag simply won't be found.    
            
            // First we check this.
            
            if (String.Equals(m_strTag, tag))
                return Unescape( m_strText );
                
            if (m_lChildren == null)
                return null;

            IEnumerator enumerator = m_lChildren.GetEnumerator();

            while (enumerator.MoveNext())
            {
                String current = ((SecurityElement)enumerator.Current).SearchForTextOfTag( tag );
            
                if (current != null)
                    return current;
            }

            return null;
        } 
   
        
    }                
        
        
    [Serializable]
    internal sealed class SecurityStringPair
    {
        internal String m_strAttributeName;
        internal String m_strAttributeValue;
        
        internal SecurityStringPair()
        {
            m_strAttributeName = null;
            m_strAttributeValue = null;                  
        }                                               
                                                        
        internal SecurityStringPair( String name, String value )  
        {                                               
            m_strAttributeName = name;                  
            m_strAttributeValue = value;                  
        }                                               
                                                        
        internal SecurityStringPair( SecurityStringPair rhs )            
        {                                               
            m_strAttributeName = rhs.m_strAttributeName;
            m_strAttributeValue = rhs.m_strAttributeValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissionset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security {
    using System;
    using System.Threading;
    using System.Security.Util;
    using System.Collections;
    using System.IO;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Runtime.Serialization.Formatters.Binary;
    using BindingFlags = System.Reflection.BindingFlags;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Runtime.Remoting.Activation;

	[Serializable] 
    internal enum SpecialPermissionSetFlag
    {
        // These also appear in clr/src/vm/permset.h
        Regular = 0,
        NoSet = 1,
        EmptySet = 2,
        SkipVerification = 3
    }

    /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet"]/*' />
    [Serializable] 
    [StrongNameIdentityPermissionAttribute(SecurityAction.InheritanceDemand, Name = "mscorlib", PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293" )]
	public class PermissionSet : ISecurityEncodable, ICollection, IStackWalk, IDeserializationCallback
    {
    #if _DEBUG
        internal static readonly bool debug = false;
    #endif
    
        private static void DEBUG_WRITE(String str) {
        #if _DEBUG
            if (debug) Console.WriteLine(str);
        #endif
         }

        private static void DEBUG_COND_WRITE(bool exp, String str)
        {
        #if _DEBUG
            if (debug && (exp)) Console.WriteLine(str);
        #endif
        }

        private static void DEBUG_PRINTSTACK(Exception e)
        {
        #if _DEBUG
            if (debug) Console.Error.WriteLine((e).StackTrace);
        #endif
        }
    
        // Remove this bool and function in Beta2
        private bool readableonly;    
        private void ReadableOnlyFunc()
        {
            readableonly = true;
            bool happy = readableonly;
        }

        private bool m_Unrestricted;
        internal TokenBasedSet m_unrestrictedPermSet = null;
        internal TokenBasedSet m_normalPermSet = null;
        
        internal static readonly PermissionSet s_fullTrust = new PermissionSet( true );

        internal static readonly bool optOn = true;
    
        [NonSerialized] private bool m_CheckedForNonCas;
        [NonSerialized] private bool m_ContainsCas;
        [NonSerialized] private bool m_ContainsNonCas;
        [NonSerialized] private SecurityElement m_toBeLoaded;

        internal PermissionSet()
        {
            Reset();
        }
        
        internal PermissionSet(bool fUnrestricted)
            : this()
        {
            SetUnrestricted(fUnrestricted);
            // Compiler hack to include the readableonly field in the serialized format.
            readableonly = true;
            if (readableonly)
                return;
        }
        
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.PermissionSet"]/*' />
        public PermissionSet(PermissionState state)
            : this()
        {
            if (state == PermissionState.Unrestricted)
            {
                SetUnrestricted( true );
            }
            else if (state == PermissionState.None)
            {
                SetUnrestricted( false );
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.PermissionSet1"]/*' />
        public PermissionSet(PermissionSet permSet)
            : this()
        {
            if (permSet == null)
            {
                Reset();
                return;
            }
    
            m_Unrestricted = permSet.m_Unrestricted;
            m_CheckedForNonCas = permSet.m_CheckedForNonCas;
            m_ContainsCas = permSet.m_ContainsCas;
            m_ContainsNonCas = permSet.m_ContainsNonCas;
            
            if (permSet.m_normalPermSet != null)
            {
                m_normalPermSet = new TokenBasedSet(permSet.m_normalPermSet);
                
                 // now deep copy all permissions in set
                for (int i = 0; i <= m_normalPermSet.GetMaxUsedIndex(); i++)
                {
                    IPermission perm = (IPermission)m_normalPermSet.GetItem(i);
                    if (perm != null)
                    {
                        m_normalPermSet.SetItem(i, perm.Copy());
                    }
                }
            }
               
            if (permSet.m_unrestrictedPermSet != null)
            {
                m_unrestrictedPermSet = new TokenBasedSet(permSet.m_unrestrictedPermSet);
                
                 // now deep copy all permissions in set
                for (int i = 0; i <= m_unrestrictedPermSet.GetMaxUsedIndex(); i++)
                {
                    IPermission perm = (IPermission)m_unrestrictedPermSet.GetItem(i);
                    if (perm != null)
                    {
                        m_unrestrictedPermSet.SetItem(i, perm.Copy());
                    }
                }
            }

            if (permSet.m_toBeLoaded != null)
            {
                this.m_toBeLoaded = new SecurityElement();

                IEnumerator enumerator = permSet.m_toBeLoaded.m_lChildren.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    this.m_toBeLoaded.AddChild( (SecurityElement)enumerator.Current );
                }
            }

        }
        
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.CopyTo"]/*' />
        public virtual void CopyTo(Array array, int index)
        {
            if (array == null)
                throw new ArgumentNullException( "array" );
        
            IEnumerator enumerator = GetEnumerator();
            
            while (enumerator.MoveNext())
            {
                array.SetValue( enumerator.Current , index++ );
            }
        }
        
        
        // private constructor that doesn't create any token based sets
        private PermissionSet( Object trash, Object junk )
        {
            m_Unrestricted = false;
        }
           
        
        // Returns an object appropriate for synchronizing access to this 
        // collection.
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.SyncRoot"]/*' />
        public virtual Object SyncRoot
        {  get { return this; } }	
        
        // Is this collection thread-safe?  If you want a synchronized
        // collection, you can use SyncRoot as an object to synchronize your 
        // collection with.  
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IsSynchronized"]/*' />
        public virtual bool IsSynchronized
        {  get { return false; } }	
            
        // Is this Collection ReadOnly?
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IsReadOnly"]/*' />
        public virtual bool IsReadOnly 
        {  get {return false; } }	

        // Reinitializes all state in PermissionSet.
        internal virtual void Reset()
        {
            m_Unrestricted = true;
            m_CheckedForNonCas = false;
            m_ContainsCas = false;
            m_ContainsNonCas = false;
    
            m_normalPermSet = null;
            m_unrestrictedPermSet = null;
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IsEmpty"]/*' />
        public virtual bool IsEmpty()
        {
            if (m_Unrestricted)
                return false;

            if ((m_normalPermSet == null || m_normalPermSet.FastIsEmpty()) &&
                (m_unrestrictedPermSet == null || m_unrestrictedPermSet.FastIsEmpty()))
                return true;

            IEnumerator enumerator = this.GetEnumerator();

            while (enumerator.MoveNext())
            {
                IPermission perm = (IPermission)enumerator.Current;

                if (!perm.IsSubsetOf( null ))
                {
                    return false;
                }
            }

            return true;
        }

        internal virtual bool FastIsEmpty()
        {
            if (m_Unrestricted)
                return false;

            if ((m_normalPermSet == null || m_normalPermSet.FastIsEmpty()) &&
                (m_unrestrictedPermSet == null || m_unrestrictedPermSet.FastIsEmpty()))
                return true;

            return false;
        }            
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Count"]/*' />
        public virtual int Count
        {
            get
            {
                int count = 0;

                if (m_normalPermSet != null)
                    count += m_normalPermSet.GetCount();

                if (m_unrestrictedPermSet != null)
                    count += m_unrestrictedPermSet.GetCount();

                return count;
            }
        }

    
           
        internal virtual IPermission GetPermission(int index, bool unrestricted)
        {
            if (unrestricted)
            {
                if (m_unrestrictedPermSet == null)
                    return null;

                return (IPermission)m_unrestrictedPermSet.GetItem( index );
            }
            else
            {
                if (m_normalPermSet == null)
                    return null;

                return (IPermission)m_normalPermSet.GetItem( index );
            }  
        }
    
    
        internal virtual IPermission GetPermission(PermissionToken permToken)
        {
            if (permToken == null)
                return null;
                    
            return GetPermission( permToken.m_index, permToken.m_isUnrestricted );
        }

        internal virtual IPermission GetPermission( IPermission perm )
        {
            if (perm == null)
                return null;

            return GetPermission(PermissionToken.GetToken( perm ));
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.GetPermission"]/*' />
        public virtual IPermission GetPermission(Type permClass)
        {
            if (permClass == null)
                return null;
                
            return GetPermission(PermissionToken.FindToken(permClass));
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.SetPermission"]/*' />
        public virtual IPermission SetPermission(IPermission perm)
        {
            return(SetPermission(perm, true));
        }
    
        // SetPermission adds a permission to a permissionset.
        // if fReplace is true, then force an override of current slot contents
        // otherwise, don't replace current slot contents.
        internal virtual IPermission SetPermission(IPermission perm, bool fReplace)
        {
            // can't get token if perm is null
            if (perm == null)
                return null;
            
            PermissionToken permToken = PermissionToken.GetToken(perm);
            
            TokenBasedSet permSet;
            
            if (permToken.m_isUnrestricted)
            {
                // SetPermission Makes the Permission "Restricted"
                m_Unrestricted = false;
                
                if (m_unrestrictedPermSet == null)
                    m_unrestrictedPermSet = new TokenBasedSet( permToken.m_index + 1, 4 );

                permSet = m_unrestrictedPermSet;
            }
            else
            {
                if (m_normalPermSet == null)
                    m_normalPermSet = new TokenBasedSet( permToken.m_index + 1, 4 );

                permSet = m_normalPermSet;
            }
                
            IPermission currPerm = (IPermission)permSet.GetItem(permToken.m_index);        
                
            // If a Permission exists in this slot, then our behavior
            // is defined by the value of fReplace.  Don't replace if 
            // fReplace is false, just return what was found. The caller of this function
            // should compare the references of the added permission
            // to the one returned. If they are equal, then the permission
            // was added successfully, otherwise it was not.
            if ((currPerm != null) && !fReplace) {
                return currPerm;
            }
    
            // OK, either we were told to always override (fReplace == true) or
            // there wasn't anything in the slot.  In either case, set the slot contents
            // to perm and return.

            m_CheckedForNonCas = false;
            
            // Should we copy here?
            permSet.SetItem(permToken.m_index, perm);
            return perm;
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.AddPermission"]/*' />
        public virtual IPermission AddPermission(IPermission perm)
        {
            // can't get token if perm is null
            if (perm == null)
                return null;
            
            m_CheckedForNonCas = false;
            
            // If the permission set is unrestricted, then return an unrestricted instance
            // of perm.
            
            PermissionToken permToken = null;
            TokenBasedSet permSet = null;
            
            if (perm is IUnrestrictedPermission)
            {
                if (m_Unrestricted == true)
                {
                    Type perm_type = perm.GetType();
                    Object[] objs = new Object[1];
                    objs[0] = PermissionState.Unrestricted;
                    return (IPermission) Activator.CreateInstance(perm_type, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, null, objs, null );
                }
                else
                {
                    permToken = PermissionToken.GetToken(perm);

                    if (m_unrestrictedPermSet == null)
                        m_unrestrictedPermSet = new TokenBasedSet( permToken.m_index + 1, 4 );

                    permSet = m_unrestrictedPermSet;
                }
            }
            else
            {
                permToken = PermissionToken.GetToken(perm);

                if (m_normalPermSet == null)
                    m_normalPermSet = new TokenBasedSet( permToken.m_index + 1, 4 );

                permSet = m_normalPermSet;
            }
            
            IPermission currPerm = (IPermission)permSet.GetItem(permToken.m_index);
            
            // If a Permission exists in this slot, then union it with perm
            // Otherwise, just add perm.
    
            if (currPerm != null) {
                IPermission ip_union = currPerm.Union(perm);
                permSet.SetItem(permToken.m_index, ip_union);
                return(ip_union);
            } else {
                // Should we copy here?
                permSet.SetItem(permToken.m_index, perm);
                return perm;
            }
                
        }
        
        internal virtual IPermission RemovePermission(int index, bool unrestricted)
        {
            m_CheckedForNonCas = false;
            
            if (unrestricted)
            {
                if (m_unrestrictedPermSet == null)
                    return null;

                return (IPermission)m_unrestrictedPermSet.RemoveItem( index );
            }
            else
            {
                if (m_normalPermSet == null)
                    return null;

                return (IPermission)m_normalPermSet.RemoveItem( index );
            }
        }
        
        internal virtual IPermission RemovePermission(PermissionToken permToken)
        {
            if (permToken == null)
                return null;
            
            return RemovePermission( permToken.m_index, permToken.m_isUnrestricted );
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.RemovePermission"]/*' />
        public virtual IPermission RemovePermission(Type permClass)
        {
            if (permClass == null)
                return null;
            
            return RemovePermission(PermissionToken.FindToken(permClass));
        }
    
        // Make this internal soon.
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.SetUnrestricted"]/*' />
        internal virtual void SetUnrestricted(bool unrestricted)
        {
            m_Unrestricted = unrestricted;
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IsUnrestricted"]/*' />
        public virtual bool IsUnrestricted()
        {
            return m_Unrestricted;
        }
    
        internal int CanUnrestrictedOverride()
        {
            return (m_normalPermSet == null || m_normalPermSet.IsEmpty()) ? 1 : 0;
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IsSubsetOf"]/*' />
        public virtual bool IsSubsetOf(PermissionSet target)
        {
    #if _DEBUG        
            DEBUG_WRITE("IsSubsetOf\n" +
                        "Other:\n" +
                        (target == null ? "<null>" : target.ToString()) +
                        "\nMe:\n" +
                        ToString());
    #endif
    
            if (target == null || target.IsEmpty())
                return this.IsEmpty();
            else if (this.IsUnrestricted() && !target.IsUnrestricted())
            {
                return false;
            }
            else if (this.m_normalPermSet != null && !this.m_normalPermSet.IsSubsetOf( target.m_normalPermSet ))
            {
                return false;
            }
            else if (target.IsUnrestricted() && !this.ContainsNonCodeAccessPermissions()) 
            {
                return true;
            }
            else
            {
                return this.m_unrestrictedPermSet == null || this.m_unrestrictedPermSet.IsSubsetOf( target.m_unrestrictedPermSet );
            }
        }
    
        internal virtual void InplaceIntersect( PermissionSet other )
        {
            Exception savedException = null;
        
            m_CheckedForNonCas = false;
            m_toBeLoaded = null;
            
            if (other == null || other.IsEmpty())
            {
                // If the other is empty or null, make this empty.
                Reset();
                m_Unrestricted = false;
                return;
            }
            else
            {
                try
                {
                    if (m_normalPermSet != null)
                        this.m_normalPermSet.InplaceIntersect( other.m_normalPermSet );
                }
                catch (Exception e)
                {
                    savedException = e;
                }
                
                if (this.IsEmpty() || (other.IsUnrestricted()))
                {
                    goto END;
                }
                else if (this.IsUnrestricted())
                {
                    this.m_Unrestricted = other.m_Unrestricted;
                    if (other.m_unrestrictedPermSet != null)
                    {
                        // if this is unrestricted, the intersection is exactly other so do a deep copy of it.
                        m_Unrestricted = false;

                        if (this.m_unrestrictedPermSet == null)
                            this.m_unrestrictedPermSet = new TokenBasedSet(other.m_unrestrictedPermSet.GetMaxUsedIndex() + 1, 4);
     
                        // now deep copy all permissions in set
                        for (int i = 0; i <= other.m_unrestrictedPermSet.GetMaxUsedIndex(); i++)
                        {
                            IPermission perm = (IPermission)other.m_unrestrictedPermSet.GetItem(i);
                            if (perm != null)
                            {
                                this.m_unrestrictedPermSet.SetItem(i, perm.Copy());
                            }
                            else
                            {
                                this.m_unrestrictedPermSet.SetItem(i, null);
                            }
                        }
                        for (int i = other.m_unrestrictedPermSet.GetMaxUsedIndex() + 1; i <= this.m_unrestrictedPermSet.GetMaxUsedIndex(); ++i)
                        {
                            this.m_unrestrictedPermSet.SetItem(i, null);
                        }
                    }
                    goto END;
                }
            }
    
            if (this.m_unrestrictedPermSet != null)
                this.m_unrestrictedPermSet.InplaceIntersect( other.m_unrestrictedPermSet );
            
        END:
            if (savedException != null)
                throw savedException;
            
        }
            
            
        
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Intersect"]/*' />
        public virtual PermissionSet Intersect(PermissionSet other)
        {
            PermissionSet pset = null;
            
            // If operand is null or anything is empty, then
            // return null, which is equivalent to (and less
            // memory-consuming than) empty.
            if (other == null || other.IsEmpty() || this.IsEmpty())
            {
                pset = new PermissionSet(false);     // leave empty
            }
            else if (this.IsUnrestricted())                        // If one of the permission sets is fully trusted (universal set),
                                                                   // then the intersection is the other set.
            {                                   
                pset = new PermissionSet(other);

                if (pset.m_normalPermSet != null)
                    pset.m_normalPermSet.InplaceIntersect( this.m_normalPermSet );
            }
            else if (other.IsUnrestricted())
            {
                pset = new PermissionSet(this);

                if (pset.m_normalPermSet != null)
                    pset.m_normalPermSet.InplaceIntersect( other.m_normalPermSet );
            }
            else
            {
                pset = new PermissionSet( null, null );
                if (this.m_unrestrictedPermSet == null)
                    pset.m_unrestrictedPermSet = null;
                else
                    pset.m_unrestrictedPermSet = this.m_unrestrictedPermSet.Intersect( other.m_unrestrictedPermSet );

                if (this.m_normalPermSet == null)
                    pset.m_normalPermSet = null;
                else
                    pset.m_normalPermSet = this.m_normalPermSet.Intersect( other.m_normalPermSet );
            }
            
    #if _DEBUG
            DEBUG_WRITE(pset.ToString());
    #endif
    
            if (pset.IsEmpty())
                return null;
            else
                return pset;
        }
    
        internal virtual void InplaceUnion( PermissionSet other )
        {
            // Unions the "other" PermissionSet into this one.  It can be optimized to do less copies than
            // need be done by the traditional union (and we don't have to create a new PermissionSet).
            
            // Quick out conditions, union doesn't change this PermissionSet
            if (other == null || other.IsEmpty())
                return;
    
            // Save exceptions until the end
            Exception savedException = null;
    
            m_CheckedForNonCas = false;
            m_toBeLoaded = null;
            
            // We have to union "normal" permission no matter what now.
            
            try
            {
                if (this.m_normalPermSet == null)
                    this.m_normalPermSet = other.m_normalPermSet == null ? null : new TokenBasedSet( other.m_normalPermSet );
                else
                    this.m_normalPermSet.InplaceUnion( other.m_normalPermSet );
            }
            catch (Exception e)
            {
                savedException = e;
            }
    
            // If this is unrestricted, we're done.
            if (this.IsUnrestricted() && !this.ContainsNonCodeAccessPermissions())
                goto END;
                
            // Union makes this an unrestricted.
            if (other.IsUnrestricted() && !other.ContainsNonCodeAccessPermissions())
            {
                this.SetUnrestricted( true );
                goto END;
            }
            
            if (this.m_unrestrictedPermSet == null)
                this.m_unrestrictedPermSet = other.m_unrestrictedPermSet == null ? null : new TokenBasedSet( other.m_unrestrictedPermSet );
            else
            this.m_unrestrictedPermSet.InplaceUnion( other.m_unrestrictedPermSet );
            
        END:
            if (savedException != null)
                throw savedException;
        }
                
            
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Union"]/*' />
        public virtual PermissionSet Union(PermissionSet other) {
            PermissionSet pset = null;
            
            // if other is null or empty, return a clone of myself
            if (other == null || other.IsEmpty())
            {
                pset = this.Copy();
            }
            else if ((this.IsUnrestricted() && !this.ContainsNonCodeAccessPermissions()) ||
                     (other.IsUnrestricted() && !other.ContainsNonCodeAccessPermissions()))
            {
                // if either this or other are unrestricted, return an unrestricted set
                pset = new PermissionSet(null, null);
                pset.m_Unrestricted = true;
                pset.m_unrestrictedPermSet = null;

                if (this.m_normalPermSet == null)
                    pset.m_normalPermSet = other.m_normalPermSet == null ? null : new TokenBasedSet( other.m_normalPermSet );
                else
                    pset.m_normalPermSet = this.m_normalPermSet.Union( other.m_normalPermSet );
            }
            else if (this.IsEmpty())
            {
                pset = other.Copy();
            }
            else
            {
                pset = new PermissionSet(null, null);

                if (this.m_unrestrictedPermSet == null)
                    pset.m_unrestrictedPermSet = other.m_unrestrictedPermSet == null ? null : new TokenBasedSet( other.m_unrestrictedPermSet );
                else
                    pset.m_unrestrictedPermSet = this.m_unrestrictedPermSet.Union( other.m_unrestrictedPermSet );

                if (this.m_normalPermSet == null)
                    pset.m_normalPermSet = other.m_normalPermSet == null ? null : new TokenBasedSet( other.m_normalPermSet );
                else
                    pset.m_normalPermSet = this.m_normalPermSet.Union( other.m_normalPermSet );
            }
            
            return pset;
        }

        // Treating the current permission set as a grant set, and the input set as
        // a set of permissions to be denied, try to cancel out as many permissions
        // from both sets as possible. For a first cut, any granted permission that
        // is a safe subset of the corresponding denied permission can result in
        // that permission being removed from both sides.
        
        internal virtual void MergeDeniedSet(PermissionSet denied)
        {
            if (denied.IsEmpty())
            {
                return;
            }
            
            m_CheckedForNonCas = false;
            
            if (!m_Unrestricted)
            {
                if (this.m_unrestrictedPermSet != null)
                this.m_unrestrictedPermSet.MergeDeniedSet( denied.m_unrestrictedPermSet );
            }
            
            if (this.m_normalPermSet != null)
                this.m_normalPermSet.MergeDeniedSet( denied.m_normalPermSet );
    
        }
        
        // Returns true if perm is contained in this
        internal virtual bool Contains(IPermission perm)
        {
            if (perm == null)
                return true;
            
            if (m_Unrestricted && perm is IUnrestrictedPermission)
            {
                return true;
            }
    
            PermissionToken token = PermissionToken.GetToken(perm);
            IPermission p;
            
            if (token.m_isUnrestricted)
            {
                if (m_unrestrictedPermSet == null)
                    return perm.IsSubsetOf( null );

                p = (IPermission)m_unrestrictedPermSet.GetItem( token.m_index );
            }
            else
            {
                if (m_normalPermSet == null)
                    return perm.IsSubsetOf( null );

                p = (IPermission)m_normalPermSet.GetItem( token.m_index );
            }

            return perm.IsSubsetOf(p);
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Demand"]/*' />
        // Mark this method as requiring a security object on the caller's frame
        // so the caller won't be inlined (which would mess up stack crawling).
        [DynamicSecurityMethodAttribute()]
        public virtual void Demand()
        {
            if (this.FastIsEmpty())
                return;  // demanding the empty set always passes.

            ContainsNonCodeAccessPermissions();

            if (m_ContainsCas)
            {
                // Initialize the security engines.
                CodeAccessSecurityEngine icase
                    = SecurityManager.GetCodeAccessSecurityEngine();
    
                if (icase != null)
                {
                    StackCrawlMark stackMark = StackCrawlMark.LookForMyCallersCaller;
                    icase.Check(GetCasOnlySet(), ref stackMark);
                }
            }

            // Check for non-code access permissions.
            if (m_ContainsNonCas)
            {
                if (this.m_normalPermSet != null)
                {
                    for (int i = 0; i <= this.m_normalPermSet.GetMaxUsedIndex(); ++i)
                    {
                        IPermission perm = (IPermission)this.m_normalPermSet.GetItem(i);
                        if ((perm != null) && !(perm is CodeAccessPermission))
                            perm.Demand();
                    }
                }

                if (this.m_unrestrictedPermSet != null)
                {
                    for (int i = 0; i <= this.m_unrestrictedPermSet.GetMaxUsedIndex(); ++i)
                    {
                        IPermission perm = (IPermission)this.m_unrestrictedPermSet.GetItem(i);
                        if ((perm != null) && !(perm is CodeAccessPermission))
                            perm.Demand();
                    }
                }
            }
        }
        
        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Assert"]/*' />
        [DynamicSecurityMethodAttribute()]
        public virtual void Assert() 
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.Assert(this, ref stackMark);
            }
        }
    
        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Deny"]/*' />
        [DynamicSecurityMethodAttribute()]
        public virtual void Deny()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.Deny(this, ref stackMark);
            }
        }
    
        // Metadata for this method should be flaged with REQ_SQ so that
        // EE can allocate space on the stack frame for FrameSecurityDescriptor
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.PermitOnly"]/*' />
        [DynamicSecurityMethodAttribute()]
        public virtual void PermitOnly()
        {
            SecurityRuntime isr = SecurityManager.GetSecurityRuntime();
            if (isr != null)
            {
                StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
                isr.PermitOnly(this, ref stackMark);
            }
        }
        
        // Returns a deep copy
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.Copy"]/*' />
        public virtual PermissionSet Copy()
        {
            return new PermissionSet(this);
        }

        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.GetEnumerator"]/*' />
        public virtual IEnumerator GetEnumerator()
        {
            return new PermissionSetEnumerator(this);
        }

        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.ToString"]/*' />
        public override String ToString()
        {
            return ToXml().ToString();
        }
   
        private void NormalizePermissionSet()
        {
            // This function guarantees that all the permissions are placed at
            // the proper index within the token based sets.  This becomes necessary
            // since these indices are dynamically allocated based on usage order.
        
            PermissionSet permSetTemp = new PermissionSet(false);
            
            permSetTemp.m_Unrestricted = this.m_Unrestricted;

            // Move all the normal permissions to the new permission set

            if (this.m_normalPermSet != null)
            {
                for (int i = 0; i <= this.m_normalPermSet.GetMaxUsedIndex(); ++i)
                {
                    IPermission perm = (IPermission)this.m_normalPermSet.GetItem(i);
                    if (perm != null)
                    {
                        permSetTemp.SetPermission( perm );
                    }
                }
            }

            // Move all the unrestricted permissions to the new permission set
            
            if (this.m_unrestrictedPermSet != null)
            {
                for (int i = 0; i <= this.m_unrestrictedPermSet.GetMaxUsedIndex(); ++i)
                {
                    IPermission perm = (IPermission)this.m_unrestrictedPermSet.GetItem(i);
                    if (perm != null)
                    {
                        permSetTemp.SetPermission( perm );
                    }
                }
            }
    
            // Copy the new permission sets info back to the original set
            
            this.m_normalPermSet = permSetTemp.m_normalPermSet;
            this.m_unrestrictedPermSet = permSetTemp.m_unrestrictedPermSet;
        }
        
        private bool DecodeXml(byte[] data, out int flags )
        {
            if (data != null && data.Length > 0)
            {
                FromXml( new Parser( new BinaryReader( new MemoryStream( data ), Encoding.Unicode ) ).GetTopElement() );
            }

            PermissionSet pSet = new PermissionSet( PermissionState.None );
            pSet.AddPermission( new SecurityPermission( SecurityPermissionFlag.SkipVerification ) );

            if (pSet.IsSubsetOf( this ) && this.IsSubsetOf( pSet ))
                flags = (int)SpecialPermissionSetFlag.SkipVerification;
            else
                flags = (int)SpecialPermissionSetFlag.Regular;

            return true;
        }
            

        private static bool CompareArrays( byte[] first, byte[] second )
        {
            if (first.Length != second.Length)
            {
                //Console.WriteLine( "Lengths not equal" );
                return false;
            }
            
            int count = first.Length;

            bool retval = true;
            for (int i = 0; i < count; ++i)
            {
                if (first[i] != second[i])
                {
                    //Console.WriteLine( "Not equal at " + i + " expected = " + second[i] + " actual = " + first[i] );
                    retval = false;
                    break;
                }
            }
            
            return retval;
        }            
        
        
        private bool DecodeBinary(byte[] data, out int flags )
        {
            s_fullTrust.Assert();

            flags = (int)SpecialPermissionSetFlag.Regular;

            return DecodeUsingSerialization( data );
        }
        
        private bool DecodeUsingSerialization( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryFormatter formatter = new BinaryFormatter();

            PermissionSet ps = null;
            
            Object obj = formatter.Deserialize(ms);
         
            if (obj != null)
            {
                ps = (PermissionSet)obj;
                this.m_Unrestricted = ps.m_Unrestricted;
                this.m_normalPermSet = ps.m_normalPermSet;
                this.m_unrestrictedPermSet = ps.m_unrestrictedPermSet;
                this.m_CheckedForNonCas = false;
                BCLDebug.Trace("SER", ps.ToString());
                return true;
            }
            else
            {
                return false;
            }                            
        }               

        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.FromXml"]/*' />
        public virtual void FromXml( SecurityElement et )
        {
            bool fullyLoaded;
            FromXml( et, false, out fullyLoaded );
        }

        internal bool IsFullyLoaded()
        {
            return m_toBeLoaded == null;
        }

        // Returns true if all permissions are loaded

        internal bool LoadPostponedPermissions()
        {
            if (m_toBeLoaded == null)
                return true;

            int i = 0;

            while (i < m_toBeLoaded.m_lChildren.Count)
            {
                SecurityElement elPerm = (SecurityElement)m_toBeLoaded.m_lChildren[i];
            
                bool assemblyIsLoading;

                IPermission ip = CreatePermissionFromElement( elPerm, false, true, out assemblyIsLoading );

                if (ip == null && assemblyIsLoading)
                {
                    ++i;
                }
                else
                {
                    m_toBeLoaded.m_lChildren.RemoveAt( i );

                    // Set the permission but do not overwrite anything that is
                    // already there.
    
                    if (ip != null)
                    {
                        SetPermission( ip, false );
                    }
                }
            }
    
            if (m_toBeLoaded.m_lChildren.Count == 0)
            {
                m_toBeLoaded = null;
                return true;
            }
            else
            {
                return false;
            }
        }

        internal void AddToPostponedPermissions( SecurityElement elem )
        {
            if (m_toBeLoaded == null)
            {
                m_toBeLoaded = new SecurityElement();
            }

            m_toBeLoaded.AddChild( elem );
        }
            

        internal virtual void FromXml( SecurityElement et, bool policyLoad, out bool fullyLoaded )
        {
            if (et == null)
                throw new ArgumentNullException("et");
            
            if (!et.Tag.Equals(s_str_PermissionSet))
                throw new ArgumentException(String.Format( Environment.GetResourceString( "Argument_InvalidXMLElement" ), "PermissionSet", this.GetType().FullName) );
            
            SetUnrestricted(false);
            m_CheckedForNonCas = false;
           
            Exception savedException = null;
           
            fullyLoaded = true;

            m_Unrestricted = XMLUtil.IsUnrestricted( et );

            ArrayList postponedPermissions = new ArrayList();

            if (et.m_lChildren != null)
            {
                int i = 0;
                int childCount = et.m_lChildren.Count;
                
                while (i < childCount)
                {
                    SecurityElement elem = (SecurityElement)et.m_lChildren[i];
                
                    if (elem.Tag.Equals( s_str_Permission ) || elem.Tag.Equals( s_str_IPermission ))
                    {
                        try
                        {
                            IPermission ip = CreatePermissionFromElement (elem, true) ;
                            if (ip == null)
                            {
                                // This means that the permission is from an assembly that isn't loaded yet.
                                // Remove it from the element tree and save it for the second creation stage.

                                // Note: this code operates much in the same fashion at the code in CodeGroup.ParseChildren()

                                et.m_lChildren.RemoveAt( i );

                                childCount = et.m_lChildren.Count;

                                postponedPermissions.Add( new PermissionPositionMarker( i, elem ) );
                            }
                            else
                            {
                                AddPermission(ip);
                                ++i;
                            }
                        }
                        catch (Exception e)
                        {
    #if _DEBUG
                            DEBUG_WRITE( "error while decoding permission set =\n" + e.ToString() );
    #endif
                            if (savedException == null)
                                savedException = e;

                            ++i;
                        }
                    }
                    else
                    {
                        ++i;
                    }
                }

                if (postponedPermissions.Count > 0)
                {
                    bool assemblyIsLoading;

                    IEnumerator enumerator = postponedPermissions.GetEnumerator();

                    while (enumerator.MoveNext())
                    {
                        PermissionPositionMarker position = (PermissionPositionMarker)enumerator.Current;

                        IPermission ip = CreatePermissionFromElement( position.element, false, policyLoad, out assemblyIsLoading );

                        et.m_lChildren.Insert( position.index, position.element );

                        if (ip == null)
                        {
                            if (policyLoad && assemblyIsLoading)
                            {
                                AddToPostponedPermissions( position.element );
                                fullyLoaded = false;
                            }
                            else if (savedException == null)
                            {                            
                                String className = position.element.Attribute( "class" );
                    
                                if (className != null)
                                    savedException = new ArgumentException( String.Format( Environment.GetResourceString( "Argument_UnableToCreatePermission" ), className ) );
                                else
                                    savedException = new ArgumentException( Environment.GetResourceString( "Argument_UnableToCreatePermissionNoClass" ) );
                            }
                        }
                        else
                        {

                            AddPermission( ip );
                        }
                    }
                }
                        
            }
            
            if (savedException != null)
                throw savedException;
                
        }
         
        private IPermission
        CreatePermissionFromElement( SecurityElement el, bool safeLoad )
        {
            bool assemblyIsLoading;

            return CreatePermissionFromElement( el, safeLoad, false, out assemblyIsLoading );
        }

        private IPermission
        CreatePermissionFromElement( SecurityElement el, bool safeLoad, bool policyLoad, out bool assemblyIsLoading )
        {
    #if _DEBUG
            DEBUG_WRITE( "ip element = " + el.ToString() );
    #endif            
        
            IPermission ip = XMLUtil.CreatePermission( el, safeLoad, policyLoad, out assemblyIsLoading );

    #if _DEBUG
            DEBUG_WRITE( "ip after create = " + (ip == null ? "<null>" : ip.ToString()) );
    #endif

            if (ip == null)
                return null ;
            
            ip.FromXml( el );

    #if _DEBUG
            DEBUG_WRITE( "ip after decode = " + (ip == null ? "<null>" : ip.ToString()) );
    #endif
            
            return ip;            
        }
    
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.ToXml"]/*' />
        public virtual SecurityElement ToXml()
        {
            SecurityElement elTrunk = new SecurityElement("PermissionSet");
            elTrunk.AddAttribute( "class", this.GetType().FullName);
            elTrunk.AddAttribute( "version", "1" );
        
            IPermission          ipTemp;
            IEnumerator           ieTemp;
    
            if (m_Unrestricted)
            {
                elTrunk.AddAttribute(s_str_Unrestricted, "true" );
                ieTemp = (IEnumerator) new TokenBasedSetEnumerator( this.m_normalPermSet );
            }
            else
            {
                ieTemp = GetEnumerator();
            }
    
            while (ieTemp.MoveNext())
            {
                ipTemp = (IPermission) ieTemp.Current;

                elTrunk.AddChild( ipTemp.ToXml() );
            }
            return elTrunk ;
        }
    
        // Encode up the default binary representation of a permission set
        internal virtual byte[] DefaultBinaryEncoding()
        {
            // Currently the default encoding is binary.
            return EncodeXml();
        }
    
        internal 
        virtual byte[] EncodeBinary()
        {
            BCLDebug.Assert( false, "EncodeBinary should never be called" );
            s_fullTrust.Assert();
            return EncodeUsingSerialization();
        }

        internal byte[] EncodeUsingSerialization()
        {
            MemoryStream ms = new MemoryStream();
            new BinaryFormatter().Serialize( ms, this );
            return ms.ToArray();
        }

        internal
        virtual byte[] EncodeXml()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter writer = new BinaryWriter( ms, Encoding.Unicode );
            writer.Write( this.ToXml().ToString() );
            writer.Flush();

            // The BinaryWriter is going to place
            // two bytes indicating a Unicode stream.
            // We want to chop those off before returning
            // the bytes out.

            ms.Position = 2;
            int countBytes = (int)ms.Length - 2;
            byte[] retval = new byte[countBytes];
            ms.Read( retval, 0, retval.Length );
            return retval;
        }
        
        internal static PermissionSet
        DecodeFromASCIIFile (String fileName,
                             String format)
        {
            if (fileName == null)
                return null ;
    
            PermissionSet permSet = new PermissionSet (false) ;
            
            try {
                FileStream fs = new FileStream (fileName, 
                                            FileMode.Open, 
                                            FileAccess.Read) ;
    #if _DEBUG
                DEBUG_WRITE("DecodeFromASCIIFile: Format = " + format + " File = " + fileName);
    #endif
                if (format == null || format.Equals( "XMLASCII" ))
                {
                    permSet.FromXml( new Parser( new BinaryReader( fs, Encoding.ASCII ) ).GetTopElement() );
                }
                else if (format.Equals( "XMLUNICODE" ))
                {
                    permSet.FromXml( new Parser( new BinaryReader( fs ) ).GetTopElement() );
                }
                else
                {
                    return null;
                }
            }
            catch (Exception)
            {
            }
   
            return null;
        }
        
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.ConvertPermissionSet"]/*' />
        /// <internalonly/>
        static public byte[]
        ConvertPermissionSet(String inFormat,
                             byte[] inData,
                             String outFormat)
        {
        
            // This used to be pretty easy to support when we had Encode/Decode
            // Now that we don't it's really junky, but workable for V1.
        
            if(inData == null) 
                return null;
            if(inFormat == null)
                throw new ArgumentNullException("inFormat");
            if(outFormat == null)
                throw new ArgumentNullException("outFormat");
    
            PermissionSet permSet = new PermissionSet( false );
    
            inFormat = String.SmallCharToUpper(inFormat);
            outFormat = String.SmallCharToUpper(outFormat);

            if (inFormat.Equals( "XMLASCII" ) || inFormat.Equals( "XML" ))
            {
                permSet.FromXml( new Parser( inData ).GetTopElement() );
            }
            else if (inFormat.Equals( "XMLUNICODE" ))
            {
                permSet.FromXml( new Parser( new BinaryReader( new MemoryStream( inData ) ) ).GetTopElement() );
            }
            else if (inFormat.Equals( "BINARY" ))
            {
                permSet.DecodeUsingSerialization( inData );
            }
            else
            {
                return null;
            }
            
            if (outFormat.Equals( "XMLASCII" ) ||  inFormat.Equals( "XML" ))
            {
                MemoryStream ms = new MemoryStream();
                StreamWriter writer = new StreamWriter( ms, Encoding.ASCII );
                writer.Write( permSet.ToXml().ToString() );
                writer.Flush();
                return ms.ToArray();
            }
            else if (outFormat.Equals( "XMLUNICODE" ))
            {
                MemoryStream ms = new MemoryStream();
                StreamWriter writer = new StreamWriter( ms, Encoding.Unicode );
                writer.Write( permSet.ToXml().ToString() );
                writer.Flush();

                ms.Position = 2;
                int countBytes = (int)ms.Length - 2;
                byte[] retval = new byte[countBytes];
                ms.Read( retval, 0, retval.Length );
                return retval;
            }
            else if (outFormat.Equals( "BINARY" ))
            {
                return permSet.EncodeUsingSerialization();
            }
            else
            {
                return null;
            }
        }
        
        
        // Internal routine. Called by native to create a binary encoding
        // from a PermissionSet decoded with an the format.
        // Encodes requested CodeAccessPermissions, omitting
        // CodeIdentityPermissions if found.
        private static byte[] EncodeBinaryFromASCIIFile(String fileName,
                                                String format)
        {
            if (fileName[0] == '-')
            {
                int sep = fileName.IndexOf(':');
                if (sep != -1)
                {
                    format = fileName.Substring(1, sep-1);
                    if(format != null) {
                        format = String.SmallCharToUpper(format);
                    }                    
                    fileName = fileName.Substring(sep+1);
                }
            }
            
            PermissionSet permSet = DecodeFromASCIIFile(fileName,
                                                        format);
    #if _DEBUG
            DEBUG_WRITE("EncodeBinaryFromASCIIFile\n" + permSet + "\n\n");
    #endif
            if (permSet == null)
                return null;
            else
                return permSet.EncodeXml();
        }
        
        
        private const String s_sPermSpecTag = "PermissionSpecification";
        private const String s_sCapRefTag   = "CapabilityRef";
    
        private static PermissionSet GetPermsFromSpecTree(SecurityElement et)
        {
            BCLDebug.Assert(et != null, "et != null");
            
            SecurityElement el, ec;
            
            if (et.Tag.Equals(s_sPermSpecTag) && et.Children != null)
                ec = (SecurityElement)et.Children[0];
            else if (et.Tag.Equals(s_str_PermissionSet))
                ec = et;
            else
                return null;
            
            if (ec == null)
                return null;

            // All of the next bit is a hack to support capability xml until we're
            // sure the compilers don't use it anymore.
            
            if (ec.Tag.Equals( s_sCapRefTag ))
                el = ec;
            else
                el = ec.SearchForChildByTag(s_sCapRefTag);
                
            if (el != null)
            {
            
                SecurityElement eGUID = el.SearchForChildByTag("GUID");
            
                if (eGUID != null)
                {
                    if (eGUID.Text.Equals("{9653abdf-7db7-11d2-b2eb-00a0c9b4694e}"))
                    {
                        return new PermissionSet( false );
                    }
                    else if (eGUID.Text.Equals("{9653abde-7db7-11d2-b2eb-00a0c9b4694e}"))
                    {
                        return new PermissionSet( true );
                    }
                    else
                    {
                        return new PermissionSet( false );
                    }
                }
                
                return new PermissionSet( false );
            }
            
            if (ec.Tag.Equals( s_str_PermissionSet ))
                el = ec;
            else
                el = ec.SearchForChildByTag(s_str_PermissionSet);
                
            if (el != null)
            {
                PermissionSet permSet = new PermissionSet(false);
                permSet.FromXml(el);
                return permSet;
            }
    
            return null;
        }
      
        // Internal routine. Called by native to create a binary encoding
        // from a PermissionSet decoded from a byte array with a format
        internal static byte[] EncodePermissionSpecification(byte[] unicodeXml)
        {
            if (unicodeXml == null) 
                return null;
            
            PermissionSet permSet;
    
            try {
    
                permSet = GetPermsFromSpecTree(XMLUtil.GetElementFromUnicodeByteArray(unicodeXml));

                if (permSet == null)
                    return null;
    
                if (permSet.IsEmpty())
                    return new byte[0];
    
            } catch (Exception e) {
                BCLDebug.Assert(false, "PermissionSet::EncodePermissionSpecification - Someone threw an Exception!\n"+e.ToString());
                return null;
            }
    
            return permSet.IsEmpty() ? null : permSet.EncodeXml();
        }

        // Determines whether the permission set contains any non-code access
        // security permissions.
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.ContainsNonCodeAccessPermissions"]/*' />
        public bool ContainsNonCodeAccessPermissions()
        {
            if (m_CheckedForNonCas)
                return m_ContainsNonCas;

            lock (this)
            {
                m_ContainsCas = false;
                m_ContainsNonCas = false;

                if (this.m_normalPermSet != null)
                {
                    for (int i = 0; i <= this.m_normalPermSet.GetMaxUsedIndex(); ++i)
                    {
                        IPermission perm = (IPermission)this.m_normalPermSet.GetItem(i);
                        if (perm != null)
                        {
                            if (perm is CodeAccessPermission)
                                m_ContainsCas = true;
                            else
                                m_ContainsNonCas = true;
                        }
                    }
                }

                if (IsUnrestricted())
                    m_ContainsCas = true;

                if (this.m_unrestrictedPermSet != null)
                {
                    for (int i = 0; i <= this.m_unrestrictedPermSet.GetMaxUsedIndex(); ++i)
                    {
                        IPermission perm = (IPermission)this.m_unrestrictedPermSet.GetItem(i);
                        if (perm != null)
                        {
                            if (perm is CodeAccessPermission)
                                m_ContainsCas = true;
                            else
                                m_ContainsNonCas = true;
                        }
                    }
                }

                m_CheckedForNonCas = true;
            }

            return m_ContainsNonCas;
        }
        
        // Returns a permission set containing only CAS-permissions. If possible
        // this is just the input set, otherwise a new set is allocated.
        private PermissionSet GetCasOnlySet()
        {
            if (!m_ContainsNonCas)
                return this;

            // This is a hack that relies on the fact that we know the CAS
            // engine won't look for individual permissions if the permission
            // set is marked unrestricted.
            if (IsUnrestricted())
                return this;

            PermissionSet pset = new PermissionSet(false);

            if (this.m_normalPermSet != null)
                for (int i = 0; i <= this.m_normalPermSet.GetMaxUsedIndex(); ++i)
                {
                    IPermission perm = (IPermission)this.m_normalPermSet.GetItem(i);
                    if ((perm != null) && (perm is CodeAccessPermission))
                        pset.AddPermission(perm);
                }

            if (this.m_unrestrictedPermSet != null)
                for (int i = 0; i <= this.m_unrestrictedPermSet.GetMaxUsedIndex(); ++i)
                {
                    IPermission perm = (IPermission)this.m_unrestrictedPermSet.GetItem(i);
                    if ((perm != null) && (perm is CodeAccessPermission))
                        pset.AddPermission(perm);
                }

            pset.m_CheckedForNonCas = true;
            pset.m_ContainsCas = !pset.IsEmpty();
            pset.m_ContainsNonCas = false;

            return pset;
        }

        // Called by native to create a safe binary encoding given an action
        internal static byte[] GetSafePermissionSet(int action)
        {
            PermissionSet permSet;
        
            switch (action)
            {
            case (int)System.Security.Permissions.SecurityAction.Demand:
            case (int)System.Security.Permissions.SecurityAction.Deny:
            case (int)System.Security.Permissions.SecurityAction.LinkDemand:
            case (int)System.Security.Permissions.SecurityAction.InheritanceDemand:
            case (int)System.Security.Permissions.SecurityAction.RequestOptional:
                permSet = new PermissionSet(true);
                break;
    
            case (int)System.Security.Permissions.SecurityAction.PermitOnly:
            case (int)System.Security.Permissions.SecurityAction.Assert:
            case (int)System.Security.Permissions.SecurityAction.RequestMinimum:
            case (int)System.Security.Permissions.SecurityAction.RequestRefuse:
                permSet = new PermissionSet(false);
                break;
    
            default :
                BCLDebug.Assert(false, "false");
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidFlag"));
            }
            
            return permSet.EncodeXml();
        }
        
        /*
         * Internal routine. Called by native to create a String containing
         * all the permission names. This is used to display the names of the 
         * permissions on the authenticode certificate.
         * 
         * Note: this routine depends on permissions encoding display text using
         * unicode!
         *
         */
        private String 
        GetDisplayTextW () 
        {
            StringBuilder sb = new StringBuilder();

            if (IsUnrestricted())
            {
                sb.Append(s_str_Unrestricted + "\n");
            } 
            
            if (this.Count == 0)
            {
                sb.Append("Empty");
            }
            else
            {
                IEnumerator iter = GetEnumerator();
                while(iter.MoveNext())
                {
                    IPermission ip = (IPermission) iter.Current;
                    if (ip != null)
                    {
                        sb.Append(ip.GetType().FullName + "\n");
                    }
                }
            }

            return sb.ToString();
        }

        private const String s_str_PermissionSet = "PermissionSet";
        private const String s_str_Permission    = "Permission";
        private const String s_str_IPermission    = "IPermission";
        private const String s_str_Unrestricted  = "Unrestricted";

        private static String GetGacLocation()
        {
            Microsoft.Win32.RegistryKey rLocal = Microsoft.Win32.Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\Fusion");
            if (rLocal != null)
            {
                Object oTemp = rLocal.GetValue("CacheLocation");
                if (oTemp != null && oTemp is string)
                    return (String) oTemp;
            }
            String sWinDir = System.Environment.GetEnvironmentVariable("windir");
            if (sWinDir == null || sWinDir.Length < 1)
                throw new ArgumentException( Environment.GetResourceString( "Argument_UnableToGeneratePermissionSet" ) );
            if (!sWinDir.EndsWith("\\"))
                sWinDir += "\\";
            return sWinDir + "assembly";
        }

        // Internal routine used to setup a special security context
        // for creating and manipulated security custom attributes
        // that we use when the Runtime is hosted.

        private static void SetupSecurity()
        {
            PolicyLevel level = PolicyLevel.CreateAppDomainLevel();

            CodeGroup rootGroup = new UnionCodeGroup( new AllMembershipCondition(), level.GetNamedPermissionSet( "Execution" ) );

            StrongNamePublicKeyBlob microsoftBlob = new StrongNamePublicKeyBlob( PolicyLevelData.s_microsoftPublicKey );
            CodeGroup microsoftGroup = new UnionCodeGroup( new StrongNameMembershipCondition( microsoftBlob, null, null ), level.GetNamedPermissionSet( "FullTrust" ) );

            StrongNamePublicKeyBlob ecmaBlob = new StrongNamePublicKeyBlob( PolicyLevelData.s_ecmaPublicKey );
            CodeGroup ecmaGroup = new UnionCodeGroup( new StrongNameMembershipCondition( ecmaBlob, null, null ), level.GetNamedPermissionSet( "FullTrust" ) );

            CodeGroup gacGroup = new UnionCodeGroup( new UrlMembershipCondition( "file:\\\\" + GetGacLocation() + "\\*"), level.GetNamedPermissionSet( "FullTrust" ) );

            rootGroup.AddChild( microsoftGroup );
            rootGroup.AddChild( ecmaGroup );
            rootGroup.AddChild( gacGroup );

            level.RootCodeGroup = rootGroup;

            try
            {
                AppDomain.CurrentDomain.SetAppDomainPolicy( level );
            }
            catch (PolicyException)
            {
            }
        }

        // Internal routine used to create a temporary permission set (given a
        // set of security attribute classes as input) and return the serialized
        // version. May actually return two sets, split into CAS and non-CAS
        // variants.
        private static byte[] CreateSerialized(Object[] attrs, ref byte[] nonCasBlob)
        {
            // Create two new (empty) sets.
            PermissionSet casPset = new PermissionSet(false);
            PermissionSet nonCasPset = new PermissionSet(false);
    
            // Most security attributes generate a single permission. The
            // PermissionSetAttribute class generates an entire permission set we
            // need to merge, however.
            for (int i = 0; i < attrs.Length; i++)
                if (attrs[i] is PermissionSetAttribute)
                {
                    PermissionSet pset = null;

                    pset = ((PermissionSetAttribute)attrs[i]).CreatePermissionSet();

                    if (pset == null)
                    {
                        throw new ArgumentException( Environment.GetResourceString( "Argument_UnableToGeneratePermissionSet" ) );
                    }

                    if (pset.m_normalPermSet != null)
                    {
                        for (int j = 0; j <= pset.m_normalPermSet.GetMaxUsedIndex(); ++j)
                        {
                            IPermission perm = (IPermission)pset.m_normalPermSet.GetItem(j);
                            if (perm != null)
                            {
                                if (perm is CodeAccessPermission)
                                    casPset.AddPermission(perm);
                                else
                                    nonCasPset.AddPermission(perm);
                            }
                        }
                    }

                    if (pset.IsUnrestricted())
                        casPset.SetUnrestricted(true);

                    if (pset.m_unrestrictedPermSet != null)
                    {
                        for (int j = 0; j <= pset.m_unrestrictedPermSet.GetMaxUsedIndex(); ++j)
                        {
                            IPermission perm = (IPermission)pset.m_unrestrictedPermSet.GetItem(j);
                            if (perm != null)
                            {
                                if (perm is CodeAccessPermission)
                                {
                                    IPermission oldPerm = casPset.GetPermission( perm.GetType() );
                                    IPermission unionPerm = casPset.AddPermission(perm);
                                    if (oldPerm != null && !oldPerm.IsSubsetOf( unionPerm ))
                                        throw new NotSupportedException( Environment.GetResourceString( "NotSupported_DeclarativeUnion" ) );
                                }
                                else
                                {
                                    IPermission oldPerm = nonCasPset.GetPermission( perm.GetType() );
                                    IPermission unionPerm = nonCasPset.AddPermission( perm );
                                    if (oldPerm != null && !oldPerm.IsSubsetOf( unionPerm ))
                                        throw new NotSupportedException( Environment.GetResourceString( "NotSupported_DeclarativeUnion" ) );
                                }
                            }
                        }
                    }

                }
                else
                {
                    IPermission perm = ((SecurityAttribute)attrs[i]).CreatePermission();
                    if (perm != null)
                    {
                        if (perm is CodeAccessPermission)
                        {
                            IPermission oldPerm = casPset.GetPermission( perm.GetType() );
                            IPermission unionPerm = casPset.AddPermission(perm);
                            if (oldPerm != null && !oldPerm.IsSubsetOf( unionPerm ))
                                throw new NotSupportedException( Environment.GetResourceString( "NotSupported_DeclarativeUnion" ) );
                        }
                        else
                        {
                            IPermission oldPerm = nonCasPset.GetPermission( perm.GetType() );
                            IPermission unionPerm = nonCasPset.AddPermission( perm );
                            if (oldPerm != null && !oldPerm.IsSubsetOf( unionPerm ))
                                throw new NotSupportedException( Environment.GetResourceString( "NotSupported_DeclarativeUnion" ) );
                        }
                    }
                }

            // Serialize the set(s).
            if (!nonCasPset.IsEmpty())
                nonCasBlob = nonCasPset.EncodeXml();
            return casPset.EncodeXml();
        }
        
        /// <include file='doc\PermissionSet.uex' path='docs/doc[@for="PermissionSet.IDeserializationCallback.OnDeserialization"]/*' />
        /// <internalonly/>
        void IDeserializationCallback.OnDeserialization(Object sender)        
        {
            NormalizePermissionSet();
            m_CheckedForNonCas = false;
        }        
    }

    internal class PermissionPositionMarker
    {
        internal int index;
        internal SecurityElement element;

        internal PermissionPositionMarker( int index, SecurityElement element )
        {
            this.index = index;
            this.element = element;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\securityzone.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  SecurityZone.cool
//
//  Enumeration of the zones code can come from
//

namespace System.Security {
	using System;
    /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone"]/*' />
	[Serializable]
    public enum SecurityZone
    {
        // Note: this information is referenced in $/Com99/src/vm/security.cpp
        // in ApplicationSecurityDescriptor.GetEvidence().
    
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.MyComputer"]/*' />
        MyComputer = 0,
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.Intranet"]/*' />
        Intranet     = 1,
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.Trusted"]/*' />
        Trusted      = 2,
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.Internet"]/*' />
        Internet     = 3,
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.Untrusted"]/*' />
        Untrusted    = 4,
    
        /// <include file='doc\SecurityZone.uex' path='docs/doc[@for="SecurityZone.NoZone"]/*' />
        NoZone       = -1,  // No Zone Information
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\verificationexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
 *
 * Class: VerificationException
 *
 * Purpose: The exception class for verification failures.
 *
 * @author  Shajan Dasan
 *
 ****************************************************************************/

namespace System.Security {
	using System.Security;
	using System;
	using System.Runtime.Serialization;
    /// <include file='doc\VerificationException.uex' path='docs/doc[@for="VerificationException"]/*' />
    [Serializable] public class VerificationException : SystemException {
        /// <include file='doc\VerificationException.uex' path='docs/doc[@for="VerificationException.VerificationException"]/*' />
        public VerificationException() 
            : base(Environment.GetResourceString("Verification_Exception")) {
    		SetErrorCode(__HResults.COR_E_VERIFICATION);
        }
    
        /// <include file='doc\VerificationException.uex' path='docs/doc[@for="VerificationException.VerificationException1"]/*' />
        public VerificationException(String message) 
            : base(message) {
    		SetErrorCode(__HResults.COR_E_VERIFICATION);
        }
    	
        /// <include file='doc\VerificationException.uex' path='docs/doc[@for="VerificationException.VerificationException2"]/*' />
        public VerificationException(String message, Exception innerException) 
            : base(message, innerException) {
    		SetErrorCode(__HResults.COR_E_VERIFICATION);
        }
        
        /// <include file='doc\VerificationException.uex' path='docs/doc[@for="VerificationException.VerificationException3"]/*' />
        protected VerificationException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\xmlsyntaxexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** CLASS:    Tokenizer.cool
**
** AUTHOR:   Brian Beckman (brianbec)
**
** PURPOSE:  Provide Syntax-error exceptions to callers
**           of XML parser. 
** 
** DATE:     25 Jun 1998
** 
===========================================================*/
namespace System.Security {
    
    
	using System;
    using System.Runtime.Serialization;

    /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException"]/*' />
    [Serializable] sealed public class XmlSyntaxException : SystemException
    {
        /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException.XmlSyntaxException"]/*' />
        public
        XmlSyntaxException ()
            : base (Environment.GetResourceString( "XMLSyntax_InvalidSyntax" ))
        {
    		SetErrorCode(__HResults.CORSEC_E_XMLSYNTAX);
        }
    
        /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException.XmlSyntaxException1"]/*' />
        public
        XmlSyntaxException (String message)
            : base (message)
        {
    		SetErrorCode(__HResults.CORSEC_E_XMLSYNTAX);
        }
    
        /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException.XmlSyntaxException2"]/*' />
        public
        XmlSyntaxException (String message, Exception inner)
            : base (message, inner)
        {
    		SetErrorCode(__HResults.CORSEC_E_XMLSYNTAX);
        }
    
        /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException.XmlSyntaxException3"]/*' />
        public
        XmlSyntaxException (int lineNumber)
            : base (String.Format( Environment.GetResourceString( "XMLSyntax_SyntaxError" ), lineNumber ) )
        {
    		SetErrorCode(__HResults.CORSEC_E_XMLSYNTAX);
        }
        
        /// <include file='doc\XMLSyntaxException.uex' path='docs/doc[@for="XmlSyntaxException.XmlSyntaxException4"]/*' />
        public
        XmlSyntaxException( int lineNumber, String message )
            : base( String.Format( Environment.GetResourceString( "XMLSyntax_SyntaxErrorEx" ), lineNumber, message ) )
        {
    		SetErrorCode(__HResults.CORSEC_E_XMLSYNTAX);
        }

        internal XmlSyntaxException(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\asymmetricalgorithm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// AsymmetricAlgorithm.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System;
    /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm"]/*' />
    public abstract class AsymmetricAlgorithm : IDisposable {
        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.KeySizeValue"]/*' />
        protected int           KeySizeValue;
        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.LegalKeySizesValue"]/*' />
        protected KeySizes[]    LegalKeySizesValue;

        // *********************** CONSTRUCTORS *************************

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.AsymmetricAlgorithm"]/*' />
        protected AsymmetricAlgorithm() {
        }

        // AsymmetricAlgorithm implements IDisposable

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.Dispose"]/*' />
        protected abstract void Dispose(bool disposing);
    
        /************************* Property Methods **********************/
    
        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.KeySize"]/*' />
        public virtual int KeySize {
            get { return KeySizeValue; }
            set {
                int   i;
                int   j;

                for (i=0; i<LegalKeySizesValue.Length; i++) {
                    if (LegalKeySizesValue[i].SkipSize == 0) {
                        if (LegalKeySizesValue[i].MinSize == value) { // assume MinSize = MaxSize
                            KeySizeValue = value;
                            return;
                        }
                    } else {
                        for (j = LegalKeySizesValue[i].MinSize; j<=LegalKeySizesValue[i].MaxSize;
                             j += LegalKeySizesValue[i].SkipSize) {
                            if (j == value) {
                                KeySizeValue = value;
                                return;
                            }
                        }
                    }
                }
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
            }
        }
        
        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.LegalKeySizes"]/*' />
        public virtual KeySizes[] LegalKeySizes { 
            get { return (KeySizes[]) LegalKeySizesValue.Clone(); }
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.SignatureAlgorithm"]/*' />
        public abstract String SignatureAlgorithm {
            get;
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.KeyExchangeAlgorithm"]/*' />
        public abstract String KeyExchangeAlgorithm {
            get;
        }
        
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.Create"]/*' />
        static public AsymmetricAlgorithm Create() {
            // Use the crypto config system to return an instance of
            // the default AsymmetricAlgorithm on this machine
            return Create("System.Security.Cryptography.AsymmetricAlgorithm");
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.Create1"]/*' />
        static public AsymmetricAlgorithm Create(String algName) {
            return (AsymmetricAlgorithm) CryptoConfig.CreateFromName(algName);
        }

        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.FromXmlString"]/*' />
        public abstract void FromXmlString(String xmlString);
        /// <include file='doc\AsymmetricAlgorithm.uex' path='docs/doc[@for="AsymmetricAlgorithm.ToXmlString"]/*' />
        public abstract String ToXmlString(bool includePrivateParameters);

        // ** Internal Utility Functions ** //

        internal static String DiscardWhiteSpaces(String inputBuffer) {
            return DiscardWhiteSpaces(inputBuffer, 0, inputBuffer.Length);
        }

        internal static String DiscardWhiteSpaces(String inputBuffer, int inputOffset, int inputCount) {
            int i, iCount = 0;
            for (i=0; i<inputCount; i++)
                if (Char.IsWhiteSpace(inputBuffer[inputOffset + i])) iCount++;
            char[] rgbOut = new char[inputCount - iCount];
            iCount = 0;
            for (i=0; i<inputCount; i++)
                if (!Char.IsWhiteSpace(inputBuffer[inputOffset + i])) {
                    rgbOut[iCount++] = inputBuffer[inputOffset + i];
                }
            return new String(rgbOut);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\asymmetrickeyexchangedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// AsymmetricKeyExchangeDeformatter.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System;

    /// <include file='doc\AsymmetricKeyExchangeDeformatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeDeformatter"]/*' />
    public abstract class AsymmetricKeyExchangeDeformatter {
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\AsymmetricKeyExchangeDeformatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeDeformatter.AsymmetricKeyExchangeDeformatter"]/*' />
        public AsymmetricKeyExchangeDeformatter() {
        }
    
        /*************************** Properties **************************/

        /// <include file='doc\AsymmetricKeyExchangeDeformatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeDeformatter.Parameters"]/*' />
        public abstract String Parameters {
            get;
            set;
        }

        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\AsymmetricKeyExchangeDeformatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeDeformatter.SetKey"]/*' />
        abstract public void SetKey(AsymmetricAlgorithm key);
        /// <include file='doc\AsymmetricKeyExchangeDeformatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeDeformatter.DecryptKeyExchange"]/*' />
        abstract public byte[] DecryptKeyExchange(byte[] rgb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\asymmetrickeyexchangeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// AsymmetricKeyExchangeFormatter.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System;

    /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter"]/*' />
    public abstract class AsymmetricKeyExchangeFormatter {
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter.AsymmetricKeyExchangeFormatter"]/*' />
        public AsymmetricKeyExchangeFormatter() {
        }

        /************************* Properties ****************************/

        /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter.Parameters"]/*' />
        public abstract String Parameters {
            get;
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter.SetKey"]/*' />
        abstract public void SetKey(AsymmetricAlgorithm key);
        /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter.CreateKeyExchange"]/*' />
        abstract public byte[] CreateKeyExchange(byte[] data);
        /// <include file='doc\AsymmetricKeyExchangeFormatter.uex' path='docs/doc[@for="AsymmetricKeyExchangeFormatter.CreateKeyExchange1"]/*' />
        abstract public byte[] CreateKeyExchange(byte[] data, Type symAlgType);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\base64transforms.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * Base64Transform.cs
 *
 * Author: bal
 *
 */

// This file contains two ICryptoTransforms: ToBase64Transform and FromBase64Transform
// they may be attached to a CryptoStream in either read or write mode

namespace System.Security.Cryptography {
    using System;
    using System.IO;
    using System.Text;

    /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64TransformMode"]/*' />
    [Serializable]
    public enum FromBase64TransformMode {
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64TransformMode.IgnoreWhiteSpaces"]/*' />
        IgnoreWhiteSpaces = 0,
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64TransformMode.DoNotIgnoreWhiteSpaces"]/*' />
        DoNotIgnoreWhiteSpaces = 1,
    }

    /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform"]/*' />
    public class ToBase64Transform : ICryptoTransform {

        private ASCIIEncoding asciiEncoding = new ASCIIEncoding();

        // converting to Base64 takes 3 bytes input and generates 4 bytes output
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.InputBlockSize"]/*' />
        public int InputBlockSize {
            get { return(3); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.OutputBlockSize"]/*' />
        public int OutputBlockSize {
            get { return(4); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.CanTransformMultipleBlocks"]/*' />
        public bool CanTransformMultipleBlocks {
            get { return(false); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.CanReuseTransform"]/*' />
        public virtual bool CanReuseTransform { 
            get { return(true); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.TransformBlock"]/*' />
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) {
            if (asciiEncoding == null)
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Do some validation, we let InternalBlockCopy do the destination array validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            // for now, only convert 3 bytes to 4
            char[] temp = new char[4];
            Convert.ToBase64CharArray(inputBuffer, inputOffset, 3, temp, 0);
            byte[] tempBytes = asciiEncoding.GetBytes(temp);
            if (tempBytes.Length != 4) throw new CryptographicException(Environment.GetResourceString( "Cryptography_SSE_InvalidDataSize" ));
            Buffer.InternalBlockCopy(tempBytes, 0, outputBuffer, outputOffset, tempBytes.Length);
            return(tempBytes.Length);
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.TransformFinalBlock"]/*' />
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) { 
            if (asciiEncoding == null)
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Do some validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            // Convert.ToBase64CharArray already does padding, so all we have to check is that
            // the inputCount wasn't 0

            // again, for now only a block at a time
            if (inputCount == 0) {
                return(new byte[0]);
            } else {
                char[] temp = new char[4];
                Convert.ToBase64CharArray(inputBuffer, inputOffset, inputCount, temp, 0);
                byte[] tempBytes = asciiEncoding.GetBytes(temp);
                return(tempBytes);
            }
        }

        // must implement IDisposable, but in this case there's nothing to do.

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="ToBase64Transform.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                asciiEncoding = null;
            }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.Finalize"]/*' />
        ~ToBase64Transform() {
            Dispose(false);
        }
    }


    /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform"]/*' />
    public class FromBase64Transform : ICryptoTransform {
        private byte[] _inputBuffer = new byte[4];
        private int    _inputIndex;
        
        private FromBase64TransformMode _whitespaces;

        // Constructors
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.FromBase64Transform"]/*' />
        public FromBase64Transform() : this(FromBase64TransformMode.IgnoreWhiteSpaces) {}
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.FromBase64Transform1"]/*' />
        public FromBase64Transform(FromBase64TransformMode whitespaces) {
            _whitespaces = whitespaces;
            _inputIndex = 0;
        }
        
        // converting from Base64 generates 3 bytes output from each 4 bytes input block
        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.InputBlockSize"]/*' />
        public int InputBlockSize {
            get { return(1); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.OutputBlockSize"]/*' />
        public int OutputBlockSize {
            get { return(3); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.CanTransformMultipleBlocks"]/*' />
        public bool CanTransformMultipleBlocks {
            get { return(false); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.CanReuseTransform"]/*' />
        public virtual bool CanReuseTransform { 
            get { return(true); }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.TransformBlock"]/*' />
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) {
            byte[] temp = new byte[inputCount];
            char[] tempChar;
            int effectiveCount;

            // Do some validation, we let InternalBlockCopy do the destination array validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_inputBuffer == null)
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            if (_whitespaces == FromBase64TransformMode.IgnoreWhiteSpaces) {
                temp = DiscardWhiteSpaces(inputBuffer, inputOffset, inputCount);
                effectiveCount = temp.Length;
            } else {
                Buffer.InternalBlockCopy(inputBuffer, inputOffset, temp, 0, inputCount);
                effectiveCount = inputCount;
            }            

            if (effectiveCount + _inputIndex < 4) {
                Buffer.InternalBlockCopy(temp, 0, _inputBuffer, _inputIndex, effectiveCount);
                _inputIndex += effectiveCount;  
                return 0;  
            }
            
            // Get the number of 4 bytes blocks to transform
            int numBlocks = (effectiveCount + _inputIndex) / 4;
            byte[] transformBuffer = new byte[_inputIndex + effectiveCount];
            Buffer.InternalBlockCopy(_inputBuffer, 0, transformBuffer, 0, _inputIndex);
            Buffer.InternalBlockCopy(temp, 0, transformBuffer, _inputIndex, effectiveCount);
            _inputIndex = (effectiveCount + _inputIndex) % 4; 
            Buffer.InternalBlockCopy(temp, effectiveCount - _inputIndex, _inputBuffer, 0, _inputIndex);

            tempChar = Encoding.ASCII.GetChars(transformBuffer, 0, 4*numBlocks);

            byte[] tempBytes = Convert.FromBase64CharArray(tempChar, 0, 4*numBlocks);
            Buffer.InternalBlockCopy(tempBytes, 0, outputBuffer, outputOffset, tempBytes.Length);
            return(tempBytes.Length);
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.TransformFinalBlock"]/*' />
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) {
            byte[] temp = new byte[inputCount];
            char[] tempChar;
            int effectiveCount;

            // Do some validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            if (_inputBuffer == null)
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            if (_whitespaces == FromBase64TransformMode.IgnoreWhiteSpaces) {
                temp = DiscardWhiteSpaces(inputBuffer, inputOffset, inputCount);
                effectiveCount = temp.Length;
            } else {
                Buffer.InternalBlockCopy(inputBuffer, inputOffset, temp, 0, inputCount);
                effectiveCount = inputCount;
            }            

            if (effectiveCount + _inputIndex < 4) {
                Reset();
                return (new byte[0]);  
            }
            
            // Get the number of 4 bytes blocks to transform
            int numBlocks = (effectiveCount + _inputIndex) / 4;
            byte[] transformBuffer = new byte[_inputIndex + effectiveCount];
            Buffer.InternalBlockCopy(_inputBuffer, 0, transformBuffer, 0, _inputIndex);
            Buffer.InternalBlockCopy(temp, 0, transformBuffer, _inputIndex, effectiveCount);
            _inputIndex = (effectiveCount + _inputIndex) % 4; 
            Buffer.InternalBlockCopy(temp, effectiveCount - _inputIndex, _inputBuffer, 0, _inputIndex);

            tempChar = Encoding.ASCII.GetChars(transformBuffer, 0, 4*numBlocks);

            byte[] tempBytes = Convert.FromBase64CharArray(tempChar, 0, 4*numBlocks);
            // reinitialize the transform
            Reset();
            return(tempBytes);
        }

        private byte[] DiscardWhiteSpaces(byte[] inputBuffer, int inputOffset, int inputCount) {
            int i, iCount = 0;
            for (i=0; i<inputCount; i++)
                if (Char.IsWhiteSpace((char)inputBuffer[inputOffset + i])) iCount++;
            byte[] rgbOut = new byte[inputCount - iCount];
            iCount = 0;
            for (i=0; i<inputCount; i++)
                if (!Char.IsWhiteSpace((char)inputBuffer[inputOffset + i])) {
                    rgbOut[iCount++] = inputBuffer[inputOffset + i];
                }
            return rgbOut;
        }

        // must implement IDisposable, which in this case means clearing the input buffer

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Reset the state of the transform so it can be used again
        private void Reset() {
            _inputIndex = 0;
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            // we always want to clear the input buffer
            if (disposing) {
                if (_inputBuffer != null)
                    Array.Clear(_inputBuffer, 0, _inputBuffer.Length);
                _inputBuffer = null;
                _inputIndex = 0;
            }
        }

        /// <include file='doc\base64Transforms.uex' path='docs/doc[@for="FromBase64Transform.Finalize1"]/*' />
        ~FromBase64Transform() {
            Dispose(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\crypto.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Crypto.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System.Runtime.Serialization;
    using System;

    // This enum represents cipher chaining modes: cipher block chaining (CBC), 
    // electronic code book (ECB), output feedback (OFB), cipher feedback (CFB),
    // and ciphertext-stealing (CTS).  Not all implementations will support all modes.
    /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode"]/*' />
    [Serializable]
    public enum CipherMode {            // Please keep with wincrypt.h
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode.CBC"]/*' />
        CBC = 1,                        //    CRYPT_MODE_*
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode.ECB"]/*' />
        ECB = 2,
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode.OFB"]/*' />
        OFB = 3,
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode.CFB"]/*' />
        CFB = 4,
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CipherMode.CTS"]/*' />
        CTS = 5
    }

    // This enum represents the padding method to use for filling out short blocks.
    // "None" means no padding (whole blocks required). 
    // "PKCS7" is the padding mode defined in RFC 2898, Section 6.1.1, Step 4, generalized
    // to whatever block size is required.  
    // "Zeros" means pad with zero bytes to fill out the last block.
    /// <include file='doc\Crypto.uex' path='docs/doc[@for="PaddingMode"]/*' />
    [Serializable]
    public enum PaddingMode {
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="PaddingMode.None"]/*' />
        None = 1,
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="PaddingMode.PKCS7"]/*' />
        PKCS7 = 2,
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="PaddingMode.Zeros"]/*' />
        Zeros = 3
    }

    // This structure is used for returning the set of legal key sizes and
    // block sizes of the symmetric algorithms.
    // Note: this class should be sealed, otherwise someone could sub-class it and the read-only
    // properties we depend on can have setters. Ideally, we should have a struct here (value type)
    // but we use what we have now and try to close the hole allowing someone to specify an invalid key size
    /// <include file='doc\Crypto.uex' path='docs/doc[@for="KeySizes"]/*' />
    public sealed class KeySizes
    {
        private int          _MinSize;
        private int          _MaxSize;
        private int          _SkipSize;

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="KeySizes.MinSize"]/*' />
        public int MinSize {
            get { return(_MinSize); }
        }

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="KeySizes.MaxSize"]/*' />
        public int MaxSize {
            get { return(_MaxSize); }
        }

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="KeySizes.SkipSize"]/*' />
        public int SkipSize {
            get { return(_SkipSize); }
        }

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="KeySizes.KeySizes"]/*' />
        public KeySizes(int minSize, int maxSize, int skipSize) {
            _MinSize = minSize; _MaxSize = maxSize; _SkipSize = skipSize;
        }
    }
    
    /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException"]/*' />
    [Serializable]
    public class CryptographicException : SystemException
    {
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException"]/*' />
        public CryptographicException() 
            : base(Environment.GetResourceString("Arg_CryptographyException")) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException1"]/*' />
        public CryptographicException(String message) 
            : base(message) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException2"]/*' />
        public CryptographicException(String format, String insert) 
            : base(String.Format(format, insert)) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException3"]/*' />
        public CryptographicException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException4"]/*' />
        public CryptographicException(int hr) 
            : base() {
            SetErrorCode(hr);
        }

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicException.CryptographicException5"]/*' />
        protected CryptographicException(SerializationInfo info, StreamingContext context) : base (info, context) {}
    }
    
    /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException"]/*' />
    [Serializable()]
    public class CryptographicUnexpectedOperationException : CryptographicException
    {
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException.CryptographicUnexpectedOperationException"]/*' />
        public CryptographicUnexpectedOperationException() 
            : base() {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO_UNEX_OPER);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException.CryptographicUnexpectedOperationException1"]/*' />
        public CryptographicUnexpectedOperationException(String message) 
            : base(message) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO_UNEX_OPER);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException.CryptographicUnexpectedOperationException2"]/*' />
        public CryptographicUnexpectedOperationException(String format, String insert) 
            : base(String.Format(format, insert)) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO_UNEX_OPER);
        }
    
        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException.CryptographicUnexpectedOperationException3"]/*' />
        public CryptographicUnexpectedOperationException(String message, Exception inner) 
            : base(message, inner) {
            SetErrorCode(__HResults.CORSEC_E_CRYPTO_UNEX_OPER);
        }

        /// <include file='doc\Crypto.uex' path='docs/doc[@for="CryptographicUnexpectedOperationException.CryptographicUnexpectedOperationException4"]/*' />
        protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context) : base (info, context) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\asymmetricsignaturedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// AsymmetricSignatureDeformatter.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System;

    /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter"]/*' />
    public abstract class AsymmetricSignatureDeformatter  {
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter.AsymmetricSignatureDeformatter"]/*' />
        public AsymmetricSignatureDeformatter() {
        }
    
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter.SetKey"]/*' />
        abstract public void SetKey(AsymmetricAlgorithm key);
        /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter.SetHashAlgorithm"]/*' />
        abstract public void SetHashAlgorithm(String strName);
    
        /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter.VerifySignature"]/*' />
        public virtual bool VerifySignature(HashAlgorithm hash, byte[] rgbSignature) {
            if (hash == null) throw new ArgumentNullException("hash");
            SetHashAlgorithm(hash.ToString());
            return VerifySignature(hash.Hash, rgbSignature);
        }
        
        /// <include file='doc\AsymmetricSignatureDeformatter.uex' path='docs/doc[@for="AsymmetricSignatureDeformatter.VerifySignature1"]/*' />
        abstract public bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\securitymanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  SecurityManager.cs
//
//  The SecurityManager class provides a general purpose API for interacting
//  with the security system.
//

namespace System.Security {
    using System;
    using System.Security.Util;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.Runtime.CompilerServices;
    using SecurityPermission = System.Security.Permissions.SecurityPermission;
    using SecurityPermissionFlag = System.Security.Permissions.SecurityPermissionFlag;
    using System.Text;
    using Microsoft.Win32;
    using System.Threading;
    using System.Reflection;
    using System.IO;

    #if _DEBUG
    using FileIOPermission = System.Security.Permissions.FileIOPermission;
    using PermissionState = System.Security.Permissions.PermissionState;
    #endif
    
    /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="PolicyLevelType"]/*' />
    [Serializable]
    public enum PolicyLevelType
    {
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="PolicyLevelType.User"]/*' />
        User = 0,
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="PolicyLevelType.Machine"]/*' />
        Machine = 1,
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="PolicyLevelType.Enterprise"]/*' />
        Enterprise = 2,
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="PolicyLevelType.AppDomain"]/*' />
        AppDomain = 3
    }
    
    /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager"]/*' />
   sealed public class SecurityManager
    {
        [System.Diagnostics.Conditional( "_DEBUG" )]
        private static void DEBUG_OUT( String str )
        {
#if _DEBUG        
            if (debug)
            {
                if (to_file)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append( str );
                    sb.Append ((char)13) ;
                    sb.Append ((char)10) ;
                    PolicyManager._DebugOut( file, sb.ToString() );
                }
                else
                    Console.WriteLine( str );
            }
#endif            
        }
        
#if _DEBUG
        private static bool debug = false;
        private static readonly bool to_file = false;
        private const String file = "c:\\fee\\debug.txt";
#endif

        // CorPerm.h and secpol.cool
        internal const String s_rkpolicymanager = "Software\\Microsoft\\.NETFramework\\Security\\Policy\\1.002";
    
        internal static bool requestEngineInitialized = false;
        internal static bool policyManagerInitialized = false;
    
        internal static CodeAccessSecurityEngine icase = null;
        internal static SecurityRuntime isr = null;
        internal static PolicyManager polmgr = null;
        
        // This is refered from EE
        private static PermissionSet s_ftPermSet = null;
        
        private static Type securityPermissionType = null;
        private static SecurityPermission executionSecurityPermission = null;
    
        // Global Settings See src/inc/CorPerm.h
        internal const int SecurityOff              = 0x1F000000;
        
        // This flag enables checking for execution rights on start-up (slow)
        internal const int CheckExecutionRightsDisabledFlag  = 0x00000100;
        
        internal const int UseNetPermissionsFlag = 0x00000200;

        // -1 if no decision has been made yet
        // 0 if we don't need to check
        // 1 if we do.
        private static int checkExecution = -1;
        
        private static bool needToSetSecurityOn = false;
        
        // C# adds a public default constructor if there are
        // not constructors for the class.  Define a private
        // one to get around this.

        private SecurityManager() {}

        static SecurityManager()
        {
            Init();
        }
    
        // Init - Called by the runtime to initialize security.
    
        internal static void Init()
        {
            if (SecurityEnabled)
            {
                // Separate function so that the jit doesn't load all those classes
                DoInitSecurity();
            }
        }
    
    
        static private bool InitPolicy() {
            if(policyManagerInitialized == false) 
            {
                Type type = typeof( System.Security.PolicyManager );

                lock (type)
                {
                    polmgr = new PolicyManager();
                    policyManagerInitialized = true;
                }
            }
            return (polmgr != null);
        }
        
        static private void DoInitSecurity()
        {
            s_ftPermSet = new PermissionSet(true);
            
            isr = new SecurityRuntime();
            icase = new CodeAccessSecurityEngine();
        }
        
        //
        // Protected APIs for retrieving security engines
        //
        
        internal static CodeAccessSecurityEngine GetCodeAccessSecurityEngine()
        {
            return icase;
        }
        
        internal static SecurityRuntime GetSecurityRuntime()
        {
            return isr;
        }
        
        internal static void AddLevel( PolicyLevel level )
        {
            if (InitPolicy())
            {
                polmgr.AddLevel( level );
            }
        }

        //
        // Public APIs
        //
        
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.IsGranted"]/*' />
        public static bool IsGranted( IPermission perm )
        {
            if (perm == null)
                return true;

            PermissionSet granted, denied;

            StackCrawlMark stackMark = StackCrawlMark.LookForMyCaller;
            
            _GetGrantedPermissions( out granted, out denied, ref stackMark );
            
            return granted.Contains( perm ) && (denied == null || !denied.Contains( perm ));
        }

        static private bool CheckExecution()
        {
            if (checkExecution == -1)
                checkExecution = (GetGlobalFlags() & CheckExecutionRightsDisabledFlag) != 0 ? 0 : 1;
                
            if (checkExecution == 1)
            {
                if (securityPermissionType == null)
                {
                    securityPermissionType = typeof( System.Security.Permissions.SecurityPermission );
                    executionSecurityPermission = new SecurityPermission( SecurityPermissionFlag.Execution );
                }
                DEBUG_OUT( "Execution checking ON" );
                return true;
            }
            else
            {
                DEBUG_OUT( "Execution checking OFF" );
                return false;
            }
               
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.GetZoneAndOrigin"]/*' />
        /// <internalonly/>
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, Name = "System.Windows.Forms", PublicKey = "0x00000000000000000400000000000000" )]
        static public void GetZoneAndOrigin( out ArrayList zone, out ArrayList origin )
        {
            StackCrawlMark mark = StackCrawlMark.LookForMyCaller;

            if (SecurityEnabled)
            {
                icase.GetZoneAndOrigin( ref mark, out zone, out origin );
            }
            else
            {
                zone = null;
                origin = null;
            }
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.LoadPolicyLevelFromFile"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy )]
        static public PolicyLevel LoadPolicyLevelFromFile( String path, PolicyLevelType type )
        {
             if (path == null)
               throw new ArgumentNullException( "path" );

            ConfigId id = SharedStatics.GetNextConfigId();

            ConfigRetval retval = Config.InitData( id, path );

            if ((retval & ConfigRetval.ConfigFile) == 0)
                throw new ArgumentException( Environment.GetResourceString( "Argument_PolicyFileDoesNotExist" ) );

            String name = Enum.GetName( typeof( PolicyLevelType ), type );

            if (name == null)
                return null;

            String fullPath = Path.GetFullPath( path );

            FileIOPermission perm = new FileIOPermission( PermissionState.None );
            perm.AddPathList( FileIOPermissionAccess.Read, fullPath );
            perm.AddPathList( FileIOPermissionAccess.Write, fullPath );
            perm.Demand();

            PolicyLevel level = new PolicyLevel( name, id, type == PolicyLevelType.Machine );
            level.ThrowOnLoadError = true;
            level.CheckLoaded( false );
            return level;
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.LoadPolicyLevelFromString"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy )]
        static public PolicyLevel LoadPolicyLevelFromString( String str, PolicyLevelType type )
        {
#if _DEBUG
            if (debug)
            {
                DEBUG_OUT( "Input string =" );
                DEBUG_OUT( str );
            }
#endif 

            if (str == null)
                throw new ArgumentNullException( "str" );

            String name = Enum.GetName( typeof( PolicyLevelType ), type );

            if (name == null)
                return null;

            Parser parser = new Parser( str );

            PolicyLevel level = new PolicyLevel( name, ConfigId.None, type == PolicyLevelType.Machine );

            SecurityElement elRoot = parser.GetTopElement();
            
            if (elRoot == null)
            {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Policy_BadXml" ), "configuration" ) );
            }
            
            SecurityElement elMscorlib = elRoot.SearchForChildByTag( "mscorlib" );
            
            if (elMscorlib == null)
            {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Policy_BadXml" ), "mscorlib" ) );
            }
            
            SecurityElement elSecurity = elMscorlib.SearchForChildByTag( "security" );

            if (elSecurity == null)
            {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Policy_BadXml" ), "security" ) );
            }

            SecurityElement elPolicy = elSecurity.SearchForChildByTag( "policy" );
                
            if (elPolicy == null)
            {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Policy_BadXml" ), "policy" ) );
            }

            SecurityElement elPolicyLevel = elPolicy.SearchForChildByTag( "PolicyLevel" );
            
            if (elPolicyLevel != null)
            {
                level.FromXml( elPolicyLevel );
            }
            else
            {
                throw new ArgumentException( String.Format( Environment.GetResourceString( "Policy_BadXml" ), "PolicyLevel" ) );
            }

            level.Loaded = true; 

            return level;
        }


        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.SavePolicyLevel"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy )]
        static public void SavePolicyLevel( PolicyLevel level )
        {
            PolicyManager.EncodeLevel( level );
        }

        static
        private PermissionSet GetDefaultMyComputerPolicy( out PermissionSet denied )
        {
            // This function is a crazy little hack that just returns the default MyComputer
            // zone policy.  This is actually useful for detecting what policy an assembly
            // would be granted as long as it's unsigned.  We should add support for
            // signed stuff in later.
        
            Evidence ev = new Evidence();
            
            ev.AddHost( new Zone( SecurityZone.MyComputer ) );
            
            return ResolvePolicy( ev, new PermissionSet( false ), new PermissionSet( true ), null, out denied );
        }
        
        static
        private PermissionSet ResolvePolicy( Evidence evidence,
                                             PermissionSet reqdPset,
                                             PermissionSet optPset,
                                             PermissionSet denyPset,
                                             out PermissionSet denied,
                                             out int grantedIsUnrestricted,
                                             bool checkExecutionPermission )
        {
            CodeAccessPermission.AssertAllPossible();

            PermissionSet granted = ResolvePolicy( evidence,
                                                   reqdPset,
                                                   optPset,
                                                   denyPset,
                                                   out denied,
                                                   checkExecutionPermission );
                                                   
            if (granted != null && granted.IsUnrestricted() && (denied == null || denied.IsEmpty()))
                grantedIsUnrestricted = 1;
            else
                grantedIsUnrestricted = 0;
         
            return granted;
        }
                                                   

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.ResolvePolicy"]/*' />
        static public PermissionSet ResolvePolicy(Evidence evidence,
                           PermissionSet reqdPset,
                           PermissionSet optPset,
                           PermissionSet denyPset,
                           out PermissionSet denied)
        {
            return ResolvePolicy( evidence, reqdPset, optPset, denyPset, out denied, true );
        }
                           
        static private PermissionSet ResolvePolicy(Evidence evidence,
                           PermissionSet reqdPset,
                           PermissionSet optPset,
                           PermissionSet denyPset,
                           out PermissionSet denied,
                           bool checkExecutionPermission)
        {
            PermissionSet requested;
            PermissionSet optional;
            PermissionSet allowed;

            Exception savedException = null;

            // We don't want to recurse back into here as a result of a
            // stackwalk during resolution. So simply assert full trust (this
            // implies that custom permissions cannot use any permissions that
            // don't implement IUnrestrictedPermission.
            // PermissionSet.s_fullTrust.Assert();

            // The requested set is the union of the minimal request and the
            // optional request. Minimal request defaults to empty, optional
            // is "AllPossible" (includes any permission that can be defined)
            // which is symbolized by null.
            optional = optPset;
                        
            if (reqdPset == null)
            {
                requested = optional;
            }
            else
            {
                // If optional is null, the requested set becomes null/"AllPossible".
                requested = optional == null ? null : reqdPset.Union(optional);
            }
    
            // Make sure that the right to execute is requested (if this feature is
            // enabled).
            
            if (requested != null && !requested.IsUnrestricted() && CheckExecution())
            {
                requested.AddPermission( executionSecurityPermission );
            }
            
            if (InitPolicy())
            {
                // If we aren't passed any evidence, just make an empty object
                // If we are passed evidence, copy it before passing it
                // to the policy manager.
                // Note: this is not a deep copy, the pieces of evidence within the
                // Evidence object can still be altered and affect the originals.
            
                if (evidence == null)
                    evidence = new Evidence();
                else
                    evidence = evidence.ShallowCopy();
                    
                evidence.AddHost(new PermissionRequestEvidence(reqdPset, optPset, denyPset));
                
                // We need to make sure that no stray exceptions come out of Resolve so
                // we wrap it in a try block.

                try
                {
                    allowed = polmgr.Resolve(evidence,requested);
                }
                catch (Exception e)
                {
#if _DEBUG
                    if (debug)
                    {
                        DEBUG_OUT( "Exception during resolve" );
                        DEBUG_OUT( e.GetType().FullName );
                        DEBUG_OUT( e.Message );
                        DEBUG_OUT( e.StackTrace );
                    }
#endif

                    // If we get a policy exception, we are done are we are going to fail to
                    // load no matter what.

                    if (e is PolicyException)
                        throw e;

                    // If we get any other kid of exception, we set the allowed set to the
                    // empty set and continue processing as normal.  This allows assemblies
                    // that make no request to be loaded but blocks any assembly that
                    // makes a request from being loaded.  This seems like a valid design to
                    // me -- gregfee 6/19/2000

                    savedException = e;
                    allowed = new PermissionSet();
                }
            }
            else
            {
                denied = null;
                return null;
            }
                

#if _DEBUG    
            if (debug)
            {
                DEBUG_OUT("ResolvePolicy:");
                IEnumerator enumerator = evidence.GetEnumerator();
                DEBUG_OUT("Evidence:");
                while (enumerator.MoveNext())
                {
                    Object obj = enumerator.Current;
                    if (obj is Site)
                    {
                        DEBUG_OUT( ((Site)obj).ToXml().ToString() );
                    }
                    else if (obj is Zone)
                    {
                        DEBUG_OUT( ((Zone)obj).ToXml().ToString() );
                    }
                    else if (obj is Url)
                    {
                        DEBUG_OUT( ((Url)obj).ToXml().ToString() );
                    }
                    else if (obj is Publisher)
                    {
                        DEBUG_OUT( ((Publisher)obj).ToXml().ToString() );
                    }
                    else if (obj is StrongName)
                    {
                        DEBUG_OUT( ((StrongName)obj).ToXml().ToString() );
                    }
                    else if (obj is PermissionRequestEvidence)
                    {
                        DEBUG_OUT( ((PermissionRequestEvidence)obj).ToXml().ToString() );
                    }
                }
                DEBUG_OUT("Required permissions:");
                DEBUG_OUT(reqdPset != null ? reqdPset.ToString() : "<null>");
                DEBUG_OUT("Optional permissions:");
                DEBUG_OUT(optPset != null ? optPset.ToString() : "<null>");
                DEBUG_OUT("Denied permissions:");
                DEBUG_OUT(denyPset != null ? denyPset.ToString() : "<null>");
                DEBUG_OUT("Requested permissions:");
                DEBUG_OUT(requested != null ? requested.ToString() : "<null>");
                DEBUG_OUT("Granted permissions:");
                DEBUG_OUT(allowed != null ? allowed.ToString() : "<null>");
            }
#endif
        
            // Check that we were granted the right to execute.
            if (!allowed.IsUnrestricted() && checkExecutionPermission && CheckExecution())
            {
                SecurityPermission secPerm = (SecurityPermission)allowed.GetPermission( securityPermissionType );

                if (secPerm == null || !executionSecurityPermission.IsSubsetOf( secPerm ))
                {
#if _DEBUG
                    DEBUG_OUT( "No execute permission" );
#endif                            
                    throw new PolicyException(Environment.GetResourceString( "Policy_NoExecutionPermission" ),
                                              System.__HResults.CORSEC_E_NO_EXEC_PERM,
                                              savedException );
                }
            }

            // Check that we were granted at least the minimal set we asked for. Do
            // this before pruning away any overlap with the refused set so that
            // users have the flexability of defining minimal permissions that are
            // only expressable as set differences (e.g. allow access to "C:\" but
            // disallow "C:\Windows").
            if (reqdPset != null && !reqdPset.IsSubsetOf(allowed))
            {
#if _DEBUG
                DEBUG_OUT( "Didn't get required permissions" );
#endif           
                throw new PolicyException(Environment.GetResourceString( "Policy_NoRequiredPermission" ),
                                          System.__HResults.CORSEC_E_MIN_GRANT_FAIL,
                                          savedException );
            }
    
            // Remove any granted permissions that are safe subsets of some denied
            // permission. The remaining denied permissions (if any) are returned
            // along with the modified grant set for use in checks.
            if (denyPset != null)
            {
                denied = denyPset.Copy();
                allowed.MergeDeniedSet(denied);
                if (denied.IsEmpty())
                    denied = null;
            }
            else
                denied = null;
    
    
#if _DEBUG
            if (debug)
            {
                DEBUG_OUT("Final denied permissions:");
                DEBUG_OUT(denied != null ? denied.ToString() : "<null>");
            }
#endif
    
            return allowed;
        }


        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.ResolvePolicy1"]/*' />
        static public PermissionSet ResolvePolicy( Evidence evidence )
        {
            if (InitPolicy())
            {
                // If we aren't passed any evidence, just make an empty object
                // If we are passed evidence, copy it before passing it
                // to the policy manager.
                // Note: this is not a deep copy, the pieces of evidence within the
                // Evidence object can still be altered and affect the originals.
            
                if (evidence == null)
                    evidence = new Evidence();
                else
                    evidence = evidence.ShallowCopy();
                    
                evidence.AddHost(new PermissionRequestEvidence(null, null, null));
                
                return polmgr.Resolve(evidence,null);
            }
            else
            {
                return null;
            }
        }

            

    
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.ResolvePolicyGroups"]/*' />
        static public IEnumerator ResolvePolicyGroups(Evidence evidence)
        {
            if (InitPolicy()) {
                return polmgr.ResolveCodeGroups(evidence);
            } else {
                return null;
            }
            
        }
        
        internal static IEnumerator InternalPolicyHierarchy()
        {
            if (InitPolicy())
            {
                AppDomain currentDomain = AppDomain.CurrentDomain;

                // Before we handle out the policy hierarchy, we
                // want to make sure that all currently loaded assemblies
                // have had policy resolved for them.  Otherwise, changing
                // policy could make it so that assemblies we've decided
                // to load don't end up getting granted what our caching
                // said they would get.

                return polmgr.PolicyHierarchy();
            }
            else
            {
                return null;
            }
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.PolicyHierarchy"]/*' />
        public static IEnumerator PolicyHierarchy()
        {
            if (InitPolicy())
            {
                AppDomain currentDomain = AppDomain.CurrentDomain;

                // Before we handle out the policy hierarchy, we
                // want to make sure that all currently loaded assemblies
                // have had policy resolved for them.  Otherwise, changing
                // policy could make it so that assemblies we've decided
                // to load don't end up getting granted what our caching
                // said they would get.

                currentDomain.nForcePolicyResolution();
                currentDomain.nForceResolve();

                return polmgr.PolicyHierarchy();
            }
            else
            {
                return null;
            }
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.SavePolicy"]/*' />
        [SecurityPermissionAttribute( SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlPolicy )]
        public static void SavePolicy()
        {
            if (InitPolicy()) {
                polmgr.Save();
            }

            // We have serious issues with setting security on in a running process, therefore
            // we go through some hoops to persist security on changes to the registry without
            // affecting the running process.

            if (needToSetSecurityOn)
            {
                // Grab the flags, set security on, save those flags, revert back to the original

                int originalFlags = GetGlobalFlags();
                SetGlobalFlags( SecurityOff, 0 );
                SaveGlobalFlags();
                SetGlobalFlags( originalFlags, originalFlags );
            }
            else
            {
                SaveGlobalFlags();
            }
            
            }
            
                
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.CheckExecutionRights"]/*' />
       static public bool CheckExecutionRights
        {
            get
            {
                return (GetGlobalFlags() & CheckExecutionRightsDisabledFlag) != CheckExecutionRightsDisabledFlag;
            }
            
            set
            {
                if (value)
                {
                    // Disable policy caching

                    IEnumerator enumerator = PolicyHierarchy();

                    while (enumerator.MoveNext())
                    {
                        ((PolicyLevel)enumerator.Current).m_caching = false;
                    }

                    checkExecution = 1;
                    SetGlobalFlags( CheckExecutionRightsDisabledFlag, 0 );
                }
                else
                {
                    new SecurityPermission( SecurityPermissionFlag.ControlPolicy ).Demand();
                    
                    checkExecution = 0;
                    SetGlobalFlags( CheckExecutionRightsDisabledFlag, CheckExecutionRightsDisabledFlag );
                }
            }
        }                
    
        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.SecurityEnabled"]/*' />
        public static bool SecurityEnabled
        {
            get
            {
#if _DEBUG            
                try
                {
#endif                
                    return _IsSecurityOn();
#if _DEBUG                        
                }
                catch (Exception e)
                {
                    DEBUG_OUT( "Exception during IsSecurityOn check" );
                    DEBUG_OUT( e.GetType().FullName );
                    DEBUG_OUT( e.Message );
                    DEBUG_OUT( e.StackTrace );
                    throw e;
                }
#endif                
            }
            
            set
            {
                if (value)
                {
                    needToSetSecurityOn = true;
                }
                else
                {
                    needToSetSecurityOn = false;

                    SetGlobalFlags( SecurityOff, SecurityOff );
                }
            }
                
        }

        // Given a set of evidence and some permission requests, resolve policy
        // and compare the result against the given grant & deny sets. Return
        // whether the two are equivalent.
        static private bool CheckGrantSets(Evidence evidence,
                                           PermissionSet minimal,
                                           PermissionSet optional,
                                           PermissionSet refused,
                                           PermissionSet granted,
                                           PermissionSet denied)
        {
            PermissionSet newGranted = null;
            PermissionSet newDenied = null;
            int isUnrestricted;

            try {
                newGranted = ResolvePolicy(evidence,
                                           minimal,
                                           optional,
                                           refused,
                                           out newDenied,
                                           out isUnrestricted,
                                           true);
            } catch {
                return false;
            }

            if (granted == null)
            {
                if ((newGranted != null) && !newGranted.IsEmpty())
                    return false;
            }
            else
            {
                if (newGranted == null)
                    return granted.IsEmpty();

                try
                {
                    if (!granted.IsSubsetOf(newGranted) ||
                        !newGranted.IsSubsetOf(granted))
                        return false;
                }
                catch (Exception)
                {
                    // We catch any exception and just return false.
                    // This has to be done because not all permissions
                    // may support the IsSubsetOf operation.
                    return false;
                }
            }

            if (denied == null)
            {
                if ((newDenied != null) && !newDenied.IsEmpty())
                    return false;
            }
            else
            {
                if (newDenied == null)
                    return denied.IsEmpty();

                try
                {
                    if (!denied.IsSubsetOf(newDenied) ||
                        !newDenied.IsSubsetOf(denied))
                        return false;
                }
                catch (Exception)
                {
                    // We catch any exception and just return false.
                    // This has to be done because not all permissions
                    // may support the IsSubsetOf operation.
                    return false;
                }
            }

            return true;
        }

        // This method is conditionally called by Security::SetGlobalSecurity
        private static void CheckPermissionToSetGlobalFlags(int flags)
        {
            new SecurityPermission(SecurityPermissionFlag.ControlPolicy).Demand();
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private static extern bool _IsSecurityOn();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern int GetGlobalFlags();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void SetGlobalFlags( int mask, int flags );
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void SaveGlobalFlags();
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void Log(String str);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal static extern void _GetGrantedPermissions(out PermissionSet granted, out PermissionSet denied, ref StackCrawlMark stackmark);
    
    #if _DEBUG
        private static FileStream dbgStream = null;
        private static bool openFailed = false;
     
        internal static void dbg(String str)
        {
            if (debug == false)
                return;
    
            Console.WriteLine(str);
    
            if (str == null || str.Length == 0)
                return;
    
            if (dbgStream == null && openFailed == false)
            {
                new FileIOPermission(PermissionState.Unrestricted).Assert();    // No reccursion here.
                try {
                    dbgStream = new FileStream("C:\\Temp\\security.dbg", FileMode.Create, FileAccess.Write);
                } catch (Exception e) {
                    Console.WriteLine("Dbg : " + e);
                    openFailed = true;
                }
            }
    
            if (dbgStream != null)
            {
                byte[] ub = new byte[str.Length]; 
                for (int i=0; i<str.Length; ++i)
                    ub[i] = (byte) str[i];
                dbgStream.Write(ub, 0, ub.Length);
                dbgStream.Flush();
            }
    
        }

        /// <include file='doc\SecurityManager.uex' path='docs/doc[@for="SecurityManager.PrintGrantInfo"]/*' />
        public static void PrintGrantInfo()
        {
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            PermissionSet grant;
            PermissionSet denied;

            int length = assemblies.Length;
            for (int i = 0; i < length; ++i)
            {
                assemblies[i].nGetGrantSet( out grant, out denied );

                Console.WriteLine( "Assembly = " + assemblies[i].nGetSimpleName() );
                Console.WriteLine( "grant = " );
                Console.WriteLine( (grant == null ? "<null>" : grant.ToString()) );
                Console.WriteLine( "denied = " );
                Console.WriteLine( (denied == null ? "<null>" : denied.ToString()) );
                Console.WriteLine( "" );
            }
        }
    #endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\asymmetricsignatureformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// AsymmetricSignatureFormatter.cs
//

namespace System.Security.Cryptography {
    using System.Security;
    using System;

    /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter"]/*' />
    public abstract class AsymmetricSignatureFormatter {
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter.AsymmetricSignatureFormatter"]/*' />
        public AsymmetricSignatureFormatter() {
        }
    
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter.SetKey"]/*' />
        abstract public void SetKey(AsymmetricAlgorithm key);
        /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter.SetHashAlgorithm"]/*' />
        abstract public void SetHashAlgorithm(String strName);
    
        /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter.CreateSignature"]/*' />
        public virtual byte[] CreateSignature(HashAlgorithm hash) {
            if (hash == null) throw new ArgumentNullException("hash");
            SetHashAlgorithm(hash.ToString());
            return CreateSignature(hash.Hash);
        }
        
        /// <include file='doc\AsymmetricSignatureFormatter.uex' path='docs/doc[@for="AsymmetricSignatureFormatter.CreateSignature1"]/*' />
        abstract public byte[] CreateSignature(byte[] rgbHash);
    
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\cryptoapitransform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * CryptoAPITransform.cs
 *
 * Author: bal
 *
 */

namespace System.Security.Cryptography {
    using System;
    using System.IO;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.CompilerServices;
    using SecurityElement = System.Security.SecurityElement;
    using Microsoft.Win32;
    using System.Threading;

    /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransformMode"]/*' />
    [Serializable]
    internal enum CryptoAPITransformMode {
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransformMode.Encrypt"]/*' />
        Encrypt = 0,
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransformMode.Decrypt"]/*' />
        Decrypt = 1,
    }

    /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform"]/*' />
    public sealed class CryptoAPITransform : ICryptoTransform {
        private const int ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const int ALG_TYPE_BLOCK     = (3 << 9);
        private const int CALG_DES      = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | 1 );
        private const int CALG_3DES     = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 3 );
        private const int CALG_RC2      = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 2 );
        private const int CALG_AES_128  = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 14);
        private const int CALG_AES_192 = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 15);
        private const int CALG_AES_256 = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 16);

        private int             _algid;
        private int             EffectiveKeySizeValue;
        private IntPtr                 _hCSP;
        //private IntPtr             _hMasterKey;
        private IntPtr                 _hKey;
        private __KeyHandleProtector _KeyHandleProtector = null;
        private CspParameters      _parameters;
        private byte[] _depadBuffer = null;

        private String NameValue;
        private int                   BlockSizeValue;
        private int                   FeedbackSizeValue;
        private byte[]                IVValue;
        private int                   KeySizeValue;
        private CipherMode            ModeValue;
        private PaddingMode           PaddingValue;
        private int                   State;
        private CryptoAPITransformMode encryptOrDecrypt;
        // below needed for Reset
        private int[] _rgArgIds;
        private Object[] _rgArgValues;
        private byte[] _rgbKey;
        private int _cArgs;

        private static bool _runningWin2KOrLaterCrypto = CheckForWin2KCrypto();

#if _DEBUG
        private bool debug = false;
#endif
      
        // *********************** CONSTRUCTORS *************************
        
        internal CryptoAPITransform(String strName, int algid, int cArgs, int[] rgArgIds,
                                  Object[] rgArgValues, byte[] rgbKey,
                                  CspParameters param, PaddingMode padding, 
                                  CipherMode cipherChainingMode, int blockSize,
                                  int feedbackSize, CryptoAPITransformMode encDecMode) {
            int         dwValue;
            int         hr;
            int         i;
            byte[]      rgbValue;

            State = 0;
            NameValue = strName;
            BlockSizeValue = blockSize;
            FeedbackSizeValue = feedbackSize;
            ModeValue = cipherChainingMode;
            PaddingValue = padding;
            KeySizeValue = rgbKey.Length*8;
            _algid = algid;
            encryptOrDecrypt = encDecMode;

            // Copy the input args
            _cArgs = cArgs;
            _rgArgIds = new int[rgArgIds.Length];
            Array.Copy(rgArgIds, _rgArgIds, rgArgIds.Length);
            _rgbKey = new byte[rgbKey.Length];
            Array.Copy(rgbKey, _rgbKey, rgbKey.Length);
            _rgArgValues = new Object[rgArgValues.Length];
            // an element of rgArgValues can only be an int or a byte[]
            for (int j = 0; j < rgArgValues.Length; j++) {
                if (rgArgValues[j] is byte[]) {
                    byte[] rgbOrig = (byte[]) rgArgValues[j];
                    byte[] rgbNew = new byte[rgbOrig.Length];
                    Array.Copy(rgbOrig, rgbNew, rgbOrig.Length);
                    _rgArgValues[j] = rgbNew;
                    continue;
                }
                if (rgArgValues[j] is int) {
                    _rgArgValues[j] = (int) rgArgValues[j];
                    continue;
                }
                if (rgArgValues[j] is CipherMode) {
                    _rgArgValues[j] = (int) rgArgValues[j];
                    continue;
                }
            }

            _hCSP = IntPtr.Zero;
            //_hMasterKey = IntPtr.Zero;
            _hKey = IntPtr.Zero;

            //  If we have no passed in CSP parameters, use the default ones

            if (param == null) {
                _parameters = new CspParameters();
            } else {
                _parameters = param;
            }

            //
            // Try and open the CSP.
            // On downlevel crypto platforms, we have to create a key container because we can't
            // use the exponent-of-one trick on a CRYPT_VERIFYONLY keyset
            // see URT bug #15957
            //
            if (_runningWin2KOrLaterCrypto) {
                hr = _AcquireCSP(_parameters, ref _hCSP);
            } else {
                hr = _CreateCSP(_parameters, ref _hCSP);
            }
            if ((hr != 0) || (_hCSP == IntPtr.Zero)) {
#if _DEBUG
                if (debug) {
                    Console.WriteLine("_CreateCSP failed in CSP_Encryptor, hr = {0:X} hCSP = {1:X}", hr, _hCSP);
                }
#endif
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            }

            // Check to see if this alg & key size are supported
            // Commented out for now until I can fix the DES/3DES 56/64 problem
            /* {
               int hasAlgHR;
               Console.WriteLine("Keysizevalue = " + KeySizeValue);
               hasAlgHR = _SearchForAlgorithm(_hCSP, algid, KeySizeValue);
               if (hasAlgHR != 0) {
               throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_CSP_AlgKeySizeNotAvailable"),KeySizeValue));                 
               }
               }
            */

#if _DEBUG
            if (debug) {
                Console.WriteLine("Got back _hCSP = {0}", _hCSP);
            }
#endif

#if _DEBUG
            if (debug) {
                Console.WriteLine("Calling _ImportBulkKey({0}, {1}, {2})", _hCSP, algid, rgbKey);
            }
#endif
            _hKey = _ImportBulkKey(_hCSP, algid, _rgbKey);
            if (_hKey == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ImportBulkKey"));
            }
            //hr = _DuplicateKey(_hMasterKey, ref _hKey);
#if _DEBUG
            if (debug) {
                Console.WriteLine("Got back _hKey = {0}", _hKey);
            }
#endif
            for (i=0; i<cArgs; i++) {
                switch (rgArgIds[i]) {
                case 1: // KP_IV
                    IVValue = (byte[]) _rgArgValues[i];
                    rgbValue = IVValue;
                SetAsByteArray:
                    _SetKeyParamRgb(_hKey, _rgArgIds[i], rgbValue);
                    break;

                case 4: // KP_MODE
                    ModeValue = (CipherMode) _rgArgValues[i];
                    dwValue = (Int32) _rgArgValues[i];
                SetAsDWord:
#if _DEBUG
                    if (debug) {
                        Console.WriteLine("Calling _SetKeyParamDw({0}, {1}, {2})", _hKey, _rgArgIds[i], dwValue);
                    }
#endif
                    _SetKeyParamDw(_hKey, _rgArgIds[i], dwValue);
                    break;

                case 5: // KP_MODE_BITS
                    FeedbackSizeValue = (Int32) _rgArgValues[i];
                    dwValue = FeedbackSizeValue;
                    goto SetAsDWord;

                case 19: // KP_EFFECTIVE_KEYLEN
                    EffectiveKeySizeValue = (Int32) _rgArgValues[i];
                    dwValue = EffectiveKeySizeValue;
                    goto SetAsDWord;

                default:
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeyParameter"), "_rgArgIds[i]");
                }
            }

            _KeyHandleProtector = new __KeyHandleProtector(_hKey);
        }

        // ICryptoTransforms are required to implement  IDisposable implementation

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.Dispose"]/*' />
        void Dispose(bool disposing) {
            if (disposing) {
                // we always want to clear out these items
                // clear out _rgbKey 
                if (_rgbKey != null) {
                    Array.Clear(_rgbKey,0,_rgbKey.Length);
                    _rgbKey = null;
                }
                if (IVValue != null) {
                    Array.Clear(IVValue,0,IVValue.Length);
                    IVValue = null;
                }
                if (_depadBuffer != null) {
                    Array.Clear(_depadBuffer, 0, _depadBuffer.Length);
                    _depadBuffer = null;
                }
            }

            if (_KeyHandleProtector != null && !_KeyHandleProtector.IsClosed) {
                _KeyHandleProtector.Close();
            }
            // Delete the temporary key container
            if (!_runningWin2KOrLaterCrypto) {
                _DeleteKeyContainer(_parameters, _hCSP);
            }
            if (_hCSP != IntPtr.Zero) {
                _FreeCSP(_hCSP);
                _hCSP = IntPtr.Zero;
            }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.Finalize"]/*' />
        ~CryptoAPITransform() {
            Dispose(false);
        }
    
        /*********************** PROPERTY METHODS ************************/

        // all CSP-based ciphers have the same input and output block size

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.KeyHandle"]/*' />
        public IntPtr KeyHandle {
            [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get { return(_KeyHandleProtector.Handle); }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.InputBlockSize"]/*' />
        public int InputBlockSize {
            get { return(BlockSizeValue/8); }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.OutputBlockSize"]/*' />
        public int OutputBlockSize {
            get { return(BlockSizeValue/8); }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.CanTransformMultipleBlocks"]/*' />
        public bool CanTransformMultipleBlocks {
            get { return(true); }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.CanReuseTransform"]/*' />
        public bool CanReuseTransform {
            get { return(true); }
        }

        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.TransformBlock"]/*' />
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) {
            // Note: special handling required if I'm decrypting & using PKCS#7 padding
            // Because the padding adds to the end of the last block, I have to buffer
            // an entire block's worth of bytes in case what I just transformed turns out to be the last block
            // Then in TransformFinalBlock we strip off the PKCS pad.

            if (_KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // First, let's do some bounds checking since the actual crypto is implemented
            // in unmanaged.

            if (inputBuffer == null)
                throw new ArgumentNullException( "inputBuffer" );

            if (outputBuffer == null)
                throw new ArgumentNullException( "outputBuffer" );

            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if ((inputCount <= 0) || (inputCount % InputBlockSize != 0) || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            // Note: there is no need to do the bounds check for the outputBuffer
            // since it will happen in the Buffer.InternalBlockCopy() operation and we are unconcerned
            // about the perf characteristics of the error case.

            byte[] transformedBytes;
            // fDone = true only on Final Block, not here
            if (encryptOrDecrypt == CryptoAPITransformMode.Encrypt) {
                // if we're encrypting we can always push out the bytes because no padding mode
                // removes bytes during encryption
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        transformedBytes = _EncryptData(_KeyHandleProtector.Handle, inputBuffer, inputOffset, inputCount, false);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                if (outputBuffer.Length < outputOffset + transformedBytes.Length)
                    throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );
                Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                return(transformedBytes.Length);
            } else {
                // For de-padding PKCS#7-padded ciphertext, we want to buffer the *input* bytes not
                // the output bytes.  Why?  Because we want to be able to guarantee that we can throw the 
                // "Final" flag to CAPI when processing the last block, and that requires that we have PKCS#7
                // valid output, so we have to cache the input ciphertext.
                if (PaddingValue != PaddingMode.PKCS7) {
                    // like encryption, if we're not using PKCS padding on decrypt we can write out all
                    // the bytes.  Note that we cannot depad a block partially padded with Zeros because
                    // we can't tell if those zeros are plaintext or pad.
                    bool incremented = false;
                    try {
                        if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                            transformedBytes = _DecryptData(_KeyHandleProtector.Handle, inputBuffer, inputOffset, inputCount, false);
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incremented) _KeyHandleProtector.Release();
                    }
                    if (outputBuffer.Length < outputOffset + transformedBytes.Length)
                        throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );
                    Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                    return(transformedBytes.Length);
                } else {
                    // OK, now we're in the special case.  Check to see if this is the *first* block we've seen
                    // If so, buffer it and return null zero bytes

                    int blockSizeInBytes = BlockSizeValue / 8;
                    if (_depadBuffer == null) {
                        _depadBuffer = new byte[InputBlockSize];
                        // copy the last InputBlockSize*8 bytes to _depadBufffer
                        // everything else gets processed and returned
                        int inputToProcess = inputCount - InputBlockSize;
                        bool incremented = false;
                        try {
                            if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                transformedBytes = _DecryptData(_KeyHandleProtector.Handle, inputBuffer, inputOffset, inputToProcess, false);
                            }
                            else
                                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                        }
                        finally {
                            if (incremented) _KeyHandleProtector.Release();
                        }
                        Buffer.InternalBlockCopy(inputBuffer, inputOffset+inputToProcess, _depadBuffer, 0, InputBlockSize);
                        Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                        return(transformedBytes.Length); // we copied 0 bytes into the outputBuffer
                    } else {
                        // we already have a depad buffer, so we need to decrypt that info first & copy it out
                        bool incremented = false;
                        try {
                            if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                transformedBytes = _DecryptData(_KeyHandleProtector.Handle, _depadBuffer, 0, _depadBuffer.Length, false);
                            }
                            else
                                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                        }
                        finally {
                            if (incremented) _KeyHandleProtector.Release();
                        }
                        int retval = transformedBytes.Length;
                        Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, retval);
                        outputOffset += OutputBlockSize;
                        int inputToProcess = inputCount - InputBlockSize;
                        incremented = false;
                        try {
                            if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                transformedBytes = _DecryptData(_KeyHandleProtector.Handle, inputBuffer, inputOffset, inputToProcess, false);
                            }
                            else
                                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                        }
                        finally {
                            if (incremented) _KeyHandleProtector.Release();
                        }
                        Buffer.InternalBlockCopy(inputBuffer, inputOffset+inputToProcess, _depadBuffer, 0, InputBlockSize);
                        Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                        return(retval + transformedBytes.Length);
                    }
                }
            }
        }

        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CryptoAPITransform.TransformFinalBlock"]/*' />
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) { 
            if (_KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if ((inputCount < 0) || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            byte[] temp = new byte[inputCount+InputBlockSize];
            Buffer.InternalBlockCopy(inputBuffer, inputOffset, temp, 0, inputCount);
            byte[] transformedBytes;
            // Now we have to handle Padding modes.  First, note that by
            // doing the array copy above we've implcitly padded the array out
            // with zeros.  We need to throw an exception here if 
            // we were handed a non-zero, non-full block and we're in PaddingMode.None
            int iLonelyBytes = inputCount%InputBlockSize;
            if (PaddingValue == PaddingMode.None) {
                if (inputCount == 0) {
                    Reset(false);
                    return(new byte[0]);
                }
                if (iLonelyBytes != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_SSE_InvalidDataSize"));
                }
                // otherwise just go on
            }
            // If we're using PKCS padding, then let CAPI handle it by setting this flag to true
            bool usingPKCSPadding = (PaddingValue == PaddingMode.PKCS7);
            // If we're using Zero padding, then send the entire block
            int bytesToEncrypt = (PaddingValue != PaddingMode.Zeros) ? inputCount : ((iLonelyBytes == 0) ? inputCount : (inputCount+InputBlockSize-iLonelyBytes));

            if (encryptOrDecrypt == CryptoAPITransformMode.Encrypt) {
                // If we're encrypting we can alway return what we compute because
                // there's no _depadBuffer
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        transformedBytes = _EncryptData(_KeyHandleProtector.Handle, temp, 0, bytesToEncrypt, usingPKCSPadding);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                Reset(usingPKCSPadding);
                return(transformedBytes);
            } else {
                if (iLonelyBytes != 0)
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_SSD_InvalidDataSize"));
                // We're decrypting.  If we're not in PKCS7 mode, then we don't have
                // a _depadBuffer and can just return what we have
                if (!usingPKCSPadding) {
                    bool incremented = false;
                    try {
                        if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                            transformedBytes = _DecryptData(_KeyHandleProtector.Handle, temp, 0, bytesToEncrypt, false);
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incremented) _KeyHandleProtector.Release();
                    }
                    Reset(false);
                    return(transformedBytes);
                } else {
                    // PKCS padding.  
                    // Case 1: degenerate case -- no _depadBuffer, no bytes to decrypt
                    if ((_depadBuffer == null) && (inputCount == 0)) {
                        Reset(usingPKCSPadding);
                        return(new byte[0]);
                    }
                    // Case 2: inputCount is 0, so _depadBuffer is the last block
                    if (inputCount == 0) {
                        // process the block, setting the flag to CAPI
                        bool incremented = false;
                        try {
                            if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                transformedBytes = _DecryptData(_KeyHandleProtector.Handle, _depadBuffer, 0, _depadBuffer.Length, true);
                            }
                            else
                                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                        }
                        finally {
                            if (incremented) _KeyHandleProtector.Release();
                        }
                        // CAPI does the depad for us, so we don't have to do anything here
                        Reset(usingPKCSPadding);
                        return(transformedBytes);
                    } else {
                        // Last case -- we actually have something to decrypt here
                        // transformedBytes is what needs to be depadded
                        // Note: _DecryptData gives us back depadded-data for PKCS#7 already, because
                        // CryptoAPI tells us how many bytes are good...
                        // handle the degenerate case when _depadBuffer is null
                        if (_depadBuffer == null) {
                            bool incremented = false;
                            try {
                                if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                    transformedBytes = _DecryptData(_KeyHandleProtector.Handle, temp, 0, bytesToEncrypt, true);
                                }
                                else
                                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                            }
                            finally {
                                if (incremented) _KeyHandleProtector.Release();
                            }
                            Reset(usingPKCSPadding);
                            return(transformedBytes);
                        } else {
                            byte[] tempBytes = new byte[_depadBuffer.Length + inputCount];
                            Buffer.InternalBlockCopy(_depadBuffer, 0, tempBytes, 0, _depadBuffer.Length);                     
                            Buffer.InternalBlockCopy(temp, 0, tempBytes, _depadBuffer.Length, inputCount);   
                            bool incremented = false;
                            try {
                                if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                                    transformedBytes = _DecryptData(_KeyHandleProtector.Handle, tempBytes, 0, tempBytes.Length, true);                     
                                }
                                else
                                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                            }
                            finally {
                                if (incremented) _KeyHandleProtector.Release();
                            }
                            Reset(usingPKCSPadding);
                            return(transformedBytes);
                        }
                    }
                }
            }
        }
    
    
        /************************* PRIVATE METHODS ************************/

        // This routine resets the internal state of the CryptoAPITransform and the 
        // underlying CAPI mechanism.  The trick is to guarantee that we've always called 
        // CAPI (CryptEncryt/CryptDecrytp) with the Final flag==TRUE.  This always happens when
        // we're in PKCS#7 mode because it's also the signal to CAPI to do the padding, but in 
        // other modes we don't do it, so we need to fake it here.
        private void Reset(bool usingPKCSPadding) {
            _depadBuffer = null;
            if (usingPKCSPadding) return;
            if (encryptOrDecrypt == CryptoAPITransformMode.Encrypt) {
                byte[] tempInput = new byte[InputBlockSize];
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        byte[] ignore = _EncryptData(_KeyHandleProtector.Handle, tempInput, 0, InputBlockSize, true);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }                
            } else {
                // Yuk!! For decryption, if we're not using PKCS7 padding then we have to 
                // get a new key context, because CAPI only knows about PKCS7 padding and
                // we have no way reset things.  We can't just call CryptDuplicateKey
                // because that doesn't exist on NT4.  So, let's just free the key & re-
                // create it...
                byte[] rgbValue;
                int dwValue;

                if (_KeyHandleProtector != null && !_KeyHandleProtector.IsClosed) {
                    _KeyHandleProtector.Close();
                }
                _hKey = _ImportBulkKey(_hCSP, _algid, _rgbKey);
                if (_hKey == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ImportBulkKey"));
                } 
                for (int i=0; i<_cArgs; i++) {
                    switch (_rgArgIds[i]) {
                    case 1: // KP_IV
                        IVValue = (byte[]) _rgArgValues[i];
                        rgbValue = IVValue;
                    SetAsByteArray:
                        _SetKeyParamRgb(_hKey, _rgArgIds[i], rgbValue);
                        break;
                    case 4: // KP_MODE
                        ModeValue = (CipherMode) _rgArgValues[i];
                        dwValue = (Int32) _rgArgValues[i];
                    SetAsDWord:
                        _SetKeyParamDw(_hKey, _rgArgIds[i], dwValue);
                        break;
                    case 5: // KP_MODE_BITS
                        FeedbackSizeValue = (Int32) _rgArgValues[i];
                        dwValue = FeedbackSizeValue;
                        goto SetAsDWord;
                    case 19: // KP_EFFECTIVE_KEYLEN
                        EffectiveKeySizeValue = (Int32) _rgArgValues[i];
                        dwValue = EffectiveKeySizeValue;
                        goto SetAsDWord;
                    default:
                        throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeyParameter"), "_rgArgIds[i]");
                    }
                }
                _KeyHandleProtector = new __KeyHandleProtector(_hKey);
            }
            return;
        }

        internal static bool CheckForWin2KCrypto() {
            // cut-and-paste from Environment.OSVersion so we avoid the demand for EnvironmentPermission.
            // there's a side effect here that you can do a timing attack on how long it takes to spin up this
            // function and figure out whether you're pre- or post-Win2K crypto.  But you could do that
            // anyway by looking at what CSPs are on the system.
            Microsoft.Win32.Win32Native.OSVERSIONINFO osvi = new Microsoft.Win32.Win32Native.OSVERSIONINFO();
            bool r = Win32Native.GetVersionEx(osvi);
            if (!r) { return(false); }
            if (osvi.PlatformId == Win32Native.VER_PLATFORM_WIN32_NT) {
                return(osvi.MajorVersion >= 5);
            }
            return(false);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _CreateCSP(CspParameters param, ref IntPtr unknown);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeHKey(IntPtr hKey);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _EncryptData(IntPtr hKey, byte[] rgb, int ib, int cb, bool fDone);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _DecryptData(IntPtr hKey, byte[] rgb, int ib, int cb, bool fDone);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _DeleteKeyContainer(CspParameters param, IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr     _ImportBulkKey(IntPtr hCSP, int algid, byte[] rgbKey);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _SetKeyParamDw(IntPtr hKey, int param, int dwValue);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _SetKeyParamRgb(IntPtr hKey, int param, byte[] rgbValue);
    }

    // This enum represents what we know about the contents of the key container, specificall
    // whether it contains both a public & private key (exportable), public & non-exportable private key, 
    // only a public key, or unknown contents
    internal enum KeyContainerContents {
        Unknown = 0,
        PublicOnly = 1,
        PublicAndNonExportablePrivate = 2,
        PublicAndExportablePrivate = 3
    }

    /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspProviderFlags"]/*' />
    [Flags, Serializable]
    public enum CspProviderFlags {
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspProviderFlags.UseMachineKeyStore"]/*' />
        UseMachineKeyStore = 1,
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspProviderFlags.UseDefaultKeyContainer"]/*' />
        UseDefaultKeyContainer = 2
    }

    /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters"]/*' />
    public sealed class CspParameters {
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.ProviderType"]/*' />
        public int          ProviderType;
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.ProviderName"]/*' />
        public String       ProviderName;
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.KeyContainerName"]/*' />
        public String       KeyContainerName;
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.KeyNumber"]/*' />
        public int          KeyNumber;

        private int         cspFlags;
        
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.Flags"]/*' />
        public CspProviderFlags Flags {
            get { return (CspProviderFlags) cspFlags; }
            set { cspFlags = (int) value; }
        }
        
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.CspParameters"]/*' />
        public CspParameters() 
            : this(1, null, null) {
        }
    
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.CspParameters1"]/*' />
        public CspParameters(int dwTypeIn) 
            : this(dwTypeIn, null, null) {
        }
    
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.CspParameters2"]/*' />
        public CspParameters(int dwTypeIn, String strProviderNameIn) 
            : this(dwTypeIn, strProviderNameIn, null) {
        }
    
        /// <include file='doc\cryptoapiTransform.uex' path='docs/doc[@for="CspParameters.CspParameters3"]/*' />
        public CspParameters(int dwTypeIn, String strProviderNameIn, String strContainerNameIn) {
            ProviderType = dwTypeIn;
            ProviderName = strProviderNameIn;
            KeyContainerName = strContainerNameIn;
            KeyNumber = -1;
        }

        internal CspParameters(int dwTypeIn, String strProviderNameIn, String strContainerNameIn, CspProviderFlags cspFlags) {
            ProviderType = dwTypeIn;
            ProviderName = strProviderNameIn;
            KeyContainerName = strContainerNameIn;
            KeyNumber = -1;
            this.cspFlags = (int) cspFlags;            
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\cryptostream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// CryptoStream.cs
//
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    using System.IO;
    using System.Security.Cryptography;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStreamMode"]/*' />
    [Serializable]
    public enum CryptoStreamMode {
        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStreamMode.Read"]/*' />
        Read = 0,
        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStreamMode.Write"]/*' />
        Write = 1,
    }

    /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream"]/*' />
    public class CryptoStream : Stream, IDisposable {

        // *** Member veriables
        private Stream _stream;
        private ICryptoTransform _Transform;
        private byte[] _InputBuffer;  // read from _stream before _Transform
        private int _InputBufferIndex = 0;
        private int _InputBlockSize;
        private byte[] _NextInputBuffer; // next block after _InputBuffer, necessary only on Read
        private int _NextInputBufferIndex = 0;
        private byte[] _TempInputBuffer; // swap pointer
        private byte[] _OutputBuffer; // buffered output of _Transform
        private int _OutputBufferIndex = 0;
        private int _OutputBlockSize;
        private CryptoStreamMode _transformMode;
        private bool _canRead = false;
        private bool _canWrite = false;
        private bool _finalBlockTransformed = false;

#if _DEBUG
        private static bool debug = false;
        private static System.Text.ASCIIEncoding ae = new System.Text.ASCIIEncoding();
#endif

        // *** Constructors ***

    /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.CryptoStream"]/*' />
        public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode) {
            _stream = stream;
            _transformMode = mode;
            _Transform = transform;
            switch (_transformMode) {
            case CryptoStreamMode.Read:
                if (!(_stream.CanRead)) throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotReadable"),"stream");
                _canRead = true;
                break;
            case CryptoStreamMode.Write:
                if (!(_stream.CanWrite)) throw new ArgumentException(Environment.GetResourceString("Argument_StreamNotWritable"),"stream");
                _canWrite = true;
                break;
            default:
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            }
            InitializeBuffer();
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Finalize"]/*' />
        ~CryptoStream() {
            Dispose(false);
        }

        // *** Overrides for abstract methods in Stream class *** 

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.CanRead"]/*' />
        public override bool CanRead {
            get { return _canRead; }
        }

        // For now, assume we can never seek into the middle of a cryptostream
        // and get the state right.  This is too strict.
        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.CanSeek"]/*' />
        public override bool CanSeek {
            get { return false; }
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.CanWrite"]/*' />
        public override bool CanWrite {
            get { return _canWrite; }
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Length"]/*' />
        public override long Length {
            get { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Position"]/*' />
        public override long Position {
            get { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
            set { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
        }

        // The flush final block functionality used to be part of close, but that meant you couldn't do something like this:
        // MemoryStream ms = new MemoryStream();
        // CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write);
        // cs.Write(foo, 0, foo.Length);
        // cs.Close();
        // and get the encrypted data out of ms, because the cs.Close also closed ms and the data went away.
        // so now do this:
        // cs.Write(foo, 0, foo.Length);
        // cs.FlushFinalBlock() // which can only be called once
        // byte[] ciphertext = ms.ToArray();
        // cs.Close();
        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.FlushFinalBlock"]/*' />
        public void FlushFinalBlock() {
            if (_finalBlockTransformed) 
                throw new NotSupportedException(Environment.GetResourceString("Cryptography_CryptoStream_FlushFinalBlockTwice"));
            // We have to process the last block here.  First, we have the final block in _InputBuffer, so transform it

            byte[] finalBytes = _Transform.TransformFinalBlock(_InputBuffer, 0, _InputBufferIndex);

            _finalBlockTransformed = true;
            // Now, write out anything sitting in the _OutputBuffer...
            if (_OutputBufferIndex > 0) {
                _stream.Write(_OutputBuffer, 0, _OutputBufferIndex);
                _OutputBufferIndex = 0;
            }
            // Write out finalBytes
            _stream.Write(finalBytes, 0, finalBytes.Length);
            // If the inner stream is a CryptoStream, then we want to call FlushFinalBlock on it too, otherwise
            // just Flush...
            if (_stream is CryptoStream) {
                ((CryptoStream) _stream).FlushFinalBlock();
            } else {
                _stream.Flush();
            }
            // zeroize plain text material before returning
            if (_InputBuffer != null)
                Array.Clear(_InputBuffer, 0, _InputBuffer.Length);
            if (_TempInputBuffer != null)
                Array.Clear(_TempInputBuffer, 0, _TempInputBuffer.Length);
            if (_OutputBuffer != null)
                Array.Clear(_OutputBuffer, 0, _OutputBuffer.Length);
            return;
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Close"]/*' />
        public override void Close() {
            if (!_finalBlockTransformed) {
                FlushFinalBlock();
            }
            // we've written out everything, so close the underlying stream
            _stream.Close();
        }


        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Flush"]/*' />
        public override void Flush() {
            return;
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Seek"]/*' />
        public override long Seek(long offset, SeekOrigin origin) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream"));
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.SetLength"]/*' />
        public override void SetLength(long value) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream"));
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Read"]/*' />
        public override int Read([In, Out] byte[] buffer, int offset, int count) {
          // argument checking
            if (!_canRead) 
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnreadableStream"));
            if (offset < 0) 
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            // read <= count bytes from the input stream, transforming as we go.
            // Basic idea: first we deliver any bytes we already have in the
            // _OutputBuffer, because we know they're good.  Then, if asked to deliver 
            // more bytes, we read & transform a block at a time until either there are
            // no bytes ready or we've delivered enough.
            int bytesToDeliver = count;
            int currentOutputIndex = offset;
            if (_OutputBufferIndex != 0) {
                // we have some already-transformed bytes in the output buffer
                if (_OutputBufferIndex <= count) {
                    Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, offset, _OutputBufferIndex);
                    bytesToDeliver -= _OutputBufferIndex;
                    currentOutputIndex += _OutputBufferIndex;
                    _OutputBufferIndex = 0;
                } else {
                    Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, offset, count);
                    Buffer.InternalBlockCopy(_OutputBuffer, count, _OutputBuffer, 0, _OutputBufferIndex - count);
                    _OutputBufferIndex -= count;
                    return(count);
                }
            }
            // _finalBlockTransformed == true implies we're at the end of the input stream
            // if we got through the previous if block then _OutputBufferIndex = 0, meaning
            // we have no more transformed bytes to give
            // so return count-bytesToDeliver, the amount we were able to hand back
            // eventually, we'll just always return 0 here because there's no more to read
            if (_finalBlockTransformed) {
                return(count - bytesToDeliver);
            }
            // ok, now loop until we've delivered enough or there's nothing available
            int amountRead = 0;
            int numOutputBytes;

            // OK, see first if it's a multi-block transform and we can speed up things
            if (bytesToDeliver > _OutputBlockSize)
            {
                if (_Transform.CanTransformMultipleBlocks) {
                    int BlocksToProcess = bytesToDeliver / _OutputBlockSize;
                    int numWholeBlocksInBytes = BlocksToProcess * _InputBlockSize;
                    byte[] tempInputBuffer = new byte[numWholeBlocksInBytes];
                    // get first the block already read
                    Buffer.InternalBlockCopy(_InputBuffer, 0, tempInputBuffer, 0, _InputBufferIndex);
                    amountRead = _InputBufferIndex;
                    amountRead += _stream.Read(tempInputBuffer, _InputBufferIndex, numWholeBlocksInBytes - _InputBufferIndex);
                    _InputBufferIndex = 0;
                    if (amountRead <= _InputBlockSize) {
                        _InputBuffer = tempInputBuffer;
                        _InputBufferIndex = amountRead;
                        goto slow;
                    }
                    // Make amountRead an integral multiple of _InputBlockSize
                    int numWholeReadBlocksInBytes = (amountRead / _InputBlockSize) * _InputBlockSize;
                    int numIgnoredBytes = amountRead - numWholeReadBlocksInBytes;
                    if (numIgnoredBytes != 0) {
                        _InputBufferIndex = numIgnoredBytes;
                        Buffer.InternalBlockCopy(tempInputBuffer, numWholeReadBlocksInBytes, _InputBuffer, 0, numIgnoredBytes);
                    }
                    byte[] tempOutputBuffer = new byte[(numWholeReadBlocksInBytes / _InputBlockSize) * _OutputBlockSize];
                    numOutputBytes = _Transform.TransformBlock(tempInputBuffer, 0, numWholeReadBlocksInBytes, tempOutputBuffer, 0);
                    Buffer.InternalBlockCopy(tempOutputBuffer, 0, buffer, currentOutputIndex, numOutputBytes);
                    // Now, tempInputBuffer and tempOutputBuffer are no more needed, so zeroize them to protect plain text
                    Array.Clear(tempInputBuffer, 0, tempInputBuffer.Length);
                    Array.Clear(tempOutputBuffer, 0, tempOutputBuffer.Length);
                    bytesToDeliver -= numOutputBytes;
                    currentOutputIndex += numOutputBytes;
                }
            }

slow:
            // try to fill _InputBuffer so we have something to transform
            while (_InputBufferIndex < _InputBlockSize) {
                amountRead = _stream.Read(_InputBuffer, _InputBufferIndex, _InputBlockSize - _InputBufferIndex);
                // first, check to see if we're at the end of the input stream
                if (amountRead == 0) goto ProcessFinalBlock;
                _InputBufferIndex += amountRead;
            }
            // we got enough to transform.  At this point we know _OutputBufferIndex must be 0,
            // so we can just write into that buffer
            while (bytesToDeliver > 0) {                    
                // before we do the transform we have to see if we're on the last block of the file 
                _NextInputBufferIndex = _stream.Read(_NextInputBuffer, 0, _InputBlockSize);
                // if _NextInputBufferIndex = 0, we're on the last block
                if (_NextInputBufferIndex == 0) goto ProcessFinalBlock;

                numOutputBytes = _Transform.TransformBlock(_InputBuffer, 0, _InputBlockSize, _OutputBuffer, 0);
                // now, swap things around so the next block is now the current block
                _TempInputBuffer = _InputBuffer;
                _InputBuffer = _NextInputBuffer;
                _NextInputBuffer = _TempInputBuffer;
                _InputBufferIndex = _NextInputBufferIndex;
        
                if (bytesToDeliver >= numOutputBytes) {
                    Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, currentOutputIndex, numOutputBytes);
                    currentOutputIndex += numOutputBytes;
                    bytesToDeliver -= numOutputBytes;
                } else {
                    Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, currentOutputIndex, bytesToDeliver);
                    _OutputBufferIndex = numOutputBytes - bytesToDeliver;
                    Buffer.InternalBlockCopy(_OutputBuffer, bytesToDeliver, _OutputBuffer, 0, _OutputBufferIndex);
                    return(count);
                }
            }
            return(count);

        ProcessFinalBlock:
            // if so, then call TransformFinalBlock to get whatever is left
            byte[] finalBytes = _Transform.TransformFinalBlock(_InputBuffer, 0, _InputBufferIndex);
            // now, since _OutputBufferIndex must be 0 if we're in the while loop at this point,
            // reset it to be what we just got back
            _OutputBuffer = finalBytes;
            _OutputBufferIndex = finalBytes.Length;
            // set the fact that we've transformed the final block
            _finalBlockTransformed = true;
            // now, return either everything we just got or just what's asked for, whichever is smaller
            if (bytesToDeliver < _OutputBufferIndex) {
                Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, currentOutputIndex, bytesToDeliver);
                _OutputBufferIndex -= bytesToDeliver;
                Buffer.InternalBlockCopy(_OutputBuffer, bytesToDeliver, _OutputBuffer, 0, _OutputBufferIndex);
                return(count);
            } else {
                Buffer.InternalBlockCopy(_OutputBuffer, 0, buffer, currentOutputIndex, _OutputBufferIndex);
                bytesToDeliver -= _OutputBufferIndex;
                _OutputBufferIndex = 0;
                return(count - bytesToDeliver);
            }
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Write"]/*' />
        public override void Write(byte[] buffer, int offset, int count) {
            // Note: according to JRoxe, this will soon have a return value of void, so
            // I'm not going to worry about return values here.
            if (!_canWrite) 
                throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnwritableStream"));
            if (offset < 0) 
                throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0)
                throw new ArgumentOutOfRangeException("count", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (buffer.Length - offset < count)
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            // write <= count bytes to the output stream, transforming as we go.
            // Basic idea: using bytes in the _InputBuffer first, make whole blocks,
            // transform them, and write them out.  Cache any remaining bytes in the _InputBuffer.
            int bytesToWrite = count;
            int currentInputIndex = offset;
            // if we have some bytes in the _InputBuffer, we have to deal with those first,
            // so let's try to make an entire block out of it
            if (_InputBufferIndex > 0) {
                if (count >= _InputBlockSize - _InputBufferIndex) {
                    // we have enough to transform at least a block, so fill the input block
                    Buffer.InternalBlockCopy(buffer, offset, _InputBuffer, _InputBufferIndex, _InputBlockSize - _InputBufferIndex);
                    currentInputIndex += (_InputBlockSize - _InputBufferIndex);
                    bytesToWrite -= (_InputBlockSize - _InputBufferIndex);
                    _InputBufferIndex = _InputBlockSize;
                    // Transform the block and write it out
                } else {
                    // not enough to transform a block, so just copy the bytes into the _InputBuffer
                    // and return
                    Buffer.InternalBlockCopy(buffer, offset, _InputBuffer, _InputBufferIndex, count);
                    _InputBufferIndex += count;
                    return;
                }
            }
            // If the OutputBuffer has anything in it, write it out
            if (_OutputBufferIndex > 0) {
                _stream.Write(_OutputBuffer, 0, _OutputBufferIndex);
                _OutputBufferIndex = 0;
            }
            // At this point, either the _InputBuffer is full, empty, or we've already returned.
            // If full, let's process it -- we now know the _OutputBuffer is empty
            int numOutputBytes;
            if (_InputBufferIndex == _InputBlockSize) {
                numOutputBytes = _Transform.TransformBlock(_InputBuffer, 0, _InputBlockSize, _OutputBuffer, 0);
                // write out the bytes we just got 
                _stream.Write(_OutputBuffer, 0, numOutputBytes);
                // reset the _InputBuffer
                _InputBufferIndex = 0;
            }
            while (bytesToWrite > 0) {
                if (bytesToWrite >= _InputBlockSize) {
                    // We have at least an entire block's worth to transform
                    // If the transform will handle multiple blocks at once, do that
                    if (_Transform.CanTransformMultipleBlocks) {
                        int numWholeBlocks = bytesToWrite / _InputBlockSize;
                        int numWholeBlocksInBytes = numWholeBlocks * _InputBlockSize;
                        byte[] _tempOutputBuffer = new byte[numWholeBlocks * _OutputBlockSize];
                        numOutputBytes = _Transform.TransformBlock(buffer, currentInputIndex, numWholeBlocksInBytes, _tempOutputBuffer, 0);
                        _stream.Write(_tempOutputBuffer, 0, numOutputBytes);
                        currentInputIndex += numWholeBlocksInBytes;
                        bytesToWrite -= numWholeBlocksInBytes;
                    } else {
                        // do it the slow way
                        numOutputBytes = _Transform.TransformBlock(buffer, currentInputIndex, _InputBlockSize, _OutputBuffer, 0);
                        _stream.Write(_OutputBuffer, 0, numOutputBytes);
                        currentInputIndex += _InputBlockSize;
                        bytesToWrite -= _InputBlockSize;
                    }
                } else {
                    // In this case, we don't have an entire block's worth left, so store it up in the 
                    // input buffer, which by now must be empty.
                    Buffer.InternalBlockCopy(buffer, currentInputIndex, _InputBuffer, 0, bytesToWrite);
                    _InputBufferIndex += bytesToWrite;
                    return;
                }
            }
            return;
        }
      
        // IDisposable overrides

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\CryptoStream.uex' path='docs/doc[@for="CryptoStream.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                // we need to clear all the internal buffers
                if (_InputBuffer != null) {
                    Array.Clear(_InputBuffer, 0, _InputBuffer.Length);
                }
                if (_NextInputBuffer != null) {
                    Array.Clear(_NextInputBuffer, 0, _NextInputBuffer.Length);
                }
                if (_TempInputBuffer != null) {
                    Array.Clear(_TempInputBuffer, 0, _TempInputBuffer.Length);
                }
                if (_OutputBuffer != null) {
                    Array.Clear(_OutputBuffer, 0, _OutputBuffer.Length);
                }
                _InputBuffer = null;
                _NextInputBuffer = null;
                _TempInputBuffer = null;
                _OutputBuffer = null;
                // Because we do not hold copies of _stream and _Transform we do not
                // Dispose of them here
            }
        }

        // *** Private methods *** 

        private void InitializeBuffer() {
            if (_Transform != null) {
                _InputBlockSize = _Transform.InputBlockSize;
                _InputBuffer = new byte[_InputBlockSize];
                _OutputBlockSize = _Transform.OutputBlockSize;
                _OutputBuffer = new byte[_OutputBlockSize];
            }
            if (_canRead) {
                _NextInputBuffer = new byte[_InputBlockSize];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\derivebytes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DeriveBytes.cs
//

namespace System.Security.Cryptography {
        /// <include file='doc\DeriveBytes.uex' path='docs/doc[@for="DeriveBytes"]/*' />
    public abstract class DeriveBytes {
        // *********************** Constructors ****************************
        // ********************* Property Methods **************************
        // ********************** Public Methods ***************************

        /// <include file='doc\DeriveBytes.uex' path='docs/doc[@for="DeriveBytes.GetBytes"]/*' />
        public abstract byte[] GetBytes(int cb);
        /// <include file='doc\DeriveBytes.uex' path='docs/doc[@for="DeriveBytes.Reset"]/*' />
        public abstract void Reset();

        // ********************** Private Methods **************************
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\descryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//  DES
//
//
// This file contains the wrapper object to get to the CSP versions of the
//  crypto libraries

namespace System.Security.Cryptography {
    using System.IO;
    using System.Security.Util;
    using System.Security;
    using System.Runtime.CompilerServices;
    /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider"]/*' />
    public sealed class DESCryptoServiceProvider : DES
    {
      private const int ALG_CLASS_DATA_ENCRYPT  = (3 << 13);
      private const int ALG_TYPE_BLOCK      = (3 << 9);
      private const int CALG_DES       = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 1 );
      private const int KP_IV                  = 1;
      private const int KP_MODE                = 4;
      private const int KP_MODE_BITS           = 5;


        private RNGCryptoServiceProvider             _rng;
        private CspParameters          _cspParams = null;
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider.DESCryptoServiceProvider"]/*' />
        public DESCryptoServiceProvider() {
            // Acquire a Type 1 provider.  This will be the Enhanced provider if available, otherwise 
            // it will be the base provider.
            IntPtr trialCSPHandle = IntPtr.Zero;
            int trialHR = 0;
            int hasDESHR = 0;
            CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
            trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
            if (trialCSPHandle == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            } 
            // OK, now see if CALG_DES is present in the provider we got back
            hasDESHR = _SearchForAlgorithm(trialCSPHandle, CALG_DES, 0);
            _FreeCSP(trialCSPHandle);
            if (hasDESHR != 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            }
            // Since the CSP only supports a CFB feedback of 8, make that the default
            FeedbackSizeValue = 8;
            // gen random key & IV, in case the user never sets one explicitly
            GenerateKey();
            GenerateIV();
        }
    
        /*********************** PROPERTY METHODS ************************/

        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider.CreateEncryptor"]/*' />
        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
        {
            if (IsWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"DES");
            }
            if (IsSemiWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_SemiWeak"),"DES");
            }

            return _NewEncryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }
      
        /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider.CreateDecryptor"]/*' />
        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
        {
            if (IsWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"DES");
            }
            if (IsSemiWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_SemiWeak"),"DES");
            }

            return _NewDecryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }
  
        //    public SymmetricStreamDecryptor CreateDecryptor(DeriveBytesFromHash);
    
        /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider.GenerateKey"]/*' />

        public override void GenerateKey()
        {
            KeyValue = new byte[8];
            RNG.GetBytes(KeyValue);
            // Never hand back a weak or semi-weak key
            while (DES.IsWeakKey(KeyValue) || DES.IsSemiWeakKey(KeyValue)) {
                RNG.GetBytes(KeyValue);
            }
        }
  
        /// <include file='doc\DESCryptoServiceProvider.uex' path='docs/doc[@for="DESCryptoServiceProvider.GenerateIV"]/*' />
        public override void GenerateIV()
        {
            IVValue = new byte[8];
            RNG.GetBytes(IVValue);
        }
    
        /************************* PRIVATE METHODS ************************/

        private RNGCryptoServiceProvider RNG {
            get { if (_rng == null) { _rng = new RNGCryptoServiceProvider(); } return _rng; }
        }

        private ICryptoTransform _NewDecryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];

            // Check for bad values
            // 1) we don't support OFB mode in DESCryptoServiceProvider
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             

            //  Build the key if one does not already exist
            if (rgbKey == null) {
                rgbKey = new byte[8];
                RNG.GetBytes(rgbKey);
            }

            //  Set the mode for the encryptor (defaults to CBC)
            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            //  If not ECB mode -- pass in an IV

            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            //  Create the decryption transform

            return new CryptoAPITransform("DES", CALG_DES, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue,
                                          mode, BlockSizeValue, feedbackSize, 
                                          CryptoAPITransformMode.Decrypt);
        }
    
        private ICryptoTransform _NewEncryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];

            //  Build the key if one does not already exist

            if (rgbKey == null) {
                rgbKey = new byte[8];
                RNG.GetBytes(rgbKey);
            }

            // Check for bad values
            // 1) we don't support OFB mode in DESCryptoServiceProvider
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             

            //  Set the mode for the encryptor (defaults to CBC)
            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            //  If not ECB mode -- pass in an IV

            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            //  Create the encryptor object

            return new CryptoAPITransform("DES", CALG_DES, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue,
                                          mode, BlockSizeValue, feedbackSize,
                                          CryptoAPITransformMode.Encrypt);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _SearchForAlgorithm(IntPtr hProv, int algID, int keyLength);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeCSP(IntPtr hCSP);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\des.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * DES.cs
 *
 */

namespace System.Security.Cryptography {
    using SecurityElement = System.Security.SecurityElement;
    using System;
    /// <include file='doc\DES.uex' path='docs/doc[@for="DES"]/*' />
    public abstract class DES : SymmetricAlgorithm
    {
        private static  KeySizes[] s_legalBlockSizes = {
            new KeySizes(64, 64, 0)
        };
        private static  KeySizes[] s_legalKeySizes = {
            new KeySizes(64, 64, 0)
        };
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.DES"]/*' />
        public DES() {
            KeySizeValue = 64;
            BlockSizeValue = 64;
            FeedbackSizeValue = BlockSizeValue;
            LegalBlockSizesValue = s_legalBlockSizes;
            LegalKeySizesValue = s_legalKeySizes;
        }
    
        /*********************** PROPERTY METHODS ************************/

        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.Key"]/*' />
        public override byte[] Key {
            get { 
                if (KeyValue == null) {
                    // Never hand back a weak or semi-weak key
                    do {
                        GenerateKey();
                    } while (IsWeakKey(KeyValue) || IsSemiWeakKey(KeyValue));
                }
                return (byte[]) KeyValue.Clone();
            }
            set {
                if (value == null) throw new ArgumentNullException("value");
                if (!ValidKeySize(value.Length * 8)) { // must convert bytes to bits
                    throw new ArgumentException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
                }
                if (IsWeakKey(value)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"DES");
                }
                if (IsSemiWeakKey(value)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_SemiWeak"),"DES");
                }
                KeyValue = (byte[]) value.Clone();
                KeySizeValue = value.Length * 8;
            }
        }

        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.Create"]/*' />
        new static public DES Create() {
            return Create("System.Security.Cryptography.DES");
        }

        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.Create1"]/*' />
        new static public DES Create(String algName) {
            return (DES) CryptoConfig.CreateFromName(algName);
        }

        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.IsWeakKey"]/*' />    
        public static bool IsWeakKey(byte[] rgbKey) {
            if (!IsLegalKeySize(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
            }
            byte[] rgbOddParityKey = FixupKeyParity(rgbKey);
            UInt64 key = QuadWordFromBigEndian(rgbOddParityKey);
            if ((key == 0x0101010101010101) ||
                (key == 0xfefefefefefefefe) ||
                (key == 0x1f1f1f1f0e0e0e0e) ||
                (key == 0xe0e0e0e0f1f1f1f1)) {
                return(true);
            }
            return(false);
        }

        /// <include file='doc\DES.uex' path='docs/doc[@for="DES.IsSemiWeakKey"]/*' />    
        public static bool IsSemiWeakKey(byte[] rgbKey) {
            if (!IsLegalKeySize(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
            }
            byte[] rgbOddParityKey = FixupKeyParity(rgbKey);
            UInt64 key = QuadWordFromBigEndian(rgbOddParityKey);
            if ((key == 0x01fe01fe01fe01fe) ||
                (key == 0xfe01fe01fe01fe01) ||
                (key == 0x1fe01fe00ef10ef1) ||
                (key == 0xe01fe01ff10ef10e) ||
                (key == 0x01e001e001f101f1) ||
                (key == 0xe001e001f101f101) ||
                (key == 0x1ffe1ffe0efe0efe) ||
                (key == 0xfe1ffe1ffe0efe0e) ||
                (key == 0x011f011f010e010e) ||
                (key == 0x1f011f010e010e01) ||
                (key == 0xe0fee0fef1fef1fe) ||
                (key == 0xfee0fee0fef1fef1)) {
                return(true);
            }
            return(false);
        }

        /************************* PRIVATE METHODS ************************/

        private static bool IsLegalKeySize(byte[] rgbKey) {
            if (rgbKey.Length == 8) return(true);
            return(false);
        }

        private static byte[] FixupKeyParity (byte[] rgbKey) {
            byte[] rgbOddParityKey = new byte[rgbKey.Length];
            for (int index=0; index < rgbKey.Length; index++) {
                // Get the bits we are interested in
                rgbOddParityKey[index] = (byte) (rgbKey[index] & 0xfe);
                // Get the parity of the sum of the previous bits
                byte tmp1 = (byte)((rgbOddParityKey[index] & 0xF) ^ (rgbOddParityKey[index] >> 4));
                byte tmp2 = (byte)((tmp1 & 0x3) ^ (tmp1 >> 2));
                byte sumBitsMod2 = (byte)((tmp2 & 0x1) ^ (tmp2 >> 1));
                // We need to set the last bit in rgbOddParityKey[index] to the negation
                // of the last bit in sumBitsMod2
                if (sumBitsMod2 == 0)
                    rgbOddParityKey[index] |= 1;
            }
            return rgbOddParityKey;
        }
            
        private static UInt64 QuadWordFromBigEndian(byte[] block)
        {
            UInt64 x;
            x =  (
                  (((UInt64)block[0]) << 56) | (((UInt64)block[1]) << 48) |
                  (((UInt64)block[2]) << 40) | (((UInt64)block[3]) << 32) |
                  (((UInt64)block[4]) << 24) | (((UInt64)block[5]) << 16) |
                  (((UInt64)block[6]) << 8) | ((UInt64)block[7])
                  );
            return(x);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\dsacryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DSACryptoServiceProvider.cs
//
// CSP-based implementation of DSA
//
// bal 5/17/2000
//


namespace System.Security.Cryptography {
    using System.Runtime.Remoting;
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.Runtime.CompilerServices;
    using System.Globalization;
    using System.Threading;

    internal class DSACspObject {
        internal byte[]      P;
        internal byte[]      Q;
        internal byte[]      G;
        internal byte[]      Y;
        internal byte[]      X;
        internal byte[]      J;
        internal byte[]      seed;
        internal int         counter;
    }

    /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider"]/*' />
    public sealed class DSACryptoServiceProvider : DSA
    {
        private const int ALG_CLASS_SIGNATURE   = (1 << 13);
        private const int ALG_CLASS_KEY_EXCHANGE = (5 << 13);
        private const int ALG_TYPE_RSA      = (2 << 9);
        private const int ALG_TYPE_DSS      = (1 << 9);
        private const int ALG_CLASS_HASH    = (4 << 13);
        private const int ALG_TYPE_ANY      = (0);
        private const int CALG_SHA1     = (ALG_CLASS_HASH | ALG_TYPE_ANY | 4);
        private const int CALG_RSA_KEYX     = (ALG_CLASS_KEY_EXCHANGE| ALG_TYPE_RSA | 0);
        private const int CALG_RSA_SIGN     = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | 0);
        private const int CALG_DSA_SIGN         = (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | 0);
        private const int PROV_DSS_DH = 13;

        private const int AT_KEYEXCHANGE        = 1;
        private const int AT_SIGNATURE          = 2;
        private const int PUBLICKEYBLOB     = 0x6;
        private const int PRIVATEKEYBLOB    = 0x7;
        private const int KP_KEYLEN             = 9;

        private int                 _dwKeySize;
        private CspParameters      _parameters;
        private IntPtr                 _hCSP;
        private __CSPHandleProtector _CSPHandleProtector = null;
        private IntPtr                 _hKey;
        private __KeyHandleProtector _KeyHandleProtector = null;
        private static CodeAccessPermission _UCpermission = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
        private static KeySizes[]   _legalKeySizes = {
            new KeySizes(512, 1024, 64) // per the DSS spec
                };
        private KeyContainerContents  _containerContents;    

        private SHA1 sha1;

        // This flag indicates whether we should delete the key when this object is GC'd or
        // let it stay in the CSP
        // By default, if we generate a random key container then we do NOT persist (flag is false)
        // If the user gave us a KeyContainerName and we found the key there, we DO persist (flag is true)
        // Doing anything with persisted keys requires SecurityPermission.UnmanagedCode rights since
        // it's equivalent to calling CryptoAPI directly...
        private bool _persistKeyInCSP = false; 

        private static CspProviderFlags m_UseMachineKeyStore = 0;

        // *********************** CONSTRUCTORS *************************

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.DSACryptoServiceProvider"]/*' />
        public DSACryptoServiceProvider() : this(0, new CspParameters(PROV_DSS_DH, null, null, m_UseMachineKeyStore)) {
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.DSACryptoServiceProvider1"]/*' />
        public DSACryptoServiceProvider(int dwKeySize) :
            this(dwKeySize, new CspParameters(PROV_DSS_DH, null, null, m_UseMachineKeyStore)) {
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.DSACryptoServiceProvider2"]/*' />
        public DSACryptoServiceProvider(CspParameters parameters) : this(0, parameters) {
        }
    
        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.DSACryptoServiceProvider3"]/*' />
        public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters) {
            int             hr;

            //
            //  Save the CSP Parameters
            //

            if (parameters == null) {
                _parameters = new CspParameters(PROV_DSS_DH, null, null, m_UseMachineKeyStore);
            } else {
                // Check the parameter options: specifying either a key container name or UseDefaultKeyContainer flag
                // requires unmanaged code permission
                if (((parameters.Flags & CspProviderFlags.UseDefaultKeyContainer) != 0)
                    || ((parameters.KeyContainerName != null) && (parameters.KeyContainerName.Length > 0))) {
                    _UCpermission.Demand();
                    // If we specified a key container name for this key, then mark it persisted
                    if ((parameters.KeyContainerName != null) && (parameters.KeyContainerName.Length > 0)) {
                        // CAPI doesn't accept Container Names longer than 260 characters
                        if (parameters.KeyContainerName.Length > 260) 
                            throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeyContainerName")); 
                        _persistKeyInCSP = true;
                    }
                }
                _parameters = parameters;
            }

            //
            //  Create the CSP container for this set of keys
            //
        
            _hCSP = IntPtr.Zero;
            _hKey = IntPtr.Zero;
            hr = _CreateCSP(_parameters, ref _hCSP);
            if (hr != 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            }
            if (_hCSP == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            }

            //
            //  If no key spec has been specified, then set it to be
            //      AT_KEYEXCHANGE,  if a CALG_* has been specified, then
            //      map that to AT_* value
            if (_parameters.KeyNumber == -1) {
                _parameters.KeyNumber = AT_SIGNATURE;
            }
            else if (_parameters.KeyNumber == CALG_DSA_SIGN) {
                _parameters.KeyNumber = AT_SIGNATURE;
            }

            // If the key already exists, use it, else generate a new one
            hr = _GetUserKey(_hCSP, _parameters.KeyNumber, ref _hKey);
            if (hr != 0) {
                _hKey = _GenerateKey(_hCSP, _parameters.KeyNumber, dwKeySize << 16);                
                if (_hKey == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateKey"));
                }
                // We just gen'd a new key pair, so we have both halves.
                _containerContents = KeyContainerContents.PublicAndExportablePrivate;
            } else {
                // If the key already exists, make sure to persist it
                _persistKeyInCSP = true;
                _containerContents = KeyContainerContents.Unknown;
            }

            _dwKeySize = dwKeySize;

            // Create the Hash instance
            sha1 = SHA1.Create();

            _CSPHandleProtector = new __CSPHandleProtector(_hCSP, _persistKeyInCSP, _parameters);
            _KeyHandleProtector = new __KeyHandleProtector(_hKey);
        }

        // DSACryptoServiceProvider, as an AsymmetricAlgorithm, has to implement IDisposable.

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (_KeyHandleProtector != null && !_KeyHandleProtector.IsClosed) {
                _KeyHandleProtector.Close();
            }
            if (_CSPHandleProtector != null && !_CSPHandleProtector.IsClosed) {
                _CSPHandleProtector.Close();
            }
        }
    
        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.Finalize"]/*' />
        ~DSACryptoServiceProvider() {
            Dispose(false);
        }

        /************************* Property Methods **********************/

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.KeyExchangeAlgorithm"]/*' />
        public override String KeyExchangeAlgorithm {
            get {
                // NULL means "not supported"
                return(null);
            }
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.KeySize"]/*' />
        public override int KeySize {
            get {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        byte[] rgbKeySize = _GetKeyParameter(_KeyHandleProtector.Handle, KP_KEYLEN);
                        _dwKeySize = (rgbKeySize[0] | (rgbKeySize[1] << 8) | (rgbKeySize[2] << 16) | (rgbKeySize[3] << 24));
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                return _dwKeySize;
            }
        }
    
        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.LegalKeySizes"]/*' />
        public override KeySizes[] LegalKeySizes {
            get { return (KeySizes[]) _legalKeySizes.Clone(); }
        }
    
        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.SignatureAlgorithm"]/*' />
        public override String SignatureAlgorithm {
            get { return "http://www.w3.org/2000/09/xmldsig#dsa-sha1"; }
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.UseMachineKeyStore"]/*' />
        public static bool UseMachineKeyStore {
            get { return (m_UseMachineKeyStore == CspProviderFlags.UseMachineKeyStore); }
            set { m_UseMachineKeyStore = (value ? CspProviderFlags.UseMachineKeyStore : 0); }
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.PersistKeyInCsp"]/*' />
        public bool PersistKeyInCsp {
            get { return _persistKeyInCSP; }
            set { 
                _UCpermission.Demand();
                _persistKeyInCSP = value;
                _CSPHandleProtector.PersistKeyInCsp = value;
            }
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.ExportParameters"]/*' />
        public override DSAParameters ExportParameters(bool includePrivateParameters) {
            int hr;
            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            DSACspObject      dsaKey = new DSACspObject();
            DSAParameters dsaParams = new DSAParameters();

            if (includePrivateParameters) {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        hr = _ExportKey(_KeyHandleProtector.Handle, PRIVATEKEYBLOB, dsaKey);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                if (hr != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ExportKey"));
                }
                // Must reverse after export from CAPI!
                ReverseDSACspObject(dsaKey);
                dsaParams.P = dsaKey.P;
                dsaParams.Q = dsaKey.Q;
                dsaParams.G = dsaKey.G;
                dsaParams.Y = dsaKey.Y;
                dsaParams.X = dsaKey.X;
                if (dsaKey.J != null) {
                    dsaParams.J = dsaKey.J;
                }
                if (dsaKey.seed != null) {
                    dsaParams.Seed = dsaKey.seed;
                    dsaParams.Counter = dsaKey.counter;
                }
            } else {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        hr = _ExportKey(_KeyHandleProtector.Handle, PUBLICKEYBLOB, dsaKey);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                if (hr != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ExportKey"));
                }
                // Must reverse (into network byte order) after export from CAPI!
                ReverseDSACspObject(dsaKey);
                dsaParams.P = dsaKey.P;
                dsaParams.Q = dsaKey.Q;
                dsaParams.G = dsaKey.G;
                dsaParams.Y = dsaKey.Y;
                if (dsaKey.J != null) {
                    dsaParams.J = dsaKey.J;
                }
                if (dsaKey.seed != null) {
                    dsaParams.Seed = dsaKey.seed;
                    dsaParams.Counter = dsaKey.counter;
                }
                // zeroize private key material
                if (dsaKey.X != null)
                    Array.Clear(dsaKey.X, 0, dsaKey.X.Length);
            }
            return(dsaParams);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.ImportParameters"]/*' />
        public override void ImportParameters(DSAParameters parameters) {
            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            DSACspObject      dsaKey = new DSACspObject();

            // P, Q, G are required
            if (parameters.P == null) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_MissingField"));
            }
            dsaKey.P = (byte[]) parameters.P.Clone();
            if (parameters.Q == null) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_MissingField"));
            }
            dsaKey.Q = (byte[]) parameters.Q.Clone();
            if (parameters.G == null) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_MissingField"));
            }
            dsaKey.G = (byte[]) parameters.G.Clone();

            //  Y is not required
            dsaKey.Y = (parameters.Y == null ? null : ((byte[]) parameters.Y.Clone()));
            //  J is not required
            dsaKey.J = (parameters.J == null ? null : ((byte[]) parameters.J.Clone()));

            //  seed is not required
            dsaKey.seed = (parameters.Seed == null ? null : ((byte[]) parameters.Seed.Clone()));
            //  counter is not required
            dsaKey.counter = parameters.Counter;
            //  X is not required -- private component
            dsaKey.X = (parameters.X == null ? null : ((byte[]) parameters.X.Clone()));

            // NOTE: We must reverse the dsaKey before importing!
            ReverseDSACspObject(dsaKey);
            // Free the current key handle
            _KeyHandleProtector.Close();
            // Now, import the key into the CSP
            bool incremented = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incremented)) {
                    _hKey = _ImportKey(_CSPHandleProtector.Handle, CALG_DSA_SIGN, dsaKey);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _CSPHandleProtector.Release();
            }

            _KeyHandleProtector = new __KeyHandleProtector(_hKey);                        
            _parameters.KeyNumber = AT_SIGNATURE;
            if (dsaKey.X == null) {    
                // If no X, then only have the public
                _containerContents = KeyContainerContents.PublicOnly;              
            } else {
                // Our key pairs are always exportable
                _containerContents = KeyContainerContents.PublicAndExportablePrivate;
            }
            // zeroize private key material
            if (dsaKey.X != null)
                Array.Clear(dsaKey.X, 0, dsaKey.X.Length);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.SignData"]/*' />
        public byte[] SignData(Stream inputStream)
        {
            byte[] hashVal = sha1.ComputeHash(inputStream);
            return SignHash(hashVal, null);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.SignData1"]/*' />
        public byte[] SignData(byte[] buffer) 
        {
            byte[] hashVal = sha1.ComputeHash(buffer);
            return SignHash(hashVal, null);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.SignData2"]/*' />
        public byte[] SignData(byte[] buffer, int offset, int count)
        {
            byte[] hashVal = sha1.ComputeHash(buffer, offset, count);
            return SignHash(hashVal, null);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.VerifyData"]/*' />
        public bool VerifyData(byte[] rgbData, byte[] rgbSignature)
        {
            byte[] hashVal = sha1.ComputeHash(rgbData);
            return VerifyHash(hashVal, null, rgbSignature);
        } 

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.CreateSignature"]/*' />
        override public byte[] CreateSignature(byte[] rgbHash) {
            return SignHash(rgbHash, null);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.VerifySignature"]/*' />
        override public bool VerifySignature(byte[] rgbHash, byte[] rgbSignature) {
            return VerifyHash(rgbHash, null, rgbSignature);
        }

        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.SignHash"]/*' />
        public byte[] SignHash(byte[] rgbHash, String str)
        {
            int             calgHash;
            byte[]         rgbOut;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (_containerContents == KeyContainerContents.PublicOnly) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_NoPrivateKey"));
            }

            calgHash = MapOIDToCalg(str);
            if (rgbHash.Length != sha1.HashSize / 8) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "SHA1", sha1.HashSize / 8));
            }

            bool incremented = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incremented)) {
                    rgbOut = _SignValue(_CSPHandleProtector.Handle, _parameters.KeyNumber, calgHash, rgbHash, 0);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _CSPHandleProtector.Release();
            }

            // need to reverse the signature we get from CAPI!
            ReverseDSASignature(rgbOut);

            return rgbOut;
        }
    
        /// <include file='doc\DSACryptoServiceProvider.uex' path='docs/doc[@for="DSACryptoServiceProvider.VerifyHash"]/*' />
        public bool VerifyHash(byte[] rgbHash, String str, byte[] rgbSignature)
        {
            int             calgHash;
            int             hr;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (rgbSignature == null) {
                throw new ArgumentNullException("rgbSignature");
            }

            calgHash = MapOIDToCalg(str);
            if (rgbHash.Length != sha1.HashSize / 8) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "SHA1", sha1.HashSize / 8));
            }

            // must reverse the signature for input to CAPI.
            // make a copy first
            byte[] sigValue = new byte[rgbSignature.Length];
            rgbSignature.CopyTo(sigValue,0);
            ReverseDSASignature(sigValue);

            bool incrementedCSP = false;
            bool incrementedKey = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incrementedCSP) && _KeyHandleProtector.TryAddRef(ref incrementedKey)) {
                    hr = _VerifySign(_CSPHandleProtector.Handle, _KeyHandleProtector.Handle, calgHash, rgbHash, sigValue, 0);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incrementedCSP) _CSPHandleProtector.Release();
                if (incrementedKey) _KeyHandleProtector.Release();
            }

            // Work-around for NT bug #349370, see http://searchraid/ntbug/349370.asp for details
            // Basically, on downlevel platforms (pre-Win2K), a verification failure returns NTE_FAIL
            // instead of NTE_BAD_SIGNATURE.  COMCryptogrpahy.cpp::_VerifySignature
            // converts NTE_BAD_SIGNATURE to S_FALSE, so we do the same thing with NTE_FAIL here.  This will
            // mask other internal CSP failures but there isn't a way around that.
            if (hr == System.__HResults.NTE_FAIL) {
                return(false);
            }
            if (hr < 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_VerifySignature"));
            }            

            return hr == 0;
        }

        /************************* PRIVATE METHODS ************************/

        private void ReverseDSACspObject(DSACspObject obj) {
            if (obj.P != null) {
                Array.Reverse(obj.P);
            }
            if (obj.Q != null) {
                Array.Reverse(obj.Q);
            }
            if (obj.G != null) {
                Array.Reverse(obj.G);
            }
            if (obj.Y != null) {
                Array.Reverse(obj.Y);
            }
            if (obj.X != null) {
                Array.Reverse(obj.X);
            }
            if (obj.J != null) {
                Array.Reverse(obj.J);
            }
            if (obj.seed != null) {
                Array.Reverse(obj.seed);
            }
        }

        private void ReverseDSASignature(byte[] input) {
            // A DSA signature consists of two 20-byte components, each of which
            // must be reversed in place
            if (input.Length != 40) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidDSASignatureSize"));
            }
            Array.Reverse(input,0,20);
            Array.Reverse(input,20,20);
        }

#if FALSE
        private static int ConvertByteArrayToInt(byte[] rgbInput) {
            // Input to this routine is always big endian
            int i, dwOutput;
            
            dwOutput = 0;
            for (i = 0; i < rgbInput.Length; i++) {
                dwOutput *= 256;
                dwOutput += rgbInput[i];
            }
            return(dwOutput);
        }

        private static byte[] ConvertIntToByteArray(int dwInput) {
            // output of this routine is always big endian
            byte[] rgbTemp = new byte[8]; // int can never be greater than Int64
            int t1;  // t1 is remaining value to account for
            int t2;  // t2 is t1 % 256
            int i = 0;

            t1 = dwInput; 
            while (t1 > 0) {
                BCLDebug.Assert(i < 8, "Got too big an int here!");
                t2 = t1 % 256;
                rgbTemp[i] = (byte) t2;
                t1 = (t1 - t2)/256;
                i++;
            }
            // Now, copy only the non-zero part of rgbTemp and reverse
            byte[] rgbOutput = new byte[i];
            // copy and reverse in one pass
            for (int j = 0; j < i; j++) {
                rgbOutput[j] = rgbTemp[i-j-1];
            }
            return(rgbOutput);
        }
#endif
    
        private int MapOIDToCalg(String str) {
            int     calg;

            // NULL defaults to SHA1 since DSA requires SHA1
            if (str == null) {
                calg = CALG_SHA1;
            } else if (String.Compare(str, "1.3.14.3.2.26", false, CultureInfo.InvariantCulture) == 0) {
                calg = CALG_SHA1;
            } else {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidOID"));
            }
            return calg;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _CreateCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void     _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeHKey(IntPtr hKey);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _DeleteKeyContainer(CspParameters param, IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _ExportKey(IntPtr hkey1, int hkey2, DSACspObject keyData);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _GenerateKey(IntPtr hCSP, int algid, int dwFlags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _GetKeyParameter(IntPtr hKey, int paramID);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _GetUserKey(IntPtr hCSP, int iKey, ref IntPtr hKey);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _ImportKey(IntPtr hCSP, int algid, DSACspObject data);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _SignValue(IntPtr hCSP, int iKey, int algidHash, byte[] rgbHash, int dwFlags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _VerifySign(IntPtr hCSP, IntPtr hKey, int algidHash, byte[] rgbHash, byte[] rgbValue, int dwFlags );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\dsasignaturedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  DSASignatureFormatter.cs
 *
 *  This file contains the DSA formatter.
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;

    /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter"]/*' />
    public class DSASignatureDeformatter : AsymmetricSignatureDeformatter
    {
    
        DSA     _dsaKey;            // DSA Key value to do decrypt operation
        String  _strOID;
    
        // *********************** CONSTRUCTORS ***************************

        /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter.DSASignatureDeformatter"]/*' />
        public DSASignatureDeformatter()
        {
            // The hash algorithm is always SHA1
            _strOID = CryptoConfig.MapNameToOID("SHA1");
        }

        /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter.DSASignatureDeformatter1"]/*' />
        public DSASignatureDeformatter(AsymmetricAlgorithm key) {
            SetKey(key);
            // The hash algorithm is always SHA1
            _strOID = CryptoConfig.MapNameToOID("SHA1");
        }

        /************************* PUBLIC METHODS *************************/

        /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _dsaKey = (DSA) key;
        }

        /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter.SetHashAlgorithm"]/*' />
        public override void SetHashAlgorithm(String strName)
        {
            if (CryptoConfig.MapNameToOID(strName) != _strOID)
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_InvalidOperation"));
        }

        /// <include file='doc\DSASignatureDeformatter.uex' path='docs/doc[@for="DSASignatureDeformatter.VerifySignature"]/*' />
        public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature)
        {
            bool         f;

            if (_dsaKey == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingKey"));
            }
            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (rgbSignature == null) {
                throw new ArgumentNullException("rgbSignature");
            }

            f =  _dsaKey.VerifySignature(rgbHash, rgbSignature);
        
            return f;
        }
    
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\dsa.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  DSA.cs
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;
    using System.Security.Util;
    using System.Text;

    // DSAParameters is serializable so that one could pass the public parameters
    // across a remote call, but we explicitly make the private key X non-serializable
    // so you cannot accidently send it along with the public parameters.
    /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters"]/*' />
    [Serializable]
    public struct DSAParameters {
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.P"]/*' />
        public byte[]      P;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.Q"]/*' />
        public byte[]      Q;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.G"]/*' />
        public byte[]      G;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.Y"]/*' />
        public byte[]      Y;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.J"]/*' />
        public byte[]      J;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.X"]/*' />
        [NonSerialized] public byte[]      X;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.Seed"]/*' />
        public byte[]      Seed;
        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSAParameters.Counter"]/*' />
        public int         Counter;
    }


    /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA"]/*' />
    public abstract class DSA : AsymmetricAlgorithm
    {
        //
        //  Extending this class allows us to know that you are really implementing
        //  an DSA key.  This is required for anybody providing a new DSA key value
        //  implemention.
        //
        //  The class provides no methods, fields or anything else.  Its only purpose is
        //  as a heirarchy member for identification of the algorithm.
        //
        // *********************** CONSTRUCTORS ***************************

        // We need to include the default constructor here so that the C# 
        // compiler won't generate a public one automatically
        internal DSA() { }

        /**************************** Public Methods ************************/

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.Create"]/*' />
        new static public DSA Create() {
            return Create("System.Security.Cryptography.DSA");
        }

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.Create1"]/*' />
        new static public DSA Create(String algName) {
                return (DSA) CryptoConfig.CreateFromName(algName);
        }

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.CreateSignature"]/*' />
        abstract public byte[] CreateSignature(byte[] rgbHash);

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.VerifySignature"]/*' />
        abstract public bool VerifySignature(byte[] rgbHash, byte[] rgbSignature); 

        /* Import/export functions */

        private static int ConvertByteArrayToInt(byte[] rgbInput) {
            // Input to this routine is always big endian
            int i, dwOutput;
            
            dwOutput = 0;
            for (i = 0; i < rgbInput.Length; i++) {
                dwOutput *= 256;
                dwOutput += rgbInput[i];
            }
            return(dwOutput);
        }

        private static byte[] ConvertIntToByteArray(int dwInput) {
            // output of this routine is always big endian
            byte[] rgbTemp = new byte[8]; // int can never be greater than Int64
            int t1;  // t1 is remaining value to account for
            int t2;  // t2 is t1 % 256
            int i = 0;

            if (dwInput == 0) return new byte[1]; 
            t1 = dwInput; 
            while (t1 > 0) {
                BCLDebug.Assert(i < 8, "Got too big an int here!");
                t2 = t1 % 256;
                rgbTemp[i] = (byte) t2;
                t1 = (t1 - t2)/256;
                i++;
            }
            // Now, copy only the non-zero part of rgbTemp and reverse
            byte[] rgbOutput = new byte[i];
            // copy and reverse in one pass
            for (int j = 0; j < i; j++) {
                rgbOutput[j] = rgbTemp[i-j-1];
            }
            return(rgbOutput);
        }

        // We can provide a default implementation of FromXmlString because we require 
        // every DSA implementation to implement ImportParameters
        // All we have to do here is parse the XML.

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.FromXmlString"]/*' />
        public override void FromXmlString(String xmlString) {
            if (xmlString == null) throw new ArgumentNullException("xmlString");
            DSAParameters dsaParams = new DSAParameters();
            Parser p = new Parser(xmlString);
            SecurityElement topElement = p.GetTopElement();

            // P is always present
            String pString = topElement.SearchForTextOfLocalName("P");
            if (pString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","P"));
            }
            dsaParams.P = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(pString));

            // Q is always present
            String qString = topElement.SearchForTextOfLocalName("Q");
            if (qString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","Q"));
            }
            dsaParams.Q = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(qString));

            // G is always present
            String gString = topElement.SearchForTextOfLocalName("G");
            if (gString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","G"));
            }
            dsaParams.G = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(gString));

            // Y is always present
            String yString = topElement.SearchForTextOfLocalName("Y");
            if (yString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","Y"));
            }
            dsaParams.Y = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(yString));

            // J is optional
            String jString = topElement.SearchForTextOfLocalName("J");
            if (jString != null) dsaParams.J = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(jString));

            // X is optional -- private key if present
            String xString = topElement.SearchForTextOfLocalName("X");
            if (xString != null) dsaParams.X = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(xString));

            // Seed and PgenCounter are optional as a unit -- both present or both absent
            String seedString = topElement.SearchForTextOfLocalName("Seed");
            String pgenCounterString = topElement.SearchForTextOfLocalName("PgenCounter");
            if ((seedString != null) && (pgenCounterString != null)) {
                dsaParams.Seed = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(seedString));
                dsaParams.Counter = ConvertByteArrayToInt(Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(pgenCounterString)));
            } else if ((seedString != null) || (pgenCounterString != null)) {
                if (seedString == null) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","Seed"));
                } else {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"DSA","PgenCounter"));
                }
            }

            ImportParameters(dsaParams);
        }

        // We can provide a default implementation of ToXmlString because we require 
        // every DSA implementation to implement ImportParameters
        // If includePrivateParameters is false, this is just an XMLDSIG DSAKeyValue
        // clause.  If includePrivateParameters is true, then we extend DSAKeyValue with 
        // the other (private) elements.

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.ToXmlString"]/*' />
        public override String ToXmlString(bool includePrivateParameters) {
            // From the XMLDSIG spec, RFC 3075, Section 6.4.1, a DSAKeyValue looks like this:
            /* 
               <element name="DSAKeyValue"> 
                 <complexType> 
                   <sequence>
                     <sequence>
                       <element name="P" type="ds:CryptoBinary"/> 
                       <element name="Q" type="ds:CryptoBinary"/> 
                       <element name="G" type="ds:CryptoBinary"/> 
                       <element name="Y" type="ds:CryptoBinary"/> 
                       <element name="J" type="ds:CryptoBinary" minOccurs="0"/> 
                     </sequence>
                     <sequence minOccurs="0">
                       <element name="Seed" type="ds:CryptoBinary"/> 
                       <element name="PgenCounter" type="ds:CryptoBinary"/> 
                     </sequence>
                   </sequence>
                 </complexType>
               </element>
            */
            // we extend appropriately for private component X
            DSAParameters dsaParams = this.ExportParameters(includePrivateParameters);
            StringBuilder sb = new StringBuilder();
            sb.Append("<DSAKeyValue>");
            // Add P, Q, G and Y
            sb.Append("<P>"+Convert.ToBase64String(dsaParams.P)+"</P>");
            sb.Append("<Q>"+Convert.ToBase64String(dsaParams.Q)+"</Q>");
            sb.Append("<G>"+Convert.ToBase64String(dsaParams.G)+"</G>");
            sb.Append("<Y>"+Convert.ToBase64String(dsaParams.Y)+"</Y>");
            // Add optional components if present
            if (dsaParams.J != null) {
                sb.Append("<J>"+Convert.ToBase64String(dsaParams.J)+"</J>");
            }
            if ((dsaParams.Seed != null)) {  // note we assume counter is correct if Seed is present
                sb.Append("<Seed>"+Convert.ToBase64String(dsaParams.Seed)+"</Seed>");
                sb.Append("<PgenCounter>"+Convert.ToBase64String(ConvertIntToByteArray(dsaParams.Counter))+"</PgenCounter>");
            }

            if (includePrivateParameters) {
                // Add the private component
                sb.Append("<X>"+Convert.ToBase64String(dsaParams.X)+"</X>");
            } 
            sb.Append("</DSAKeyValue>");
            return(sb.ToString());
        }

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.ExportParameters"]/*' />
        abstract public DSAParameters ExportParameters(bool includePrivateParameters);

        /// <include file='doc\dsa.uex' path='docs/doc[@for="DSA.ImportParameters"]/*' />
        abstract public void ImportParameters(DSAParameters parameters);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\cryptoconfig.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// CryptoConfig.cs
//
// Author: bal
//

namespace System.Security.Cryptography {
    
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Reflection;

    /// <include file='doc\CryptoConfig.uex' path='docs/doc[@for="CryptoConfig"]/*' />
    public class CryptoConfig
    {
        // CAPI definitions
        private const int ALG_CLASS_HASH    = (4 << 13);
        private const int ALG_TYPE_ANY      = (0);
        private const int CALG_SHA1         = (ALG_CLASS_HASH | ALG_TYPE_ANY | 4);
        private const int CALG_MD2          = (ALG_CLASS_HASH | ALG_TYPE_ANY | 1);
        private const int CALG_MD5          = (ALG_CLASS_HASH | ALG_TYPE_ANY | 3);

        private const int ALG_CLASS_DATA_ENCRYPT   =   (3 << 13);
        private const int ALG_TYPE_BLOCK           =   (3 << 9);
        private const int ALG_TYPE_STREAM          =   (4 << 9);
        private const int CALG_DES                 =   (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | 1);
        private const int CALG_RC2                 =   (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | 2);
        private const int CALG_3DES                =   (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | 3);
        private const int CALG_RC4                 =   (ALG_CLASS_DATA_ENCRYPT| ALG_TYPE_STREAM| 1);

        private static String machineConfigDir = System.Security.Util.Config.MachineDirectory;
        private static Hashtable machineNameHT = null;
        private static Hashtable machineOidHT = null;
        private static bool isInitialized = false;
        private static Hashtable defaultNameHT = null;
        private static Hashtable defaultOidHT = null;
        private static Hashtable defaultCalgHT = null;
        private static Type lockType = typeof(System.Security.Cryptography.CryptoConfig);
        private static String machineConfigFilename = "machine.config";
		private static string _Version = null;

#if _DEBUG
        private static bool debug = false;
#endif

        private static void InitializeConfigInfo() {
			// set up the version string
			Type myType = typeof(CryptoConfig);
			_Version = myType.Assembly.GetVersion().ToString();  
			if (defaultNameHT == null) {          
                lock(lockType) {
                    if (defaultNameHT == null) {
                        defaultNameHT = CreateDefaultMappingHT();
                    }
                }
            }
            if (defaultOidHT == null) {
                lock(lockType) {
                    if (defaultOidHT == null) {
                        defaultOidHT = CreateDefaultOidHT();
                    }
                }
            }
            if (defaultCalgHT == null) {
                lock(lockType) {
                    if (defaultCalgHT == null) {
                        defaultCalgHT = CreateDefaultCalgHT();
                    }
                }
            }

            if ((machineNameHT == null) && (machineOidHT == null)) {
                lock(lockType) {
                    String machineConfigFile = machineConfigDir + machineConfigFilename;
                    if (File.Exists(machineConfigFile)) {
                        // we need to assert here the right to read the machineConfigFile, since
                        // the parser now checks for this right.
                        (new FileIOPermission(FileIOPermissionAccess.Read, machineConfigFile)).Assert();
                        ConfigTreeParser parser = new ConfigTreeParser();
                        ConfigNode rootNode = parser.Parse(machineConfigFile, "configuration");                        

                        if (rootNode == null) goto endInitialization;
                        // now, find the mscorlib tag with our version
                        ArrayList rootChildren = rootNode.Children;
                        ConfigNode mscorlibNode = null;
                        foreach (ConfigNode node in rootChildren) {
                            if (node.Name.Equals("mscorlib")) {
                                ArrayList attribs = node.Attributes;
                                if (attribs.Count > 0) {
                                    DictionaryEntry attribute = (DictionaryEntry) node.Attributes[0];
                                    if (attribute.Key.Equals("version")) {
                                        if (attribute.Value.Equals(_Version)) {
                                            mscorlibNode = node;
                                            break;
                                        }
                                    }
                                }
                                else mscorlibNode = node;
                            }
                        }
                        if (mscorlibNode == null) goto endInitialization;
                        // look for cryptosettings
                        ArrayList mscorlibChildren = mscorlibNode.Children;
                        ConfigNode cryptoSettings = null;
                        foreach (ConfigNode node in mscorlibChildren) {
                            // take the first one that matches
                            if (node.Name.Equals("cryptographySettings")) {
                                cryptoSettings = node;
                                break;
                            }
                        }
                        if (cryptoSettings == null) goto endInitialization;
                        // See if there's a CryptoNameMapping section (at most one)
                        ConfigNode cryptoNameMapping = null;
                        foreach (ConfigNode node in cryptoSettings.Children) {
                            if (node.Name.Equals("cryptoNameMapping")) {
                                cryptoNameMapping = node;
                                break;
                            }
                        }
                        if (cryptoNameMapping == null) goto initializeOIDMap;
                        // We have a name mapping section, so now we have to build up the type aliases
                        // in CryptoClass elements and the mappings.
                        ArrayList cryptoNameMappingChildren = cryptoNameMapping.Children;
                        ConfigNode cryptoClasses = null;
                        // find the cryptoClases element
                        foreach (ConfigNode node in cryptoNameMappingChildren) {
                            if (node.Name.Equals("cryptoClasses")) {
                                cryptoClasses = node;
                                break;
                            }
                        }
                        // if we didn't find it, no mappings
                        if (cryptoClasses == null) goto initializeOIDMap;
                        Hashtable typeAliases = new Hashtable();
                        Hashtable nameMappings = new Hashtable();
                        foreach (ConfigNode node in cryptoClasses.Children) {
                            if (node.Name.Equals("cryptoClass")) {
                                if (node.Attributes.Count > 0) {
                                    DictionaryEntry attribute = (DictionaryEntry) node.Attributes[0];
                                    typeAliases.Add(attribute.Key,attribute.Value);
                                }
                            }
                        }
                        // Now process the name mappings
                        foreach (ConfigNode node in cryptoNameMappingChildren) {
                            if (node.Name.Equals("nameEntry")) {
                                String friendlyName = null;
                                String className = null;
                                foreach (DictionaryEntry attribNode in node.Attributes) {
                                    if (((String) attribNode.Key).Equals("name")) {
                                        friendlyName = (String) attribNode.Value;
                                        continue;
                                    }
                                    if (((String) attribNode.Key).Equals("class")) {
                                        className = (String) attribNode.Value;
                                        continue;
                                    }
                                }
                                if ((friendlyName != null) && (className != null)) {
                                    String typeName = (String) typeAliases[className];
                                    if (typeName != null) {
                                        nameMappings.Add(friendlyName,typeName);

                                    }
                                }
                            }
                        }
                        machineNameHT = nameMappings;
                    initializeOIDMap:
                        // Now, process the OID mappings
                        // See if there's an oidMap section (at most one)
                        ConfigNode oidMapNode = null;
                        foreach (ConfigNode node in cryptoSettings.Children) {
                            if (node.Name.Equals("oidMap")) {
                                oidMapNode = node;
                                break;
                            }
                        }
                        if (oidMapNode == null) goto endInitialization;
                        Hashtable oidMapHT = new Hashtable();
                        foreach (ConfigNode node in oidMapNode.Children) {
                            if (node.Name.Equals("oidEntry")) {
                                String oidString = null;
                                String friendlyName = null;
                                foreach (DictionaryEntry attribNode in node.Attributes) {
                                    if (((String) attribNode.Key).Equals("OID")) {
                                        oidString = (String) attribNode.Value;
                                        continue;
                                    }
                                    if (((String) attribNode.Key).Equals("name")) {
                                        friendlyName = (String) attribNode.Value;
                                        continue;
                                    }
                                }
                                if ((friendlyName != null) && (oidString != null)) {
                                    oidMapHT.Add(friendlyName,oidString);
                                }
                            }
                        }
                        machineOidHT = oidMapHT;
                    }
                }
            }
            endInitialization:
                isInitialized = true;
        }
        
        /// <include file='doc\CryptoConfig.uex' path='docs/doc[@for="CryptoConfig.CreateFromName"]/*' />
        [PermissionSetAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
        public static Object CreateFromName(String name, Object[] args) {
            if (name == null) throw new ArgumentNullException("name");

            Type retvalType = null;
            Object retval;

            // First we'll do the machine-wide stuff, initializing if necessary
            if (!isInitialized) {
                InitializeConfigInfo();
            }

            // Search the machine table

            if (machineNameHT != null) {
                String retvalTypeString = (String) machineNameHT[name];
                if (retvalTypeString != null) {
                    retvalType = RuntimeType.GetTypeInternal(retvalTypeString, false, false, true);
                }
            }

            // If we didn't find it in the machine-wide table,  look in the default table
            if (retvalType == null) {
                // We allow the default table to Types and Strings
                // Types get used for other stuff in mscorlib.dll
                // strings get used for delay-loaded stuff like System.Security.dll
                Object retvalObj  = defaultNameHT[name];
                if (retvalObj != null) {
                    if (retvalObj is Type) {
                        retvalType = (Type) retvalObj;
                    } else if (retvalObj is String) {
                        retvalType = RuntimeType.GetTypeInternal((String) retvalObj, false, false, true);
                    }
                }
            }

            // Maybe they gave us a classname.
            if (retvalType == null) {
                retvalType = RuntimeType.GetTypeInternal(name, false, false, true);
            }

            // Still null?  Then we didn't find it 
            if (retvalType == null) {
                return(null);
            }

            // Perform a CreateInstance by hand so we can check that the
            // constructor doesn't have a linktime demand attached (which would
            // be incorrrectly applied against mscorlib otherwise).
            RuntimeType rtType = retvalType as RuntimeType;
            if (rtType == null)
                return null;
            if (args == null)
                args = new Object[]{};

            // Locate all constructors.
            bool isDelegate;
            MethodBase[] cons = rtType.GetMemberCons(Activator.ConstructorDefault,
                                                     CallingConventions.Any,
                                                     null,
                                                     args.Length,
                                                     false,
                                                     out isDelegate);
            if (cons == null)
                return null;

            // Bind to matching ctor.
            Object state;
            RuntimeConstructorInfo rci = Type.DefaultBinder.BindToMethod(Activator.ConstructorDefault,
                                                                         cons,
                                                                         ref args,
                                                                         null,
                                                                         null,
                                                                         null,
                                                                         out state) as RuntimeConstructorInfo;

            // Check for ctor we don't like (non-existant, delegate or decorated
            // with declarative linktime demand).
            if (rci == null || isDelegate)
                return null;

            // Ctor invoke (actually causes the allocation as well).
            retval = rci.Invoke(Activator.ConstructorDefault, Type.DefaultBinder, args, null);

            // Reset any parameter re-ordering performed by the binder.
            if (state != null)
                Type.DefaultBinder.ReorderArgumentArray(ref args, state);

            return retval;
        }

        /// <include file='doc\CryptoConfig.uex' path='docs/doc[@for="CryptoConfig.CreateFromName1"]/*' />
        public static Object CreateFromName(String name) {
            return CreateFromName(name, null);
        }
        
        // This routine searches the built-in configuration table for 
        // string names of cryptographic objects...

        private static Type SHA1CryptoServiceProviderType = typeof(System.Security.Cryptography.SHA1CryptoServiceProvider); 
        private static Type MD5CryptoServiceProviderType = typeof(System.Security.Cryptography.MD5CryptoServiceProvider); 
        private static Type SHA256ManagedType = typeof(SHA256Managed);
        private static Type SHA384ManagedType = typeof(SHA384Managed);
        private static Type SHA512ManagedType = typeof(SHA512Managed);
        private static Type HMACSHA1Type      = typeof(System.Security.Cryptography.HMACSHA1);
        private static Type MAC3DESType       = typeof(System.Security.Cryptography.MACTripleDES);
        private static Type RSACryptoServiceProviderType = typeof(System.Security.Cryptography.RSACryptoServiceProvider); 
        private static Type DSACryptoServiceProviderType = typeof(System.Security.Cryptography.DSACryptoServiceProvider); 
        private static Type DESCryptoServiceProviderType = typeof(System.Security.Cryptography.DESCryptoServiceProvider); 
        private static Type TripleDESCryptoServiceProviderType = typeof(System.Security.Cryptography.TripleDESCryptoServiceProvider); 
        private static Type RC2CryptoServiceProviderType = typeof(System.Security.Cryptography.RC2CryptoServiceProvider); 
        private static Type RijndaelManagedType = typeof(System.Security.Cryptography.RijndaelManaged); 
        private static Type DSASignatureDescriptionType = typeof(System.Security.Cryptography.DSASignatureDescription);
        private static Type RSAPKCS1SHA1SignatureDescriptionType = typeof(System.Security.Cryptography.RSAPKCS1SHA1SignatureDescription);
        private static Type RNGCryptoServiceProviderType = typeof(System.Security.Cryptography.RNGCryptoServiceProvider);
        // Note that for the internal table we do all the type resolves up front, since everything is in mscorlib.
        private static Hashtable CreateDefaultMappingHT() {
            Hashtable ht = new Hashtable();
            // now all the mappings
            // Random number generator
            ht.Add("RandomNumberGenerator", RNGCryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.RandomNumberGenerator", RNGCryptoServiceProviderType);
            
            // Hash functions
            // SHA1 
            ht.Add("SHA", SHA1CryptoServiceProviderType);
            ht.Add("SHA1", SHA1CryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.SHA1", SHA1CryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.HashAlgorithm", SHA1CryptoServiceProviderType);
            // MD5
            ht.Add("MD5", MD5CryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.MD5", MD5CryptoServiceProviderType);
            // SHA256
            ht.Add("SHA256", SHA256ManagedType);
            ht.Add("SHA-256", SHA256ManagedType);
            ht.Add("System.Security.Cryptography.SHA256", SHA256ManagedType);
            // SHA384
            ht.Add("SHA384", SHA384ManagedType);
            ht.Add("SHA-384", SHA384ManagedType);
            ht.Add("System.Security.Cryptography.SHA384", SHA384ManagedType);
            // SHA512
            ht.Add("SHA512", SHA512ManagedType);
            ht.Add("SHA-512", SHA512ManagedType);
            ht.Add("System.Security.Cryptography.SHA512", SHA512ManagedType);

            // Keyed Hash Algorithms
            ht.Add("System.Security.Cryptography.KeyedHashAlgorithm", HMACSHA1Type);
            ht.Add("HMACSHA1", HMACSHA1Type);
            ht.Add("System.Security.Cryptography.HMACSHA1", HMACSHA1Type);
            ht.Add("MACTripleDES", MAC3DESType);
            ht.Add("System.Security.Cryptography.MACTripleDES", MAC3DESType);

            // Asymmetric algorithms
            // RSA
            ht.Add("RSA", RSACryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.RSA", RSACryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.AsymmetricAlgorithm", RSACryptoServiceProviderType);
            // DSA
            ht.Add("DSA", DSACryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.DSA", DSACryptoServiceProviderType);

            // Symmetric algorithms
            // DES
            ht.Add("DES", DESCryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.DES", DESCryptoServiceProviderType);
            // 3DES
            ht.Add("3DES", TripleDESCryptoServiceProviderType);
            ht.Add("TripleDES", TripleDESCryptoServiceProviderType);
            ht.Add("Triple DES", TripleDESCryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.TripleDES", TripleDESCryptoServiceProviderType);
            // RC2
            ht.Add("RC2", RC2CryptoServiceProviderType);
            ht.Add("System.Security.Cryptography.RC2", RC2CryptoServiceProviderType);
            // Rijndael
            ht.Add("Rijndael", RijndaelManagedType);
            ht.Add("System.Security.Cryptography.Rijndael", RijndaelManagedType);
            // Rijndael is the default symmetric cipher because (a) it's the strongest and (b) we know
            // we have an implementation everywhere
            ht.Add("System.Security.Cryptography.SymmetricAlgorithm", RijndaelManagedType);

            // Asymmetric signature descriptions
            // DSA
            ht.Add("http://www.w3.org/2000/09/xmldsig#dsa-sha1", DSASignatureDescriptionType);
            ht.Add("System.Security.Cryptography.DSASignatureDescription", DSASignatureDescriptionType);
            // RSA-PKCS1-v1.5
            ht.Add("http://www.w3.org/2000/09/xmldsig#rsa-sha1", RSAPKCS1SHA1SignatureDescriptionType);
            ht.Add("System.Security.Cryptography.RSASignatureDescription", RSAPKCS1SHA1SignatureDescriptionType);

            // XML-DSIG Hash algorithms
            ht.Add("http://www.w3.org/2000/09/xmldsig#sha1", SHA1CryptoServiceProviderType);
            // Add the other hash algorithms in DEBUG mode, as they aren't yet defined in the specs
#if _DEBUG
            ht.Add("http://www.w3.org/2000/09/xmldsig#sha256", SHA256ManagedType);
            ht.Add("http://www.w3.org/2000/09/xmldsig#sha384", SHA384ManagedType);
            ht.Add("http://www.w3.org/2000/09/xmldsig#sha512", SHA512ManagedType);
            ht.Add("http://www.w3.org/2000/09/xmldsig#md5", MD5CryptoServiceProviderType);
#endif

            // XML-DSIG entries
            // these are all string entries because we want them to be delay-loaded from System.Security.dll

            // Transforms
            // First arg must match the constants defined in System.Security.Cryptography.Xml.SignedXml
            ht.Add("http://www.w3.org/TR/2001/REC-xml-c14n-20010315", "System.Security.Cryptography.Xml.XmlDsigC14NTransform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);
            ht.Add("http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments", "System.Security.Cryptography.Xml.XmlDsigC14NWithCommentsTransform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig#base64","System.Security.Cryptography.Xml.XmlDsigBase64Transform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);
            ht.Add("http://www.w3.org/TR/1999/REC-xpath-19991116","System.Security.Cryptography.Xml.XmlDsigXPathTransform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);
            ht.Add("http://www.w3.org/TR/1999/REC-xslt-19991116", "System.Security.Cryptography.Xml.XmlDsigXsltTransform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig#enveloped-signature", "System.Security.Cryptography.Xml.XmlDsigEnvelopedSignatureTransform, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Custom=null, Version=" + _Version);

            // KeyInfo 
            // First arg (the key) is formed as elem.NamespaceURI+" "+elem.LocalName
            ht.Add("http://www.w3.org/2000/09/xmldsig# X509Data", "System.Security.Cryptography.Xml.KeyInfoX509Data, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig# KeyName", "System.Security.Cryptography.Xml.KeyInfoName, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig# KeyValue/DSAKeyValue", "System.Security.Cryptography.Xml.DSAKeyValue, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig# KeyValue/RSAKeyValue", "System.Security.Cryptography.Xml.RSAKeyValue, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version=" + _Version);
            ht.Add("http://www.w3.org/2000/09/xmldsig# RetrievalMethod", "System.Security.Cryptography.Xml.KeyInfoRetrievalMethod, System.Security, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, Version=" + _Version);

            // done 
            return(ht);
        }

            /*
            case "RSA-SHA1-PKCS1.5-Sign": 
            case "DSS": 
            case "RSA-PKCS1-KeyEx": 
            case "System.Security.Cryptography.KeyedHashAlgorithm": 
            case "System.Security.Cryptography.RandomNumberGenerator": 
                */

        private static Hashtable CreateDefaultOidHT() {
            Hashtable ht = new Hashtable();
            ht.Add("SHA1", "1.3.14.3.2.26");
            ht.Add("System.Security.Cryptography.SHA1", "1.3.14.3.2.26");
            ht.Add("System.Security.Cryptography.SHA1CryptoServiceProvider", "1.3.14.3.2.26");
            ht.Add("System.Security.Cryptography.SHA1Managed", "1.3.14.3.2.26");
            ht.Add("SHA256", "2.16.840.1.101.3.4.1");
            ht.Add("System.Security.Cryptography.SHA256", "2.16.840.1.101.3.4.1");
            ht.Add("System.Security.Cryptography.SHA256Managed", "2.16.840.1.101.3.4.1");
            ht.Add("SHA384", "2.16.840.1.101.3.4.2");
            ht.Add("System.Security.Cryptography.SHA384", "2.16.840.1.101.3.4.2");
            ht.Add("System.Security.Cryptography.SHA384Managed", "2.16.840.1.101.3.4.2");
            ht.Add("SHA512", "2.16.840.1.101.3.4.3");
            ht.Add("System.Security.Cryptography.SHA512", "2.16.840.1.101.3.4.3");
            ht.Add("System.Security.Cryptography.SHA512Managed", "2.16.840.1.101.3.4.3");
            ht.Add("MD5","1.2.840.113549.2.5");
            ht.Add("System.Security.Cryptography.MD5", "1.2.840.113549.2.5");
            ht.Add("System.Security.Cryptography.MD5CryptoServiceProvider", "1.2.840.113549.2.5");
            ht.Add("System.Security.Cryptography.MD5Managed", "1.2.840.113549.2.5");
            ht.Add("TripleDESKeyWrap","1.2.840.113549.1.9.16.3.6");
            return(ht);
        }

        private static Hashtable CreateDefaultCalgHT() {
            Hashtable ht = new Hashtable();
            ht.Add("SHA1", CALG_SHA1);
            ht.Add("SHA", CALG_SHA1);
            ht.Add("System.Security.Cryptography.SHA1", CALG_SHA1);
            ht.Add("System.Security.Cryptography.SHA1CryptoServiceProvider", CALG_SHA1);
            ht.Add("MD5", CALG_MD5);
            ht.Add("System.Security.Cryptography.MD5", CALG_MD5);
            ht.Add("System.Security.Cryptography.MD5CryptoServiceProvider", CALG_MD5);
            ht.Add("RC2", CALG_RC2);
            ht.Add("System.Security.Cryptography.RC2CryptoServiceProvider", CALG_RC2);
            ht.Add("DES", CALG_DES);
            ht.Add("System.Security.Cryptography.DESCryptoServiceProvider", CALG_DES);
            ht.Add("TripleDES", CALG_3DES);
            ht.Add("System.Security.Cryptography.TripleDESCryptoServiceProvider", CALG_3DES);
            return ht;
        }   

        internal static int MapNameToCalg(String name) {
            if (name == null) throw new ArgumentNullException("name");

            int retval = 0;
            // First we'll do the machine-wide stuff, initializing if necessary
            if (!isInitialized) {
                InitializeConfigInfo();
            }
            
            if (defaultCalgHT != null) {
                if (defaultCalgHT[name] != null) 
                    retval = (int) defaultCalgHT[name]; 
            }         
            return retval;
        }

        /// <include file='doc\CryptoConfig.uex' path='docs/doc[@for="CryptoConfig.MapNameToOID"]/*' />
        public static String MapNameToOID(String name) {
            if (name == null) throw new ArgumentNullException("name");

            Object retval = null;

            // First we'll do the machine-wide stuff, initializing if necessary
            if (!isInitialized) {
                InitializeConfigInfo();
            }

            // Search the machine table

            if (machineOidHT != null) {
                retval = machineOidHT[name];
            }

            // If we didn't find it in the machine-wide table,  look in the default table
            if (retval == null) {
                retval = defaultOidHT[name];
            }

            // Still null?  Then we didn't find it 
            if (retval == null) {
                return(null);
            }
            
            return((String) retval);

        }

        /// <include file='doc\CryptoConfig.uex' path='docs/doc[@for="CryptoConfig.EncodeOID"]/*' />
        static public byte[] EncodeOID(String str) {
            char[] sepArray = { '.' }; // valid ASN.1 separators
            String[] oidString = str.Split(sepArray);
            uint[] oidNums = new uint[oidString.Length];
            for (int i = 0; i < oidString.Length; i++) {
                oidNums[i] = (uint) Int32.Parse(oidString[i]);
            }
            // Allocate the array to receive encoded oidNums
            byte[] encodedOidNums = new byte[oidNums.Length * 5]; // this is guaranteed to be longer than necessary
            int encodedOidNumsIndex = 0;
            // Handle the first two oidNums special
            if (oidNums.Length < 2) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_InvalidOID"));
            }
            uint firstTwoOidNums = (oidNums[0] * 40) + oidNums[1];
            byte[] retval = EncodeSingleOIDNum(firstTwoOidNums);
            Array.Copy(retval, 0, encodedOidNums, encodedOidNumsIndex, retval.Length);
            encodedOidNumsIndex += retval.Length;
            for (int i = 2; i < oidNums.Length; i++) {
                retval = EncodeSingleOIDNum(oidNums[i]);
                Buffer.InternalBlockCopy(retval, 0, encodedOidNums, encodedOidNumsIndex, retval.Length);
                encodedOidNumsIndex += retval.Length;
            }
            // final return value is 06 <length> || encodedOidNums
            if (encodedOidNumsIndex > 0x7f) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_Config_EncodedOIDError"));
            }
            retval = new byte[ encodedOidNumsIndex + 2];
            retval[0] = (byte) 0x06;
            retval[1] = (byte) encodedOidNumsIndex;
            Buffer.InternalBlockCopy(encodedOidNums, 0, retval, 2, encodedOidNumsIndex);
            return retval;
        }

        static private byte[] EncodeSingleOIDNum(uint dwValue) {
            byte[] retval;

            if ((int)dwValue < 0x80) {
                retval = new byte[1];
                retval[0] = (byte) dwValue;
                return retval;
            }
            else if (dwValue < 0x4000) {
                retval = new byte[2];
                retval[0]   = (byte) ((dwValue >> 7) | 0x80);
                retval[1] = (byte) (dwValue & 0x7f);
                return retval;
            }
            else if (dwValue < 0x200000) {
                retval = new byte[3];
                retval[0] = (byte) ((dwValue >> 14) | 0x80);
                retval[1] = (byte) ((dwValue >> 7) | 0x80);
                retval[2] = (byte) (dwValue & 0x7f);
                return retval;
            }
            else if (dwValue < 0x10000000) {
                retval = new byte[4];
                retval[0] = (byte) ((dwValue >> 21) | 0x80);
                retval[1] = (byte) ((dwValue >> 14) | 0x80);
                retval[2] = (byte) ((dwValue >> 7) | 0x80);
                retval[3] = (byte) (dwValue & 0x7f);
                return retval;
            }
            else {
                retval = new byte[5];
                retval[0] = (byte) ((dwValue >> 28) | 0x80);
                retval[1] = (byte) ((dwValue >> 21) | 0x80);
                retval[2] = (byte) ((dwValue >> 14) | 0x80);
                retval[3] = (byte) ((dwValue >> 7) | 0x80);
                retval[4] = (byte) (dwValue & 0x7f);
                return retval;
            }
        }

        static private byte[] OldEncodeOID(String str)
        {
            int             cb;
            int             cElements;
            uint            dwValue;
            bool         fFirst = true;
            int             i;
            char[]          rgb;
            byte[]         rgbOID;
    
            if (str == null) throw new ArgumentNullException("str");
            rgb = str.ToCharArray();
            
            //
            //  Count the number of dots in the string.  We know that the first 
            //  character should never be a dot.
            //
            
            cElements = 0;
            for (i=0; i <str.Length; i++) {
                if (rgb[i] == '.') cElements += 1;
            }
    
            //
            //  Allocate enough bytes to hold the result
            //
    
            rgbOID = new byte[cElements*5];
    
            //
            //  Now process each element
            //
    
            cb = 0;
            dwValue = (uint)0;
            for (i=0; i< str.Length; i++) {
                if (rgb[i] == '.') {
                    if (fFirst && (cElements > 1)) {
                        fFirst = false;
                        // COOLPORT: Fix once we have unsigned support
                        //dwValue = dwValue * 40;
                        dwValue = (uint)((int)dwValue * 40);
                    }
                    else {
                        // COOLPORT: Fix once we have unsigned support
                        //if (dwValue < 0x80) {
                        if ((int)dwValue < 0x80) {
                            rgbOID[cb] = (byte) dwValue;
                            cb += 1;
                        }
                        // COOLPORT: Fix once we have unsigned support
                        //else if (dwValue < 0x4000) {
                        else if ((int)dwValue < 0x4000) {
                            // COOLPORT: Fix once we have unsigned support
                            //rgbOID[cb]   = (byte) ((dwValue >> 7) | 0x80);
                            //rgbOID[cb+1] = (byte) (dwValue & 0x7f);
                            rgbOID[cb]   = (byte) (((int)dwValue >> 7) | 0x80);
                            rgbOID[cb+1] = (byte) ((int)dwValue & 0x7f);
                            cb += 2;
                        }
                        // COOLPORT: Fix once we have unsigned support
                        //else if (dwValue < 0x200000) {
                        else if ((int)dwValue < 0x200000) {
                            // COOLPORT: Fix once we have unsigned support
                            //rgbOID[cb]   = (byte) ((dwValue >> 14) | 0x80);
                            //rgbOID[cb+1] = (byte) ((dwValue >> 7) | 0x80);
                            //rgbOID[cb+2] = (byte) (dwValue & 0x7f);
                            rgbOID[cb]   = (byte) (((int)dwValue >> 14) | 0x80);
                            rgbOID[cb+1] = (byte) (((int)dwValue >> 7) | 0x80);
                            rgbOID[cb+2] = (byte) ((int)dwValue & 0x7f);
                            cb += 3;
                        }
                        // COOLPORT: Fix once we have unsigned support
                        //else if (dwValue < 0x10000000) {
                        else if ((int)dwValue < 0x10000000) {
                            // COOLPORT: Fix once we have unsigned support
                            //rgbOID[cb  ] = (byte) ((dwValue >> 21) | 0x80);
                            //rgbOID[cb+1] = (byte) ((dwValue >> 14) | 0x80);
                            //rgbOID[cb+2] = (byte) ((dwValue >> 7) | 0x80);
                            //rgbOID[cb+3] = (byte) (dwValue & 0x7f);
                            rgbOID[cb  ] = (byte) (((int)dwValue >> 21) | 0x80);
                            rgbOID[cb+1] = (byte) (((int)dwValue >> 14) | 0x80);
                            rgbOID[cb+2] = (byte) (((int)dwValue >> 7) | 0x80);
                            rgbOID[cb+3] = (byte) ((int)dwValue & 0x7f);
                            cb += 4;
                        }
                        else {
                            // COOLPORT: Fix once we have unsigned support
                            //rgbOID[cb  ] = (byte) ((dwValue >> 28) | 0x80);
                            //rgbOID[cb+1] = (byte) ((dwValue >> 21) | 0x80);
                            //rgbOID[cb+2] = (byte) ((dwValue >> 14) | 0x80);
                            //rgbOID[cb+3] = (byte) ((dwValue >> 7) | 0x80);
                            //rgbOID[cb+4] = (byte) (dwValue & 0x7f);
                            rgbOID[cb  ] = (byte) (((int)dwValue >> 28) | 0x80);
                            rgbOID[cb+1] = (byte) (((int)dwValue >> 21) | 0x80);
                            rgbOID[cb+2] = (byte) (((int)dwValue >> 14) | 0x80);
                            rgbOID[cb+3] = (byte) (((int)dwValue >> 7) | 0x80);
                            rgbOID[cb+4] = (byte) ((int)dwValue & 0x7f);
                            cb += 5;
                        }
                        dwValue = (uint)0;
                    }
                }
                else {
                    // COOLPORT: Fix once we have unsigned math
                    //dwValue = dwValue * 10 + rgb[i] - '0';
                    dwValue = (uint) ((int)dwValue * 10 + rgb[i] - '0');
                }
            }
    
            //  Test for encoding error
            if (cb > 0x7f) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_Config_EncodedOIDError"));
            }
            
            //
            //
    
            byte[]         rgbReturn = new byte[cb+2];

            rgbReturn[0] = 0x6;
            rgbReturn[1] = (byte) cb;
            Buffer.InternalBlockCopy(rgbOID, 0, rgbReturn, 2, cb);
    
            return rgbReturn;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\hashalgorithm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// HashAlgorithm.cs
//

namespace System.Security.Cryptography {
    using System.IO;
    /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm"]/*' />
    public abstract class HashAlgorithm : ICryptoTransform {
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashSizeValue"]/*' />
        protected int               HashSizeValue;
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashValue"]/*' />
        protected byte[]            HashValue;
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.State"]/*' />
        protected int               State = 0;
        private bool       m_bDisposed = false;
      
        // *********************** CONSTRUCTORS *************************

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashAlgorithm"]/*' />
        protected HashAlgorithm() {
        }
    
        /********************* PROPERTY METHODS ************************/
    
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashSize"]/*' />
        public virtual int HashSize {
            get { return HashSizeValue; }
        }
      
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Hash"]/*' />
        public virtual byte[] Hash {
            get {
                if (m_bDisposed) 
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                if (State != 0) {
                    throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_HashNotYetFinalized"));
                }
                return (byte[]) HashValue.Clone();
            }
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Create"]/*' />
        static public HashAlgorithm Create() {
            return Create("System.Security.Cryptography.HashAlgorithm");
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Create1"]/*' />
        static public HashAlgorithm Create(String hashName) {
            return (HashAlgorithm) CryptoConfig.CreateFromName(hashName);
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.ComputeHash"]/*' />
        public byte[] ComputeHash(Stream inputStream) {
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            byte[] buffer = new byte[1024];
            int bytesRead;
            do {
                bytesRead = inputStream.Read(buffer,0,1024);
                if (bytesRead > 0) {
                    HashCore(buffer, 0, bytesRead);
                }
            } while (bytesRead > 0);
            HashValue = HashFinal();
            byte[] Tmp = (byte[]) HashValue.Clone();
            Initialize();
            return(Tmp);
        }
 
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.ComputeHash1"]/*' />
        public byte[] ComputeHash(byte[] buffer) {
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            
            // Do some validation
            if (buffer == null) throw new ArgumentNullException("buffer");
            
            HashCore(buffer, 0, buffer.Length);
            HashValue = HashFinal();
            byte[] Tmp = (byte[]) HashValue.Clone();
            Initialize();
            return(Tmp);
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.ComputeHash2"]/*' />
        public byte[] ComputeHash(byte[] buffer, int offset, int count) {
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Do some validation
            if (buffer == null) throw new ArgumentNullException("buffer");
            if (offset < 0) throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (count < 0 || (count > buffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((buffer.Length - count) < offset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            HashCore(buffer, offset, count);
            HashValue = HashFinal();
            byte[] Tmp = (byte[]) HashValue.Clone();
            Initialize();
            return(Tmp);
        }
    

        // ICryptoTransform methods

        // we assume any HashAlgorithm can take input a byte at a time
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.InputBlockSize"]/*' />
        public virtual int InputBlockSize { 
            get { return(1); }
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.OutputBlockSize"]/*' />
        public virtual int OutputBlockSize {
            get { return(1); }
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.CanTransformMultipleBlocks"]/*' />
        public virtual bool CanTransformMultipleBlocks { 
            get { return(true); }
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.CanReuseTransform"]/*' />
        public virtual bool CanReuseTransform { 
            get { return(true); }
        }

        // We implement TransformBlock and TransformFinalBlock here
        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.TransformBlock"]/*' />
        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) {
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Do some validation, we let InternalBlockCopy do the destination array validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            // Change the State value
            State = 1;
            HashCore(inputBuffer, inputOffset, inputCount);
            Buffer.InternalBlockCopy(inputBuffer, inputOffset, outputBuffer, outputOffset, inputCount);
            return(inputCount);
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.TransformFinalBlock"]/*' />
        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) {
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Do some validation
            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));

            HashCore(inputBuffer, inputOffset, inputCount);
            HashValue = HashFinal();
            byte[] outputBytes = new byte[inputCount];
            Buffer.InternalBlockCopy(inputBuffer, inputOffset, outputBytes, 0, inputCount);
            // reset the State value
            State = 0;
            return(outputBytes);
        }

        // IDisposable methods

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                // For hash algorithms, we always want to zero out the hash value
                if (HashValue != null) {
                    Array.Clear(HashValue, 0, HashValue.Length);
                }
                HashValue = null;
                m_bDisposed = true;
            }
        }

        // *** Abstract methods every HashAlgortihm must implement *** 

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.Initialize"]/*' />
        public abstract void Initialize();

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashCore"]/*' />
        protected abstract void HashCore(byte[] array, int ibStart, int cbSize);

        /// <include file='doc\HashAlgorithm.uex' path='docs/doc[@for="HashAlgorithm.HashFinal"]/*' />
        protected abstract byte[] HashFinal();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\dsasignatureformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  DSASignatureFormatter.cs
 *
 *  This file contains the DSA formatter.
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;

    /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter"]/*' />
    public class DSASignatureFormatter : AsymmetricSignatureFormatter
    {
        DSA     _dsaKey;
        String  _strOID;
    
        // *********************** CONSTRUCTORS ***************************

        /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter.DSASignatureFormatter"]/*' />
        public DSASignatureFormatter()
        {
            // The hash algorithm is always SHA1
            _strOID = CryptoConfig.MapNameToOID("SHA1");
        }

        /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter.DSASignatureFormatter1"]/*' />
        public DSASignatureFormatter(AsymmetricAlgorithm key) {
            SetKey(key);
            // The hash algorithm is always SHA1
            _strOID = CryptoConfig.MapNameToOID("SHA1");
        }

        /************************* PUBLIC METHODS *************************/

        /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _dsaKey = (DSA) key;
        }

        /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter.SetHashAlgorithm"]/*' />
        public override void SetHashAlgorithm(String strName)
        {
            if (CryptoConfig.MapNameToOID(strName) != _strOID)
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_InvalidOperation"));
        }

        /// <include file='doc\DSASignatureFormatter.uex' path='docs/doc[@for="DSASignatureFormatter.CreateSignature"]/*' />
        public override byte[] CreateSignature(byte[] rgbHash)
        {
            byte[]          rgbSig;

            if (_strOID == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingOID"));
            }
            if (_dsaKey == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingKey"));
            }
            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }

            rgbSig = _dsaKey.CreateSignature(rgbHash);
        
            return rgbSig;
        }
    
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\handleprotection.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

/*============================================================
**
** Class:  HandleProtection
**
** This file is hosting all inheritors of System.Threading.__HandleProtector
** that are used in Crypto classes to protect against handle 
** recycling issues
**
** Date:   December 12, 2001
**
===========================================================*/

namespace System.Security.Cryptography {
    using System;
    using System.Runtime.CompilerServices;
    using System.Threading;

    internal sealed class __CSPHandleProtector : __HandleProtector
    {
        private bool _persistKeyInCsp;
        private CspParameters _parameters;

        internal __CSPHandleProtector(IntPtr handle, bool persistKeyInCsp, CspParameters parameters) : base(handle)
        {
            _persistKeyInCsp = persistKeyInCsp;
            _parameters = parameters;
        }

        internal bool PersistKeyInCsp {
            get { return _persistKeyInCsp; }
            set { _persistKeyInCsp = value; }
        }

        protected internal override void FreeHandle(IntPtr handle)
        {
            if (handle != IntPtr.Zero) {
                if (_persistKeyInCsp == false) {
                    _DeleteKeyContainer(_parameters, handle);
                }
                _FreeCSP(handle);
                handle = IntPtr.Zero;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _DeleteKeyContainer(CspParameters param, IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeCSP(IntPtr hCSP);
    }

    internal sealed class __KeyHandleProtector : __HandleProtector
    {
        internal __KeyHandleProtector(IntPtr handle) : base(handle)
        {
        }

        protected internal override void FreeHandle(IntPtr handle)
        {
            if (handle != IntPtr.Zero) {
                _FreeHKey(handle);
                handle = IntPtr.Zero;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeHKey(IntPtr hKey);
    }

    internal sealed class __HashHandleProtector : __HandleProtector
    {
        internal __HashHandleProtector(IntPtr handle) : base(handle)
        {
        }

        protected internal override void FreeHandle(IntPtr handle)
        {
            if (handle != IntPtr.Zero) {
                _FreeHash(handle);
                handle = IntPtr.Zero;
            }
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeHash(IntPtr hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\icryptotransform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * ICryptoTransform.cs
 *
 * Author: bal
 *
 */

namespace System.Security.Cryptography {
    using System;
    using System.IO;

    /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform"]/*' />
    public interface ICryptoTransform : IDisposable {

        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.InputBlockSize"]/*' />
        int InputBlockSize { get; }

        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.OutputBlockSize"]/*' />
        int OutputBlockSize { get; }

        // CanTransformMultipleBlocks == true implies that TransformBlock() can accept any number
        // of whole blocks, not just a single block.  If CanTransformMultipleBlocks is false, you have
        // to feed blocks one at a time.  
        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.CanTransformMultipleBlocks"]/*' />
        bool CanTransformMultipleBlocks { get; }

        // If CanReuseTransform is true, then after a call to TransformFinalBlock() the transform
        // resets its internal state to its initial configuration (with Key and IV loaded) and can
        // be used to perform another encryption/decryption.
        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.CanReuseTransform"]/*' />
        bool CanReuseTransform { get; }

        // The return value of TransformBlock is the number of bytes returned to outputBuffer and is
        // always <= OutputBlockSize.  If CanTransformMultipleBlocks is true, then inputCount may be
        // any positive multiple of InputBlockSize
        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.TransformBlock"]/*' />
        int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);

        // Special function for transforming the last block or partial block in the stream.  The
        // return value is an array containting the remaining transformed bytes.
        // We return a new array here because the amount of information we send back at the end could 
        // be larger than a single block once padding is accounted for.
        /// <include file='doc\ICryptoTransform.uex' path='docs/doc[@for="ICryptoTransform.TransformFinalBlock"]/*' />
        byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\keyedhashalgorithm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// KeyedHashAlgorithm.cs
//

namespace System.Security.Cryptography {
    /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm"]/*' />
    public abstract class KeyedHashAlgorithm : HashAlgorithm
    {
        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.KeyValue"]/*' />
        protected byte[]        KeyValue;
        
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.KeyedHashAlgorithm"]/*' />
        protected KeyedHashAlgorithm() {
        }

        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.Finalize"]/*' />
        ~KeyedHashAlgorithm() {
            Dispose(false);
        }

        // IDisposable methods

        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            // For keyed hash algorithms, we always want to zero out the key value
            if (disposing) {
                if (KeyValue != null) {
                    Array.Clear(KeyValue, 0, KeyValue.Length);
                }
                KeyValue = null;
            }
            base.Dispose(disposing);
        }

        /*********************** Property Methods ***********************/

        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.Key"]/*' />
        public virtual byte[] Key {
            get { return (byte[]) KeyValue.Clone(); }
            set {
                if (State != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_HashKeySet"));
                }
                KeyValue = (byte[]) value.Clone();
            }
        }

        /*********************  Public Methods **************************/

        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.Create"]/*' />
        new static public KeyedHashAlgorithm Create() {
            return Create("System.Security.Cryptography.KeyedHashAlgorithm");
        }

        /// <include file='doc\KeyedHashAlgorithm.uex' path='docs/doc[@for="KeyedHashAlgorithm.Create1"]/*' />
        new static public KeyedHashAlgorithm Create(String algName) {
            return (KeyedHashAlgorithm) CryptoConfig.CreateFromName(algName);    
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\hmacsha1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// HMACSHA1.cs
//

//
// For test vectors, see RFC2104, e.g. http://www.faqs.org/rfcs/rfc2104.html
//

namespace System.Security.Cryptography {
    using System.IO;
    
    /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1"]/*' />
    public class HMACSHA1 : KeyedHashAlgorithm 
    {
        private SHA1            _hash1;
        private SHA1            _hash2;
        private String          _strHashName;
        private bool            _bHashing = false;
        
        // _rgbInner = PaddedKey ^ {0x36,...,0x36}
        // _rgbOuter = PaddedKey ^ {0x5C,...,0x5C}
        private byte[]          _rgbInner = new byte[64];
        private byte[]          _rgbOuter = new byte[64];
           
        
        // *********************** CONSTRUCTORS *************************

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.HMACSHA1"]/*' />
        public HMACSHA1() {
            _strHashName = "SHA1";
            HashSizeValue = 160;
            // create the hash algorithms
            _hash1 = SHA1.Create();
            _hash2 = SHA1.Create();
            // Generate the key
            KeyValue = new byte[64];
            RandomNumberGenerator _rng = RandomNumberGenerator.Create();
            _rng.GetBytes(KeyValue);
            // Compute _rgbInner and _rgbOuter
            int i = 0;
            for (i=0; i<64; i++) { 
                _rgbInner[i] = 0x36;
                _rgbOuter[i] = 0x5C;
            }
            for (i=0; i<KeyValue.Length; i++) {
                _rgbInner[i] ^= KeyValue[i];
                _rgbOuter[i] ^= KeyValue[i];
            }
        }
    
        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.HMACSHA11"]/*' />
        public HMACSHA1(byte[] rgbKey) {
            _strHashName = "SHA1";
            HashSizeValue = 160;
            // create the hash algorithms
            _hash1 = SHA1.Create();
            _hash2 = SHA1.Create();
            // Get the key
            if (rgbKey.Length > 64) {
                KeyValue = _hash1.ComputeHash(rgbKey);
                // No need to call Initialize, ComputeHash will do it for us
            }
            else
                KeyValue = (byte[]) rgbKey.Clone();
            // Compute _rgbInner and _rgbOuter
            int i = 0;
            for (i=0; i<64; i++) { 
                _rgbInner[i] = 0x36;
                _rgbOuter[i] = 0x5C;
            }
            for (i=0; i<KeyValue.Length; i++) {
                _rgbInner[i] ^= KeyValue[i];
                _rgbOuter[i] ^= KeyValue[i];
            }
        }

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.Finalize"]/*' />
        ~HMACSHA1() {
            Dispose(false);
        }

        // ********************* Property Methods **********************

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.Key"]/*' />
        public override byte[] Key {
            get { return (byte[]) KeyValue.Clone(); }
            set {
                if (_bHashing) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_HashKeySet"));
                }
                if (value.Length > 64) {
                    KeyValue = _hash1.ComputeHash(value);
                    // No need to call Initialize, ComputeHash will do it for us
                }
                else
                    KeyValue = (byte[]) value.Clone();
                // Compute _rgbInner and _rgbOuter
                int i = 0;
                for (i=0; i<64; i++) { 
                    _rgbInner[i] = 0x36;
                    _rgbOuter[i] = 0x5C;
                }
                for (i=0; i<KeyValue.Length; i++) {
                    _rgbInner[i] ^= KeyValue[i];
                    _rgbOuter[i] ^= KeyValue[i];
                }
            }
        }

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.HashName"]/*' />
        public String HashName {
            get { return _strHashName; }
            // Yes, you might want to set the hash name to something other
            // than 'SHA1' if you want a particular *implementation* of SHA1
            set { 
                if (_bHashing)
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_HashNameSet"));
                _strHashName = value; 
                // create the hash algorithms
                _hash1 = SHA1.Create(_strHashName);
                _hash2 = SHA1.Create(_strHashName);
            }
        }

        // ********************* Public Methods ************************

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.Initialize"]/*' />
        public override void Initialize() {
            _hash1.Initialize();
            _hash2.Initialize();
            _bHashing = false;
        }

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ib, int cb) {
            if (_bHashing == false) {
                _hash1.TransformBlock(_rgbInner, 0, 64, _rgbInner, 0);
                _bHashing = true;                
            }
            _hash1.TransformBlock(rgb, ib, cb, rgb, ib);
        }

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            if (_bHashing == false) {
                _hash1.TransformBlock(_rgbInner, 0, 64, _rgbInner, 0);
                _bHashing = true;                
            }
            // finalize the original hash
            _hash1.TransformFinalBlock(new byte[0], 0, 0);
            // write the outer array
            _hash2.TransformBlock(_rgbOuter, 0, 64, _rgbOuter, 0);
            // write the inner hash and finalize the hash
            _hash2.TransformFinalBlock(_hash1.Hash, 0, _hash1.Hash.Length);
            _bHashing = false;
            return _hash2.Hash;
        }
        
        // IDisposable methods

        /// <include file='doc\HMACSHA1.uex' path='docs/doc[@for="HMACSHA1.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // We always want to dispose _hash1
                if (_hash1 != null) {
                    _hash1.Clear();
                }
                // We always want to dispose _hash2
                if (_hash2 != null) {
                    _hash2.Clear();
                }
                // We want to zeroize _rgbInner and _rgbOuter
                if (_rgbInner != null) {
                    Array.Clear(_rgbInner, 0, _rgbInner.Length);
                }
                if (_rgbOuter != null) {
                    Array.Clear(_rgbOuter, 0, _rgbOuter.Length);
                }
            }
            // call the base class's Dispose
            base.Dispose(disposing);
        }

        // ********************* Private  Methods **********************
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\maskgenerationmethod.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;

    /// <include file='doc\MaskGenerationMethod.uex' path='docs/doc[@for="MaskGenerationMethod"]/*' />
    public abstract class MaskGenerationMethod {
        /******************** Public Methods *******************************/

        /// <include file='doc\MaskGenerationMethod.uex' path='docs/doc[@for="MaskGenerationMethod.GenerateMask"]/*' />
        abstract public byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\md5.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// MD5.cs
//

namespace System.Security.Cryptography {
    /// <include file='doc\MD5.uex' path='docs/doc[@for="MD5"]/*' />
    public abstract class MD5 : HashAlgorithm
    {
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\MD5.uex' path='docs/doc[@for="MD5.MD5"]/*' />
        protected MD5() {
            HashSizeValue = 128;
        }
    
        /********************* PROPERTY METHODS ************************/
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\MD5.uex' path='docs/doc[@for="MD5.Create"]/*' />
        new static public MD5 Create() {
            return Create("System.Security.Cryptography.MD5");
        }

        /// <include file='doc\MD5.uex' path='docs/doc[@for="MD5.Create1"]/*' />
        new static public MD5 Create(String algName) {
            return (MD5) CryptoConfig.CreateFromName(algName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\md5cryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//  MD5CryptoServiceProvider.cs
//
//
// This file contains the wrapper object to get to the CSP versions of the
//  crypto libraries



namespace System.Security.Cryptography {
	using System.Runtime.CompilerServices;
    using System.Threading;

    /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider"]/*' />
    public sealed class MD5CryptoServiceProvider : MD5
    {
        private const int ALG_CLASS_HASH = (4 << 13);
        private const int ALG_TYPE_ANY   = (0);
        private const int CALG_MD5       = (ALG_CLASS_HASH | ALG_TYPE_ANY | 3);
        
        private CspParameters      _cspParams;
        private IntPtr             _hHash;
        private __HashHandleProtector _HashHandleProtector = null;
    
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.MD5CryptoServiceProvider"]/*' />
        public MD5CryptoServiceProvider() : this(new CspParameters()) {
        }
    
        private static IntPtr _zeroPointer = IntPtr.Zero;

        private MD5CryptoServiceProvider(CspParameters cspParams)
        {
            _cspParams = cspParams;

            if (SharedStatics.Crypto_MD5CryptoServiceProviderContext == _zeroPointer) {
                IntPtr hCSP = IntPtr.Zero;
                int hr = _AcquireCSP(_cspParams, ref hCSP);
                if (hCSP == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
                }
                SharedStatics.Crypto_MD5CryptoServiceProviderContext = hCSP;
                // next bit is in case we do two acquires...
                if (SharedStatics.Crypto_MD5CryptoServiceProviderContext != hCSP) {
                    _FreeCSP(hCSP);
                }
            }
            _hHash = _CreateHash(SharedStatics.Crypto_MD5CryptoServiceProviderContext, CALG_MD5);
            if (_hHash == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateHash"));
           }
            _HashHandleProtector = new __HashHandleProtector(_hHash);    
        }
    
        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.Finalize"]/*' />
        protected override void Dispose(bool disposing)
        {
            if (_HashHandleProtector != null && !_HashHandleProtector.IsClosed)
                _HashHandleProtector.Close();
            base.Dispose(disposing);
        }
    
        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.Finalize1"]/*' />
        ~MD5CryptoServiceProvider()
        {
            Dispose(false);
        }   
                 
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.Initialize"]/*' />
        public override void Initialize() {
            if (_HashHandleProtector != null && !_HashHandleProtector.IsClosed)
                _HashHandleProtector.Close();
            _hHash = _CreateHash(SharedStatics.Crypto_MD5CryptoServiceProviderContext, CALG_MD5);
            if (_hHash == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateHash"));
            }
            _HashHandleProtector = new __HashHandleProtector(_hHash);
        }
    
        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            bool incremented = false;
            try {
                if (_HashHandleProtector.TryAddRef(ref incremented)) {
                    _HashData(_HashHandleProtector.Handle, rgb, ibStart, cbSize);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _HashHandleProtector.Release();
            }
        }
      
        /// <include file='doc\MD5CryptoServiceProvider.uex' path='docs/doc[@for="MD5CryptoServiceProvider.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            bool incremented = false;
            byte[] result = null;
            try {
                if (_HashHandleProtector.TryAddRef(ref incremented)) {
                    result = _EndHash(_HashHandleProtector.Handle);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _HashHandleProtector.Release();
            }
            return result;
        }
        
        /************************* PRIVATE METHODS ************************/
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int  _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _CreateHash(IntPtr hCSP, int algid);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _EndHash(IntPtr hHash);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeHash(IntPtr hHash);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _HashData(IntPtr hHash, byte[] rgbData, int ibStart, int cbSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\pkcs1maskgenerationmethod.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;

    /// <include file='doc\PKCS1MaskGenerationMethod.uex' path='docs/doc[@for="PKCS1MaskGenerationMethod"]/*' />
    public class PKCS1MaskGenerationMethod : MaskGenerationMethod
    {
        private String          HashNameValue;

        /*********************** Private Methods ***************************/

		private static void ConvertIntToByteArray(uint dwInput, ref byte[] rgbCounter) {
			uint t1 = dwInput;  // t1 is remaining value to account for
			uint t2;  // t2 is t1 % 256
			int i = 0;

			// clear the array first
			Array.Clear(rgbCounter, 0, rgbCounter.Length);
			if (dwInput == 0) return;
			while (t1 > 0) {
                BCLDebug.Assert(i < 4, "Got too big an int here!");
				t2 = t1 % 256;
				rgbCounter[3 - i] = (byte) t2;
				t1 = (t1 - t2)/256;
				i++;
			}
		}

        /************************ Constructors *****************************/
        
        /// <include file='doc\PKCS1MaskGenerationMethod.uex' path='docs/doc[@for="PKCS1MaskGenerationMethod.PKCS1MaskGenerationMethod"]/*' />
        public PKCS1MaskGenerationMethod() {
            HashNameValue = "SHA1";
        }

        /********************** Properties ********************************/

        /// <include file='doc\PKCS1MaskGenerationMethod.uex' path='docs/doc[@for="PKCS1MaskGenerationMethod.HashName"]/*' />
        public String HashName {
            get { return HashNameValue; }
            set { 
                HashNameValue = value;
                if (HashNameValue == null) {
                    HashNameValue = "SHA1";
                }
            }
        }

        /*********************** Public Methods ***************************/

        /// <include file='doc\PKCS1MaskGenerationMethod.uex' path='docs/doc[@for="PKCS1MaskGenerationMethod.GenerateMask"]/*' />
        override public byte[] GenerateMask(byte[] rgbSeed, int cbReturn)
        {
            HashAlgorithm       hash;
            int                 ib;
            byte[]              rgbCounter = new byte[4];
            byte[]              rgbT = new byte[cbReturn];
			uint				counter = 0;		

            for (ib=0; ib<rgbT.Length; ) {
                //  Increment counter -- up to 2^32 * sizeof(Hash)
                ConvertIntToByteArray(counter++, ref rgbCounter);
                hash = (HashAlgorithm) CryptoConfig.CreateFromName(HashNameValue);
                byte[] temp = new byte[4+rgbSeed.Length];
                Buffer.InternalBlockCopy(rgbCounter, 0, temp, 0, 4);
                Buffer.InternalBlockCopy(rgbSeed, 0, temp, 4, rgbSeed.Length);
                hash.ComputeHash(temp);
                if (rgbT.Length - ib > hash.HashSize/8) {
                    Buffer.InternalBlockCopy(hash.Hash, 0, rgbT, ib, hash.Hash.Length);
                }
                else {
                    Buffer.InternalBlockCopy(hash.Hash, 0, rgbT, ib, rgbT.Length - ib);
                }
                ib += hash.Hash.Length;
            }
            return rgbT;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\mactripledes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * MACTripleDES.cs -- Implementation of the MAC-CBC keyed hash w/ 3DES
 *
 * @author t-ccaron
 *
 */

// See: http://www.itl.nist.gov/fipspubs/fip81.htm for a spec

namespace System.Security.Cryptography {
    using System.IO;
    using System.Runtime.InteropServices;

    /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES"]/*' />
    public class MACTripleDES : KeyedHashAlgorithm 
    {
        // Output goes to HashMemorySink since we don't care about the actual data
        private ICryptoTransform m_encryptor;
        private CryptoStream _cs;
        private TailStream _ts;
        private const int m_bitsPerByte = 8;
        private int m_bytesPerBlock;
        private TripleDES des;
  
        // ---------------------------- Constructors ----------------------------

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.MACTripleDES"]/*' />
        public MACTripleDES()
        {
            RandomNumberGenerator _rng;

            KeyValue = new byte[24];
            _rng = RandomNumberGenerator.Create();
            _rng.GetBytes(KeyValue);

            // Create a TripleDES encryptor
            des = TripleDES.Create();
            HashSizeValue = des.BlockSize;

            m_bytesPerBlock = des.BlockSize/m_bitsPerByte;
            // By definition, MAC-CBC-3DES takes an IV=0.  C# zero-inits arrays,
            // so all we have to do here is define it.
            des.IV = new byte[m_bytesPerBlock];
            des.Padding = PaddingMode.Zeros;

            m_encryptor = null;    
        }

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.MACTripleDES1"]/*' />
        public MACTripleDES(byte[] rgbKey) 
            : this("System.Security.Cryptography.TripleDES",rgbKey) { }

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.MACTripleDES2"]/*' />
        public MACTripleDES(String strTripleDES, byte[] rgbKey)
        {
            // Make sure we know which algorithm to use
            if (rgbKey == null)
                throw new ArgumentNullException("rgbKey");
            // Create a TripleDES encryptor
            if (strTripleDES == null) {
                des = TripleDES.Create();
            } else {
                des = TripleDES.Create(strTripleDES);
            }

            HashSizeValue = des.BlockSize;
            // Stash the key away
            KeyValue = (byte[]) rgbKey.Clone();

            m_bytesPerBlock = des.BlockSize/m_bitsPerByte;
            // By definition, MAC-CBC-3DES takes an IV=0.  C# zero-inits arrays,
            // so all we have to do here is define it.
            des.IV = new byte[m_bytesPerBlock];
            des.Padding = PaddingMode.Zeros;
    
            m_encryptor = null;
        }

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.Finalize"]/*' />
        ~MACTripleDES() {
            Dispose(false);
        }

        // ------------------------- Protected Methods --------------------------

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.Initialize"]/*' />
        public override void Initialize() {
            m_encryptor = null;            
        }

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.HashCore"]/*' />
        protected override void HashCore(byte[] rgbData, int ibStart, int cbSize)
        {
            // regenerate the TripleDES object before each call to ComputeHash
            if (m_encryptor == null) {
                des.Key = this.Key;
                m_encryptor = des.CreateEncryptor();
                _ts = new TailStream(des.BlockSize / 8); // 8 bytes
                _cs = new CryptoStream(_ts, m_encryptor, CryptoStreamMode.Write);   
            }

            // Encrypt using 3DES
            _cs.Write(rgbData, ibStart, cbSize);
        }

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.HashFinal"]/*' />
        protected override byte[] HashFinal()
        {
            // If Hash has been called on a zero buffer
            if (m_encryptor == null) {
                des.Key = this.Key;
                m_encryptor = des.CreateEncryptor();
                _ts = new TailStream(des.BlockSize / 8); // 8 bytes 
                _cs = new CryptoStream(_ts, m_encryptor, CryptoStreamMode.Write);   
            }

            // Finalize the hashing and return the result
            _cs.Close();
            return(_ts.Buffer);
        }

        // IDisposable methods

        /// <include file='doc\mactripleDES.uex' path='docs/doc[@for="MACTripleDES.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // dispose of our internal state
                if (des != null) {
                    des.Clear();
                }
                if (m_encryptor != null) {
                    m_encryptor.Dispose();
                }
                if (_cs != null) {
                    _cs.Clear();
                }
                if (_ts != null) {
                    _ts.Clear();
                }
            }
            base.Dispose(disposing);
        }

    }

    //
    // TailStream is another utility class -- it remembers the last n bytes written to it
    // This is useful for MAC-3DES since we need to capture only the result of the last block

    internal class TailStream : Stream, IDisposable {
        private byte[] _Buffer;
        private int _BufferSize;
        private int _BufferIndex = 0;
        private bool _BufferFull = false;

        public TailStream(int bufferSize) {
            _Buffer = new byte[bufferSize];
            _BufferSize = bufferSize;
        }

        ~TailStream() {
            Dispose(false);
        }

        // IDisposable methods

        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (_Buffer != null) {
                    Array.Clear(_Buffer, 0, _Buffer.Length);
                }
                _Buffer = null;
            }
        }

        public byte[] Buffer {
            get { return (byte[]) _Buffer.Clone(); }
        }

        public override bool CanRead {
            get { return false; }
        }

        public override bool CanSeek {
            get { return false; }
        }

        public override bool CanWrite {
            get { return true; }
        }

        public override long Length {
            get { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
        }

        public override long Position {
            get { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
            set { throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream")); }
        }

        public override void Close() {
            return;
        }

        public override void Flush() {
            return;
        }

        public override long Seek(long offset, SeekOrigin origin) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream"));
        }

        public override void SetLength(long value) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnseekableStream"));
        }

        public override int Read([In, Out] byte[] buffer, int offset, int count) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_UnreadableStream"));
        }

        public override void Write(byte[] buffer, int offset, int count) {
            // If no bytes to write, then return
            if (count == 0) return;
            // The most common case will be when we have a full buffer
            if (_BufferFull) {
                // if more bytes are written in this call than the size of the buffer,
                // just remember the last _BufferSize bytes
                if (count > _BufferSize) {
                    System.Buffer.InternalBlockCopy(buffer, offset+count-_BufferSize, _Buffer, 0, _BufferSize);
                    return;
                } else {
                    // move _BufferSize - count bytes left, then copy the new bytes
                    System.Buffer.InternalBlockCopy(_Buffer, _BufferSize - count, _Buffer, 0, _BufferSize - count);
                    System.Buffer.InternalBlockCopy(buffer, offset, _Buffer, _BufferSize - count, count);
                    return;
                }
            } else {
                // buffer isn't full yet, so more cases
                if (count > _BufferSize) {
                    System.Buffer.InternalBlockCopy(buffer, offset+count-_BufferSize, _Buffer, 0, _BufferSize);
                    _BufferFull = true;
                    return;
                } else if (count + _BufferIndex >= _BufferSize) {
                    System.Buffer.InternalBlockCopy(_Buffer, _BufferIndex+count-_BufferSize, _Buffer, 0, _BufferSize - count);
                    System.Buffer.InternalBlockCopy(buffer, offset, _Buffer, _BufferIndex, count);
                    _BufferFull = true;
                    return;
                } else {
                    System.Buffer.InternalBlockCopy(buffer, offset, _Buffer, _BufferIndex, count);
                    _BufferIndex += count;
                    return;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\passwordderivebytes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// PasswordDerivedBytes.cs
//

namespace System.Security.Cryptography {

    using System.IO;
    using System.Text;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.CompilerServices;

    /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes"]/*' />
    public class PasswordDeriveBytes : DeriveBytes
    {
        private int             _ibExtra;
        private int             _iPrefix;
        private int             _iterations;
        private byte[]          _rgbBaseValue;
        private byte[]          _rgbExtra;
        private byte[]          _rgbSalt;
        private String          _strHashName;
        private String          _strPassword;
        private HashAlgorithm   _hash;
        private CspParameters   _cspParams;
        private IntPtr          _hCSP;          // Handle to the CSP
        
        // *********************** Constructors ****************************

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.PasswordDeriveBytes"]/*' />
        public PasswordDeriveBytes(String strPassword, byte[] rgbSalt) : this(strPassword, rgbSalt, new CspParameters()) {

        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.PasswordDeriveBytes1"]/*' />
        public PasswordDeriveBytes(String strPassword, byte[] rgbSalt, String strHashName, int iterations) : 
            this(strPassword, rgbSalt, strHashName, iterations, new CspParameters()) {

        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.PasswordDeriveBytes2"]/*' />
        public PasswordDeriveBytes(String strPassword, byte[] rgbSalt, CspParameters cspParams) {
            _strPassword = strPassword;
            _rgbSalt = rgbSalt;
            _iterations = 100;
            _strHashName = "SHA1";
            _hash = SHA1.Create();
            _hCSP = IntPtr.Zero;
            _cspParams = cspParams;
        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.PasswordDeriveBytes3"]/*' />
        public PasswordDeriveBytes(String strPassword, byte[] rgbSalt,
                                    String strHashName, int iterations, CspParameters cspParams) {
            if (iterations <= 0)
                throw new ArgumentOutOfRangeException("iterations", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            _strPassword = strPassword;
            _rgbSalt = rgbSalt;
            _strHashName = strHashName;
            _iterations = iterations;
            _hash = (HashAlgorithm) CryptoConfig.CreateFromName(_strHashName);
            _hCSP = IntPtr.Zero;
            _cspParams = cspParams;
        }


        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.Finalize"]/*' />
        ~PasswordDeriveBytes()
        {
            if (_hCSP != IntPtr.Zero) {
                _FreeCSP(_hCSP);
                _hCSP = IntPtr.Zero;
            }
        }

        
        // ********************* Property Methods **************************

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.HashName"]/*' />
        public String HashName {
            get { return _strHashName; }
            set { 
                if (_rgbBaseValue != null) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_ValuesFixed"),"HashName"));
                }
                _strHashName = value;
                _hash = (HashAlgorithm) CryptoConfig.CreateFromName(_strHashName);
            }
        }
        
        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.IterationCount"]/*' />
        public int IterationCount {
            get { return _iterations; }
            set { 
                if (_rgbBaseValue != null) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_ValuesFixed"),"IterationCount"));
                }
                _iterations = value;
            }
        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.Salt"]/*' />
        public byte[] Salt {
            get { 
                if (_rgbSalt == null) return(null);
                return (byte[]) _rgbSalt.Clone(); }
            set { 
                if (_rgbBaseValue != null) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_ValuesFixed"),"Salt"));
                }
                _rgbSalt = (byte[]) value.Clone();
            }
        }

        // ********************** Public Methods ***************************

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.GetBytes"]/*' />
        public override byte[] GetBytes(int cb) {
            int         ib = 0;
            byte[]      rgb;
            byte[]      rgbOut = new byte[cb];

            if (_rgbBaseValue == null) {
                ComputeBaseValue();
            }
            else if (_rgbExtra != null) {
                ib = _rgbExtra.Length - _ibExtra;
                if (ib >= cb) {
                    Buffer.InternalBlockCopy(_rgbExtra, _ibExtra, rgbOut, 0, cb);
                    if (ib > cb) {
                        _ibExtra += cb;
                    }
                    else {
                        _rgbExtra = null;
                    }
                    return rgbOut;
                }
                else {
                    Buffer.InternalBlockCopy(_rgbExtra, ib, rgbOut, 0, ib);
                    _rgbExtra = null;
                }
            }

            rgb = ComputeBytes(cb-ib);
            Buffer.InternalBlockCopy(rgb, 0, rgbOut, ib, cb-ib);
            if (rgb.Length + ib > cb) {
                _rgbExtra = rgb;
                _ibExtra = cb-ib;
            }
            return rgbOut;
        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.Reset"]/*' />
        public override void Reset() {
            _iPrefix = 0;
            _rgbExtra = null;
        }

        /// <include file='doc\PasswordDeriveBytes.uex' path='docs/doc[@for="PasswordDeriveBytes.CryptDeriveKey"]/*' />
        public byte[] CryptDeriveKey(String algname, String alghashname, int keySize, byte[] rgbIV) {
            int             hr;
            int             algid;
            int             algidhash;
            int             dwFlags = 0;

            if (keySize < 0)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));

            if (_hCSP == IntPtr.Zero) {
                hr = _AcquireCSP(_cspParams, ref _hCSP);
                if (_hCSP == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
                }
            }
            //  Convert password to UTF8 string
            byte[] rgbPwd = (new UTF8Encoding(false)).GetBytes(_strPassword);

            // Form the correct dwFlags
            dwFlags |= (keySize << 16); 

            algidhash = CryptoConfig.MapNameToCalg(alghashname);
            if (algidhash == 0) throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_InvalidAlgorithm"));
            algid = CryptoConfig.MapNameToCalg(algname);
            if (algid == 0) throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_InvalidAlgorithm"));
            
            // Validate the rgbIV array 
            SymmetricAlgorithm symAlg = (SymmetricAlgorithm) CryptoConfig.CreateFromName(algname);
            if (symAlg == null) throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_InvalidAlgorithm"));
            if (rgbIV == null || rgbIV.Length != symAlg.BlockSize / 8) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_InvalidIV"));
        
            byte[] rgbKey = _CryptDeriveKey(_hCSP, algid, algidhash, rgbPwd, dwFlags, rgbIV);
            GC.KeepAlive(this);
            return rgbKey;
        }

        /************************* PRIVATE METHODS ************************/
    
        private byte[] ComputeBaseValue() {
            int             i;
            byte[]          rgbPassword;
            
            //  Convert password to UTF8 string
            rgbPassword = (new UTF8Encoding(false)).GetBytes(_strPassword);

            _hash.Initialize();
            CryptoStream cs = new CryptoStream(Stream.Null, _hash, CryptoStreamMode.Write);
            cs.Write(rgbPassword, 0, rgbPassword.Length);
            if (_rgbSalt != null) {
                cs.Write(_rgbSalt, 0, _rgbSalt.Length);
            }
            cs.Close();

            _rgbBaseValue = _hash.Hash;
            _hash.Initialize();            

            for (i=1; i<(_iterations - 1); i++) {
                _hash.ComputeHash(_rgbBaseValue);
                _rgbBaseValue = _hash.Hash;
            }

            _strPassword = null;
            return _rgbBaseValue;
        }

        private byte[] ComputeBytes(int cb) {
            int                 cbHash;
            int                 ib = 0;
            byte[]              rgb;

            _hash.Initialize();
            cbHash = _hash.HashSize / 8;
            rgb = new byte[((cb+cbHash-1)/cbHash)*cbHash];

            CryptoStream cs = new CryptoStream(Stream.Null, _hash, CryptoStreamMode.Write);
            HashPrefix(cs);
            cs.Write(_rgbBaseValue, 0, _rgbBaseValue.Length);
            cs.Close();
            Buffer.InternalBlockCopy(_hash.Hash, 0, rgb, ib, cbHash);
            ib += cbHash;

            while (cb > ib) {
                _hash.Initialize();
                cs = new CryptoStream(Stream.Null, _hash, CryptoStreamMode.Write);
                HashPrefix(cs);
                cs.Write(_rgbBaseValue, 0, _rgbBaseValue.Length);
                cs.Close();
                Buffer.InternalBlockCopy(_hash.Hash, 0, rgb, ib, cbHash);
                ib += cbHash;
            }

            return rgb;
        }

        void HashPrefix(CryptoStream cs) {
            int         cb = 0;
            byte[]      rgb = {(byte)'0', (byte)'0', (byte)'0'};

            if (_iPrefix > 999) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_TooManyBytes"));
            }

            if (_iPrefix >= 100) {
                rgb[0] += (byte) (_iPrefix /100);
                cb += 1;
            }
            if (_iPrefix >= 10) {
                rgb[cb] += (byte) ((_iPrefix % 100) / 10);
                cb += 1;
            }
            if (_iPrefix > 0) {
                rgb[cb] += (byte) (_iPrefix % 10);
                cb += 1;
                cs.Write(rgb, 0, cb);
            }
            
            _iPrefix += 1;
        }
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int  _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _CryptDeriveKey(IntPtr hCSP, int algid, int algidHash, byte[] rgbPwd, int dwFlags, byte[] rgbIV);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\randomnumbergenerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// RandomNumberGenerator.cs
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator"]/*' />
    public abstract class RandomNumberGenerator {
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator.RandomNumberGenerator"]/*' />
        public RandomNumberGenerator() {
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator.Create"]/*' />
        static public RandomNumberGenerator Create() {
            return Create("System.Security.Cryptography.RandomNumberGenerator");
        }

        /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator.Create1"]/*' />
        static public RandomNumberGenerator Create(String rngName) {
            return (RandomNumberGenerator) CryptoConfig.CreateFromName(rngName);
        }
    
        /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator.GetBytes"]/*' />
        public abstract void GetBytes(byte[] data);

        /// <include file='doc\RandomNumberGenerator.uex' path='docs/doc[@for="RandomNumberGenerator.GetNonZeroBytes"]/*' />
        public abstract void GetNonZeroBytes(byte[] data);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rc2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// RC2.cs
//

namespace System.Security.Cryptography {
    using SecurityElement = System.Security.SecurityElement;

    /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2"]/*' />
    public abstract class RC2 : SymmetricAlgorithm
    {
        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.EffectiveKeySizeValue"]/*' />
        protected int               EffectiveKeySizeValue;
        private static  KeySizes[] s_legalBlockSizes = {
          new KeySizes(64, 64, 0)
        };
        private static  KeySizes[] s_legalKeySizes = {
            new KeySizes(40, 1024, 8)  // 1024 bits is theoretical max according to the RFC
        };
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.RC2"]/*' />
        public RC2() {
            KeySizeValue = 128;
            BlockSizeValue = 64;
            FeedbackSizeValue = BlockSizeValue;
            LegalBlockSizesValue = s_legalBlockSizes;
            LegalKeySizesValue = s_legalKeySizes;
        }
    
        /*********************** PROPERTY METHODS ************************/

        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.EffectiveKeySize"]/*' />
        public virtual int EffectiveKeySize {
            get {
                if (EffectiveKeySizeValue == 0) return KeySizeValue;
                return EffectiveKeySizeValue;
            }
            set {
                if (value > KeySizeValue) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_RC2_EKSKS"));
                } else if (value == 0) {
                    EffectiveKeySizeValue = value;
                } else if (value < 40) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_RC2_EKS40"));
                } else {
                    if (ValidKeySize(value))
                        EffectiveKeySizeValue = value;
                    else
                        throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
                }
            }
        }

        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.KeySize"]/*' />
        public override int KeySize {
            get { return KeySizeValue; }
            set { 
                if (value < EffectiveKeySizeValue) throw new CryptographicException(Environment.GetResourceString("Cryptography_RC2_EKSKS"));
                base.KeySize = value;
            }
        }
        
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.Create"]/*' />
        new static public RC2 Create() {
            return Create("System.Security.Cryptography.RC2");
        }

        /// <include file='doc\RC2.uex' path='docs/doc[@for="RC2.Create1"]/*' />
        new static public RC2 Create(String AlgName) {
            return (RC2) CryptoConfig.CreateFromName(AlgName);
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rc2cryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//  RC2
//
//
// This file contains the wrapper object to get to the CSP versions of the
//  crypto libraries

namespace System.Security.Cryptography {
    using System.Runtime.CompilerServices;
    using SecurityElement = System.Security.SecurityElement;
    /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider"]/*' />
    public sealed class RC2CryptoServiceProvider : RC2
    {
        private const int KP_IV                  = 1;
        private const int KP_MODE                = 4;
        private const int KP_MODE_BITS           = 5;
        private const int KP_EFFECTIVE_KEYLEN    = 19;

        private const int ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const int ALG_TYPE_BLOCK      = (3 << 9);
        private const int CALG_RC2        = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 2 );

        private RNGCryptoServiceProvider             _rng;
        private CspParameters          _cspParams = null;

        private static  KeySizes[] s_legalKeySizes = {
            new KeySizes(40, 128, 8)  // cryptoAPI implementation only goes up to 128
        };
      
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.RC2CryptoServiceProvider"]/*' />
        public RC2CryptoServiceProvider() {
            // Acquire a Type 1 provider.  This will be the Enhanced provider if available, otherwise 
            // it will be the base provider.
            LegalKeySizesValue = s_legalKeySizes;

            IntPtr trialCSPHandle = IntPtr.Zero;
            int trialHR = 0;
            int hasRC2HR = 0;
            CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
            trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
            if (trialCSPHandle == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            } 
            // OK, now see if CALG_RC2 is present in the provider we got back
            // Don't bother checking keysize now since we will when we create the encryptor/decryptor
            hasRC2HR = _SearchForAlgorithm(trialCSPHandle, CALG_RC2, 0);
            _FreeCSP(trialCSPHandle);
            if (hasRC2HR != 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            }
            // Since the CSP only supports a CFB feedback of 8, make that the default
            FeedbackSizeValue = 8;
            // gen random key & IV, in case the user never sets one explicitly
            GenerateKey();
            GenerateIV();
        }
    
        /*********************** PROPERTY METHODS ************************/

        /************************* PUBLIC METHODS ************************/
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.EffectiveKeySize"]/*' />
        public override int EffectiveKeySize {
            get {
				return KeySizeValue;
			}
            set {
				if (value != KeySizeValue)
					throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_RC2_EKSKS2"));
            }
        }
    
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.CreateEncryptor"]/*' />
        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
        {
            return _NewEncryptor(rgbKey, ModeValue, rgbIV, EffectiveKeySizeValue, 
                                 FeedbackSizeValue);
        }
      
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.CreateDecryptor"]/*' />
        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
        {
            return _NewDecryptor(rgbKey, ModeValue, rgbIV, EffectiveKeySizeValue,
                                 FeedbackSizeValue);
        }
      
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.GenerateKey"]/*' />
        public override void GenerateKey()
        {
            // respect KeySizeValue
            KeyValue = new byte[KeySizeValue/8];
            RNG.GetBytes(KeyValue);
        }
  
        /// <include file='doc\RC2CryptoServiceProvider.uex' path='docs/doc[@for="RC2CryptoServiceProvider.GenerateIV"]/*' />
        public override void GenerateIV()
        {
            // block size is always 64 bits so IV is always 64 bits == 8 bytes
            IVValue = new byte[8];
            RNG.GetBytes(IVValue);
        }
    
        /************************* PRIVATE METHODS ************************/

        private RNGCryptoServiceProvider RNG {
            get { if (_rng == null) { _rng = new RNGCryptoServiceProvider(); } return _rng; }
        }
    
        private ICryptoTransform _NewDecryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV,
                                               int effectiveKeySize, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];

            // Check for bad values
            // 1) we don't support OFB mode in RC2_CSP
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             
		
			// Check the rgbKey size
			if (rgbKey == null) throw new ArgumentNullException("rgbKey");
			if (!ValidKeySize(rgbKey.Length * 8)) throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));

            // Build the key if one does not already exist
            // respect KeySizeValue here
            if (rgbKey == null) {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            //  Deal with effective key length questions
            rgArgIds[cArgs] = KP_EFFECTIVE_KEYLEN;
            if (EffectiveKeySizeValue == 0) {
                rgArgValues[cArgs] = rgbKey.Length * 8;
            }
            else {
                rgArgValues[cArgs] = effectiveKeySize;
            }
            cArgs += 1;

            //  Set the mode for the encryptor (defaults to CBC)

            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            //  If not ECB mode -- pass in an IV

            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            // Make sure the requested key size is supported
            {
                IntPtr trialCSPHandle = IntPtr.Zero;
                int trialHR = 0;
                int hasRC2HR = 0;
                CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
                trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
                if (trialCSPHandle == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
                } 
                // OK, now see if key size is supported
                hasRC2HR = _SearchForAlgorithm(trialCSPHandle, CALG_RC2, KeySizeValue);
                _FreeCSP(trialCSPHandle);
                if (hasRC2HR != 0) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_CSP_AlgKeySizeNotAvailable"),KeySizeValue));
                }
            }

            //  Create the encryptor object

            return new CryptoAPITransform("RC2", CALG_RC2, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue, 
                                          mode, BlockSizeValue, feedbackSize,
                                          CryptoAPITransformMode.Decrypt);
        }
    
        private ICryptoTransform _NewEncryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV,
                                               int effectiveKeySize, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];

            // Check for bad values
            // 1) we don't support OFB mode in RC2_CSP
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             

			// Check the rgbKey size
			if (rgbKey == null) throw new ArgumentNullException("rgbKey");
			if (!ValidKeySize(rgbKey.Length * 8)) throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));

            // Build the key if one does not already exist
            // Respect KeySizeValue here
            if (rgbKey == null) {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            //  Deal with effective key length questions
            rgArgIds[cArgs] = KP_EFFECTIVE_KEYLEN;
            if (EffectiveKeySizeValue == 0) {
                rgArgValues[cArgs] = rgbKey.Length << 3;
            }
            else {
                rgArgValues[cArgs] = effectiveKeySize;
            }
            cArgs += 1;

            //  Set the mode for the encryptor (defaults to CBC)

            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            //  If not ECB mode -- pass in an IV

            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            // Make sure the requested key size is supported
            {
                IntPtr trialCSPHandle = IntPtr.Zero;
                int trialHR = 0;
                int hasRC2HR = 0;
                CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
                trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
                if (trialCSPHandle == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
                } 
                // OK, now see if key size is supported
                hasRC2HR = _SearchForAlgorithm(trialCSPHandle, CALG_RC2, KeySizeValue);
                _FreeCSP(trialCSPHandle);
                if (hasRC2HR != 0) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_CSP_AlgKeySizeNotAvailable"),KeySizeValue));
                }
            }

            //  Create the encryptor object

            return new CryptoAPITransform("RC2", CALG_RC2, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue,
                                          mode, BlockSizeValue, feedbackSize,
                                          CryptoAPITransformMode.Encrypt);
        }
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _SearchForAlgorithm(IntPtr hProv, int algID, int keyLength);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeCSP(IntPtr hCSP);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rijndaelmanaged.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


namespace System.Security.Cryptography
{
    using System;
    using System.Security;


    /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged"]/*' />
    sealed public class RijndaelManaged : Rijndael
    {
        private RNGCryptoServiceProvider _rng;

        /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged.RijndaelManaged"]/*' />
        public RijndaelManaged()
        {
            GenerateKey();
        }


        /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged.CreateEncryptor"]/*' />
        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
        {
            return _NewEncryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }
      
        /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged.CreateDecryptor"]/*' />
        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
        {
            return _NewDecryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }

        /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged.GenerateKey"]/*' />
        public override void GenerateKey()
        {
            KeyValue = new byte[KeySizeValue/8];
            RNG.GetBytes(KeyValue);
        }

        /// <include file='doc\RijndaelManaged.uex' path='docs/doc[@for="RijndaelManaged.GenerateIV"]/*' />
        public override void GenerateIV()
        {
            IVValue = new byte[BlockSizeValue/8];
            RNG.GetBytes(IVValue);
        }

        private RNGCryptoServiceProvider RNG {
            get { if (_rng == null) { _rng = new RNGCryptoServiceProvider(); } return _rng; }
        }


        private ICryptoTransform _NewEncryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV, int feedbackSize)
        {
            //  Build the key if one does not already exist

            if (rgbKey == null)
            {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            // Check for bad values
            // we don't support OFB or CFB mode in RijndaelManaged
            if (mode == CipherMode.OFB || mode == CipherMode.CFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));

            //  If not ECB mode, make sure we have an IV

            if (mode != CipherMode.ECB)
            {
                if (rgbIV == null)
                {
                    rgbIV = new byte[BlockSizeValue/8];
                    RNG.GetBytes(rgbIV);
                }
            }

            //  Create the encryptor object

            return new RijndaelManagedTransform( rgbKey,
                                                 mode,
                                                 rgbIV,
                                                 BlockSizeValue,
                                                 feedbackSize,
                                                 PaddingValue,
                                                 RijndaelManagedTransformMode.Encrypt );
        }

        private ICryptoTransform _NewDecryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV, int feedbackSize)
        {
            //  Build the key if one does not already exist

            if (rgbKey == null)
            {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            // Check for bad values
            // we don't support OFB or CFB mode in RijndaelManaged
            if (mode == CipherMode.OFB || mode == CipherMode.CFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));

            //  If not ECB mode, make sure we have an IV

            if (mode != CipherMode.ECB)
            {
                if (rgbIV == null)
                {
                    rgbIV = new byte[BlockSizeValue/8];
                    RNG.GetBytes(rgbIV);
                }
            }

            //  Create the encryptor object

            return new RijndaelManagedTransform( rgbKey,
                                                 mode,
                                                 rgbIV,
                                                 BlockSizeValue,
                                                 feedbackSize,
                                                 PaddingValue,
                                                 RijndaelManagedTransformMode.Decrypt );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rijndaelmanagedtransform.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


namespace System.Security.Cryptography
{
    using System;
    using System.Security;
    using System.Text;

    [Serializable]
    internal enum RijndaelManagedTransformMode
    {
        Encrypt = 0,
        Decrypt = 1
    }

    internal class RijndaelManagedTransform : ICryptoTransform
    {
        private int blockSizeValue;
        private int blockSizeBytes;
        private CipherMode cipherMode;
        private int[] IV;
        private int[] m_lastBlockBuffer = null;
        private int feedbackSize;
        private PaddingMode paddingValue;
        private RijndaelManagedTransformMode transformMode;
        private int[] m_encryptKeyExpansion;
        private int[] m_decryptKeyExpansion;
        private int Nr;
        private int Nb;
        private int Nk;
        private int S1; 
        private int S2; 
        private int[] m_encryptindex1 = null;
        private int[] m_encryptindex2 = null;
        private int[] m_encryptindex3 = null;

        private int[] m_decryptindex1 = null;
        private int[] m_decryptindex2 = null;
        private int[] m_decryptindex3 = null;

        private byte[] _depadBuffer;
        private bool       m_bDisposed = false;

        public RijndaelManagedTransform( byte[] rgbKey,
                                         CipherMode mode,
                                         byte[] rgbIV,
                                         int blockSize,
                                         int feedbackSize,
                                         PaddingMode paddingValue,
                                         RijndaelManagedTransformMode transformMode )
        {
            this.blockSizeValue = blockSize;
            this.blockSizeBytes = blockSize / 8;
            this.cipherMode = mode;
            this.feedbackSize = feedbackSize;
            this.paddingValue = paddingValue;
            this.transformMode = transformMode;
            Nb = blockSize / 32;
            Nk = rgbKey.Length / 4;
            S1 = Nb > 6 ? 3 : 2;
            S2 = Nb > 6 ? 4 : 3;

            // Precompute the modulus operations: these are performance killers when called frequently
            m_encryptindex1 = new int[Nb];
            m_encryptindex2 = new int[Nb];
            m_encryptindex3 = new int[Nb];

            m_decryptindex1 = new int[Nb];
            m_decryptindex2 = new int[Nb];
            m_decryptindex3 = new int[Nb];

            for (int j=0; j<Nb; j++) {
                m_encryptindex1[j] = (j+1)%Nb;
                m_encryptindex2[j] = (j+S1)%Nb;
                m_encryptindex3[j] = (j+S2)%Nb;
                m_decryptindex1[j] = (j-1+Nb)%Nb;
                m_decryptindex2[j] = (j-S1+Nb)%Nb;
                m_decryptindex3[j] = (j-S2+Nb)%Nb;
            }


            switch (cipherMode)
            {
                case CipherMode.ECB:
                case CipherMode.CBC:
                    break;

                default:
                    throw new CryptographicException( Environment.GetResourceString( "Cryptography_InvalidCipherMode" ) );
            }

            if (mode == CipherMode.ECB)
            {
                IV = null;
            }
            else
            {
                if (rgbIV == null)
                    throw new ArgumentNullException( "rgbIV" );
                    
                if (rgbIV.Length / 4 != Nb)
                    throw new CryptographicException( Environment.GetResourceString( "Cryptography_InvalidIVSize" ) );

                IV = new int[Nb];
                int index = 0;
                for (int i = 0; i < Nb; ++i) {
                    int i0 = rgbIV[index++];
                    int i1 = rgbIV[index++];
                    int i2 = rgbIV[index++];
                    int i3 = rgbIV[index++];
                    IV[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
                }
            }

            if (rgbKey == null)
                throw new ArgumentNullException( "rgbKey" );
            
            GenerateKeyExpansion( rgbKey );
        }


        // ICryptoTransforms are required to implement  IDisposable implementation

        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        void Dispose(bool disposing) {
            if (disposing) {
                // We need to always zeroize the following fields because they contain sensitive data
                if (IV != null) {               
                    Array.Clear(IV, 0, IV.Length);
                    IV = null;
                }
                if (m_lastBlockBuffer != null) {
                    Array.Clear(m_lastBlockBuffer, 0, m_lastBlockBuffer.Length);
                    m_lastBlockBuffer = null;
                }
                if (m_encryptKeyExpansion != null) {
                    Array.Clear(m_encryptKeyExpansion, 0, m_encryptKeyExpansion.Length);
                    m_encryptKeyExpansion = null;
                }
                if (m_decryptKeyExpansion != null) {
                    Array.Clear(m_decryptKeyExpansion, 0, m_decryptKeyExpansion.Length);
                    m_decryptKeyExpansion = null;
                }
                if (_depadBuffer != null) {
                    Array.Clear(_depadBuffer, 0, _depadBuffer.Length);
                    _depadBuffer = null;
                }
                m_bDisposed = true;
            }
        }

        ~RijndaelManagedTransform() {
            Dispose(false);
        }

        // ICryptoTransform required methods

        protected int BlockSizeValue
        {
            get
            {
                return blockSizeValue;
            }
        }

        public int InputBlockSize
        {
            get
            {
                return BlockSizeValue/8;
            }
        }

        public int OutputBlockSize
        {
            get
            {
                return BlockSizeValue/8;
            }
        }

        public bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        public bool CanReuseTransform
        {
            get {
                return true;
            }
        }

        public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset) 
        {
            // Note: special handling required if I'm decrypting & using PKCS#7 padding
            // Because the padding adds to the end of the last block, I have to buffer
            // an entire block's worth of bytes in case what I just transformed turns out to be the last block
            // Then in TransformFinalBlock we strip off the PKCS pad.
            // fDone = true only on Final Block, not here

            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (inputBuffer == null)
                throw new ArgumentNullException( "inputBuffer" );

            if (outputBuffer == null)
                throw new ArgumentNullException( "outputBuffer" );

            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount <= 0 || (inputCount % InputBlockSize != 0) || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
        
            // Note: there is no need to do the bounds check for the outputBuffer
            // since it will happen in the Buffer.InternalBlockCopy() operation and we are unconcerned
            // about the perf characteristics of the error case.

            byte[] transformedBytes;
            if (transformMode == RijndaelManagedTransformMode.Encrypt) 
            {
                // if we're encrypting we can always push out the bytes because no padding mode
                // removes bytes during encryption
                transformedBytes = _EncryptData(inputBuffer, inputOffset, inputCount, false);
                if (outputBuffer.Length < outputOffset + transformedBytes.Length)
                    throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );
                Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                return(transformedBytes.Length);
            } 
            else 
            {
                transformedBytes = _DecryptData(inputBuffer, inputOffset, inputCount, false);
                if (paddingValue != PaddingMode.PKCS7) 
                {
                    // like encryption, if we're not using PKCS padding on decrypt we can write out all
                    // the bytes.  Note that we cannot depad a block partially padded with Zeros because
                    // we can't tell if those zeros are plaintext or pad.
                    if (outputBuffer.Length < outputOffset + transformedBytes.Length)
                        throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );
                    Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, transformedBytes.Length);
                    return(transformedBytes.Length);
                } 
                else 
                {
                    // OK, now we're in the special case.  Check to see if this is the *first* block we've seen
                    // If so, buffer it and return null zero bytes

                    int blockSizeInBytes = blockSizeValue / 8;
                    if (_depadBuffer == null) {
                        int ret = transformedBytes.Length - blockSizeInBytes;
                        if (ret <= 0) {
                            _depadBuffer = transformedBytes;
                            return(0); // we copied 0 bytes into the outputBuffer
                        } else {
                            _depadBuffer = new byte[blockSizeInBytes];
                        }
                        if (outputBuffer.Length < outputOffset + ret)
                            throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );

                        Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset, ret);  
                        Buffer.InternalBlockCopy(transformedBytes, ret, _depadBuffer, 0, blockSizeInBytes);                   
                        return(ret); // we copied ret bytes into the outputBuffer
                    }
                    else
                    {
                        // OK, not the first block, so send back the _depadBuffer and then hold onto the
                        // new stuff
                        int ret = transformedBytes.Length;
                        
                        if (outputBuffer.Length < outputOffset + ret)
                            throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );

                        Buffer.InternalBlockCopy(_depadBuffer, 0, outputBuffer, outputOffset, blockSizeInBytes); 
                        Buffer.InternalBlockCopy(transformedBytes, 0, outputBuffer, outputOffset + blockSizeInBytes, ret - blockSizeInBytes);          
                        Buffer.InternalBlockCopy(transformedBytes, ret - blockSizeInBytes, _depadBuffer, 0, blockSizeInBytes);
                        return ret;
                    }
                }
            }
        }

        public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount) 
        { 
            if (m_bDisposed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (inputBuffer == null) throw new ArgumentNullException("inputBuffer");
            if (inputOffset < 0) throw new ArgumentOutOfRangeException("inputOffset", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            if (inputCount < 0 || (inputCount > inputBuffer.Length)) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));
            if ((inputBuffer.Length - inputCount) < inputOffset) throw new ArgumentException(Environment.GetResourceString("Argument_InvalidOffLen"));
            byte[] temp = new byte[inputCount+InputBlockSize];

            Buffer.InternalBlockCopy(inputBuffer, inputOffset, temp, 0, inputCount);
            byte[] transformedBytes;
            // Now we have to handle Padding modes.  First, note that by
            // doing the array copy above we've implcitly padded the array out
            // with zeros.  We need to throw an exception here if 
            // we were handed a non-zero, non-full block and we're in PaddingMode.None

            int iLonelyBytes = inputCount%InputBlockSize;
            if (paddingValue == PaddingMode.None) 
            {
                if (inputCount == 0) {
                    Reset();
                    return(new byte[0]);
            }

                if (iLonelyBytes != 0) 
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_SSE_InvalidDataSize"));

                // otherwise just go on
            }
            // If we're using PKCS padding, set the flag to true
            bool usingPKCSPadding = (paddingValue == PaddingMode.PKCS7);
            // If we're using Zero padding, then send the entire block
            int bytesToEncrypt = (paddingValue != PaddingMode.Zeros) ? inputCount : ((iLonelyBytes == 0) ? inputCount : (inputCount+InputBlockSize-iLonelyBytes));

            if (transformMode == RijndaelManagedTransformMode.Encrypt) 
            {
                // If we're encrypting we can always return what we compute because
                // there's no _depadBuffer
                transformedBytes = _EncryptData(temp, 0, bytesToEncrypt, usingPKCSPadding);
                Reset();
                return(transformedBytes);
            } 
            else 
            {
                if (iLonelyBytes != 0)
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_SSD_InvalidDataSize"));
                // We're decrypting.  If we're not in PKCS7 mode, then we don't have
                // a _depadBuffer and can just return what we have
                if (paddingValue != PaddingMode.PKCS7) 
                {
                    transformedBytes = _DecryptData(temp, 0, bytesToEncrypt, usingPKCSPadding);
                    Reset();
                    return(transformedBytes);
                } 
                else 
                {
                    // PKCS padding.  
                    if (_depadBuffer == null && inputCount == 0) 
                    {
                        // Case 1: degenerate case -- no _depadBuffer, no bytes to decrypt
                        Reset();
                        return new byte[0];
                    }
                    else if (inputCount == 0) 
                    {
                        // Case 2: inputCount is 0, so _depadBuffer is the last block
                        // NOTE: in PKCS padding, you pad with k bytes of value k
                        // e.g. xx yy zz ww 04 04 04 04

                        int numPadBytes = _depadBuffer[_depadBuffer.Length - 1];
                        // sanity check that the number of bytes we're trying to remove it less than or
                        // equal to the block size
                        if (numPadBytes > _depadBuffer.Length) {
                            throw new CryptographicException(Environment.GetResourceString("Cryptography_PKCS7_InvalidPadding"));
                        }
                        byte[] tempBytes = new byte[_depadBuffer.Length - numPadBytes];
                        Buffer.InternalBlockCopy(_depadBuffer, 0, tempBytes, 0, _depadBuffer.Length - numPadBytes);
                        Reset();
                        return tempBytes;
                    } else {
                        // Last case -- we actually have something to decrypt here
                        // transformedBytes is what needs to be depadded
                        transformedBytes = _DecryptData(temp, 0, bytesToEncrypt, usingPKCSPadding);
                        // handle the degenerate case when _depadBuffer is null
                        if (_depadBuffer == null) {
                            Reset();
                            return(transformedBytes);
                        } else {
                            byte[] tempBytes = new byte[_depadBuffer.Length + transformedBytes.Length];
                            Buffer.InternalBlockCopy(_depadBuffer, 0, tempBytes, 0, _depadBuffer.Length);                     
                            Buffer.InternalBlockCopy(transformedBytes, 0, tempBytes, _depadBuffer.Length, transformedBytes.Length);
                            Reset();
                            return tempBytes;
                        }
                    }
                }
            }
        }

        // Reset the state of the transform so it can be used again
        private void Reset() {
            m_lastBlockBuffer = null;
            _depadBuffer = null;
        }

        // System.Security.Cryptography.RijndaelManagedTransform::_EncryptData

        private byte[] _EncryptData( byte[] inputBuffer, int inputOffset, int inputCount, bool usingPKCSPadding)
        {
            if (inputBuffer == null)
                throw new ArgumentNullException( "inputBuffer" );

            if (inputBuffer.Length < inputOffset + inputCount)
                throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );

            int padSize = 0;
            int lonelyBytes = inputCount % blockSizeBytes;

            // Check the padding mode and make sure we have enough
            // outputBuffer to handle any padding we have to do.
            if (paddingValue != PaddingMode.None) {
                if (lonelyBytes == 0)
                {
                    if (paddingValue == PaddingMode.PKCS7 && usingPKCSPadding)
                        padSize = blockSizeBytes;
                    else
                        padSize = 0;
                }
                else
                {
                    padSize = blockSizeBytes - lonelyBytes;
                }
            } else {
                if (lonelyBytes != 0)
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_SSE_InvalidDataSize"));
            }

            byte[] outputBuffer = new byte[inputCount + padSize];

            int[] work = new int[Nb];
            int[] temp = new int[Nb];

            BCLDebug.Assert( work.Length % Nb == 0, "The work buffer should be a multiple of the number of block size" );

            int transformCount = 0;

            if (cipherMode == CipherMode.CBC)
            {
                if (m_lastBlockBuffer == null) {
                    m_lastBlockBuffer = new int[Nb];
                    Buffer.InternalBlockCopy(IV, 0, m_lastBlockBuffer, 0, blockSizeBytes);
                }
            }
            
            int iNumBlocks = (inputCount + padSize) / blockSizeBytes;
            int keyIndex = 0, workBaseIndex = inputOffset;
            for (int blockNum = 0;  blockNum < iNumBlocks; ++blockNum)
            {
                // Copy the block into the buffer, special-case the last block
                if (blockNum != iNumBlocks - 1) {
                    Buffer.InternalBlockCopy(inputBuffer, workBaseIndex, work, 0, blockSizeBytes);
                } else {
                    if (paddingValue != PaddingMode.None && padSize != 0) {
                        byte padValue;            
                        if (paddingValue == PaddingMode.PKCS7)
                            padValue = (byte)padSize;
                        else
                            padValue = 0;
                        
                        int index = workBaseIndex;
                        for (int i = 0; i < Nb; ++i) {
                            int i0 = (index >= workBaseIndex + lonelyBytes) ? padValue : inputBuffer[index++];
                            int i1 = (index >= workBaseIndex + lonelyBytes) ? padValue : inputBuffer[index++];
                            int i2 = (index >= workBaseIndex + lonelyBytes) ? padValue : inputBuffer[index++];
                            int i3 = (index >= workBaseIndex + lonelyBytes) ? padValue : inputBuffer[index++];
                            work[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
                        }
                    } else {
                        int index = workBaseIndex;
                        for (int i = 0; i < Nb; ++i) {
                            int i0 = inputBuffer[index++];
                            int i1 = inputBuffer[index++];
                            int i2 = inputBuffer[index++];
                            int i3 = inputBuffer[index++];
                            work[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
                        }
                    }                    
                }                    

                for (int i = 0; i < Nb; ++i) {
                    // XOR with the last encrypted block
                    if (cipherMode == CipherMode.CBC)
                        work[i] ^= m_lastBlockBuffer[i];
                    work[i] ^= m_encryptKeyExpansion[i];                    
                }

                keyIndex = Nb;
                for (int r = 1; r < Nr; ++r) {
                    for (int i = 0; i < Nb; ++i) {
                        temp[i] = s_T1[work[i] & 0xFF] ^
                                  s_T2[(work[m_encryptindex1[i]] >> 8) & 0xFF] ^
                                  s_T3[(work[m_encryptindex2[i]] >> 16) & 0xFF] ^ 
                                  s_T4[(work[m_encryptindex3[i]] >> 24) & 0xFF] ^ 
                                  m_encryptKeyExpansion[keyIndex];
                        keyIndex++;
                    }
                    Buffer.InternalBlockCopy(temp, 0, work, 0, blockSizeBytes);
                }


                for (int i = 0; i < Nb; ++i)
                {
                    temp[i] = s_TF1[work[i] & 0xFF] ^
                              s_TF2[(work[m_encryptindex1[i]] >> 8 ) & 0xFF] ^
                              s_TF3[(work[m_encryptindex2[i]] >> 16) & 0xFF] ^
                              s_TF4[(work[m_encryptindex3[i]] >> 24) & 0xFF] ^
                              m_encryptKeyExpansion[keyIndex];
                    outputBuffer[transformCount++] = (byte)(temp[i]       & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 8  & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 16 & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 24 & 0xFF);
                    keyIndex++;
                } 

                if (cipherMode == CipherMode.CBC) {
                    Buffer.InternalBlockCopy(temp, 0, m_lastBlockBuffer, 0, blockSizeBytes);
                }
                workBaseIndex += blockSizeBytes;                     
            }

            return outputBuffer;
        }

        // System.Security.Cryptography.RijndaelManagedTransform::_DecryptData

        private byte[] _DecryptData( byte[] inputBuffer, int inputOffset, int inputCount, bool usingPKCSPadding)
        {
            if (inputBuffer == null)
                throw new ArgumentNullException( "inputBuffer" );

            if (inputBuffer.Length < inputOffset + inputCount)
                throw new CryptographicException( Environment.GetResourceString( "Cryptography_InsufficientBuffer" ) );

            byte[] outputBuffer = new byte[inputCount];

            int[] work = new int[Nb];
            int[] temp = new int[Nb];

            if (cipherMode == CipherMode.CBC) {
                if (m_lastBlockBuffer == null) {
                    m_lastBlockBuffer = new int[Nb];
                    Buffer.InternalBlockCopy(IV, 0, m_lastBlockBuffer, 0, blockSizeBytes);
                }
            }

            int transformCount = 0;
            int iNumBlocks = inputCount / blockSizeBytes;
            int workBaseIndex = inputOffset;
            for (int blockNum = 0; blockNum < iNumBlocks; ++blockNum)
            {
                int index = workBaseIndex;
                for (int i = 0; i < Nb; ++i) {
                    int i0 = inputBuffer[index++];
                    int i1 = inputBuffer[index++];
                    int i2 = inputBuffer[index++];
                    int i3 = inputBuffer[index++];
                    work[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
                }

                int keyIndex = Nb * Nr;
                for (int i = 0; i < Nb; ++i) {
                    work[i] ^= m_decryptKeyExpansion[keyIndex];
                    keyIndex++;
                }

                for (int r = 1; r < Nr; ++r) {
                    keyIndex -= 2 * Nb;
                    for (int i = 0; i < Nb; ++i) {
                        temp[i] = s_iT1[(work[i]) & 0xFF] ^
                                  s_iT2[(work[m_decryptindex1[i]] >> 8 ) & 0xFF] ^
                                  s_iT3[(work[m_decryptindex2[i]] >> 16) & 0xFF] ^
                                  s_iT4[(work[m_decryptindex3[i]] >> 24) & 0xFF] ^
                                  m_decryptKeyExpansion[keyIndex];
                        keyIndex++;
                    }
                    Buffer.InternalBlockCopy(temp, 0, work, 0, blockSizeBytes);
                }

                keyIndex = 0;
                for (int i = 0; i < Nb; ++i)
                {
                    temp[i] = s_iTF1[(work[i]) & 0xFF] ^
                              s_iTF2[(work[m_decryptindex1[i]] >> 8 ) & 0xFF] ^
                              s_iTF3[(work[m_decryptindex2[i]] >> 16) & 0xFF] ^
                              s_iTF4[(work[m_decryptindex3[i]] >> 24) & 0xFF] ^
                              m_decryptKeyExpansion[keyIndex];

                    if (cipherMode == CipherMode.CBC) {
                        temp[i] ^= m_lastBlockBuffer[i];
                    }

                    outputBuffer[transformCount++] = (byte)(temp[i]       & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 8  & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 16 & 0xFF);
                    outputBuffer[transformCount++] = (byte)(temp[i] >> 24 & 0xFF);

                    keyIndex++;
                }

                if (cipherMode == CipherMode.CBC) {
                    index = workBaseIndex;
                    for (int i = 0; i < Nb; ++i) {
                        int i0 = inputBuffer[index++];
                        int i1 = inputBuffer[index++];
                        int i2 = inputBuffer[index++];
                        int i3 = inputBuffer[index++];
                        m_lastBlockBuffer[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
                    }
                }                        
                workBaseIndex += blockSizeBytes;
            }

            if (!usingPKCSPadding) return outputBuffer;
            int numPad = outputBuffer[inputCount - 1];
            if (numPad > outputBuffer.Length)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_PKCS7_InvalidPadding"));
            byte[] outputBuffer1 = new byte[outputBuffer.Length - numPad];
            Buffer.InternalBlockCopy(outputBuffer, 0, outputBuffer1, 0, outputBuffer.Length - numPad);
            return outputBuffer1;            
        }

        // System.Security.Cryptography.RijndaelManagedTransform::GenerateKeyExpansion

        private void GenerateKeyExpansion( byte[] rgbKey )
        {
            switch (blockSizeValue > rgbKey.Length * 8 ? blockSizeValue : rgbKey.Length * 8)
            {
            case 128:            
                Nr = 10;
                break;

            case 192:
                Nr = 12;
                break;

            case 256:
                Nr = 14;
                break;

            default:
                throw new CryptographicException( Environment.GetResourceString( "Cryptography_InvalidKeySize" ) );
            }

            m_encryptKeyExpansion = new int[Nb * (Nr+1)];
            m_decryptKeyExpansion = new int[Nb * (Nr+1)];
            int iTemp;

            int Nk = rgbKey.Length / 4;

            int index = 0;
            for (int i = 0; i < Nk; ++i) {
                int i0 = rgbKey[index++];
                int i1 = rgbKey[index++];
                int i2 = rgbKey[index++];
                int i3 = rgbKey[index++];
                m_encryptKeyExpansion[i] = i3 << 24 | i2 << 16 | i1 << 8 | i0;
            }

            if (Nk <= 6)
            {
                for (int i = Nk; i < Nb * (Nr + 1); ++i)
                {
                    iTemp = m_encryptKeyExpansion[i-1];

                    if (i % Nk == 0)
                    {
                        iTemp = SubWord( rot3( iTemp ) );
                
                        iTemp = iTemp ^ s_Rcon[(i / Nk) - 1];
                    }

                    m_encryptKeyExpansion[i] = m_encryptKeyExpansion[i - Nk] ^ iTemp;
                }
            }
            else
            {
                for (int i = Nk; i < Nb * (Nr + 1); ++i)
                {
                    iTemp = m_encryptKeyExpansion[i-1];

                    if (i % Nk == 0)
                    {
                        iTemp = SubWord( rot3( iTemp ) );
                
                        iTemp = iTemp ^ s_Rcon[(i / Nk) - 1];
                    }
                    else if (i % Nk == 4)
                    {
                        iTemp = SubWord( iTemp );
                    }
                    
                    m_encryptKeyExpansion[i] = m_encryptKeyExpansion[i - Nk] ^ iTemp;
                }
            }

            for (int i = 0; i < Nb; ++i)
            {
                m_decryptKeyExpansion[i] = m_encryptKeyExpansion[i];
                m_decryptKeyExpansion[Nb * Nr + i] = m_encryptKeyExpansion[Nb * Nr + i];
            }

            for (int i = Nb; i < Nb * Nr; ++i)
            {
                int key = m_encryptKeyExpansion[i];
                int mul02 = MulX(key);
                int mul04 = MulX(mul02);
                int mul08 = MulX(mul04);
                int mul09 = key ^ mul08;
                m_decryptKeyExpansion[i] = mul02 ^ mul04 ^ mul08 ^ rot3( mul02 ^ mul09 ) ^ rot2( mul04 ^ mul09 ) ^ rot1( mul09 );
            }
        }

        private static int rot1( int val )
        {
            return (val << 8  & unchecked((int)0xFFFFFF00)) | (val >> 24 & unchecked((int)0x000000FF));
        }

        private static int rot2( int val )
        {
            return (val << 16 & unchecked((int)0xFFFF0000)) | (val >> 16 & unchecked((int)0x0000FFFF));
        }

        private static int rot3( int val )
        {
            return (val << 24 & unchecked((int)0xFF000000)) | (val >> 8  & unchecked((int)0x00FFFFFF));
        }

        private static int SubWord( int a )
        {
            return s_Sbox[a       & 0xFF]       |
                   s_Sbox[a >> 8  & 0xFF] << 8  |
                   s_Sbox[a >> 16 & 0xFF] << 16 |
                   s_Sbox[a >> 24 & 0xFF] << 24;
        }

        private static int MulX( int x )
        {
            int    u = x & unchecked((int)0x80808080);
            return ((x & unchecked((int)0x7f7f7f7f)) << 1) ^ ((u - (u >> 7 & 0x01FFFFFF)) & 0x1b1b1b1b);
        }



        private static readonly byte[] s_Sbox = new byte[] {
             99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118, 
            202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 
            183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 216,  49,  21, 
              4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 235,  39, 178, 117, 
              9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132, 
             83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207, 
            208, 239, 170, 251,  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168, 
             81, 163,  64, 143, 146, 157,  56, 245, 188, 182, 218,  33,  16, 255, 243, 210, 
            205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 100,  93,  25, 115, 
             96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219, 
            224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121, 
            231, 200,  55, 109, 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8, 
            186, 120,  37,  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138, 
            112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158, 
            225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223, 
            140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22 };

        private static readonly int[] s_Rcon = new int[] {
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,
            0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6,
            0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };

        private static readonly int[] s_T1 = new int[256]
            {  -1520213050,  -2072216328,  -1720223762,  -1921287178,    234025727,  -1117033514,  -1318096930,   1422247313, 
                1345335392,     50397442,  -1452841010,   2099981142,    436141799,   1658312629,   -424957107,  -1703512340, 
                1170918031,  -1652391393,   1086966153,  -2021818886,    368769775,   -346465870,   -918075506,    200339707, 
                -324162239,   1742001331,    -39673249,   -357585083,  -1080255453,   -140204973,  -1770884380,   1539358875, 
               -1028147339,    486407649,  -1366060227,   1780885068,   1513502316,   1094664062,     49805301,   1338821763, 
                1546925160,   -190470831,    887481809,    150073849,  -1821281822,   1943591083,   1395732834,   1058346282, 
                 201589768,   1388824469,   1696801606,   1589887901,    672667696,  -1583966665,    251987210,  -1248159185, 
                 151455502,    907153956,  -1686077413,   1038279391,    652995533,   1764173646,   -843926913,  -1619692054, 
                 453576978,  -1635548387,   1949051992,    773462580,    756751158,  -1301385508,   -296068428,    -73359269, 
                -162377052,   1295727478,   1641469623,   -827083907,   2066295122,   1055122397,   1898917726,  -1752923117, 
                -179088474,   1758581177,            0,    753790401,   1612718144,    536673507,   -927878791,   -312779850, 
               -1100322092,   1187761037,   -641810841,   1262041458,   -565556588,   -733197160,   -396863312,   1255133061, 
                1808847035,    720367557,   -441800113,    385612781,   -985447546,   -682799718,   1429418854,  -1803188975, 
                -817543798,    284817897,    100794884,  -2122350594,   -263171936,   1144798328,  -1163944155,   -475486133, 
                -212774494,    -22830243,  -1069531008,  -1970303227,  -1382903233,  -1130521311,   1211644016,     83228145, 
                -541279133,  -1044990345,   1977277103,   1663115586,    806359072,    452984805,    250868733,   1842533055, 
                1288555905,    336333848,    890442534,    804056259,   -513843266,  -1567123659,   -867941240,    957814574, 
                1472513171,   -223893675,  -2105639172,   1195195770,  -1402706744,   -413311558,    723065138,  -1787595802, 
               -1604296512,  -1736343271,   -783331426,   2145180835,   1713513028,   2116692564,  -1416589253,  -2088204277, 
                -901364084,    703524551,   -742868885,   1007948840,   2044649127,   -497131844,    487262998,   1994120109, 
                1004593371,   1446130276,   1312438900,    503974420,   -615954030,    168166924,   1814307912,   -463709000, 
                1573044895,   1859376061,   -273896381,  -1503501628,  -1466855111,  -1533700815,    937747667,  -1954973198, 
                 854058965,   1137232011,   1496790894,  -1217565222,  -1936880383,   1691735473,   -766620004,   -525751991, 
               -1267962664,    -95005012,    133494003,    636152527,  -1352309302,  -1904575756,   -374428089,    403179536, 
                -709182865,  -2005370640,   1864705354,   1915629148,    605822008,   -240736681,   -944458637,   1371981463, 
                 602466507,   2094914977,  -1670089496,    555687742,   -582268010,   -591544991,  -2037675251,  -2054518257, 
               -1871679264,   1111375484,   -994724495,  -1436129588,   -666351472,     84083462,     32962295,    302911004, 
               -1553899070,   1597322602,   -111716434,   -793134743,  -1853454825,   1489093017,    656219450,  -1180787161, 
                 954327513,    335083755,  -1281845205,    856756514,  -1150719534,   1893325225,  -1987146233,  -1483434957, 
               -1231316179,    572399164,  -1836611819,    552200649,   1238290055,    -11184726,   2015897680,   2061492133, 
               -1886614525,   -123625127,  -2138470135,    386731290,   -624967835,    837215959,   -968736124,  -1201116976, 
               -1019133566,  -1332111063,   1999449434,    286199582,   -877612933,    -61582168,   -692339859,    974525996 };

        private static readonly int[] s_T2 = new int[256]
            {   1667483301,   2088564868,   2004348569,   2071721613,   -218956019,   1802229437,   1869602481,   -976907948, 
                 808476752,     16843267,   1734856361,    724260477,    -16849127,   -673729182,  -1414836762,   1987505306, 
                -892694715,  -2105401443,   -909539008,   2105408135,    -84218091,   1499050731,   1195871945,   -252642549, 
               -1381154324,   -724257945,  -1566416899,  -1347467798,  -1667488833,  -1532734473,   1920132246,  -1061119141, 
               -1212713534,    -33693412,  -1819066962,    640044138,    909536346,   1061125697,   -134744830,   -859012273, 
                 875849820,  -1515892236,   -437923532,   -235800312,   1903288979,   -656888973,    825320019,    353708607, 
                  67373068,   -943221422,    589514341,  -1010590370,    404238376,  -1768540255,     84216335,  -1701171275, 
                 117902857,    303178806,  -2139087973,   -488448195,   -336868058,    656887401,  -1296924723,   1970662047, 
                 151589403,  -2088559202,    741103732,    437924910,    454768173,   1852759218,   1515893998,  -1600103429, 
                1381147894,    993752653,   -690571423,  -1280082482,    690573947,   -471605954,    791633521,  -2071719017, 
                1397991157,   -774784664,            0,   -303185620,    538984544,    -50535649,  -1313769016,   1532737261, 
                1785386174,   -875852474,  -1094817831,    960066123,   1246401758,   1280088276,   1482207464,   -808483510, 
                -791626901,   -269499094,  -1431679003,    -67375850,   1128498885,   1296931543,    859006549,  -2054876780, 
                1162185423,   -101062384,     33686534,   2139094657,   1347461360,   1010595908,  -1616960070,  -1465365533, 
                1364304627,  -1549574658,   1077969088,  -1886452342,  -1835909203,  -1650646596,    943222856,   -168431356, 
               -1128504353,  -1229555775,   -623202443,    555827811,    269492272,        -6886,   -202113778,   -757940371, 
                -842170036,    202119188,    320022069,   -320027857,   1600110305,  -1751698014,   1145342156,    387395129, 
                -993750185,  -1482205710,   2122251394,   1027439175,   1684326572,   1566423783,    421081643,   1936975509, 
                1616953504,  -2122245736,   1330618065,   -589520001,    572671078,    707417214,  -1869595733,  -2004350077, 
                1179028682,   -286341335,  -1195873325,    336865340,   -555833479,   1583267042,    185275933,   -606360202, 
                -522134725,    842163286,    976909390,    168432670,   1229558491,    101059594,    606357612,   1549580516, 
               -1027432611,   -741098130,  -1397996561,   1650640038,  -1852753496,  -1785384540,   -454765769,   2038035083, 
                -404237006,   -926381245,    926379609,   1835915959,  -1920138868,   -707415708,   1313774802,  -1448523296, 
                1819072692,   1448520954,   -185273593,   -353710299,   1701169839,   2054878350,  -1364310039,    134746136, 
               -1162186795,   2021191816,    623200879,    774790258,    471611428,  -1499047951,  -1263242297,   -960063663, 
                -387396829,   -572677764,   1953818780,    522141217,   1263245021,  -1111662116,  -1953821306,  -1970663547, 
                1886445712,   1044282434,  -1246400060,   1718013098,   1212715224,     50529797,   -151587071,    235805714, 
                1633796771,    892693087,   1465364217,  -1179031088,  -2038032495,  -1044276904,    488454695,  -1633802311, 
                -505292488,   -117904621,  -1734857805,    286335539,   1768542907,   -640046736,  -1903294583,  -1802226777, 
               -1684329034,    505297954,  -2021190254,   -370554592,   -825325751,   1431677695,    673730680,   -538991238, 
               -1936981105,  -1583261192,  -1987507840,    218962455,  -1077975590,   -421079247,   1111655622,   1751699640, 
                1094812355,  -1718015568,    757946999,    252648977,  -1330611253,   1414834428,  -1145344554,    370551866 };

        private static readonly int[] s_T3 = new int[256]
            {   1673962851,   2096661628,   2012125559,   2079755643,   -218165774,   1809235307,   1876865391,   -980331323, 
                 811618352,     16909057,   1741597031,    727088427,    -18408962,   -675978537,  -1420958037,   1995217526, 
                -896580150,  -2111857278,   -913751863,   2113570685,    -84994566,   1504897881,   1200539975,   -251982864, 
               -1388188499,   -726439980,  -1570767454,  -1354372433,  -1675378788,  -1538000988,   1927583346,  -1063560256, 
               -1217019209,    -35578627,  -1824674157,    642542118,    913070646,   1065238847,   -134937865,   -863809588, 
                 879254580,  -1521355611,   -439274267,   -235337487,   1910674289,   -659852328,    828527409,    355090197, 
                  67636228,   -946515257,    591815971,  -1013096765,    405809176,  -1774739050,     84545285,  -1708149350, 
                 118360327,    304363026,  -2145674368,   -488686110,   -338876693,    659450151,  -1300247118,   1978310517, 
                 152181513,  -2095210877,    743994412,    439627290,    456535323,   1859957358,   1521806938,  -1604584544, 
                1386542674,    997608763,   -692624938,  -1283600717,    693271337,   -472039709,    794718511,  -2079090812, 
                1403450707,   -776378159,            0,   -306107155,    541089824,    -52224004,  -1317418831,   1538714971, 
                1792327274,   -879933749,  -1100490306,    963791673,   1251270218,   1285084236,   1487988824,   -813348145, 
                -793023536,   -272291089,  -1437604438,    -68348165,   1132905795,   1301993293,    862344499,  -2062445435, 
                1166724933,   -102166279,     33818114,   2147385727,   1352724560,   1014514748,  -1624917345,  -1471421528, 
                1369633617,  -1554121053,   1082179648,  -1895462257,  -1841320558,  -1658733411,    946882616,   -168753931, 
               -1134305348,  -1233665610,   -626035238,    557998881,    270544912,     -1762561,   -201519373,   -759206446, 
                -847164211,    202904588,    321271059,   -322752532,   1606345055,  -1758092649,   1149815876,    388905239, 
                -996976700,  -1487539545,   2130477694,   1031423805,   1690872932,   1572530013,    422718233,   1944491379, 
                1623236704,  -2129028991,   1335808335,   -593264676,    574907938,    710180394,  -1875137648,  -2012511352, 
                1183631942,   -288937490,  -1200893000,    338181140,   -559449634,   1589437022,    185998603,   -609388837, 
                -522503200,    845436466,    980700730,    169090570,   1234361161,    101452294,    608726052,   1555620956, 
               -1029743166,   -742560045,  -1404833876,   1657054818,  -1858492271,  -1791908715,   -455919644,   2045938553, 
                -405458201,   -930397240,    929978679,   1843050349,  -1929278323,   -709794603,   1318900302,  -1454776151, 
                1826141292,   1454176854,   -185399308,   -355523094,   1707781989,   2062847610,  -1371018834,    135272456, 
               -1167075910,   2029029496,    625635109,    777810478,    473441308,  -1504185946,  -1267480652,   -963161658, 
                -389340184,   -576619299,   1961401460,    524165407,   1268178251,  -1117659971,  -1962047861,  -1978694262, 
                1893765232,   1048330814,  -1250835275,   1724688998,   1217452104,     50726147,   -151584266,    236720654, 
                1640145761,    896163637,   1471084887,  -1184247623,  -2045275770,  -1046914879,    490350365,  -1641563746, 
                -505857823,   -118811656,  -1741966440,    287453969,   1775418217,   -643206951,  -1912108658,  -1808554092, 
               -1691502949,    507257374,  -2028629369,   -372694807,   -829994546,   1437269845,    676362280,   -542803233, 
               -1945923700,  -1587939167,  -1995865975,    219813645,  -1083843905,   -422104602,   1115997762,   1758509160, 
                1099088705,  -1725321063,    760903469,    253628687,  -1334064208,   1420360788,  -1150429509,    371997206 };

        private static readonly int[] s_T4 = new int[256]
            {   -962239645,   -125535108,   -291932297,   -158499973,    -15863054,   -692229269,   -558796945,  -1856715323, 
                1615867952,     33751297,   -827758745,   1451043627,   -417726722,  -1251813417,   1306962859,   -325421450, 
               -1891251510,    530416258,  -1992242743,    -91783811,   -283772166,  -1293199015,  -1899411641,    -83103504, 
                1106029997,  -1285040940,   1610457762,   1173008303,    599760028,   1408738468,   -459902350,  -1688485696, 
                1975695287,   -518193667,   1034851219,   1282024998,   1817851446,   2118205247,   -184354825,  -2091922228, 
                1750873140,   1374987685,   -785062427,   -116854287,   -493653647,  -1418471208,   1649619249,    708777237, 
                 135005188,  -1789737017,   1181033251,  -1654733885,    807933976,    933336726,    168756485,    800430746, 
                 235472647,    607523346,    463175808,   -549592350,   -853087253,   1315514151,   2144187058,   -358648459, 
                 303761673,    496927619,   1484008492,    875436570,    908925723,   -592286098,  -1259447718,   1543217312, 
               -1527360942,   1984772923,  -1218324778,   2110698419,   1383803177,   -583080989,   1584475951,    328696964, 
               -1493871789,  -1184312879,            0,  -1054020115,   1080041504,   -484442884,   2043195825,  -1225958565, 
                -725718422,  -1924740149,   1742323390,   1917532473,  -1797371318,  -1730917300,  -1326950312,  -2058694705, 
               -1150562096,   -987041809,   1340451498,   -317260805,  -2033892541,  -1697166003,   1716859699,    294946181, 
               -1966127803,   -384763399,     67502594,    -25067649,  -1594863536,   2017737788,    632987551,   1273211048, 
               -1561112239,   1576969123,  -2134884288,     92966799,   1068339858,    566009245,   1883781176,   -251333131, 
                1675607228,   2009183926,  -1351230758,   1113792801,    540020752,   -451215361,    -49351693,  -1083321646, 
               -2125673011,    403966988,    641012499,  -1020269332,  -1092526241,    899848087,  -1999879100,    775493399, 
               -1822964540,   1441965991,    -58556802,   2051489085,   -928226204,  -1159242403,    841685273,   -426413197, 
               -1063231392,    429425025,  -1630449841,  -1551901476,   1147544098,   1417554474,   1001099408,    193169544, 
               -1932900794,   -953553170,   1809037496,    675025940,  -1485185314,  -1126015394,    371002123,  -1384719397, 
                -616832800,   1683370546,   1951283770,    337512970,  -1831122615,    201983494,   1215046692,  -1192993700, 
               -1621245246,  -1116810285,   1139780780,   -995728798,    967348625,    832869781,   -751311644,   -225740423, 
                -718084121,  -1958491960,   1851340599,   -625513107,     25988493,  -1318791723,  -1663938994,   1239460265, 
                -659264404,  -1392880042,   -217582348,   -819598614,   -894474907,   -191989126,   1206496942,    270010376, 
                1876277946,   -259491720,   1248797989,   1550986798,    941890588,   1475454630,   1942467764,  -1756248378, 
                -886839064,  -1585652259,   -392399756,   1042358047,  -1763882165,   1641856445,    226921355,    260409994, 
                -527404944,   2084716094,   1908716981,   -861247898,  -1864873912,    100991747,   -150866186,    470945294, 
               -1029480095,   1784624437,  -1359390889,   1775286713,    395413126,  -1722236479,    975641885,    666476190, 
                -650583583,   -351012616,    733190296,    573772049,   -759469719,  -1452221991,    126455438,    866620564, 
                 766942107,   1008868894,    361924487,   -920589847,  -2025206066,  -1426107051,   1350051880,  -1518673953, 
                  59739276,   1509466529,    159418761,    437718285,   1708834751,   -684595482,  -2067381694,   -793221016, 
               -2101132991,    699439513,   1517759789,    504434447,   2076946608,  -1459858348,   1842789307,    742004246 };

        private static readonly int[] s_TF1 = new int[256]
            {           99,          124,          119,          123,          242,          107,          111,          197, 
                        48,            1,          103,           43,          254,          215,          171,          118, 
                       202,          130,          201,          125,          250,           89,           71,          240, 
                       173,          212,          162,          175,          156,          164,          114,          192, 
                       183,          253,          147,           38,           54,           63,          247,          204, 
                        52,          165,          229,          241,          113,          216,           49,           21, 
                         4,          199,           35,          195,           24,          150,            5,          154, 
                         7,           18,          128,          226,          235,           39,          178,          117, 
                         9,          131,           44,           26,           27,          110,           90,          160, 
                        82,           59,          214,          179,           41,          227,           47,          132, 
                        83,          209,            0,          237,           32,          252,          177,           91, 
                       106,          203,          190,           57,           74,           76,           88,          207, 
                       208,          239,          170,          251,           67,           77,           51,          133, 
                        69,          249,            2,          127,           80,           60,          159,          168, 
                        81,          163,           64,          143,          146,          157,           56,          245, 
                       188,          182,          218,           33,           16,          255,          243,          210, 
                       205,           12,           19,          236,           95,          151,           68,           23, 
                       196,          167,          126,           61,          100,           93,           25,          115, 
                        96,          129,           79,          220,           34,           42,          144,          136, 
                        70,          238,          184,           20,          222,           94,           11,          219, 
                       224,           50,           58,           10,           73,            6,           36,           92, 
                       194,          211,          172,           98,          145,          149,          228,          121, 
                       231,          200,           55,          109,          141,          213,           78,          169, 
                       108,           86,          244,          234,          101,          122,          174,            8, 
                       186,          120,           37,           46,           28,          166,          180,          198, 
                       232,          221,          116,           31,           75,          189,          139,          138, 
                       112,           62,          181,          102,           72,            3,          246,           14, 
                        97,           53,           87,          185,          134,          193,           29,          158, 
                       225,          248,          152,           17,          105,          217,          142,          148, 
                       155,           30,          135,          233,          206,           85,           40,          223, 
                       140,          161,          137,           13,          191,          230,           66,          104, 
                        65,          153,           45,           15,          176,           84,          187,           22 };

        private static readonly int[] s_TF2 = new int[256]
            {        25344,        31744,        30464,        31488,        61952,        27392,        28416,        50432, 
                     12288,          256,        26368,        11008,        65024,        55040,        43776,        30208, 
                     51712,        33280,        51456,        32000,        64000,        22784,        18176,        61440, 
                     44288,        54272,        41472,        44800,        39936,        41984,        29184,        49152, 
                     46848,        64768,        37632,         9728,        13824,        16128,        63232,        52224, 
                     13312,        42240,        58624,        61696,        28928,        55296,        12544,         5376, 
                      1024,        50944,         8960,        49920,         6144,        38400,         1280,        39424, 
                      1792,         4608,        32768,        57856,        60160,         9984,        45568,        29952, 
                      2304,        33536,        11264,         6656,         6912,        28160,        23040,        40960, 
                     20992,        15104,        54784,        45824,        10496,        58112,        12032,        33792, 
                     21248,        53504,            0,        60672,         8192,        64512,        45312,        23296, 
                     27136,        51968,        48640,        14592,        18944,        19456,        22528,        52992, 
                     53248,        61184,        43520,        64256,        17152,        19712,        13056,        34048, 
                     17664,        63744,          512,        32512,        20480,        15360,        40704,        43008, 
                     20736,        41728,        16384,        36608,        37376,        40192,        14336,        62720, 
                     48128,        46592,        55808,         8448,         4096,        65280,        62208,        53760, 
                     52480,         3072,         4864,        60416,        24320,        38656,        17408,         5888, 
                     50176,        42752,        32256,        15616,        25600,        23808,         6400,        29440, 
                     24576,        33024,        20224,        56320,         8704,        10752,        36864,        34816, 
                     17920,        60928,        47104,         5120,        56832,        24064,         2816,        56064, 
                     57344,        12800,        14848,         2560,        18688,         1536,         9216,        23552, 
                     49664,        54016,        44032,        25088,        37120,        38144,        58368,        30976, 
                     59136,        51200,        14080,        27904,        36096,        54528,        19968,        43264, 
                     27648,        22016,        62464,        59904,        25856,        31232,        44544,         2048, 
                     47616,        30720,         9472,        11776,         7168,        42496,        46080,        50688, 
                     59392,        56576,        29696,         7936,        19200,        48384,        35584,        35328, 
                     28672,        15872,        46336,        26112,        18432,          768,        62976,         3584, 
                     24832,        13568,        22272,        47360,        34304,        49408,         7424,        40448, 
                     57600,        63488,        38912,         4352,        26880,        55552,        36352,        37888, 
                     39680,         7680,        34560,        59648,        52736,        21760,        10240,        57088, 
                     35840,        41216,        35072,         3328,        48896,        58880,        16896,        26624, 
                     16640,        39168,        11520,         3840,        45056,        21504,        47872,         5632 };

        private static readonly int[] s_TF3 = new int[256]
            {      6488064,      8126464,      7798784,      8060928,     15859712,      7012352,      7274496,     12910592, 
                   3145728,        65536,      6750208,      2818048,     16646144,     14090240,     11206656,      7733248, 
                  13238272,      8519680,     13172736,      8192000,     16384000,      5832704,      4653056,     15728640, 
                  11337728,     13893632,     10616832,     11468800,     10223616,     10747904,      7471104,     12582912, 
                  11993088,     16580608,      9633792,      2490368,      3538944,      4128768,     16187392,     13369344, 
                   3407872,     10813440,     15007744,     15794176,      7405568,     14155776,      3211264,      1376256, 
                    262144,     13041664,      2293760,     12779520,      1572864,      9830400,       327680,     10092544, 
                    458752,      1179648,      8388608,     14811136,     15400960,      2555904,     11665408,      7667712, 
                    589824,      8585216,      2883584,      1703936,      1769472,      7208960,      5898240,     10485760, 
                   5373952,      3866624,     14024704,     11730944,      2686976,     14876672,      3080192,      8650752, 
                   5439488,     13697024,            0,     15532032,      2097152,     16515072,     11599872,      5963776, 
                   6946816,     13303808,     12451840,      3735552,      4849664,      4980736,      5767168,     13565952, 
                  13631488,     15663104,     11141120,     16449536,      4390912,      5046272,      3342336,      8716288, 
                   4521984,     16318464,       131072,      8323072,      5242880,      3932160,     10420224,     11010048, 
                   5308416,     10682368,      4194304,      9371648,      9568256,     10289152,      3670016,     16056320, 
                  12320768,     11927552,     14286848,      2162688,      1048576,     16711680,     15925248,     13762560, 
                  13434880,       786432,      1245184,     15466496,      6225920,      9895936,      4456448,      1507328, 
                  12845056,     10944512,      8257536,      3997696,      6553600,      6094848,      1638400,      7536640, 
                   6291456,      8454144,      5177344,     14417920,      2228224,      2752512,      9437184,      8912896, 
                   4587520,     15597568,     12058624,      1310720,     14548992,      6160384,       720896,     14352384, 
                  14680064,      3276800,      3801088,       655360,      4784128,       393216,      2359296,      6029312, 
                  12713984,     13828096,     11272192,      6422528,      9502720,      9764864,     14942208,      7929856, 
                  15138816,     13107200,      3604480,      7143424,      9240576,     13959168,      5111808,     11075584, 
                   7077888,      5636096,     15990784,     15335424,      6619136,      7995392,     11403264,       524288, 
                  12189696,      7864320,      2424832,      3014656,      1835008,     10878976,     11796480,     12976128, 
                  15204352,     14483456,      7602176,      2031616,      4915200,     12386304,      9109504,      9043968, 
                   7340032,      4063232,     11862016,      6684672,      4718592,       196608,     16121856,       917504, 
                   6356992,      3473408,      5701632,     12124160,      8781824,     12648448,      1900544,     10354688, 
                  14745600,     16252928,      9961472,      1114112,      6881280,     14221312,      9306112,      9699328, 
                  10158080,      1966080,      8847360,     15269888,     13500416,      5570560,      2621440,     14614528, 
                   9175040,     10551296,      8978432,       851968,     12517376,     15073280,      4325376,      6815744, 
                   4259840,     10027008,      2949120,       983040,     11534336,      5505024,     12255232,      1441792 };

        private static readonly int[] s_TF4 = new int[256]
            {   1660944384,   2080374784,   1996488704,   2063597568,   -234881024,   1795162112,   1862270976,   -989855744, 
                 805306368,     16777216,   1728053248,    721420288,    -33554432,   -687865856,  -1426063360,   1979711488, 
                -905969664,  -2113929216,   -922746880,   2097152000,   -100663296,   1493172224,   1191182336,   -268435456, 
               -1392508928,   -738197504,  -1577058304,  -1358954496,  -1677721600,  -1543503872,   1912602624,  -1073741824, 
               -1224736768,    -50331648,  -1828716544,    637534208,    905969664,   1056964608,   -150994944,   -872415232, 
                 872415232,  -1526726656,   -452984832,   -251658240,   1895825408,   -671088640,    822083584,    352321536, 
                  67108864,   -956301312,    587202560,  -1023410176,    402653184,  -1778384896,     83886080,  -1711276032, 
                 117440512,    301989888,  -2147483648,   -503316480,   -352321536,    654311424,  -1308622848,   1962934272, 
                 150994944,  -2097152000,    738197504,    436207616,    452984832,   1845493760,   1509949440,  -1610612736, 
                1375731712,    989855744,   -704643072,  -1291845632,    687865856,   -486539264,    788529152,  -2080374784, 
                1392508928,   -788529152,            0,   -318767104,    536870912,    -67108864,  -1325400064,   1526726656, 
                1778384896,   -889192448,  -1107296256,    956301312,   1241513984,   1275068416,   1476395008,   -822083584, 
                -805306368,   -285212672,  -1442840576,    -83886080,   1124073472,   1291845632,    855638016,  -2063597568, 
                1157627904,   -117440512,     33554432,   2130706432,   1342177280,   1006632960,  -1627389952,  -1476395008, 
                1358954496,  -1560281088,   1073741824,  -1895825408,  -1845493760,  -1660944384,    939524096,   -184549376, 
               -1140850688,  -1241513984,   -637534208,    553648128,    268435456,    -16777216,   -218103808,   -771751936, 
                -855638016,    201326592,    318767104,   -335544320,   1593835520,  -1761607680,   1140850688,    385875968, 
               -1006632960,  -1493172224,   2113929216,   1023410176,   1677721600,   1560281088,    419430400,   1929379840, 
                1610612736,  -2130706432,   1325400064,   -603979776,    570425344,    704643072,  -1879048192,  -2013265920, 
                1174405120,   -301989888,  -1207959552,    335544320,   -570425344,   1577058304,    184549376,   -620756992, 
                -536870912,    838860800,    973078528,    167772160,   1224736768,    100663296,    603979776,   1543503872, 
               -1040187392,   -754974720,  -1409286144,   1644167168,  -1862270976,  -1795162112,   -469762048,   2030043136, 
                -419430400,   -939524096,    922746880,   1828716544,  -1929379840,   -721420288,   1308622848,  -1459617792, 
                1811939328,   1442840576,   -201326592,   -369098752,   1694498816,   2046820352,  -1375731712,    134217728, 
               -1174405120,   2013265920,    620756992,    771751936,    469762048,  -1509949440,  -1275068416,   -973078528, 
                -402653184,   -587202560,   1946157056,    520093696,   1258291200,  -1124073472,  -1962934272,  -1979711488, 
                1879048192,   1040187392,  -1258291200,   1711276032,   1207959552,     50331648,   -167772160,    234881024, 
                1627389952,    889192448,   1459617792,  -1191182336,  -2046820352,  -1056964608,    486539264,  -1644167168, 
                -520093696,   -134217728,  -1744830464,    285212672,   1761607680,   -654311424,  -1912602624,  -1811939328, 
               -1694498816,    503316480,  -2030043136,   -385875968,   -838860800,   1426063360,    671088640,   -553648128, 
               -1946157056,  -1593835520,  -1996488704,    218103808,  -1090519040,   -436207616,   1107296256,   1744830464, 
                1090519040,  -1728053248,    754974720,    251658240,  -1342177280,   1409286144,  -1157627904,    369098752 };

        private static readonly int[] s_iT1 = new int[256]
            {   1353184337,   1399144830,  -1012656358,  -1772214470,   -882136261,   -247096033,  -1420232020,  -1828461749, 
                1442459680,   -160598355,  -1854485368,    625738485,    -52959921,   -674551099,  -2143013594,  -1885117771, 
                1230680542,   1729870373,  -1743852987,   -507445667,     41234371,    317738113,  -1550367091,   -956705941, 
                -413167869,  -1784901099,   -344298049,   -631680363,    763608788,   -752782248,    694804553,   1154009486, 
                1787413109,   2021232372,   1799248025,   -579749593,  -1236278850,    397248752,   1722556617,  -1271214467, 
                 407560035,  -2110711067,   1613975959,   1165972322,   -529046351,  -2068943941,    480281086,  -1809118983, 
                1483229296,    436028815,  -2022908268,  -1208452270,    601060267,   -503166094,   1468997603,    715871590, 
                 120122290,     63092015,  -1703164538,  -1526188077,   -226023376,  -1297760477,  -1167457534,   1552029421, 
                 723308426,  -1833666137,   -252573709,  -1578997426,   -839591323,   -708967162,    526529745,  -1963022652, 
               -1655493068,  -1604979806,    853641733,   1978398372,    971801355,  -1427152832,    111112542,   1360031421, 
                -108388034,   1023860118,  -1375387939,   1186850381,  -1249028975,     90031217,   1876166148,    -15380384, 
                 620468249,  -1746289194,   -868007799,   2006899047,  -1119688528,  -2004121337,    945494503,   -605108103, 
                1191869601,   -384875908,   -920746760,            0,  -2088337399,   1223502642,  -1401941730,   1316117100, 
                 -67170563,   1446544655,    517320253,    658058550,   1691946762,    564550760,   -783000677,    976107044, 
               -1318647284,    266819475,   -761860428,  -1634624741,   1338359936,  -1574904735,   1766553434,    370807324, 
                 179999714,   -450191168,   1138762300,    488053522,    185403662,  -1379431438,  -1180125651,   -928440812, 
               -2061897385,   1275557295,  -1143105042,    -44007517,  -1624899081,  -1124765092,   -985962940,    880737115, 
                1982415755,   -590994485,   1761406390,   1676797112,   -891538985,    277177154,   1076008723,    538035844, 
                2099530373,   -130171950,    288553390,   1839278535,   1261411869,   -214912292,   -330136051,   -790380169, 
                1813426987,  -1715900247,    -95906799,    577038663,   -997393240,    440397984,   -668172970,   -275762398, 
                -951170681,  -1043253031,    -22885748,    906744984,   -813566554,    685669029,    646887386,  -1530942145, 
                -459458004,    227702864,  -1681105046,   1648787028,  -1038905866,   -390539120,   1593260334,   -173030526, 
               -1098883681,   2090061929,  -1456614033,  -1290656305,    999926984,  -1484974064,   1852021992,   2075868123, 
                 158869197,   -199730834,     28809964,  -1466282109,   1701746150,   2129067946,    147831841,   -420997649, 
                -644094022,   -835293366,   -737566742,   -696471511,  -1347247055,    824393514,    815048134,  -1067015627, 
                 935087732,  -1496677636,  -1328508704,    366520115,   1251476721,   -136647615,    240176511,    804688151, 
               -1915335306,   1303441219,   1414376140,   -553347356,   -474623586,    461924940,  -1205916479,   2136040774, 
                  82468509,   1563790337,   1937016826,    776014843,   1511876531,   1389550482,    861278441,    323475053, 
               -1939744870,   2047648055,  -1911228327,  -1992551445,   -299390514,    902390199,   -303751967,   1018251130, 
                1507840668,   1064563285,   2043548696,  -1086863501,   -355600557,   1537932639,    342834655,  -2032450440, 
               -2114736182,   1053059257,    741614648,   1598071746,   1925389590,    203809468,  -1958134744,   1100287487, 
                1895934009,   -558691320,  -1662733096,  -1866377628,   1636092795,   1890988757,   1952214088,   1113045200 };

        private static readonly int[] s_iT2 = new int[256]
            {  -1477160624,   1698790995,  -1541989693,   1579629206,   1806384075,   1167925233,   1492823211,     65227667, 
                 -97509291,   1836494326,   1993115793,   1275262245,   -672837636,   -886389289,   1144333952,  -1553812081, 
                1521606217,    465184103,    250234264,  -1057071647,   1966064386,   -263421678,  -1756983901,   -103584826, 
                1603208167,  -1668147819,   2054012907,   1498584538,  -2084645843,    561273043,   1776306473,   -926314940, 
               -1983744662,   2039411832,   1045993835,   1907959773,   1340194486,  -1383534569,  -1407137434,    986611124, 
                1256153880,    823846274,    860985184,   2136171077,   2003087840,  -1368671356,  -1602093540,    722008468, 
                1749577816,    -45773031,   1826526343,   -126135625,   -747394269,     38499042,  -1893735593,  -1420466646, 
                 686535175,  -1028313341,   2076542618,    137876389,  -2027409166,  -1514200142,   1778582202,  -2112426660, 
                 483363371,  -1267095662,   -234359824,   -496415071,   -187013683,  -1106966827,   1647628575,    -22625142, 
                1395537053,   1442030240,   -511048398,   -336157579,   -326956231,   -278904662,  -1619960314,    275692881, 
               -1977532679,    115185213,     88006062,  -1108980410,  -1923837515,   1573155077,   -737803153,    357589247, 
                 -73918172,   -373434729,   1128303052,  -1629919369,   1122545853,  -1953953912,   1528424248,   -288851493, 
                 175939911,    256015593,    512030921,            0,  -2038429309,   -315936184,   1880170156,   1918528590, 
                 -15794693,    948244310,   -710001378,    959264295,   -653325724,  -1503893471,   1415289809,    775300154, 
                1728711857,   -413691121,  -1762741038,  -1852105826,   -977239985,    551313826,   1266113129,    437394454, 
               -1164713462,    715178213,   -534627261,    387650077,    218697227,   -947129683,  -1464455751,  -1457646392, 
                 435246981,    125153100,   -577114437,   1618977789,    637663135,   -177054532,    996558021,   2130402100, 
                 692292470,   -970732580,    -51530136,   -236668829,   -600713270,  -2057092592,    580326208,    298222624, 
                 608863613,   1035719416,    855223825,  -1591097491,    798891339,    817028339,   1384517100,   -473860144, 
                 380840812,  -1183798887,   1217663482,   1693009698,  -1929598780,   1072734234,    746411736,  -1875696913, 
                1313441735,   -784803391,  -1563783938,    198481974,  -2114607409,   -562387672,  -1900553690,  -1079165020, 
               -1657131804,  -1837608947,   -866162021,   1182684258,    328070850,  -1193766680,   -147247522,  -1346141451, 
               -2141347906,  -1815058052,    768962473,    304467891,  -1716729797,   2098729127,   1671227502,  -1153705093, 
                2015808777,    408514292,  -1214583807,  -1706064984,   1855317605,   -419452290,   -809754360,   -401215514, 
               -1679312167,    913263310,    161475284,   2091919830,  -1297862225,    591342129,  -1801075152,   1721906624, 
               -1135709129,   -897385306,   -795811664,   -660131051,  -1744506550,   -622050825,   1355644686,   -158263505, 
                -699566451,  -1326496947,   1303039060,     76997855,  -1244553501,  -2006299621,    523026872,   1365591679, 
                -362898172,    898367837,   1955068531,   1091304238,    493335386,   -757362094,   1443948851,   1205234963, 
                1641519756,    211892090,    351820174,   1007938441,    665439982,   -916342987,   -451091987,  -1320715716, 
                -539845543,   1945261375,   -837543815,    935818175,   -839429142,  -1426235557,   1866325780,   -616269690, 
                -206583167,   -999769794,    874788908,   1084473951,  -1021503886,    635616268,   1228679307,  -1794244799, 
                  27801969,  -1291056930,   -457910116,  -1051302768,  -2067039391,  -1238182544,   1550600308,   1471729730 };

        private static readonly int[] s_iT3 = new int[256]
            {   -195997529,   1098797925,    387629988,    658151006,  -1422144661,  -1658851003,    -89347240,   -481586429, 
                 807425530,   1991112301,   -863465098,     49620300,   -447742761,    717608907,    891715652,   1656065955, 
               -1310832294,  -1171953893,   -364537842,    -27401792,    801309301,   1283527408,   1183687575,   -747911431, 
               -1895569569,  -1844079204,   1841294202,   1385552473,  -1093390973,   1951978273,   -532076183,   -913423160, 
               -1032492407,  -1896580999,   1486449470,  -1188569743,   -507595185,  -1997531219,    550069932,   -830622662, 
                -547153846,    451248689,   1368875059,   1398949247,   1689378935,   1807451310,  -2114052960,    150574123, 
                1215322216,   1167006205,   -560691348,   2069018616,   1940595667,   1265820162,    534992783,   1432758955, 
                -340654296,  -1255210046,   -981034373,    936617224,    674296455,  -1088179547,     50510442,    384654466, 
                -813028580,   2041025204,    133427442,   1766760930,   -630862348,     84334014,    886120290,  -1497068802, 
                 775200083,   -207445931,  -1979370783,   -156994069,  -2096416276,   1614850799,   1901987487,   1857900816, 
                 557775242,   -577356538,   1054715397,   -431143235,   1418835341,   -999226019,    100954068,   1348534037, 
               -1743182597,  -1110009879,   1082772547,   -647530594,   -391070398,  -1995994997,    434583643,   -931537938, 
                2090944266,   1115482383,  -2064070370,            0,  -2146860154,    724715757,    287222896,   1517047410, 
                 251526143,  -2062592456,  -1371726123,    758523705,    252339417,   1550328230,   1536938324,    908343854, 
                 168604007,   1469255655,   -290139498,  -1692688751,  -1065332795,   -597581280,   2002413899,    303830554, 
               -1813902662,  -1597971158,    574374880,    454171927,    151915277,  -1947030073,  -1238517336,    504678569, 
                -245922535,   1974422535,  -1712407587,   2141453664,     33005350,   1918680309,   1715782971,    -77908866, 
                1133213225,    600562886,   -306812676,   -457677839,    836225756,   1665273989,  -1760346078,   -964419567, 
                1250262308,  -1143801795,   -106032846,    700935585,  -1642247377,  -1294142672,  -2045907886,  -1049112349, 
               -1288999914,   1890163129,  -1810761144,   -381214108,    -56048500,   -257942977,   2102843436,    857927568, 
                1233635150,    953795025,   -896729438,   -728222197,   -173617279,   2057644254,  -1210440050,  -1388337985, 
                 976020637,   2018512274,   1600822220,   2119459398,  -1913208301,   -661591880,    959340279,  -1014827601, 
                1570750080,   -798393197,   -714102483,    634368786,  -1396163687,    403744637,  -1662488989,   1004239803, 
                 650971512,   1500443672,  -1695809097,   1334028442,  -1780062866,     -5603610,  -1138685745,    368043752, 
                -407184997,   1867173430,  -1612000247,  -1339435396,  -1540247630,   1059729699,  -1513738092,  -1573535642, 
                1316239292,  -2097371446,  -1864322864,  -1489824296,     82922136,   -331221030,   -847311280,  -1860751370, 
                1299615190,   -280801872,  -1429449651,  -1763385596,   -778116171,   1783372680,    750893087,   1699118929, 
                1587348714,  -1946067659,  -2013629580,    201010753,   1739807261,   -611167534,    283718486,   -697494713, 
                -677737375,  -1590199796,   -128348652,    334203196,  -1446056409,   1639396809,    484568549,   1199193265, 
                -761505313,   -229294221,    337148366,   -948715721,   -145495347,    -44082262,   1038029935,   1148749531, 
               -1345682957,   1756970692,    607661108,  -1547542720,    488010435,   -490992603,   1009290057,    234832277, 
               -1472630527,    201907891,  -1260872476,   1449431233,   -881106556,    852848822,   1816687708,  -1194311081 };

        private static readonly int[] s_iT4 = new int[256]
            {   1364240372,   2119394625,    449029143,    982933031,   1003187115,    535905693,  -1398056710,   1267925987, 
                 542505520,  -1376359050,  -2003732788,   -182105086,   1341970405,   -975713494,    645940277,  -1248877726, 
                -565617999,    627514298,   1167593194,   1575076094,  -1023249105,  -2129465268,  -1918658746,   1808202195, 
                  65494927,    362126482,  -1075086739,  -1780852398,   -735214658,   1490231668,   1227450848,  -1908094775, 
                1969916354,   -193431154,  -1721024936,    668823993,  -1095348255,   -266883704,   -916018144,   2108963534, 
                1662536415,   -444452582,  -1755303087,   1648721747,  -1310689436,  -1148932501,    -31678335,   -107730168, 
                1884842056,  -1894122171,  -1803064098,   1387788411,  -1423715469,   1927414347,   -480800993,   1714072405, 
               -1308153621,    788775605,  -2036696123,   -744159177,    821200680,    598910399,     45771267,   -312704490, 
               -1976886065,  -1483557767,   -202313209,   1319232105,   1707996378,    114671109,   -786472396,   -997523802, 
                 882725678,  -1566550541,     87220618,  -1535775754,    188345475,   1084944224,   1577492337,  -1118760850, 
                1056541217,  -1774385443,   -575797954,   1296481766,  -1850372780,   1896177092,     74437638,   1627329872, 
                 421854104,   -694687299,  -1983102144,   1735892697,  -1329773848,    126389129,   -415737063,   2044456648, 
               -1589179780,   2095648578,   -121037180,            0,    159614592,    843640107,    514617361,   1817080410, 
                 -33816818,    257308805,   1025430958,    908540205,    174381327,   1747035740,  -1680780197,    607792694, 
                 212952842,  -1827674281,  -1261267218,    463376795,  -2142255680,   1638015196,   1516850039,    471210514, 
                -502613357,  -1058723168,   1011081250,    303896347,    235605257,   -223492213,    767142070,    348694814, 
                1468340721,  -1353971851,   -289677927,  -1543675777,   -140564991,   1555887474,   1153776486,   1530167035, 
               -1955190461,   -874723805,  -1234633491,  -1201409564,   -674571215,   1108378979,    322970263,  -2078273082, 
               -2055396278,   -755483205,  -1374604551,   -949116631,    491466654,   -588042062,    233591430,   2010178497, 
                 728503987,  -1449543312,    301615252,   1193436393,  -1463513860,  -1608892432,   1457007741,    586125363, 
               -2016981431,   -641609416,  -1929469238,  -1741288492,  -1496350219,  -1524048262,   -635007305,   1067761581, 
                 753179962,   1343066744,   1788595295,   1415726718,   -155053171,  -1863796520,    777975609,  -2097827901, 
               -1614905251,   1769771984,   1873358293,   -810347995,   -935618132,    279411992,   -395418724,   -612648133, 
                -855017434,   1861490777,   -335431782,  -2086102449,   -429560171,  -1434523905,    554225596,   -270079979, 
               -1160143897,   1255028335,   -355202657,    701922480,    833598116,    707863359,   -969894747,    901801634, 
                1949809742,    -56178046,   -525283184,    857069735,   -246769660,   1106762476,   2131644621,    389019281, 
                1989006925,   1129165039,   -866890326,   -455146346,  -1629243951,   1276872810,  -1044898004,   1182749029, 
               -1660622242,     22885772,    -93096825,    -80854773,  -1285939865,  -1840065829,   -382511600,   1829980118, 
               -1702075945,    930745505,   1502483704,   -343327725,   -823253079,  -1221211807,   -504503012,   2050797895, 
               -1671831598,   1430221810,    410635796,   1941911495,   1407897079,   1599843069,   -552308931,   2022103876, 
                -897453137,  -1187068824,    942421028,  -1033944925,    376619805,  -1140054558,    680216892,    -12479219, 
                 963707304,    148812556,   -660806476,   1687208278,   2069988555,   -714033614,   1215585388,   -800958536 };

        private static readonly int[] s_iTF1 = new int[256]
            {           82,            9,          106,          213,           48,           54,          165,           56, 
                       191,           64,          163,          158,          129,          243,          215,          251, 
                       124,          227,           57,          130,          155,           47,          255,          135, 
                        52,          142,           67,           68,          196,          222,          233,          203, 
                        84,          123,          148,           50,          166,          194,           35,           61, 
                       238,           76,          149,           11,           66,          250,          195,           78, 
                         8,           46,          161,          102,           40,          217,           36,          178, 
                       118,           91,          162,           73,          109,          139,          209,           37, 
                       114,          248,          246,          100,          134,          104,          152,           22, 
                       212,          164,           92,          204,           93,          101,          182,          146, 
                       108,          112,           72,           80,          253,          237,          185,          218, 
                        94,           21,           70,           87,          167,          141,          157,          132, 
                       144,          216,          171,            0,          140,          188,          211,           10, 
                       247,          228,           88,            5,          184,          179,           69,            6, 
                       208,           44,           30,          143,          202,           63,           15,            2, 
                       193,          175,          189,            3,            1,           19,          138,          107, 
                        58,          145,           17,           65,           79,          103,          220,          234, 
                       151,          242,          207,          206,          240,          180,          230,          115, 
                       150,          172,          116,           34,          231,          173,           53,          133, 
                       226,          249,           55,          232,           28,          117,          223,          110, 
                        71,          241,           26,          113,           29,           41,          197,          137, 
                       111,          183,           98,           14,          170,           24,          190,           27, 
                       252,           86,           62,           75,          198,          210,          121,           32, 
                       154,          219,          192,          254,          120,          205,           90,          244, 
                        31,          221,          168,           51,          136,            7,          199,           49, 
                       177,           18,           16,           89,           39,          128,          236,           95, 
                        96,           81,          127,          169,           25,          181,           74,           13, 
                        45,          229,          122,          159,          147,          201,          156,          239, 
                       160,          224,           59,           77,          174,           42,          245,          176, 
                       200,          235,          187,           60,          131,           83,          153,           97, 
                        23,           43,            4,          126,          186,          119,          214,           38, 
                       225,          105,           20,           99,           85,           33,           12,          125 };

        private static readonly int[] s_iTF2 = new int[256]
            {        20992,         2304,        27136,        54528,        12288,        13824,        42240,        14336, 
                     48896,        16384,        41728,        40448,        33024,        62208,        55040,        64256, 
                     31744,        58112,        14592,        33280,        39680,        12032,        65280,        34560, 
                     13312,        36352,        17152,        17408,        50176,        56832,        59648,        51968, 
                     21504,        31488,        37888,        12800,        42496,        49664,         8960,        15616, 
                     60928,        19456,        38144,         2816,        16896,        64000,        49920,        19968, 
                      2048,        11776,        41216,        26112,        10240,        55552,         9216,        45568, 
                     30208,        23296,        41472,        18688,        27904,        35584,        53504,         9472, 
                     29184,        63488,        62976,        25600,        34304,        26624,        38912,         5632, 
                     54272,        41984,        23552,        52224,        23808,        25856,        46592,        37376, 
                     27648,        28672,        18432,        20480,        64768,        60672,        47360,        55808, 
                     24064,         5376,        17920,        22272,        42752,        36096,        40192,        33792, 
                     36864,        55296,        43776,            0,        35840,        48128,        54016,         2560, 
                     63232,        58368,        22528,         1280,        47104,        45824,        17664,         1536, 
                     53248,        11264,         7680,        36608,        51712,        16128,         3840,          512, 
                     49408,        44800,        48384,          768,          256,         4864,        35328,        27392, 
                     14848,        37120,         4352,        16640,        20224,        26368,        56320,        59904, 
                     38656,        61952,        52992,        52736,        61440,        46080,        58880,        29440, 
                     38400,        44032,        29696,         8704,        59136,        44288,        13568,        34048, 
                     57856,        63744,        14080,        59392,         7168,        29952,        57088,        28160, 
                     18176,        61696,         6656,        28928,         7424,        10496,        50432,        35072, 
                     28416,        46848,        25088,         3584,        43520,         6144,        48640,         6912, 
                     64512,        22016,        15872,        19200,        50688,        53760,        30976,         8192, 
                     39424,        56064,        49152,        65024,        30720,        52480,        23040,        62464, 
                      7936,        56576,        43008,        13056,        34816,         1792,        50944,        12544, 
                     45312,         4608,         4096,        22784,         9984,        32768,        60416,        24320, 
                     24576,        20736,        32512,        43264,         6400,        46336,        18944,         3328, 
                     11520,        58624,        31232,        40704,        37632,        51456,        39936,        61184, 
                     40960,        57344,        15104,        19712,        44544,        10752,        62720,        45056, 
                     51200,        60160,        47872,        15360,        33536,        21248,        39168,        24832, 
                      5888,        11008,         1024,        32256,        47616,        30464,        54784,         9728, 
                     57600,        26880,         5120,        25344,        21760,         8448,         3072,        32000 };

        private static readonly int[] s_iTF3 = new int[256]
            {      5373952,       589824,      6946816,     13959168,      3145728,      3538944,     10813440,      3670016, 
                  12517376,      4194304,     10682368,     10354688,      8454144,     15925248,     14090240,     16449536, 
                   8126464,     14876672,      3735552,      8519680,     10158080,      3080192,     16711680,      8847360, 
                   3407872,      9306112,      4390912,      4456448,     12845056,     14548992,     15269888,     13303808, 
                   5505024,      8060928,      9699328,      3276800,     10878976,     12713984,      2293760,      3997696, 
                  15597568,      4980736,      9764864,       720896,      4325376,     16384000,     12779520,      5111808, 
                    524288,      3014656,     10551296,      6684672,      2621440,     14221312,      2359296,     11665408, 
                   7733248,      5963776,     10616832,      4784128,      7143424,      9109504,     13697024,      2424832, 
                   7471104,     16252928,     16121856,      6553600,      8781824,      6815744,      9961472,      1441792, 
                  13893632,     10747904,      6029312,     13369344,      6094848,      6619136,     11927552,      9568256, 
                   7077888,      7340032,      4718592,      5242880,     16580608,     15532032,     12124160,     14286848, 
                   6160384,      1376256,      4587520,      5701632,     10944512,      9240576,     10289152,      8650752, 
                   9437184,     14155776,     11206656,            0,      9175040,     12320768,     13828096,       655360, 
                  16187392,     14942208,      5767168,       327680,     12058624,     11730944,      4521984,       393216, 
                  13631488,      2883584,      1966080,      9371648,     13238272,      4128768,       983040,       131072, 
                  12648448,     11468800,     12386304,       196608,        65536,      1245184,      9043968,      7012352, 
                   3801088,      9502720,      1114112,      4259840,      5177344,      6750208,     14417920,     15335424, 
                   9895936,     15859712,     13565952,     13500416,     15728640,     11796480,     15073280,      7536640, 
                   9830400,     11272192,      7602176,      2228224,     15138816,     11337728,      3473408,      8716288, 
                  14811136,     16318464,      3604480,     15204352,      1835008,      7667712,     14614528,      7208960, 
                   4653056,     15794176,      1703936,      7405568,      1900544,      2686976,     12910592,      8978432, 
                   7274496,     11993088,      6422528,       917504,     11141120,      1572864,     12451840,      1769472, 
                  16515072,      5636096,      4063232,      4915200,     12976128,     13762560,      7929856,      2097152, 
                  10092544,     14352384,     12582912,     16646144,      7864320,     13434880,      5898240,     15990784, 
                   2031616,     14483456,     11010048,      3342336,      8912896,       458752,     13041664,      3211264, 
                  11599872,      1179648,      1048576,      5832704,      2555904,      8388608,     15466496,      6225920, 
                   6291456,      5308416,      8323072,     11075584,      1638400,     11862016,      4849664,       851968, 
                   2949120,     15007744,      7995392,     10420224,      9633792,     13172736,     10223616,     15663104, 
                  10485760,     14680064,      3866624,      5046272,     11403264,      2752512,     16056320,     11534336, 
                  13107200,     15400960,     12255232,      3932160,      8585216,      5439488,     10027008,      6356992, 
                   1507328,      2818048,       262144,      8257536,     12189696,      7798784,     14024704,      2490368, 
                  14745600,      6881280,      1310720,      6488064,      5570560,      2162688,       786432,      8192000 };

        private static readonly int[] s_iTF4 = new int[256]
            {   1375731712,    150994944,   1778384896,   -721420288,    805306368,    905969664,  -1526726656,    939524096, 
               -1090519040,   1073741824,  -1560281088,  -1644167168,  -2130706432,   -218103808,   -687865856,    -83886080, 
                2080374784,   -486539264,    956301312,  -2113929216,  -1694498816,    788529152,    -16777216,  -2030043136, 
                 872415232,  -1912602624,   1124073472,   1140850688,  -1006632960,   -570425344,   -385875968,   -889192448, 
                1409286144,   2063597568,  -1811939328,    838860800,  -1509949440,  -1040187392,    587202560,   1023410176, 
                -301989888,   1275068416,  -1795162112,    184549376,   1107296256,   -100663296,  -1023410176,   1308622848, 
                 134217728,    771751936,  -1593835520,   1711276032,    671088640,   -654311424,    603979776,  -1308622848, 
                1979711488,   1526726656,  -1577058304,   1224736768,   1828716544,  -1962934272,   -788529152,    620756992, 
                1912602624,   -134217728,   -167772160,   1677721600,  -2046820352,   1744830464,  -1744830464,    369098752, 
                -738197504,  -1543503872,   1543503872,   -872415232,   1560281088,   1694498816,  -1241513984,  -1845493760, 
                1811939328,   1879048192,   1207959552,   1342177280,    -50331648,   -318767104,  -1191182336,   -637534208, 
                1577058304,    352321536,   1174405120,   1459617792,  -1493172224,  -1929379840,  -1660944384,  -2080374784, 
               -1879048192,   -671088640,  -1426063360,            0,  -1946157056,  -1140850688,   -754974720,    167772160, 
                -150994944,   -469762048,   1476395008,     83886080,  -1207959552,  -1291845632,   1157627904,    100663296, 
                -805306368,    738197504,    503316480,  -1895825408,   -905969664,   1056964608,    251658240,     33554432, 
               -1056964608,  -1358954496,  -1124073472,     50331648,     16777216,    318767104,  -1979711488,   1795162112, 
                 973078528,  -1862270976,    285212672,   1090519040,   1325400064,   1728053248,   -603979776,   -369098752, 
               -1761607680,   -234881024,   -822083584,   -838860800,   -268435456,  -1275068416,   -436207616,   1929379840, 
               -1778384896,  -1409286144,   1946157056,    570425344,   -419430400,  -1392508928,    889192448,  -2063597568, 
                -503316480,   -117440512,    922746880,   -402653184,    469762048,   1962934272,   -553648128,   1845493760, 
                1191182336,   -251658240,    436207616,   1895825408,    486539264,    687865856,   -989855744,  -1996488704, 
                1862270976,  -1224736768,   1644167168,    234881024,  -1442840576,    402653184,  -1107296256,    452984832, 
                 -67108864,   1442840576,   1040187392,   1258291200,   -973078528,   -771751936,   2030043136,    536870912, 
               -1711276032,   -620756992,  -1073741824,    -33554432,   2013265920,   -855638016,   1509949440,   -201326592, 
                 520093696,   -587202560,  -1476395008,    855638016,  -2013265920,    117440512,   -956301312,    822083584, 
               -1325400064,    301989888,    268435456,   1493172224,    654311424,  -2147483648,   -335544320,   1593835520, 
                1610612736,   1358954496,   2130706432,  -1459617792,    419430400,  -1258291200,   1241513984,    218103808, 
                 754974720,   -452984832,   2046820352,  -1627389952,  -1828716544,   -922746880,  -1677721600,   -285212672, 
               -1610612736,   -536870912,    989855744,   1291845632,  -1375731712,    704643072,   -184549376,  -1342177280, 
                -939524096,   -352321536,  -1157627904,   1006632960,  -2097152000,   1392508928,  -1728053248,   1627389952, 
                 385875968,    721420288,     67108864,   2113929216,  -1174405120,   1996488704,   -704643072,    637534208, 
                -520093696,   1761607680,    335544320,   1660944384,   1426063360,    553648128,    201326592,   2097152000 };


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rijndael.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Rijndael.cs
//

namespace System.Security.Cryptography
{
    using System;
    using System.Security;
    using System.Security.Util;

    /// <include file='doc\Rijndael.uex' path='docs/doc[@for="Rijndael"]/*' />
    public abstract class Rijndael : SymmetricAlgorithm
    {
        private static  KeySizes[] s_legalBlockSizes = {
          new KeySizes(128, 256, 64)
        };

        private static  KeySizes[] s_legalKeySizes = {
            new KeySizes(128, 256, 64)
        };

        // *********************** CONSTRUCTORS *************************

        /// <include file='doc\Rijndael.uex' path='docs/doc[@for="Rijndael.Rijndael"]/*' />
        public Rijndael() {
            KeySizeValue = 256;
            BlockSizeValue = 128;
            FeedbackSizeValue = BlockSizeValue;
            LegalBlockSizesValue = s_legalBlockSizes;
            LegalKeySizesValue = s_legalKeySizes;
        }

        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\Rijndael.uex' path='docs/doc[@for="Rijndael.Create"]/*' />
        new static public Rijndael Create() {
            return Create("System.Security.Cryptography.Rijndael");
        }

        /// <include file='doc\Rijndael.uex' path='docs/doc[@for="Rijndael.Create1"]/*' />
        new static public Rijndael Create(String algName) {
            return (Rijndael) CryptoConfig.CreateFromName(algName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rfc2898derivebytes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Rfc2898DeriveBytes.cs
//

// This implementation follows RFC2898 recommendations. See http://www.ietf.org/rfc/rfc2898.txt

namespace System.Security.Cryptography {

    using System.IO;
    using System.Text;
	using System.Runtime.CompilerServices;

    /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes"]/*' />
    public class Rfc2898DeriveBytes : DeriveBytes
    {
        private int             _iterations;
        private byte[]          _rgbSalt;
        private String          _strPassword;
        private byte[]          _rgbPassword;
        private HashAlgorithm   _hmacsha1;  // The pseudo-random generator function used in PBKDF2
        private int             _iSuffix;
        private const int       BlockSize = 20;

        // *********************** Constructors ****************************


        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Rfc2898DeriveBytes"]/*' />
        public Rfc2898DeriveBytes(String strPassword, int saltSize) : this(strPassword, saltSize, 100) {}


        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Rfc2898DeriveBytes1"]/*' />
        public Rfc2898DeriveBytes(String strPassword, int saltSize, int iterations) {
            _strPassword = strPassword;
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            if (saltSize < 0) throw new ArgumentOutOfRangeException("saltSize", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            // 8 is the minimum size for an acceptable salt      
            if (saltSize < 8) throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_FewBytesSalt")));
            _rgbSalt = new byte[saltSize];
            rng.GetBytes(_rgbSalt);       
            _iterations = 100;
            //  Convert password to UTF8 string
            _rgbPassword = (new UTF8Encoding(false)).GetBytes(_strPassword);
            _hmacsha1 = new HMACSHA1(_rgbPassword);
            _iSuffix = 1;
        }

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Rfc2898DeriveBytes2"]/*' />
        public Rfc2898DeriveBytes(String strPassword, byte[] rgbSalt) : this(strPassword, rgbSalt, 100) {}

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Rfc2898DeriveBytes3"]/*' />
        public Rfc2898DeriveBytes(String strPassword, byte[] rgbSalt, int iterations) {
            _strPassword = strPassword;
            if (rgbSalt == null) throw new ArgumentNullException("rgbSalt");
            if (rgbSalt.Length < 8) throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_FewBytesSalt")));
            _rgbSalt = rgbSalt;
            if (iterations <= 0) throw new ArgumentOutOfRangeException("iterations", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
            _iterations = iterations;
            //  Convert password to UTF8 string
            _rgbPassword = (new UTF8Encoding(false)).GetBytes(_strPassword);
            _hmacsha1 = new HMACSHA1(_rgbPassword);
            _iSuffix = 1;
        }


        // ********************* Property Methods **************************

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.IterationCount"]/*' />
        public int IterationCount {
            get { return _iterations; }
            set {
                if (value <= 0) throw new ArgumentOutOfRangeException("iterations", Environment.GetResourceString("ArgumentOutOfRange_NeedNonNegNum"));
                _iterations = value;
            }
        }

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Salt"]/*' />
        public byte[] Salt {
            get { return (byte[]) _rgbSalt.Clone(); }
            set { 
                if (value == null) throw new ArgumentNullException("rgbSalt");
                if (value.Length < 8) throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_FewBytesSalt")));
                _rgbSalt = (byte[]) value.Clone(); 
            }
        }

        // ********************** Public Methods ***************************

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.GetBytes"]/*' />
        public override byte[] GetBytes(int cb) {
            byte[]  rgbOut = new byte[cb];
            int iOut = 0;
            int cBlocks = cb / BlockSize; 
            int cLastBlock = cb - cBlocks * BlockSize;

            for (int i = 1; i <= cBlocks; i++) {
                Buffer.InternalBlockCopy(Func(_rgbSalt, _iterations), 0, rgbOut, iOut, BlockSize);
                iOut += BlockSize;
            }

            // now the last block
            if (cLastBlock > 0) {
                Buffer.InternalBlockCopy(Func(_rgbSalt, _iterations), 0, rgbOut, iOut, cLastBlock);
                iOut += cLastBlock;
            }

            return rgbOut;
        }

        // This function is defined as follow :
        // Func (S, i) = HMAC(S || i) ^ HMAC2(S || i) ^ ... ^ HMAC(iterations) (S || i) 
        private byte[] Func (byte[] rgbSalt, int numIterations) {
            byte[] currentHash = new byte[BlockSize];
            byte[] rgbOut = new byte[BlockSize]; 

            _hmacsha1.Initialize();
            CryptoStream cs = new CryptoStream(Stream.Null, _hmacsha1, CryptoStreamMode.Write);              
            cs.Write(_rgbSalt, 0, _rgbSalt.Length);
            HashSuffix(cs);
             cs.Close(); 
            Buffer.InternalBlockCopy(_hmacsha1.Hash, 0, currentHash, 0, BlockSize);
            Buffer.InternalBlockCopy(_hmacsha1.Hash, 0, rgbOut, 0, BlockSize);

            for (int i=1; i<numIterations; i++) {
                _hmacsha1.Initialize();
                cs = new CryptoStream(Stream.Null, _hmacsha1, CryptoStreamMode.Write);              
                cs.Write(currentHash, 0, currentHash.Length);
                cs.Close(); 
                for (int j=0; j<BlockSize; j++) {
                    rgbOut[j] = (byte) (rgbOut[j] ^ _hmacsha1.Hash[j]); 
                }
            }
            
            return rgbOut;
        }

        /// <include file='doc\Rfc2898DeriveBytes.uex' path='docs/doc[@for="Rfc2898DeriveBytes.Reset"]/*' />
        public override void Reset() {         
            _iSuffix = 1;
        }

        private void HashSuffix(CryptoStream cs) {
            int         cb = 0;
            byte[]      rgb = {(byte)'0', (byte)'0', (byte)'0'};

            if (_iSuffix > 999) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_PasswordDerivedBytes_TooManyBytes"));
            }

            if (_iSuffix >= 100) {
                rgb[0] += (byte) (_iSuffix /100);
                cb += 1;
            }
            if (_iSuffix >= 10) {
                rgb[cb] += (byte) ((_iSuffix % 100) / 10);
                cb += 1;
            }
            if (_iSuffix > 0) {
                rgb[cb] += (byte) (_iSuffix % 10);
                cb += 1;
                cs.Write(rgb, 0, cb);
            }
            
            _iSuffix += 1;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsacryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// RSACryptoServiceProvider.cs
//
// CSP-based implementation of RSA
//
// bal 5/17/2000
//


namespace System.Security.Cryptography {
    using System.Runtime.Remoting;
    using System;
    using System.IO;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.Runtime.CompilerServices;
    using System.Globalization;
    using System.Threading;

    internal class RSACspObject {
        internal int         Exponent;
        internal byte[]      Modulus;
        internal byte[]      P;
        internal byte[]      Q;
        internal byte[]      dp;
        internal byte[]      dq;
        internal byte[]      InverseQ;
        internal byte[]      d;
    }

    /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider"]/*' />
    public sealed class RSACryptoServiceProvider : RSA
    {
        private const int ALG_CLASS_SIGNATURE   = (1 << 13);
        private const int ALG_CLASS_KEY_EXCHANGE =(5 << 13);
        private const int ALG_TYPE_RSA      = (2 << 9);
        private const int ALG_CLASS_HASH    = (4 << 13);
        private const int ALG_TYPE_ANY      = (0);
        private const int CALG_MD5     = (ALG_CLASS_HASH | ALG_TYPE_ANY | 3);
        private const int CALG_SHA1     = (ALG_CLASS_HASH | ALG_TYPE_ANY | 4);
        private const int CALG_RSA_KEYX     = (ALG_CLASS_KEY_EXCHANGE| ALG_TYPE_RSA | 0);
        private const int CALG_RSA_SIGN     = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | 0);
        private const int AT_KEYEXCHANGE        = 1;
        private const int AT_SIGNATURE          = 2;
        private const int PUBLICKEYBLOB     = 0x6;
        private const int PRIVATEKEYBLOB    = 0x7;
        private const int KP_KEYLEN              = 9;
        private const int CRYPT_OAEP            = 0x40;

        private int                 _dwKeySize;
        private int                _defaultKeySize = 1024;
        private CspParameters      _parameters;
        private IntPtr                 _hCSP;
        private __CSPHandleProtector _CSPHandleProtector = null;
        private IntPtr                 _hKey;
        private __KeyHandleProtector _KeyHandleProtector = null;
        private static CodeAccessPermission _UCpermission = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
        private KeyContainerContents  _containerContents;    
        private bool                _hasEnhancedProvider = false; // TRUE if the Enhanced Provider is available on this machine
        private static bool _runningWin2KOrLaterCrypto = CryptoAPITransform.CheckForWin2KCrypto();

        // This flag indicates whether we should delete the key when this object is GC'd or
        // let it stay in the CSP
        // By default, if we generate a random key container then we do NOT persist (flag is false)
        // If the user gave us a KeyContainerName and we found the key there, we DO persist (flag is true)
        // Doing anything with persisted keys requires SecurityPermission.UnmanagedCode rights since
        // it's equivalent to calling CryptoAPI directly...
        private bool _persistKeyInCSP = false; 

        private static CspProviderFlags m_UseMachineKeyStore = 0;

        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.RSACryptoServiceProvider"]/*' />
        public RSACryptoServiceProvider() 
            : this(0, new CspParameters(1, null, null, m_UseMachineKeyStore), true) {
        }
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.RSACryptoServiceProvider1"]/*' />
        public RSACryptoServiceProvider(int dwKeySize) 
            : this(dwKeySize, new CspParameters(1, null, null, m_UseMachineKeyStore), false) {
        }
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.RSACryptoServiceProvider2"]/*' />
        public RSACryptoServiceProvider(CspParameters parameters) 
            : this(0, parameters, true) {
        }
        
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.RSACryptoServiceProvider3"]/*' />
        public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters)
            : this(dwKeySize, parameters, false) {
        }
        
        internal RSACryptoServiceProvider(int dwKeySize, CspParameters parameters, bool useDefaultKeySize) {
            int             hr;
            //
            //  Save the CSP Parameters
            //

            if (parameters == null) {
                _parameters = new CspParameters(1, null, null, m_UseMachineKeyStore);
            } else {
                // Check the parameter options: specifying either a key container name or UseDefaultKeyContainer flag
                // requires unmanaged code permission
                if (((parameters.Flags & CspProviderFlags.UseDefaultKeyContainer) != 0)
                    || ((parameters.KeyContainerName != null) && (parameters.KeyContainerName.Length > 0))) {
                    _UCpermission.Demand();
                    // If we specified a key container name for this key, then mark it persisted
                    if ((parameters.KeyContainerName != null) && (parameters.KeyContainerName.Length > 0)) {
                        // CAPI doesn't accept Container Names longer than 260 characters
                        if (parameters.KeyContainerName.Length > 260) 
                            throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeyContainerName")); 

                        _persistKeyInCSP = true;
                    }
                }
                _parameters = parameters;
            }

    
            //
            //  If no key spec has been specified, then set it to be
            //      AT_KEYEXCHANGE,  if a CALG_* has been specified, then
            //      map that to AT_* value
            if (_parameters.KeyNumber == -1) {
                _parameters.KeyNumber = AT_KEYEXCHANGE;
            }
            else if (_parameters.KeyNumber == CALG_RSA_KEYX) {
                _parameters.KeyNumber = AT_KEYEXCHANGE;
            }
            else if (_parameters.KeyNumber == CALG_RSA_SIGN) {
                _parameters.KeyNumber = AT_SIGNATURE;
            }

            // See if we have the Enhanced RSA provider on this machine
            _hasEnhancedProvider = HasEnhancedProvider();
    
            // Now determine legal key sizes.  If AT_SIGNATURE, then 384 -- 16386.  Otherwise, depends on
            // whether the strong provider is present.

            if (_parameters.KeyNumber == AT_SIGNATURE) {
                LegalKeySizesValue = new KeySizes[1] { new KeySizes(384, 16384, 8) };
            } else if (_hasEnhancedProvider) {
                // it is, we have the strong provider
                LegalKeySizesValue = new KeySizes[1] { new KeySizes(384, 16384, 8) };
            } else {
                // nope, all we have is the base provider
                LegalKeySizesValue = new KeySizes[1] { new KeySizes(384, 512, 8) };
                // tone down the default key size
                _defaultKeySize = 512;
            }
            // Set the key size; this will throw an exception if dwKeySize is invalid.
            // Don't check if dwKeySize == 0, since that's the "default size", however
            // *our* default should be 1024 if the CSP can handle it.  So, if the 
            // key size was unspecified in a constructor to us, it'll be -1 here and 
            // change it to the default size.  If the user really put in a 0 give him back
            // the default for the CSP whatever it is.
            if (useDefaultKeySize) dwKeySize = _defaultKeySize;
            if (dwKeySize != 0) {
                KeySize = dwKeySize;
            }
            _dwKeySize = dwKeySize;
            
            //
            //  Create the CSP container for this set of keys
            //
            _hCSP = IntPtr.Zero;
            _hKey = IntPtr.Zero;
            hr = _CreateCSP(_parameters, ref _hCSP);
            if (hr != 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            }
            if (_hCSP == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            }            

            // If the key already exists, use it, else generate a new one
            hr = _GetUserKey(_hCSP, _parameters.KeyNumber, ref _hKey);
            if (hr != 0) {
                _hKey = _GenerateKey(_hCSP, _parameters.KeyNumber, dwKeySize << 16);                
                if (_hKey == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateKey"));
                }
                // We just gen'd a new key pair, so we have both halves.
                _containerContents = KeyContainerContents.PublicAndExportablePrivate;
            } else {
                // If the key already exists, make sure to persist it
                _persistKeyInCSP = true;
                // we have both halves, but we don't know if it's exportable or not
                _containerContents = KeyContainerContents.Unknown;
            }

            _CSPHandleProtector = new __CSPHandleProtector(_hCSP, _persistKeyInCSP, _parameters);
            _KeyHandleProtector = new __KeyHandleProtector(_hKey);
        }
        
        // RSACryptoServiceProvider, as an AsymmetricAlgorithm, has to implement IDisposable.

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (_KeyHandleProtector != null && !_KeyHandleProtector.IsClosed) {
                _KeyHandleProtector.Close();
            }
            if (_CSPHandleProtector != null && !_CSPHandleProtector.IsClosed) {
                _CSPHandleProtector.Close();
            }
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.Finalize"]/*' />
        ~RSACryptoServiceProvider() {
            Dispose(false);
        }

        private bool HasEnhancedProvider() {
            // OK, let's find out what we have
                
            // Acquire a Type 1 provider.  This will be the Enhanced provider if available, otherwise 
            // it will be the base provider.
            IntPtr trialCSPHandle = IntPtr.Zero;
            int trialHR = 0;
            int hasRSAHR = 0;
            CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
            trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
            if (trialCSPHandle == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            } 
            // OK, now see if CALG_RSA_KEYX is present with key size 2048 in the provider we got back
            hasRSAHR = _SearchForAlgorithm(trialCSPHandle, CALG_RSA_KEYX, 2048);
            _FreeCSP(trialCSPHandle);
            // If hasRSAHR == 0, we have the strong provider
            return(hasRSAHR == 0);
        }

        private void ReverseRSACspObject(RSACspObject obj) {
            if (obj.Modulus != null) {
                Array.Reverse(obj.Modulus);
            }
            if (obj.P != null) {
                Array.Reverse(obj.P);
            }
            if (obj.Q != null) {
                Array.Reverse(obj.Q);
            }
            if (obj.dp != null) {
                Array.Reverse(obj.dp);
            }
            if (obj.dq != null) {
                Array.Reverse(obj.dq);
            }
            if (obj.InverseQ != null) {
                Array.Reverse(obj.InverseQ);
            }
            if (obj.d != null) {
                Array.Reverse(obj.d);
            }
        }
    
        /************************* Property Methods **********************/
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.KeySize"]/*' />
        public override int KeySize {
            get {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        byte[] rgbKeySize = _GetKeyParameter(_KeyHandleProtector.Handle, KP_KEYLEN);
                        _dwKeySize = (rgbKeySize[0] | (rgbKeySize[1] << 8) | (rgbKeySize[2] << 16) | (rgbKeySize[3] << 24));
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                return _dwKeySize;
            }
        }
        
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.KeyExchangeAlgorithm"]/*' />
        public override String KeyExchangeAlgorithm {
            get { 
                if (_parameters.KeyNumber == AT_KEYEXCHANGE) {
                    return "RSA-PKCS1-KeyEx"; 
                } else {
                    return(null);
                }
            }
        }
        
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.SignatureAlgorithm"]/*' />
        public override String SignatureAlgorithm {
            get { return "http://www.w3.org/2000/09/xmldsig#rsa-sha1"; }
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.UseMachineKeyStore"]/*' />
        public static bool UseMachineKeyStore {
            get { return (m_UseMachineKeyStore == CspProviderFlags.UseMachineKeyStore); }
            set { m_UseMachineKeyStore = (value ? CspProviderFlags.UseMachineKeyStore : 0); }
        }
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.PersistKeyInCsp"]/*' />
        public bool PersistKeyInCsp {
            get { return _persistKeyInCSP; }
            set { 
                _UCpermission.Demand();
                _persistKeyInCSP = value;
                _CSPHandleProtector.PersistKeyInCsp = value;
            }
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.ExportParameters"]/*' />    
        public override RSAParameters ExportParameters(bool includePrivateParameters) {
            int             hr;
            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            RSACspObject  rsaKey = new RSACspObject();
            RSAParameters rsaParams = new RSAParameters();
            if (includePrivateParameters) {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        hr = _ExportKey(_KeyHandleProtector.Handle, PRIVATEKEYBLOB, rsaKey);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                if (hr != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ExportKey"));
                }
                // Must reverse after export!
                ReverseRSACspObject(rsaKey);
                rsaParams.Modulus = rsaKey.Modulus;
                rsaParams.Exponent = ConvertIntToByteArray(rsaKey.Exponent);
                rsaParams.P = rsaKey.P;
                rsaParams.Q = rsaKey.Q;
                rsaParams.DP = rsaKey.dp;
                rsaParams.DQ = rsaKey.dq;
                rsaParams.InverseQ = rsaKey.InverseQ;
                rsaParams.D = rsaKey.d;
            } else {
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        hr = _ExportKey(_KeyHandleProtector.Handle, PUBLICKEYBLOB, rsaKey);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
                if (hr != 0) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_ExportKey"));
                } 
                // Must reverse after export!
                ReverseRSACspObject(rsaKey);
                rsaParams.Modulus = rsaKey.Modulus;
                rsaParams.Exponent = ConvertIntToByteArray(rsaKey.Exponent);
                // zeroize private info
                if (rsaKey.d != null)
                    Array.Clear(rsaKey.d, 0, rsaKey.d.Length);
                if (rsaKey.P != null)
                    Array.Clear(rsaKey.P, 0, rsaKey.P.Length);
                if (rsaKey.Q != null)
                    Array.Clear(rsaKey.Q, 0, rsaKey.Q.Length);
                if (rsaKey.dp != null)
                    Array.Clear(rsaKey.dp, 0, rsaKey.dp.Length);
                if (rsaKey.dq != null)
                    Array.Clear(rsaKey.dq, 0, rsaKey.dq.Length);
                if (rsaKey.InverseQ != null)
                    Array.Clear(rsaKey.InverseQ, 0, rsaKey.InverseQ.Length);
            }
            return(rsaParams);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.ImportParameters"]/*' />
        public override void ImportParameters(RSAParameters parameters) {
            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            RSACspObject      rsaKey = new RSACspObject();
            
            // Modulus is required for both public & private keys
            if (parameters.Modulus == null) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_MissingField"));
            }
            rsaKey.Modulus = (byte[]) parameters.Modulus.Clone();
            // Exponent is required
            byte[] rgbExponent = parameters.Exponent;
            if (rgbExponent == null) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_MissingField"));
            }
            rsaKey.Exponent = ConvertByteArrayToInt(rgbExponent);
            // p is optional
            rsaKey.P = (parameters.P == null ? null : ((byte[]) parameters.P.Clone()));
            // q is optional
            rsaKey.Q = (parameters.Q == null ? null : ((byte[]) parameters.Q.Clone()));
            // dp is optional
            rsaKey.dp = (parameters.DP == null ? null : ((byte[]) parameters.DP.Clone()));
            // dq is optional
            rsaKey.dq = (parameters.DQ == null ? null : ((byte[]) parameters.DQ.Clone()));
            // InverseQ is optional
            rsaKey.InverseQ = (parameters.InverseQ == null ? null : ((byte[]) parameters.InverseQ.Clone()));
            // d is optional
            rsaKey.d = (parameters.D == null ? null : ((byte[]) parameters.D.Clone()));

            // NOTE: We must reverse the rsaKey before importing!
            ReverseRSACspObject(rsaKey);
            // Free the current key handle
            _KeyHandleProtector.Close();
            // Now, import the key into the CSP
            bool incremented = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incremented)) {
                    _hKey = _ImportKey(_CSPHandleProtector.Handle, CALG_RSA_KEYX, rsaKey);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _CSPHandleProtector.Release();
            }

            _KeyHandleProtector = new __KeyHandleProtector(_hKey);                        
            _parameters.KeyNumber = AT_KEYEXCHANGE;
            // reset _containerContents
            if (rsaKey.P == null) {
                _containerContents = KeyContainerContents.PublicOnly;              
            } else {
                // Our key pairs are always exportable
                _containerContents = KeyContainerContents.PublicAndExportablePrivate;
            }
            // zeroize private info
            if (rsaKey.d != null)
               Array.Clear(rsaKey.d, 0, rsaKey.d.Length);
            if (rsaKey.P != null)
               Array.Clear(rsaKey.P, 0, rsaKey.P.Length);
            if (rsaKey.Q != null)
               Array.Clear(rsaKey.Q, 0, rsaKey.Q.Length);
            if (rsaKey.dp != null)
               Array.Clear(rsaKey.dp, 0, rsaKey.dp.Length);
            if (rsaKey.dq != null)
               Array.Clear(rsaKey.dq, 0, rsaKey.dq.Length);
            if (rsaKey.InverseQ != null)
               Array.Clear(rsaKey.InverseQ, 0, rsaKey.InverseQ.Length);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.SignData"]/*' />
        public byte[] SignData(Stream inputStream, Object halg)
        {
            byte[] hashVal;
            string strOID = ObjToOID(ref halg);

            hashVal = ((HashAlgorithm)halg).ComputeHash(inputStream);
            return SignHash(hashVal, strOID);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.SignData1"]/*' />
        public byte[] SignData(byte[] buffer, Object halg)
        {
            byte[] hashVal;
            string strOID = ObjToOID(ref halg);

            hashVal = ((HashAlgorithm)halg).ComputeHash(buffer);
            return SignHash(hashVal, strOID);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.SignData2"]/*' />
        public byte[] SignData(byte[] buffer, int offset, int count, Object halg)
        {
            byte[] hashVal;
            string strOID = ObjToOID(ref halg);

            hashVal = ((HashAlgorithm)halg).ComputeHash(buffer, offset, count);
            return SignHash(hashVal, strOID);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.VerifyData"]/*' />
        public bool VerifyData(byte[] buffer, Object halg, byte[] signature)
        {
            byte[] hashVal;
            string strOID = ObjToOID(ref halg);

            hashVal = ((HashAlgorithm)halg).ComputeHash(buffer);
            return VerifyHash(hashVal, strOID, signature);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.SignHash"]/*' />
        public byte[] SignHash(byte[] rgbHash, String str)
        {
            int             calgHash;
            byte[]         rgbOut;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (_containerContents == KeyContainerContents.PublicOnly) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_NoPrivateKey"));
            }
    
            calgHash = MapOIDToCalg(str);
            // SHA1 HashSize is 20 bytes, MD5 HashSize is 16 bytes
            if (calgHash == CALG_SHA1 && rgbHash.Length != 20) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "SHA1", 20));
            }
            if (calgHash == CALG_MD5 && rgbHash.Length != 16) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "MD5", 16));
            }
    
            bool incremented = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incremented)) {
                    rgbOut = _SignValue(_CSPHandleProtector.Handle, _parameters.KeyNumber, calgHash, rgbHash, 0);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _CSPHandleProtector.Release();
            }

            // Need to reverse the signature we get from CAPI!
            Array.Reverse(rgbOut);
            return rgbOut;
        }
        
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.VerifyHash"]/*' />
        public bool VerifyHash(byte[] rgbHash, String str, byte[] rgbSignature)
        {
            int             calgHash;
            int             hr;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (rgbSignature == null) {
                throw new ArgumentNullException("rgbSignature");
            }
    
            calgHash = MapOIDToCalg(str);
            // SHA1 HashSize is 20 bytes, MD5 HashSize is 16 bytes
            if (calgHash == CALG_SHA1 && rgbHash.Length != 20) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "SHA1", 20));
            }
            if (calgHash == CALG_MD5 && rgbHash.Length != 16) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidHashSize"), "MD5", 16));
            }

            // must reverse the signature for input to CAPI.
            // make a copy first
            byte[] sigValue = new byte[rgbSignature.Length];
            rgbSignature.CopyTo(sigValue,0);
            Array.Reverse(sigValue);

            bool incrementedCSP = false;
            bool incrementedKey = false;
            try {
                if (_CSPHandleProtector.TryAddRef(ref incrementedCSP) && _KeyHandleProtector.TryAddRef(ref incrementedKey)) {
                    hr = _VerifySign(_CSPHandleProtector.Handle, _KeyHandleProtector.Handle, calgHash, rgbHash, sigValue, 0);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incrementedCSP) _CSPHandleProtector.Release();
                if (incrementedKey) _KeyHandleProtector.Release();
            }

            if (hr < 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_VerifySignature"));
            }            
    
            return hr == 0;
        }

        // For Encrypt and Decrypt, there are two modes
        // if fOAEP == false, then we'll try to do encryption/decryption using
        // symmetric key import/export through the exponent-of-one trick
        // if fOAEP == true, then we'll use the new functionality in the Win2K
        // enhanced provider to do direct encryption of a value with PKCS#1 v2.0 (OAEP) padding
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.Encrypt"]/*' />
        public byte[] Encrypt(byte[] rgb, bool fOAEP) {
            byte[] ciphertext;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Our behavior depends on whether fOAEP is true or not
            if (fOAEP) {
                // this is only available if we have the enhanced provider AND we're on Win2K
                if (!(_hasEnhancedProvider && _runningWin2KOrLaterCrypto)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_Padding_Win2KEnhOnly"));
                }
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        ciphertext = _EncryptPKWin2KEnh(_KeyHandleProtector.Handle, rgb, true); // true means use CRYPT_OAEP flag
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
            } else {
                if (_hasEnhancedProvider && _runningWin2KOrLaterCrypto) {
                    // Use PKCS1 v1 type 2 padding here
                    bool incremented = false;
                    try {
                        if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                            ciphertext = _EncryptPKWin2KEnh(_KeyHandleProtector.Handle, rgb, false); 
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incremented) _KeyHandleProtector.Release();
                    }
                } else {
                    // The amount we can encrypt is limited by the size of a legal symmetric key in this provider
                    // For now, if we have the enhanced provider, that limit is 128 bits = 16 bytes.
                    // For the weak provider, the limit is 40 bits = 5 bytes.
                    int maxSize = (_hasEnhancedProvider ? 16 : 5);
                    // Special case TripleDES
                    bool bException = (rgb.Length > maxSize) && !(_hasEnhancedProvider && rgb.Length == 24);
                    if (bException) {
                        throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_MaxSizePKEncrypt"),maxSize.ToString());
                    }
                    bool incrementedCSP = false;
                    bool incrementedKey = false;
                    try {
                        if (_CSPHandleProtector.TryAddRef(ref incrementedCSP) && _KeyHandleProtector.TryAddRef(ref incrementedKey)) {
                            ciphertext = _EncryptKey(_CSPHandleProtector.Handle, _KeyHandleProtector.Handle, rgb, 0);
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incrementedCSP) _CSPHandleProtector.Release();
                        if (incrementedKey) _KeyHandleProtector.Release();
                    }
                }
            }
            return ciphertext;
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.Decrypt"]/*' />
        public byte [] Decrypt(byte[] rgb, bool fOAEP) {
            byte[] plaintext;

            if (_CSPHandleProtector.IsClosed || _KeyHandleProtector.IsClosed) 
                throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));

            // Our behavior depends on whether fOAEP is true or not
            if (fOAEP) {
                // this is only available if we have the enhanced provider AND we're on Win2K
                if (!(_hasEnhancedProvider && _runningWin2KOrLaterCrypto)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_Padding_Win2KEnhOnly"));
                }
                // size check -- must be at most the modulus size
                if ((rgb.Length) > (KeySize/8)) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_Padding_DecDataTooBig"), KeySize/8));
                }
                bool incremented = false;
                try {
                    if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                        plaintext = _DecryptPKWin2KEnh(_KeyHandleProtector.Handle, rgb, true);
                    }
                    else
                        throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                }
                finally {
                    if (incremented) _KeyHandleProtector.Release();
                }
            } else {
                if (_hasEnhancedProvider && _runningWin2KOrLaterCrypto) {
                    // Use PKCS1 v1 type 2 padding here
                    bool incremented = false;
                    try {
                        if (_KeyHandleProtector.TryAddRef(ref incremented)) {
                            plaintext = _DecryptPKWin2KEnh(_KeyHandleProtector.Handle, rgb, false); 
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incremented) _KeyHandleProtector.Release();
                    }
                } else {
                    bool incrementedCSP = false;
                    bool incrementedKey = false;
                    try {
                        if (_CSPHandleProtector.TryAddRef(ref incrementedCSP) && _KeyHandleProtector.TryAddRef(ref incrementedKey)) {
                            plaintext = _DecryptKey(_CSPHandleProtector.Handle, _KeyHandleProtector.Handle, rgb, 0);
                        }
                        else
                            throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
                    }
                    finally {
                        if (incrementedCSP) _CSPHandleProtector.Release();
                        if (incrementedKey) _KeyHandleProtector.Release();
                    }
                }
            }                
            return(plaintext);
        }

        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.DecryptValue"]/*' />
        override public byte[] DecryptValue(byte[] rgb) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_Method"));
        }
    
        /// <include file='doc\RSACryptoServiceProvider.uex' path='docs/doc[@for="RSACryptoServiceProvider.EncryptValue"]/*' />
        override public byte[] EncryptValue(byte[] rgb) {
            throw new NotSupportedException(Environment.GetResourceString("NotSupported_Method"));
        }
    
        /************************* PRIVATE METHODS ************************/

        private static int ConvertByteArrayToInt(byte[] rgbInput) {
            // Input to this routine is always big endian
            int i, dwOutput;
            
            dwOutput = 0;
            for (i = 0; i < rgbInput.Length; i++) {
                dwOutput *= 256;
                dwOutput += rgbInput[i];
            }
            return(dwOutput);
        }

        private string ObjToOID (ref Object halg) {
            string strOID = null;
            string algname;

            if (halg == null)
                throw new ArgumentNullException("halg");
            
            if (halg is String)
            {
                strOID = CryptoConfig.MapNameToOID((String)halg);
                halg = (HashAlgorithm) CryptoConfig.CreateFromName((String)halg);
            }
            else if (halg is HashAlgorithm)
            {
                algname = halg.GetType().ToString();
                strOID = CryptoConfig.MapNameToOID(algname);
            }
            else if (halg is Type)
            {
                algname = halg.ToString();
                strOID = CryptoConfig.MapNameToOID(algname);
                halg = (HashAlgorithm) CryptoConfig.CreateFromName(halg.ToString());
            }
            else
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidValue"));            

            return strOID;
        }

        private static byte[] ConvertIntToByteArray(int dwInput) {
            // output of this routine is always big endian
            byte[] rgbTemp = new byte[8]; // int can never be greater than Int64
            int t1;  // t1 is remaining value to account for
            int t2;  // t2 is t1 % 256
            int i = 0;

            if (dwInput == 0) return new byte[1]; 
            t1 = dwInput; 
            while (t1 > 0) {
                BCLDebug.Assert(i < 8, "Got too big an int here!");
                t2 = t1 % 256;
                rgbTemp[i] = (byte) t2;
                t1 = (t1 - t2)/256;
                i++;
            }
            // Now, copy only the non-zero part of rgbTemp and reverse
            byte[] rgbOutput = new byte[i];
            // copy and reverse in one pass
            for (int j = 0; j < i; j++) {
                rgbOutput[j] = rgbTemp[i-j-1];
            }
            return(rgbOutput);
        }
    
        private int MapOIDToCalg(String str) {
            int     calg;
            
            if (String.Compare(str, "1.3.14.3.2.26", false, CultureInfo.InvariantCulture) == 0) {
                calg = CALG_SHA1;
            } else if (String.Compare(str, "1.2.840.113549.2.5", false, CultureInfo.InvariantCulture) == 0) {
                calg = CALG_MD5;
            } else {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidOID"));
            }
            return calg;
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr unknown);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _CreateCSP(CspParameters param, ref IntPtr unknown);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeHKey(IntPtr hKey);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _DeleteKeyContainer(CspParameters param, IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void     _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _DecryptKey(IntPtr hCSP, IntPtr hPubKey, byte[] rgbKey, int dwFlags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _DecryptPKWin2KEnh(IntPtr hPubKey, byte[] rgbKey, bool fOAEP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _EncryptKey(IntPtr hCSP, IntPtr hPubKey, byte[] rgbKey, int dwFlags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]  _EncryptPKWin2KEnh(IntPtr hPubKey, byte[] rgbKey, bool fOAEP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _ExportKey(IntPtr unknown1, int unknown2, RSACspObject unknown3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _GenerateKey(IntPtr unknown1, int unknown2, int unknown3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[]   _GetKeyParameter(IntPtr unknown1, int unknown2);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _GetUserKey(IntPtr unknown1, int unknown2, ref IntPtr unknown3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _ImportKey(IntPtr unknown1, int unknown2, RSACspObject unknown3);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _SearchForAlgorithm(IntPtr hProv, int algID, int keyLength);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _SignValue(IntPtr unknown1, int unknown2, int unknown3, byte[] unknownArray, int dwFlags);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _VerifySign(IntPtr hCSP, IntPtr hKey, int calgHash, byte[] rgbHash, byte[] rgbSignature, int dwFlags);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rngcryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// RNGCryptoServiceProvider.cs
//

namespace System.Security.Cryptography {
    using System;
    using System.Runtime.CompilerServices;
    /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider"]/*' />
    public sealed class RNGCryptoServiceProvider : RandomNumberGenerator
    {
        private IntPtr                  _hCSP;          // Handle of the CSP
        static private CspParameters    _cspDefParams = new CspParameters();
    
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.RNGCryptoServiceProvider"]/*' />
        public RNGCryptoServiceProvider() : this((CspParameters)null) {
            
        }
    
        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.RNGCryptoServiceProvider1"]/*' />
        public RNGCryptoServiceProvider(String str) : this((CspParameters)null) {
        }

        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.RNGCryptoServiceProvider2"]/*' />
        public RNGCryptoServiceProvider(byte[] rgb) : this((CspParameters)null) {
        }

        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.RNGCryptoServiceProvider3"]/*' />
        public RNGCryptoServiceProvider(CspParameters cspParams)
        {
            int             hr;
            if (cspParams != null) {
                hr = _AcquireCSP(cspParams, ref _hCSP);
                if (_hCSP == IntPtr.Zero)
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
            } else {
                if (SharedStatics.Crypto_RNGCryptoServiceProviderContext == IntPtr.Zero) {
                    hr = _AcquireCSP(_cspDefParams, ref _hCSP);
                    if (_hCSP == IntPtr.Zero)
                        throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
                    SharedStatics.Crypto_RNGCryptoServiceProviderContext = _hCSP;
                } else {
                    _hCSP = SharedStatics.Crypto_RNGCryptoServiceProviderContext;
                }
            }
        }
    
        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.Finalize"]/*' />
        ~RNGCryptoServiceProvider()
        {
            if (_hCSP != IntPtr.Zero && _hCSP != SharedStatics.Crypto_RNGCryptoServiceProviderContext) {
                _FreeCSP(_hCSP);
                _hCSP = IntPtr.Zero;
            }
        }
        
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.GetBytes"]/*' />
        public override void GetBytes(byte[] data)
        {
            if (data == null) throw new ArgumentNullException("data");
            _GetBytes(_hCSP, data);
            GC.KeepAlive(this);
            return;
        }
    
        /// <include file='doc\RNGCryptoServiceProvider.uex' path='docs/doc[@for="RNGCryptoServiceProvider.GetNonZeroBytes"]/*' />
        public override void GetNonZeroBytes(byte[] data)
        {
            if (data == null) throw new ArgumentNullException("data");
            _GetNonZeroBytes(_hCSP, data);
            GC.KeepAlive(this);
            return;
        }
        
        /************************* PRIVATE METHODS ************************/
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int  _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _GetBytes(IntPtr hCSP, byte[] rgb);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _GetNonZeroBytes(IntPtr hCSP, byte[] rgb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsaoaepkeyexchangedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;
    using System.Security;

    /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter"]/*' />
    public class RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter
    {
        private RSA             _rsaKey;            // RSA Key value to do decrypt operation
        private String          HashNameValue;
        private byte[]          ParameterValue = new byte[0]; // Empty octet string
        
        // *********************** CONSTRUCTORS ***************************
    
        /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter.RSAOAEPKeyExchangeDeformatter"]/*' />
        public RSAOAEPKeyExchangeDeformatter()
        {
            HashNameValue = "SHA1";
        }
    
        /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter.RSAOAEPKeyExchangeDeformatter1"]/*' />
        public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key) {
            SetKey(key);
            HashNameValue = "SHA1";
        }

        /************************ Public Properties ***********************/

        /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter.Parameters"]/*' />
        public override String Parameters {
            get { return null; }
            set { ; }
        }
    
        /************************* PUBLIC METHODS *************************/
    
        /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange"]/*' />
        public override byte[] DecryptKeyExchange(byte[] rgbData)
        {
            byte[]      rgbOut = null;
            
            if (_rsaKey is RSACryptoServiceProvider) {
                rgbOut = ((RSACryptoServiceProvider) _rsaKey).Decrypt(rgbData, true);
            }
            else {
				int	cb = _rsaKey.KeySize/8;
				int cbHash;        
                HashAlgorithm           hash;
                int                     i;
                MaskGenerationMethod    mgf;
                byte[]                  rgbDB;
                byte[]                  rgbMask;
                byte[]                  rgbSeed;
				byte[]					rgbIn;
				bool					bError = false;

				// 1. Decode the input data
				// It is important that the Integer to Octet String conversion errors be indistinguishable from the other decoding
				// errors to protect against chosen cipher text attacks
				// A lecture given by James Manger during Crypto 2001 explains the issue in details
				try {
					rgbIn = _rsaKey.DecryptValue(rgbData);
				} catch {
					bError = true;
					goto error;
				}

                // 2. Create the hash object so we can get its size info.
                hash = (HashAlgorithm) CryptoConfig.CreateFromName(HashNameValue);
				cbHash = hash.HashSize/8;
				if (rgbIn.Length != cb || cb < 2*cbHash + 2) {
					bError = true;
					goto error;					
				}

                //  3.  Let maskedSeed be the first hLen octects and maskedDB
                //      be the remaining bytes.

				rgbSeed = new byte[cbHash];
				Buffer.InternalBlockCopy(rgbIn, 1, rgbSeed, 0, rgbSeed.Length);

				rgbDB = new byte[rgbIn.Length - rgbSeed.Length - 1];
				Buffer.InternalBlockCopy(rgbIn, rgbSeed.Length + 1, rgbDB, 0, rgbDB.Length);

                //  4.  seedMask = MGF(maskedDB, hLen);

                mgf = new PKCS1MaskGenerationMethod();
                rgbMask = mgf.GenerateMask(rgbDB, rgbSeed.Length);

                //  5.  seed = seedMask XOR maskedSeed

                for (i=0; i<rgbSeed.Length; i++) {
                    rgbSeed[i] ^= rgbMask[i];
                }

                //  6.  dbMask = MGF(seed, |EM| - hLen);

                rgbMask = mgf.GenerateMask(rgbSeed, rgbDB.Length);

                //  7.  DB = maskedDB xor dbMask

                for (i=0; i<rgbDB.Length; i++) {
                    rgbDB[i] ^= rgbMask[i];
                }

                //  8.  pHash = HASH(P)

                hash.ComputeHash(ParameterValue);

                //  9.  DB = pHash' || PS || 01 || M
                //
                //  10.  Check that pHash = pHash'

                for (i=0; i<cbHash; i++) {
                    if (rgbDB[i] != hash.Hash[i]) {
						bError = true;
						goto error;
                    }
                }

                //  Check that PS is all zeros

                for (; i<rgbDB.Length; i++) {
                    if (rgbDB[i] == 01) {
                        break;
                    }
                    else if (rgbDB[i] != 0) {
						bError = true;
						goto error;
                    }
                }

                if (i == rgbDB.Length) {
					bError = true;
					goto error;
                }

                i++;			// Skip over the one

                rgbOut = new byte[rgbDB.Length - i];

                //  11. Output M.
                
                Buffer.InternalBlockCopy(rgbDB, i, rgbOut, 0, rgbOut.Length);

error:          if (bError)
					throw new CryptographicException(Environment.GetResourceString("Cryptography_OAEPDecoding"));
            }
            return rgbOut;
        }
        
        /// <include file='doc\RSAOAEPKeyExchangeDeformatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeDeformatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }
    
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsaoaepkeyexchangeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;
    using System.Security;

    /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter"]/*' />
    public class RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter
    {
        private byte[]          ParameterValue;
        private RSA             _rsaKey;
        private RandomNumberGenerator RngValue;
        
        // *********************** CONSTRUCTORS ***************************
    
        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.RSAOAEPKeyExchangeFormatter"]/*' />
        public RSAOAEPKeyExchangeFormatter()
        {
        }
    
        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.RSAOAEPKeyExchangeFormatter1"]/*' />
        public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key) {
            SetKey(key);
        }

        /************************* Properties *****************************/

        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.Parameter"]/*' />
        /// <internalonly/>
        public byte[] Parameter {
            get {
                if (ParameterValue == null) return(null); else return((byte[]) ParameterValue.Clone()); 
            }
            set { 
                if (value == null) ParameterValue = value; else ParameterValue = (byte[]) value.Clone();
            }
        }
        
        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.Parameters"]/*' />
        /// <internalonly/>
        public override String Parameters {
            get { return null; }
        }

        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.Rng"]/*' />
        public RandomNumberGenerator Rng {
            get { return RngValue; }
            set { RngValue = value; }
        }
    
        /************************* PUBLIC METHODS *************************/
    
        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }
    
        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.CreateKeyExchange"]/*' />
        public override byte[] CreateKeyExchange(byte[] rgbData)
        {
            byte[]      rgbKeyEx;

            if (_rsaKey is RSACryptoServiceProvider) {
                rgbKeyEx = ((RSACryptoServiceProvider) _rsaKey).Encrypt(rgbData, true);
            }
            else {
				int	cb = _rsaKey.KeySize/8;
				int cbHash;
                HashAlgorithm   hash;
                int             i;
                MaskGenerationMethod mgf;
                byte[]          rgbDB;
                byte[]          rgbIn;
                byte[]          rgbMask;
                byte[]          rgbSeed;

                //  Create the OAEP padding object.

                //  1.  Hash the parameters to get rgbPHash

                hash = (HashAlgorithm) CryptoConfig.CreateFromName("SHA1"); // Create the default SHA1 object
				cbHash = hash.HashSize/8;
		        if ((rgbData.Length + 2 + 2*cbHash) > cb) {
		            throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_Padding_EncDataTooBig"), cb-2-2*cbHash));
		        }
                hash.ComputeHash(new byte[0]); // Use an empty octet string

                //  2.  Create DB object

		        rgbDB = new byte[cb - cbHash - 1];

                //  Structure is as follows:
                //      pHash || PS || 01 || M
                //      PS consists of all zeros

				Buffer.InternalBlockCopy(hash.Hash, 0, rgbDB, 0, cbHash);
				rgbDB[rgbDB.Length - rgbData.Length - 1] = 1;
				Buffer.InternalBlockCopy(rgbData, 0, rgbDB, rgbDB.Length-rgbData.Length, rgbData.Length);

                // 3. Create a random value of size hLen

                if (RngValue == null) {
                    RngValue = RandomNumberGenerator.Create();
                }

				rgbSeed = new byte[cbHash];
				RngValue.GetBytes(rgbSeed);

                // 4.  Compute the mask value

                mgf = new PKCS1MaskGenerationMethod();
                
                rgbMask = mgf.GenerateMask(rgbSeed, rgbDB.Length);

                // 5.  Xor rgbMaskDB into rgbDB

                for (i=0; i<rgbDB.Length; i++) {
                    rgbDB[i] = (byte) (rgbDB[i] ^ rgbMask[i]);
                }

                // 6.  Compute seed mask value

		        rgbMask = mgf.GenerateMask(rgbDB, cbHash);

                // 7.  Xor rgbMask into rgbSeed

                for (i=0; i<rgbSeed.Length; i++) {
                    rgbSeed[i] ^= rgbMask[i];
                }

                // 8. Concatenate rgbSeed and rgbDB to form value to encrypt

				rgbIn = new byte[cb];
				Buffer.InternalBlockCopy(rgbSeed, 0, rgbIn, 1, rgbSeed.Length);
				Buffer.InternalBlockCopy(rgbDB, 0, rgbIn, rgbSeed.Length + 1, rgbDB.Length);

                // 9.  Now Encrypt it

                rgbKeyEx = _rsaKey.EncryptValue(rgbIn);
            }
            return rgbKeyEx;
        }

        /// <include file='doc\RSAOAEPKeyExchangeFormatter.uex' path='docs/doc[@for="RSAOAEPKeyExchangeFormatter.CreateKeyExchange1"]/*' />
        public override byte[] CreateKeyExchange(byte[] rgbData, Type symAlgType)
        {
            return CreateKeyExchange(rgbData);
        }
        
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsapkcs1keyexchangedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;
    using System.Security;

    /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter"]/*' />
    public class RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter
    {
        RSA                     _rsaKey;
        RandomNumberGenerator   RngValue;

        // Constructors

        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.RSAPKCS1KeyExchangeDeformatter"]/*' />
        public RSAPKCS1KeyExchangeDeformatter()
        {
        }

        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.RSAPKCS1KeyExchangeDeformatter1"]/*' />
        public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key) {
            SetKey(key);
        }

        /*********************** Parameters *************************/

        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.RNG"]/*' />
        public RandomNumberGenerator RNG {
            get { return RngValue; }
            set { RngValue = value; }
        }
        
        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.Parameters"]/*' />
        public override String Parameters {
            get { return null; }
            set { ;}
        }

        /******************* Public Methods *************************/

        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange"]/*' />
        public override byte[] DecryptKeyExchange(byte[] rgbIn) {
            byte[]      rgbOut;

            if (_rsaKey == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_PKCS1Decoding"));
            }

            if (_rsaKey is RSACryptoServiceProvider) {
                rgbOut = ((RSACryptoServiceProvider) _rsaKey).Decrypt(rgbIn, false);
            }
            else {
                int     i;
                byte[]  rgb;
                rgb = _rsaKey.DecryptValue(rgbIn);

                //
                //  Expected format is:
                //      00 || 02 || PS || 00 || D
                //      where PS does not contain any zeros.
                //

                for (i = 2; i<rgb.Length; i++) {
                    if (rgb[i] == 0) {
                        break;
                    }
                }

                if (i >= rgb.Length) {
                    throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingKey"));
                }

                i++;            // Skip over the zero

                rgbOut = new byte[rgb.Length - i];
                Buffer.InternalBlockCopy(rgb, i, rgbOut, 0, rgbOut.Length);
            }
            return rgbOut;
        }

        /// <include file='doc\RSAPKCS1KeyExchangeDeformatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeDeformatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsapkcs1signaturedeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  RSAPKCS1SignatureDeformatter.cs
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;
    using System;

    /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter"]/*' />
    public class RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter
    {
        //
        //  This class provides the PKCS#1 v1.5 signature format processing during
        //  the verification process (i.e. decrypting the object).  The class has
        //  some special code for dealing with the CSP based RSA keys as the 
        //  formatting and verification is done within the CSP rather than in
        //  managed code.
        //
        
        private RSA             _rsaKey;            // RSA Key value to do decrypt operation
        private String          _strOID;            // OID value for the HASH algorithm
        
        // *********************** CONSTRUCTORS ***************************
    
        /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter.RSAPKCS1SignatureDeformatter"]/*' />
        public RSAPKCS1SignatureDeformatter()
        {
        }
    
        /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter.RSAPKCS1SignatureDeformatter1"]/*' />
        public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key) {
            SetKey(key);
        }
    
        /************************* PUBLIC METHODS *************************/
    
        /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }
    
        /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter.SetHashAlgorithm"]/*' />
        public override void SetHashAlgorithm(String strName)
        {
            _strOID = CryptoConfig.MapNameToOID(strName);
        }
    
        /// <include file='doc\RSAPKCS1SignatureDeformatter.uex' path='docs/doc[@for="RSAPKCS1SignatureDeformatter.VerifySignature"]/*' />
        public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature)
        {
            bool         f;
    
            if (_strOID == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingOID"));
            }
            if (_rsaKey == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingKey"));
            }
            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
            if (rgbSignature == null) {
                throw new ArgumentNullException("rgbSignature");
            }
    
            //
            // Two cases here -- if we are talking to the CSP version or
            //      if we are talking to some other RSA provider.
            //
    
            if (_rsaKey is RSACryptoServiceProvider) {
                f = ((RSACryptoServiceProvider) _rsaKey).VerifyHash(rgbHash, _strOID, rgbSignature);
            }
            else {
                int         cb = _rsaKey.KeySize/8;
                int         cb1;
                int         i;
                byte[]     rgbInput = new byte[cb];
                byte[]     rgbOid = CryptoConfig.EncodeOID(_strOID);
                int		   lenOid = rgbOid.Length;
				byte[]      rgbOut;
    
                //
                //  We want to pad this to the following format:
                //
                //  00 || 01 || FF ... FF || 00 || prefix || Data
                //
				// We want basically to ASN 1 encode the OID + hash:
				// STRUCTURE {
				//  STRUCTURE {
				//	OID <hash algorithm OID>
				//	NULL (0x05 0x00)  // this is actually an ANY and contains the parameters of the algorithm specified by the OID, I think
				//  }
				//  OCTET STRING <hashvalue>
				// }
                //

				// Get the correct prefix 				
				byte[] rgbPrefix = new byte[lenOid + 8 + rgbHash.Length];
				rgbPrefix[0] = 0x30; // a structure follows
				int tmp = rgbPrefix.Length - 2;
				rgbPrefix[1] = (byte) tmp;
				rgbPrefix[2] = 0x30;
				tmp = rgbOid.Length + 2;
				rgbPrefix[3] = (byte) tmp;
				Buffer.InternalBlockCopy(rgbOid, 0, rgbPrefix, 4, lenOid);
				rgbPrefix[4 + lenOid] = 0x05;
				rgbPrefix[4 + lenOid + 1] = 0x00;
				rgbPrefix[4 + lenOid + 2] = 0x04; // an octet string follows
				rgbPrefix[4 + lenOid + 3] = (byte) rgbHash.Length;
				Buffer.InternalBlockCopy(rgbHash, 0, rgbPrefix, lenOid + 8, rgbHash.Length);
    
				// Construct the whole array
                cb1 = cb - rgbHash.Length - rgbPrefix.Length;
				if (cb1 <= 2) {
	                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_InvalidOID"));
				}

                rgbInput[0] = 0;
                rgbInput[1] = 1;
                for (i=2; i<cb1-1; i++) {
                    rgbInput[i] = 0xff;
                }
                rgbInput[cb1-1] = 0;
				Buffer.InternalBlockCopy(rgbPrefix, 0, rgbInput, cb1, rgbPrefix.Length);
                Buffer.InternalBlockCopy(rgbHash, 0, rgbInput, cb1 + rgbPrefix.Length, rgbHash.Length);
    
                //
                //  Apply the public key to the signature data to get back
                //      the padded buffer actually signed.
                //
                
                rgbOut = _rsaKey.EncryptValue(rgbSignature);

                //
                //  Compare the two buffers to see if they match
                //

                f = rgbOut.Equals(rgbInput);
            }
            
            return f;
        }
        
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsa.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  RSA.cs
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;
    using System;
    using System.Text;
    using System.Security.Util;

    // We allow only the public components of an RSAParameters object, the Modulus and Exponent
    // to be serializable.
    /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters"]/*' />
    [Serializable]
    public struct RSAParameters {
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.Exponent"]/*' />
        public byte[]      Exponent;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.Modulus"]/*' />
        public byte[]      Modulus;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.P"]/*' />
        [NonSerialized] public byte[]      P;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.Q"]/*' />
        [NonSerialized] public byte[]      Q;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.DP"]/*' />
        [NonSerialized] public byte[]      DP;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.DQ"]/*' />
        [NonSerialized] public byte[]      DQ;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.InverseQ"]/*' />
        [NonSerialized] public byte[]      InverseQ;
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSAParameters.D"]/*' />
        [NonSerialized] public byte[]      D;
    }

    /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA"]/*' />
    public abstract class RSA : AsymmetricAlgorithm
    {
        //
        //  Extending this class allows us to know that you are really implementing
        //  an RSA key.  This is required for anybody providing a new RSA key value
        //  implemention.
        //
        //  The class provides no methods, fields or anything else.  Its only purpose is
        //  as a heirarchy member for identification of algorithm.
        //
        // *********************** CONSTRUCTORS ***************************
    
        // We need to include the default constructor here so that the C# 
        // compiler won't generate a public one automatically
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.RSA"]/*' />
        public RSA() { }

        /*************************** Public Methods **************************/

        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.Create"]/*' />
        new static public RSA Create() {
            return Create("System.Security.Cryptography.RSA");
        }

        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.Create1"]/*' />
        new static public RSA Create(String algName) {
                return (RSA) CryptoConfig.CreateFromName(algName);
        }

        // Apply the private key to the data.  This function represents a
        // raw RSA operation -- no implicit depadding of the imput value
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.DecryptValue"]/*' />
        abstract public byte[] DecryptValue(byte[] rgb);

        // Apply the public key to the data.  Again, this is a raw operation, no
        // automatic padding.
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.EncryptValue"]/*' />
        abstract public byte[] EncryptValue(byte[] rgb);

        /* Import/export functions */

        // We can provide a default implementation of FromXmlString because we require 
        // every RSA implementation to implement ImportParameters
        // All we have to do here is parse the XML.

        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.FromXmlString"]/*' />
        public override void FromXmlString(String xmlString) {
            if (xmlString == null) throw new ArgumentNullException("xmlString");
            RSAParameters rsaParams = new RSAParameters();
            Parser p = new Parser(xmlString);
            SecurityElement topElement = p.GetTopElement();

            // Modulus is always present
            String modulusString = topElement.SearchForTextOfLocalName("Modulus");
            if (modulusString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"RSA","Modulus"));
            }
            rsaParams.Modulus = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(modulusString));

            // Exponent is always present
            String exponentString = topElement.SearchForTextOfLocalName("Exponent");
            if (exponentString == null) {
                throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_InvalidFromXmlString"),"RSA","Exponent"));
            }
            rsaParams.Exponent = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(exponentString));

            // P is optional
            String pString = topElement.SearchForTextOfLocalName("P");
            if (pString != null) rsaParams.P = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(pString));

            // Q is optional
            String qString = topElement.SearchForTextOfLocalName("Q");
            if (qString != null) rsaParams.Q = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(qString));

            // DP is optional
            String dpString = topElement.SearchForTextOfLocalName("DP");
            if (dpString != null) rsaParams.DP = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(dpString));

            // DQ is optional
            String dqString = topElement.SearchForTextOfLocalName("DQ");
            if (dqString != null) rsaParams.DQ = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(dqString));

            // InverseQ is optional
            String inverseQString = topElement.SearchForTextOfLocalName("InverseQ");
            if (inverseQString != null) rsaParams.InverseQ = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(inverseQString));

            // D is optional
            String dString = topElement.SearchForTextOfLocalName("D");
            if (dString != null) rsaParams.D = Convert.FromBase64String(AsymmetricAlgorithm.DiscardWhiteSpaces(dString));

            ImportParameters(rsaParams);
        }

        // We can provide a default implementation of ToXmlString because we require 
        // every RSA implementation to implement ImportParameters
        // If includePrivateParameters is false, this is just an XMLDSIG RSAKeyValue
        // clause.  If includePrivateParameters is true, then we extend RSAKeyValue with 
        // the other (private) elements.
        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.ToXmlString"]/*' />
        public override String ToXmlString(bool includePrivateParameters) {
            // From the XMLDSIG spec, RFC 3075, Section 6.4.2, an RSAKeyValue looks like this:
            /* 
               <element name="RSAKeyValue"> 
                 <complexType> 
                   <sequence>
                     <element name="Modulus" type="ds:CryptoBinary"/> 
                     <element name="Exponent" type="ds:CryptoBinary"/>
                   </sequence> 
                 </complexType> 
               </element>
            */
            // we extend appropriately for private components
            RSAParameters rsaParams = this.ExportParameters(includePrivateParameters);
            StringBuilder sb = new StringBuilder();
            sb.Append("<RSAKeyValue>");
            // Add the modulus
            sb.Append("<Modulus>"+Convert.ToBase64String(rsaParams.Modulus)+"</Modulus>");
            // Add the exponent
            sb.Append("<Exponent>"+Convert.ToBase64String(rsaParams.Exponent)+"</Exponent>");
            if (includePrivateParameters) {
                // Add the private components
                sb.Append("<P>"+Convert.ToBase64String(rsaParams.P)+"</P>");
                sb.Append("<Q>"+Convert.ToBase64String(rsaParams.Q)+"</Q>");
                sb.Append("<DP>"+Convert.ToBase64String(rsaParams.DP)+"</DP>");
                sb.Append("<DQ>"+Convert.ToBase64String(rsaParams.DQ)+"</DQ>");
                sb.Append("<InverseQ>"+Convert.ToBase64String(rsaParams.InverseQ)+"</InverseQ>");
                sb.Append("<D>"+Convert.ToBase64String(rsaParams.D)+"</D>");
            } 
            sb.Append("</RSAKeyValue>");
            return(sb.ToString());
        }

        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.ExportParameters"]/*' />
        abstract public RSAParameters ExportParameters(bool includePrivateParameters);

        /// <include file='doc\rsa.uex' path='docs/doc[@for="RSA.ImportParameters"]/*' />
        abstract public void ImportParameters(RSAParameters parameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsapkcs1keyexchangeformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Security.Cryptography {
    using System;
    using System.Security;
    /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter"]/*' />
    public class RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter
    {
        RandomNumberGenerator   RngValue;
        RSA                     _rsaKey;

        // *************** Constructor

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.RSAPKCS1KeyExchangeFormatter"]/*' />
        public RSAPKCS1KeyExchangeFormatter()
        {
        }

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.RSAPKCS1KeyExchangeFormatter1"]/*' />
        public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key)
        {
            SetKey(key);
        }

        /********************* Properties ****************************/

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.Parameters"]/*' />
        public override String Parameters {
            get { return "<enc:KeyEncryptionMethod enc:Algorithm=\"http://www.microsoft.com/xml/security/algorithm/PKCS1-v1.5-KeyEx\" xmlns:enc=\"http://www.microsoft.com/xml/security/encryption/v1.0\" />"; }
        }

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.Rng"]/*' />
        public RandomNumberGenerator Rng {
            get { return RngValue; }
            set { RngValue = value; }
        }
        
        /******************* Public Methods **************************/

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.CreateKeyExchange"]/*' />
        public override byte[] CreateKeyExchange(byte[] rgbData)
        {
            byte[]         rgbKeyEx;

            if (_rsaKey is RSACryptoServiceProvider) {
                rgbKeyEx = ((RSACryptoServiceProvider) _rsaKey).Encrypt(rgbData, false);
            }
            else {
                int     cb = _rsaKey.KeySize/8;
                if ((rgbData.Length + 11) > cb) {
                    throw new CryptographicException(String.Format(Environment.GetResourceString("Cryptography_Padding_EncDataTooBig"), cb-11));
                }
                byte[]  rgbInput = new byte[cb];

                //
                //  We want to pad to the following format:
                //      00 || 02 || PS || 00 || D
                //
                //      PS - pseudorandom non zero bytes
                //      D - data
                //

                if (RngValue == null) {
                    RngValue = RandomNumberGenerator.Create();
                }
                
                Rng.GetNonZeroBytes(rgbInput);
                rgbInput[0] = 0;
                rgbInput[1] = 2;
                rgbInput[cb-rgbData.Length-1] = 0;
                Buffer.InternalBlockCopy(rgbData, 0, rgbInput, cb-rgbData.Length, rgbData.Length);

                //
                //  Now encrypt the value and return it. (apply public key)
                //

                rgbKeyEx = _rsaKey.EncryptValue(rgbInput);
            }
            return rgbKeyEx;
        }

        /// <include file='doc\RSAPKCS1KeyExchangeFormatter.uex' path='docs/doc[@for="RSAPKCS1KeyExchangeFormatter.CreateKeyExchange1"]/*' />
        public override byte[] CreateKeyExchange(byte[] rgbData, Type symAlgType)
        {
            return CreateKeyExchange(rgbData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha1cryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA1CryptoServiceProvider.cs
//

namespace System.Security.Cryptography {
    using System;
	using System.Runtime.CompilerServices;
    using System.Threading;

    /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider"]/*' />
    public sealed class SHA1CryptoServiceProvider : SHA1
    {
        private const int ALG_CLASS_HASH = (4 << 13);
        private const int ALG_TYPE_ANY   = (0);
        private const int CALG_SHA1      = (ALG_CLASS_HASH | ALG_TYPE_ANY | 4);

        private CspParameters      _paramCSP;
        private IntPtr                 _hHash;
        private __HashHandleProtector _HashHandleProtector = null;
    
        // *********************** CONSTRUCTORS *************************
        //
      
        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.SHA1CryptoServiceProvider"]/*' />
        public SHA1CryptoServiceProvider()
            : this(new CspParameters()) {
        }
    
        private static IntPtr _zeroPointer = new IntPtr(0);

        private SHA1CryptoServiceProvider(CspParameters parameters)
        {
            _paramCSP = parameters;
            _hHash = IntPtr.Zero;
            if (SharedStatics.Crypto_SHA1CryptoServiceProviderContext == _zeroPointer) {
                IntPtr hCSP = IntPtr.Zero;
                int hr = _AcquireCSP(_paramCSP, ref hCSP);
                if (hCSP == IntPtr.Zero) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CouldNotAcquire"));
                }
                SharedStatics.Crypto_SHA1CryptoServiceProviderContext = hCSP;
                // next bit is in case we do two acquires...
                if (SharedStatics.Crypto_SHA1CryptoServiceProviderContext != hCSP) {
                    _FreeCSP(hCSP);
                }
            }
            _hHash = _CreateHash(SharedStatics.Crypto_SHA1CryptoServiceProviderContext, CALG_SHA1);
            if (_hHash == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateHash"));
            }
            _HashHandleProtector = new __HashHandleProtector(_hHash);
        }
    
        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.Finalize"]/*' />
        protected override void Dispose(bool disposing)
        {
            if (_HashHandleProtector != null && !_HashHandleProtector.IsClosed)
                _HashHandleProtector.Close();
            // call the base class's Dispose
            base.Dispose(disposing);
        }

        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.Finalize1"]/*' />
        ~SHA1CryptoServiceProvider() {
            Dispose(false);
        }

    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.Initialize"]/*' />
        public override void Initialize() {
            if (_HashHandleProtector != null && !_HashHandleProtector.IsClosed)
                _HashHandleProtector.Close();
            _hHash = _CreateHash(SharedStatics.Crypto_SHA1CryptoServiceProviderContext, CALG_SHA1);
            if (_hHash == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CreateHash"));
            }
            _HashHandleProtector = new __HashHandleProtector(_hHash);           
        }
    
        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            bool incremented = false;
            try {
                if (_HashHandleProtector.TryAddRef(ref incremented)) {
                    _HashData(_HashHandleProtector.Handle, rgb, ibStart, cbSize);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _HashHandleProtector.Release();
            }
        }
      
        /// <include file='doc\SHA1CryptoServiceProvider.uex' path='docs/doc[@for="SHA1CryptoServiceProvider.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            bool incremented = false;
            byte[] result = null;
            try {
                if (_HashHandleProtector.TryAddRef(ref incremented)) {
                    result = _EndHash(_HashHandleProtector.Handle);
                }
                else
                    throw new ObjectDisposedException(null, Environment.GetResourceString("ObjectDisposed_Generic_ObjectName1"));
            }
            finally {
                if (incremented) _HashHandleProtector.Release();
            }
            return result;
        }
    
        /************************* PRIVATE METHODS ************************/
    
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int  _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern IntPtr  _CreateHash(IntPtr hCSP, int algid);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern byte[] _EndHash(IntPtr hHash);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeCSP(IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _FreeHash(IntPtr hHash);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void _HashData(IntPtr hHash, byte[] rgbData, int ibStart, int cbSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA1.cs
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA1.uex' path='docs/doc[@for="SHA1"]/*' />
    public abstract class SHA1 : HashAlgorithm
    {
        /******************************* Constructors ************************/

        /// <include file='doc\SHA1.uex' path='docs/doc[@for="SHA1.SHA1"]/*' />
        protected SHA1() {
            HashSizeValue = 160;
        }

        /************************** Public Methods **************************/

        /// <include file='doc\SHA1.uex' path='docs/doc[@for="SHA1.Create"]/*' />
        new static public SHA1 Create() {
            return Create("System.Security.Cryptography.SHA1");
        }

        /// <include file='doc\SHA1.uex' path='docs/doc[@for="SHA1.Create1"]/*' />
        new static public SHA1 Create(String hashName) {
            return (SHA1) CryptoConfig.CreateFromName(hashName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\rsapkcs1signatureformatter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***
 *
 *  RSAPKCS1SignatureFormatter.cs
 *
 */

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;
    using System;
    /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter"]/*' />
    public class RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter
    {
        private RSA             _rsaKey;
        private String          _strOID;
        
        // *********************** CONSTRUCTORS ***************************
    
        /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter.RSAPKCS1SignatureFormatter"]/*' />
        public RSAPKCS1SignatureFormatter()
        {
        }
    
        /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter.RSAPKCS1SignatureFormatter1"]/*' />
        public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key) {
            SetKey(key);
        }
    
        /************************* PUBLIC METHODS *************************/
    
        /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter.SetKey"]/*' />
        public override void SetKey(AsymmetricAlgorithm key)
        {
            _rsaKey = (RSA) key;
        }
    
        /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter.SetHashAlgorithm"]/*' />
        public override void SetHashAlgorithm(String strName)
        {
            _strOID = CryptoConfig.MapNameToOID(strName);
        }
    
        /// <include file='doc\RSAPKCS1SignatureFormatter.uex' path='docs/doc[@for="RSAPKCS1SignatureFormatter.CreateSignature"]/*' />
        public override byte[] CreateSignature(byte[] rgbHash)
        {
            byte[]         rgbSig;
    
            if (_strOID == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingOID"));
            }
            if (_rsaKey == null) {
                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_MissingKey"));
            }
            if (rgbHash == null) {
                throw new ArgumentNullException("rgbHash");
            }
    
            //
            // Two cases here -- if we are talking to the CSP version or
            //      if we are talking to some other RSA provider.
            //
    
            if (_rsaKey is RSACryptoServiceProvider) {
                rgbSig = ((RSACryptoServiceProvider) _rsaKey).SignHash(rgbHash, _strOID);
            }
            else {
                int         cb = _rsaKey.KeySize/8;
                int         cb1;
                int         i;
                byte[]     rgbInput = new byte[cb];
                byte[]     rgbOid = CryptoConfig.EncodeOID(_strOID);
                int		   lenOid = rgbOid.Length;
    
                //
                //  We want to pad this to the following format:
                //
                //  00 || 01 || FF ... FF || 00 || prefix || Data
                //
				// We want basically to ASN 1 encode the OID + hash:
				// STRUCTURE {
				//  STRUCTURE {
				//	OID <hash algorithm OID>
				//	NULL (0x05 0x00)  // this is actually an ANY and contains the parameters of the algorithm specified by the OID, I think
				//  }
				//  OCTET STRING <hashvalue>
				// }
                //

				// Get the correct prefix 				
				byte[] rgbPrefix = new byte[lenOid + 8 + rgbHash.Length];
				rgbPrefix[0] = 0x30; // a structure follows
				int tmp = rgbPrefix.Length - 2;
				rgbPrefix[1] = (byte) tmp;
				rgbPrefix[2] = 0x30;
				tmp = rgbOid.Length + 2;
				rgbPrefix[3] = (byte) tmp;
				Buffer.InternalBlockCopy(rgbOid, 0, rgbPrefix, 4, lenOid);
				rgbPrefix[4 + lenOid] = 0x05;
				rgbPrefix[4 + lenOid + 1] = 0x00;
				rgbPrefix[4 + lenOid + 2] = 0x04; // an octet string follows
				rgbPrefix[4 + lenOid + 3] = (byte) rgbHash.Length;
				Buffer.InternalBlockCopy(rgbHash, 0, rgbPrefix, lenOid + 8, rgbHash.Length);
    
				// Construct the whole array
                cb1 = cb - rgbHash.Length - rgbPrefix.Length;
				if (cb1 <= 2) {
	                throw new CryptographicUnexpectedOperationException(Environment.GetResourceString("Cryptography_InvalidOID"));
				}

                rgbInput[0] = 0;
                rgbInput[1] = 1;
                for (i=2; i<cb1-1; i++) {
                    rgbInput[i] = 0xff;
                }
                rgbInput[cb1-1] = 0;
				Buffer.InternalBlockCopy(rgbPrefix, 0, rgbInput, cb1, rgbPrefix.Length);
                Buffer.InternalBlockCopy(rgbHash, 0, rgbInput, cb1 + rgbPrefix.Length, rgbHash.Length);
        
                //
                //  Create the signature by applying the private key to
                //      the padded buffer we just created.
                //
    
                rgbSig = _rsaKey.DecryptValue(rgbInput);
            }
            
            return rgbSig;
        }
        
        /************************* PRIVATE METHODS ************************/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha256.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA256.cs
//
// This abstract class represents the SHA-256 hash algorithm.
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA256.uex' path='docs/doc[@for="SHA256"]/*' />
    public abstract class SHA256 : HashAlgorithm
    {
        /******************************* Constructors ************************/

        /// <include file='doc\SHA256.uex' path='docs/doc[@for="SHA256.SHA256"]/*' />
        public SHA256() {
            HashSizeValue = 256;
        }

        /************************** Public Methods **************************/

        /// <include file='doc\SHA256.uex' path='docs/doc[@for="SHA256.Create"]/*' />
        new static public SHA256 Create() {
            return Create("System.Security.Cryptography.SHA256");
        }

        /// <include file='doc\SHA256.uex' path='docs/doc[@for="SHA256.Create1"]/*' />
        new static public SHA256 Create(String hashName) {
            return (SHA256) CryptoConfig.CreateFromName(hashName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha384.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA384.cs
//
// This abstract class represents the SHA-384 hash algorithm.
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA384.uex' path='docs/doc[@for="SHA384"]/*' />
    public abstract class SHA384 : HashAlgorithm
    {
        /******************************* Constructors ************************/

        /// <include file='doc\SHA384.uex' path='docs/doc[@for="SHA384.SHA384"]/*' />
        public SHA384() {
            HashSizeValue = 384;
        }

        /************************** Public Methods **************************/

        /// <include file='doc\SHA384.uex' path='docs/doc[@for="SHA384.Create"]/*' />
        new static public SHA384 Create() {
            return Create("System.Security.Cryptography.SHA384");
        }

        /// <include file='doc\SHA384.uex' path='docs/doc[@for="SHA384.Create1"]/*' />
        new static public SHA384 Create(String hashName) {
            return (SHA384) CryptoConfig.CreateFromName(hashName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha256managed.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA256Managed.cs
//
// C# implementation of the proposed SHA-256 hash algorithm
//
// Author: bal
//

namespace System.Security.Cryptography {
    using System;

    /// <include file='doc\SHA256Managed.uex' path='docs/doc[@for="SHA256Managed"]/*' />
    public class SHA256Managed : SHA256
    {
        private byte[]    _buffer;
        private long      _count; // Number of bytes in the hashed message
        private UInt32[]  _stateSHA256;
        private UInt32[]  _W;
        
        // *********************** CONSTRUCTORS *************************
    
        //
        /// <include file='doc\SHA256Managed.uex' path='docs/doc[@for="SHA256Managed.SHA256Managed"]/*' />
        public SHA256Managed()
        {
            /* SHA initialization. Begins an SHA operation, writing a new context.
             */
    
            _stateSHA256 = new UInt32[8];
            
            _buffer = new byte[64];
            _W = new UInt32[64];

            Initialize();    
        }
    
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\SHA256Managed.uex' path='docs/doc[@for="SHA256Managed.Initialize"]/*' />
        public override void Initialize() {
            /* Load magic initialization constants.
             */
            _count = 0;

            _stateSHA256[0] = 0x6a09e667;
            _stateSHA256[1] = 0xbb67ae85;
            _stateSHA256[2] = 0x3c6ef372;
            _stateSHA256[3] = 0xa54ff53a;
            _stateSHA256[4] = 0x510e527f;
            _stateSHA256[5] = 0x9b05688c;
            _stateSHA256[6] = 0x1f83d9ab;
            _stateSHA256[7] = 0x5be0cd19;

            /* Zeroize potentially sensitive information.
             */
            Array.Clear(_buffer, 0, _buffer.Length);            
            Array.Clear(_W, 0, _W.Length);
        }

        /// <include file='doc\SHA256Managed.uex' path='docs/doc[@for="SHA256Managed.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            _HashData(rgb, ibStart, cbSize);
        }
    
        /// <include file='doc\SHA256Managed.uex' path='docs/doc[@for="SHA256Managed.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            return _EndHash();
        }
        
        /************************* PRIVATE METHODS ************************/
    
        /* SHA256 block update operation. Continues an SHA message-digest
           operation, processing another message block, and updating the
           context.
           */
    
        private void _HashData(byte[] partIn, int ibStart, int cbSize)
        {
            int bufferLen;
            int partInLen = cbSize;
            int partInBase = ibStart;
    
            /* Compute length of buffer */
            bufferLen = (int) (_count & 0x3f);
    
            /* Update number of bytes */
            _count += partInLen;
    
            if ((bufferLen > 0) && (bufferLen + partInLen >= 64)) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, 64-bufferLen);
                partInBase += (64-bufferLen);
                partInLen -= (64-bufferLen);
                SHATransform (_stateSHA256, _buffer);
                bufferLen = 0;
            }
    
            /* Copy input to temporary buffer and hash
             */
        
            while (partInLen >= 64) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, 0, 64);
                partInBase += 64;
                partInLen -= 64;
                SHATransform (_stateSHA256, _buffer);
            }
    
            if (partInLen > 0) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, partInLen);
            }
        }
    
        /* SHA256 finalization. Ends an SHA256 message-digest operation, writing
           the message digest.
           */
    
        private byte[] _EndHash()
        {
            byte[]         pad;
            int            padLen;
            long           bitCount;
            byte[]         hash = new byte[32]; // HashSizeValue = 256
    
            /* Compute padding: 80 00 00 ... 00 00 <bit count>
             */
            
            padLen = 64 - (int)(_count & 0x3f);
            if (padLen <= 8)
                padLen += 64;
    
            pad = new byte[padLen];
            pad[0] = 0x80;
    
            //  Convert count to bit count
            bitCount = _count * 8;
    
            pad[padLen-8] = (byte) ((bitCount >> 56) & 0xff);
            pad[padLen-7] = (byte) ((bitCount >> 48) & 0xff);
            pad[padLen-6] = (byte) ((bitCount >> 40) & 0xff);
            pad[padLen-5] = (byte) ((bitCount >> 32) & 0xff);
            pad[padLen-4] = (byte) ((bitCount >> 24) & 0xff);
            pad[padLen-3] = (byte) ((bitCount >> 16) & 0xff);
            pad[padLen-2] = (byte) ((bitCount >> 8) & 0xff);
            pad[padLen-1] = (byte) ((bitCount >> 0) & 0xff);
    
            /* Digest padding */
            _HashData(pad, 0, pad.Length);
    
            /* Store digest */
            DWORDToBigEndian (hash, _stateSHA256, 8);
    
            HashValue = hash;
            return hash;
        }

        private readonly static UInt32[] _K = {
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
            0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
            0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
            0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
            0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
            0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
            0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
            0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
            0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
        };
    
        private void SHATransform (UInt32[] state, byte[] block)
        {
            UInt32 a, b, c, d, e, f, h, g;
            UInt32 aa, bb, cc, dd, ee, ff, hh, gg;
            UInt32 T1;
    
            a = state[0];
            b = state[1];
            c = state[2];
            d = state[3];
            e = state[4];
            f = state[5];
            g = state[6];
            h = state[7];

            // fill in the first 16 bytes of W.
            DWORDFromBigEndian (_W, 16, block);
            SHA256Expand (_W);
    
            /* Apply the SHA256 compression function */
            // We are trying to be smart here and avoid as many copies as we can
            // The perf gain with this method over the straightforward modify and shift 
            // forward is >= 20%, so it's worth the pain
            for (int j=0; j<64; ) {
                T1 = h + Sigma_1(e) + Ch(e,f,g) + _K[j] + _W[j];
                ee = d + T1;
                aa = T1 + Sigma_0(a) + Maj(a,b,c);                 
                j++;

                T1 = g + Sigma_1(ee) + Ch(ee,e,f) + _K[j] + _W[j];
                ff = c + T1;
                bb = T1 + Sigma_0(aa) + Maj(aa,a,b);
                j++;

                T1 = f + Sigma_1(ff) + Ch(ff,ee,e) + _K[j] + _W[j];
                gg = b + T1;
                cc = T1 + Sigma_0(bb) + Maj(bb,aa,a);
                j++;
                 
                T1 = e + Sigma_1(gg) + Ch(gg,ff,ee) + _K[j] + _W[j];
                hh = a + T1;
                dd = T1 + Sigma_0(cc) + Maj(cc,bb,aa);
                j++;

                T1 = ee + Sigma_1(hh) + Ch(hh,gg,ff) + _K[j] + _W[j];
                h = aa + T1;
                d = T1 + Sigma_0(dd) + Maj(dd,cc,bb);
                j++;

                T1 = ff + Sigma_1(h) + Ch(h,hh,gg) + _K[j] + _W[j];
                g = bb + T1;
                c = T1 + Sigma_0(d) + Maj(d,dd,cc);
                j++;

                T1 = gg + Sigma_1(g) + Ch(g,h,hh) + _K[j] + _W[j];
                f = cc + T1;
                b = T1 + Sigma_0(c) + Maj(c,d,dd);
                j++;

                T1 = hh + Sigma_1(f) + Ch(f,g,h) + _K[j] + _W[j];
                e = dd + T1;
                a = T1 + Sigma_0(b) + Maj(b,c,d);
                j++;
            }

            state[0] += a;
            state[1] += b;
            state[2] += c;
            state[3] += d;
            state[4] += e;
            state[5] += f;
            state[6] += g;
            state[7] += h;
        }

        private UInt32 RotateRight(UInt32 x, int n) {
            return  (((x) >> (n)) | ((x) << (32-(n))));
        }

        private UInt32 Ch(UInt32 x, UInt32 y, UInt32 z) {
            return ((x & y) ^ ((x ^ 0xffffffff) & z));
        }

        private UInt32 Maj(UInt32 x, UInt32 y, UInt32 z) {
            return ((x & y) ^ (x & z) ^ (y & z));
        }
    
        private UInt32 sigma_0(UInt32 x) {
            return (RotateRight(x,7) ^ RotateRight(x,18) ^ (x >> 3));
        }

        private UInt32 sigma_1(UInt32 x) {
            return (RotateRight(x,17) ^ RotateRight(x,19) ^ (x >> 10));
        }

        private UInt32 Sigma_0(UInt32 x) {
            return (RotateRight(x,2) ^ RotateRight(x,13) ^ RotateRight(x,22));
        }

        private UInt32 Sigma_1(UInt32 x) {
            return (RotateRight(x,6) ^ RotateRight(x,11) ^ RotateRight(x,25));
        }

        /* This function creates W_16,...,W_63 according to the formula
           W_j <- sigma_1(W_{j-2}) + W_{j-7} + sigma_0(W_{j-15}) + W_{j-16};
        */
          
        private void SHA256Expand (UInt32[] x)
        {
            int     i;
    
            for (i = 16; i < 64; i++) {
                x[i] = sigma_1(x[i-2]) + x[i-7] + sigma_0(x[i-15]) + x[i-16];
            }
        }
    
        // digits == number of DWORDs
        private void DWORDFromBigEndian (UInt32[] x, int digits, byte[] block)
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 4)
                x[i] =  (UInt32) ((block[j] << 24) | (block[j+1] << 16) | (block[j+2] << 8) | block[j+3]);
        }
    
        /* Encodes x (DWORD) into block (unsigned char), most significant
            byte first.
            */
        // digits == number of DWORDs
        private void DWORDToBigEndian (byte[] block, UInt32[] x, int digits)
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 4) {
                block[j] = (byte)((x[i] >> 24) & 0xff);
                block[j+1] = (byte)((x[i] >> 16) & 0xff);
                block[j+2] = (byte)((x[i] >> 8) & 0xff);
                block[j+3] = (byte)(x[i] & 0xff);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha512.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA512.cs
//
// This abstract class represents the SHA-512 hash algorithm.
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA512.uex' path='docs/doc[@for="SHA512"]/*' />
    public abstract class SHA512 : HashAlgorithm
    {
        /******************************* Constructors ************************/

        /// <include file='doc\SHA512.uex' path='docs/doc[@for="SHA512.SHA512"]/*' />
        public SHA512() {
            HashSizeValue = 512;
        }

        /************************** Public Methods **************************/

        /// <include file='doc\SHA512.uex' path='docs/doc[@for="SHA512.Create"]/*' />
        new static public SHA512 Create() {
            return Create("System.Security.Cryptography.SHA512");
        }

        /// <include file='doc\SHA512.uex' path='docs/doc[@for="SHA512.Create1"]/*' />
        new static public SHA512 Create(String hashName) {
            return (SHA512) CryptoConfig.CreateFromName(hashName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha384managed.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA384Managed.cs
//
// C# implementation of the proposed SHA-384 hash algorithm
//
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA384Managed.uex' path='docs/doc[@for="SHA384Managed"]/*' />
    public class SHA384Managed : SHA384
    {
        private byte[]   _buffer;
        private ulong      _count; // Number of bytes in the hashed message
        private UInt64[]  _stateSHA384;
        private UInt64[]  _W;
    
        // *********************** CONSTRUCTORS *************************
    
        //
        /// <include file='doc\SHA384Managed.uex' path='docs/doc[@for="SHA384Managed.SHA384Managed"]/*' />
        public SHA384Managed()
        {
            /* SHA initialization. Begins an SHA operation, writing a new context.
             */
                 
            _stateSHA384 = new UInt64[8];

            _buffer = new byte[128];        
            _W = new UInt64[80];
            
            Initialize();
        }
    
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\SHA384Managed.uex' path='docs/doc[@for="SHA384Managed.Initialize"]/*' />
        public override void Initialize() {
            /* Load magic initialization constants.
             */
            _count = 0;

            _stateSHA384[0] = 0xcbbb9d5dc1059ed8;
            _stateSHA384[1] = 0x629a292a367cd507;
            _stateSHA384[2] = 0x9159015a3070dd17;
            _stateSHA384[3] = 0x152fecd8f70e5939;
            _stateSHA384[4] = 0x67332667ffc00b31;
            _stateSHA384[5] = 0x8eb44a8768581511;
            _stateSHA384[6] = 0xdb0c2e0d64f98fa7;
            _stateSHA384[7] = 0x47b5481dbefa4fa4;

            /* Zeroize potentially sensitive information.
             */
            Array.Clear(_buffer, 0, _buffer.Length);                        
            Array.Clear(_W, 0, _W.Length);
        }

        /// <include file='doc\SHA384Managed.uex' path='docs/doc[@for="SHA384Managed.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            _HashData(rgb, ibStart, cbSize);
        }
    
        /// <include file='doc\SHA384Managed.uex' path='docs/doc[@for="SHA384Managed.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            return _EndHash();
        }
        
        /************************* PRIVATE METHODS ************************/
    
        /* SHA384 block update operation. Continues an SHA message-digest
           operation, processing another message block, and updating the
           context.
           */
    
        private void _HashData(byte[] partIn, int ibStart, int cbSize)
        {
            int bufferLen;
            int partInLen = cbSize;
            int partInBase = ibStart;
    
            /* Compute length of buffer */
            bufferLen = (int) (_count & 0x7f);
    
            /* Update number of bytes */
            _count += (ulong) partInLen;
    
            if ((bufferLen > 0) && (bufferLen + partInLen >= 128)) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, 128-bufferLen);
                partInBase += (128-bufferLen);
                partInLen -= (128-bufferLen);
                SHATransform (_stateSHA384, _buffer);
                bufferLen = 0;
            }
    
            /* Copy input to temporary buffer and hash
             */
        
            while (partInLen >= 128) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, 0, 128);
                partInBase += 128;
                partInLen -= 128;
                SHATransform (_stateSHA384, _buffer);
            }
    
            if (partInLen > 0) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, partInLen);
            }
        }
    
        /* SHA384 finalization. Ends an SHA384 message-digest operation, writing
           the message digest.
           */
    
        private byte[] _EndHash()
        {
            byte[]         pad;
            int            padLen;
            ulong          bitCount;
            byte[]         hash = new byte[48]; // HashSizeValue = 384
    
            /* Compute padding: 80 00 00 ... 00 00 <bit count>
             */
            
            padLen = 128 - (int)(_count & 0x7f);
            if (padLen <= 16)
                padLen += 128;
    
            pad = new byte[padLen];
            pad[0] = 0x80;

            //  Convert count to bit count
            bitCount = _count * 8;

            // bitCount is at most 8 * 128 = 1024. Its representation as a 128-bit number has all bits set to zero
            // except eventually the 11 lower bits
    
            //pad[padLen-16] = (byte) ((bitCount >> 120) & 0xff);
            //pad[padLen-15] = (byte) ((bitCount >> 112) & 0xff);
            //pad[padLen-14] = (byte) ((bitCount >> 104) & 0xff);
            //pad[padLen-13] = (byte) ((bitCount >> 96) & 0xff);
            //pad[padLen-12] = (byte) ((bitCount >> 88) & 0xff);
            //pad[padLen-11] = (byte) ((bitCount >> 80) & 0xff);
            //pad[padLen-10] = (byte) ((bitCount >> 72) & 0xff);
            //pad[padLen-9] = (byte) ((bitCount >> 64) & 0xff);
            pad[padLen-8] = (byte) ((bitCount >> 56) & 0xff);
            pad[padLen-7] = (byte) ((bitCount >> 48) & 0xff);
            pad[padLen-6] = (byte) ((bitCount >> 40) & 0xff);
            pad[padLen-5] = (byte) ((bitCount >> 32) & 0xff);
            pad[padLen-4] = (byte) ((bitCount >> 24) & 0xff);
            pad[padLen-3] = (byte) ((bitCount >> 16) & 0xff);
            pad[padLen-2] = (byte) ((bitCount >> 8) & 0xff);
            pad[padLen-1] = (byte) ((bitCount >> 0) & 0xff);
    
            /* Digest padding */
            _HashData(pad, 0, pad.Length);
    
            /* Store digest */
            QuadWordToBigEndian (hash, _stateSHA384, 6);
    
            HashValue = hash;
            return hash;
        }

        private readonly static UInt64[] _K = {
            0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
            0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
            0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
            0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
            0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
            0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
            0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
            0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
            0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
            0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
            0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
            0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
            0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
            0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
            0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
            0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
            0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
            0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
            0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
            0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817,
        };

        private void SHATransform (UInt64[] state, byte[] block)
        {
            UInt64 a, b, c, d, e, f, g, h;
            UInt64 aa, bb, cc, dd, ee, ff, hh, gg;
            UInt64 T1;
            
            a = state[0];
            b = state[1];
            c = state[2];
            d = state[3];
            e = state[4];
            f = state[5];
            g = state[6];
            h = state[7];
        
            // fill in the first 16 blocks of W.
            QuadWordFromBigEndian (_W, 16, block);
            SHA384Expand (_W);
    
            /* Apply the SHA384 compression function */
            // We are trying to be smart here and avoid as many copies as we can
            // The perf gain with this method over the straightforward modify and shift 
            // forward is >= 20%, so it's worth the pain
            for (int j=0; j<80; ) {
                T1 = h + Sigma_1(e) + Ch(e,f,g) + _K[j] + _W[j];
                ee = d + T1;
                aa = T1 + Sigma_0(a) + Maj(a,b,c);                 
                j++;

                T1 = g + Sigma_1(ee) + Ch(ee,e,f) + _K[j] + _W[j];
                ff = c + T1;
                bb = T1 + Sigma_0(aa) + Maj(aa,a,b);
                j++;

                T1 = f + Sigma_1(ff) + Ch(ff,ee,e) + _K[j] + _W[j];
                gg = b + T1;
                cc = T1 + Sigma_0(bb) + Maj(bb,aa,a);
                j++;
                 
                T1 = e + Sigma_1(gg) + Ch(gg,ff,ee) + _K[j] + _W[j];
                hh = a + T1;
                dd = T1 + Sigma_0(cc) + Maj(cc,bb,aa);
                j++;

                T1 = ee + Sigma_1(hh) + Ch(hh,gg,ff) + _K[j] + _W[j];
                h = aa + T1;
                d = T1 + Sigma_0(dd) + Maj(dd,cc,bb);
                j++;

                T1 = ff + Sigma_1(h) + Ch(h,hh,gg) + _K[j] + _W[j];
                g = bb + T1;
                c = T1 + Sigma_0(d) + Maj(d,dd,cc);
                j++;

                T1 = gg + Sigma_1(g) + Ch(g,h,hh) + _K[j] + _W[j];
                f = cc + T1;
                b = T1 + Sigma_0(c) + Maj(c,d,dd);
                j++;

                T1 = hh + Sigma_1(f) + Ch(f,g,h) + _K[j] + _W[j];
                e = dd + T1;
                a = T1 + Sigma_0(b) + Maj(b,c,d);
                j++;
            }

            state[0] += a;
            state[1] += b;
            state[2] += c;
            state[3] += d;
            state[4] += e;
            state[5] += f;
            state[6] += g;
            state[7] += h;
        }

        private UInt64 RotateRight(UInt64 x, int n) {
            return  (((x) >> (n)) | ((x) << (64-(n))));
        }

        private UInt64 Ch(UInt64 x, UInt64 y, UInt64 z) {
            return ((x & y) ^ ((x ^ 0xffffffffffffffff) & z));
        }

        private UInt64 Maj(UInt64 x, UInt64 y, UInt64 z) {
            return ((x & y) ^ (x & z) ^ (y & z));
        }
    
        private UInt64 Sigma_0(UInt64 x) {
            return (RotateRight(x,28) ^ RotateRight(x,34) ^ RotateRight(x,39));
        }

        private UInt64 Sigma_1(UInt64 x) {
            return (RotateRight(x,14) ^ RotateRight(x,18) ^ RotateRight(x,41));
        }

        private UInt64 sigma_0(UInt64 x) {
            return (RotateRight(x,1) ^ RotateRight(x,8) ^ (x >> 7));
        }

        private UInt64 sigma_1(UInt64 x) {
            return (RotateRight(x,19) ^ RotateRight(x,61) ^ (x >> 6));
        }


        /* This function creates W_16,...,W_79 according to the formula
           W_j <- sigma_1(W_{j-2}) + W_{j-7} + sigma_0(W_{j-15}) + W_{j-16};
        */
          
        private void SHA384Expand (UInt64[] x)
        {
            int     i;
    
            for (i = 16; i < 80; i++) {
                x[i] = sigma_1(x[i-2]) + x[i-7] + sigma_0(x[i-15]) + x[i-16];
            }
        }
    
        // digits == number of QWORDs
        private void QuadWordFromBigEndian (UInt64[] x, int digits, byte[] block)
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 8)
                x[i] =  (
                         (((UInt64)block[j]) << 56) | (((UInt64)block[j+1]) << 48) |
                         (((UInt64)block[j+2]) << 40) | (((UInt64)block[j+3]) << 32) |
                         (((UInt64)block[j+4]) << 24) | (((UInt64)block[j+5]) << 16) |
                         (((UInt64)block[j+6]) << 8) | ((UInt64)block[j+7])
                         );
        }
    
        /* Encodes x (DWORD) into block (unsigned char), most significant
            byte first.
            */
        // digits = number of QWORDS
        private void QuadWordToBigEndian (byte[] block, UInt64[] x, int digits) 
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 8) {
                block[j] = (byte)((x[i] >> 56) & 0xff);
                block[j+1] = (byte)((x[i] >> 48) & 0xff);
                block[j+2] = (byte)((x[i] >> 40) & 0xff);
                block[j+3] = (byte)((x[i] >> 32) & 0xff);
                block[j+4] = (byte)((x[i] >> 24) & 0xff);
                block[j+5] = (byte)((x[i] >> 16) & 0xff);
                block[j+6] = (byte)((x[i] >> 8) & 0xff);
                block[j+7] = (byte)(x[i] & 0xff);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha512managed.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA512Managed.cs
//
// C# implementation of the proposed SHA-512 hash algorithm
//
// Author: bal
//

namespace System.Security.Cryptography {
    using System;
    /// <include file='doc\SHA512Managed.uex' path='docs/doc[@for="SHA512Managed"]/*' />
    public class SHA512Managed : SHA512
    {
        private byte[]   _buffer;
        private ulong    _count; // Number of bytes in the hashed message
        private UInt64[] _stateSHA512;
        private UInt64[]  _W;
    
        // *********************** CONSTRUCTORS *************************
    
        //
        /// <include file='doc\SHA512Managed.uex' path='docs/doc[@for="SHA512Managed.SHA512Managed"]/*' />
        public SHA512Managed()
        {
            /* SHA initialization. Begins an SHA operation, writing a new context.
             */
            _stateSHA512 = new UInt64[8];

            _buffer = new byte[128];
            _W = new UInt64[80];

            Initialize();    
        }
    
        /************************* PUBLIC METHODS ************************/

        /// <include file='doc\SHA512Managed.uex' path='docs/doc[@for="SHA512Managed.Initialize"]/*' />
        public override void Initialize() {
            /* Load magic initialization constants.
             */
            _count = 0;

            _stateSHA512[0] = 0x6a09e667f3bcc908;
            _stateSHA512[1] = 0xbb67ae8584caa73b;
            _stateSHA512[2] = 0x3c6ef372fe94f82b;
            _stateSHA512[3] = 0xa54ff53a5f1d36f1;
            _stateSHA512[4] = 0x510e527fade682d1;
            _stateSHA512[5] = 0x9b05688c2b3e6c1f;
            _stateSHA512[6] = 0x1f83d9abfb41bd6b;
            _stateSHA512[7] = 0x5be0cd19137e2179;

            /* Zeroize potentially sensitive information.
             */
            Array.Clear(_buffer, 0, _buffer.Length);                        
            Array.Clear(_W, 0, _W.Length);
        }
    
        /// <include file='doc\SHA512Managed.uex' path='docs/doc[@for="SHA512Managed.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            _HashData(rgb, ibStart, cbSize);
        }
    
        /// <include file='doc\SHA512Managed.uex' path='docs/doc[@for="SHA512Managed.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            return _EndHash();
        }
        
        /************************* PRIVATE METHODS ************************/

        /* SHA512 block update operation. Continues an SHA message-digest
           operation, processing another message block, and updating the
           context.
           */
    
        private void _HashData(byte[] partIn, int ibStart, int cbSize)
        {
            int bufferLen;
            int partInLen = cbSize;
            int partInBase = ibStart;
    
            /* Compute length of buffer */
            bufferLen = (int) (_count & 0x7f);
    
            /* Update number of bytes */
            _count += (ulong) partInLen;
    
            if ((bufferLen > 0) && (bufferLen + partInLen >= 128)) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, 128-bufferLen);
                partInBase += (128-bufferLen);
                partInLen -= (128-bufferLen);
                SHATransform (_stateSHA512, _buffer);
                bufferLen = 0;
            }
    
            /* Copy input to temporary buffer and hash
             */
        
            while (partInLen >= 128) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, 0, 128);
                partInBase += 128;
                partInLen -= 128;
                SHATransform (_stateSHA512, _buffer);
            }
    
            if (partInLen > 0) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, partInLen);
            }
        }
    
        /* SHA512 finalization. Ends an SHA512 message-digest operation, writing
           the message digest.
           */
    
        private byte[] _EndHash()
        {
            byte[]         pad;
            int            padLen;
            ulong          bitCount;
            byte[]         hash = new byte[64]; // HashSizeValue = 512

            /* Compute padding: 80 00 00 ... 00 00 <bit count>
             */
            
            padLen = 128 - (int)(_count & 0x7f);
            if (padLen <= 16)
                padLen += 128;
    
            pad = new byte[padLen];
            pad[0] = 0x80;
    
            //  Convert count to bit count
            bitCount = _count * 8;

            // If we ever have UInt128 for bitCount, then these need to be uncommented.
            // Note that C# only looks at the low 6 bits of the shift value for ulongs,
            // so >>0 and >>64 are equal!

            //pad[padLen-16] = (byte) ((bitCount >> 120) & 0xff);
            //pad[padLen-15] = (byte) ((bitCount >> 112) & 0xff);
            //pad[padLen-14] = (byte) ((bitCount >> 104) & 0xff);
            //pad[padLen-13] = (byte) ((bitCount >> 96) & 0xff);
            //pad[padLen-12] = (byte) ((bitCount >> 88) & 0xff);
            //pad[padLen-11] = (byte) ((bitCount >> 80) & 0xff);
            //pad[padLen-10] = (byte) ((bitCount >> 72) & 0xff);
            //pad[padLen-9] = (byte) ((bitCount >> 64) & 0xff);
            pad[padLen-8] = (byte) ((bitCount >> 56) & 0xff);
            pad[padLen-7] = (byte) ((bitCount >> 48) & 0xff);
            pad[padLen-6] = (byte) ((bitCount >> 40) & 0xff);
            pad[padLen-5] = (byte) ((bitCount >> 32) & 0xff);
            pad[padLen-4] = (byte) ((bitCount >> 24) & 0xff);
            pad[padLen-3] = (byte) ((bitCount >> 16) & 0xff);
            pad[padLen-2] = (byte) ((bitCount >> 8) & 0xff);
            pad[padLen-1] = (byte) ((bitCount >> 0) & 0xff);    
    
            /* Digest padding */
            _HashData(pad, 0, pad.Length);
    
            /* Store digest */
            QuadWordToBigEndian (hash, _stateSHA512, 8);
    
            HashValue = hash;
            return hash;
        }

        private readonly static UInt64[] _K = {
            0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
            0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
            0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
            0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
            0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
            0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
            0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
            0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
            0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
            0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
            0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
            0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
            0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
            0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
            0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
            0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
            0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
            0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
            0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
            0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817,
        };

        private void SHATransform (UInt64[] state, byte[] block)
        {
            UInt64 a, b, c, d, e, f, g, h;
            UInt64 aa, bb, cc, dd, ee, ff, hh, gg;
            UInt64 T1;
            
            a = state[0];
            b = state[1];
            c = state[2];
            d = state[3];
            e = state[4];
            f = state[5];
            g = state[6];
            h = state[7];
    
            // fill in the first 16 blocks of W.
            QuadWordFromBigEndian (_W, 16, block);
            SHA512Expand (_W);

            /* Apply the SHA512 compression function */
            // We are trying to be smart here and avoid as many copies as we can
            // The perf gain with this method over the straightforward modify and shift 
            // forward is >= 20%, so it's worth the pain
            for (int j=0; j<80; ) {
                T1 = h + Sigma_1(e) + Ch(e,f,g) + _K[j] + _W[j];
                ee = d + T1;
                aa = T1 + Sigma_0(a) + Maj(a,b,c);                 
                j++;

                T1 = g + Sigma_1(ee) + Ch(ee,e,f) + _K[j] + _W[j];
                ff = c + T1;
                bb = T1 + Sigma_0(aa) + Maj(aa,a,b);
                j++;

                T1 = f + Sigma_1(ff) + Ch(ff,ee,e) + _K[j] + _W[j];
                gg = b + T1;
                cc = T1 + Sigma_0(bb) + Maj(bb,aa,a);
                j++;
                 
                T1 = e + Sigma_1(gg) + Ch(gg,ff,ee) + _K[j] + _W[j];
                hh = a + T1;
                dd = T1 + Sigma_0(cc) + Maj(cc,bb,aa);
                j++;

                T1 = ee + Sigma_1(hh) + Ch(hh,gg,ff) + _K[j] + _W[j];
                h = aa + T1;
                d = T1 + Sigma_0(dd) + Maj(dd,cc,bb);
                j++;

                T1 = ff + Sigma_1(h) + Ch(h,hh,gg) + _K[j] + _W[j];
                g = bb + T1;
                c = T1 + Sigma_0(d) + Maj(d,dd,cc);
                j++;

                T1 = gg + Sigma_1(g) + Ch(g,h,hh) + _K[j] + _W[j];
                f = cc + T1;
                b = T1 + Sigma_0(c) + Maj(c,d,dd);
                j++;

                T1 = hh + Sigma_1(f) + Ch(f,g,h) + _K[j] + _W[j];
                e = dd + T1;
                a = T1 + Sigma_0(b) + Maj(b,c,d);
                j++;
            }

            state[0] += a;
            state[1] += b;
            state[2] += c;
            state[3] += d;
            state[4] += e;
            state[5] += f;
            state[6] += g;
            state[7] += h;
        }

        private UInt64 RotateRight(UInt64 x, int n) {
            return  (((x) >> (n)) | ((x) << (64-(n))));
        }

        private UInt64 Ch(UInt64 x, UInt64 y, UInt64 z) {
            return ((x & y) ^ ((x ^ 0xffffffffffffffff) & z));
        }

        private UInt64 Maj(UInt64 x, UInt64 y, UInt64 z) {
            return ((x & y) ^ (x & z) ^ (y & z));
        }
    
        private UInt64 Sigma_0(UInt64 x) {
            return (RotateRight(x,28) ^ RotateRight(x,34) ^ RotateRight(x,39));
        }

        private UInt64 Sigma_1(UInt64 x) {
            return (RotateRight(x,14) ^ RotateRight(x,18) ^ RotateRight(x,41));
        }

        private UInt64 sigma_0(UInt64 x) {
            return (RotateRight(x,1) ^ RotateRight(x,8) ^ (x >> 7));
        }

        private UInt64 sigma_1(UInt64 x) {
            return (RotateRight(x,19) ^ RotateRight(x,61) ^ (x >> 6));
        }


        /* This function creates W_16,...,W_79 according to the formula
           W_j <- sigma_1(W_{j-2}) + W_{j-7} + sigma_0(W_{j-15}) + W_{j-16};
        */
          
        private void SHA512Expand (UInt64[] x)
        {
            int     i;
    
            for (i = 16; i < 80; i++) {
                x[i] = sigma_1(x[i-2]) + x[i-7] + sigma_0(x[i-15]) + x[i-16];
            }
        }
    
        // digits == number of QWORDs
        private void QuadWordFromBigEndian (UInt64[] x, int digits, byte[] block)
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 8)
                x[i] =  (
                         (((UInt64)block[j]) << 56) | (((UInt64)block[j+1]) << 48) |
                         (((UInt64)block[j+2]) << 40) | (((UInt64)block[j+3]) << 32) |
                         (((UInt64)block[j+4]) << 24) | (((UInt64)block[j+5]) << 16) |
                         (((UInt64)block[j+6]) << 8) | ((UInt64)block[j+7])
                         );
        }
    
        /* Encodes x (DWORD) into block (unsigned char), most significant
            byte first.
            */
        // digits = number of QWORDS
        private void QuadWordToBigEndian (byte[] block, UInt64[] x, int digits) 
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 8) {
                block[j] = (byte)((x[i] >> 56) & 0xff);
                block[j+1] = (byte)((x[i] >> 48) & 0xff);
                block[j+2] = (byte)((x[i] >> 40) & 0xff);
                block[j+3] = (byte)((x[i] >> 32) & 0xff);
                block[j+4] = (byte)((x[i] >> 24) & 0xff);
                block[j+5] = (byte)((x[i] >> 16) & 0xff);
                block[j+6] = (byte)((x[i] >> 8) & 0xff);
                block[j+7] = (byte)(x[i] & 0xff);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\symmetricalgorithm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SymmetricAlgorithm.cs
//

namespace System.Security.Cryptography {
    using System.Runtime.InteropServices;
    using System.Security.Util;
    using System.IO;
    using System.Text;

    /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm"]/*' />
    public abstract class SymmetricAlgorithm : IDisposable {
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.BlockSizeValue"]/*' />
        protected int               BlockSizeValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.FeedbackSizeValue"]/*' />
        protected int               FeedbackSizeValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.IVValue"]/*' />
        protected byte[]            IVValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.KeyValue"]/*' />
        protected byte[]            KeyValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.LegalBlockSizesValue"]/*' />
        protected KeySizes[]        LegalBlockSizesValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.LegalKeySizesValue"]/*' />
        protected KeySizes[]        LegalKeySizesValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.KeySizeValue"]/*' />
        protected int               KeySizeValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.ModeValue"]/*' />
        protected CipherMode        ModeValue;
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.PaddingValue"]/*' />
        protected PaddingMode       PaddingValue;
        
        // *********************** CONSTRUCTORS *************************
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.SymmetricAlgorithm"]/*' />
        public SymmetricAlgorithm() {
            // Default to cipher block chaining (CipherMode.CBC) and
            // PKCS-style padding (pad n bytes with value n)
            ModeValue = CipherMode.CBC;
            PaddingValue = PaddingMode.PKCS7;
        }

        // SymmetricAlgorithm implements IDisposable

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Clear"]/*' />
        public void Clear() {
            ((IDisposable) this).Dispose();
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                // Note: we *always* want to zeroize the sensitive key material
                if (KeyValue != null) {
                    Array.Clear(KeyValue, 0, KeyValue.Length);
                    KeyValue = null;
                }
                if (IVValue != null) {
                    Array.Clear(IVValue, 0, IVValue.Length);
                    IVValue = null;
                }
            }
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Finalize"]/*' />
        ~SymmetricAlgorithm() {
            Dispose(false);
        }
    
        /*********************** PROPERTY METHODS ************************/
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.BlockSize"]/*' />
        public virtual int BlockSize {
            get { return BlockSizeValue; }
            set {
                int   i;
                int   j;

                for (i=0; i<LegalBlockSizesValue.Length; i++) {
                    // If a cipher has only one valid key size, MinSize == MaxSize and SkipSize will be 0
                    if (LegalBlockSizesValue[i].SkipSize == 0) {
                        if (LegalBlockSizesValue[i].MinSize == value) { // assume MinSize = MaxSize
                            BlockSizeValue = value;
                            IVValue = null;
                            return;
                        }
                    } else {
                        for (j = LegalBlockSizesValue[i].MinSize; j<=LegalBlockSizesValue[i].MaxSize;
                             j += LegalBlockSizesValue[i].SkipSize) {
                            if (j == value) {
                                if (BlockSizeValue != value) {
                                    BlockSizeValue = value;
                                    IVValue = null;      // Wrong length now
                                }
                                return;
                            }
                        }
                    }
                }
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidBlockSize"));
            }
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.FeedbackSize"]/*' />
        public virtual int FeedbackSize {
            get { return FeedbackSizeValue; }
            set {
               if (value > BlockSizeValue) {
                   throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidFeedbackSize"));
               }
               FeedbackSizeValue = value;
            }
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.IV"]/*' />
        public virtual byte[] IV {
            get { 
                if (IVValue == null) GenerateIV();
                return((byte[]) IVValue.Clone());
            }
            set {
                if (value == null) throw new ArgumentNullException("value");
                if (value.Length > BlockSizeValue/8) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidIVSize"));
                }
                IVValue = (byte[]) value.Clone();
            }
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Key"]/*' />
        public virtual byte[] Key {
            get { 
                if (KeyValue == null) GenerateKey();
                return (byte[]) KeyValue.Clone();
            }
            set { 
                if (value == null) throw new ArgumentNullException("value");
                if (ValidKeySize(value.Length * 8)) { // must convert bytes to bits
                    KeyValue = (byte[]) value.Clone();
                    KeySizeValue = value.Length * 8;
                } else {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
                }
            }
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.LegalBlockSizes"]/*' />
        public virtual KeySizes[] LegalBlockSizes {
            get { return (KeySizes[]) LegalBlockSizesValue.Clone(); }
        }
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.LegalKeySizes"]/*' />
        public virtual KeySizes[] LegalKeySizes {
            get { return (KeySizes[]) LegalKeySizesValue.Clone(); }
        }
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.KeySize"]/*' />
        public virtual int KeySize {
            get { return KeySizeValue; }
            set {
                if (ValidKeySize(value)) {
                    KeySizeValue = value;
                    KeyValue = null;
                    return;
                }
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKeySize"));
            }
        }
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Mode"]/*' />
        public virtual CipherMode Mode {
            get { return ModeValue; }
            set { 
                if ((value < CipherMode.CBC) || (CipherMode.CFB < value)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidCipherMode"));
                }
                ModeValue = value;
            }
        }
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Padding"]/*' />
        public virtual PaddingMode Padding {
            get { return PaddingValue; }
            set { 
                if ((value < PaddingMode.None) || (PaddingMode.Zeros < value)) {
                    throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidPaddingMode"));
                }
                PaddingValue = value;
            }
        }
    
        /************************* PUBLIC METHODS ************************/

        // The following method takes a bit length input and returns whether that length is a valid size
        // according to LegalKeySizes
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.ValidKeySize"]/*' />
        public bool ValidKeySize(int bitLength) {
            KeySizes[] validSizes = this.LegalKeySizes;
            int i,j;
            
            if (validSizes == null) return false;
            for (i=0; i< validSizes.Length; i++) {
                if (validSizes[i].SkipSize == 0) {
                    if (validSizes[i].MinSize == bitLength) { // assume MinSize = MaxSize
                        return true;
                    }
                } else {
                    for (j = validSizes[i].MinSize; j<= validSizes[i].MaxSize;
                         j += validSizes[i].SkipSize) {
                        if (j == bitLength) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Create"]/*' />
        static public SymmetricAlgorithm Create() {
            // use the crypto config system to return an instance of
            // the default SymmetricAlgorithm on this machine
            return Create("System.Security.Cryptography.SymmetricAlgorithm");
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.Create1"]/*' />
        static public SymmetricAlgorithm Create(String algName) {
            return (SymmetricAlgorithm) CryptoConfig.CreateFromName(algName);
        }
    
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.CreateEncryptor"]/*' />
        public virtual ICryptoTransform CreateEncryptor() {
            return CreateEncryptor(Key, IV);
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.CreateEncryptor3"]/*' />
        public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.CreateDecryptor"]/*' />
        public virtual ICryptoTransform CreateDecryptor() {
            return CreateDecryptor(Key, IV);
        }

        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.CreateDecryptor3"]/*' />
        public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
        
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.GenerateKey"]/*' />
        public abstract void GenerateKey();
        /// <include file='doc\SymmetricAlgorithm.uex' path='docs/doc[@for="SymmetricAlgorithm.GenerateIV"]/*' />
        public abstract void GenerateIV();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\sha1managed.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SHA1Managed.cs
//

namespace System.Security.Cryptography {
    using System;

    /// <include file='doc\SHA1Managed.uex' path='docs/doc[@for="SHA1Managed"]/*' />
    public class SHA1Managed : SHA1
    {
        private byte[]      _buffer;
        private long        _count; // Number of bytes in the hashed message
        private uint[]      _stateSHA1;
        private uint[]      _expandedBuffer;
    
        // *********************** CONSTRUCTORS *************************
    
        //
        /// <include file='doc\SHA1Managed.uex' path='docs/doc[@for="SHA1Managed.SHA1Managed"]/*' />
        public SHA1Managed()
        {
            /* SHA initialization. Begins an SHA operation, writing a new context. */            
            _stateSHA1 = new uint[5];

            _buffer = new byte[64];
            _expandedBuffer = new uint[80];
             
            Initialize();      
        }
    
        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\SHA1Managed.uex' path='docs/doc[@for="SHA1Managed.Initialize"]/*' />
        public override void Initialize() {
            /* Load magic initialization constants.
             */
            _count = 0;

            _stateSHA1[0] =  0x67452301;
            _stateSHA1[1] =  0xefcdab89;
            _stateSHA1[2] =  0x98badcfe;
            _stateSHA1[3] =  0x10325476;
            _stateSHA1[4] =  0xc3d2e1f0;

            /* Zeroize potentially sensitive information.
             */
            Array.Clear(_buffer, 0, _buffer.Length);
            Array.Clear(_expandedBuffer, 0, _expandedBuffer.Length);
        }
        
        /// <include file='doc\SHA1Managed.uex' path='docs/doc[@for="SHA1Managed.HashCore"]/*' />
        protected override void HashCore(byte[] rgb, int ibStart, int cbSize) {
            _HashData(rgb, ibStart, cbSize);
        }
    
        /// <include file='doc\SHA1Managed.uex' path='docs/doc[@for="SHA1Managed.HashFinal"]/*' />
        protected override byte[] HashFinal() {
            return _EndHash();
        }
        
        /************************* PRIVATE METHODS ************************/
    
        /* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
           unpublished work protected as such under copyright law.  This work
           contains proprietary, confidential, and trade secret information of
           RSA Data Security, Inc.  Use, disclosure or reproduction without the
           express written authorization of RSA Data Security, Inc. is
           prohibited.
           */

        /* SHA block update operation. Continues an SHA message-digest
           operation, processing another message block, and updating the
           context.
           */
    
        private void _HashData(byte[] partIn, int ibStart, int cbSize)
        {
            int bufferLen;
            int partInLen = cbSize;
            int partInBase = ibStart;
    
            /* Compute length of buffer */
            bufferLen = (int) (_count & 0x3f);
    
            /* Update number of bytes */
            _count += partInLen;
    
            if ((bufferLen > 0) && (bufferLen + partInLen >= 64)) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, 64-bufferLen);
                partInBase += (64-bufferLen);
                partInLen -= (64-bufferLen);
                SHATransform (_stateSHA1, _buffer);
                bufferLen = 0;
            }
    
            /* Copy input to temporary buffer and hash
             */
        
            while (partInLen >= 64) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, 0, 64);
                partInBase += 64;
                partInLen -= 64;
                SHATransform (_stateSHA1, _buffer);
            }
    
            if (partInLen > 0) {
                Buffer.InternalBlockCopy(partIn, partInBase, _buffer, bufferLen, partInLen);
            }
        }
    
        /* SHA finalization. Ends an SHA message-digest operation, writing
           the message digest.
            */
    
        private byte[] _EndHash()
        {
            byte[]          pad;
            int             padLen;
            long            bitCount;
            byte[]          hash = new byte[20];
    
            /* Compute padding: 80 00 00 ... 00 00 <bit count>
             */
            
            padLen = 64 - (int)(_count & 0x3f);
            if (padLen <= 8)
                padLen += 64;
    
            pad = new byte[padLen];    
            pad[0] = 0x80;
    
            //  Convert count to bit count
            bitCount = _count * 8;
    
            pad[padLen-8] = (byte) ((bitCount >> 56) & 0xff);
            pad[padLen-7] = (byte) ((bitCount >> 48) & 0xff);
            pad[padLen-6] = (byte) ((bitCount >> 40) & 0xff);
            pad[padLen-5] = (byte) ((bitCount >> 32) & 0xff);
            pad[padLen-4] = (byte) ((bitCount >> 24) & 0xff);
            pad[padLen-3] = (byte) ((bitCount >> 16) & 0xff);
            pad[padLen-2] = (byte) ((bitCount >> 8) & 0xff);
            pad[padLen-1] = (byte) ((bitCount >> 0) & 0xff);
    
            /* Digest padding */
            _HashData(pad, 0, pad.Length);
    
            /* Store digest */
            DWORDToBigEndian (hash, _stateSHA1, 5);
                
            HashValue = hash;
            return hash;
        }
    
        private void SHATransform (uint[] state, byte[] block)
        {
            uint a = state[0];
            uint b = state[1];
            uint c = state[2];
            uint d = state[3];
            uint e = state[4];
    
            int i;

            DWORDFromBigEndian (_expandedBuffer, 16, block);
            SHAExpand (_expandedBuffer);
    
            /* Round 1 */
            for (i=0; i<20; i+= 5) {
                { (e) +=  (((((a)) << (5)) | (((a)) >> (32-(5)))) + ( (d) ^ ( (b) & ( (c) ^ (d) ) ) ) + (_expandedBuffer[i]) + 0x5a827999); (b) =  ((((b)) << (30)) | (((b)) >> (32-(30)))); }
                { (d) +=  (((((e)) << (5)) | (((e)) >> (32-(5)))) + ( (c) ^ ( (a) & ( (b) ^ (c) ) ) ) + (_expandedBuffer[i+1]) + 0x5a827999); (a) =  ((((a)) << (30)) | (((a)) >> (32-(30)))); }
                { (c) +=  (((((d)) << (5)) | (((d)) >> (32-(5)))) + ( (b) ^ ( (e) & ( (a) ^ (b) ) ) ) + (_expandedBuffer[i+2]) + 0x5a827999); (e) =  ((((e)) << (30)) | (((e)) >> (32-(30)))); };;
                { (b) +=  (((((c)) << (5)) | (((c)) >> (32-(5)))) + ( (a) ^ ( (d) & ( (e) ^ (a) ) ) ) + (_expandedBuffer[i+3]) + 0x5a827999); (d) =  ((((d)) << (30)) | (((d)) >> (32-(30)))); };;
                { (a) +=  (((((b)) << (5)) | (((b)) >> (32-(5)))) + ( (e) ^ ( (c) & ( (d) ^ (e) ) ) ) + (_expandedBuffer[i+4]) + 0x5a827999); (c) =  ((((c)) << (30)) | (((c)) >> (32-(30)))); };;
            }

            /* Round 2 */
            for (; i<40; i+= 5) {
                { (e) +=  (((((a)) << (5)) | (((a)) >> (32-(5)))) + ((b) ^ (c) ^ (d)) + (_expandedBuffer[i]) + 0x6ed9eba1); (b) =  ((((b)) << (30)) | (((b)) >> (32-(30)))); };;
                { (d) +=  (((((e)) << (5)) | (((e)) >> (32-(5)))) + ((a) ^ (b) ^ (c)) + (_expandedBuffer[i+1]) + 0x6ed9eba1); (a) =  ((((a)) << (30)) | (((a)) >> (32-(30)))); };;
                { (c) +=  (((((d)) << (5)) | (((d)) >> (32-(5)))) + ((e) ^ (a) ^ (b)) + (_expandedBuffer[i+2]) + 0x6ed9eba1); (e) =  ((((e)) << (30)) | (((e)) >> (32-(30)))); };;
                { (b) +=  (((((c)) << (5)) | (((c)) >> (32-(5)))) + ((d) ^ (e) ^ (a)) + (_expandedBuffer[i+3]) + 0x6ed9eba1); (d) =  ((((d)) << (30)) | (((d)) >> (32-(30)))); };;
                { (a) +=  (((((b)) << (5)) | (((b)) >> (32-(5)))) + ((c) ^ (d) ^ (e)) + (_expandedBuffer[i+4]) + 0x6ed9eba1); (c) =  ((((c)) << (30)) | (((c)) >> (32-(30)))); };;
            }

            /* Round 3 */
            for (; i<60; i+=5) {
                { (e) +=  (((((a)) << (5)) | (((a)) >> (32-(5)))) + ( ( (b) & (c) ) | ( (d) & ( (b) | (c) ) ) ) + (_expandedBuffer[i]) + 0x8f1bbcdc); (b) =  ((((b)) << (30)) | (((b)) >> (32-(30)))); };;
                { (d) +=  (((((e)) << (5)) | (((e)) >> (32-(5)))) + ( ( (a) & (b) ) | ( (c) & ( (a) | (b) ) ) ) + (_expandedBuffer[i+1]) + 0x8f1bbcdc); (a) =  ((((a)) << (30)) | (((a)) >> (32-(30)))); };;
                { (c) +=  (((((d)) << (5)) | (((d)) >> (32-(5)))) + ( ( (e) & (a) ) | ( (b) & ( (e) | (a) ) ) ) + (_expandedBuffer[i+2]) + 0x8f1bbcdc); (e) =  ((((e)) << (30)) | (((e)) >> (32-(30)))); };;
                { (b) +=  (((((c)) << (5)) | (((c)) >> (32-(5)))) + ( ( (d) & (e) ) | ( (a) & ( (d) | (e) ) ) ) + (_expandedBuffer[i+3]) + 0x8f1bbcdc); (d) =  ((((d)) << (30)) | (((d)) >> (32-(30)))); };;
                { (a) +=  (((((b)) << (5)) | (((b)) >> (32-(5)))) + ( ( (c) & (d) ) | ( (e) & ( (c) | (d) ) ) ) + (_expandedBuffer[i+4]) + 0x8f1bbcdc); (c) =  ((((c)) << (30)) | (((c)) >> (32-(30)))); };;
            }

            /* Round 4 */
            for (; i<80; i+=5) {
                { (e) +=  (((((a)) << (5)) | (((a)) >> (32-(5)))) + ((b) ^ (c) ^ (d)) + (_expandedBuffer[i]) + 0xca62c1d6); (b) =  ((((b)) << (30)) | (((b)) >> (32-(30)))); };;
                { (d) +=  (((((e)) << (5)) | (((e)) >> (32-(5)))) + ((a) ^ (b) ^ (c)) + (_expandedBuffer[i+1]) + 0xca62c1d6); (a) =  ((((a)) << (30)) | (((a)) >> (32-(30)))); };;
                { (c) +=  (((((d)) << (5)) | (((d)) >> (32-(5)))) + ((e) ^ (a) ^ (b)) + (_expandedBuffer[i+2]) + 0xca62c1d6); (e) =  ((((e)) << (30)) | (((e)) >> (32-(30)))); };;
                { (b) +=  (((((c)) << (5)) | (((c)) >> (32-(5)))) + ((d) ^ (e) ^ (a)) + (_expandedBuffer[i+3]) + 0xca62c1d6); (d) =  ((((d)) << (30)) | (((d)) >> (32-(30)))); };;
                { (a) +=  (((((b)) << (5)) | (((b)) >> (32-(5)))) + ((c) ^ (d) ^ (e)) + (_expandedBuffer[i+4]) + 0xca62c1d6); (c) =  ((((c)) << (30)) | (((c)) >> (32-(30)))); };;
            }

            state[0] += a;
            state[1] += b;
            state[2] += c;
            state[3] += d;
            state[4] += e;
        }
    
        /* Expands x[0..15] into x[16..79], according to the recurrence
           x[i] = x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16].
           */
    
        private void SHAExpand (uint[] x)
        {
            int      i;
            uint     tmp;
    
            for (i = 16; i < 80; i++) {
                tmp =  (x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16]);
                x[i] =  ((tmp << 1) | (tmp >> 31));
            }
        }
    
        // digits == number of DWORDs
        private void DWORDFromBigEndian (uint[] x, int digits, byte[] block)
        {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 4)
                x[i] =  (uint) ((block[j] << 24) | (block[j+1] << 16) | (block[j+2] << 8) | block[j+3]);
        }
    
        /* Encodes x (DWORD) into block (unsigned char), most significant byte first. */
        // digits == number of DWORDs
        private void DWORDToBigEndian (byte[] block, uint[] x, int digits) {
            int i;
            int j;
    
            for (i = 0, j = 0; i < digits; i++, j += 4) {
                block[j] = (byte)((x[i] >> 24) & 0xff);
                block[j+1] = (byte)((x[i] >> 16) & 0xff);
                block[j+2] = (byte)((x[i] >> 8) & 0xff);
                block[j+3] = (byte)(x[i] & 0xff);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\tripledescryptoserviceprovider.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//  TripleDESCryptoServiceProvider.cs
//
//
// This file contains the wrapper object to get to the CSP versions of the
//  crypto libraries

namespace System.Security.Cryptography {
    using System.Runtime.CompilerServices;
    /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider"]/*' />
    public sealed class TripleDESCryptoServiceProvider : TripleDES
    {
        private const int KP_IV                  = 1;
        private const int KP_MODE                = 4;
        private const int KP_MODE_BITS           = 5;

        // These magic constants come from wincrypt.h
        private const int ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const int ALG_TYPE_BLOCK      = (3 << 9);
        private const int CALG_3DES         = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 3 );
        private const int CALG_3DES_112     = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK| 9 );

        private RNGCryptoServiceProvider             _rng;
        private CspParameters      _cspParams = null;
      
        // *********************** CONSTRUCTORS *************************
    
        private const String MSEnhancedProviderName = "Microsoft Enhanced Cryptographic Provider v1.0";

        /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider.TripleDESCryptoServiceProvider"]/*' />
        public TripleDESCryptoServiceProvider() {
            // Acquire a Type 1 provider.  This will be the Enhanced provider if available, otherwise 
            // it will be the base provider.
            IntPtr trialCSPHandle = IntPtr.Zero;
            int trialHR = 0;
            int has3DESHR = 0;
            CspParameters cspParams = new CspParameters(1); // 1 == PROV_RSA_FULL
            trialHR = _AcquireCSP(cspParams, ref trialCSPHandle);
            if (trialCSPHandle == IntPtr.Zero) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            } 
            // OK, now see if CALG_DES is present in the provider we got back
            has3DESHR = _SearchForAlgorithm(trialCSPHandle, CALG_3DES, 0);
            _FreeCSP(trialCSPHandle);
            if (has3DESHR != 0) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_AlgorithmNotAvailable"));
            }
            // Since the CSP only supports a CFB feedback of 8, make that the default
            FeedbackSizeValue = 8;
            // gen random key & IV, in case the user never sets one explicitly
            GenerateKey();
            GenerateIV();
        }
    
        /*********************** PROPERTY METHODS ************************/

        /************************* PUBLIC METHODS ************************/
    
        /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider.CreateEncryptor"]/*' />
        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
        {
            if (IsWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"TripleDES");
            }
            return _NewEncryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }
      
        /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider.CreateDecryptor"]/*' />
        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
        {
            if (IsWeakKey(rgbKey)) {
                throw new CryptographicException(Environment.GetResourceString("Cryptography_InvalidKey_Weak"),"TripleDES");
            }
            return _NewDecryptor(rgbKey, ModeValue, rgbIV, FeedbackSizeValue);
        }
      
        /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider.GenerateKey"]/*' />
        public override void GenerateKey()
        {
            // respect KeySizeValue
            KeyValue = new byte[KeySizeValue/8];
            RNG.GetBytes(KeyValue);
            // Never hand back a weak or semi-weak key
            while (TripleDES.IsWeakKey(KeyValue)) {
                RNG.GetBytes(KeyValue);
            }
        }
  
        /// <include file='doc\TripleDESCryptoServiceProvider.uex' path='docs/doc[@for="TripleDESCryptoServiceProvider.GenerateIV"]/*' />
        public override void GenerateIV()
        {
            // IV is always 8 bytes/64 bits because block size is always 64 bits
            IVValue = new byte[8];
            RNG.GetBytes(IVValue);
        }
    
        /************************* PRIVATE METHODS ************************/

        private RNGCryptoServiceProvider RNG {
            get { if (_rng == null) { _rng = new RNGCryptoServiceProvider(); } return _rng; }
        }
    
        private ICryptoTransform _NewDecryptor(byte[] rgbKey, CipherMode mode,
                                               byte[] rgbIV, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];
            int algid = CALG_3DES;

            // Check for bad values
            // 1) we don't support OFB mode in TripleDESCryptoServiceProvider
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             

            //  Build the key if one does not already exist
            // Must respect KeySizeValue here...
            if (rgbKey == null) {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            //  Set the mode for the encryptor (defaults to CBC)

            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            //  If not ECB mode -- pass in an IV

            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            // If the size of rgbKey is 16 bytes, then we're doing two-key 3DES, so switch algids
            // Note that we assume that if a CSP supports CALG_3DES then it also supports CALG_3DES_112
            if (rgbKey.Length == 16) {
                algid = CALG_3DES_112;
            }

            //  Create the encryptor object

            return new CryptoAPITransform("TripleDES", algid, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue,
                                          mode, BlockSizeValue, feedbackSize,
                                          CryptoAPITransformMode.Decrypt);
        }
    
        private ICryptoTransform _NewEncryptor(byte[] rgbKey, CipherMode mode, byte[] rgbIV, int feedbackSize)
        {
            int         cArgs = 0;
            int[]       rgArgIds = new int[10];
            Object[]   rgArgValues = new Object[10];
            int algid = CALG_3DES;

            // Check for bad values
            // 1) we don't support OFB mode in TripleDESCryptoServiceProvider
            if (mode == CipherMode.OFB)
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_OFBNotSupported"));
            // 2) we only support CFB with a feedback size of 8 bits
            if ((mode == CipherMode.CFB) && (feedbackSize != 8)) 
                throw new CryptographicException(Environment.GetResourceString("Cryptography_CSP_CFBSizeNotSupported"));             

            // Build the key if one does not already exist
            // Must respect KeySizeValue here...
            if (rgbKey == null) {
                rgbKey = new byte[KeySizeValue/8];
                RNG.GetBytes(rgbKey);
            }

            //  Set the mode for the encryptor (defaults to CBC)

            if (mode != CipherMode.CBC) {
                rgArgIds[cArgs] = KP_MODE;
                rgArgValues[cArgs] = mode;
                cArgs += 1;
            }

            // If not ECB mode -- pass in an IV
            // IV is always 8 bytes (size of a block)
            if (mode != CipherMode.ECB) {
                if (rgbIV == null) {
                    rgbIV = new byte[8];
                    RNG.GetBytes(rgbIV);
                }
                rgArgIds[cArgs] = KP_IV;
                rgArgValues[cArgs] = rgbIV;
                cArgs += 1;
            }

            //  If doing OFB or CFB, then we need to set the feed back loop size

            if ((mode == CipherMode.OFB) || (mode == CipherMode.CFB)) {
                rgArgIds[cArgs] = KP_MODE_BITS;
                rgArgValues[cArgs] = feedbackSize;
                cArgs += 1;
            }

            // If the size of rgbKey is 16 bytes, then we're doing two-key 3DES, so switch algids
            // Note that we assume that if a CSP supports CALG_3DES then it also supports CALG_3DES_112
            if (rgbKey.Length == 16) {
                algid = CALG_3DES_112;
            }

            //  Create the encryptor object

            return new CryptoAPITransform("TripleDES", algid, cArgs, rgArgIds, 
                                          rgArgValues, rgbKey, _cspParams, PaddingValue,
                                          mode, BlockSizeValue, feedbackSize,
                                          CryptoAPITransformMode.Encrypt);
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _AcquireCSP(CspParameters param, ref IntPtr hCSP);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern int     _SearchForAlgorithm(IntPtr hProv, int algID, int keyLength);
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern void    _FreeCSP(IntPtr hCSP);
 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\cryptography\signaturedescription.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Crypto.cool
//

namespace System.Security.Cryptography {
    using System.Runtime.Serialization;
    using SecurityElement = System.Security.SecurityElement;
    /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription"]/*' />
    public class SignatureDescription {
        private String              _strKey;
        private String              _strDigest;
        private String              _strFormatter;
        private String              _strDeformatter;
    
        /************************ Constructors  *************************/

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.SignatureDescription"]/*' />
        public SignatureDescription() {
        }

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.SignatureDescription1"]/*' />
        public SignatureDescription(SecurityElement el) {
            if (el == null) throw new ArgumentNullException("el");
            _strKey = el.SearchForTextOfTag("Key");
            _strDigest = el.SearchForTextOfTag("Digest");
            _strFormatter = el.SearchForTextOfTag("Formatter");
            _strDeformatter = el.SearchForTextOfTag("Deformatter");
        }

        /************************ Property Methods  ********************/

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.KeyAlgorithm"]/*' />
        public String KeyAlgorithm { 
            get { return _strKey; }
            set { _strKey = value; }
        }
        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.DigestAlgorithm"]/*' />
        public String DigestAlgorithm { 
            get { return _strDigest; }
            set { _strDigest = value; }
        }
        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.FormatterAlgorithm"]/*' />
        public String FormatterAlgorithm { 
            get { return _strFormatter; }
            set { _strFormatter = value; }
        }
        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.DeformatterAlgorithm"]/*' />
        public String DeformatterAlgorithm { 
            get {return _strDeformatter; }
            set {_strDeformatter = value; }
        }

        /*******************  PUBLIC METHODS **********************/

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.CreateDeformatter"]/*' />
        public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key) {
            AsymmetricSignatureDeformatter     item;

            item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(_strDeformatter);
            item.SetKey(key);
            return item;
        }

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.CreateFormatter"]/*' />
        public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key) {
            AsymmetricSignatureFormatter     item;

            item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(_strFormatter);
            item.SetKey(key);
            return item;
        }

        /// <include file='doc\SignatureDescription.uex' path='docs/doc[@for="SignatureDescription.CreateDigest"]/*' />
        public virtual HashAlgorithm CreateDigest() {
            return (HashAlgorithm) CryptoConfig.CreateFromName(_strDigest);
        }
    }

    internal class RSAPKCS1SHA1SignatureDescription : SignatureDescription {

        public RSAPKCS1SHA1SignatureDescription() {
            KeyAlgorithm = "System.Security.Cryptography.RSACryptoServiceProvider";
            DigestAlgorithm = "System.Security.Cryptography.SHA1CryptoServiceProvider";
            FormatterAlgorithm = "System.Security.Cryptography.RSAPKCS1SignatureFormatter";
            DeformatterAlgorithm = "System.Security.Cryptography.RSAPKCS1SignatureDeformatter";
        }

        public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key) {
            AsymmetricSignatureDeformatter     item;

            item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm);
            item.SetKey(key);
            item.SetHashAlgorithm("SHA1");
            return item;
        }
    }

    internal class DSASignatureDescription : SignatureDescription {

        public DSASignatureDescription() {
            KeyAlgorithm = "System.Security.Cryptography.DSACryptoServiceProvider";
            DigestAlgorithm = "System.Security.Cryptography.SHA1CryptoServiceProvider";
            FormatterAlgorithm = "System.Security.Cryptography.DSASignatureFormatter";
            DeformatterAlgorithm = "System.Security.Cryptography.DSASignatureDeformatter";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\filedialogpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// FileDialogPermission.cs
//

namespace System.Security.Permissions {
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Util;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Collections;

    /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermissionAccess"]/*' />
    [Serializable, Flags]
    public enum FileDialogPermissionAccess {
        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermissionAccess.None"]/*' />
        None = 0x00,
    
        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermissionAccess.Open"]/*' />
        Open = 0x01,
    
        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermissionAccess.Save"]/*' />
        Save = 0x02,
        
        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermissionAccess.OpenSave"]/*' />
        OpenSave = Open | Save
    
    }

    /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission"]/*' />
    [Serializable] 
    public sealed class FileDialogPermission : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission {
        FileDialogPermissionAccess access;

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.FileDialogPermission"]/*' />
        public FileDialogPermission(PermissionState state) {
            if (state == PermissionState.Unrestricted) {
                SetUnrestricted(true);
            }
            else if (state == PermissionState.None) {
                SetUnrestricted(false);
                Reset();
            }
            else {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }    

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.FileDialogPermission1"]/*' />
        public FileDialogPermission(FileDialogPermissionAccess access) {
            VerifyAccess(access);
            this.access = access;
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.Access"]/*' />
        public FileDialogPermissionAccess Access {
            get {
                return access;
            }

            set {
                VerifyAccess(value);
                access = value;
            }
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.Copy"]/*' />
        public override IPermission Copy() {
            return new FileDialogPermission(this.access);
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd) {
            CodeAccessPermission.ValidateElement(esd, this);
            if (XMLUtil.IsUnrestricted(esd)) {
                SetUnrestricted(true);
                return;
            }

            access = FileDialogPermissionAccess.None;

            string accessXml = esd.Attribute("Access");
            if (accessXml != null)
                access = (FileDialogPermissionAccess)Enum.Parse(typeof(FileDialogPermissionAccess), accessXml);
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex() {
            return FileDialogPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex() {
            return BuiltInPermissionIndex.FileDialogPermissionIndex;
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target) {
            if (target == null) {
                return null;
            }
            else if (!VerifyType(target)) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName));
            }

            FileDialogPermission operand = (FileDialogPermission)target;

            FileDialogPermissionAccess intersectAccess = access & operand.Access;

            if (intersectAccess == FileDialogPermissionAccess.None)
                return null;
            else
                return new FileDialogPermission(intersectAccess);
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target) {
            if (target == null) {
                // Only safe subset if this is empty
                return access == FileDialogPermissionAccess.None;
            }

            try {
                FileDialogPermission operand = (FileDialogPermission)target;
                if (operand.IsUnrestricted()) {
                    return true;
                }
                else if (this.IsUnrestricted()) {
                    return false;
                }
                else {
                    int open = (int)(access & FileDialogPermissionAccess.Open);
                    int save = (int)(access & FileDialogPermissionAccess.Save);
                    int openTarget = (int)(operand.Access & FileDialogPermissionAccess.Open);
                    int saveTarget = (int)(operand.Access & FileDialogPermissionAccess.Save);

                    return open <= openTarget && save <= saveTarget;
                }
            }
            catch (InvalidCastException) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName));
            }

        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted() {
            return access == FileDialogPermissionAccess.OpenSave;
        }

        void Reset() {
            access = FileDialogPermissionAccess.None;
        }

        void SetUnrestricted( bool unrestricted ) {
            if (unrestricted) {
                access = FileDialogPermissionAccess.OpenSave;
            }
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.ToString"]/*' />
        public override string ToString() {
#if _DEBUG
            StringBuilder sb = new StringBuilder();
            sb.Append("FileDialogPermission(");
            if (IsUnrestricted()) {
                sb.Append("Unrestricted");
            }
            else {
                sb.Append(access.ToString("G"));
            }

            sb.Append(")");
            return sb.ToString();
#else
            return base.ToString();
#endif
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.ToXml"]/*' />
        public override SecurityElement ToXml() {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement(this);
            if (!IsUnrestricted()) {
                if (access != FileDialogPermissionAccess.None) {
                    esd.AddAttribute("Access", Enum.GetName(typeof(FileDialogPermissionAccess), access));
                }
            }
            else {
                esd.AddAttribute("Unrestricted", "true");
            }
            return esd;
        }

        /// <include file='doc\FileDialogPermission.uex' path='docs/doc[@for="FileDialogPermission.Union"]/*' />
        public override IPermission Union(IPermission target) {
            if (target == null) {
                return this.Copy();
            }
            else if (!VerifyType(target)) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName));
            }

            FileDialogPermission operand = (FileDialogPermission)target;
            return new FileDialogPermission(access | operand.Access);
        }        

        static void VerifyAccess(FileDialogPermissionAccess access) {
            if ((access & ~FileDialogPermissionAccess.OpenSave) != 0 ) {
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)access));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\environmentpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  EnvironmentPermission.cool
//

namespace System.Security.Permissions {
    using System.Security;
    using System;
    using SecurityElement = System.Security.SecurityElement;
    using System.Security.Util;
    using System.IO;
    using System.Globalization;

    /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermissionAccess"]/*' />
    [Flags,Serializable]
    public enum EnvironmentPermissionAccess
    {
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermissionAccess.NoAccess"]/*' />
        NoAccess = 0x00,
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermissionAccess.Read"]/*' />
        Read = 0x01,
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermissionAccess.Write"]/*' />
        Write = 0x02,
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermissionAccess.AllAccess"]/*' />
        AllAccess = 0x03,
    }
    
    [Serializable] internal class EnvironmentStringExpressionSet : StringExpressionSet
    {
        public EnvironmentStringExpressionSet()
            : base( true, null, false )
        {
        }
        
        public EnvironmentStringExpressionSet( String str )
            : base( true, str, false )
        {
        }
        
        public EnvironmentStringExpressionSet( bool ignoreCase )
            : base( ignoreCase, null, false )
        {
        }
        
        public EnvironmentStringExpressionSet( bool ignoreCase, bool throwOnRelative )
            : base( ignoreCase, null, throwOnRelative )
        {
        }
        
        public EnvironmentStringExpressionSet( bool ignoreCase, String str )
            : base( ignoreCase, str, false )
        {
        }

        protected override StringExpressionSet CreateNewEmpty()
        {
            return new EnvironmentStringExpressionSet();
        }

        protected override bool StringSubsetString( String left, String right, bool ignoreCase )
        {
            return String.Compare( left, right, ignoreCase, CultureInfo.InvariantCulture) == 0;
        }

        protected override String ProcessWholeString( String str )
        {
            return str;
        }

        protected override String ProcessSingleString( String str )
        {
            return str;
        }
    }
    
    /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission"]/*' />
    [Serializable()] sealed public class EnvironmentPermission : CodeAccessPermission, IUnrestrictedPermission, IBuiltInPermission
    {
        private StringExpressionSet m_read;
        private StringExpressionSet m_write;
        private bool m_unrestricted;
    
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.EnvironmentPermission"]/*' />
        public EnvironmentPermission(PermissionState state)
        {
            if (state == PermissionState.Unrestricted)
            {
                m_unrestricted = true;
            }
            else if (state == PermissionState.None)
            {
                m_unrestricted = false;
                m_read = new EnvironmentStringExpressionSet();
                m_write = new EnvironmentStringExpressionSet();
            }
            else
            {
                throw new ArgumentException(Environment.GetResourceString("Argument_InvalidPermissionState"));
            }
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.EnvironmentPermission1"]/*' />
        public EnvironmentPermission( EnvironmentPermissionAccess flag, String pathList )
        {
            VerifyFlag( flag );
        
            AddPathList( flag, pathList );
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.SetPathList"]/*' />
        public void SetPathList( EnvironmentPermissionAccess flag, String pathList )
        {
            VerifyFlag( flag );
            
            if ((flag & EnvironmentPermissionAccess.Read) != 0)
                m_read = null;
            
            if ((flag & EnvironmentPermissionAccess.Write) != 0)
                m_write = null;
            
            AddPathList( flag, pathList );
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.AddPathList"]/*' />
        public void AddPathList( EnvironmentPermissionAccess flag, String pathList )
        {
            VerifyFlag( flag );
            
            m_unrestricted = false;
            
            if (FlagIsSet( flag, EnvironmentPermissionAccess.Read ))
            {
                if (m_read == null)
                {
                    m_read = new EnvironmentStringExpressionSet();
                }
                m_read.AddExpressions( pathList );
            }
            
            if (FlagIsSet( flag, EnvironmentPermissionAccess.Write ))
            {
                if (m_write == null)
                {
                    m_write = new EnvironmentStringExpressionSet();
                }
                m_write.AddExpressions( pathList );
            }
    
        }
    
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.GetPathList"]/*' />
        public String GetPathList( EnvironmentPermissionAccess flag )
        {
            VerifyFlag( flag );
            ExclusiveFlag( flag );
    
            if (FlagIsSet( flag, EnvironmentPermissionAccess.Read ))
            {
                if (m_read == null)
                {
                    return "";
                }
                return m_read.ToString();
            }
            
            if (FlagIsSet( flag, EnvironmentPermissionAccess.Write ))
            {
                if (m_write == null)
                {
                    return "";
                }
                return m_write.ToString();
            }
    
            /* not reached */
            
            return "";
        }     
        
            
        private void VerifyFlag( EnvironmentPermissionAccess flag )
        {
            if ((flag & ~EnvironmentPermissionAccess.AllAccess) != 0)
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_EnumIllegalVal"), (int)flag));
        }
    
        private void ExclusiveFlag( EnvironmentPermissionAccess flag )
        {
            if (flag == EnvironmentPermissionAccess.NoAccess)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") ); 
            }
    
            if (((int)flag & ((int)flag-1)) != 0)
            {
                throw new ArgumentException( Environment.GetResourceString("Arg_EnumNotSingleFlag") );
            }
        }
        
        
        private bool FlagIsSet( EnvironmentPermissionAccess flag, EnvironmentPermissionAccess question )
        {
            return (flag & question) != 0;
        }
        
        private bool IsEmpty()
        {
            return (!m_unrestricted &&
                    (this.m_read == null || this.m_read.IsEmpty()) &&
                    (this.m_write == null || this.m_write.IsEmpty()));
        }
        
        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted()
        {
            return m_unrestricted;
        }
        
        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.IsSubsetOf"]/*' />
        public override bool IsSubsetOf(IPermission target)
        {
            if (target == null)
            {
                return this.IsEmpty();
            }

            try
            {
                EnvironmentPermission operand = (EnvironmentPermission)target;
                if (operand.IsUnrestricted())
                    return true;
                else if (this.IsUnrestricted())
                    return false;
                else
                    return ((this.m_read == null || this.m_read.IsSubsetOf( operand.m_read )) &&
                            (this.m_write == null || this.m_write.IsSubsetOf( operand.m_write )));
            }
            catch (InvalidCastException)
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.Intersect"]/*' />
        public override IPermission Intersect(IPermission target)
        {
            if (target == null)
            {
                return null;
            }
            else if (!VerifyType(target))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
            else if (this.IsUnrestricted())
            {
                return target.Copy();
            }
    
            EnvironmentPermission operand = (EnvironmentPermission)target;
    
            if (operand.IsUnrestricted())
            {
                return this.Copy();
            }
            
            StringExpressionSet intersectRead = this.m_read == null ? null : this.m_read.Intersect( operand.m_read );
            StringExpressionSet intersectWrite = this.m_write == null ? null : this.m_write.Intersect( operand.m_write );
            
            if ((intersectRead == null || intersectRead.IsEmpty()) &&
                (intersectWrite == null || intersectWrite.IsEmpty()))
            {
                return null;
            }
            
            EnvironmentPermission intersectPermission = new EnvironmentPermission(PermissionState.None);
            intersectPermission.m_unrestricted = false;
            intersectPermission.m_read = intersectRead;
            intersectPermission.m_write = intersectWrite;
            
            return intersectPermission;
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.Union"]/*' />
        public override IPermission Union(IPermission other)
        {
            if (other == null)
            {
                return this.Copy();
            }
            else if (!VerifyType(other))
            {
                throw new 
                    ArgumentException(
                                    String.Format(Environment.GetResourceString("Argument_WrongType"), this.GetType().FullName)
                                     );
            }
    
            EnvironmentPermission operand = (EnvironmentPermission)other;
           
            if (this.IsUnrestricted() || operand.IsUnrestricted())
            {
                return new EnvironmentPermission( PermissionState.Unrestricted );
            }
    
            StringExpressionSet unionRead = this.m_read == null ? operand.m_read : this.m_read.Union( operand.m_read );
            StringExpressionSet unionWrite = this.m_write == null ? operand.m_write : this.m_write.Union( operand.m_write );
            
            if ((unionRead == null || unionRead.IsEmpty()) &&
                (unionWrite == null || unionWrite.IsEmpty()))
            {
                return null;
            }
            
            EnvironmentPermission unionPermission = new EnvironmentPermission(PermissionState.None);
            unionPermission.m_unrestricted = false;
            unionPermission.m_read = unionRead;
            unionPermission.m_write = unionWrite;
            
            return unionPermission;
        }    
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.Copy"]/*' />
        public override IPermission Copy()
        {
            EnvironmentPermission copy = new EnvironmentPermission(PermissionState.None);
            if (this.m_unrestricted)
            {
                copy.m_unrestricted = true;
            }
            else
            {
                copy.m_unrestricted = false;
                if (this.m_read != null)
                {
                    copy.m_read = this.m_read.Copy();
                }
                if (this.m_write != null)
                {
                    copy.m_write = this.m_write.Copy();
                }
    
            }
            return copy;   
        }
       
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.ToXml"]/*' />
        public override SecurityElement ToXml()
        {
            SecurityElement esd = CodeAccessPermission.CreatePermissionElement( this );
            if (!IsUnrestricted())
            {
                if (this.m_read != null && !this.m_read.IsEmpty())
                {
                    esd.AddAttribute( "Read", SecurityElement.Escape( m_read.ToString() ) );
                }
                if (this.m_write != null && !this.m_write.IsEmpty())
                {
                    esd.AddAttribute( "Write", SecurityElement.Escape( m_write.ToString() ) );
                }
            }
            else
            {
                esd.AddAttribute( "Unrestricted", "true" );
            }
            return esd;
        }
        
        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.FromXml"]/*' />
        public override void FromXml(SecurityElement esd)
        {
            CodeAccessPermission.ValidateElement( esd, this );

            String et;
            
            if (XMLUtil.IsUnrestricted(esd))
            {
                m_unrestricted = true;
                return;
            }
    
            m_unrestricted = false;
            
            et = esd.Attribute( "Read" );
            if (et != null)
            {
                m_read = new EnvironmentStringExpressionSet( et );
            }
            
            et = esd.Attribute( "Write" );
            if (et != null)
            {
                m_write = new EnvironmentStringExpressionSet( et );
            }
    
        }

        /// <include file='doc\EnvironmentPermission.uex' path='docs/doc[@for="EnvironmentPermission.IBuiltInPermission.GetTokenIndex"]/*' />
        /// <internalonly/>
        int IBuiltInPermission.GetTokenIndex()
        {
            return EnvironmentPermission.GetTokenIndex();
        }

        internal static int GetTokenIndex()
        {
            return BuiltInPermissionIndex.EnvironmentPermissionIndex;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\ibuiltinpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  IBuiltInPermission.cool
//

namespace System.Security.Permissions
{
    internal interface IBuiltInPermission
    {
        int GetTokenIndex();
    }

    internal class BuiltInPermissionIndex
    {
        internal const int NUM_BUILTIN_UNRESTRICTED = 9;
        internal const int NUM_BUILTIN_NORMAL = 5;

        // Unrestricted permissions

        internal const int EnvironmentPermissionIndex = 0;
        internal const int FileDialogPermissionIndex = 1;
        internal const int FileIOPermissionIndex = 2;
        internal const int IsolatedStorageFilePermissionIndex = 3;
        internal const int ReflectionPermissionIndex = 4;
        internal const int RegistryPermissionIndex = 5;
        internal const int SecurityPermissionIndex = 6;
        internal const int UIPermissionIndex = 7;
        internal const int PrincipalPermissionIndex = 8;

        // Normal permissions

        internal const int PublisherIdentityPermissionIndex = 0 + NUM_BUILTIN_UNRESTRICTED;
        internal const int SiteIdentityPermissionIndex = 1 + NUM_BUILTIN_UNRESTRICTED;
        internal const int StrongNameIdentityPermissionIndex = 2 + NUM_BUILTIN_UNRESTRICTED;
        internal const int UrlIdentityPermissionIndex = 3 + NUM_BUILTIN_UNRESTRICTED;
        internal const int ZoneIdentityPermissionIndex = 4 + NUM_BUILTIN_UNRESTRICTED;
    }

	[Serializable]
    internal enum BuiltInPermissionFlag
    {
        // Unrestricted permissions

        EnvironmentPermission = 0x1,
        FileDialogPermission = 0x2,
        FileIOPermission = 0x4,
        IsolatedStorageFilePermission = 0x8,
        ReflectionPermission = 0x10,
        RegistryPermission = 0x20,
        SecurityPermission = 0x40,
        UIPermission = 0x80,
        PrincipalPermission = 0x100,

        // Normal permissions

        PublisherIdentityPermission = 0x200,
        SiteIdentityPermission = 0x400,
        StrongNameIdentityPermission = 0x800,
        UrlIdentityPermission = 0x1000,
        ZoneIdentityPermission = 0x2000
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\system\security\permissions\isolatedstoragefilepermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// IsolatedStorageFilePermission.cool
//
// Author : Shajan Dasan
//
// Purpose : This permission is used to controls/administer access to 
//	IsolatedStorageFile
//

namespace System.Security.Permissions {
    
    /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission"]/*' />
    [Serializable]
    sealed public class IsolatedStorageFilePermission : IsolatedStoragePermission, IBuiltInPermission
    {
        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.IsolatedStorageFilePermission"]/*' />
        public IsolatedStorageFilePermission(PermissionState state)
		: base(state) { }

        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.IsolatedStorageFilePermission1"]/*' />
        internal IsolatedStorageFilePermission(IsolatedStorageContainment UsageAllowed, 
            long ExpirationDays, bool PermanentData)
		: base(UsageAllowed, ExpirationDays, PermanentData) { }

        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.IsolatedStorageFilePermission2"]/*' />
        internal IsolatedStorageFilePermission(IsolatedStorageContainment UsageAllowed,
            long ExpirationDays, bool PermanentData, long UserQuota)
		: base(UsageAllowed, ExpirationDays, PermanentData, UserQuota) { }

        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------
        
        /// <include file='doc\IsolatedStorageFilePermission.uex' path='docs/doc[@for="IsolatedStorageFilePermission.Union"]/*' />
        public override IPermission Union(IPermission target)
        {
            if (target == null)
            {
   