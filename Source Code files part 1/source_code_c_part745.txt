opspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt      = VT_BSTR;
    propvar[0].pwszVal = bstr;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
        *ppv = (IWiaDataCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

CWiaDataCallback::CWiaDataCallback()
{
    m_cRef              = 0;
    m_BytesTransfered   = 0;
    m_pProgressFunc     = NULL;
    m_bCanceled         = FALSE;
    m_bBitmapCreated    = FALSE;
}

CWiaDataCallback::~CWiaDataCallback()
{

}

HRESULT _stdcall CWiaDataCallback::Initialize(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    m_pProgressFunc = pDataAcquireInfo->pProgressFunc;
    m_pDataAcquireInfo = pDataAcquireInfo;
    m_lPageCount = 0;
    return S_OK;
}

HRESULT _stdcall CWiaDataCallback::BandedDataCallback(LONG  lMessage,
                                                      LONG  lStatus,
                                                      LONG  lPercentComplete,
                                                      LONG  lOffset,
                                                      LONG  lLength,
                                                      LONG  lReserved,
                                                      LONG  lResLength,
                                                      BYTE* pbBuffer)
{
    m_bCanceled = FALSE;

    //
    // process callback messages
    //

    switch (lMessage)
    {
    case IT_MSG_DATA_HEADER:
        {
            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
            m_MemBlockSize                    = pHeader->lBufferSize;

            //
            // If the Buffer is 0, then alloc a 64k chunk (default)
            //

            if(m_MemBlockSize <= 0)
                m_MemBlockSize = 65535;

            if(m_pDataAcquireInfo->bTransferToClipboard) {
                m_pDataAcquireInfo->hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,m_MemBlockSize);
            } else {
                m_pDataAcquireInfo->hBitmapData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,m_MemBlockSize);
            }
            m_BytesTransfered            = 0;
            m_cFormat                    = pHeader->guidFormatID;
        }
        break;

    case IT_MSG_DATA:
        {
            //
            // increment bytes transferred counter
            //

            m_BytesTransfered += lLength;
            if(m_BytesTransfered >= m_MemBlockSize){

                //
                // Alloc more memory for transfer buffer
                //

                m_MemBlockSize += (lLength * 2);

                if(m_pDataAcquireInfo->bTransferToClipboard) {
                    if(m_pDataAcquireInfo->hClipboardData != NULL) {
                        m_pDataAcquireInfo->hClipboardData = GlobalReAlloc(m_pDataAcquireInfo->hClipboardData,
                                                                           m_MemBlockSize, GMEM_MOVEABLE);
                    }
                } else {
                    if(m_pDataAcquireInfo->hBitmapData != NULL) {
                        m_pDataAcquireInfo->hBitmapData = GlobalReAlloc(m_pDataAcquireInfo->hBitmapData,
                                                                           m_MemBlockSize, GMEM_MOVEABLE);
                    }
                }
            }


            if(m_pDataAcquireInfo->bTransferToClipboard) {
                BYTE* pByte = (BYTE*)GlobalLock(m_pDataAcquireInfo->hClipboardData);
                memcpy(pByte + lOffset, pbBuffer, lLength);
                GlobalUnlock(m_pDataAcquireInfo->hClipboardData);
            } else {
                if(m_pDataAcquireInfo->hBitmapData != NULL) {
                    BYTE* pByte = (BYTE*)GlobalLock(m_pDataAcquireInfo->hBitmapData);
                    memcpy(pByte + lOffset, pbBuffer, lLength);
                    GlobalUnlock(m_pDataAcquireInfo->hBitmapData);
                }
            }

            //
            // do any extra image processing here
            //

            if(!m_pDataAcquireInfo->bTransferToClipboard) {
                if(m_cFormat == WiaImgFmt_MEMORYBMP) {

                    if(m_bBitmapCreated) {

                        //
                        // Add data to your bitmap
                        //

                        AddDataToHBITMAP(m_pDataAcquireInfo->hWnd,
                            m_pDataAcquireInfo->hBitmapData,
                            &m_pDataAcquireInfo->hBitmap,
                            lOffset);

                    } else {

                        //
                        // Create your bitmap for display
                        //

                        CreateHBITMAP(m_pDataAcquireInfo->hWnd,
                            m_pDataAcquireInfo->hBitmapData,
                            &m_pDataAcquireInfo->hBitmap,
                            lOffset);
                    }

                }
                else if(m_cFormat == WiaImgFmt_TIFF) {

                }
            }

            //
            // process progress monitor
            //

            if(m_pProgressFunc != NULL){
                if(lPercentComplete == 0)
                    m_bCanceled = m_pProgressFunc(TEXT("Acquiring Image..."),lPercentComplete);
                else {
                    TCHAR szBuffer[MAX_PATH];
                    sprintf(szBuffer,TEXT("%d%% Complete..."),lPercentComplete);
                    m_bCanceled = m_pProgressFunc(szBuffer,lPercentComplete);
                }
            }
        }
        break;

    case IT_MSG_STATUS:
        {

            //
            // process "Status" message
            //

            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Transfer from device"),lPercentComplete);
            }
            else if (lStatus & IT_STATUS_PROCESSING_DATA) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Processing Data"),lPercentComplete);
            }
            else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Transfer to Client"),lPercentComplete);
            }
        }
        break;

    case IT_MSG_NEW_PAGE:
        {
            //
            // process "New Page" message
            //

            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
            m_lPageCount =  pHeader->lPageCount;
            if(m_pProgressFunc != NULL)
                m_bCanceled = m_pProgressFunc(TEXT("New Page"),lPercentComplete);
        }
        break;
    }

    //
    // check use canceled acquire
    //

   if(m_bCanceled)
       return S_FALSE;

   return S_OK;
}

void CWiaDataCallback::AddDataToHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset)
{
    BYTE* pData = (BYTE*)GlobalLock(hBitmapData);
    if(pData) {
        HDC hdc = ::GetDC(hWnd);
        if(*phBitmap == NULL) {
            OutputDebugString(TEXT("HBITMAP is NULL...this is a bad thing\n"));
            return;
        }
        if(hdc == NULL) {
            OutputDebugString(TEXT("HDC is NULL...this is a bad thing\n"));
            return;
        }
        LPBITMAPINFO pbmi   = (LPBITMAPINFO)pData;

        if(hdc != NULL){
            if(pbmi != NULL) {
                if(SetDIBits(hdc,
                    *phBitmap,
                    0,
                    (pbmi->bmiHeader.biHeight < 0?(-(pbmi->bmiHeader.biHeight)):pbmi->bmiHeader.biHeight),
                    pData + sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed),
                    pbmi,
                    DIB_RGB_COLORS) == 0) {

                    DWORD dwLastError = GetLastError();
                    TCHAR buf[10];
                    sprintf(buf,"GetLastError() code = %d\n",dwLastError);
                    OutputDebugString("AddDataToHBITMAP, SetDIBits failed..with ");
                    OutputDebugString(buf);
                }
            }
        }
        GlobalUnlock(hBitmapData);
    } else {
        OutputDebugString(TEXT("No bitmap memory available..\n"));
    }
}
void CWiaDataCallback::CreateHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset)
{
    HDC hdc             = NULL; // DC to draw to
    LPBITMAPINFO pbmi   = NULL; // pointer to BITMAPINFO struct
    BITMAP  bitmap;
    BYTE *pDib          = NULL; // dib data
    BYTE *pData         = (BYTE*)GlobalLock(hBitmapData);

    if(pData) {

        if(*phBitmap != NULL) {

            //
            // delete old bitmap, if one exists
            //

            OutputDebugString(TEXT("Destroying old HBITMAP..\n"));
            DeleteObject(*phBitmap);
        }

        //
        // get hdc
        //

        hdc = ::GetWindowDC(hWnd);
        if(hdc != NULL){


            //
            // set bitmap header information
            //

            pbmi   = (LPBITMAPINFO)pData;
            if (pbmi != NULL) {

                //
                // create a HBITMAP object
                //

                *phBitmap = ::CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(void **)&pDib,NULL,0);

                if (*phBitmap != NULL) {

                    //
                    // initialize it to white
                    //

                    memset(pDib,255,pbmi->bmiHeader.biSizeImage);

                    //
                    // get HBITMAP
                    //

                    ::GetObject(*phBitmap,sizeof(BITMAP),(LPSTR)&bitmap);
                    m_bBitmapCreated = TRUE;
                } else {
                    OutputDebugString(TEXT("HBITMAP is NULL..\n"));
                }
            } else {
                OutputDebugString(TEXT("BITMAPINFOHEADER is NULL..\n"));
            }

            //
            // release hdc
            //

            ::ReleaseDC(hWnd,hdc);
        } else {
            OutputDebugString(TEXT("DC is NULL\n"));
        }
        GlobalUnlock(hBitmapData);
    } else {
        OutputDebugString(TEXT("No bitmap memory available..\n"));
    }
}

//
// global Interface access functions
//

HRESULT WriteInterfaceToGlobalInterfaceTable(DWORD *pdwCookie, IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    hr = g_pGIT->RegisterInterfaceInGlobal(pIWiaItem, IID_IWiaItem,  pdwCookie);
    return hr;
}

HRESULT ReadInterfaceFromGlobalInterfaceTable(DWORD dwCookie, IWiaItem **ppIWiaItem)
{
    HRESULT hr = S_OK;
    hr = g_pGIT->GetInterfaceFromGlobal(dwCookie, IID_IWiaItem, (void**)ppIWiaItem);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\adfdlg.h ===
#ifndef _ADFDLG_H
#define _ADFDLG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ADFDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CADFDlg dialog

class CADFDlg : public CDialog
{
// Construction
public:
    CADFDlg(ADF_SETTINGS *pADFSettings, CWnd* pParent = NULL);   // standard constructor
    UINT m_MaxPagesAllowed;

// Dialog Data
    //{{AFX_DATA(CADFDlg)
    enum { IDD = IDD_ADF_SETTING_DIALOG };
    CComboBox   m_PageOrderComboBox;
    CComboBox   m_ADFModeComboBox;
    CEdit   m_ScanNumberOfPagesEditBox;
    CString m_ADFStatusText;
    UINT    m_NumberOfPages;
    CButton m_ScanAllPages;
    CButton m_ScanNumberOfPages;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CADFDlg)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    ADF_SETTINGS *m_pADFSettings;
    LONG m_DocumentHandlingSelectBackup;
    VOID InitStatusText();
    VOID InitFeederModeComboBox();
    VOID InitPageOrderComboBox();
    INT GetIDAndStringFromDocHandlingStatus(LONG lDocHandlingStatus, TCHAR *pszString);
    // Generated message map functions
    //{{AFX_MSG(CADFDlg)
    afx_msg void OnKillfocusNumberOfPagesEditbox();
    virtual BOOL OnInitDialog();
    afx_msg void OnScanAllPagesRadiobutton();
    afx_msg void OnScanSpecifiedPagesRadiobutton();
    afx_msg void OnSelchangeAdfModeCombobox();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\msqscan.cpp ===
// MSQSCAN.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "MSQSCANDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp

BEGIN_MESSAGE_MAP(CMSQSCANApp, CWinApp)
    //{{AFX_MSG_MAP(CMSQSCANApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp construction

CMSQSCANApp::CMSQSCANApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMSQSCANApp object

CMSQSCANApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp initialization

BOOL CMSQSCANApp::InitInstance()
{
    AfxEnableControlContainer();

    //
    // Initialize COM
    //

    if (SUCCEEDED(CoInitialize(NULL))) {


        // Standard initialization
        // If you are not using these features and wish to reduce the size
        //  of your final executable, you should remove from the following
        //  the specific initialization routines you do not need.

#ifdef _AFXDLL
        Enable3dControls();         // Call this when using MFC in a shared DLL
#else
        Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

        CMSQSCANDlg dlg;
        m_pMainWnd = &dlg;

        switch (dlg.DoModal()) {
        case IDOK:
            break;
        case IDCANCEL:
            break;
        default:
            break;
        }

        //
        // clean up WIA before we uninitialize COM
        //

        dlg.m_WIA.CleanUp();

        if(dlg.m_DataAcquireInfo.hBitmapData != NULL) {
            GlobalUnlock(dlg.m_DataAcquireInfo.hBitmapData);
            GlobalFree(dlg.m_DataAcquireInfo.hBitmapData);
            dlg.m_DataAcquireInfo.hBitmapData = NULL;
        }

        //
        // Uninitialize COM
        //

        CoUninitialize();

    } else {
        AfxMessageBox("COM Failed to initialize correctly");
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\msqscan.h ===
// MSQSCAN.h : main header file for the MSQSCAN application
//

#ifndef _MSQSCAN_H
#define _MSQSCAN_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#define WM_UPDATE_PREVIEW WM_USER + 503

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp:
// See MSQSCAN.cpp for the implementation of this class
//

class CMSQSCANApp : public CWinApp
{
public:
    CMSQSCANApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMSQSCANApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CMSQSCANApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\preview.cpp ===
// Preview.cpp : implementation file
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "Preview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreview

CPreview::CPreview()
{
    m_hBitmap = NULL;
}

CPreview::~CPreview()
{
}

void CPreview::GetSelectionRect(RECT *pRect)
{
    CopyRect(pRect,&m_RectTracker.m_rect);
}

void CPreview::SetSelectionRect(RECT *pRect)
{
    CopyRect(&m_RectTracker.m_rect,pRect);
    InvalidateSelectionRect();
}

void CPreview::SetPreviewRect(CRect Rect)
{
    m_PreviewRect.left = 0;
    m_PreviewRect.top = 0;
    m_PreviewRect.right = Rect.Width();
    m_PreviewRect.bottom = Rect.Height();
    
    //
    // set selection rect styles
    //

    m_RectTracker.m_rect.left = PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.top = PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.right = Rect.Width()-PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.bottom = Rect.Height()-PREVIEW_SELECT_OFFSET;
        
    m_RectTracker.m_nStyle = CRectTracker::resizeInside|CRectTracker::dottedLine;
    m_RectTracker.SetClippingWindow(m_RectTracker.m_rect);
}

BEGIN_MESSAGE_MAP(CPreview, CWnd)
    //{{AFX_MSG_MAP(CPreview)   
    ON_WM_LBUTTONDOWN()
    ON_WM_SETCURSOR()
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreview message handlers

void CPreview::OnLButtonDown(UINT nFlags, CPoint point) 
{   
    m_RectTracker.Track(this,point,FALSE,this);
    InvalidateSelectionRect();
    CWnd::OnLButtonDown(nFlags, point);
}

BOOL CPreview::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
    if(m_RectTracker.SetCursor(pWnd,nHitTest))
        return TRUE;
    return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CPreview::OnPaint() 
{
    CPaintDC dc(this); // device context for painting       
    
    if(m_hBitmap == NULL) {
        
        CRect TrueRect;        
        GetWindowRect(TrueRect);
        
        //
        // convert to client coords
        //
        
        CWnd* pParent = GetParent();
        if(pParent) {
            ScreenToClient(TrueRect);
            
            //
            // create a white brush
            //
            
            CBrush WhiteBrush;
            WhiteBrush.CreateSolidBrush(RGB(255,255,255));
            
            //
            // select white brush, while saving previously selected brush
            //
            
            CBrush* pOldBrush = dc.SelectObject(&WhiteBrush);
            
            //
            // fill the preview window with white
            //
            
            dc.FillRect(TrueRect,&WhiteBrush);
            
            //
            // put back the previously selected brush
            //
            
            dc.SelectObject(pOldBrush);
            
            //
            // destroy the white brush
            //
            
            WhiteBrush.DeleteObject();
        }
    } else {

        //
        // paint preview bitmap
        //

        PaintHBITMAPToDC();
    }

    //
    // draw the selection rect, over the image
    //

    m_RectTracker.Draw(&dc);
}

void CPreview::InvalidateSelectionRect()
{
    //
    // get parent window
    //

    CWnd* pParent = GetParent();
    
    if(pParent) {
        
        //
        // get your window rect
        //
        
        CRect TrueRect;
        GetWindowRect(TrueRect);
        
        //
        // convert to client coords
        //
        
        pParent->ScreenToClient(TrueRect);
        
        //
        // invalidate through parent, because we are using the parent's DC to
        // draw images.
        //
        
        pParent->InvalidateRect(TrueRect);
    }
}

void CPreview::SetHBITMAP(HBITMAP hBitmap)
{
    m_hBitmap = hBitmap;
    PaintHBITMAPToDC();
}

void CPreview::PaintHBITMAPToDC()
{
    //
    // get hdc
    //

    HDC hMemorydc = NULL;
    HDC hdc = ::GetWindowDC(m_hWnd);
    BITMAP bitmap;

    if(hdc != NULL){
        
        //
        // create a memory dc
        //
        
        hMemorydc = ::CreateCompatibleDC(hdc);
        if(hMemorydc != NULL){
                        
            //
            // select HBITMAP into your hMemorydc
            //
            
            if(::GetObject(m_hBitmap,sizeof(BITMAP),(LPSTR)&bitmap) != 0) {
                HGDIOBJ hGDIObj = ::SelectObject(hMemorydc,m_hBitmap);
                
                RECT ImageRect;
                ImageRect.top = 0;
                ImageRect.left = 0;
                ImageRect.right = bitmap.bmWidth;
                ImageRect.bottom = bitmap.bmHeight;
                                
                ScaleBitmapToDC(hdc,hMemorydc,&m_PreviewRect,&ImageRect);
                                
            } else {
                OutputDebugString(TEXT("Failed GetObject\n"));
            }
        }
        
        //
        // delete hMemorydc
        //
                
        ::DeleteDC(hMemorydc);               
    }
    
    //
    // delete hdc
    //
    
    ::ReleaseDC(m_hWnd,hdc);    
}

void CPreview::ScreenRectToClientRect(HWND hWnd,LPRECT pRect)
{
    POINT PtConvert;

    PtConvert.x = pRect->left;
    PtConvert.y = pRect->top;

    //
    // convert upper left point
    //

    ::ScreenToClient(hWnd,&PtConvert);

    pRect->left = PtConvert.x;
    pRect->top = PtConvert.y;

    PtConvert.x = pRect->right;
    PtConvert.y = pRect->bottom;

    //
    // convert lower right point
    //

    ::ScreenToClient(hWnd,&PtConvert);

    pRect->right = PtConvert.x;
    pRect->bottom = PtConvert.y;

    pRect->bottom-=1;
    pRect->left+=1;
    pRect->right-=1;
    pRect->top+=1;
}

void CPreview::ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect)
{
    ::SetStretchBltMode(hDC, COLORONCOLOR);    

    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &&
        (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
                    ::BitBlt (hDC,                   // hDC
                             lpDCRect->left,        // DestX
                             lpDCRect->top,         // DestY
                             RECTWIDTH(lpDCRect),   // nDestWidth
                             RECTHEIGHT(lpDCRect),  // nDestHeight                             
                             hDCM,
                             0,
                             0,
                             SRCCOPY);        
    else {
                      StretchBlt(hDC,                   // hDC
                                lpDCRect->left,        // DestX
                                lpDCRect->top,         // DestY
                                lpDCRect->right,//ScaledWidth,           // nDestWidth
                                lpDCRect->bottom,//ScaledHeight,          // nDestHeight
                                hDCM,
                                0,                     // SrcX
                                0,                     // SrcY
                                RECTWIDTH(lpDIBRect),  // wSrcWidth
                                RECTHEIGHT(lpDIBRect), // wSrcHeight
                                SRCCOPY);              // dwROP        
    }   
}
/////////////////////////////////////////////////////////////////////////////
// CRectTrackerEx overridden functions

void CRectTrackerEx::AdjustRect( int nHandle, LPRECT lpRect )
{
    //
    // if clipping rect is empty, do nothing
    // 

    if (!m_rectClippingWindow.IsRectEmpty()) {
        if (nHandle == hitMiddle) {

            // user is dragging entire selection around...
            // make sure selection rect does not get out of clipping
            // rect
            //

            CRect rect = lpRect;
            if (rect.right > m_rectClippingWindow.right)
                rect.OffsetRect(m_rectClippingWindow.right - rect.right, 0);
            if (rect.left < m_rectClippingWindow.left)
                rect.OffsetRect(m_rectClippingWindow.left - rect.left, 0);
            if (rect.bottom > m_rectClippingWindow.bottom)
                rect.OffsetRect(0, m_rectClippingWindow.bottom - rect.bottom);
            if (rect.top < m_rectClippingWindow.top)
                rect.OffsetRect(0, m_rectClippingWindow.top - rect.top);
            *lpRect = rect;
        } else {

            //
            // user is resizing the selection rect
            // make sure selection rect does not extend outside of clipping
            // rect
            //

            int *px, *py;

            //
            // get X and Y selection axis
            //

            GetModifyPointers(nHandle, &px, &py, NULL, NULL);           

            if (px != NULL)
                *px = max(min(m_rectClippingWindow.right, *px), m_rectClippingWindow.left);
            if (py != NULL)
                *py = max(min(m_rectClippingWindow.bottom, *py), m_rectClippingWindow.top);

            CRect rect = lpRect;

            //
            // check/adjust X axis
            //

            if (px != NULL && abs(rect.Width()) < m_sizeMin.cx) {
                if (*px == rect.left)
                    rect.left = rect.right;
                else
                    rect.right = rect.left;
            }

            //
            // check/adjust Y axis
            //

            if (py != NULL && abs(rect.Height()) < m_sizeMin.cy) {
                if (*py == rect.top)
                    rect.top = rect.bottom;
                else
                    rect.bottom = rect.top;
            }

            //
            // save the adjusted rectangle
            //

            *lpRect = rect;
        }
    }
}

void CRectTrackerEx::SetClippingWindow(CRect Rect)
{
    m_rectClippingWindow = Rect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\preview.h ===
#ifndef _PREVIEW_H
#define _PREVIEW_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Preview.h : header file
//

#define PREVIEW_SELECT_OFFSET 1

/////////////////////////////////////////////////////////////////////////////
// CRectTrackerEx

class CRectTrackerEx : public CRectTracker
{
public :
	void SetClippingWindow(CRect Rect);
protected:
	CRect m_rectClippingWindow;
	virtual void AdjustRect( int nHandle, LPRECT lpRect );
};

/////////////////////////////////////////////////////////////////////////////
// CPreview window

class CPreview : public CWnd
{
// Construction
public:
	void SetHBITMAP(HBITMAP hBitmap);
	void PaintHBITMAPToDC();
	void ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect);	
	
	void ScreenRectToClientRect(HWND hWnd,LPRECT pRect);	
    
	CRectTrackerEx m_RectTracker;
	CPreview();

// Attributes
public:

// Operations
public:
	void GetSelectionRect(RECT *pRect);
	void SetSelectionRect(RECT *pRect);

	void InvalidateSelectionRect();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreview)
	//}}AFX_VIRTUAL

// Implementation
public:
	void SetPreviewRect(CRect Rect);	
	virtual ~CPreview();

	// Generated message map functions
protected:
	HBITMAP m_hBitmap;
	CRect m_PreviewRect;
	//{{AFX_MSG(CPreview)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\msqscandlg.h ===
// MSQSCANDlg.h : header file
//

#ifndef _MSQSCANDLG_H
#define _MSQSCANDLG_H

#include "Preview.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define PREVIEW_RES 100

#include "datatypes.h"

#define ID_WIAEVENT_CONNECT		0
#define ID_WIAEVENT_DISCONNECT	1

/////////////////////////////////////////////////////////////////////////////
// CEventCallback

class CEventCallback : public IWiaEventCallback
{
private:
   ULONG	m_cRef;		// Object reference count.
   int		m_EventID;	// What kind of event is this callback for?
public:
   IUnknown *m_pIUnkRelease; // release server registration
public:
    // Constructor, initialization and destructor methods.
    CEventCallback();
    ~CEventCallback();

    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(int EventID);

    HRESULT _stdcall ImageEventCallback(
        const GUID      *pEventGUID,
        BSTR            bstrEventDescription,
        BSTR            bstrDeviceID,
        BSTR            bstrDeviceDescription,
        DWORD           dwDeviceType,
        BSTR            bstrFullItemName,
        ULONG           *plEventType,
        ULONG           ulReserved);
};

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg dialog

class CMSQSCANDlg : public CDialog
{
// Construction
public:    
    CMSQSCANDlg(CWnd* pParent = NULL);  // standard constructor
    
    //
    // events callback
    //

    CEventCallback* m_pConnectEventCB;

    //
    // scanner preview window
    //

    CPreview m_PreviewWindow;

    //
    // WIA components, WIA device manager, and WIA Wrapper object
    //

    IWiaDevMgr *m_pIWiaDevMgr;
    CWIA m_WIA;
    
    //
    // Data transfer, thread information structure
    //

    DATA_ACQUIRE_INFO m_DataAcquireInfo;    
    ADF_SETTINGS      m_ADFSettings;
    
    //
    // UI <--> device settings helpers
    //

    BOOL InitDialogSettings();
    BOOL InitResolutionEditBoxes();
    BOOL InitDataTypeComboBox();
    BOOL InitContrastSlider();
    BOOL InitBrightnessSlider();
    BOOL InitFileTypeComboBox();
    BOOL ResetWindowExtents();
	BOOL ReadADFSettings(ADF_SETTINGS *pADFSettings);
    BOOL WriteADFSettings(ADF_SETTINGS *pADFSettings);

    BOOL WriteScannerSettingsToDevice(BOOL bPreview = FALSE);

    //
    // UI helpers
    //

    INT  GetIDAndStringFromGUID(GUID guidFormat, TCHAR *pszguidString);
    GUID GetGuidFromID(INT iID);
    INT  GetIDAndStringFromDataType(LONG lDataType, TCHAR *pszguidString);
    LONG GetDataTypeFromID(INT iID);
    BOOL SetDeviceNameToWindowTitle(BSTR bstrDeviceName);
    
    //
    // Image (clipboard manipulation) helpers
    //

    BOOL PutDataOnClipboard();
    VOID VerticalFlip(BYTE *pBuf);
    
// Dialog Data
    //{{AFX_DATA(CMSQSCANDlg)
    enum { IDD = IDD_MSQSCAN_DIALOG };
    CButton m_ChangeBothResolutionsCheckBox;
    CSpinButtonCtrl m_YResolutionBuddy;
    CSpinButtonCtrl m_XResolutionBuddy;
    CButton m_ScanButton;
    CButton m_PreviewButton;
    CComboBox   m_FileTypeComboBox;
    CComboBox   m_DataTypeComboBox;
    CSliderCtrl m_ContrastSlider;
    CSliderCtrl m_BrightnessSlider;
    CStatic m_PreviewRect;
    CString m_MAX_Brightness;
    CString m_MAX_Contrast;
    CString m_MIN_Brightness;
    CString m_MIN_Contrast;
    long    m_XResolution;
    long    m_YResolution;
    CButton m_DataToFile;
    CButton m_DataToClipboard;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMSQSCANDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CMSQSCANDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnDeltaposEditXresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDeltaposEditYresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusEditXres();
    afx_msg void OnKillfocusEditXres();
    afx_msg void OnKillfocusEditYres();
    afx_msg void OnSetfocusEditYres();
    afx_msg void OnScanButton();
    afx_msg void OnPreviewButton();
    afx_msg void OnFileClose();
    afx_msg void OnFileSelectDevice();
	afx_msg void OnAdfSettings();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSQSCANDLG_H__E1A2B3DB_C967_47EF_8487_C4F243D0BC58__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\msqscandlg.cpp ===
// MSQSCANDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "MSQSCANDlg.h"
#include "ProgressDlg.h"
#include "uitables.h"
#include "ADFDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PIXELS_PER_INCH_FACTOR 32
#define PREVIEW_WINDOW_OFFSET  11

DWORD g_dwCookie = 0;
IGlobalInterfaceTable *g_pGIT = NULL;

//
// global UI lookup tables
//

extern WIA_FORMAT_TABLE_ENTRY   g_WIA_FORMAT_TABLE[];
extern WIA_DATATYPE_TABLE_ENTRY g_WIA_DATATYPE_TABLE[];

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg dialog

CMSQSCANDlg::CMSQSCANDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CMSQSCANDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMSQSCANDlg)
    m_MAX_Brightness = _T("");
    m_MAX_Contrast   = _T("");
    m_MIN_Brightness = _T("");
    m_MIN_Contrast   = _T("");
    m_XResolution    = 0;
    m_YResolution    = 0;
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_DataAcquireInfo.bTransferToClipboard = FALSE;
    m_DataAcquireInfo.bPreview             = TRUE;
    m_DataAcquireInfo.bTransferToFile      = FALSE;
    m_DataAcquireInfo.dwCookie             = 0;
    m_DataAcquireInfo.hBitmap              = NULL;
    m_DataAcquireInfo.hClipboardData       = NULL;
    m_DataAcquireInfo.pProgressFunc        = NULL;
    m_DataAcquireInfo.hBitmapData          = NULL;
    m_pConnectEventCB = NULL;
}

void CMSQSCANDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMSQSCANDlg)
    DDX_Control(pDX, IDC_CHANGE_BOTH_CHECKBOX, m_ChangeBothResolutionsCheckBox);
    DDX_Control(pDX, IDC_EDIT_YRES_SPIN_BUDDY, m_YResolutionBuddy);
    DDX_Control(pDX, IDC_EDIT_XRES_SPIN_BUDDY, m_XResolutionBuddy);
    DDX_Control(pDX, IDC_SCAN_BUTTON, m_ScanButton);
    DDX_Control(pDX, IDC_PREVIEW_BUTTON, m_PreviewButton);
    DDX_Control(pDX, IDC_IMAGE_FILETYPE_COMBO, m_FileTypeComboBox);
    DDX_Control(pDX, IDC_DATATYPE_COMBO, m_DataTypeComboBox);
    DDX_Control(pDX, IDC_CONTRAST_SLIDER, m_ContrastSlider);
    DDX_Control(pDX, IDC_BRIGHTNESS_SLIDER, m_BrightnessSlider);
    DDX_Control(pDX, IDC_PREVIEW_WINDOW, m_PreviewRect);
    DDX_Text(pDX, IDC_MAX_BRIGHTNESS, m_MAX_Brightness);
    DDX_Text(pDX, IDC_MAX_CONTRAST, m_MAX_Contrast);
    DDX_Text(pDX, IDC_MIN_BRIGHTNESS, m_MIN_Brightness);
    DDX_Text(pDX, IDC_MIN_CONTRAST, m_MIN_Contrast);
    DDX_Text(pDX, IDC_EDIT_XRES, m_XResolution);
    DDX_Text(pDX, IDC_EDIT_YRES, m_YResolution);
    DDX_Control(pDX, IDC_DATA_TO_FILE, m_DataToFile);
    DDX_Control(pDX, IDC_DATA_TO_CLIPBOARD, m_DataToClipboard);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMSQSCANDlg, CDialog)
    //{{AFX_MSG_MAP(CMSQSCANDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_NOTIFY(UDN_DELTAPOS, IDC_EDIT_XRES_SPIN_BUDDY, OnDeltaposEditXresSpinBuddy)
    ON_NOTIFY(UDN_DELTAPOS, IDC_EDIT_YRES_SPIN_BUDDY, OnDeltaposEditYresSpinBuddy)
    ON_EN_SETFOCUS(IDC_EDIT_XRES, OnSetfocusEditXres)
    ON_EN_KILLFOCUS(IDC_EDIT_XRES, OnKillfocusEditXres)
    ON_EN_KILLFOCUS(IDC_EDIT_YRES, OnKillfocusEditYres)
    ON_EN_SETFOCUS(IDC_EDIT_YRES, OnSetfocusEditYres)
    ON_BN_CLICKED(IDC_SCAN_BUTTON, OnScanButton)
    ON_BN_CLICKED(IDC_PREVIEW_BUTTON, OnPreviewButton)
    ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
    ON_COMMAND(ID_FILE_SELECT_DEVICE, OnFileSelectDevice)
    ON_BN_CLICKED(IDC_ADF_SETTINGS, OnAdfSettings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg message handlers

BOOL CMSQSCANDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    //
    // Set radio button setting (Data to File as DEFAULT setting)
    //

    m_DataToFile.SetCheck(1);
    m_DataAcquireInfo.hBitmap = NULL;

    OnFileSelectDevice();

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMSQSCANDlg::OnPaint()
{
    if (IsIconic()) {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMSQSCANDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg message handlers

BOOL CMSQSCANDlg::InitDialogSettings()
{

    //
    // fill common resolution combo box
    //

    if (InitResolutionEditBoxes()) {

        //
        // fill data type combo box
        //

        if (InitDataTypeComboBox()) {

            //
            // set min/max contrast slider control
            //

            if (InitContrastSlider()) {

                //
                // set min/max brightness slider control
                //

                if (InitBrightnessSlider()) {

                    //
                    // fill supported file type combo box
                    //

                    if (!InitFileTypeComboBox()) {
                        return FALSE;
                    }
                } else {
                    MessageBox("Brightness Slider control failed to initialize");
                    return FALSE;
                }
            } else {
                MessageBox("Contrast Slider control failed to initialize");
                return FALSE;
            }
        } else {
            MessageBox("Data Type combobox failed to initialize");
            return FALSE;
        }
    } else {
        MessageBox("Resolution edit boxes failed to initialize");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::InitResolutionEditBoxes()
{

    //
    // Set buddy controls to their "buddy"
    //

    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_XRES,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read x resolution (Min Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read x resolution (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read x resolution (Current Setting)");
        return FALSE;
    }

    m_XResolutionBuddy.SetBuddy(GetDlgItem(IDC_EDIT_XRES));
    m_XResolutionBuddy.SetRange(lMin,lMax);
    m_XResolutionBuddy.SetPos(lCurrent);
    m_XResolution = m_XResolutionBuddy.GetPos();

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {

            hr = m_WIA.ReadLong(NULL,WIA_IPS_XRES,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read y resolution (Min Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read y resolution (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read y resolution (Current Setting)");
        return FALSE;
    }

    m_YResolutionBuddy.SetBuddy(GetDlgItem(IDC_EDIT_YRES));
    m_YResolutionBuddy.SetRange(lMin,lMax);
    m_YResolutionBuddy.SetPos(lCurrent);
    m_YResolution = m_YResolutionBuddy.GetPos();

    //
    // set current selection, to be scanner's current setting
    //

    UpdateData(FALSE);

    //
    // check 'change both resolutions' check box
    //

    m_ChangeBothResolutionsCheckBox.SetCheck(1);

    return TRUE;
}

BOOL CMSQSCANDlg::InitDataTypeComboBox()
{
    //
    // reset data type combo box
    //

    m_DataTypeComboBox.ResetContent();

    //
    // set current selection, to be scanner's current setting
    //

    //
    // Below is a hard coded supported data type list.  This should be obtained from the
    // device itself. (ie. some scanners may not support color..)
    // This was done for testing purposes.
    //

    ULONG ulCount = 3;
    TCHAR szDataType[MAX_PATH];
    LONG plDataType[3] = {
        WIA_DATA_THRESHOLD,
        WIA_DATA_COLOR,
        WIA_DATA_GRAYSCALE
    };

    for(ULONG index = 0;index < ulCount;index++) {

        //
        // add data type  to combo box
        //

        INT TableIndex  = GetIDAndStringFromDataType(plDataType[index],szDataType);
        INT InsertIndex = m_DataTypeComboBox.AddString(szDataType);
        m_DataTypeComboBox.SetItemData(InsertIndex, TableIndex);
    }

    return TRUE;
}

BOOL CMSQSCANDlg::InitContrastSlider()
{
    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_CONTRAST,WIA_RANGE_MIN,&lMin);
    if(SUCCEEDED(hr)){
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_CONTRAST,WIA_RANGE_MAX,&lMax);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_CONTRAST,&lCurrent);
            if(FAILED(hr)){
                MessageBox("Application Failed to read contrast (Current Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read contrast (Max Setting)");
            return FALSE;
        }
    }else {
        MessageBox("Application Failed to read contrast (Min Setting)");
        return FALSE;
    }

    m_ContrastSlider.SetRange(lMin,lMax,TRUE);
    m_ContrastSlider.SetPos(lCurrent);
    m_ContrastSlider.SetTicFreq(lMax/11);

    m_MIN_Contrast.Format("%d",lMin);
    m_MAX_Contrast.Format("%d",lMax);

    UpdateData(FALSE);

    //
    // set current selection, to be scanner's current setting
    //

    m_DataTypeComboBox.SetCurSel(0);
    return TRUE;
}

BOOL CMSQSCANDlg::InitBrightnessSlider()
{
    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_BRIGHTNESS,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_BRIGHTNESS,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_BRIGHTNESS,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read brightness (Current Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read brightness (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read brightness (Min Setting)");
        return FALSE;
    }

    m_BrightnessSlider.SetRange(lMin,lMax,TRUE);
    m_BrightnessSlider.SetPos(lCurrent);
    m_BrightnessSlider.SetTicFreq(lMax/11);

    m_MIN_Brightness.Format("%d",lMin);
    m_MAX_Brightness.Format("%d",lMax);

    UpdateData(FALSE);

    //
    // set current selection, to be scanner's current setting
    //

    return TRUE;
}

BOOL CMSQSCANDlg::InitFileTypeComboBox()
{
    //
    // reset file type combo box
    //

    m_FileTypeComboBox.ResetContent();

    HRESULT hr = S_OK;
    TCHAR szguidFormat[MAX_PATH];

    //
    // set current selection, to be scanner's current setting
    //

    //
    // enumerate supported file types
    //

    WIA_FORMAT_INFO *pSupportedFormats = NULL;
    ULONG ulCount = 0;

    hr = m_WIA.EnumerateSupportedFormats(NULL, &pSupportedFormats, &ulCount);
    if(SUCCEEDED(hr)) {

        //
        // filter out TYMED_FILE formats only
        //

        for(ULONG index = 0;index < ulCount;index++) {
            if(pSupportedFormats[index].lTymed == TYMED_FILE) {

                //
                // add supported file format to combo box
                //

                INT TableIndex  = GetIDAndStringFromGUID(pSupportedFormats[index].guidFormatID,szguidFormat);
                INT InsertIndex = m_FileTypeComboBox.AddString(szguidFormat);
                m_FileTypeComboBox.SetItemData(InsertIndex, TableIndex);
            }
        }

        //
        // free the memory allocated by the CWIA call
        //

        GlobalFree(pSupportedFormats);
        m_FileTypeComboBox.SetCurSel(0);
        return TRUE;
    }
    return FALSE;
}

BOOL CMSQSCANDlg::SetDeviceNameToWindowTitle(BSTR bstrDeviceName)
{
    //
    // convert BSTR to a CString
    //

    CString DeviceName = bstrDeviceName;

    //
    // write the new title to the window
    //

    SetWindowText("Microsoft Quick Scan: [ " + DeviceName + " ]");
    return TRUE;
}

void CMSQSCANDlg::OnDeltaposEditXresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_YResolution = (pNMUpDown->iPos + pNMUpDown->iDelta);
        UpdateData(FALSE);
    }
    *pResult = 0;
}

void CMSQSCANDlg::OnDeltaposEditYresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = (pNMUpDown->iPos + pNMUpDown->iDelta);
        UpdateData(FALSE);
    }
    *pResult = 0;
}

void CMSQSCANDlg::OnSetfocusEditXres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnKillfocusEditXres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_YResolution = m_XResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnKillfocusEditYres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnSetfocusEditYres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnScanButton()
{
    memset(m_DataAcquireInfo.szFileName,0,sizeof(m_DataAcquireInfo.szFileName));

    if(m_DataToFile.GetCheck() == 1) {
        
        //
        // scan to file
        //

        m_DataAcquireInfo.bTransferToFile = TRUE;

        //
        // allow user to set the file name
        //

        CHAR szFilter[256];
        memset(szFilter,0,sizeof(szFilter));
        CFileDialog FileDialog(FALSE);

        //
        // Get filter from selected combobox (file type)
        //

        INT CurrentSelection = m_FileTypeComboBox.GetCurSel();
        m_FileTypeComboBox.GetLBText(CurrentSelection, szFilter);
        FileDialog.m_ofn.lpstrFilter = szFilter;

        //
        // Show the SaveAs dialog to user
        //

        if(FileDialog.DoModal() == IDOK) {

            //
            // save user selected filename
            //

            strcpy(m_DataAcquireInfo.szFileName,FileDialog.m_ofn.lpstrFile);
            DeleteFile(m_DataAcquireInfo.szFileName);
        } else {

            //
            // do nothing... the user decided not to enter a file name
            //

            return;
        }

    } else {

        //
        // scan to clipboard
        //

        m_DataAcquireInfo.bTransferToFile = FALSE;
        m_DataAcquireInfo.bTransferToClipboard = TRUE;
    }

    //
    // Write settings from dialog to device
    //

    if(WriteScannerSettingsToDevice()) {

        ADF_SETTINGS ADFSettings;
        if(SUCCEEDED(ReadADFSettings(&ADFSettings))){

            //
            // check file type, and warn user about BMP files.
            //

            CHAR szFormat[256];
            memset(szFormat,0,sizeof(szFormat));
        
            INT FILEFORMAT = m_FileTypeComboBox.GetCurSel();
            m_FileTypeComboBox.GetLBText(FILEFORMAT, szFormat);
            if (NULL != strstr(szFormat,"BMP")) {
                if(ADFSettings.lPages > 1) {
                    MessageBox(TEXT("BMP Files will only save the last page scanned, because there\nis no Multi-page BMP file format."),TEXT("BMP File Format Warning"),MB_ICONWARNING);
                } else if(ADFSettings.lPages == 0) {
                    MessageBox(TEXT("BMP Files will only save the last page scanned, because there\nis no Multi-page BMP file format."),TEXT("BMP File Format Warning"),MB_ICONWARNING);
                }
            }
        }

        //
        // create progress dialog object
        //

        CProgressDlg ProgDlg(this);

        //
        // set preview flag, and data acquire information
        //

        m_DataAcquireInfo.bPreview = FALSE; // this is a 'final' scan
        ProgDlg.SetAcquireData(&m_DataAcquireInfo);

        //
        // activate scan progress dialog
        //

        ProgDlg.DoModal();

        if(m_DataAcquireInfo.bTransferToClipboard ) {

            //
            // Put memory on clipboard
            //

            PutDataOnClipboard();
            m_DataAcquireInfo.bTransferToClipboard  = FALSE;
        }
    }
}

void CMSQSCANDlg::OnPreviewButton()
{

    memset(m_DataAcquireInfo.szFileName,0,sizeof(m_DataAcquireInfo.szFileName));
    m_DataAcquireInfo.bTransferToFile = FALSE;

    //
    // Write settings from dialog to device
    //

    if(WriteScannerSettingsToDevice(TRUE)) {

        //
        // create progress dialog object
        //

        CProgressDlg ProgDlg(this);

        //
        // set preview flag, and data acquire information
        //

        m_DataAcquireInfo.bPreview = TRUE; // this is a 'preview' scan
        if(m_DataAcquireInfo.hBitmapData != NULL) {
            GlobalUnlock(m_DataAcquireInfo.hBitmapData);

            //
            // free previous preview scan
            //

            GlobalFree(m_DataAcquireInfo.hBitmapData);
            m_DataAcquireInfo.hBitmapData = NULL;
        }

        ProgDlg.SetAcquireData(&m_DataAcquireInfo);

        //
        // activate scan progress dialog
        //

        ProgDlg.DoModal();
        Invalidate();
    }
}

INT CMSQSCANDlg::GetIDAndStringFromGUID(GUID guidFormat, TCHAR *pszguidString)
{
    INT index = 0;
    while(*(g_WIA_FORMAT_TABLE[index].pguidFormat) != guidFormat && index < NUM_WIA_FORMAT_INFO_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_FORMAT_INFO_ENTRIES)
        index = NUM_WIA_FORMAT_INFO_ENTRIES;

    lstrcpy(pszguidString, g_WIA_FORMAT_TABLE[index].szFormatName);

    return index;
}

GUID CMSQSCANDlg::GetGuidFromID(INT iID)
{
    return *(g_WIA_FORMAT_TABLE[iID].pguidFormat);
}

LRESULT CMSQSCANDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    if(message == WM_UPDATE_PREVIEW) {
        m_PreviewWindow.SetHBITMAP(m_DataAcquireInfo.hBitmap);
    }
    return CDialog::WindowProc(message, wParam, lParam);
}

INT CMSQSCANDlg::GetIDAndStringFromDataType(LONG lDataType, TCHAR *pszString)
{
    INT index = 0;
    while(g_WIA_DATATYPE_TABLE[index].lDataType != lDataType && index < NUM_WIA_DATATYPE_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_DATATYPE_ENTRIES)
        index = NUM_WIA_DATATYPE_ENTRIES;

    lstrcpy(pszString, g_WIA_DATATYPE_TABLE[index].szDataTypeName);

    return index;
}

LONG CMSQSCANDlg::GetDataTypeFromID(INT iID)
{
    return (g_WIA_DATATYPE_TABLE[iID].lDataType);
}

BOOL CMSQSCANDlg::WriteScannerSettingsToDevice(BOOL bPreview)
{
    HRESULT hr = S_OK;
    int SelectionIndex = 0;
    int TableIndex = 0;
    SelectionIndex = m_DataTypeComboBox.GetCurSel();
    TableIndex = (int)m_DataTypeComboBox.GetItemData(SelectionIndex);

    //
    // Set data type
    //

    hr = m_WIA.WriteLong(NULL,WIA_IPA_DATATYPE,GetDataTypeFromID(TableIndex));

    if(SUCCEEDED(hr)){
        LONG lBrightness = m_BrightnessSlider.GetPos();

        //
        // Set Brightness
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_BRIGHTNESS,lBrightness);
        if(SUCCEEDED(hr)){
            LONG lContrast = m_ContrastSlider.GetPos();

            //
            // Set Contrast
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_CONTRAST,lContrast);
            if(FAILED(hr)) {
                MessageBox("Application Failed to set Data Type");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set Brightness");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to set Data Type");
        return FALSE;
    }

    //
    // Reset selection rect, to be full bed.
    // This is good to do if you want a solid starting
    // place, for extent setting
    //

    if(!ResetWindowExtents()) {
        return FALSE;
    }

    if(bPreview) {

        //
        // set to preview  X resolution
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XRES,PREVIEW_RES);
        if(SUCCEEDED(hr)) {

            //
            // set to preview  Y resolution
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_YRES,PREVIEW_RES);
            if(SUCCEEDED(hr)) {

                //
                // set to memory bitmap for preview display
                //

                hr = m_WIA.WriteGuid(NULL,WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
                if(FAILED(hr)) {
                    MessageBox("Application Failed to set format to Memory BMP");
                    return FALSE;
                }
            } else {
                MessageBox("Application Failed to set Y Resolution (Preview)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set X Resolution (Preview)");
            return FALSE;
        }

    } else {

        //
        // Are we scanning to the clipboard??
        //

        if(m_DataAcquireInfo.bTransferToClipboard ) {

            //
            // Do only Banded transfer, and WiaImgFmt_MEMORYBMP for clipboard
            // transfers. (This application can only do this function using
            // those specific settings).
            // Note: Other applications are not restricted by this. This is
            //       is a design issue with this sample only!!!
            //

            //
            // set to memory bitmap for clipboard scanning
            //

            hr = m_WIA.WriteGuid(NULL,WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
            if(FAILED(hr)) {
                MessageBox("Memory BMP could not be set to Device");
                return FALSE;
            }
        }

        //
        // write dialog setting for resolution
        //

        UpdateData(TRUE);

        //
        // set X resolution
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XRES,m_XResolution);
        if(SUCCEEDED(hr)) {

            //
            // set Y resolution
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_YRES,m_YResolution);
            if(FAILED(hr)) {
                MessageBox("Application Failed to set Y Resolution (Preview)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set X Resolution (Preview)");
            return FALSE;
        }

        //
        // write extent values
        //

        CRect SelectionRect;
        m_PreviewWindow.GetSelectionRect(SelectionRect);

        CRect PreviewRect;
        m_PreviewWindow.GetWindowRect(PreviewRect);

        LONG lXPos = 0;
        LONG lYPos = 0;
        LONG lMaxXExtent = 0;
        LONG lMaxYExtent = 0;
        LONG lXExtent = 0;
        LONG lYExtent = 0;

        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XEXTENT,WIA_RANGE_MAX,&lMaxXExtent);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_YEXTENT,WIA_RANGE_MAX,&lMaxYExtent);
            if(FAILED(hr)) {
                MessageBox("Application failed to read y extent (Max value)");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to read x extent (Max value)");
            return FALSE;
        }

        FLOAT fxRatio = ((FLOAT)lMaxXExtent/(FLOAT)PreviewRect.Width());
        FLOAT fyRatio = ((FLOAT)lMaxYExtent/(FLOAT)PreviewRect.Height());

        lXPos = (LONG)(SelectionRect.left * fxRatio);
        lYPos = (LONG)(SelectionRect.top * fyRatio);

        lXExtent = (LONG)(SelectionRect.Width() * fxRatio);
        lYExtent = (LONG)(SelectionRect.Height() * fyRatio);

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XPOS,lXPos);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.WriteLong(NULL,WIA_IPS_YPOS,lYPos);
            if(SUCCEEDED(hr)) {
                hr = m_WIA.WriteLong(NULL,WIA_IPS_XEXTENT,lXExtent);
                if(SUCCEEDED(hr)) {
                    hr = m_WIA.WriteLong(NULL,WIA_IPS_YEXTENT,lYExtent);
                    if(FAILED(hr)){
                        MessageBox("Application failed to set Y Extent");
                        return FALSE;
                    }
                } else {
                    MessageBox("Application failed to set X Extent");
                    return FALSE;
                }
            }else {
                MessageBox("Application failed to set Y Position");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to set X Position");
            return FALSE;
        }
    }
    return TRUE;
}

void CMSQSCANDlg::OnFileClose()
{
    CDialog::OnOK();
}

void CMSQSCANDlg::OnFileSelectDevice()
{
    CRect DialogClientRect;

    GetClientRect(DialogClientRect);

    //
    // use scan window place holder, as template for placing the scan
    // preview window
    //

    CRect WindowRect;
    m_PreviewRect.GetWindowRect(WindowRect);
    ScreenToClient(WindowRect);

    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,(void**)&g_pGIT);

    if(SUCCEEDED(hr)) {

        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
            IID_IWiaDevMgr,(void**)&m_pIWiaDevMgr);

        if (SUCCEEDED(hr)) {
           
            //
            // An example on how to register for Device Connection Events
            //

            m_pConnectEventCB = new CEventCallback;
            if (m_pConnectEventCB) {

                IWiaEventCallback* pIWiaEventCallback = NULL;
                IUnknown*       pIUnkRelease;

                // register connected event
                m_pConnectEventCB->Initialize(ID_WIAEVENT_CONNECT);
                m_pConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);

                GUID guidConnect = WIA_EVENT_DEVICE_CONNECTED;
                hr = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                                   NULL,
                                                                   &guidConnect,
                                                                   pIWiaEventCallback,
                                                                   &pIUnkRelease);

                m_pConnectEventCB->m_pIUnkRelease = pIUnkRelease;                
                               
                //
                // An Example on how to register for events with this application 
                //

                WCHAR szMyApplicationLaunchPath[MAX_PATH];
                memset(szMyApplicationLaunchPath,0,sizeof(szMyApplicationLaunchPath));
                GetModuleFileNameW(NULL,szMyApplicationLaunchPath,sizeof(szMyApplicationLaunchPath));
                BSTR bstrMyApplicationLaunchPath = SysAllocString(szMyApplicationLaunchPath);
                
                WCHAR szMyApplicationName[MAX_PATH];
                memset(szMyApplicationName,0,sizeof(szMyApplicationName));                                                                    
                HINSTANCE hInst = AfxGetInstanceHandle();
                if(hInst){
                    LoadStringW(hInst, IDS_MYAPPLICATION_NAME, szMyApplicationName, (sizeof(szMyApplicationName)/sizeof(WCHAR)));
                    
                    BSTR bstrMyApplicationName = SysAllocString(szMyApplicationName);
                    
                    GUID guidScanButtonEvent = WIA_EVENT_SCAN_IMAGE;
                    hr = m_pIWiaDevMgr->RegisterEventCallbackProgram(
                                            WIA_REGISTER_EVENT_CALLBACK,
                                            NULL,
                                            &guidScanButtonEvent,
                                            bstrMyApplicationLaunchPath,
                                            bstrMyApplicationName,
                                            bstrMyApplicationName,
                                            bstrMyApplicationLaunchPath);
                    if(FAILED(hr)){
                        MessageBox("Could not Register Application for Events");
                        hr = S_OK; // continue and try to use device
                    }

                    SysFreeString(bstrMyApplicationName);
                    bstrMyApplicationName = NULL;

                }
                SysFreeString(bstrMyApplicationLaunchPath);
                bstrMyApplicationLaunchPath = NULL;                

            }            
            if (SUCCEEDED(hr)) {

                //
                // select your scanning device here
                //

                IWiaItem *pIWiaRootItem = NULL;

                hr = m_pIWiaDevMgr->SelectDeviceDlg(m_hWnd,StiDeviceTypeScanner,0,NULL,&pIWiaRootItem);
                if (hr == S_OK) {

                    //
                    // Write interface to Global Interface Table
                    //

                    hr = WriteInterfaceToGlobalInterfaceTable(&m_DataAcquireInfo.dwCookie,
                                                              pIWiaRootItem);
                    if (SUCCEEDED(hr)) {

                        //
                        // save root item (device) created
                        //

                        m_WIA.SetRootItem(pIWiaRootItem);

                        //
                        // query selected device for it's name
                        //

                        BSTR bstrDeviceName;
                        hr = m_WIA.ReadStr(pIWiaRootItem,WIA_DIP_DEV_NAME,&bstrDeviceName);
                        if (SUCCEEDED(hr)) {
                            SetDeviceNameToWindowTitle(bstrDeviceName);
                            SysFreeString(bstrDeviceName);
                        }

                        //
                        // query selected device for scanner bed size, so we can create
                        // a scanner preview window
                        //

                        LONG MaxScanBedWidth  = 0;
                        LONG MaxScanBedHeight = 0;
                        FLOAT fRatio     = 0;
                        FLOAT fXFactor   = 0.0f;
                        FLOAT fYFactor   = 0.0f;
                        FLOAT fTheFactor = 0.0f;

                        m_WIA.ReadLong(pIWiaRootItem,WIA_DPS_HORIZONTAL_BED_SIZE,&MaxScanBedWidth);
                        m_WIA.ReadLong(pIWiaRootItem,WIA_DPS_VERTICAL_BED_SIZE,&MaxScanBedHeight);

                        fRatio = (FLOAT)((FLOAT)MaxScanBedHeight / (FLOAT)MaxScanBedWidth);

                        fXFactor = (FLOAT)WindowRect.Width()/(FLOAT)MaxScanBedWidth;
                        fYFactor = (FLOAT)WindowRect.Height()/(FLOAT)MaxScanBedHeight;

                        if (fXFactor > fYFactor)
                            fTheFactor = fYFactor;
                        else
                            fTheFactor = fXFactor;

                        //
                        // adjust the pixel returned size so it will fit on the dialog correctly
                        //

                        WindowRect.right = (LONG)(fTheFactor * MaxScanBedWidth) + WindowRect.left;
                        WindowRect.bottom = (LONG)(fTheFactor * MaxScanBedHeight) + WindowRect.top;
                        //WindowRect.right = (MaxScanBedWidth/PIXELS_PER_INCH_FACTOR);
                        //WindowRect.bottom = (LONG)(WindowRect.right * fRatio);

                        //
                        // check scanner bed size, against actual window size, and adjust
                        //

                        if (DialogClientRect.bottom < WindowRect.bottom) {
                            CRect DialogRect;
                            GetWindowRect(DialogRect);
                            DialogRect.InflateRect(0,0,0,(WindowRect.bottom - DialogClientRect.bottom) + 10);
                            MoveWindow(DialogRect);
                        }
                    } else {
                        MessageBox("Failed to Set IWiaRootItem Interface in to Global Interface Table");
                    }

                } else {
                    MessageBox("No Scanner was selected.");
                    return;
                }
            } else {
                MessageBox("Could not Register for Device Disconnect Events");
            }

            m_PreviewWindow.DestroyWindow();

            //
            // create the preview window
            //

            if(!m_PreviewWindow.Create(NULL,
                                   TEXT("Preview Window"),
                                   WS_CHILD|WS_VISIBLE,
                                   WindowRect,
                                   this,
                                   PREVIEW_WND_ID)){
                MessageBox("Failed to create preview window");
                return;
            }

            m_DataAcquireInfo.hWnd = m_PreviewWindow.m_hWnd;

            //
            // intialize selection rect to entire bed for preview
            //

            m_PreviewWindow.SetPreviewRect(WindowRect);

            //
            // InitDialogSettings
            //

            InitDialogSettings();

        } else {
            MessageBox("CoCreateInstance for WIA Device Manager failed");
            return;
        }
    } else {
        MessageBox("CoCreateInstance for Global Interface Table failed");
        return;
    }
}

BOOL CMSQSCANDlg::PutDataOnClipboard()
{
    BOOL bSuccess = FALSE;
    if(OpenClipboard()){
        if(EmptyClipboard()){
            BYTE* pbBuf = (BYTE*)GlobalLock(m_DataAcquireInfo.hClipboardData);
            VerticalFlip(pbBuf);
            GlobalUnlock(m_DataAcquireInfo.hClipboardData);
            if(SetClipboardData(CF_DIB, m_DataAcquireInfo.hClipboardData) == NULL) {
                MessageBox("SetClipboardData failed");
            } else {

                //
                // We succeeded to give memory handle to clipboard
                //

                bSuccess = TRUE;
            }
        } else {
            MessageBox("EmptyClipboard failed");
        }
        if (!CloseClipboard()) {
            MessageBox("CloseClipboard failed");
        }
    } else {
        MessageBox("OpenClipboard failed");
    }

    if(!bSuccess) {

        //
        // Free the memory ourselves, because the Clipboard failed to accept it.
        //

        GlobalFree(m_DataAcquireInfo.hClipboardData);
    }

    //
    // Set handle to NULL, to mark it fresh when scanning more data.
    // This handle is now owned by the Clipbpard...so freeing it would be a bad idea.
    //

    m_DataAcquireInfo.hClipboardData = NULL;
    return bSuccess;
}

VOID CMSQSCANDlg::VerticalFlip(BYTE *pBuf)
{
    HRESULT             hr = S_OK;
    LONG                lHeight;
    LONG                lWidth;
    BITMAPINFOHEADER    *pbmih;
    PBYTE               pTop    = NULL;
    PBYTE               pBottom = NULL;

    pbmih = (BITMAPINFOHEADER*) pBuf;

    if (pbmih->biHeight > 0) {
        return;
    }

    pTop = pBuf + pbmih->biSize + ((pbmih->biClrUsed) * sizeof(RGBQUAD));
    lWidth = ((pbmih->biWidth * pbmih->biBitCount + 31) / 32) * 4;
    pbmih->biHeight = abs(pbmih->biHeight);
    lHeight = pbmih->biHeight;

    PBYTE pTempBuffer = (PBYTE)LocalAlloc(LPTR, lWidth);

    if (pTempBuffer) {
        LONG  index = 0;
        pBottom = pTop + (lHeight-1) * lWidth;
        for (index = 0;index < (lHeight/2);index++) {

            memcpy(pTempBuffer, pTop, lWidth);
            memcpy(pTop, pBottom, lWidth);
            memcpy(pBottom,pTempBuffer, lWidth);

            pTop    += lWidth;
            pBottom -= lWidth;
        }
        LocalFree(pTempBuffer);
    }
}

BOOL CMSQSCANDlg::ResetWindowExtents()
{

    LONG lMaxXExtent = 0;
    LONG lMaxYExtent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.WriteLong(NULL,WIA_IPS_XPOS,0);
    if(SUCCEEDED(hr)) {
        hr = m_WIA.WriteLong(NULL,WIA_IPS_YPOS,0);
        if(SUCCEEDED(hr)){
            hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XEXTENT,WIA_RANGE_MAX,&lMaxXExtent);
            if(SUCCEEDED(hr)){
                hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_YEXTENT,WIA_RANGE_MAX,&lMaxYExtent);
                if(SUCCEEDED(hr)){
                    hr = m_WIA.WriteLong(NULL,WIA_IPS_XEXTENT,lMaxXExtent);
                    if(SUCCEEDED(hr)){
                        hr = m_WIA.WriteLong(NULL,WIA_IPS_YEXTENT,lMaxYExtent);
                        if(FAILED(hr)) {
                            MessageBox("Application failed to write y extent");
                            return FALSE;
                        }
                    } else {
                        MessageBox("Application failed to write x extent");
                        return FALSE;
                    }
                } else {
                    MessageBox("Application failed to read y extent");
                    return FALSE;
                }
            } else {
                MessageBox("Application failed to read x extent");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to write y pos");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to write x pos");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::ReadADFSettings(ADF_SETTINGS *pADFSettings)
{

//#define USE_FAKE_ADFCAPS
#ifdef USE_FAKE_ADFCAPS
    pADFSettings->lDocumentHandlingCapabilites = FEED|       // Feeder
                                                 FLAT|       // Flatbed
                                                 DUP;        // Duplex
    pADFSettings->lDocumentHandlingCapacity    = 20;         // 20 pages max
    pADFSettings->lDocumentHandlingSelect      = FLATBED|    // Feeder Mode is ON
                                                 FRONT_FIRST|// scan front page first
                                                 FRONT_ONLY; // scan front only

    pADFSettings->lDocumentHandlingStatus      = FLAT_READY; // Feeder is ready
    pADFSettings->lPages = 1;                                // Initialize pages to 1
    return TRUE;

#endif

    HRESULT hr = S_OK;
    if(pADFSettings!= NULL) {

        //
        // Read Settings From Root Item
        //

        IWiaItem *pRootItem = NULL;
        pRootItem = m_WIA.GetRootItem();

        if(pRootItem != NULL) {
            hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_SELECT,&pADFSettings->lDocumentHandlingSelect);
            if(SUCCEEDED(hr)){
                hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,&pADFSettings->lDocumentHandlingCapabilites);
                if(SUCCEEDED(hr)){
                    hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_STATUS,&pADFSettings->lDocumentHandlingStatus);
                    if(SUCCEEDED(hr)){
                        hr = m_WIA.ReadLong(pRootItem,WIA_DPS_PAGES,&pADFSettings->lPages);
                        if (SUCCEEDED(hr)) {
                            hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_CAPACITY,&pADFSettings->lDocumentHandlingCapacity);
                            if (FAILED(hr)) {
                                MessageBox("Application failed to read the Document Handling Capacity");
                                return FALSE;
                            }
                        } else {
                            MessageBox("Application failed to read the Pages Property");
                            return FALSE;
                        }
                    }  else {
                        MessageBox("Application failed to read the Document Handling Status");
                        return FALSE;
                    }
                }  else {
                    MessageBox("Application failed to read the Document Handling Capabilites");
                    return FALSE;
                }
            } else {
                MessageBox("Application failed to read the Document Handling Select Property");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to find the Root Item.");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to read ADF settings, because the pointer to the Settings structure is NULL");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::WriteADFSettings(ADF_SETTINGS *pADFSettings)
{
    HRESULT hr = S_OK;
    if(pADFSettings!= NULL) {

        //
        // Write Settings to the Root Item
        //

        IWiaItem *pRootItem = NULL;
        pRootItem = m_WIA.GetRootItem();

        if(pRootItem != NULL) {
            hr = m_WIA.WriteLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_SELECT,pADFSettings->lDocumentHandlingSelect);
            if(FAILED(hr)){
                MessageBox("Application failed to write ADF settings, because the Document Handling Select value failed to set");
                return FALSE;
            }
            hr = m_WIA.WriteLong(pRootItem,WIA_DPS_PAGES,pADFSettings->lPages);
            if(FAILED(hr)){
                MessageBox("Application failed to write ADF settings, because the Pages property failed to set");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to find the Root Item.");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to write ADF settings, because the pointer to the Settings structure is NULL");
        return FALSE;
    }
    return TRUE;
}

void CMSQSCANDlg::OnAdfSettings()
{
    if(ReadADFSettings(&m_ADFSettings)) {

        //
        // create ADF dialog object
        //

        CADFDlg ADFDlg(&m_ADFSettings);

        //
        // display setting dialog
        //

        if(ADFDlg.DoModal() == IDOK) {

            //
            // write ADF settings back to the scanner if the user pushes the "OK" button
            //

            WriteADFSettings(&m_ADFSettings);
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CEventCallback message handlers

HRESULT _stdcall CEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback)
        *ppv = (IWiaEventCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CEventCallback::AddRef()
{
    InterlockedIncrement((long*)&m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEventCallback::Release()
{
	ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
	{
        delete this;
        return 0;
    }
    return ulRefCount;
}

CEventCallback::CEventCallback()
{
    m_cRef = 0;
    m_pIUnkRelease = NULL;
}

CEventCallback::~CEventCallback()
{
    Release();
}

HRESULT _stdcall CEventCallback::Initialize(int EventID)
{
	if((EventID > 1)||(EventID < 0))
		return S_FALSE;

	m_EventID = EventID;
	return S_OK;
}

HRESULT _stdcall CEventCallback::ImageEventCallback(
    const GUID                      *pEventGUID,
    BSTR                            bstrEventDescription,
    BSTR                            bstrDeviceID,
    BSTR                            bstrDeviceDescription,
    DWORD                           dwDeviceType,
    BSTR                            bstrFullItemName,
    ULONG                           *plEventType,
    ULONG                           ulReserved)
{
	switch(m_EventID)
	{
	case ID_WIAEVENT_CONNECT:
		MessageBox(NULL,"a connect event has been trapped...","Event Notice",MB_OK);
		break;
	case ID_WIAEVENT_DISCONNECT:
		MessageBox(NULL,"a disconnect event has been trapped...","Event Notice",MB_OK);
		break;
	default:
		AfxMessageBox("Ah HA!..an event just happened!!!!\n and...I have no clue what is was..");
		break;
	}
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\progressdlg.h ===
#ifndef _PROGRESSDLG_H
#define _PROGRESSDLG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

//
// User defined windows messages
//

#define WM_STEP_PROGRESS        WM_USER + 500
#define WM_CANCEL_ACQUIRE       WM_USER + 501
#define WM_UPDATE_PROGRESS_TEXT WM_USER + 502

class CProgressDlg : public CDialog
{
// Construction
public:
    CProgressDlg(CWnd* pParent = NULL);   // standard constructor
    void SetAcquireData(DATA_ACQUIRE_INFO* pDataAcquireInfo);
    DATA_ACQUIRE_INFO* m_pDataAcquireInfo;
// Dialog Data
    //{{AFX_DATA(CProgressDlg)
    enum { IDD = IDD_PROGRESS_DIALOG };
    CButton       m_CancelButton;
    CProgressCtrl m_ProgressCtrl;
    CString       m_ProgressText;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    CWinThread* m_pDataAcquireThread;

protected:

    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    afx_msg void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//
// Thread information
//

UINT WINAPIV DataAcquireThreadProc(LPVOID pParam);

BOOL ProgressFunction(LPTSTR lpszText, LONG lPercentComplete);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\progressdlg.cpp ===
// ProgressDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msqscan.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// globals
//

extern IGlobalInterfaceTable * g_pGIT;
HWND g_hWnd = NULL;
BOOL g_bCancel = FALSE; // use global for now, It would be better to use an "event"
BOOL g_bPaintPreview  = TRUE;

/////////////////////////////////////////////////////////////////////////////
// Thread Information

UINT WINAPIV DataAcquireThreadProc(LPVOID pParam)
{
    HRESULT hr = S_OK;

    //
    // Initialize COM, for this thread
    //

    hr = CoInitialize(NULL);

    if(SUCCEEDED(hr)) {

        //
        // set global cancel flag
        //

        g_bCancel = FALSE;

        //
        // prepare, and use the DATA_ACQUIRE_INFO struct
        //

        DATA_ACQUIRE_INFO *pDataAcquireInfo = (DATA_ACQUIRE_INFO*)pParam;
        pDataAcquireInfo->pProgressFunc = &ProgressFunction;
        g_bPaintPreview = pDataAcquireInfo->bPreview;

        IWiaItem *pIWiaRootItem = NULL;

        hr = ReadInterfaceFromGlobalInterfaceTable(pDataAcquireInfo->dwCookie, &pIWiaRootItem);
        if(SUCCEEDED(hr)) {

            //
            // create a new WIA object for data transfer
            //

            CWIA MyWIA;

            //
            // set the Root Item, used for current settings
            //

            MyWIA.SetRootItem(pIWiaRootItem);

            //
            // Initiate WIA Transfer
            //

            if(pDataAcquireInfo->bTransferToFile) {
                hr = MyWIA.DoFileTransfer(pDataAcquireInfo);
                if(SUCCEEDED(hr)) {
                    OutputDebugString(TEXT("WIA File Transfer is complete...\n"));
                } else if(hr == WIA_ERROR_PAPER_EMPTY){
                    MessageBox(NULL,TEXT("Document Feeder is out of Paper"),TEXT("ADF Status Message"),MB_ICONERROR);
                }

            } else {
                hr = MyWIA.DoBandedTransfer(pDataAcquireInfo);
                if(SUCCEEDED(hr)) {
                    OutputDebugString(TEXT("WIA Banded Transfer is complete...\n"));
                }
            }

            //
            // Do Window messaging, while thread processes
            //

            while (!MyWIA.IsAcquireComplete()) {
                MSG message;
                if(::PeekMessage(&message, NULL, 0, 0, PM_NOREMOVE)) {
                    ::TranslateMessage(&message);
                    ::DispatchMessage(&message);
                }
            }
        }

        //
        // Uninitialize COM, for this thread
        //

        CoUninitialize();
    }

    //
    // Post the quit message, to close the progress dialog
    //

    ::PostMessage(g_hWnd, WM_CANCEL_ACQUIRE, 0, 0);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Progress Callback function

BOOL ProgressFunction(LPTSTR lpszText, LONG lPercentComplete)
{
    ::PostMessage(g_hWnd, WM_STEP_PROGRESS, 0, lPercentComplete);
    ::PostMessage(g_hWnd, WM_UPDATE_PROGRESS_TEXT, 0, (LPARAM)lpszText);

    if(g_bPaintPreview) {

        //
        // make parent update it's preview
        //

        HWND hParentWnd = NULL;
        hParentWnd = GetParent(g_hWnd);
        if(hParentWnd != NULL)
            ::PostMessage(hParentWnd,WM_UPDATE_PREVIEW,0,0);
    }

    return g_bCancel;
}

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CProgressDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CProgressDlg)
    m_ProgressText = _T("");
    m_pDataAcquireThread = NULL;
    //}}AFX_DATA_INIT
}

void CProgressDlg::SetAcquireData(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    m_pDataAcquireInfo = pDataAcquireInfo;
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProgressDlg)
    DDX_Control(pDX, IDC_CANCEL, m_CancelButton);
    DDX_Control(pDX, IDC_PROGRESS_CONTROL, m_ProgressCtrl);
    DDX_Text(pDX, IDC_PROGRESS_TEXT, m_ProgressText);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
    ON_BN_CLICKED(IDC_CANCEL, OnCancel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

void CProgressDlg::OnCancel()
{

    //
    // suspend the data acquire thread
    //

    m_pDataAcquireThread->SuspendThread();

    //
    // set the global cancel flag
    //

    g_bCancel = TRUE;

    //
    // resume the data acquire thread
    //

    m_pDataAcquireThread->ResumeThread();

    //
    // post a nice, wait message while WIA catches up with the
    // cancel..ie. S_FALSE sent through the callback Interface
    //

    m_ProgressText = TEXT("Please Wait... Your Acquire is being canceled.");
    UpdateData(FALSE);

    //
    // disable the 'cancel' button, to show the user that somthing did happen,
    // when they pushed 'cancel'.
    //

    m_CancelButton.EnableWindow(FALSE);
}

BOOL CProgressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // set the progress range, 0-100% complete
    //

    m_ProgressCtrl.SetRange(0,100);
    m_ProgressCtrl.SetPos(0);

    //
    // save window handle, for messages
    //

    g_hWnd = m_hWnd;

    //
    // start data acquire thread
    //

    m_pDataAcquireThread = AfxBeginThread(DataAcquireThreadProc, m_pDataAcquireInfo, THREAD_PRIORITY_NORMAL);

    //
    // suspend thread until dialog is ready to acquire
    //

    m_pDataAcquireThread->SuspendThread();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CProgressDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    //
    // Trap progress control message, sent from data acquire thread
    //

    switch(message) {
    case WM_STEP_PROGRESS:

        //
        // step progress control
        //

        m_ProgressCtrl.SetPos((int)lParam);
        break;
    case WM_ACTIVATE:

        //
        // dialog is ready, so resume thread for acquiring data
        //

        m_pDataAcquireThread->ResumeThread();
        break;
    case WM_CANCEL_ACQUIRE:

        //
        // cancel/close dialog
        //

        CDialog::OnOK();
        break;
    default:
        break;
    }

    //
    // handle any special cases
    //

    //
    // if the user has canceled the acquire, do not process another
    // progress text message, because we already have updated them
    // with a 'friendly' wait message.
    //

    if(!g_bCancel) {
        if(message == WM_UPDATE_PROGRESS_TEXT) {
            m_ProgressText = (LPTSTR)lParam;
            UpdateData(FALSE);
        }
    }
    return CDialog::WindowProc(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSQSCAN.rc
//
#define IDD_MSQSCAN_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDB_MSLOGO_BITMAP               130
#define IDD_PROGRESS_DIALOG             131
#define IDR_MSQSCAN_MENU                132
#define IDD_ADF_SETTING_DIALOG          133
#define IDC_PREVIEW_WINDOW              1000
#define PREVIEW_WND_ID                  1001
#define IDC_BRIGHTNESS_SLIDER           1002
#define IDC_CONTRAST_SLIDER             1003
#define IDC_DATATYPE_COMBO              1005
#define IDC_IMAGE_FILETYPE_COMBO        1006
#define IDC_MIN_CONTRAST                1007
#define IDC_MAX_CONTRAST                1008
#define IDC_MIN_BRIGHTNESS              1009
#define IDC_MAX_BRIGHTNESS              1010
#define IDC_PREVIEW_BUTTON              1011
#define IDC_SCAN_BUTTON                 1012
#define IDC_EDIT_XRES                   1015
#define IDC_EDIT_YRES                   1016
#define IDC_EDIT_XRES_SPIN_BUDDY        1017
#define IDC_EDIT_YRES_SPIN_BUDDY        1018
#define IDC_CHANGE_BOTH_CHECKBOX        1019
#define IDC_DATA_TO_FILE                1022
#define IDC_DATA_TO_CLIPBOARD           1023
#define IDC_MSLOGO                      1024
#define IDC_PROGRESS_CONTROL            1025
#define IDC_PROGRESS_TEXT               1026
#define IDC_CANCEL                      1027
#define IDC_ADF_SETTINGS                1029
#define IDC_FEEDER_STATUS_TEXT          1033
#define IDC_ADF_MODE_COMBOBOX           1034
#define IDC_SCAN_ALL_PAGES_RADIOBUTTON  1035
#define IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON 1036
#define IDC_NUMBER_OF_PAGES_EDITBOX     1037
#define IDC_PAGE_ORDER_COMBOBOX         1039
#define IDS_MYAPPLICATION_NAME          1040
#define ID_FILE_SELECT_DEVICE           32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=msqscan
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\msqscan.cpp          \
        ..\msqscandlg.cpp       \
        ..\preview.cpp          \
        ..\uitables.cpp         \
        ..\progressdlg.cpp      \
        ..\cwia.cpp             \
        ..\adfdlg.cpp           \
        ..\msqscan.rc


# Add interlac.cpp if the PNG support is ever fixed

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "cwia.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  MSQSCAN.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\uitables.h ===
// UITABLES.H

#ifndef _UITABLES_H
#define _UITABLES_H

#include "wia.h"
#include "datatypes.h"
#include "sti.h"
#include "uitables.h"

//
// TABLE entry counters
//

#define NUM_WIA_FORMAT_INFO_ENTRIES         12
#define NUM_WIA_DATATYPE_ENTRIES             7
#define NUM_WIA_DOC_HANDLING_CAPS_ENTRIES   10
#define NUM_WIA_DOC_HANDLING_STATUS_ENTRIES  7
#define NUM_WIA_DOC_HANDLING_SELECT_ENTRIES 11

#define WIA_DOC_HANDLING_SELECT_PAGEORDER_INDEX 3

//
// TABLE entry types
//

typedef struct _WIA_FORMAT_TABLE_ENTRY {
	const GUID *pguidFormat;
	TCHAR szFormatName[MAX_PATH];
}WIA_FORMAT_TABLE_ENTRY;

typedef struct _WIA_DATATYPE_TABLE_ENTRY {
	LONG lDataType;
	TCHAR szDataTypeName[MAX_PATH];
}WIA_DATATYPE_TABLE_ENTRY;

typedef struct _WIA_DOCUMENT_HANDLING_TABLE_ENTRY {
	LONG lFlagValue;
	TCHAR szFlagName[MAX_PATH];
}WIA_DOCUMENT_HANDLING_TABLE_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\uitables.cpp ===
// UITABLES.CPP

#include "stdafx.h"
#include "uitables.h"

//
// WIA Format Table, for UI display (english only, these should be in a resource file)
//

WIA_FORMAT_TABLE_ENTRY g_WIA_FORMAT_TABLE[NUM_WIA_FORMAT_INFO_ENTRIES] = {
    &WiaImgFmt_UNDEFINED,TEXT("Undefined File")            ,
    &WiaImgFmt_MEMORYBMP,TEXT("Memory Bitmap File (*.BMP)"),
    &WiaImgFmt_BMP,      TEXT("Bitmap File (*.BMP)")       ,
    &WiaImgFmt_EMF,      TEXT("EMF File (*.EMF)")          ,
    &WiaImgFmt_WMF,      TEXT("WMF File (*.WMF)")          ,
    &WiaImgFmt_JPEG,     TEXT("JPEG File (*.JPG)")         ,
    &WiaImgFmt_GIF,      TEXT("GIF File (*.GIF)")          ,
    &WiaImgFmt_TIFF,     TEXT("Tiff File (*.TIF)")         ,
    &WiaImgFmt_EXIF,     TEXT("Exif File (*.XIF)")         ,
    &WiaImgFmt_PHOTOCD,  TEXT("Photo CD File (*.PCD)")     ,
    &WiaImgFmt_FLASHPIX, TEXT("Flash Pix File (*.FPX)")    ,
    &GUID_NULL,       TEXT("Unknown Format GUID (*.???)"),
};

//
// WIA Data Type Table, for UI display (english only, these should be in a resource file)
//

WIA_DATATYPE_TABLE_ENTRY g_WIA_DATATYPE_TABLE[NUM_WIA_DATATYPE_ENTRIES] = {
    WIA_DATA_THRESHOLD,      TEXT("1 bit black and white")     ,
    WIA_DATA_DITHER,         TEXT("Black and white dither")    ,
    WIA_DATA_GRAYSCALE,      TEXT("8 bit grayscale")           ,
    WIA_DATA_COLOR,          TEXT("24 bit color")              ,
    WIA_DATA_COLOR_THRESHOLD,TEXT("8 bit paletted color ")     ,
    WIA_DATA_COLOR_DITHER,   TEXT("Color dither")              ,
    9999,                    TEXT("Unknown Data Type")         ,
};

//
// WIA Document Handling Tables, for UI display (english only, these should be in a resource file)
//

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[NUM_WIA_DOC_HANDLING_CAPS_ENTRIES] = {
    FEED,             TEXT("ADF capable"),
    FLAT,             TEXT("Flatbed capable"),
    DUP,              TEXT("Duplex capable"),
    DETECT_FLAT,      TEXT("Flatbed detection capable"),
    DETECT_SCAN,      TEXT("Scan detection capable"),
    DETECT_FEED,      TEXT("ADF detection capable"),
    DETECT_DUP,       TEXT("Duplex detection capable"),
    DETECT_FEED_AVAIL,TEXT("Scanner can automatically detect if an ADF is installed"),
    DETECT_DUP_AVAIL, TEXT("Scanner can automatically detect if Duplex unit is installed"),
    9999,             TEXT("Unknown capability flag value"),
};

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[NUM_WIA_DOC_HANDLING_STATUS_ENTRIES] = {
    FEED_READY,   TEXT("Feeder Ready"),
    FLAT_READY,   TEXT("Flatbed Ready"),
    DUP_READY,    TEXT("Duplex Ready"),
    FLAT_COVER_UP,TEXT("Flatbed cover is up"),
    PATH_COVER_UP,TEXT("Pathway is covered up"),
    PAPER_JAM,    TEXT("Paper Jam detected"),
    9999,         TEXT("Unknown status flag value"),
};

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[NUM_WIA_DOC_HANDLING_SELECT_ENTRIES] = {
    FEEDER,      TEXT("Feeder Mode"),
    FLATBED,     TEXT("Flatbed Mode"),
    DUPLEX,      TEXT("Duplex Mode"),
    FRONT_FIRST, TEXT("Scan front page first"),
    BACK_FIRST,  TEXT("Scan back page first"),
    FRONT_ONLY,  TEXT("Scan front page only"),
    BACK_ONLY,   TEXT("Scan back page only"),
    NEXT_PAGE,   TEXT("Scan next page"),
    PREFEED,     TEXT("Prefeed the document"),
    AUTO_ADVANCE,TEXT("Auto Advance the feeder"),
    9999,        TEXT("Unknown select flag value"),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\remote\connect\connect.cpp ===
#include <tchar.h>
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <stdlib.h>
#include <stdarg.h>
#include <wia.h>
#include <stdio.h>

#ifdef _DEBUG
#define TRACE(x) Trace x
#else
#define TRACE(x) Trace x
#endif

#define RELEASE(x)\
                  do {\
                  if((x)) {\
                  (x)->Release(); \
                  (x) = NULL;\
                  }\
                  }while(0)

#define REQUIRE(x)\
                  do {\
                  if(!(x)) {\
                  TRACE((_T("%hs(%d): %hs failed with LastError() = %d\r\n"),\
                  __FILE__, __LINE__, #x, GetLastError()));\
                  goto Cleanup;\
                  }\
                  } while(0)


#define REQUIRE_S_OK(x)\
                       do {\
                       hr = (x);\
                       \
                       if(hr != S_OK) {\
                       TRACE((_T("%hs(%d): %hs failed with hr = %x\r\n"),\
                       __FILE__, __LINE__, #x, hr));\
                       goto Cleanup;\
                       }\
                       } while(0)

#define REQUIRE_SUCCESS(x)\
                          do {\
                          DWORD dwResult = (x);\
                          \
                          if(dwResult != ERROR_SUCCESS) {\
                          TRACE((_T("%hs(%d): %hs failed with status = %x\r\n"),\
                          __FILE__, __LINE__, #x, dwResult));\
                          goto Cleanup;\
                          }\
                          } while(0)



void Trace(LPCTSTR fmt, ...)
{
    TCHAR buffer[2048];
    va_list marker;

    va_start(marker, fmt);
    wvsprintf(buffer, fmt, marker);

    printf("\nError: %ws", buffer);
}

struct regVals_t {
    ULONG propId;
    LPWSTR propName;
} regVals[] = {
    {WIA_DIP_DEV_ID, WIA_DIP_DEV_ID_STR},
    {WIA_DIP_VEND_DESC, WIA_DIP_VEND_DESC_STR},
    {WIA_DIP_DEV_DESC, WIA_DIP_DEV_DESC_STR},
    {WIA_DIP_DEV_TYPE, WIA_DIP_DEV_TYPE_STR},
    {WIA_DIP_PORT_NAME, WIA_DIP_PORT_NAME_STR},
    {WIA_DIP_DEV_NAME, WIA_DIP_DEV_NAME_STR},
    {WIA_DIP_SERVER_NAME, WIA_DIP_SERVER_NAME_STR},
    {WIA_DIP_REMOTE_DEV_ID, WIA_DIP_REMOTE_DEV_ID_STR},
    {WIA_DIP_UI_CLSID, WIA_DIP_UI_CLSID_STR}
};
#define NREGVALS (sizeof(regVals) / sizeof(regVals[0]))

HRESULT RegisterRemoteScanners(LPCWSTR servername) 
{
    HRESULT hr;
    IWiaDevMgr *pDevMgr = NULL;
    IEnumWIA_DEV_INFO *pEnumInfo = NULL;
    IWiaPropertyStorage *pWiaPropStg = NULL;
    COSERVERINFO csi;
    HKEY hDevList = NULL;
    HKEY hKey = NULL;
    MULTI_QI mq[1];

    ZeroMemory(&csi, sizeof(csi));
    csi.pAuthInfo = NULL;
    csi.pwszName = SysAllocString(servername);

    mq[0].hr = S_OK;
    mq[0].pIID = &IID_IWiaDevMgr;
    mq[0].pItf = NULL;

    REQUIRE_S_OK(CoCreateInstanceEx(CLSID_WiaDevMgr, NULL, CLSCTX_REMOTE_SERVER, 
        &csi, 1, mq));

    pDevMgr = (IWiaDevMgr *)mq[0].pItf;

    REQUIRE_SUCCESS(RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DevList"),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hDevList,
        NULL));

    //
    // Enumerate all devices scanner
    //
    REQUIRE_S_OK(pDevMgr->EnumDeviceInfo(0, &pEnumInfo));

    while(pEnumInfo->Next(1, &pWiaPropStg, NULL) == S_OK) 
    {
        PROPSPEC ps[NREGVALS];
        PROPVARIANT pv[NREGVALS];
        WCHAR keyname[MAX_PATH];
        WCHAR *p;
        int i;

        ZeroMemory(pv, sizeof(pv));
        for(i = 0; i < NREGVALS; i++) {
            ps[i].ulKind = PRSPEC_PROPID;
            ps[i].propid = regVals[i].propId;
        }

        REQUIRE_S_OK(pWiaPropStg->ReadMultiple(
            sizeof(ps) / sizeof(ps[0]), 
            ps, 
            pv));

        //
        // Skip any remote devices (anything other than "local"
        // in server name field
        //
        for(i = 0; i < NREGVALS; i++) {
            if(regVals[i].propId == WIA_DIP_SERVER_NAME) {
                if(wcscmp(pv[i].bstrVal, L"local")) {
                    goto SkipDevice;
                }
            }
        }

        //
        // pv[0] consists of device ID and "\NNN", replace "\" with ".", prepend target machine name
        //
        p = pv[0].bstrVal;
        wcscpy(keyname, servername);
        wcscat(keyname, L".");
        while(*p && *p != L'\\')
        {
            p++;
        }
        REQUIRE(*p == L'\\');
        REQUIRE(*(++p) != L'\0');

        wcscat(keyname, p);

        //
        // Create device key and populate values
        //
        REQUIRE_SUCCESS(RegCreateKeyExW(
            hDevList,
            keyname,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            NULL));

        for(i = 0; i < NREGVALS; i++) {

            switch(pv[i].vt) {

            case VT_BSTR:
                if(regVals[i].propId == WIA_DIP_SERVER_NAME) {
                    //
                    // Server name is reported as "local",
                    // we need to set it to the actual server name
                    // 
                    REQUIRE_SUCCESS(RegSetValueExW(
                        hKey, 
                        regVals[i].propName,
                        0,
                        REG_SZ,
                        (CONST BYTE *)servername,
                        wcslen(servername) * sizeof(WCHAR)));
                } else {
                    //
                    // All other values we simply copy 
                    //
                    REQUIRE_SUCCESS(RegSetValueExW(
                        hKey, 
                        regVals[i].propName,
                        0,
                        REG_SZ,
                        (CONST BYTE *)pv[i].bstrVal,
                        wcslen(pv[i].bstrVal) * sizeof(WCHAR)));
                }
                break;

            case VT_I4:
                REQUIRE_SUCCESS(RegSetValueExW(
                    hKey,
                    regVals[i].propName,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&pv[i].lVal,
                    sizeof(DWORD)));
                break;

            default:
                TRACE((_T("Unexpected property type: %d\n"), pv[i].vt));
                break;
            }

            PropVariantClear(pv + i);
        }

        RegCloseKey(hKey);
        
SkipDevice:        
        RELEASE(pWiaPropStg);
    }

Cleanup:
    if(hDevList) RegCloseKey(hDevList);
    RELEASE(pEnumInfo);
    RELEASE(pDevMgr);

    if(csi.pwszName) SysFreeString(csi.pwszName);
    return hr;
}


int __cdecl main(int argc, char **argv)
{
    HRESULT hr;
    WCHAR servername[MAX_PATH];
    HKEY hKey;


    if(argc < 2) {
        printf("usage: connect <server name>\n");
        exit(0);
    }

    MultiByteToWideChar(CP_ACP, 0, argv[1], -1, servername, sizeof(servername) / sizeof(servername[0]));

    printf("Registering scanners on %s...", argv[1]);
    
    REQUIRE_S_OK(CoInitializeEx(NULL, COINIT_MULTITHREADED));
    REQUIRE_S_OK(CoInitializeSecurity(NULL, -1, NULL, NULL,
                                      RPC_C_AUTHN_LEVEL_CONNECT,
                                      RPC_C_IMP_LEVEL_IMPERSONATE,
                                      NULL,
                                      0,
                                      NULL));
    REQUIRE_S_OK(RegisterRemoteScanners(servername));

    REQUIRE_SUCCESS(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 _T("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DevList"),
                                   0,
                                   KEY_READ,
                                   &hKey));
    for(int i = 0;;i++) {
        TCHAR subkeyName[1024];
        DWORD subkeySize;
        HKEY hSubKey;
        TCHAR string[1024];
        DWORD cbString;
        DWORD dwType;
                
        subkeySize = sizeof(subkeyName) / sizeof(subkeyName[0]);
        if(RegEnumKeyEx(hKey, i, subkeyName, &subkeySize, 0, NULL, NULL, NULL) != ERROR_SUCCESS) {
            break;
        }
        REQUIRE_SUCCESS(RegOpenKeyEx(hKey, subkeyName, 0, KEY_READ, &hSubKey));
        cbString = sizeof(string);
        REQUIRE_SUCCESS(RegQueryValueEx(hSubKey, _T("Server"), NULL, &dwType, (BYTE *)string, &cbString));
        if(lstrcmpi(string, servername))
            continue;
        
        cbString = sizeof(string);
        REQUIRE_SUCCESS(RegQueryValueEx(hSubKey, _T("Name"), NULL, &dwType, (BYTE *)string, &cbString));
        printf("\nRegistered: %ws", string);
        RegCloseKey(hSubKey);
    }


    printf("\ndone.\n");
    
Cleanup:
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stillvue.rc
//
#define IDD_SELECT                      701
#define IDD_SETTINGS                    702
#define IDD_SETVALUE                    703
#define IDD_COMPLIANCE                  704
#define IDI_STI                         801
#define IDR_STI_COMP                    901
#define IDR_STI_DDK                     902
#define IDR_STI_LAB                     903
#define IDM_                            1001
#define IDM_GO                          1002
#define IDM_STOP                        1003
#define IDM_TIMERON                     1004
#define IDM_TIMEROFF                    1005
#define IDM_TIMERNEW                    1006
#define IDM_CLEAR                       1007
#define IDM_HEX                         1008
#define IDM_DECIMAL                     1009
#define IDM_TIMEOUT                     1010
#define IDM_NEXT                        1011
#define IDC_EDIT1                       1011
#define IDM_AUTO                        1012
#define IDM_OPEN                        1013
#define IDM_CLOSE                       1014
#define IDM_HELP                        1015
#define IDM_ACTION                      1016
#define IDM_LAMPON                      1017
#define IDM_LAMPOFF                     1018
#define IDM_SCAN                        1019
#define IDM_ACQUIRE                     1020
#define IDM_SHOWDIB                     1021
#define IDM_PAUSE                       1022
#define IDM_SETTINGS                    1023
#define IDM_LAST_STATS                  1024
#define IDM_THIS_STATS                  1025
#define IDM_GETLASTERROR                1026
#define IDM_INTERNAL                    1027
#define IDM_EXTERNAL                    1028
#define IDM_COMPLIANCE                  1029
#define IDM_SHIPCRIT                    1030
#define IDM__                           1050
#define IDM_CREATE_INSTANCE             1051
#define IDM___                          1052
#define IDM_INITIALIZE                  1053
#define IDM_GET_DEVLIST                 1054
#define IDM_GET_DEVINFO                 1055
#define IDM_CREATE_DEV                  1056
#define IDM_PICK_NAME                   1057
#define IDM_GET_DEVVAL                  1058
#define IDM_SET_DEVVAL                  1059
#define IDM_GET_LAUNCHINFO              1060
#define IDM_REGISTER_LAUNCH             1061
#define IDM_UNREGISTER_LAUNCH           1062
#define IDM_ENABLE_HWNOTIF              1063
#define IDM_GET_HWNOTIF                 1064
#define IDM_REFRESH_DEVBUS              1065
#define IDM_LAUNCH_APP_FOR_DEV          1066
#define IDM_SETUP_DEVPARAMS             1067
#define IDM_WRITE_ERRORLOG              1068
#define IDM_IMAGE_RELEASE               1069
#define IDM____                         1070
#define IDM_GET_STATUS_A                1071
#define IDM_GET_STATUS_B                1072
#define IDM_GET_STATUS_C                1073
#define IDM_GET_CAPS                    1074
#define IDM_DEVICERESET                 1075
#define IDM_DIAGNOSTIC                  1076
#define IDM_GET_LASTERRINFO             1077
#define IDM_LOCKDEV                     1078
#define IDM_UNLOCKDEV                   1080
#define IDM_SUBSCRIBE                   1081
#define IDM_UNSUBSCRIBE                 1082
#define IDM_GET_LASTNOTIFDATA           1083
#define IDM_ESCAPE_A                    1084
#define IDM_ESCAPE_B                    1085
#define IDM_RAWREADDATA_A               1086
#define IDM_RAWREADDATA_B               1087
#define IDM_RAWWRITEDATA_A              1088
#define IDM_RAWWRITEDATA_B              1089
#define IDM_RAWREADCOMMAND_A            1090
#define IDM_RAWREADCOMMAND_B            1091
#define IDM_RAWWRITECOMMAND_A           1092
#define IDM_RAWWRITECOMMAND_B           1093
#define IDM_DEVICE_RELEASE              1094
#define IDM_NEXT_DEVICE                 1095
#define IDM_____                        1096
#define IDC_SELECT_DEVICE               1201
#define IDC_SELECT_NAME                 1202
#define IDC_USER_DEVICE                 1203
#define IDC_AUTO_SECONDS                1204
#define IDC_SCAN_SECONDS                1205
#define IDC_RGB_R                       1206
#define IDC_RGB_G                       1207
#define IDC_RGB_B                       1208
#define IDC_MAX_SCAN                    1209
#define IDC_GET_VALUE                   1210
#define IDC_SETVAL_TYPE                 1211
#define IDC_SETVAL_DATA                 1212
#define IDC_COMPLIANCE_DEV_NAME         1213
#define IDC_                            1214
#define IDS_CLASSNAME                   1501
#define IDS_APPNAME                     1502
#define IDS_CAPTION                     1503
#define IDS_PRIVSECTION                 1504
#define IDS_PRIVINI                     1505
#define IDS_AUTO                        1506
#define IDS_LAST_COUNT                  1507
#define IDS_LAST_SCAN                   1508
#define IDS_LAST_ERROR                  1509
#define IDS_THIS_COUNT                  1510
#define IDS_THIS_SCAN                   1511
#define IDS_THIS_ERROR                  1512
#define IDS_NTLOG                       1514

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\acquire.h ===
/******************************************************************************

  acquire.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include    <scanner.h>                 // SCL commands

//
// Hewlett-Packard ScanJet command strings
//
WCHAR szScanReadyMfr[]   = L"Hewlett-Packard";

CHAR SCLReset[]         = "E";
CHAR SetXRes[]          = "*a%dR";
CHAR SetYRes[]          = "*a%dS";
CHAR SetXExtPix[]       = "*f%dP";
CHAR SetYExtPix[]       = "*f%dQ";
CHAR InqXRes[]          = "*s10323R";
CHAR SetBitsPerPixel[]  = "*a%dG";
CHAR SetIntensity[]     = "*a%dL";
CHAR SetContrast[]      = "*a%dK";
CHAR SetNegative[]      = "*a%dI";
CHAR SetMirror[]        = "*a%dM";
CHAR SetDataType[]      = "*a%dT";
CHAR ScanCmd[]          = "*f0S";
CHAR LampOn[]           = "*f1L";
CHAR LampOff[]          = "*f0L";
CHAR PollButton[]       = "*s1044E";


LPBITMAPINFO            pDIB = NULL;        // pointer to DIB bitmap header
HBITMAP                 hDIBSection = NULL; // handle to DIB
LPBYTE                  pDIBBits = NULL;    // pointer to DIB bit data
int                     m_XSize = 800,      // horizontal size in pixels
                        m_YSize = 800;      // vertical size in pixels

BYTE					bRed        = 0,	// bitmap colors
						bGreen      = 100,
						bBlue       = 50;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\stisvc.cpp ===
/******************************************************************************

  stiddk.cpp

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/


/*****************************************************************************
    int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
        Determine whether we have Acquire commands for device

    Parameters:
        Pointer to Device Information structure

    Return:
        1 if Acquire commands available, 0 otherwise

*****************************************************************************/
int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
{
	return (0);
}


/******************************************************************************
    HRESULT
    WINAPI
    SendDeviceCommandString(
        PSTIDEVICE  pStiDevice,
        LPSTR       pszFormat,
        ...
        )
    Send formatted command string to device

    Parameters:
        StiDevice buffer and the command string

    Return:
        Result of the call.

******************************************************************************/
HRESULT
WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...
    )
{
    HRESULT hres = STIERR_UNSUPPORTED;


    return (hres);
}


/******************************************************************************
    HRESULT
    WINAPI
    TransactDevice(
        PSTIDEVICE  pStiDevice,
        LPSTR       lpResultBuffer,
        UINT        cbResultBufferSize,
        LPSTR       pszFormat,
        ...
        )
    Send formatted command string to device and return data in a buffer.

    Parameters:
        StiDevice buffer, data buffer, sizeof databuffer and the command string.

    Return:
        Result of the call.

******************************************************************************/
HRESULT
WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR       pszFormat,
    ...
    )
{
    HRESULT hres = STIERR_UNSUPPORTED;


    return (hres);
}


/*****************************************************************************
    void StiLamp(int nOnOff)
        Turn the scanner lamp on and off

    Parameters:
        Send "ON" to turn lamp on, "OFF" to turn it off.

    Return:
        none

*****************************************************************************/
void StiLamp(int nOnOff)
{
	return;
}


/*****************************************************************************
    INT StiScan(HWND hWnd)
        Scan and display an image from device.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiScan(HWND hWnd)
{
	return (-1);
}


/*****************************************************************************
    INT     CreateScanDIB(HWND);
        Create a DIB to display scanned image..

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT CreateScanDIB(HWND hWnd)
{
	return (-1);
}


/*****************************************************************************
    INT     DeleteScanDIB();
        Delete the DIB used to display a scanned image..

    Parameters:

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DeleteScanDIB()
{
    return (-1);
}


/*****************************************************************************
    INT     DisplayScanDIB(HWND);
        Show the DIB.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DisplayScanDIB(HWND hWnd)
{
    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\stillvue.h ===
/******************************************************************************

  stillvue.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#pragma warning (disable:4001)          // ignore '//' comments

#define     _X86_   1
#define     WIN32_LEAN_AND_MEAN 1

#include    <windows.h>
#include    <sti.h>                     // Still Image services
#include    "ntlog.h"                   // ntlogging APIs

#include    "resource.h"                // resource defines

#include    <stdio.h>
#include    <stdlib.h>                  // rand()
#include    <string.h>                  // strcat
#include    <time.h>                    // srand(time())

#include    "winx.h"


/*****************************************************************************

        global defines

*****************************************************************************/

#define LONGSTRING                  256
#define MEDSTRING                   128
#define SHORTSTRING                 32


/*****************************************************************************

        HWEnable states

*****************************************************************************/

#define OFF                                                     0
#define ON                                                      1
#define PEEK                                            2


/*****************************************************************************

        events

*****************************************************************************/

#define STIEVENTARG                                     "StiEvent"
#define STIDEVARG                                       "StiDevice"


/*****************************************************************************

    StiSelect contexts

*****************************************************************************/

#define AUTO            1
#define EVENT           4
#define MANUAL          8


/*****************************************************************************

    ErrorLog structure

*****************************************************************************/

typedef struct _ERRECORD
{
        // index into current test suite
        int                     nIndex;
        // unique test ID
        int                     nTest;
        // total number of times this test failed
        int                     nCount;
        // TRUE = compliance test failure; FALSE = acceptable error
        BOOL            bFatal;
        // the actual error returned
        DWORD           dwError;
        // any associated error string
        WCHAR           szErrorString[MEDSTRING];
        // previous / next record
        _ERRECORD       *pPrev;
        _ERRECORD       *pNext;
} ERRECORD, *PERRECORD;

typedef struct _DEVLOG
{
        // internal device name
        WCHAR           szInternalName[STI_MAX_INTERNAL_NAME_LENGTH];
        // friendly device name
        WCHAR           szLocalName[STI_MAX_INTERNAL_NAME_LENGTH];
        // pointer to error record structure
        PERRECORD       pRecord;
        // error total
        int                     nError;
        // previous / next record
        _DEVLOG         *pPrev;
        _DEVLOG         *pNext;
} DEVLOG, *PDEVLOG;


/*****************************************************************************

    stillvue.cpp prototypes

*****************************************************************************/

BOOL    StartAutoTimer(HWND);
BOOL    ComplianceDialog(HWND);
void    LogOutput(int,LPSTR,...);
VOID    DisplayOutput(LPSTR,...);
int     EndTest(HWND,int);
void    FatalError(char *);
BOOL    FirstInstance(HANDLE);
void    Help();
HWND    MakeWindow(HANDLE);
BOOL    ParseCmdLine(LPSTR);

BOOL    CommandParse(HWND,UINT,WPARAM,LPARAM);
BOOL    Creation(HWND,UINT,WPARAM,LPARAM);
BOOL    Destruction(HWND,UINT,WPARAM,LPARAM);
BOOL    HScroll(HWND,UINT,WPARAM,LPARAM);
BOOL    VScroll(HWND,UINT,WPARAM,LPARAM);

BOOL    NTLogInit();
BOOL    NTLogEnd();

BOOL FAR PASCAL   Compliance(HWND,UINT,WPARAM,LPARAM);
BOOL FAR PASCAL   Settings(HWND,UINT,WPARAM,LPARAM);

long FAR PASCAL   WiskProc(HWND,UINT,WPARAM,LPARAM);


/*****************************************************************************

    wsti.cpp prototypes

*****************************************************************************/

int       ClosePrivateList(PDEVLOG *);
void      DisplayLogPassFail(BOOL);
int       InitPrivateList(PDEVLOG *,int *);
int       NextStiDevice();
void      StiDisplayError(HRESULT,char *,BOOL);
HRESULT   StiEnumPrivate(PVOID *,DWORD *);
int       StiSelect(HWND,int,BOOL *);

void      IStillDeviceMenu(DWORD);
void      IStillImageMenu(DWORD);
void      IStillNameMenu(DWORD);
void      IStillScanMenu(DWORD);

HRESULT   StiClose(BOOL *);
HRESULT   StiCreateInstance(BOOL *);
HRESULT   StiDeviceRelease(BOOL *);
HRESULT   StiDiagnostic(BOOL *);
HRESULT   StiEnableHwNotification(LPWSTR,int *,BOOL *);
HRESULT   StiEnum(BOOL *);
HRESULT   StiEscape(DWORD,char *,BOOL *);
HRESULT   StiEvent(HWND);
HRESULT   StiGetCaps(BOOL *);
HRESULT   StiGetDeviceValue(LPWSTR,LPWSTR,LPBYTE,DWORD *,DWORD,BOOL *);
HRESULT   StiGetDeviceInfo(LPWSTR,BOOL *);
HRESULT   StiGetLastErrorInfo(BOOL *);
HRESULT   StiGetStatus(int,BOOL *);
HRESULT   StiImageRelease(BOOL *);
HRESULT   StiRawReadData(char *,LPDWORD,BOOL *);
HRESULT   StiRawWriteData(char *,DWORD,BOOL *);
HRESULT   StiRawReadCommand(char *,LPDWORD,BOOL *);
HRESULT   StiRawWriteCommand(char *,DWORD,BOOL *);
HRESULT   StiRefresh(LPWSTR,BOOL *);
HRESULT   StiRegister(HWND,HINSTANCE,int,BOOL *);
HRESULT   StiReset(BOOL *);
HRESULT   StiSetDeviceValue(LPWSTR,LPWSTR,LPBYTE,DWORD,DWORD,BOOL *);
HRESULT   StiSubscribe(BOOL *);
HRESULT   StiWriteErrLog(DWORD,LPCWSTR,BOOL *);

BOOL FAR PASCAL   SelectDevice(HWND,UINT,WPARAM,LPARAM);


/*****************************************************************************

    acquire.cpp prototypes

*****************************************************************************/

int     IsScanDevice(PSTI_DEVICE_INFORMATION);
void    StiLamp(int);
INT     StiScan(HWND);

INT     CreateScanDIB(HWND);
INT     DeleteScanDIB();
INT     DisplayScanDIB(HWND);

HRESULT WINAPI   SendDeviceCommandString(PSTIDEVICE,LPSTR,...);
HRESULT WINAPI   TransactDevice(PSTIDEVICE,LPSTR,UINT,LPSTR,...);


/*****************************************************************************

    winx.cpp prototypes

*****************************************************************************/

BOOL   GetFinalWindow (HANDLE hInst,LPRECT lprRect,LPSTR  lpzINI,LPSTR  lpzSection);
BOOL   SaveFinalWindow (HANDLE hInst,HWND hWnd,LPSTR lpzINI,LPSTR lpzSection);
BOOL   LastError(BOOL bNewOnly);

BOOL   ErrorMsg(HWND hWnd, LPSTR lpzMsg, LPSTR lpzCaption, BOOL bFatal);
int    NextToken(char *pDest,char *pSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\ntlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ntlog.h
//
//--------------------------------------------------------------------------

/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling	
|
\*---------------------------------------------------------------------------*/

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string 
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable



// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__



// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\acquire.cpp ===
/******************************************************************************

  acquire.cpp

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include    <scanner.h>                 // SCL commands

//
// Hewlett-Packard ScanJet command strings
//
CHAR SCLReset[]         = "E";
CHAR SetXRes[]          = "*a%dR";
CHAR SetYRes[]          = "*a%dS";
CHAR SetXExtPix[]       = "*f%dP";
CHAR SetYExtPix[]       = "*f%dQ";
CHAR InqXRes[]          = "*s10323R";
CHAR SetBitsPerPixel[]  = "*a%dG";
CHAR SetIntensity[]     = "*a%dL";
CHAR SetContrast[]      = "*a%dK";
CHAR SetNegative[]      = "*a%dI";
CHAR SetMirror[]        = "*a%dM";
CHAR SetDataType[]      = "*a%dT";
CHAR ScanCmd[]          = "*f0S";
CHAR LampOn[]           = "*f1L";
CHAR LampOff[]          = "*f0L";
CHAR PollButton[]       = "*s1044E";


LPBITMAPINFO            pDIB = NULL;        // pointer to DIB bitmap header
HBITMAP                 hDIBSection = NULL; // handle to DIB
LPBYTE                  pDIBBits = NULL;    // pointer to DIB bit data
int                     m_XSize = 800,      // horizontal size in pixels
                        m_YSize = 800;      // vertical size in pixels

BYTE					bRed        = 0,	// bitmap colors
						bGreen      = 100,
						bBlue       = 50;


/*****************************************************************************
    int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
        Determine whether we have Acquire commands for device

    Parameters:
        Pointer to Device Information structure

    Return:
        1 if Acquire commands available, 0 otherwise

*****************************************************************************/
int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
{
	int n;

WCHAR szScanReadyMfr[]   = L"Hewlett-Packard";
WCHAR szScanReadyDev[][48] = {
    L"Hewlett-Packard ScanJet 5p",
    L"Hewlett-Packard ScanJet 6100c or 4c/3c",
    L"Hewlett-Packard ScanJet 4p",
    L"Hewlett-Packard ScanJet 3p",
    L"Hewlett-Packard ScanJet IIcx",
    L"Hewlett-Packard ScanJet IIp",
    L"Hewlett-Packard ScanJet IIc",
	L""
};


	//
	// look for non-camera from Hewlett-Packard
	//
	if ((GET_STIDEVICE_TYPE(pStiDevI->DeviceType) == 1) &&
		(wcscmp(pStiDevI->pszVendorDescription,szScanReadyMfr) == 0)) {
		for (n = 0;*szScanReadyDev[n];n++) {
			//
			// is it an HP SCL compatible device?
			//
			if (wcscmp(pStiDevI->pszLocalName,szScanReadyDev[n]) == 0)
				return (1);
		}
	}
	return (0);
}


/******************************************************************************
    HRESULT
    WINAPI
    SendDeviceCommandString(
        PSTIDEVICE  pStiDevice,
        LPSTR       pszFormat,
        ...
        )
    Send formatted SCL string to the device

    Parameters:
        StiDevice buffer and the command string

    Return:
        HRESULT of last failed Sti call

******************************************************************************/
HRESULT
WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...
    )
{

	HRESULT hres = STI_OK,
		    hError = STI_OK;
    CHAR    ScanCommand[255];
    UINT    cbChar = 1;


    //
    // lock device first
    //
    hres = pStiDevice->LockDevice(2000);

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"LockDevice",TRUE);
		hError = hres;
    }
	else {
	    //
		// Format command string
		//
	    ZeroMemory(ScanCommand,sizeof(ScanCommand));
		ScanCommand[0]='\033';

	    va_list ap;
		va_start(ap, pszFormat);
		cbChar += wvsprintfA(ScanCommand+1, pszFormat, ap);
	    va_end(ap);

		DisplayOutput("->RawWriteData sending \"%2x %s\"",
			ScanCommand[0],ScanCommand+1);

	    //
		// Send command string to the device
	    //
		hres = pStiDevice->RawWriteData(
			ScanCommand,    //
	        cbChar,         //
		    NULL            //
			);

		if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"RawWriteData",TRUE);
			hError = hres;
		}
	}

    //
    // unlock device
    //
    hres = pStiDevice->UnLockDevice();

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"UnLockDevice",TRUE);
		hError = hres;
    }

    return (hError);
}


/******************************************************************************
    HRESULT
    WINAPI
    TransactDevice(
        PSTIDEVICE  pStiDevice,
        LPSTR       lpResultBuffer,
        UINT        cbResultBufferSize,
        LPSTR       pszFormat,
        ...
        )
    Send formatted SCL string to the device and return data in a buffer.

    Parameters:
        StiDevice buffer, data buffer, sizeof databuffer and the command string.

    Return:
        HRESULT of last failed Sti call

******************************************************************************/
HRESULT
WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR       pszFormat,
    ...
    )
{

	HRESULT hres = STI_OK,
		    hError = STI_OK;
    CHAR    ScanCommand[255];
    UINT    cbChar = 1;
    ULONG   cbActual = 0;


    //
    // lock device first
    //
    hres = pStiDevice->LockDevice(2000);

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"LockDevice",TRUE);
		hError = hres;
    }
	else {
	    //
		// Format command string
	    //
		ZeroMemory(ScanCommand,sizeof(ScanCommand));
	    ScanCommand[0]='\033';

	    va_list ap;
		va_start(ap, pszFormat);
	    cbChar += wvsprintfA(ScanCommand+1, pszFormat, ap);
		va_end(ap);

	    DisplayOutput("->Escape sending \"%2x %s\"",
		    ScanCommand[0],ScanCommand+1);

		//
		// Send command string to the device
		//
		hres = pStiDevice->Escape(
			StiTransact,        // EscapeFunction
			ScanCommand,        // lpInData
			cbChar,             // cbInDataSize
			lpResultBuffer,     // pOutData
			cbResultBufferSize, // dwOutDataSize
			&cbActual);         // pdwActualData
		
		if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"Escape",TRUE);
			hError = hres;
		}
		if (cbActual != 0)
			DisplayOutput("  cbActual %xh",cbActual);
	}

    //
    // unlock device
    //
    hres = pStiDevice->UnLockDevice();

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"UnLockDevice",TRUE);
		hError = hres;
    }

    return (hError);
}


/*****************************************************************************
    void StiLamp(int nOnOff)
        Turn the scanner lamp on and off

    Parameters:
        Send "ON" to turn lamp on, "OFF" to turn it off.

    Return:
        none

*****************************************************************************/
void StiLamp(int nOnOff)
{
    HRESULT hres;


    //
    // check that an Sti device is selected
    //
    if (pStiDevice == NULL)
        return;

    //
    // Test lamp on/off capability
    //
    if (nOnOff == ON) {
        strcpy(pszStr1,LampOn);
        strcpy(pszStr2,"On");
    }
    else {
        strcpy(pszStr1,LampOff);
        strcpy(pszStr2,"Off");
    }

    hres = SendDeviceCommandString(pStiDevice,pszStr1);

	if (SUCCEEDED(hres)) {
        DisplayOutput("Turned Lamp  %s",pszStr2);
	}

	return;
}


/*****************************************************************************
    INT StiScan(HWND hWnd)
        Scan and display an image from device.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiScan(HWND hWnd)
{
    HRESULT             hres;
    ULONG               cbDataSize,
                        ulDIBSize,
                        ulScanSize;
    RGBTRIPLE           *pTriplet;
    LPBYTE              pDIBPtr;
    UINT                i,
                        iPixel,
                        xRes = 0;
    int                 m_XResolution = 100,
                        m_YResolution = 100;
    CHAR                ScanData[1024*16];


    //
    // ensure there is an active still imaging device open
    //
    if (pStiDevice == NULL)
		return (-1);

    //
    // Set basic parameters
    //
    hres = SendDeviceCommandString(pStiDevice,SetBitsPerPixel,24);
	if (! SUCCEEDED(hres))
		return (-1);
	hres = SendDeviceCommandString(pStiDevice,SetIntensity,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetContrast,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetNegative,1);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetMirror,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetDataType,5);    // Color
	if (! SUCCEEDED(hres))
		return (-1);

    hres = SendDeviceCommandString(pStiDevice,SetXRes,m_XResolution);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetYRes,m_YResolution);
	if (! SUCCEEDED(hres))
		return (-1);

    hres = SendDeviceCommandString(pStiDevice,SetXExtPix,(m_XSize*300/m_XResolution));
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetYExtPix,(m_YSize*300/m_YResolution));
	if (! SUCCEEDED(hres))
		return (-1);

    //
    // Inquire commands ( X and Y resolution)
    //
    cbDataSize = sizeof(ScanData);
    ZeroMemory(ScanData,sizeof(ScanData));
/*
    hres = TransactDevice(pStiDevice,ScanData,cbDataSize,InqXRes);
	if (! SUCCEEDED(hres))
		return (-1);
*/

    //
    // calculate the size of the DIB
    //
    ulDIBSize = pDIB->bmiHeader.biWidth * (-pDIB->bmiHeader.biHeight);

    //
    // start the scan
    //
    hres = SendDeviceCommandString(pStiDevice,ScanCmd);

    for (i = 0,pDIBPtr = pDIBBits,cbDataSize = sizeof(ScanData);
        cbDataSize == sizeof(ScanData);i++) {

		//
	    // lock device first
		//
	    hres = pStiDevice->LockDevice(2000);
	
	    if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"LockDevice",TRUE);
	    }
		else {
			hres = pStiDevice->RawReadData(ScanData,&cbDataSize,NULL);

			if (! SUCCEEDED(hres)) {
				StiDisplayError(hres,"RawReadData",TRUE);
			}
		}

		//
		// unlock device
	    //
		hres = pStiDevice->UnLockDevice();

	    if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"UnLockDevice",TRUE);
	    }

        if ((cbDataSize * i) < ulDIBSize) {
            //
            // copy this scanline into the DIB until it is full
            //
            memcpy(pDIBPtr,ScanData,cbDataSize);
            pDIBPtr += cbDataSize;
        }
    }

    //
    // how large was the scan?
    //
    ulScanSize = (sizeof(ScanData))*i+cbDataSize;

    DisplayOutput("Scan done. Total passes %d, bytes %lu.",
        i,ulScanSize);

    //
    // Triplets coming in from scanner are inverted from DIB format
    //
    for (iPixel = 0,pTriplet = (RGBTRIPLE *) pDIBBits;
        iPixel < ulDIBSize/3;iPixel++,pTriplet++) {
        BYTE    bTemp;

        bTemp = pTriplet->rgbtBlue;
        pTriplet->rgbtBlue = pTriplet->rgbtRed;
        pTriplet->rgbtRed = bTemp;
        }

    //
    // display the DIB
    //
    DisplayScanDIB(hWnd);
    nScanCount++;

    return (0);
}


/*****************************************************************************
    INT     CreateScanDIB(HWND);
        Create a DIB to display scanned image..

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT CreateScanDIB(HWND hWnd)
{
    HDC                 hScreenDC;
    RGBTRIPLE           *pTriplet;
    LPBITMAPINFOHEADER  pHdr;
    int                 x,
                        y;


    GdiFlush();

    // delete the DIB object if it exists
    if (hDIBSection)
        DeleteObject(hDIBSection);

/*

    hWindow = CreateWindow((LPSTR) pszB,
        (LPSTR) pszA,
        WS_OVERLAPPEDWINDOW,
        rect.left,
        rect.top,
        rect.right,
        rect.bottom,
        (HWND) NULL,
        0,
        hInst,
        NULL);

*/

    //
    // initialize the DIB
    //
    pDIB = (LPBITMAPINFO) GlobalAlloc(GPTR,sizeof(BITMAPINFO));

    pHdr = &pDIB->bmiHeader;

    pHdr->biSize            = sizeof(BITMAPINFOHEADER);
    pHdr->biWidth           = m_XSize;
    pHdr->biHeight          = -m_YSize; // indicate top-down dib
    pHdr->biPlanes          = 1;
    pHdr->biBitCount        = 24;
    pHdr->biCompression     = BI_RGB;
    pHdr->biSizeImage       = 0;
    pHdr->biXPelsPerMeter   = 0;
    pHdr->biYPelsPerMeter   = 0;
    pHdr->biClrUsed         = 0;
    pHdr->biClrImportant    = 0;

    //
    // create the DIB
    //
    hScreenDC = GetDC(hWnd);
    if (NULL == (hDIBSection = CreateDIBSection(hScreenDC,
        (PBITMAPINFO) pDIB,
        DIB_RGB_COLORS,
        (void **) &pDIBBits,
        NULL,
        0)))
    {
        LastError(TRUE);
        DisplayOutput("*failed to create DIB");
        ReleaseDC(hWnd,hScreenDC);
        return (-1);
    }
    ReleaseDC(hWnd,hScreenDC);

    //
    // Fill the DIB with colors
    //
    pTriplet = (RGBTRIPLE *) pDIBBits;

    for (x = 0;x < m_XSize;x++) {
        for (y = 0;y < m_YSize;y++,pTriplet++) {
            pTriplet->rgbtRed   = bRed;
            pTriplet->rgbtGreen = bGreen;
            pTriplet->rgbtBlue  = bBlue;
        }
    }

    return (0);
}


/*****************************************************************************
    INT     DeleteScanDIB();
        Delete the DIB used to display a scanned image..

    Parameters:

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DeleteScanDIB()
{
	GdiFlush();
	DeleteObject(hDIBSection);
	
    return (0);
}


/*****************************************************************************
    INT     DisplayScanDIB(HWND);
        Show the DIB.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DisplayScanDIB(HWND hWnd)
{
    HDC                 hScreenDC;


    //
    // display the DIB
    //
    hScreenDC = GetDC(hWnd);
    SetDIBitsToDevice(hScreenDC,
        0,0,
        m_XSize,m_YSize,
        0,0,
        0,m_YSize,
        pDIBBits,
        (LPBITMAPINFO) pDIB,
        DIB_RGB_COLORS);
    ReleaseDC(hWnd,hScreenDC);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\stillvue.cpp ===
/******************************************************************************

  stillvue.cpp
  Simple test of WDM Still Image Class

  Copyright (C) Microsoft Corporation, 1997 - 1999
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#define     INITGUID

#include    "stillvue.h"

#include <dbt.h>
#include <devguid.h>
#include <pnpmgr.h>

#include    "stivar.h"                // stillvue local includes

//
// defined in wsti.cpp
//
extern      WCHAR szFriendlyName[];
extern      WCHAR szInternalName[];
extern      DWORD dwStiTotal;
extern      PSTI_DEVICE_INFORMATION pStiInfoPtr;


/******************************************************************************
  BOOL CommandParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Handle user menu commands.
******************************************************************************/
BOOL CommandParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    HRESULT hres = STI_OK;
    DWORD   dwSize = 0,
            dwType = 0,
            dwPriority = STI_TRACE_ERROR,
            EscapeFunction = 0,
            dwNumberOfBytes = 0;
    WCHAR   szMessage[] = L"Sti Compliance Test message";
    WCHAR   szDevKey[LONGSTRING];
    char    lpInData[LONGSTRING],
            lpOutData[LONGSTRING];
    int     nReturn = 0;    // generic return value
    BOOL    bReturn;


    //
    // Set the InATest semaphore
    //
    nInATestSemaphore = 1;

    switch(wParam)
    {
    // IStillImage Interfaces
    case IDM_CREATE_INSTANCE:
        hres = StiCreateInstance(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVLIST:
        hres = StiEnum(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_CREATE_DEV:
        if (bAuto)
            hres = StiSelect(hWnd,AUTO,&bReturn);
        else
            hres = StiSelect(hWnd,MANUAL,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVINFO:
        hres = StiGetDeviceInfo(szInternalName,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVVAL:
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_TWAIN_NAME,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_ISIS_NAME,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_ICM_PROFILE,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_SET_DEVVAL:
        //
        // Store a dummy registry key and value
        //
        wcscpy(szDevKey,L"StiTestRegKey");
        strcpy(lpOutData,"This is a bland statement");
        dwType = REG_SZ;
        dwSize = strlen(lpOutData);

        //
        // set the value and then retrieve it
        //
        hres = StiSetDeviceValue(szInternalName,
            szDevKey,(LPBYTE) lpOutData,dwType,dwSize,&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            szDevKey,(LPBYTE) lpOutData,&dwType,DWORD(LONGSTRING),&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_REGISTER_LAUNCH:
        hres = StiRegister(hWnd,hThisInstance,ON,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_UNREGISTER_LAUNCH:
        hres = StiRegister(hWnd,hThisInstance,OFF,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_ENABLE_HWNOTIF:
        //
        // Change Hw notification to inverse
        //
        nHWState = 0;

        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        if (nHWState == 0)
            nHWState = 1;
        else
            nHWState = 0;
        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_HWNOTIF:
        //
        // Look at the current HW notification state
        //
        nHWState = PEEK;
        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_REFRESH_DEVBUS:
        hres = StiRefresh(szInternalName,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_WRITE_ERRORLOG:
        for (;lParam >= 1;lParam--)
            hres = StiWriteErrLog(dwPriority,szMessage,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_IMAGE_RELEASE:
        hres = StiImageRelease(&bReturn);
        DisplayLogPassFail(bReturn);
        break;

    // IStillImage_Device Interfaces
    case IDM_GET_STATUS_A:
        nReturn = STI_DEVSTATUS_ONLINE_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_STATUS_B:
        nReturn = STI_DEVSTATUS_EVENTS_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_STATUS_C:
        nReturn = STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_CAPS:
        hres = StiGetCaps(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_DEVICERESET:
        hres = StiReset(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_DIAGNOSTIC:
        hres = StiDiagnostic(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_LASTERRINFO:
        hres = StiGetLastErrorInfo(&bReturn);
        DisplayLogPassFail(bReturn);
        DisplayOutput("");
        break;
    case IDM_SUBSCRIBE:
        hres = StiSubscribe(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_UNSUBSCRIBE:
        nUnSubscribe = 0;
        DisplayOutput("");
        break;

    case IDM_ESCAPE_A:
        //
        // Set up the Escape command parameters
        //
        EscapeFunction = 0;
        strcpy(lpInData,"This is a bland statement");

        hres = StiEscape(EscapeFunction,&lpInData[0],&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWREADDATA_A:
        //
        // Set up the RawReadData command parameters
        //
        ZeroMemory(lpInData,LONGSTRING);
        dwNumberOfBytes = 16;

        hres = StiRawReadData(lpInData,&dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWWRITEDATA_A:
        //
        // Set up the RawReadData command parameters
        //
        strcpy(lpOutData,"The eagle flies high");
        dwNumberOfBytes = strlen(lpOutData);

        hres = StiRawWriteData(lpOutData,dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWREADCOMMAND_A:
        //
        // Set up the RawReadCommand command parameters
        //
        ZeroMemory(lpInData,LONGSTRING);
        dwNumberOfBytes = 16;

        hres = StiRawReadCommand(lpInData,&dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWWRITECOMMAND_A:
        //
        // Set up the RawWriteCommand command parameters
        //
        strcpy(lpOutData,"Jack and Jill went up the hill");
        dwNumberOfBytes = strlen(lpOutData);

        hres = StiRawWriteCommand(lpOutData,dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;

    case IDM_DEVICE_RELEASE:
        hres = StiDeviceRelease(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_NEXT_DEVICE:
        hres = NextStiDevice();
        DisplayLogPassFail(bReturn);
        break;

    case IDM_LAMPON:
        StiLamp(ON);
        break;
    case IDM_LAMPOFF:
        StiLamp(OFF);
        break;
    case IDM_SCAN:
        hres = StiScan(hWnd);
        break;
    case IDM_SHOWDIB:
        hres = DisplayScanDIB(hWnd);
        break;

    case IDM_COMPLIANCE:
        //
        // assign a test suite and start the automated test timer
        //
        pSuite = nComplianceSuite;
        nMaxCount = 3;
        nTimeScan = 10;
        nTimeNext = 1;
        bAuto = StartAutoTimer(hWnd);
        break;
    case IDM_SHIPCRIT:
        //
        // assign a test suite and start the automated test timer
        //
        pSuite = nShipcritSuite;
        nMaxCount = 200;
        nTimeScan = 10;
        nTimeNext = 1;
        bAuto = StartAutoTimer(hWnd);
        break;

    case IDM_PAUSE:
        // toggle pausing automation (if running) on/off
        if (! nPause) {
            DisplayOutput("..pausing automated test..");
            nPause = 1;
           }
        else {
            DisplayOutput("Resuming automated test");
            nPause = 0;
        }
        break;
    case IDM_AUTO:
        // toggle the automation on/off
        if (bAuto) {
            // stop the auto timer and the stress tests
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;
            EnableMenuItem(hMenu, IDM_PAUSE,  MF_DISABLED);
            DisplayOutput("Ending the tests");
        }
        else {
            // start the auto timer and the stress tests
            LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);
            if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL))
                ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
            else {
                bAuto = TRUE;
                EnableMenuItem(hMenu, IDM_PAUSE,  MF_ENABLED);
                DisplayOutput("Starting the Sti Compliance tests");
                pSuite = nComplianceSuite;
                //
                // initialize NT Logging
                //
                NTLogInit();
            }
        }
        break;
    case IDM_SETTINGS:
        bReturn = fDialog(IDD_SETTINGS, hWnd, (FARPROC) Settings);

        // implement the settings if user pressed OK
        if (bReturn != FALSE)
        {
            if (nTTNext != nTimeNext) {
                nTimeNext = nTTNext;
                DisplayOutput("Test interval changed to %d seconds",nTimeNext);
            }
            if (nTTScan != nTimeScan) {
                nTimeScan = nTTScan;
                DisplayOutput("Scan interval changed to %d seconds",
                    nTimeScan * nTimeNext);
            }
            if (nTTMax != nMaxCount) {
                nMaxCount = nTTMax;
                DisplayOutput("Test loops changed to %d (0 is forever)",
                    nMaxCount);
            }
        }
        break;
    case IDM_HELP:
        Help();
        break;
    default:
        break;
    }
    //
    // Clear the InATest semaphore
    //
    nInATestSemaphore = 0;

    // always return 0
    return 0;
}


/******************************************************************************
  BOOL TimerParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Each timer tick, decide whether to run the next test, repeat a prior test,
  end testing, or shut everything down.
******************************************************************************/
BOOL TimerParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    HRESULT hres = STI_OK;              // generic Sti return value
    int     nReturn = 0,                // generic return value
            *pTest;                     // pointer to the test suite to run
    BOOL    bResume = TRUE,             // reset timer flag
            bReturn = TRUE;             // dialog box return value
static int  nDeviceNumber = 1;          // current device
static int  nCountdown = nTimeScan;     // WM_TIMER ticks until next scan
static DWORD dwOut = 0;


    //
    // Don't start a test if paused or running a test currently.
    //
    //
    if ((nInTimerSemaphore)||(nInATestSemaphore)||(nPause))
        return 0;

    //
    // Suspend the timer while running this test.
    // Set Flag to reset timer
    // Set the nInTimerSemaphore
    // Set the current test ID
    //
    KillTimer(hWnd,TIMER_ONE);
    bResume = TRUE;
    nInTimerSemaphore = 1;
    nTestID = nNextTest;

    //
    // point to the next test in the current suite to run
    //
    pTest = pSuite + nNextTest;

    switch (*pTest)
    {
    case NONE:
        nNextTest++;
        break;
    case HELP:
        nNextTest++;
        break;
    case COMPLIANCE:
        //
        // initialize test structures
        //
        if (pdevRoot == NULL) {
            InitPrivateList(&pdevRoot,pSuite);
            pdevPtr = pdevRoot;
        }

        //
        // if this is COMPLIANCE test, ask user to confirm test
        //
        bResume = ComplianceDialog(hWnd);

        nNextTest++;
        break;
    case SHIPCRIT:
        //
        // initialize test structures
        //
        if (pdevRoot == NULL) {
            InitPrivateList(&pdevRoot,pSuite);
            pdevPtr = pdevRoot;
        }
        nNextTest++;
        break;
    case ERRORLOG:
        nNextTest++;
        break;
    case TEST:
        nNextTest++;
        break;
    case tBeginningOfTest:
        DisplayOutput("Begin Testing test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Begin Testing test, loop %d, device %d",nTestCount,nDeviceNumber);
        nNextTest++;
        break;
    case tCreateInstance:
        DisplayOutput("CreateInstance test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"CreateInstance test, loop %d, device %d",nTestCount,nDeviceNumber);
        DisplayOutput("%S (%S) is being tested",
            pdevPtr->szLocalName,pdevPtr->szInternalName);
        tlLog(hNTLog,TL_LOG,"%S (%S) is being tested",
            pdevPtr->szLocalName,pdevPtr->szInternalName);
        DisplayOutput("");
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_INSTANCE,0);
        nNextTest++;
        break;
    case tGetDeviceList:
        DisplayOutput("GetDeviceList test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceList test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVLIST,0);
        nNextTest++;
        break;
    case tCreateDevice:
        DisplayOutput("CreateDevice test (Device ONLINE), loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,
            "CreateDevice test (Device ONLINE), loop %d, device %d",nTestCount,nDeviceNumber);
        //
        // Call Sti with device
        //
        nNameOnly = 0;
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_DEV,0);
        nNextTest++;
        break;
    case tSelectDeviceName:
        DisplayOutput("SelectDeviceName test (Device OFFLINE), "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"SelectDeviceName test (Device OFFLINE),"\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        //
        // Call Sti with device name only
        //
        nNameOnly = 1;
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_DEV,0);
        nNextTest++;
        break;
    case tGetDeviceInfo:
        DisplayOutput("GetDeviceInfo test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceInfo test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVINFO,0);
        nNextTest++;
        break;
    case tGetDeviceValue:
        DisplayOutput("GetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVVAL,0);
        nNextTest++;
        break;
    case tSetDeviceValue:
        DisplayOutput("SetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"SetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_SET_DEVVAL,0);
        nNextTest++;
        break;
    case tRegisterLaunchApplication:
        DisplayOutput("RegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_REGISTER_LAUNCH,0);
        nNextTest++;
        break;
    case tUnRegisterLaunchApplication:
        DisplayOutput("UnRegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"UnRegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_UNREGISTER_LAUNCH,0);
        nNextTest++;
        break;
    case tEnableHwNotifications:
        DisplayOutput("EnableHwNotifications test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"EnableHwNotifications test, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_ENABLE_HWNOTIF,0);
        nNextTest++;
        break;
    case tGetHwNotificationState:
        DisplayOutput("GetHwNotificationState test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetHwNotificationState test, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_HWNOTIF,0);
        nNextTest++;
        break;
    case tWriteToErrorLog:
        DisplayOutput("WriteToErrorLog test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"WriteToErrorLog test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_WRITE_ERRORLOG,0);
        nNextTest++;
        break;
    case tWriteToErrorLogBig:
        DisplayOutput("WriteToErrorLog test, Variation 1, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"WriteToErrorLog test, Variation 1, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_WRITE_ERRORLOG,100);
        nNextTest++;
        break;
    case tGetStatusA:
        DisplayOutput("GetStatus (Online) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_A,0);
        nNextTest++;
        break;
    case tGetStatusB:
        DisplayOutput("GetStatus (Event) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_B,0);
        nNextTest++;
        break;
    case tGetStatusC:
        DisplayOutput("GetStatus (All) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_C,0);
        nNextTest++;
        break;
    case tGetCapabilities:
        DisplayOutput("GetCapabilities test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetCapabilities test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_CAPS,0);
        nNextTest++;
        break;
    case tDeviceReset:
        DisplayOutput("DeviceReset test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"DeviceReset test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DEVICERESET,0);
        nNextTest++;
        break;
    case tDiagnostic:
        DisplayOutput("Diagnostic test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Diagnostic test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DIAGNOSTIC,0);
        nNextTest++;
        break;
    case tGetLastInfoError:
        DisplayOutput("GetLastInfoError test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetLastInfoError test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_LASTERRINFO,0);
        nNextTest++;
        break;
    case tSubscribe:
        DisplayOutput("Subscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Subscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_SUBSCRIBE,0);
        nNextTest++;
        break;
    case tUnSubscribe:
        DisplayOutput("UnSubscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"UnSubscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_UNSUBSCRIBE,0);
        nNextTest++;
        break;
    case tEscapeA:
        DisplayOutput("Escape (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Escape test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_ESCAPE_A,0);
        nNextTest++;
        break;
    case tRawReadDataA:
        DisplayOutput("RawReadData (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawReadData test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWREADDATA_A,0);
        nNextTest++;
        break;
    case tRawWriteDataA:
        DisplayOutput("RawWriteData (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawWriteData test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWWRITEDATA_A,0);
        nNextTest++;
        break;
    case tRawReadCommandA:
        DisplayOutput("RawReadCommand (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawReadCommand test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWREADCOMMAND_A,0);
        nNextTest++;
        break;
    case tRawWriteCommandA:
        DisplayOutput("RawWriteCommand (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawWriteCommand test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWWRITECOMMAND_A,0);
        nNextTest++;
        break;
    case tAcquire:
        if (! nICanScan) {
            nNextTest++;
        } else {
            if (nCountdown == nTimeScan) {
                nCountdown--;
                DisplayOutput("...countdown %d to acquire...",nCountdown);
                PostMessage(hWnd,WM_COMMAND,IDM_SCAN,0);
            }
            else {
                if (nCountdown == 0) {
                    nNextTest++;
                    nCountdown = nTimeScan;
                }
                else {
                    nCountdown--;
                    DisplayOutput("Acquire test, loop %d, device %d",nTestCount,nDeviceNumber);
                    tlLog(hNTLog,TL_LOG,"Acquire test, loop %d, device %d",nTestCount,nDeviceNumber);
                    PostMessage(hWnd,WM_COMMAND,IDM_SHOWDIB,0);
                }
            }
        }
        break;
    case tReleaseDevice:
        DisplayOutput("ReleaseDevice test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"ReleaseDevice test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DEVICE_RELEASE,0);
        nNextTest++;
        break;
    case tReleaseSti:
        DisplayOutput("ReleaseSti test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"ReleaseSti test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_IMAGE_RELEASE,0);
        nNextTest++;
        break;
    case tHelp:
        PostMessage(hWnd,WM_COMMAND,IDM_HELP,0);
        nNextTest++;
        break;
    case tTest:
        DisplayOutput("   Line %d",dwOut++);
        nNextTest++;
        break;
    case tEndOfTest:
        //
        // Reached the end of test suite
        //
        DisplayOutput("test loop complete");
        tlLog(hNTLog,TL_LOG,"test loop complete");
        if (nICanScan) {
            DisplayOutput("-> %d loops (%d scans and %d errors) device %d",
                nTestCount,nScanCount,pdevPtr->nError,nDeviceNumber);
            tlLog(hNTLog,TL_LOG,"-> %d loops (%d scans and %d errors) device %d",
                nTestCount,nScanCount,pdevPtr->nError,nDeviceNumber);
        } else {
            DisplayOutput("-> %d loops (%d errors) device %d",
                nTestCount,pdevPtr->nError,nDeviceNumber);
            tlLog(hNTLog,TL_LOG,"-> %d loops (%d errors) device %d",
                nTestCount,pdevPtr->nError,nDeviceNumber);
        }

        //
        // Have we run requested number of tests per device?
        //
        if (((nTestCount >= nMaxCount) &&
            ((dwStiTotal == (DWORD) (nDeviceNumber)) || (dwStiTotal == 0)) &&
            (nMaxCount != 0))) {
            DisplayOutput("Requested number of test loops per device "\
                "reached");
            tlLog(hNTLog,TL_LOG,"Requested number of test loops per "\
                "device reached");

            //
            // shut off timer and turn off automation
            //
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;
            bResume = FALSE;

            //
            // print the test summary for the devices
            //
            DisplayOutput("");
            tlLog(hNTLog,TL_LOG,"");
            if (pdevRoot == NULL) {
                DisplayOutput("No valid Still Imaging devices were found");
                tlLog(hNTLog,TL_LOG,"No valid Still Imaging devices were found");
            } else {
                PDEVLOG     pD = pdevRoot;
                PERRECORD   pR = NULL;
                BOOL        bPF = FALSE;


                DisplayOutput("Testing results:");
                tlLog(hNTLog,TL_LOG,"Testing results:");

                do {
                    DisplayOutput(" %S (%S)",pD->szLocalName,pD->szInternalName);
                    tlLog(hNTLog,TL_LOG," %S (%S)",pD->szLocalName,
                        pD->szInternalName);

                    for (pR = pD->pRecord;pR->pNext != NULL;pR = pR->pNext) {
                        if (pR->bFatal && pR->nCount) {
                            DisplayOutput("  %s failures: %d",
                                StrFromTable(pR->nTest,StSuiteStrings),
                                pR->nCount);
                            tlLog(hNTLog,TL_LOG,"  %s failures: %d",
                                StrFromTable(pR->nTest,StSuiteStrings),
                                pR->nCount);
                            //
                            // set the FAIL flag
                            //
                            bPF = TRUE;
                        }
                    }
                    if (bPF == TRUE) {
                        DisplayOutput("FAIL: This device has FAILED the "\
                            "Still Imaging Compliance test!");
                        tlLog(hNTLog,TL_LOG,"FAIL: This device has FAILED "\
                            "the Still Imaging Compliance test!");
                    } else {
                        DisplayOutput("PASS: This device has PASSED the "\
                            "Still Imaging Compliance test!");
                        tlLog(hNTLog,TL_LOG,"PASS: This device has PASSED "\
                            "the Still Imaging Compliance test!");
                    }

                    // cycle through all devices, BREAK at end of list
                    if (pD->pNext) {
                        pD = pD->pNext;
                        DisplayOutput("");
                        tlLog(hNTLog,TL_LOG,"");
                        bPF = FALSE;
                    } else {
                        DisplayOutput("");
                        break;
                    }
                } while (TRUE);
            }
            //
            // free the private lists and close Sti subsystem
            //
            ClosePrivateList(&pdevRoot);
            StiClose(&bReturn);
            //
            // reset test counters
            //
            nDeviceNumber = 1;
            nNextTest = 0;
            nTestCount = 1;

            DisplayOutput("End of testing");
            tlLog(hNTLog,TL_LOG,"End of testing");
            DisplayOutput("");

        } else {
            //
            // Point to first test (past initialization) in list.
            //
            nNextTest = 2;
            //
            // select next device in device log
            // Note that this list isn't dynamic for PNP changes...
            //
            nDeviceNumber = NextStiDevice();

            //
            // increment test pass counter if we're at first device again
            //
            if ((++nDeviceNumber) == 1)
                nTestCount++;

            DisplayOutput("");
        }
        break;
    default:
        DisplayOutput("");
        DisplayOutput("Unimplemented test # %d",*pTest);
        DisplayOutput("");
        nNextTest++;
        break;
    }
    //
    // Resume the timer if the flag is set
    //
    if (bResume) {
        if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL)) {
            LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);
            ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
        }
    }
    //
    // Clear the nInTimerSemaphore
    //
    nInTimerSemaphore = 0;

    // always return 0
    return 0;
}


/******************************************************************************
  int EndTest(HWND hWnd,int nNumTest)

  After each test run cleanup.
******************************************************************************/
int EndTest(HWND hWnd,int nNumTest)
{
    int     nReturn = 0;    // generic return value
    BOOL    bReturn;        // generic return value


    // shut off timer
    KillTimer(hWnd,TIMER_ONE);

    // close any open still imaging devices
    StiClose(&bReturn);

    // save test stats if more than non-trivial number of tests run
    if (nTestCount >= 2)
    {
        LoadString(hThisInstance,IDS_PRIVINI,pszOut,LONGSTRING);
        LoadString(hThisInstance,IDS_PRIVSECTION,pszStr4,LONGSTRING);

        _itoa(nTestCount,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last count",pszStr2,pszOut);
        _itoa(nScanCount,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last scan",pszStr2,pszOut);
        _itoa(nError,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last error",pszStr2,pszOut);
    }
    DisplayOutput("Testing complete");
    DisplayOutput("This run was %d loops (%d scans and %d errors)",
        nTestCount,nScanCount,nError);

    // reset current line, errors
//    nError = nNextLine = 0;

    //
    // end NT Logging
    //
    NTLogEnd();

    return nReturn;
}


/******************************************************************************
  BOOL NTLogInit()

  Initialize NT logging
******************************************************************************/
BOOL NTLogInit()
{
    //
    // Create the log object. We are specifying that the file be refreshed,
    // and that logging be output for variations. The flags also specify that
    // only output at SEV2, WARN and PASS levels should be logged.
    //
    dwNTStyle = TLS_SEV2 | TLS_WARN | TLS_PASS | TLS_VARIATION | TLS_REFRESH |
        TLS_TEST;


    LoadString(hThisInstance,IDS_NTLOG,pszStr1,LONGSTRING);
    hNTLog = tlCreateLog(pszStr1,dwNTStyle);
    tlAddParticipant(hNTLog,NULL,0);

    return (TRUE);
}


/******************************************************************************
  BOOL NTLogEnd()

  Terminate NT logging
******************************************************************************/
BOOL NTLogEnd()
{

    tlRemoveParticipant(hNTLog);
    tlDestroyLog(hNTLog);

    return (TRUE);
}


/******************************************************************************
  void Help()

  Display help.
******************************************************************************/
void Help()
{
    DisplayOutput("Stillvue command line parameters");
    DisplayOutput("");
    DisplayOutput("Stillvue -COMPLIANCE");
    DisplayOutput("  WHQL external Sti Compliance test");
    DisplayOutput("Stillvue -SHIPCRIT");
    DisplayOutput("  Internal PSD Sti Compliance test");
    DisplayOutput("Stillvue -ERRORLOG");
    DisplayOutput("  Errorlog limits test");
//    DisplayOutput("Stillvue -EXIT");
//    DisplayOutput("  Application will Exit after test completes");
    DisplayOutput("Stillvue -NODIALOG");
    DisplayOutput("  Don't display opening dialog");
    DisplayOutput("Stillvue -HELP");
    DisplayOutput("  Display this help");
    DisplayOutput("");

/*
    DisplayOutput("Stillvue /INF test.inf");
    DisplayOutput("  Read test.inf file");
    DisplayOutput("Stillvue /LOG test.log");
    DisplayOutput("  Write to test.log file");
    DisplayOutput("Stillvue /");
    DisplayOutput("  ");
*/

}


/******************************************************************************
  BOOL StartAutoTimer(HWND)
    Start the automated test timer

  Parameters
    Handle to app's window

  Return
    Return TRUE if successful, else FALSE

******************************************************************************/
BOOL StartAutoTimer(HWND hWnd)
{
    BOOL bAutoTimer = TRUE;


    // start the timer to run tests automatically
    LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);

    if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL)) {
        ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
        bAutoTimer = FALSE;
    } else {
        EnableMenuItem(hMenu, IDM_PAUSE,  MF_ENABLED);
        DisplayOutput("Starting the Automated tests");
    }

    return (bAutoTimer);
}


/******************************************************************************
  BOOL ComplianceDialog(HWND)
    Call the Compliance test confirmation dialog

  Parameters
    Handle to app's window

  Return
    Return TRUE if user pressed OK, else FALSE

******************************************************************************/
BOOL ComplianceDialog(HWND hWnd)
{
    BOOL bReturn = FALSE;


    if ((pSuite[0] == COMPLIANCE)&&(bCompDiag == TRUE)) {
        bReturn = fDialog(IDD_COMPLIANCE, hWnd, (FARPROC) Compliance);
        //
        // implement the settings if user pressed OK
        //
        if (bReturn == FALSE)
        {
            //
            // shut off timer and turn off automation
            //
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;

            //
            // free the private lists
            //
            ClosePrivateList(&pdevRoot);

            DisplayOutput("Testing cancelled at user request");
            tlLog(hNTLog,TL_LOG,"Testing cancelled at user request");
        } else {
            DisplayOutput("Testing starting at user request");
            tlLog(hNTLog,TL_LOG,"Testing starting at user request");
        }
    }

    return (bReturn);
}


/******************************************************************************
    BOOL FAR PASCAL Compliance(HWND,UINT,WPARAM,LPARAM)
        OK the Compliance test dialog

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL Compliance(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    PDEVLOG pPtr = pdevRoot;
    int     iIndex = 0;


    switch (msg) {

        case WM_INITDIALOG:

            //
            // fill dialog with Sti Device Internal Names
            //

            if (pPtr == NULL) {
                //
                // could not find any devices
                //
                wsprintf(pszStr1,"%s","No Sti devices found!");
                iIndex = SendDlgItemMessage(hDlg,IDC_COMPLIANCE_DEV_NAME,
                    LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            } else {
                for (;pPtr->szLocalName;) {
                    //
                    // convert UNICODE string to ANSI
                    //
                    wsprintf(pszStr1,"%ls",pPtr->szLocalName);
                    iIndex = SendDlgItemMessage(hDlg,IDC_COMPLIANCE_DEV_NAME,
                        LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);

                    if (pPtr->pNext)
                        pPtr = pPtr->pNext;
                    else
                        break;
                }
            }

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
    }
    return FALSE;
}


/******************************************************************************
    BOOL FAR PASCAL Settings(HWND,UINT,WPARAM,LPARAM)
        Miscellaneous settings dialog

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL Settings(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    int     iIndex;
    int     iMC[] = { 0,1,10,100,200,300,-1 };
    int     iTN[] = { 1,2,5,10,20,30,-1 };
    int     iTS[] = { 10,20,30,60,120,-1 };

    switch (msg) {

        case WM_INITDIALOG:

            //
            // fill the comboboxes
            //
            for (iIndex = 0;iMC[iIndex] != -1;iIndex++) {
                _itoa(iMC[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_MAX_SCAN,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            for (iIndex = 0;iTN[iIndex] != -1;iIndex++) {
                _itoa(iTN[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            for (iIndex = 0;iTS[iIndex] != -1;iIndex++) {
                _itoa(iTS[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }

            //
            // set the combobox to the current setttings
            //
            for (iIndex = 0;iMC[iIndex] != -1;iIndex++) {
                if (nMaxCount == iMC[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_MAX_SCAN,CB_SETCURSEL,iIndex,0);
            for (iIndex = 0;iTN[iIndex] != -1;iIndex++) {
                if (nTimeNext == iTN[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,CB_SETCURSEL,iIndex,0);
            for (iIndex = 0;iTS[iIndex] != -1;iIndex++) {
                if (nTimeScan == iTS[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,CB_SETCURSEL,iIndex,0);

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    iIndex = SendDlgItemMessage(hDlg,IDC_MAX_SCAN,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_MAX_SCAN,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTMax = atoi(pszStr1);

                    iIndex = SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTNext = atoi(pszStr1);

                    iIndex = SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTScan = atoi(pszStr1);

                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }

    }
    return FALSE;
}


/******************************************************************************
  BOOL SizeDiff(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Output redraw handler when window size changes.
******************************************************************************/
BOOL SizeDiff(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    RECT rcClient;


    GetClientRect(hWnd,&rcClient);
    SetWindowPos(hLogWindow,NULL,0,0,
        rcClient.right+(GetSystemMetrics(SM_CXBORDER)*2),
        rcClient.bottom+(GetSystemMetrics(SM_CXBORDER)*2),
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL HScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Horizontal scroll handler.
******************************************************************************/
BOOL HScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int iHscrollInc;


    switch (LOWORD (wParam))
    {
    case SB_LINEUP :
        iHscrollInc = -1 ;
        break ;

    case SB_LINEDOWN :
        iHscrollInc = 1 ;
        break ;

    case SB_PAGEUP :
        iHscrollInc = -8 ;
        break ;

    case SB_PAGEDOWN :
        iHscrollInc = 8 ;
        break ;

    case SB_THUMBPOSITION :
        iHscrollInc = HIWORD(wParam) - iHscrollPos ;
        break ;

    default :
        iHscrollInc = 0 ;
    }
    iHscrollInc = max (-iHscrollPos,
        min (iHscrollInc, iHscrollMax - iHscrollPos)) ;

    if (iHscrollInc != 0)
    {
        iHscrollPos += iHscrollInc ;
        ScrollWindow (hWnd, -cxChar * iHscrollInc, 0, NULL, NULL) ;
        SetScrollPos (hWnd, SB_HORZ, iHscrollPos, TRUE) ;
    }
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL VScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Vertical scroll handler.
******************************************************************************/
BOOL VScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int iVscrollInc;


    switch (LOWORD (wParam))
    {
    case SB_TOP :
        iVscrollInc = -iVscrollPos ;
        break ;

    case SB_BOTTOM :
        iVscrollInc = iVscrollMax - iVscrollPos ;
        break ;

    case SB_LINEUP :
        iVscrollInc = -1 ;
        break ;

    case SB_LINEDOWN :
        iVscrollInc = 1 ;
        break ;

    case SB_PAGEUP :
        iVscrollInc = min (-1, -cyClient / cyChar) ;
        break ;

    case SB_PAGEDOWN :
        iVscrollInc = max (1, cyClient / cyChar) ;
        break ;

    case SB_THUMBTRACK :
        iVscrollInc = HIWORD (wParam) - iVscrollPos ;
        break ;

    default :
        iVscrollInc = 0 ;
    }
    iVscrollInc = max (-iVscrollPos,
        min (iVscrollInc, iVscrollMax - iVscrollPos)) ;

    if (iVscrollInc != 0)
    {
        iVscrollPos += iVscrollInc ;
        ScrollWindow (hWnd, 0, -cyChar * iVscrollInc, NULL, NULL) ;
        SetScrollPos (hWnd, SB_VERT, iVscrollPos, TRUE) ;
        UpdateWindow (hWnd) ;
    }
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL Creation(HWND,UINT,WPARAM,LPARAM)

  Initialization and global allocation.
  Return 0 to continue creation of window, -1 to quit
******************************************************************************/
BOOL Creation(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    TEXTMETRIC  tm;
    RECT        rRect;
    HDC         hDC;


    // seed random generator
    srand((unsigned)time(NULL));

    // create the 5 display and utility strings
    if (! ((hLHand[0] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszOut = (PSTR) LocalLock(hLHand[0]))))
        return -1;
    if (! ((hLHand[1] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr2 = (PSTR) LocalLock(hLHand[1]))))
        return -1;
    if (! ((hLHand[2] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr1 = (PSTR) LocalLock(hLHand[2]))))
        return -1;
    if (! ((hLHand[3] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr3 = (PSTR) LocalLock(hLHand[3]))))
        return -1;
    if (! ((hLHand[4] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr4 = (PSTR) LocalLock(hLHand[4]))))
        return -1;

    // create output display window
    hDC = GetDC(hWnd);
    GetTextMetrics(hDC,&tm);

    cxChar = tm.tmAveCharWidth ;
    cxCaps = (tm.tmPitchAndFamily & 1 ? 3 : 2) * cxChar / 2 ;
    cyChar = tm.tmHeight + tm.tmExternalLeading ;
    iMaxWidth = 40 * cxChar + 22 * cxCaps ;

    ReleaseDC(hWnd,hDC);

    GetClientRect(hWnd,&rRect);

    if (NULL == (hLogWindow = CreateWindow("LISTBOX",NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL |
        LBS_NOINTEGRALHEIGHT | LBS_NOSEL,
        0,0,rRect.right,rRect.bottom,hWnd,NULL,
        (HINSTANCE)GetWindowLong(hWnd,GWL_HINSTANCE),NULL)))
        return -1;

    // create the DIB to display scanned image
    CreateScanDIB(hWnd);

    // return 0 to continue creation of window
    return 0;
}


/******************************************************************************
  BOOL Destruction(HWND,UINT,WPARAM,LPARAM)

  Current instance termination routines.
  Free error message buffer, send destroy window message.
  Note that if Creation() fails, pszMessage is 0.
******************************************************************************/
BOOL Destruction(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int     x;  // loop counter


    LoadString(hThisInstance,IDS_PRIVINI,pszStr2,LONGSTRING);
    LoadString(hThisInstance,IDS_PRIVSECTION,pszStr1,LONGSTRING);

    // save window location
    SaveFinalWindow(hThisInstance,hWnd,pszStr2,pszStr1);

    // free the 5 display and utility strings
    for (x = 0;x < 5;x++)
    {
        LocalUnlock(hLHand[x]);
        LocalFree(hLHand[x]);
    }

    // delete the DIB object
    DeleteScanDIB();

    // free the output and main windows
    DestroyWindow(hLogWindow);
    DestroyWindow(hWnd);

    // always return 0
    return 0;
}


/******************************************************************************
  BOOL OnDeviceChange(HWND,UINT,WPARAM,LPARAM)

******************************************************************************/

const   CHAR    cszStiBroadcastPrefix[] = TEXT("STI");

BOOL OnDeviceChange(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    struct _DEV_BROADCAST_USERDEFINED *pBroadcastHeader;

    if (wParam == DBT_USERDEFINED ) {

        pBroadcastHeader = (struct _DEV_BROADCAST_USERDEFINED *)lParam;

        __try {

            if (pBroadcastHeader &&
                (pBroadcastHeader->dbud_dbh.dbch_devicetype == DBT_DEVTYP_OEM) &&
                (_strnicmp(pBroadcastHeader->dbud_szName,cszStiBroadcastPrefix,lstrlen(cszStiBroadcastPrefix)) == 0)
                ) {

                //
                // Got STI device broadcast
                //

                DisplayOutput("Received STI device broadcast with message:%s  ",
                              pBroadcastHeader->dbud_szName + lstrlen(cszStiBroadcastPrefix));

            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            ::GetExceptionCode();
        }

    }

    return FALSE;
}


/******************************************************************************
  BOOL FirstInstance(HANDLE)

  Register the window.
  Return TRUE/FALSE on success/failure.
******************************************************************************/
BOOL FirstInstance(HINSTANCE hInst)
{
   PWNDCLASS    pClass;
   PSTR         pszClass;


    if (! (pszClass = (PSTR) LocalAlloc(LPTR, LONGSTRING)))
        return FALSE;
    LoadString((HINSTANCE)hInst, IDS_CLASSNAME, pszClass, LONGSTRING);

    pClass = (PWNDCLASS) LocalAlloc(LPTR, sizeof(WNDCLASS));

    // set hbrBackground to 0 for no background (app draws background)
    // use COLOR_BACKGROUND+1 for desktop color
    pClass->style          = CS_HREDRAW | CS_VREDRAW;
    pClass->lpfnWndProc    = WiskProc;
    pClass->cbClsExtra     = 0;
    pClass->cbWndExtra     = 0;
    pClass->hInstance      = (HINSTANCE)hInst;
    pClass->hIcon          = LoadIcon((HINSTANCE)hInst, MAKEINTRESOURCE(IDI_STI));
    pClass->hCursor        = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
    pClass->hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1);
    pClass->lpszMenuName   = NULL;
    pClass->lpszClassName  = (LPSTR) pszClass;

    if (! (RegisterClass((LPWNDCLASS) pClass)))
        return FALSE;

    LocalFree((HANDLE) pClass);
    LocalFree((HANDLE) pszClass);

    return TRUE;
}


/******************************************************************************
  HWND MakeWindow(HANDLE)

  Create a window for current instance.
  Return handle to window (which is 0 on failure)
******************************************************************************/
HWND MakeWindow(HINSTANCE hInst)
{
    HWND    hWindow;
    PSTR    pszA,pszB;
    RECT    rect;
    DWORD   dwError;


    // if we can't get string memory, shut down app
    if (pszA = (PSTR) LocalAlloc(LPTR, LONGSTRING))
    {
        if (! (pszB = (PSTR) LocalAlloc(LPTR, LONGSTRING)))
        {
            LocalFree((HANDLE) pszA);
            return FALSE;
        }
    }
    else
        return FALSE;

    // get the caption, classname
    LoadString(hInst, IDS_PRIVINI, pszA, LONGSTRING);
    LoadString(hInst, IDS_PRIVSECTION, pszB, LONGSTRING);

    GetFinalWindow(hInst,&rect,pszA,pszB);

    LoadString(hInst,IDS_CAPTION,pszA,LONGSTRING);
    LoadString(hInst,IDS_CLASSNAME,pszB,LONGSTRING);

    hWindow = CreateWindow((LPSTR) pszB,
        (LPSTR) pszA,
        WS_OVERLAPPEDWINDOW,
        rect.left,
        rect.top,
        rect.right,
        rect.bottom,
        (HWND) NULL,
        0,
        hInst,
        NULL);

    if (hWindow == 0)
        dwError = GetLastError();

    // Save Instance globally
    hThisInstance = hInst;

    LocalFree((HANDLE) pszB);
    LocalFree((HANDLE) pszA);

    return hWindow;
}


/******************************************************************************
  void DisplayOutput(LPSTR pString,...)

  Show text on the display window
******************************************************************************/
void DisplayOutput(LPSTR pString,...)
{
    char    Buffer[512];
    MSG     msg;
    int     iIndex;
    va_list list;


    va_start(list,pString);
    vsprintf(Buffer,pString,list);

    if (ulCount1++ == MAX_LOOP)
    {
        ulCount1 = 1;
        ulCount2++;
        SendMessage(hLogWindow,LB_RESETCONTENT,0,0);
    }

    iIndex = SendMessage(hLogWindow,LB_ADDSTRING,0,(LPARAM)Buffer);
    SendMessage(hLogWindow,LB_SETCURSEL,iIndex,(LPARAM)MAKELONG(FALSE,0));

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UpdateWindow(hLogWindow);
}


/******************************************************************************
  void LogOutput(int,LPSTR pString,...)

  Show text on the display window
******************************************************************************/
void LogOutput(int nVerbose,LPSTR pString,...)
{
    char    Buffer[512];
    MSG     msg;
    int     iIndex;
    va_list list;


    va_start(list,pString);
    vsprintf(Buffer,pString,list);

    if (ulCount1++ == MAX_LOOP)
    {
        ulCount1 = 1;
        ulCount2++;
        SendMessage(hLogWindow,LB_RESETCONTENT,0,0);
    }

    iIndex = SendMessage(hLogWindow,LB_ADDSTRING,0,(LPARAM)Buffer);
    SendMessage(hLogWindow,LB_SETCURSEL,iIndex,(LPARAM)MAKELONG(FALSE,0));

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UpdateWindow(hLogWindow);
}


/*****************************************************************************
    void StiDisplayError(HRESULT,char *,BOOL)
        Display verbose error information

    Parameters:
        HRESULT from failed call
        failed call title string
        BOOL TRUE to record error, else ignore it


    Return:
        none

*****************************************************************************/
void FatalError(char *szMsg)
{
    DisplayOutput(szMsg);
    DisplayOutput("* FATAL ERROR CANNOT CONTINUE *");

    return;
}


/******************************************************************************
  void DisplayLogPassFail(BOOL bPass)


******************************************************************************/
void DisplayLogPassFail(BOOL bPass)
{
    if (bPass)
        sprintf(pszStr1,"  PASS");
    else
        sprintf(pszStr1,"  FAIL");
    DisplayOutput(pszStr1);
    DisplayOutput("");
    tlLog(hNTLog,TL_LOG,pszStr1);
}


/******************************************************************************
  BOOL ParseCmdLine(LPSTR lpCmdLine)

  Parse the command line for valid options

  Return TRUE if an automated test was selected, else FALSE
******************************************************************************/
BOOL ParseCmdLine(LPSTR lpCmdLine)
{
    int     nAnyTest = 0,
            nInfFile = 0,
            nLogFile = 0,
            nWLogFile = 0,
            next;
    char    *pArg,
            *szPtr,
            szTmpBuf[LONGSTRING];


    if (*lpCmdLine) {
        DisplayOutput("Command line: \"%s\"",lpCmdLine);
        DisplayOutput("");
    }

    for (pArg = lpCmdLine;*pArg;)
    {
        next = NextToken(szTmpBuf,pArg);
        pArg += next;

        // remove the common command line separators (if present)
        if (szTmpBuf[0] == '/' || szTmpBuf[0] == '-')
            strcpy(szTmpBuf,(szTmpBuf + 1));

        // upper case our parameter
        for (szPtr = &szTmpBuf[0];*szPtr;szPtr++)
            *szPtr = toupper(*szPtr);

        // Look for other switches
        switch(szTmpBuf[0])
        {
        case '?':
        case 'H':
            if (! nAnyTest) {
                // request for help
                if ((! strncmp("?",szTmpBuf,strlen(szTmpBuf)) ||
                    (! strncmp("HELP",szTmpBuf,strlen(szTmpBuf))))) {
                    pSuite = nHelpSuite;
                    nMaxCount = 1;
                    nAnyTest = 1;
                }
            }
            break;
        case 'C':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("COMPLIANCE",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nComplianceSuite;
                    nMaxCount = 3;
                    nTimeScan = 10;
                    nTimeNext = 1;
                    nAnyTest = 1;

                    // get handle to the compliance menu
                    hMenu = LoadMenu(hThisInstance,
                        MAKEINTRESOURCE(IDR_STI_COMP));
                }
            }
            break;
        case 'E':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("ERRORLOG",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nErrorlogSuite;
                    nMaxCount = 1;
                    nTimeNext = 1;
                    nAnyTest = 1;
                }
            }
            // exit when test has run
            if (! strncmp("EXIT",szTmpBuf,strlen(szTmpBuf)))
                bExit = TRUE;
            break;
        case 'I':
            if (! nInfFile) {
                // read test instructions from an .INF file
                if (! strncmp("INF",szTmpBuf,strlen(szTmpBuf))) {
// inf file stuff
                    nInfFile = 1;
                }
            }
            break;
        case 'L':
            if (! nLogFile) {
                // write screen output to .LOG file
                if (! strncmp("LOG",szTmpBuf,strlen(szTmpBuf))) {
// log file stuff
                    nLogFile = 1;
                }
            }
            break;
        case 'N':
            // don't show COMPLIANCE test dialog
            if (! strncmp("NODIALOG",szTmpBuf,strlen(szTmpBuf)))
                bCompDiag = FALSE;
            break;
        case 'S':
            if (! nAnyTest) {
                // internal Sti SHIPCRIT test
                if (! strncmp("SHIPCRIT",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nShipcritSuite;
                    nMaxCount = 200;
                    nTimeScan = 10;
                    nTimeNext = 1;
                    nAnyTest = 1;
                }
            }
            // the application was launched by an Sti event!
            if (! (strncmp(STIEVENTARG,szTmpBuf, strlen(STIEVENTARG))) ||
                (! (strncmp(STIDEVARG,szTmpBuf, strlen(STIDEVARG))))) {
                nEvent = 1;
                MessageBox(NULL,szTmpBuf,"Stillvue",MB_OK);
            }
            break;
        case 'T':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("TEST",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nOutputSuite;
                    nMaxCount = 0;
                    nTimeNext = 1;
                    nAnyTest = 1;
                    nTimeMultiplier = 1;
                }
            }
            break;
        case 'W':
            if (! nWLogFile) {
                // write NTLOG output to STIWHQL.LOG file
                if (! strncmp("WHQL",szTmpBuf,strlen(szTmpBuf))) {
// log file stuff
                    nWLogFile = 1;
                }
            }
            break;
        default:
            break;
        }
    }

    if (nAnyTest)
        return TRUE;
    else
        return FALSE;
}


/******************************************************************************
  int PASCAL WinMain(HANDLE,HANDLE,LPSTR,short)

  The app itself.
******************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    MSG     msg;                        // message passing structure
    HWND    hWnd;                       // Handle to main window
    HMENU   hMenuPopup;                 // add ports to PORT menu


    // exit if registration and window creation fail
    if (! FirstInstance (hInstance))
       return FALSE;

    // Can't create window? Bail out
    if (! (hWnd = MakeWindow (hInstance)))
        return FALSE;

    ShowWindow(hWnd,nCmdShow);

    // save instance
    hThisInstance = hInstance;

    // initialize NT Logging
    NTLogInit();

    // display name of this app
    LoadString(hThisInstance,IDS_APPNAME,pszOut,LONGSTRING);
    LoadString(hThisInstance,IDS_CAPTION,pszStr2,LONGSTRING);
    wsprintf(pszStr1,"%s - %s",pszOut,pszStr2);
    DisplayOutput(pszStr1);

    // display last run statistics
    {
        int     nCount,
                nScan,
                nError;


        LoadString(hThisInstance,IDS_PRIVINI,pszStr3,LONGSTRING);
        LoadString(hThisInstance,IDS_PRIVSECTION,pszStr4,LONGSTRING);

        nCount = GetPrivateProfileInt(pszStr4,"Last count",0,pszStr3);
        nScan  = GetPrivateProfileInt(pszStr4,"Last scan",0,pszStr3);
        nError = GetPrivateProfileInt(pszStr4,"Last error",0,pszStr3);

        wsprintf(pszStr1,
            "Last run was %d loops (%d scans and %d errors)",
            nCount,nScan,nError);
        DisplayOutput(pszStr1);
    }

    // get handle to the standard menu
    hMenu = LoadMenu(hThisInstance, MAKEINTRESOURCE(IDR_STI_LAB));

    // parse the command line
    bAuto = ParseCmdLine(lpCmdLine);

    // start test timer if automated test on command line
    if (bAuto)
    {
        bAuto = StartAutoTimer(hWnd);
    }

    // start Sti event handler if an Sti event launched us
    if (nEvent)
    {
        BOOL    bReturn;


        StiCreateInstance(&bReturn);
        StiEnum(&bReturn);
        StiEvent(hWnd);
        // select the device that called the event
        StiSelect(hWnd,EVENT,&bReturn);
    }

    // load the selected menu
    hMenuPopup = CreateMenu();
    SetMenu(hWnd, hMenu);

    while (GetMessage(&msg,(HWND) NULL,0,0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}


/******************************************************************************
  long FAR PASCAL WiskProc(HWND,UINT,WPARAM,LPARAM)

  The main exported procedure.
******************************************************************************/
long FAR PASCAL WiskProc(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    switch (wMsgID)
    {
        case WM_COMMAND:
            return CommandParse(hWnd,wMsgID,wParam,lParam);

        case WM_TIMER:
            return TimerParse(hWnd,wMsgID,wParam,lParam);

        case WM_SIZE:
            return SizeDiff(hWnd,wMsgID,wParam,lParam);

        case WM_HSCROLL:
            return HScroll(hWnd,wMsgID,wParam,lParam);

        case WM_VSCROLL:
            return VScroll(hWnd,wMsgID,wParam,lParam);

        case WM_CLOSE:
            EndTest(hWnd,0);
            return Destruction(hWnd,wMsgID,wParam,lParam);

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0L;

        case WM_CREATE:
            return Creation(hWnd,wMsgID,wParam,lParam);

        case WM_DEVICECHANGE:
            return OnDeviceChange(hWnd,wMsgID,wParam,lParam);

        default:
            return DefWindowProc(hWnd,wMsgID,wParam,lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\stivar.h ===
/******************************************************************************

  stivar.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "resource.h"

//
// reset listbox window display after this many iterations
//
#define MAX_LOOP 16383

//
// INF defines
//
#define INFBUFSIZ                   0x8000      // assume 32k for largest INF

//
// available test suites
//

#define NONE                        500         // no test suite selected
#define HELP                        501         // display help
#define COMPLIANCE                  502         // external compliance suite
#define SHIPCRIT                    503         // internal compliance suite
#define ERRORLOG                    504         // big error log test
#define TEST                        505         // test test

//
// Sti service tests
//
enum TimedTests {
    // open iStillImage interface
    tCreateInstance,
    // IStillImage interface
    tGetDeviceList,
    tCreateDevice,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    // variation
    tWriteToErrorLogBig,
    tReleaseSti,
    // IStillDevice interface
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tGetCapabilities,
    tDeviceReset,
    tDiagnostic,
    tGetLastInfoError,
    tSubscribe,
    tUnSubscribe,
    tEscapeA,
    tEscapeB,
    tRawReadDataA,
    tRawReadDataB,
    tRawWriteDataA,
    tRawWriteDataB,
    tRawReadCommandA,
    tRawReadCommandB,
    tRawWriteCommandA,
    tRawWriteCommandB,
    tReleaseDevice,
    // select a device name
    tSelectDeviceName,
    // Scan (if HP SCL device)
    tAcquire,
    // help request
    tHelp,
    // Beginning of test pass initialization
    tBeginningOfTest,
    // output test
    tTest,
    // End of test pass summary
    tEndOfTest
} tLabTests;

//
// display help
//
int nHelpSuite[] = {
    HELP,
    tBeginningOfTest,
    tHelp,
    tEndOfTest,
    -1
};

//
// external Sti Compliance tests
//
int nComplianceSuite[] = {
    COMPLIANCE,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tCreateDevice,
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tDiagnostic,
    tGetDeviceValue,
    tGetCapabilities,
    tGetLastInfoError,
//  tSubscribe,
//  tUnSubscribe,
    tDeviceReset,
    tEscapeA,
    tRawReadDataA,
    tRawWriteDataA,
    tRawReadCommandA,
    tRawWriteCommandA,
    tReleaseDevice,
    tReleaseSti,
    tEndOfTest,
    -1
};

//
// internal Sti Compliance tests
//
int nShipcritSuite[] = {
    SHIPCRIT,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tSelectDeviceName,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    tCreateDevice,
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tDiagnostic,
    tDeviceReset,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    tGetCapabilities,
    tGetLastInfoError,
//  tSubscribe,
//  tUnSubscribe,
    tEscapeA,
    tRawReadDataA,
    tRawWriteDataA,
    tRawReadCommandA,
    tRawWriteCommandA,
    tAcquire,
    tReleaseDevice,
    tReleaseSti,
    tEndOfTest,
    -1
};


//
// big Error log tests
//
int nErrorlogSuite[] = {
    ERRORLOG,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tSelectDeviceName,
    tWriteToErrorLogBig,
    tReleaseSti,
    tEndOfTest,
    -1
};


//
// test tests
//
int nOutputSuite[] = {
    TEST,
    tBeginningOfTest,
    tTest,
    tEndOfTest,
    -1
};


//
// Test Suite test strings
//
STRINGTABLE StSuiteStrings[] =
{
    tCreateInstance, "Create Instance",0,
    tGetDeviceList, "Get Device List",0,
    tCreateDevice, "Create Device",0,
    tGetDeviceInfo, "Get Device Info",0,
    tGetDeviceValue, "Get Device Value",0,
    tSetDeviceValue, "Set Device Value",0,
    tRegisterLaunchApplication, "Register Launch Application",0,
    tUnRegisterLaunchApplication, "UnRegister Launch Application",0,
    tEnableHwNotifications, "Enable Hardware Notifications",0,
    tGetHwNotificationState, "Get Hardware Notification State",0,
    tWriteToErrorLog, "Write To Error Log (variation A)",0,
    tWriteToErrorLogBig, "Write to Error Log (variation B)",0,
    tReleaseSti, "Release Sti subsystem",0,
    tGetStatusA, "Get Status (Online)",0,
    tGetStatusB, "Get Status (Event)",0,
    tGetStatusC, "Get Status (All)",0,
    tGetCapabilities, "Get Capabilities",0,
    tDeviceReset, "Device Reset",0,
    tDiagnostic, "Diagnostic",0,
    tGetLastInfoError, "Get Last Error Information",0,
    tSubscribe, "Subscribe",0,
    tUnSubscribe, "Unsubscribe",0,
    tEscapeA, "Escape (variation A)",0,
    tEscapeB, "Escape (variation B)",0,
    tRawReadDataA, "Raw Read Data (variation A)",0,
    tRawReadDataB, "Raw Read Data (variation B)",0,
    tRawWriteDataA, "Raw Write Data (variation A)",0,
    tRawWriteDataB, "Raw Write Data (variation B)",0,
    tRawReadCommandA, "Raw Read Command (variation A)",0,
    tRawReadCommandB, "Raw Read Command (variation B)",0,
    tRawWriteCommandA, "Raw Write Command (variation A)",0,
    tRawWriteCommandB, "Raw Write Command (variation B)",0,
    tReleaseDevice, "Release Device",0,
    tSelectDeviceName, "Select Device Name",0,
    tAcquire, "Acquire",0,
    tHelp, "Help",0,
    tBeginningOfTest, "Beginning of Test",0,
    tTest, "Test",0,
    tEndOfTest, "End of testing",0,
    0, "Unknown Test",-1
};


//
// timers
//
#define TIMER_ONE                   3001
#define TIMER_TWO                   3002


//
// GLOBAL VARIABLES
//

//
// global window handles
//
HINSTANCE   hThisInstance;              // current instance
HWND        hThisWindow;                // current window
HMENU       hMenu;                      // current menu

//
// general purpose strings
//
HGLOBAL     hLHand[5];                  // utility string handles
LPSTR       lpzString;                  // utility FAR string
PSTR        pszOut,                     // TextOut string
            pszStr1,                    // utility NEAR strings
            pszStr2,
            pszStr3,
            pszStr4;

//
// global test settings
//
BOOL        bAuto        = FALSE,        // TRUE = running an Automated test
            bCompDiag    = TRUE,         // TRUE = show COMPLIANCE test dialog
            bExit        = FALSE;        // TRUE = exit when test has completed
int         nError       = 0,            // number of errors
            nEvent       = 0,            // 1 = StiEvent, 2 = StiDevice
            nFatal       = 0,            // can't continue after this...
            nGo          = 0,            // 1 = nonstop timed test
            nHWState     = 0,            // current HWEnable state
            nICanScan    = 0,            // Stillvue can / can't scan this device
            nInATestSemaphore = 0,       // 1 = a test is running
            nInTimerSemaphore = 0,       // 1 = don't reenter TimerParse
            nLastLine    = 1,            // last line number in script
            nMaxCount    = 1,            // run test Suite this many times
            nNameOnly    = 0,            // 1 = select device name, not device
            nNextLine    = 1,            // next line of inf to run
            nNextTest    = 0,            // pointer to next test to run
            nPause       = 0,            // toggle for run (0) pause test (! 0)
            nRunInf      = 0,            // 0 = no INF, 1 = INF is loaded
            nRadix       = 10,           // base is decimal (or hex)
            nSaveLog     = 0,            // always write out log
            nScanCount   = 0,            // number of scans run so far
            nScriptLine  = 1,            // next script line to parse
            nTestCount   = 1,            // number of tests run so far
            nTestID      = 0,            // the current test ID
            nTimeMultiplier = 1000,      // multiply nTimeNext for seconds
            nTimeNext    = 5,            // wait time between timer in seconds
            nTimeState   = 0,            // 0 timer is off, 1 timer is on
            nTimeScan    = 60,           // wait nTimeNext units before next scan
            nTTMax       = 0,            // temp var
            nTTNext      = 0,            // temp var
            nTTScan      = 0,            // temp var
            nUnSubscribe = 0,            // 0 = UnSubscribe'd, 1 = Subscribed
            nUnSubscribeSemaphore = 0;   // semaphore for UnSubscribe
int         *pSuite      = nHelpSuite;   // pointer to test Suite to run
DWORD       dwLastError  = 0;            // last GetLastError found

//
// text display
//
HWND        hLogWindow;
ULONG       ulCount1,ulCount2;
int         cxChar,cxCaps,cyChar,cxClient,cyClient,iMaxWidth,
            iHscrollPos,iHscrollMax,
            iVscrollPos,iVscrollMax;

//
// inf, logfile, NT logging
//
HANDLE      hLog = NULL,                // output log file handle
            hDLog = NULL,               // display output log handle
            hNTLog = NULL;              // NT log handle
char        szInfName[LONGSTRING] = "", // input script file name
            szDLogName[LONGSTRING] = "",// display output log file name
            szWLogName[LONGSTRING] = "";// WHQL NTLOG output log file name
LPSTR       lpInf = NULL,               // buffer for INF commands
            lpLine;
DWORD       dwNTStyle;                  // NTLog style

//
// device logging
//
PDEVLOG     pdevPtr = NULL,             // pointer to current device log device
            pdevRoot = NULL;            // base of the device log table
PVOID       pInfoPrivate = NULL;        // private list of devices under test
PSTI_DEVICE_INFORMATION
            pInfoPrivatePtr = NULL;     // pointer to device in pStiBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\winx.h ===
/******************************************************************************

  winx.h
  Windows utility procedures

  Copyright (C) Microsoft Corporation, 1997 - 1997
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/


// macros
#define RANDBYTE(r)     LOBYTE(rand() % ((r)+1))

#ifdef _DEBUG
#define TRAP { _asm int 3 }
#else
#define TRAP {}
#endif

// stringtables
typedef struct _STRINGTABLE
{
    long    number;
    char    *szString;
    long    end;
} STRINGTABLE, *PSTRINGTABLE;

/*
STRINGTABLE StSample[] =
{
    0, "String zero",0,
    1, "String one",0,
    0, "",-1
};

Retrieve strings associated with unique values:
  strString = StrFromTable(nValue,&StSample);

*/
extern STRINGTABLE StWinerror[];

// prototypes
ULONG   atox(LPSTR);
void    DisplayDebug(LPSTR sz,...);
BOOL    ErrorMsg(HWND,LPSTR,LPSTR,BOOL);
BOOL    fDialog(int,HWND,FARPROC);
void    FormatHex(unsigned char *,char *);
BOOL    GetFinalWindow (HANDLE,LPRECT,LPSTR,LPSTR);
BOOL    LastError(BOOL);
int     NextToken(char *,char *);
BOOL    SaveFinalWindow (HANDLE,HWND,LPSTR,LPSTR);
char *  StrFromTable(long,PSTRINGTABLE);
BOOL    Wait32(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\addremove.cpp ===
// AddRemove.cpp : implementation file
//

#include "stdafx.h"
#include "wialogcfg.h"
#include "AddRemove.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddRemove dialog


CAddRemove::CAddRemove(CWnd* pParent /*=NULL*/)
	: CDialog(CAddRemove::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddRemove)
	m_NewKeyName = _T("");
	m_StatusText = _T("");
	//}}AFX_DATA_INIT
}


void CAddRemove::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddRemove)
	DDX_Text(pDX, IDC_EDIT_KEYNAME, m_NewKeyName);
	DDX_Text(pDX, IDC_STATUS_TEXT, m_StatusText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRemove, CDialog)
	//{{AFX_MSG_MAP(CAddRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddRemove message handlers

void CAddRemove::OnOK() 
{
	UpdateData(TRUE);
	if(m_NewKeyName.IsEmpty()) {
		MessageBox("Please enter a Module Name, or\npress 'Cancel' to exit.",m_szTitle,MB_ICONERROR|MB_OK);
	} else {
		CDialog::OnOK();
	}
}

void CAddRemove::SetTitle(TCHAR *pszDlgTitle)
{
	lstrcpy(m_szTitle,pszDlgTitle);
}

void CAddRemove::SetStatusText(TCHAR *pszStatusText)
{
	m_StatusText = pszStatusText;
}

BOOL CAddRemove::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	SetWindowText(m_szTitle);
	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddRemove::GetNewKeyName(TCHAR *pszNewKeyName)
{
	lstrcpy(pszNewKeyName,m_NewKeyName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\wsti.cpp ===
/******************************************************************************

  wsti.cpp
  WDM Still Imaging interface

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "stillvue.h"

//
// globals defined in Stivar.h
//
extern  PDEVLOG         pdevPtr,                   // pointer to current device log device
pdevRoot;                  // base of the device log table
extern  PSTR            pszStr1,pszStr2,pszStr3,   // utility strings
pszStr4;
extern  HINSTANCE       hThisInstance;             // instance of this app
extern  HANDLE  hNTLog;                            // NT log handle
extern  HMENU           hMenu;                     // current menu
extern  int             *pSuite;                   // pointer to test Suite to run
extern  int             nError, nICanScan,         // global flags
nNextTest,                 // index into pSuite
nNameOnly, nScanCount,
nTestID,
nUnSubscribeSemaphore,     // semaphore for StiSubscribe
nUnSubscribe;              // flag to request UnSubscribe

//
// STI.H - STI_DEVICE_MJ_TYPE
//
STRINGTABLE StStiDeviceType[] =
{
    0, "StiDeviceTypeDefault",0,
    1, "StiDeviceTypeScanner",0,
    2, "StiDeviceTypeDigitalCamera",0,
    0, "Unknown device type",-1
};

//
// STIERR.H - errors
//
STRINGTABLE StStiError[] =
{
    STI_OK,                     "STI_OK",0,
    STI_NOTCONNECTED,           "STI_NOTCONNECTED",0,
    STI_CHANGENOEFFECT,         "STI_CHANGENOEFFECT",0,
    STIERR_OLD_VERSION,         "STIERR_OLD_VERSION",0,
    STIERR_BETA_VERSION,        "STIERR_BETA_VERSION",0,
    STIERR_BADDRIVER,           "STIERR_BADDRIVER",0,
    STIERR_DEVICENOTREG,        "STIERR_DEVICENOTREG",0,
    STIERR_OBJECTNOTFOUND,      "STIERR_OBJECTNOTFOUND",0,
    STIERR_INVALID_PARAM,       "STIERR_INVALID_PARAM",0,
    STIERR_NOINTERFACE,         "STIERR_NOINTERFACE",0,
    STIERR_GENERIC,             "STIERR_GENERIC", 0,
    STIERR_OUTOFMEMORY,         "STIERR_OUTOFMEMORY", 0,
    STIERR_UNSUPPORTED,         "STIERR_UNSUPPORTED", 0,
    STIERR_NOT_INITIALIZED,     "STIERR_NOT_INITIALIZED", 0,
    STIERR_ALREADY_INITIALIZED, "STIERR_ALREADY_INITIALIZED", 0,
    STIERR_DEVICE_LOCKED,       "STIERR_DEVICE_LOCKED", 0,
    STIERR_READONLY,            "STIERR_READONLY", 0,
    STIERR_NOTINITIALIZED,      "STIERR_NOTINITIALIZED", 0,
    STIERR_NEEDS_LOCK,          "STIERR_NEEDS_LOCK", 0,
    STIERR_SHARING_VIOLATION,   "STIERR_SHARING_VIOLATION", 0,
    STIERR_HANDLEEXISTS,        "STIERR_HANDLEEXISTS", 0,
    STIERR_INVALID_DEVICE_NAME, "STIERR_INVALID_DEVICE_NAME", 0,
    STIERR_INVALID_HW_TYPE,     "STIERR_INVALID_HW_TYPE", 0,
    STIERR_INVALID_HW_TYPE,     "STIERR_INVALID_HW_TYPE", 0,
    STIERR_NOEVENTS,            "STIERR_NOEVENTS", 0,
    0, "Unknown STI error",-1
};

//
// WINNT.H -  Predefined Value Types.
//
STRINGTABLE StRegValType[] =
{
    0, "REG_NONE",0,
    1, "REG_SZ",0,
    3, "REG_BINARY",0,
    4, "REG_DWORD",0,
    0, "Unknown reg type",-1
};

//
// global still image
//
PSTI                    pSti = NULL;        // handle to Sti subsystem
PVOID                   pStiInfo = NULL;    // Sti device info buffer
PSTI_DEVICE_INFORMATION pStiInfoPtr = NULL; // pointer to device in pStiBuffer
PSTIDEVICE              pStiDevice = NULL;  // Sti device being used
HANDLE                  hWaitEvent;         // Subscribe Event handle
int                     nStiNumber = 0;     // 0 based index into pStiInfo
DWORD                   dwStiTotal = 0;     // total number of Sti devices found
WCHAR                   szInternalName[STI_MAX_INTERNAL_NAME_LENGTH];
// user selected Sti device name
WCHAR                   szFriendlyName[STI_MAX_INTERNAL_NAME_LENGTH];
// user selected Sti friendly name


/*****************************************************************************

        define ACQUIRE to load device specific command handler for stub
        functions defined in STIDDK.CPP

*****************************************************************************/
#ifdef ACQUIRE
//
// device specific image acquire code
//
    #include "acquire.cpp"

#else
//
// only exercise Sti services
//
    #include "stisvc.cpp"

#endif


/*****************************************************************************
    void IStillImageMenu(DWORD dwState)
        Enable or Disable the menus for the IStillDevice interface.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillImageMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,         dwState);
    EnableMenuItem(hMenu, IDM_GET_DEVLIST,           dwState);
    EnableMenuItem(hMenu, IDM_CREATE_DEV,            dwState);
    EnableMenuItem(hMenu, IDM_REGISTER_LAUNCH,       dwState);
    EnableMenuItem(hMenu, IDM_UNREGISTER_LAUNCH,     dwState);
    EnableMenuItem(hMenu, IDM_WRITE_ERRORLOG,        dwState);
}


/*****************************************************************************
    void IStillNameMenu(DWORD dwState)
        Enable or Disable the menus for the IStillImage interface that only
                require a device name.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillNameMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_GET_DEVINFO,        dwState);
    EnableMenuItem(hMenu, IDM_GET_DEVVAL,         dwState);
    EnableMenuItem(hMenu, IDM_SET_DEVVAL,         dwState);
    EnableMenuItem(hMenu, IDM_GET_LAUNCHINFO,     dwState);
    EnableMenuItem(hMenu, IDM_ENABLE_HWNOTIF,     dwState);
    EnableMenuItem(hMenu, IDM_GET_HWNOTIF,        dwState);
    EnableMenuItem(hMenu, IDM_REFRESH_DEVBUS,     dwState);
    EnableMenuItem(hMenu, IDM_LAUNCH_APP_FOR_DEV, dwState);
    EnableMenuItem(hMenu, IDM_SETUP_DEVPARAMS,    dwState);
}


/*****************************************************************************
    void IStillDeviceMenu(DWORD dwState)
        Enable or Disable the menus for the IStillDevice interface.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillDeviceMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_GET_CAPS,           dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_A,       dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_B,       dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_C,       dwState);
    EnableMenuItem(hMenu, IDM_DEVICERESET,        dwState);
    EnableMenuItem(hMenu, IDM_DIAGNOSTIC,         dwState);
    EnableMenuItem(hMenu, IDM_ESCAPE_A,           dwState);
    EnableMenuItem(hMenu, IDM_ESCAPE_B,           dwState);
    EnableMenuItem(hMenu, IDM_GET_LASTERRINFO,    dwState);
    EnableMenuItem(hMenu, IDM_LOCKDEV,            dwState);
    EnableMenuItem(hMenu, IDM_UNLOCKDEV,          dwState);
    EnableMenuItem(hMenu, IDM_RAWREADDATA_A,      dwState);
    EnableMenuItem(hMenu, IDM_RAWREADDATA_B,      dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITEDATA_A,     dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITEDATA_B,     dwState);
    EnableMenuItem(hMenu, IDM_RAWREADCOMMAND_A,   dwState);
    EnableMenuItem(hMenu, IDM_RAWREADCOMMAND_B,   dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITECOMMAND_A,  dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITECOMMAND_B,  dwState);
    EnableMenuItem(hMenu, IDM_SUBSCRIBE,          dwState);
    EnableMenuItem(hMenu, IDM_UNSUBSCRIBE,        dwState);
    EnableMenuItem(hMenu, IDM_DEVICE_RELEASE,     dwState);
}


/*****************************************************************************
    void IStillScanMenu(DWORD dwState)
        Enable or Disable the menus for scanning.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillScanMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_LAMPON,   dwState);
    EnableMenuItem(hMenu, IDM_LAMPOFF,  dwState);
    EnableMenuItem(hMenu, IDM_SCAN,             dwState);
}


/*****************************************************************************
    int NextStiDevice()
        Select next valid Sti device

    Parameters:
        none

    Return:
        number of next sti device (0 == first)

*****************************************************************************/
int NextStiDevice()
{
    //
    // select next device from static list (go to first at end of list)
    //
    nStiNumber++;

    if ( nStiNumber >= (int) dwStiTotal ) {
        //
        // point to head of list
        //
        nStiNumber = 0;
    }

    //
    // select next device from device log (go to first at end of list)
    //
    if ( pdevPtr->pNext ) {
        pdevPtr = pdevPtr->pNext;
    } else {
        //
        // point to head of list
        //
        pdevPtr = pdevRoot;
    }

    return nStiNumber;
}


/*****************************************************************************
    HRESULT StiCreateInstance(BOOL *)
        Opens Sti subsystem

    Parameters:
        Pointer to receive PASS/FAIL status

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiCreateInstance(BOOL *bPass)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // close any open devices before enumeration
    //
    StiClose(&bReturn);

    //
    // The StiCreateInstance interface locates the primary still image interface.
    // Use this call to optain the pointer to the IStillImage interface.
    //
    hres = StiCreateInstance(
                            GetModuleHandle(NULL),  // instance handle of this application
                            STI_VERSION,            // Sti version
                            &pSti,                  // pointer to IStillImage interface
                            NULL                    // pointer to controlling unknown of OLE aggregation
                            );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"StiCreateInstance",TRUE);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;
    DisplayOutput(" The Sti subsystem is opened");
    DisplayOutput("");

    //
    // Enable the menu items for IStillImage interface calls available
    //
    IStillImageMenu(MF_ENABLED);
    EnableMenuItem(hMenu, IDM_CREATE_INSTANCE,       MF_GRAYED);

    return (hres);
}


/*****************************************************************************
    HRESULT StiClose(BOOL *)
        Close any open devices and Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiClose(BOOL *bPass)
{
    HRESULT hres = STI_OK;


    *bPass = TRUE;

    // stop subscribing
    nUnSubscribe = 0;

    // close any open devices and then close Sti subsystem
    hres = StiDeviceRelease(bPass);
    hres = StiImageRelease(bPass);

    //
    // clear the internal device name and the friendly user name
    //
    ZeroMemory(szInternalName,STI_MAX_INTERNAL_NAME_LENGTH);
    ZeroMemory(szFriendlyName,STI_MAX_INTERNAL_NAME_LENGTH);

    return (hres);
}


/*****************************************************************************
    HRESULT StiDeviceRelease(BOOL *)
        Close the Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiDeviceRelease(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;


    *bPass = TRUE;

    //
    // Need to UnSuscribe if the semaphore is set.
    //
    if ( nUnSubscribeSemaphore ) {
        //
        // clear the semaphores
        //
        nUnSubscribe = nUnSubscribeSemaphore = 0;

        // UnSubscribe is called when an application no longer wants to receive
        // events from a device.
        //
        hres = pStiDevice->UnSubscribe();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"UnSubscribe",TRUE);
            hError = hres;
            *bPass = FALSE;
        }

        //
        // we're done with the event
        //
        CloseHandle(hWaitEvent);

        DisplayOutput(" StiDeviceRelease has UnSubscribed");
    }
    //
    // The STI_DEVICE_INFORMATION array returned by GetDeviceList needs to
    // be freed with LocalFree(). Also, resetting internal Sti device counter.
    //
    if ( pStiInfo )
        LocalFree(pStiInfo);
    pStiInfo = pStiInfoPtr = NULL;

    //
    // close device if any are open
    //
    if ( pStiDevice ) {
        //
        // Close an open device.
        //
        hres = pStiDevice->Release();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Release (Device)",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else
            DisplayOutput(" Device Released");

        DisplayOutput("");

        //
        // clear the Sti device pointer
        //
        pStiDevice = NULL;

        //
        // disable IStiDevice menu items
        //
        IStillDeviceMenu(MF_GRAYED);
        IStillNameMenu(MF_GRAYED);
        IStillScanMenu(MF_GRAYED);
        EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,      MF_ENABLED);
        CheckMenuItem(hMenu,  IDM_ENABLE_HWNOTIF,     MF_UNCHECKED);
    }

    return (hError);
}


/*****************************************************************************
    HRESULT StiImageRelease(BOOL *)
        Close the Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiImageRelease(BOOL *bPass)
{
    HRESULT hres = STI_OK;


    *bPass = TRUE;

    //
    // if Sti subsystem is open, close it
    //
    if ( pSti ) {
        //
        // Close the Still Imaging subsystem.
        //
        hres = pSti->Release();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Release (Image)",TRUE);
            *bPass = FALSE;
        } else
            DisplayOutput(" Imaging subsystem Released");

        DisplayOutput("");

        //
        // clear the Sti subsystem pointer
        //
        pSti = NULL;

        //
        // Disable the menu items for IStillImage interface calls
        //
        IStillNameMenu(MF_GRAYED);
        IStillImageMenu(MF_GRAYED);
        EnableMenuItem(hMenu, IDM_CREATE_INSTANCE,       MF_ENABLED);
    }

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnum(BOOL *)
        Opens Sti subsystem and enumerates any still image devices found

    Parameters:
        Pointer to receive PASS/FAIL status

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEnum(BOOL *bPass)
{
    HRESULT hres = STI_OK;

    DWORD   dwCounter;
    DWORD   dwStiCount = 0;

    PSTI_DEVICE_INFORMATION pI = NULL;
    BOOL    bReturn;

    PCSTR   pszStringTablePtr = NULL;



    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }

    //
    // Enumerate devices
    //
    dwStiTotal = 0;
    pStiInfo = NULL;

    //
    // The GetDeviceList interface is used to get a list of the installed still
    // image devices. Use this call to obtain a STI_DEVICE_INFORMATION array
    // filled with info on all currently installed Sti devices.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceList(
                              NULL,           // Type (reserved, use NULL)
                              NULL,           // Flags (reserved, use NULL)
                              &dwStiTotal,    // address of variable to return number of devices found
                              &pStiInfo       // Sti device info buffer
                              );

    if ( ! SUCCEEDED(hres) || ! pStiInfo ) {
        StiDisplayError(hres,"GetDeviceList",TRUE);
        StiClose(&bReturn);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Display Sti info on each device found
    //
    for ( dwCounter = 0,pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
        dwCounter < dwStiTotal;
        dwCounter++, pStiInfoPtr++ ) {

        DisplayOutput(" Device number %2d",dwCounter + 1);
        pszStringTablePtr = StrFromTable(GET_STIDEVICE_TYPE(pStiInfoPtr->DeviceType),
                               StStiDeviceType);
        DisplayOutput("  Device type %xh %s",
                      GET_STIDEVICE_TYPE(pStiInfoPtr->DeviceType),
                      pszStringTablePtr);
        DisplayOutput("  Device subtype %xh",
                      GET_STIDEVICE_SUBTYPE(pStiInfoPtr->DeviceType));
        DisplayOutput("  Internal name \"%S\"",
                      pStiInfoPtr->szDeviceInternalName);
        DisplayOutput("  Device capabilities %xh",
                      pStiInfoPtr->DeviceCapabilities);
        DisplayOutput("  Hardware configuration %xh",
                      pStiInfoPtr->dwHardwareConfiguration);
        DisplayOutput("  Vendor description \"%S\"",
                      pStiInfoPtr->pszVendorDescription);
        DisplayOutput("  Device description \"%S\"",
                      pStiInfoPtr->pszDeviceDescription);
        DisplayOutput("  Port Name \"%S\"",
                      pStiInfoPtr->pszPortName);
        DisplayOutput("  Prop provider \"%S\"",
                      pStiInfoPtr->pszPropProvider);
        DisplayOutput("  Local name \"%S\"",
                      pStiInfoPtr->pszLocalName);
        DisplayOutput("");
    }

    //
    // point to most recently selected device again
    //
    pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo + nStiNumber;

    DisplayOutput(" GetDeviceList found %d device%s",dwStiTotal,
                  dwStiTotal == 1 ? "" : "s");

    if ( dwStiTotal != dwCounter ) {
        DisplayOutput("* Get DeviceList actually returned %d devices",dwCounter);
        dwStiTotal = dwCounter;
        nError++;
        pdevPtr-nError++;
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnumPrivate(PVOID *, DWORD *)
        Call GetDeviceList and return pointer to struct

    Parameters:
        Pointer to private DeviceList
                Pointer to number of devices found counter

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEnumPrivate(PVOID *pPtr, DWORD *dwHowMany)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti )
        return (STIERR_GENERIC);

    //
    // The GetDeviceList interface is used to get a list of the installed still
    // image devices. Use this call to obtain a STI_DEVICE_INFORMATION array
    // filled with info on all currently installed Sti devices.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceList(
                              NULL,            // Type (reserved, use NULL)
                              NULL,            // Flags (reserved, use NULL)
                              dwHowMany,       // address of variable to return number of devices found
                              pPtr             // Sti device info buffer
                              );

    if ( ! SUCCEEDED(hres) || ! *pPtr ) {
        StiDisplayError(hres,"GetDeviceList",TRUE);
        StiClose(&bReturn);
        return (STIERR_GENERIC);
    }

    return (hres);
}


/*****************************************************************************
    INT StiSelect(HWND hWnd,int nContext,BOOL *)
        Select and open a specific Still Image device

    Parameters:
        handle to current window
                context we were called from
                pointer to receive Pass/Fail

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiSelect(HWND hWnd,int nContext,BOOL *bPass)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (-1);
    }
    *bPass = TRUE;

    //
    // look for devices if count of available is 0
    //
    if ( dwStiTotal == 0 ) {
        StiEnum(&bReturn);
    }

    //
    // if still no devices, inform user and leave
    //
    if ( dwStiTotal == 0 ) {

        ZeroMemory(szInternalName,sizeof(szInternalName));
        ZeroMemory(szFriendlyName,sizeof(szFriendlyName));

        DisplayOutput("* No Sti devices found!");
        DisplayOutput("");
        *bPass = FALSE;
        return (-1);
    }

    switch ( nContext ) {
        case EVENT:
            //
            // Sti push event or automated test
            //
            if ( nStiNumber == -1 ) {
                //
                // we could not select the correct device, just return
                //
                nStiNumber = 0;
                return (0);
            }
            break;
        case MANUAL:
            //
            // manual device selection
            //
            bReturn = fDialog(IDD_SELECT, hWnd, (FARPROC) SelectDevice);

            //
            // just return if user pressed CANCEL in dialog
            //
            if ( bReturn == FALSE ) {
                return (0);
            }
            break;
    }

    //
    // close any currently active imaging device
    //
    if ( pStiDevice )
        StiDeviceRelease(&bReturn);

    //
    // get pointer to device selected in dialog
    //
    pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo + nStiNumber;

    if ( ! *(pStiInfoPtr->szDeviceInternalName) ) {
        DisplayOutput("* Invalid device name !");
        nError++;
        pdevPtr-nError++;
        *bPass = FALSE;
        return (-1);
    }

    //
    // copy the internal device name and the friendly user name
    //
    wcscpy(szInternalName,pStiInfoPtr->szDeviceInternalName);
    wcscpy(szFriendlyName,pStiInfoPtr->pszLocalName);
    IStillNameMenu(MF_ENABLED);

    DisplayOutput(" Selected device %d \"%S\"",nStiNumber + 1,szInternalName);
    DisplayOutput(" Friendly name \"%S\"",szFriendlyName);

    //
    // Are we selecting the device or just its name?
    //
    if ( ! nNameOnly ) {
        //
        // The CreateDevice interface creates an IStiDevice object.
        // The IStiDevice object provides access to the IStiDevice interface
        // and device specific Imaging functionality.
        //
        hres = pSti->CreateDevice(
                                 pStiInfoPtr->szDeviceInternalName,
                                 // internal device name
                                 STI_DEVICE_CREATE_BOTH,     // device creation mode
                                 &pStiDevice,            // pointer where IStiDevice object is to be stored
                                 NULL );                 // pointer to controlling unknown of OLE aggregation

        if ( ! SUCCEEDED(hres) || ! pStiDevice ) {
            StiDisplayError(hres,"CreateDevice",TRUE);
            DisplayOutput("* \"%S\" (%S) cannot be tested",
                          pStiInfoPtr->pszLocalName,pStiInfoPtr->szDeviceInternalName);
            DisplayOutput("");
            *bPass = FALSE;
            return (-1);
        }

        //
        // enable Sti menu items
        //
        IStillDeviceMenu(MF_ENABLED);
        CheckMenuItem(hMenu,  IDM_ENABLE_HWNOTIF,     MF_CHECKED);
        EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,      MF_GRAYED);

        //
        // Do we have scan commands for this device?
        //
        if ( nICanScan = IsScanDevice(pStiInfoPtr) ) {
            IStillScanMenu(MF_ENABLED);
        }
        DisplayOutput(" \"%S\" is ready for Testing",szFriendlyName);
    }
    DisplayOutput("");

    return (0);
}


/******************************************************************************
    BOOL FAR PASCAL SelectDevice(HWND,UINT,WPARAM,LPARAM)
        Put up a dialog for user to select a Still Image device

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL SelectDevice(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    PSTI_DEVICE_INFORMATION
    pTmpInfoPtr;
    DWORD   dwCounter;
    int     iIndex;
    static int      iLastPick = 0;


    switch ( msg ) {

        case WM_INITDIALOG:

            //
            // fill dialog with Sti Device Internal Names
            //
            for ( dwCounter = 0, pTmpInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
                dwCounter < dwStiTotal;dwCounter++, pTmpInfoPtr++ ) {
                //
                // convert UNICODE string to ANSI
                //
                wsprintf(pszStr1,"%ls",pTmpInfoPtr->pszLocalName);

                iIndex = SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,
                                            CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,CB_SETCURSEL,iLastPick,0);

            return (TRUE);

        case WM_COMMAND:
            switch ( wParam ) {
                case IDOK:
                    nStiNumber = SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,
                                                    CB_GETCURSEL,0,0);
                    nNameOnly = SendDlgItemMessage(hDlg,IDC_SELECT_NAME,
                                                   BM_GETCHECK,0,0);

                    //
                    // ensure device number not greater than total
                    // (NOTE: dwStiTotal is 1's base, while nStiNumber is 0 based)
                    //
                    if ( nStiNumber >= (int) dwStiTotal )
                        nStiNumber = (int) dwStiTotal - 1;
                    if ( nStiNumber < 0 )
                        nStiNumber = 0;
                    iLastPick = nStiNumber;

                    EndDialog(hDlg, TRUE);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return (TRUE);
            }

    }
    return (FALSE);
}


/*****************************************************************************
    void StiDisplayError(HRESULT,char *,BOOL)
        Display verbose error information

    Parameters:
        HRESULT from failed call
        TRUE = record error as compliance failure


    Return:
        none

*****************************************************************************/
void StiDisplayError(HRESULT hres,char *szCall,BOOL bFail)
{
    PERRECORD               pR = pdevPtr->pRecord;
    BOOL                    bReturn;


    StiGetLastErrorInfo(&bReturn);
    LastError(TRUE);

    //
    // record the error
    //
    pR += nTestID;
    pR->nCount++;


// BUG BUG can't copy the string correctly to UNICODE string

//      sprintf(pszStr4,"%s",StrFromTable(hres,StStiError));
//      swprintf(pR->szErrorString,L"%s",pszStr4);

    //
    // compliance test failure error?
    //
    if ( bFail ) {
        nError++;
        pdevPtr-nError++;
        pR->bFatal = TRUE;
        DisplayOutput("* Sti Compliance test error");
        tlLog(hNTLog,TL_LOG,"* Sti Compliance test error");

    } else {
        DisplayOutput("* Allowed error");
    }
    DisplayOutput("* %s returned %xh (%d)",szCall,hres,hres);
    if ( bFail )
        tlLog(hNTLog,TL_LOG,"* %s returned %xh (%d)",szCall,hres,hres);
    DisplayOutput(" \"%s\"",StrFromTable(hres,StStiError));
    if ( bFail )
        tlLog(hNTLog,TL_LOG," \"%s\"",StrFromTable(hres,StStiError));

    return;
}


/******************************************************************************
    int InitPrivateList(PDEVLOG,int *)
        Initialize private test structures

    Parameters:
        pointer to Devicelog to initialize
                pointer to test suite

    Return:
        total number of devices found (-1 on failure)

******************************************************************************/
int InitPrivateList(PDEVLOG *pDev,int *pSuiteList)
{
    DWORD           dwStiDevCount = 0;
    PVOID           pList = NULL;
    PSTI_DEVICE_INFORMATION
    pInfoPrivatePtr = NULL;     // pointer to device in pStiBuffer
    PDEVLOG         pPtr = NULL;
    PERRECORD       precPtr = NULL;
    int                     i,k,nNumberTests,nTotalDevices;
    BOOL            bReturn;


    //
    // get the current number of devices and their names
    //
    StiCreateInstance(&bReturn);

    StiEnumPrivate(&pList,&dwStiDevCount);
    if ( ! pList ) {
        DisplayOutput("* No Sti device attached !");
    } else {
        pInfoPrivatePtr = (PSTI_DEVICE_INFORMATION) pList;
    }

    //
    // create at least one list entry (even if no devices are found)
    //
    if ( ! dwStiDevCount ) {
        dwStiDevCount = 1;
        nTotalDevices = 0;
    } else
        nTotalDevices = (int) dwStiDevCount;

    //
    // create a device log for each device
    //
    pPtr = (PDEVLOG) calloc(dwStiDevCount,sizeof(DEVLOG));
    if ( pPtr == NULL ) {
        FatalError("Could not initialize private structures");
        return (-1);
    }
    *pDev = pPtr;

    //
    // count the number of tests in suite
    //
    for ( nNumberTests = 0;pSuiteList[nNumberTests] != -1;nNumberTests++ )
        ;

    //
    // initialize linked list pointers and error records for each device log
    //
    for ( i = 0;i < (int) dwStiDevCount;i++,pPtr++,pInfoPrivatePtr++ ) {
        if ( i ) {
            (pPtr - 1)->pNext = pPtr;
            pPtr->pPrev = pPtr - 1;
        }
        if ( nTotalDevices ) {
            wcscpy(pPtr->szInternalName,pInfoPrivatePtr->szDeviceInternalName);
            wcscpy(pPtr->szLocalName,pInfoPrivatePtr->pszLocalName);
        } else {
            wcscpy(pPtr->szInternalName,L"* Invalid !");
            wcscpy(pPtr->szLocalName,L"* No Sti device attached !");
        }

        //
        // create one error log for each test (nNumberTests)
        //
        pPtr->pRecord = (PERRECORD) calloc(nNumberTests,sizeof(ERRECORD));
        if ( pPtr->pRecord == NULL ) {
            FatalError("Could not initialize private structures");
            return (-1);
        }
        //
        // initialize linked list pointers and error records for each record
        //
        for ( k = 0,precPtr = pPtr->pRecord;k < nNumberTests;k++,precPtr++ ) {
            precPtr->nIndex = k;
            precPtr->nTest = pSuite[k];
            if ( k ) {
                (precPtr - 1)->pNext = precPtr;
                precPtr->pPrev = precPtr - 1;
            }
        }
    }

    //
    // free the device list
    //
    LocalFree(pList);
    StiClose(&bReturn);

    return (nTotalDevices);
}


/******************************************************************************
    int ClosePrivateList(PDEVLOG)
        Remove private test structures

    Parameters:
        pointer to Devicelog to close

    Return:
        0 on success
        -1 on failure

******************************************************************************/
int ClosePrivateList(PDEVLOG *pDev)
{
    PDEVLOG pPtr = (PDEVLOG) *pDev;


    if ( pDev == NULL )
        return (0);

    //
    // free each device log's error record
    //
    for ( ;pPtr->pNext;pPtr++ ) {
        if ( pPtr->pRecord )
            free(pPtr->pRecord);
    }

    //
    // free the device log
    //
    if ( *pDev ) {
        free(*pDev);
        *pDev = NULL;
    }

    return (0);
}


/*****************************************************************************
    HRESULT StiGetDeviceValue(LPWSTR,LPWSTR,DWORD *,BOOL *)
                Get driver information

    Parameters:
        szDevname - internal device name
                szKeyname - key to access
                dwType - pointer to data type
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetDeviceValue(LPWSTR szDevname,LPWSTR szKeyname,LPBYTE pData,
                          DWORD *dwType,DWORD cbData,BOOL *bPass)
{
    HRESULT hres = STI_OK;

//
// WINNT.H - Predefined Value Types
//
    STRINGTABLE StRegType[] =
    {
        REG_NONE,   "REG_NONE",0,
        REG_SZ,     "REG_SZ",0,
        REG_BINARY, "REG_BINARY",0,
        REG_DWORD,  "REG_DWORD",0,
        0,          "Unknown Reg Type",-1
    };


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    ZeroMemory(pData,cbData);

    DisplayOutput(" GetDeviceValue for device \"%S\"",szDevname);
    DisplayOutput("  Key requested: \"%S\"",szKeyname);

    //
    // The GetDeviceValue function is used to retrieve data associated with a
    // still image device. Essentially, data is associated with a device
    // through a key/data type/value triplet. The only reserved standard
    // ValueNames, as defined in STI.H, are the following:
    //
    // ICMProfiles - string containing a comma-sperated list of ICM profiles
    // TwainDS - TWAIN data source display name
    // ISISDriverName - ISIS driver name
    //
    hres = pSti->GetDeviceValue(
                               szDevname,              // internal device name
                               szKeyname,              // value tag string
                               dwType,                 // pointer where data type will be stored
                               pData,                  // pointer where value will be stored
                               &cbData                 // size of value pointer storage
                               );

    if ( !SUCCEEDED(hres) ) {
        //
        // The only required registry item is STI_DEVICE_VALUE_ICM_PROFILE
        //
        if ( hres == STIERR_OBJECTNOTFOUND ) {
            if ( ! wcscmp(STI_DEVICE_VALUE_ICM_PROFILE,szKeyname) ) {
                //
                // Only STI_DEVICE_VALUE_ICM_PROFILE is a required key
                // Therefore, only this one Failure is a COMPLIANCE test failure
                //
                *bPass = FALSE;
                StiDisplayError(hres,"GetDeviceValue",TRUE);
            } else {
                StiDisplayError(hres,"GetDeviceValue",FALSE);
            }
        } else {
            *bPass = FALSE;
            StiDisplayError(hres,"GetDeviceValue",TRUE);
        }
    } else {
        DisplayOutput("  Reg Type %d %s",* dwType,
                      StrFromTable(*dwType,StRegType));
        DisplayOutput("  The following %d bytes were read from the Registry:",
                      cbData);
        DisplayOutput("  \"%s\"",pData);
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiSetDeviceValue(LPWSTR,LPWSTR,LPWSTR,DWORD,BOOL *)
                Set driver information

    Parameters:
        szDevname - internal device name
                szKeyname - key to access
                pData - value to write
                dwType - data type
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiSetDeviceValue(LPWSTR szDevname,LPWSTR szKeyname,LPBYTE pData,
                          DWORD dwType,DWORD cbData,BOOL *bPass)
{
    HRESULT hres = STI_OK;

//
// WINNT.H - Predefined Value Types
//
    STRINGTABLE StRegType[] =
    {
        REG_NONE,   "REG_NONE",0,
        REG_SZ,     "REG_SZ",0,
        REG_BINARY, "REG_BINARY",0,
        REG_DWORD,  "REG_DWORD",0,
        0,          "Unknown Reg Type",-1
    };


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    DisplayOutput(" SetDeviceValue for device \"%S\"",szDevname);
    DisplayOutput("  Key \"%S",szKeyname);

    //
    // The SetDeviceValue function is used to associate any additional data
    // with a still image device. It is used internally to store the values of
    // strings that are required to communicate information to imaging APIs
    // during use of push model behavoir. However, this function can be used
    // to associate any ancillary data with a device. The only reserved
    // ValueNames, as defined in STI.H, are the following:
    //
    // ICMProfiles - string containing a comma-sperated list of ICM profiles
    // TwainDS - TWAIN data source display name
    // ISISDriverName - ISIS driver name
    //
    hres = pSti->SetDeviceValue(
                               szDevname,              // internal device name
                               szKeyname,              // value tag string
                               dwType,                 // data type sent
                               pData,              // pointer to data to send
                               cbData                  // byte size of data
                               );

    if ( !SUCCEEDED(hres) ) {
        //
        // SetDeviceValue is not required under NT
        //
        StiDisplayError(hres,"SetDeviceValue",FALSE);
    } else {
        //pszStr1 = StrFromTable(dwType,StRegType);
        DisplayOutput("  Reg Type %d %s",dwType,StrFromTable(dwType,StRegType));
        DisplayOutput("  The following %d bytes were written to the Registry:",
                      cbData);
        DisplayOutput("  \"%s\"",(char *) pData);
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiRegister(HWND,int,BOOL *)
                Register or Unregister the application to receive Sti Launch events.

    Parameters:
        Handle to the window to display image in.
                Instance for access to string table
                int nOnOff == ON to register, OFF to unregister
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRegister(HWND hWnd,HINSTANCE hInstance,int nOnOff,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    CHAR    szModulePath[MAX_PATH+1];
    WCHAR   szModulePathW[MAX_PATH+1],
    szAppName[MEDSTRING];
    DWORD   cch;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Retrieve name of this application from STRING table
    // and convert to UNICODE.
    //
    LoadString(hInstance,IDS_APPNAME,pszStr1,MEDSTRING);
    cch = MultiByteToWideChar(CP_ACP, 0,
                              pszStr1, -1,
                              szAppName,MEDSTRING);
    if ( ! cch ) {
        LastError(TRUE);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }

    //
    // Register/deregister app
    //
    if ( nOnOff == ON ) {
        //
        // Register our application.
        // Get full path to executable and convert to UNICODE.
        //
        cch = GetModuleFileName(NULL,szModulePath,sizeof(szModulePath));

        if ( ! cch ) {
            LastError(TRUE);
            *bPass = FALSE;
            return (STIERR_GENERIC);
        }
        cch = MultiByteToWideChar(CP_ACP, 0,
                                  szModulePath, -1,
                                  szModulePathW, sizeof(szModulePathW));

        //
        // The RegisterLaunchApplication function should be called by
        // applications that would like to be launched in response to an
        // Sti push event. This function can be called more than once,
        // and should be called each time the application rus in case
        // the user relocates the application.
        //
        hres = pSti->RegisterLaunchApplication(
                                              szAppName,                      // short name of app
                                              szModulePathW           // full path to executable
                                              );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"RegisterLaunchApplication",TRUE);
            *bPass = FALSE;
            hError = hres;
        } else {
            DisplayOutput(" %s registered for Sti Launch Application",pszStr1);
        }
    } else {
        //
        // Unregister our application
        //
        hres = pSti->UnregisterLaunchApplication(
                                                szAppName                       // short name of app
                                                );
        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"UnregisterLaunchApplication",TRUE);
            hError = hres;
        } else {
            DisplayOutput(" %s Unregistered from Sti Launch",pszStr1);
        }
    }
    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiEvent(HWND hWnd)
                Handle a push model event.
                This function is called when the test app has been
                        a) registered as a push event handler
                        b) launched by a push event

    Parameters:
        Handle to the window to display image in.

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEvent(HWND hWnd)
{
    HRESULT hres = STI_OK;
    WCHAR   szDeviceName[STI_MAX_INTERNAL_NAME_LENGTH + 1],
    szEventName[LONGSTRING];
    DWORD   cch,
    dwEventCode = 0,
    cbData = LONGSTRING;
    int             nCounter;
    BOOL    bBadFlag = FALSE;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }


    ZeroMemory(szDeviceName,STI_MAX_INTERNAL_NAME_LENGTH + 1);
    ZeroMemory(szEventName,LONGSTRING);

    //
    // For an application started through push model launch,
    // GetSTILaunchInformation returns the associated information. This
    // information is used to determine which device to use and what
    // event caused the application to be launched.
    //
    hres = pSti->GetSTILaunchInformation(
                                        szDeviceName,           // pointer to where device name will be stored
                                        &dwEventCode,           // reserved
                                        szEventName                     // pointer to where GUID will be stored
                                        );

    if ( !SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetSTILaunchInformation",TRUE);
        return (STIERR_GENERIC);
    }

    ZeroMemory(pszStr2,LONGSTRING);
    ZeroMemory(pszStr4,LONGSTRING);
    cch = WideCharToMultiByte(CP_ACP,0,
                              szDeviceName,-1,
                              pszStr1,STI_MAX_INTERNAL_NAME_LENGTH + 1,
                              pszStr2,&bBadFlag);
    if ( ! cch )
        LastError(TRUE);
    if ( bBadFlag ) {
        DisplayOutput("* UNICODE translation error");
        bBadFlag = FALSE;
    }
    DisplayOutput(" %s launched via Sti push",pszStr1);
    DisplayOutput(" Event code %d (%xh)",dwEventCode,dwEventCode);

    cch = WideCharToMultiByte(CP_ACP,0,
                              szEventName,-1,
                              pszStr1,STI_MAX_INTERNAL_NAME_LENGTH + 1,
                              pszStr2,&bBadFlag);
    if ( ! cch )
        LastError(TRUE);
    if ( bBadFlag ) {
        DisplayOutput("* UNICODE translation error");
        bBadFlag = FALSE;
    }
    DisplayOutput(" Event name %s",pszStr1);

    //
    // find the Sti device that sent the event
    // set nStiNumber to -1 (no device), then set to event device when found
    //
    for ( nStiNumber = -1,nCounter = 0,
          pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
        nCounter < (int) dwStiTotal;pStiInfoPtr++,nCounter++ ) {
        if ( ! wcscmp(szDeviceName,pStiInfoPtr->szDeviceInternalName) )
            nStiNumber = nCounter;
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiGetDeviceInfo(LPWSTR szDevName,BOOL *pPass)
                Display information about the selected device

    Parameters:
                WCHAR string of the selected device
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetDeviceInfo(LPWSTR szDevname,BOOL *bPass)
{
    HRESULT                                     hres = STI_OK;
    PVOID                                   pInfo = NULL;
    PSTI_DEVICE_INFORMATION pInfoPtr = NULL;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Given a device name, the GetDeviceInfo interface makes available a
    // structure that describes the various attributes of the device.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceInfo(
                              szDevname,              // pointer to the internal device name
                              &pInfo);                // Sti device info buffer

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetDeviceInfo",TRUE);
        *bPass = FALSE;
    }

    pInfoPtr = (PSTI_DEVICE_INFORMATION) pInfo;

    DisplayOutput(" GetDeviceInfo for \"%S\"",szDevname);
    //pszStr1 = StrFromTable(GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),StStiDeviceType);
    DisplayOutput("  Device type %xh %s",
                  GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),
                  StrFromTable(GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),StStiDeviceType));
    DisplayOutput("  Device subtype %xh",
                  GET_STIDEVICE_SUBTYPE(pInfoPtr->DeviceType));
    DisplayOutput("  Internal name \"%S\"",
                  pInfoPtr->szDeviceInternalName);
    DisplayOutput("  Device capabilities %xh",
                  pInfoPtr->DeviceCapabilities);
    DisplayOutput("  Hardware configuration %xh",
                  pInfoPtr->dwHardwareConfiguration);
    DisplayOutput("  Vendor description \"%S\"",
                  pInfoPtr->pszVendorDescription);
    DisplayOutput("  Device description \"%S\"",
                  pInfoPtr->pszDeviceDescription);
    DisplayOutput("  Port Name \"%S\"",
                  pInfoPtr->pszPortName);
    DisplayOutput("  Prop provider \"%S\"",
                  pInfoPtr->pszPropProvider);
    DisplayOutput("  Local name \"%S\"",
                  pInfoPtr->pszLocalName);
    DisplayOutput("");

    // free the STI_DEVICE_INFORMATION buffer
    if ( pInfo )
        LocalFree(pInfo);

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnableHwNotification(LPWSTR,int *,BOOL *)
                Determine the current notification handling state and if requested,
                change it.

    Parameters:
                internal device name
        pointer to state request (current state returned in pointer)
                        ON = turn on polling
                        OFF = turn off polling
                        PEEK = return current polling state
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiEnableHwNotification(LPWSTR szDevnameW,int *nState,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    BOOL    bState = OFF;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // GetHwNotificationState gets the current state of notification handling.
    // The state parameter returns TRUE if the notification is enabled.
    //
    hres = pSti->GetHwNotificationState(
                                       szDevnameW,             // internal device name
                                       &bState                 // pointer where state will be stored
                                       );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetHwNotificationState",TRUE);
        *bPass = FALSE;
        hError = hres;
    } else {
        DisplayOutput(" Hardware Notification state is %s",
                      bState ? "TRUE (ON)" : "FALSE (OFF)");
    }

    if ( *nState != PEEK ) {
        //
        // EnableHwNotifications is used to turn event notification on and off.
        // For polled devices, this function will turn polling on and off.
        //
        hres = pSti->EnableHwNotifications(
                                          szDevnameW,             // internal device name
                                          *nState                 // new state to be set
                                          );
        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetHwNotificationState",TRUE);
            *bPass = FALSE;
            return (hres);
        }

        //
        // Ensure the state was changed
        //
        hres = pSti->GetHwNotificationState(
                                           szDevnameW,             // internal device name
                                           &bState                 // pointer where state will be stored
                                           );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetHwNotificationState",TRUE);
            *bPass = FALSE;
            hError = hres;
        } else {
            DisplayOutput(" Hw state has been set to %s",
                          bState ? "TRUE (ON)" : "FALSE (OFF)");
        }

        if ( bState ) {
            if ( GetMenuState(hMenu, IDM_ENABLE_HWNOTIF, NULL) == MF_UNCHECKED )
                CheckMenuItem(hMenu, IDM_ENABLE_HWNOTIF, MF_CHECKED);
        } else {
            if ( GetMenuState(hMenu, IDM_ENABLE_HWNOTIF, NULL) == MF_CHECKED )
                CheckMenuItem(hMenu, IDM_ENABLE_HWNOTIF, MF_UNCHECKED);
        }
    }
    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRefresh(LPWSTR,BOOL *)
                Refresh the bus for non-PNP devices

    Parameters:
                internal device name
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRefresh(LPWSTR szDevnameW,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    BOOL    bState = OFF;

/**/
    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // GetHwNotificationState gets the current state of notification handling.
    // The state parameter returns TRUE if the notification is enabled.
    //
    hres = pSti->RefreshDeviceBus(
                                 szDevnameW              // internal device name
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"RefreshDeviceBus",TRUE);
        *bPass = TRUE;
        hError = hres;
    } else
        DisplayOutput(" RefreshDeviceBus called on \"%S\"",szDevnameW);

    DisplayOutput("");
/**/
    return (hError);
}


/*****************************************************************************
    HRESULT StiWriteErrLog(DWORD,LPCWSTR,BOOL *)
                Write a string to the error log

    Parameters:
                DWORD severity, which can be
                        STI_TRACE_INFORMATION
                        STI_TRACE_WARNING
                        STI_TRACE_ERROR
                Wide character message to write to log.
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiWriteErrLog(DWORD dwSeverity,LPCWSTR pszMessage,BOOL *bPass)
{
    HRESULT hres = STI_OK;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // WriteToErrorLog can be used to write debugging and diagnostic
    // information into the Sti log file, located in the Windows directory
    // STI_TRACE.LOG. The user can control whether informational, warning or
    // error messages, or any combination of these three are put in the log
    // file through the Scanners & Cameras control panel.
    //
    hres = pSti->WriteToErrorLog(
                                dwSeverity,                     // severity of error
                                pszMessage                      // string to write to log
                                );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"WriteToErrorLog",TRUE);
        *bPass = FALSE;
    } else
        DisplayOutput(" WriteToErrorLog wrote \"%S\"",pszMessage);
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiGetStatus(int,BOOL *)
                Retrieve the user mode status of the driver.

    Parameters:
                StatusMask to retrieve status for. Can be a combination of:
                        STI_DEV_ONLINE_STATE
                        STI_DEV_EVENTS_STATE
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiGetStatus(int nMask,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD                           dwTimeout = 2000;
    STI_DEVICE_STATUS       StiStatus;

//
// STI.H - STI_DEVICE_MJ_TYPE
//
    STRINGTABLE StStiStatusMask[] =
    {
        STI_DEVSTATUS_ONLINE_STATE, "STI_DEVSTATUS_ONLINE_STATE",0,
        STI_DEVSTATUS_EVENTS_STATE, "STI_DEVSTATUS_EVENTS_STATE",0,
        STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE,
        "STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE",0,
        0, "Unknown status mask",-1
    };


    //
    // check that an Sti device is selected
    //
    if ( pStiDevice == NULL ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before GetStatus
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for GetStatus");

        //
        // Get and display status
        //
        ZeroMemory(&StiStatus,sizeof(StiStatus));
        //
        // The STI_DEVICE_STATUS dwSize field MUST be set by the caller.
        //
        StiStatus.dwSize = sizeof(STI_DEVICE_STATUS);
        //
        // The STI_DEVICE_STATUS StatusMask field MUST be set to the desired
        // status to retrieve.
        //
        StiStatus.StatusMask = nMask;

        DisplayOutput("  %s mask",StrFromTable(nMask,StStiStatusMask));

        //
        // The GetStatus interface gets the status from the user-mode
        // minidriver. Status returned can indicate online status and/or
        // device event activity.
        //
        hres = pStiDevice->GetStatus(
                                    &StiStatus                              // pointer to a STI_DEVICE_STATUS struct
                                    );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetStatus",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else {
            DisplayOutput(" GetStatus on %S",szFriendlyName);
        }
        //
        // Is the device on?
        //
        if ( (StiStatus.dwOnlineState == 0) &&
             (nMask & STI_DEVSTATUS_ONLINE_STATE) ) {
            DisplayOutput("* Device is TURNED OFF OR OFFLINE!!");
        }

        DisplayOutput("  %xh (%d) StatusMask",
                      StiStatus.StatusMask,StiStatus.StatusMask);
        DisplayOutput("  %xh (%d) dwOnlineState",
                      StiStatus.dwOnlineState,StiStatus.dwOnlineState);
        DisplayOutput("  %xh (%d) dwHardwareStatusCode",
                      StiStatus.dwHardwareStatusCode,StiStatus.dwHardwareStatusCode);
        DisplayOutput("  %xh (%d) dwEventHandlingState",
                      StiStatus.dwEventHandlingState,StiStatus.dwEventHandlingState);
        DisplayOutput("  %xh (%d) dwPollingInterval",
                      StiStatus.dwPollingInterval,StiStatus.dwPollingInterval);

        if ( StiStatus.dwSize != sizeof(STI_DEVICE_STATUS) ) {
            DisplayOutput("* Expected STI_DEVICE_STATUS dwSize %d, got %d",
                          sizeof(STI_DEVICE_STATUS),StiStatus.dwSize);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiGetCaps(BOOL *)
                Return the device capabilities

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetCaps(BOOL *bPass)
{
    HRESULT                             hres = STI_OK;
    STI_DEV_CAPS            StiDevCaps = { 0};


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // The GetCapabilities function returns the capabilities of the device.
    //
    hres = pStiDevice->GetCapabilities(
                                      &StiDevCaps                             // pointer to a STI_DEV_CAPS struct
                                      );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetCapabilities",TRUE);
        *bPass = FALSE;
    } else {
        DisplayOutput(" GetCapabilities on \"%S\'",szFriendlyName);

        DisplayOutput("  %xh (%d) dwGeneric",
                      StiDevCaps.dwGeneric,StiDevCaps.dwGeneric);
    }

    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiReset(BOOL *)
                Puts the device into a known state.

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiReset(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD   dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before DeviceReset
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for DeviceReset");

        //
        // The DeviceReset interface requests that a device be returned to a
        // known state.
        //
        hres = pStiDevice->DeviceReset();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"DeviceReset",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else
            DisplayOutput(" DeviceReset on \"%S\"",szFriendlyName);
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiDiagnostic(BOOL *)
                Return user mode driver diagnostic info

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiDiagnostic(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DIAG    diag;
    DWORD   dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before Diagnostic
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for Diagnostic");

        //
        // get diagnostic info
        //
        ZeroMemory(&diag,sizeof(diag));
        //
        // The DIAG dwSize field MUST be set by the caller.
        //
        diag.dwSize = sizeof(DIAG);
        //
        // The dwBasicDiagCode of this structure should be initialized with
        // the desired request code. Currently, only one request code is
        // defined, STI_DIAGCODE_HWPRESENCE.
        diag.dwBasicDiagCode = STI_DIAGCODE_HWPRESENCE;
        //
        // There is also a vendor defined field called dwVendorDiagCode that
        // can optionally be filled in.
        //
        diag.dwVendorDiagCode = 0;

        //
        // The Diagnostic interface executes the diagnostic method of the user
        // mode minidriver.
        //
        hres = pStiDevice->Diagnostic(
                                     &diag                           // pointer to STI_DIAG structure
                                     );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Diagnostic",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else {
            DisplayOutput(" Diagnostic on \"%S\"",szFriendlyName);
        }

        DisplayOutput("  %xh (%d) dwBasicDiagCode",
                      diag.dwBasicDiagCode,diag.dwBasicDiagCode);
        DisplayOutput("  %xh (%d) dwVendorDiagCode",
                      diag.dwVendorDiagCode,diag.dwVendorDiagCode);
        DisplayOutput("  %xh (%d) dwStatusMask",
                      diag.dwStatusMask,diag.dwStatusMask);

        if ( diag.dwSize != sizeof(DIAG) )
            DisplayOutput("* Expected DIAG dwSize %d, got %d",
                          sizeof(DIAG),diag.dwSize);

        //
        // any extended error info?
        //
        if ( diag.sErrorInfo.dwSize == 0 ) {
            DisplayOutput("   No Extended Errors");
        } else {
            if ( diag.sErrorInfo.dwSize != sizeof(STI_ERROR_INFO) )
                DisplayOutput("* Expected STI_ERROR_INFO dwSize %d, got %d",
                              sizeof(STI_ERROR_INFO),diag.sErrorInfo.dwSize);
            DisplayOutput("   %xh (%d) sErrorInfo.dwGenericError",
                          diag.sErrorInfo.dwGenericError,diag.sErrorInfo.dwGenericError);
            DisplayOutput("   %xh (%d) sErrorInfo.dwVendorError",
                          diag.sErrorInfo.dwVendorError,diag.sErrorInfo.dwVendorError);
            if ( * diag.sErrorInfo.szExtendedErrorText )
                DisplayOutput("   sErrorInfo.szExtendedErrorText %s",
                              diag.sErrorInfo.szExtendedErrorText);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiGetLastErrorInfo(BOOL *)
                Get and display last error from Sti device.

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetLastErrorInfo(BOOL *bPass)
{
    HRESULT                     hres = STI_OK;
    STI_ERROR_INFO  StiError;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        DisplayOutput("* NoStiDevice !");
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // get last error info
    //
    ZeroMemory(&StiError,sizeof(StiError));
    //
    // The STI_ERROR_INFO dwSize field MUST be set by the caller.
    //
    StiError.dwSize = sizeof(STI_ERROR_INFO);

    //
    // The GetLastErrorInfo interface returns the last known error from
    // the user-mode minidriver.
    //
    hres = pStiDevice->GetLastErrorInfo(
                                       &StiError                               // pointer to STI_ERROR_INFO structure
                                       );

    if ( ! SUCCEEDED(hres) ) {
        DisplayOutput("* NoStiDevice !");
        *bPass = FALSE;
    } else
        DisplayOutput(" GetLastErrorInfo on %S",szFriendlyName);

    //
    // any extended error info?
    //
    if ( StiError.dwSize == 0 ) {
        DisplayOutput("No Extended Errors");
    } else {
        if ( StiError.dwSize != sizeof(STI_ERROR_INFO) )
            DisplayOutput("* Expected STI_ERROR_INFO dwSize %d, got %d",
                          sizeof(STI_ERROR_INFO),StiError.dwSize);
        DisplayOutput("  %xh (%d) sErrorInfo.dwGenericError",
                      StiError.dwGenericError,StiError.dwGenericError);
        DisplayOutput("  %xh (%d) sErrorInfo.dwVendorError",
                      StiError.dwVendorError,StiError.dwVendorError);
        if ( * StiError.szExtendedErrorText )
            DisplayOutput("  sErrorInfo.szExtendedErrorText %s",
                          StiError.szExtendedErrorText);
    }

    return (hres);
}


/*****************************************************************************
    HRESULT StiSubscribe(BOOL *)
                Demonstrate Subscribe, UnSubscribe and GetLastNotificationData

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiSubscribe(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    STISUBSCRIBE                sSubscribe;
    DWORD                               dwErr = 0x56565656;
    int                                     nWait = TRUE;
    BOOL                                fWaiting = TRUE;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // create an unnamed event object for notification structure
    //
    hWaitEvent = CreateEvent(NULL,   // security attributes
                             FALSE,  // manual reset event flag
                             FALSE,  // initial state flag
                             NULL ); // event-object name pointer

    if ( ! hWaitEvent ) {
        *bPass = FALSE;
        return STIERR_GENERIC;
    }

    //
    // prepare the event notification structure
    //
    ZeroMemory(&sSubscribe,sizeof(sSubscribe));
    //
    // The STISUBSCRIBE dwSize field MUST be set by the caller.
    //
    sSubscribe.dwSize = sizeof(STISUBSCRIBE);
    //
    // When flag is STI_SUBSCRIBE_FLAG_WINDOW, window handle is passed in as
    // parameter. When flag is STI_SUBSCRIBE_FLAG_EVENT, event handle is
    // passed in as a parameter.
    //
    sSubscribe.dwFlags = STI_SUBSCRIBE_FLAG_EVENT;
    //
    // not used
    //
    sSubscribe.dwFilter = 0;
    //
    // When STI_SUBSCRIBE_FLAG_WINDOW bit is set, following field should
    // be set to handle of window which will receive notification message.
    //
    sSubscribe.hWndNotify = NULL;
    //
    // Handle of WIN32 auto-reset event, which will be signalled whenever
    // device has notification pending.
    //
    sSubscribe.hEvent = hWaitEvent;
    //
    // Code of notification message, sent to window
    //
    sSubscribe.uiNotificationMessage = 0;

    //
    // Subscribe is called by an application that wants to start receiving event
    // notifications from a device. This is useful for control center-style
    // applications. Each call to Subscribe should be paired with a call to
    // UnSubscribe.
    //
    hres = pStiDevice->Subscribe(
                                &sSubscribe                             // pointer to STISUBSCRIBE structure
                                );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"Subscribe",TRUE);
        CloseHandle(hWaitEvent);
        *bPass = FALSE;
        return (hres);
    }

    //
    // set the flag and semaphore for Subscribe mode
    //
    nUnSubscribe = nUnSubscribeSemaphore = 1;

    //
    // Now we wait for an event
    //
    DisplayOutput(" Subscribe on %S",szFriendlyName);

    while ( nUnSubscribe ) {

        dwErr = WaitForSingleObject(hWaitEvent,1000);

        switch ( dwErr ) {
            case WAIT_OBJECT_0:
                {
                    STINOTIFY  sNotify;


                    //
                    // received a notification
                    //
                    DisplayOutput("  WAIT_OBJECT_0 %xh (%d)",dwErr,dwErr);
                    DisplayOutput("  Received notification");

                    //
                    // prepare the notification description structure
                    //
                    ZeroMemory(&sNotify,sizeof(sNotify));
                    //
                    // The STINOTIFY dwSize field MUST be set by the caller.
                    //
                    sNotify.dwSize = sizeof(STINOTIFY);

                    //
                    // GetLastNotifyData returns information about the last
                    // event on the device.
                    //
                    hres = pStiDevice->GetLastNotificationData(
                                                              &sNotify        // pointer to STINOTIFY structure
                                                              );
                    if ( ! SUCCEEDED(hres) ) {
                        StiDisplayError(hres,"GetLastNotificationData",TRUE);
                        hError = hres;
                        *bPass = FALSE;
                    } else {
                        DisplayOutput("  GetLastNotificationData");
                        DisplayOutput("   GUID {%8x-%4x-%4x-%x}",
                                      sNotify.guidNotificationCode.Data1,
                                      sNotify.guidNotificationCode.Data2,
                                      sNotify.guidNotificationCode.Data3,
                                      sNotify.guidNotificationCode.Data4
                                     );
                    }
                }
                break;

            case WAIT_TIMEOUT:
                //
                // no notification
                //
                DisplayOutput("  WAIT_TIMEOUT %xh (%d)",dwErr,dwErr);
                DisplayOutput("  (select UnSubscribe from the IStillDevice "\
                              "menu to quit)");
                break;
            case WAIT_ABANDONED:
                DisplayOutput("  WAIT_ABANDONED %xh (%d)",dwErr,dwErr);
                break;
            default:
                DisplayOutput("  default %xh (%d)",dwErr,dwErr);
                break;
        }
    }

    //
    // if the device is gone, StiDeviceRelease has already been
    //   unsubscribed elsewhere in this app
    //
    if ( ! pStiDevice )
        return (STIERR_GENERIC);

    //
    // UnSubscribe is called when an application no longer wants to receive
    // events from a device.
    //
    hres = pStiDevice->UnSubscribe();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnSubscribe",TRUE);
        hError = hres;
        *bPass = FALSE;
    }

    //
    // we're done with the event
    //
    CloseHandle(hWaitEvent);

    //
    // clear the semaphore
    //
    nUnSubscribeSemaphore = 0;

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiEscape(DWORD,char *,BOOL *)
                The Escape function is dependent on the vendor's implementation.
                Even if a device does not require the Escape function, the driver
                must provide it. A non-functional Escape must return an error.

    Parameters:
                DWORD EscapeFunction - driver defined code
                char *lpInData - pointer to data to be sent to device
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiEscape(DWORD EscapeFunction,char *lpInData,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD   dwTimeout = 2000;

    DWORD   cbInDataSize,
    dwOutDataSize,
    pdwActualData;
    char    pOutData[LONGSTRING];


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before Escape
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for Escape");

        //
        // Set up the command
        //
        cbInDataSize = strlen(lpInData + 1);
        //
        // zero out other parameters (for clarity's sake only)
        //
        ZeroMemory(pOutData,LONGSTRING);
        dwOutDataSize = pdwActualData = 0;

        //
        // The Escape function executes a multiparameter I/O call. The semantics
        // of this call is determined by the specific user-mode minidriver.
        //
        hres = pStiDevice->Escape(
                                 EscapeFunction, // General operation code. The meaning of this code
                                 // varies in each user mode minidriver. There is no
                                 // utilization of this code by the still image
                                 // minidriver.
                                 lpInData,       // Pointer to an input memory buffer. If there are
                                 // multiple areas of memory to be read from, they
                                 // must be packaged in some sort of structure
                                 // before being passed to this API.
                                 cbInDataSize,   // The length in bytes of the memory pointed to by
                                 // lpInData
                                 pOutData,       // Pointer to a memory buffer usable for writing.
                                 // Access to this memory is checked to be sure it
                                 // is available for writing.
                                 dwOutDataSize,  // The length in bytes of the memory pointed to by
                                 // lpOutData.
                                 &pdwActualData  // Pointer to a DWORD that gets the number of bytes
                                 // actually transferred to pOutData. If this value
                                 // is less than dwOutDataSize, then an error
                                 // situation could exist.
                                 );

        if ( ! SUCCEEDED(hres) ) {
            hError = hres;
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if the escape IOCTL is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"Escape",FALSE);
                DisplayOutput("  Escape IOCTL %d unsupported",EscapeFunction);
            } else {
                StiDisplayError(hres,"Escape",TRUE);
                *bPass = FALSE;
            }
        } else {
            DisplayOutput(" Escape on %S",szFriendlyName);

            DisplayOutput("  %xh (%d) EscapeFunction",
                          EscapeFunction,EscapeFunction);
            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpInData",
                          lpInData[0],
                          lpInData[1],
                          lpInData[2],
                          lpInData[3],
                          lpInData[4],
                          lpInData[5],
                          lpInData[6],
                          lpInData[7],
                          lpInData[8],
                          lpInData[9],
                          lpInData[10],
                          lpInData[11],
                          lpInData[12],
                          lpInData[13],
                          lpInData[14],
                          lpInData[15]
                         );
            DisplayOutput("  %xh (%d) cbInDataSize",
                          cbInDataSize,cbInDataSize);
            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  pOutData",
                          pOutData[0],
                          pOutData[1],
                          pOutData[2],
                          pOutData[3],
                          pOutData[4],
                          pOutData[5],
                          pOutData[6],
                          pOutData[7],
                          pOutData[8],
                          pOutData[9],
                          pOutData[10],
                          pOutData[11],
                          pOutData[12],
                          pOutData[13],
                          pOutData[14],
                          pOutData[15]
                         );
            DisplayOutput("  %xh (%d) dwOutDataSize",
                          dwOutDataSize,dwOutDataSize);
            DisplayOutput("  %xh (%d) pdwActualData",
                          pdwActualData,pdwActualData);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawReadData(char *,LPDWORD,BOOL *)
                Obtains data from a device.

                The RawReadData function is dependent on the vendor's implementation.
                Even if a device does not require the RawReadData function, the driver
                must provide it. A non-functional RawReadData must return an error.

    Parameters:
                char *lpBuffer - Location in memory to transfer the data coming in
                        from the device.
                LPDWORD lpdwNumberOfBytes - number of bytes to be read
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawReadData(char *lpBuffer,LPDWORD lpdwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawReadData
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawReadData");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawReadData interface reads data from a device. This is a
        // general operation for obtaining data from a device. Depending on
        // the user-mode minidriver for the device, command streams and data
        // streams can be read with this call. Some devices may seperate
        // commands from data by using RawReadCommand.
        //
        hres = pStiDevice->RawReadData(
                                      lpBuffer,                       // Location in memory to transfer the data
                                      // coming from the device
                                      lpdwNumberOfBytes,  // Number of bytes requested to be read
                                      lpOverlapped        // This is used to signal that the operation
                                      // of this call should be asynchronous. The
                                      // value here conforms to the Win32 APIs.
                                      );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawReadData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawReadData",FALSE);
                DisplayOutput("  RawReadData unsupported");
            } else {
                StiDisplayError(hres,"RawReadData",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawReadData on %S",szFriendlyName);

            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpBuffer",
                          lpBuffer[0],
                          lpBuffer[1],
                          lpBuffer[2],
                          lpBuffer[3],
                          lpBuffer[4],
                          lpBuffer[5],
                          lpBuffer[6],
                          lpBuffer[7],
                          lpBuffer[8],
                          lpBuffer[9],
                          lpBuffer[10],
                          lpBuffer[11],
                          lpBuffer[12],
                          lpBuffer[13],
                          lpBuffer[14],
                          lpBuffer[15]
                         );
            DisplayOutput("  %xh (%d) lpdwNumberOfBytes read",
                          *lpdwNumberOfBytes,*lpdwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawWriteData(char *,DWORD,BOOL *)
                Sends data to the device.

                The RawWriteData function is dependent on the vendor's
                implementation. Even if a device does not require the RawWriteData
                function, the driver must provide it. A non-functional RawWriteData
                must return an error.

    Parameters:
                char *lpBuffer - Location in memory to read from when sending data to
                        a device.
                LPDWORD lpdwNumberOfBytes - number of bytes of data to be sent
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawWriteData(char *lpBuffer,DWORD dwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawWriteData
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawWriteData");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawWriteData interface writes data to a device. This is a
        // general operation for sending data to a device. Depending on
        // the user-mode minidriver for the device, command streams and data
        // streams can be written with this call. Some devices may seperate
        // commands from data by using RawWriteCommand.
        //
        hres = pStiDevice->RawWriteData(
                                       lpBuffer,                       // Location in memory to read from when sending
                                       // data to a device
                                       dwNumberOfBytes,    // Number of bytes of data to send
                                       lpOverlapped        // This is used to signal that the operation
                                       // of this call should be asynchronous. The
                                       // value here conforms to the Win32 APIs.
                                       );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawWriteData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawWriteData",FALSE);
                DisplayOutput("  RawWriteData unsupported");
            } else {
                StiDisplayError(hres,"RawWriteData",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawWriteData on %S",szFriendlyName);
            DisplayOutput("  %xh (%d) dwNumberOfBytes sent",
                          dwNumberOfBytes,dwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawReadCommand(char *,LPDWORD,BOOL *)
                Obtains command information from the device. Unique to the IStiDevice
                interface.

                The RawReadCommand function is dependent on the vendor's implementation.
                Even if a device does not require the RawReadCommand function, the
                driver must provide it. A non-functional RawReadCommand must return an
                error.

    Parameters:
                char *lpBuffer - Location in memory to transfer the data coming in
                        from the device.
                LPDWORD lpdwNumberOfBytes - number of bytes to be read
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawReadCommand(char *lpBuffer,LPDWORD lpdwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;


    //
    // Must lock device before RawReadCommand
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawReadCommand");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawReadCommand interface reads command information from a
        // device. The implementation of this call depends on the user-mode
        // minidriver for the device. Many devices will not require
        // separating commands and data. If this call is not used, the
        // user-mode minidriver should return STIERR_UNSUPPORTED.
        //
        hres = pStiDevice->RawReadCommand(
                                         lpBuffer,                       // Location in memory to transfer the command
                                         // information coming from the device
                                         lpdwNumberOfBytes,  // Number of command bytes requested to be read
                                         lpOverlapped        // This is used to signal that the operation
                                         // of this call should be asynchronous. The
                                         // value here conforms to the Win32 APIs.
                                         );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawReadCommand is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawReadCommand",FALSE);
                DisplayOutput("  RawReadCommand unsupported");
            } else {
                StiDisplayError(hres,"RawReadCommand",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawReadCommand on %S",szFriendlyName);

            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpBuffer",
                          lpBuffer[0],
                          lpBuffer[1],
                          lpBuffer[2],
                          lpBuffer[3],
                          lpBuffer[4],
                          lpBuffer[5],
                          lpBuffer[6],
                          lpBuffer[7],
                          lpBuffer[8],
                          lpBuffer[9],
                          lpBuffer[10],
                          lpBuffer[11],
                          lpBuffer[12],
                          lpBuffer[13],
                          lpBuffer[14],
                          lpBuffer[15]
                         );
            DisplayOutput("  %xh (%d) lpdwNumberOfBytes read",
                          *lpdwNumberOfBytes,*lpdwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawWriteCommand(char *,DWORD,BOOL *)
                Sends command information to the device. Unique to the IStiDevice
                interface.

                The RawWriteCommand function is dependent on the vendor's
                implementation. Even if a device does not require the RawWriteCommand
                function, the driver must provide it. A non-functional RawWriteCommand
                must return an error.

    Parameters:
                char *lpBuffer - Location in memory to read from when sending data to
                        a device.
                LPDWORD lpdwNumberOfBytes - number of bytes of data to be sent
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawWriteCommand(char *lpBuffer,DWORD dwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawWriteCommand
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawWriteCommand");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawWriteCommand interface sends command information to the
        // device. The implementation of this call depends on the user-mode
        // minidriver for the device. Many devices will not require
        // separating commands and data. If this call is not used, the
        // user-mode minidriver should return STIERR_UNSUPPORTED.
        //
        hres = pStiDevice->RawWriteCommand(
                                          lpBuffer,                       // Location in memory to read from when writing
                                          // command information to the device
                                          dwNumberOfBytes,    // Number of bytes of data to send
                                          lpOverlapped        // This is used to signal that the operation
                                          // of this call should be asynchronous. The
                                          // value here conforms to the Win32 APIs.
                                          );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawWriteData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawWriteCommand",FALSE);
                DisplayOutput("  RawWriteCommand unsupported");
            } else {
                StiDisplayError(hres,"RawWriteCommand",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawWriteCommand on %S",szFriendlyName);
            DisplayOutput("  %xh (%d) dwNumberOfBytes sent",
                          dwNumberOfBytes,dwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\stillvue\winx.cpp ===
/******************************************************************************

  winx.cpp
  Windows utility procedures

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "stillvue.h"

#include <math.h>                       // pow

// WINERROR.H - GetLastError errors
STRINGTABLE StWinerror[] =
{
    ERROR_SUCCESS,              "ERROR_SUCCESS",0,
    ERROR_FILE_NOT_FOUND,       "ERROR_FILE_NOT_FOUND",0,
    ERROR_PATH_NOT_FOUND,       "ERROR_PATH_NOT_FOUND",0,
    ERROR_INVALID_FUNCTION,     "ERROR_INVALID_FUNCTION",0,
    ERROR_ACCESS_DENIED,        "ERROR_ACCESS_DENIED",0,
    ERROR_INVALID_HANDLE,       "ERROR_INVALID_HANDLE",0,
    ERROR_INVALID_PARAMETER,    "ERROR_INVALID_PARAMETER",0,
    ERROR_CALL_NOT_IMPLEMENTED, "ERROR_CALL_NOT_IMPLEMENTED",0,
    ERROR_ALREADY_EXISTS,       "ERROR_ALREADY_EXISTS",0,
    ERROR_INVALID_FLAGS,		"ERROR_INVALID_FLAGS",0,
    ERROR_INVALID_CATEGORY,		"ERROR_INVALID_CATEGORY",0,
    RPC_S_SERVER_UNAVAILABLE,   "RPC_S_SERVER_UNAVAILABLE",0,
    0, "See WINERROR.H",-1
};


/******************************************************************************
  ULONG atox(LPSTR lpHex)

  Convert string to hexadecimal value.
******************************************************************************/
ULONG atox(LPSTR lpHex)
{
    char    *p;
    int     x;
    double  y;
    ULONG   z,ulHex = 0l;


    for (p = lpHex,x = 0;p[x];x++)
        ;

    for (x--,y = 0.0;lpHex <= (p + x);x--,y++)
    {
        z = (ULONG) pow(16.0,y);

        if ((p[x] >= '0')&&(p[x] <= '9'))
            ulHex += ((p[x] - '0') * z);
        if ((p[x] >= 'A')&&(p[x] <= 'F'))
            ulHex += ((p[x] - 'A' + 10) * z);
        if ((p[x] >= 'a')&&(p[x] <= 'f'))
            ulHex += ((p[x] - 'a' + 10) * z);
    }

    return (ulHex);
}


#ifdef _DEBUG

/******************************************************************************
  void DisplayDebug(LPSTR sz,...)

  Output text to debugger.
******************************************************************************/
void DisplayDebug(LPSTR sz,...)
{
    char    Buffer[512];
    va_list list;


    va_start(list,sz);
    vsprintf(Buffer,sz,list);

    OutputDebugString(Buffer);
    OutputDebugString("\n");

    return;
}

#else

/******************************************************************************
  void DisplayDebug(LPSTR sz,...)

  Output text to debugger - nonfunctional retail version..
******************************************************************************/
void DisplayDebug(LPSTR sz,...)
{
    return;
}

#endif


/******************************************************************************
    BOOL ErrorMsg(HWND, LPSTR, LPSTR, BOOL)
    Display an error message and send WM_QUIT if error is fatal.

    Parameters: handle to current window,
    long pointer to string with error message,
    long pointer to string with message box caption,
    error (Fatal if TRUE)

    Shut down app if bFatal is TRUE, continue if FALSE.
******************************************************************************/
BOOL ErrorMsg(HWND hWnd, LPSTR lpzMsg, LPSTR lpzCaption, BOOL bFatal)
{
    MessageBox(hWnd, lpzMsg, lpzCaption, MB_ICONEXCLAMATION | MB_OK);
    if (bFatal)
         PostMessage (hWnd, WM_QUIT, 0, 0L);

    return (bFatal);
}


/******************************************************************************
    fDialog(id,hwnd,fpfn)

    Description:
    This function displays a dialog box and returns the exit code.
    the function passed will have a proc instance made for it.

    Parameters:
    id              resource id of dialog to display
    hwnd            parent window of dialog
    fpfn            dialog message function

    Returns:
    exit code of dialog (what was passed to EndDialog)

******************************************************************************/
BOOL fDialog(int id,HWND hWnd,FARPROC fPfn)
{
    BOOL        f;
    HINSTANCE   hInst;

    hInst = (HINSTANCE) GetWindowLong(hWnd,GWL_HINSTANCE);
    //fPfn  = MakeProcInstance(fPfn,hInst);
    //f = DialogBox(hInst,MAKEINTRESOURCE(id),hWnd,(DLGPROC)fPfn);
    //FreeProcInstance(fPfn);
    f = DialogBox(hInst, MAKEINTRESOURCE(id), hWnd, fPfn);
 
	return (f);
}


/******************************************************************************
    void FormatHex(unsigned char *szSource, char *szDest)

    take first 16 bytes from szSource,
    format into a hex dump string,
    then copy the string into szDest
    szDest must have room for at least 66 bytes

    sample code fragment showing use:
    char            szOut[128],         // output string

    // print header
    sprintf(szOut,
        "Offset    --------------------- hex ---------------------  ---- ascii -----");
    puts(szOut);

    // dump 512 bytes (32 lines, 16 bytes per line)
    for (i = 0; i < 32; i++)
        {
        // get next 16 bytes
        _fmemcpy(szDbgMsg,fpSector + (i*16),16);

        // get current offset into data block
        sprintf(szOut,"%03xh(%03d) ",i*16,i*16);

        // append debug string after data block offset message
        FormatHex(szDbgMsg, szOut + strlen(szOut));
        puts(szOut);
        }

******************************************************************************/
void FormatHex(unsigned char *szSource, char *szDest)
{
    unsigned short  j;


    sprintf(szDest,
        "%02x %02x %02x %02x %02x %02x %02x %02x:"\
        "%02x %02x %02x %02x %02x %02x %02x %02x  ",
        szSource[0],
        szSource[1],
        szSource[2],
        szSource[3],
        szSource[4],
        szSource[5],
        szSource[6],
        szSource[7],
        szSource[8],
        szSource[9],
        szSource[10],
        szSource[11],
        szSource[12],
        szSource[13],
        szSource[14],
        szSource[15]);

    // replace bytes with undesirable Sprintf side effects with SPACE
    for (j = 0; j < 16; j++)
        {
        if ((0x00 == szSource[j]) ||
            (0x07 == szSource[j]) ||
            (0x09 == szSource[j]) ||
            (0x0a == szSource[j]) ||
            (0x0d == szSource[j]) ||
            (0x1a == szSource[j]))
            szSource[j] = 0x20;
        }

    sprintf(szDest + strlen(szDest),
        "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",
        szSource[0],
        szSource[1],
        szSource[2],
        szSource[3],
        szSource[4],
        szSource[5],
        szSource[6],
        szSource[7],
        szSource[8],
        szSource[9],
        szSource[10],
        szSource[11],
        szSource[12],
        szSource[13],
        szSource[14],
        szSource[15]);

    return;
}


/******************************************************************************
    BOOL GetFinalWindow(HANDLE, LPRECT, LPSTR, LPSTR)
    Retrieve the last window size & location from a private INI

    Parameters: handle to current instance,
    long pointer to a rectangle with window size/shape,
    string with INI filename,
    string with Section name

    Returns: success/failure (never fails)

    Get display size in pixels and private INI saved width and height.
    Default width (for no previous INI) is 1/3 display width.
    Default height (for no previous INI) is 1/3 display height.
    If saved size or postion would put part or all the window
    off the desktop, first change the position then the size until
    the window is completely on the desktop.

******************************************************************************/
BOOL GetFinalWindow (HANDLE hInst,
                     LPRECT lprRect,
                     LPSTR  lpzINI,
                     LPSTR  lpzSection)
{
    int       x, nDisplayWidth, nDisplayHeight;
    RECT      rect;


    nDisplayWidth  = GetSystemMetrics(SM_CXSCREEN);
    nDisplayHeight = GetSystemMetrics(SM_CYSCREEN);

    rect.left   = GetPrivateProfileInt(lpzSection, "Left",
       (nDisplayWidth/10) * 7,lpzINI);
    rect.top    = GetPrivateProfileInt(lpzSection, "Top",
       (nDisplayHeight/10) * 8,lpzINI);
    rect.right  = GetPrivateProfileInt(lpzSection, "Right",
       nDisplayWidth,lpzINI);
    rect.bottom = GetPrivateProfileInt(lpzSection, "Bottom",
       nDisplayHeight,lpzINI);


/*/////////////////////////////////////////////////////////////////////////////
    if window hangs off top or left of display, change location to
    edge of display and preserve size.
/////////////////////////////////////////////////////////////////////////////*/
    if (rect.top < 0)
         {
         rect.bottom += rect.top * -1;
         rect.top = 0;
         }

    if (rect.left < 0)
         {
         rect.right += rect.left * -1;
         rect.left = 0;
         }

/*/////////////////////////////////////////////////////////////////////////////
    if window hangs off bottom or right of display, change location
    to bring it back onscreen.  If window dimension is greater than
    display, reduce to size of display.
/////////////////////////////////////////////////////////////////////////////*/
    if (rect.bottom > nDisplayHeight)
         {
         if (rect.bottom > nDisplayHeight * 2)
              {
              rect.top    = 0;
              rect.bottom = nDisplayHeight;
              }
         else
              {
              x = rect.bottom - nDisplayHeight;
              rect.bottom -= x;
              rect.top    -= x;
              }
         }

    if (rect.right > nDisplayWidth)
         {
         if (rect.right > nDisplayWidth * 2)
              {
              rect.left  = 0;
              rect.right = nDisplayWidth;
              }
         else
              {
              x = rect.right - nDisplayWidth;
              rect.right -= x;
              rect.left  -= x;
              }
         }

/*/////////////////////////////////////////////////////////////////////////////
    GetWindowRect() returns a rect where right and bottom are absolute
    (measured from 0,0 of display).  However, CreateWindow requires
    right and bottom to be relative (measured from 0,0 of the window
    to be created).  SaveFinalWindow saves an absolute rect, and
    GetFinalRect converts these to relative measurements.
/////////////////////////////////////////////////////////////////////////////*/
    SetRect(lprRect,
         rect.left,
         rect.top,
         rect.right - rect.left,
         rect.bottom - rect.top);

    return (TRUE);
}


/******************************************************************************
    BOOL LastError(BOOL)

    Calls GetLastError and displays result in a nice string

    Parameters: bNewOnly == TRUE if you only want changed error displayed
    Returns: TRUE if it found an error, else FALSE
******************************************************************************/
BOOL LastError(BOOL bNewOnly)
{
static  DWORD   dwLast = 0;
        DWORD   dwError;


    if (dwError = GetLastError())
    {
        // if user asked for only new errors
        if (bNewOnly)
        {
            // not a new error
            if (dwLast == dwError)
                return FALSE;
            // new error, save it
            dwLast = dwError;
        }
        DisplayOutput("*GetLastError %xh %d \"%s\"",
            dwError,dwError,StrFromTable(dwError,StWinerror));
        return (TRUE);
    }

	return (FALSE);
}


/******************************************************************************
  int NextToken(char *pDest,char *pSrc)

  Return next token from a command line string.
******************************************************************************/
int NextToken(char *pDest,char *pSrc)
{
    char    *pA,*pB;
    int     x;


    // point pArg to start of token in string pSrc
    for (pA = pSrc;*pA && isspace((int) *pA);pA++)
        ;

    // find end of token in string pSrc
    for (pB = pA;((*pB) && (! isspace((int) *pB)));pB++)
        ;

	// count of chars to next token or end of string
	x = (min((pB - pA),(int) strlen(pSrc))) + 1;

    // pszDest now contains the arg
    lstrcpyn(pDest,pA,x);

    // return sizeof token
    return (x);
}


/******************************************************************************
    BOOL SaveFinalWindow(HANDLE, HWND, LPSTR, LPSTR)
    Save the current window size & location to a private INI

    Parameters: handle to current instance,
    handle to current window,
    string with INI filename,
    string with Section name

    Returns: success/failure (fails if window is MIN or MAX)
******************************************************************************/
BOOL SaveFinalWindow (HANDLE hInst,
                      HWND hWnd,
                      LPSTR lpzINI,
                      LPSTR lpzSection)
{
    PSTR      pszValue;
    RECT      rectWnd, rectINI;


    // if the window is minimized OR maximised, don't save anything
    if (IsIconic(hWnd) || IsZoomed(hWnd))
         return (FALSE);

    GetWindowRect (hWnd, &rectWnd);

    // get INI data.  If there isn't any, we'll get the default and
    // save the current Window data.
    rectINI.left   = GetPrivateProfileInt(lpzSection, "Left", 0, lpzINI);
    rectINI.top    = GetPrivateProfileInt(lpzSection, "Top", 0, lpzINI);
    rectINI.right  = GetPrivateProfileInt(lpzSection, "Right", 0, lpzINI);
    rectINI.bottom = GetPrivateProfileInt(lpzSection, "Bottom", 0, lpzINI);

    // if current window is same as in INI, don't change INI
    if ( rectINI.left   == rectWnd.left  &&
         rectINI.top    == rectWnd.top   &&
         rectINI.right  == rectWnd.right &&
         rectINI.bottom == rectWnd.bottom)
         return (TRUE);

    // EXIT if we can't local alloc our string stuffer
    if ((pszValue = (PSTR) LocalAlloc(LPTR, 80)) == NULL)
         return (FALSE);

    // it's different, so save
    sprintf(pszValue, "%d", rectWnd.left);
    WritePrivateProfileString(lpzSection, "Left", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.top);
    WritePrivateProfileString(lpzSection, "Top", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.right);
    WritePrivateProfileString(lpzSection, "Right", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.bottom);
    WritePrivateProfileString(lpzSection, "Bottom", pszValue, lpzINI);
    LocalFree((HANDLE) pszValue);

    return (TRUE);
}


/******************************************************************************
  char * StrFromTable(long number,PSTRINGTABLE pstrTable)

  Return string associated with a value from a string table.
******************************************************************************/
char * StrFromTable(long number,PSTRINGTABLE pstrTable)
{
    for (;pstrTable->end != -1;pstrTable++)
    {
        if (number == pstrTable->number)
            break;
    }

    return (pstrTable->szString);
}


/******************************************************************************
    BOOL Wait32(DWORD)

    wait DWORD milliseconds, then return

******************************************************************************/
BOOL Wait32(DWORD dwTime)
{
   DWORD   dwNewTime,
           dwOldTime;


   // wait dwTime, then exit
   dwOldTime = GetCurrentTime();
   while (TRUE)
       {
       dwNewTime = GetCurrentTime();
       if (dwNewTime > dwOldTime + dwTime)
           break;
       }

   return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\addremove.h ===
#if !defined(AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_)
#define AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddRemove.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddRemove dialog

class CAddRemove : public CDialog
{
// Construction
public:
	void GetNewKeyName(TCHAR *pszNewKeyName);
	void SetStatusText(TCHAR *pszStatusText);
	void SetTitle(TCHAR *pszDlgTitle);
	TCHAR m_szTitle[MAX_PATH];
	CAddRemove(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddRemove)
	enum { IDD = IDD_ADD_REMOVE_DIALOG };
	CString	m_NewKeyName;
	CString	m_StatusText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRemove)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRemove)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\logviewer.cpp ===
// LogViewer.cpp : implementation file
//

#include "stdafx.h"
#include "wialogcfg.h"
#include "LogViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static DWORD CALLBACK MyStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

CProgCtrl::CProgCtrl()
{
    m_pProgressCtrl = NULL;
}

CProgCtrl::~CProgCtrl()
{

}

void CProgCtrl::SetControl(CProgressCtrl *pProgressCtrl)
{
    m_pProgressCtrl = pProgressCtrl;
}

void CProgCtrl::SetupProgressCtrl(PROGCTRL_SETUP_INFO *pSetupInfo)
{
    m_pProgressCtrl->SetStep(pSetupInfo->iStepValue);
    m_pProgressCtrl->SetRange((short)pSetupInfo->iMinRange,(short)pSetupInfo->iMaxRange);
    m_MaxRange = pSetupInfo->iMaxRange;
}

void CProgCtrl::StepIt()
{
    //TCHAR szBuffer[MAX_PATH];
    //sprintf(szBuffer,"Processing %d%",(m_pProgressCtrl->StepIt() * 100) / m_MaxRange);
    //m_pStaticText->SetWindowText(szBuffer);
    //m_pStaticText->Invalidate();

    m_pProgressCtrl->StepIt();
}

void CProgCtrl::DestroyME()
{

}

/////////////////////////////////////////////////////////////////////////////
// CLogViewer dialog


CLogViewer::CLogViewer(CWnd* pParent /*=NULL*/)
    : CDialog(CLogViewer::IDD, pParent)
{
    //{{AFX_DATA_INIT(CLogViewer)
    m_pProgDlg = NULL;
    m_bColorizeLog = FALSE;
    //}}AFX_DATA_INIT
}


void CLogViewer::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogViewer)
    DDX_Control(pDX, IDC_RICHEDIT_LOGVIEWER, m_LogViewer);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogViewer, CDialog)
    //{{AFX_MSG_MAP(CLogViewer)
    ON_WM_SIZE()
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogViewer message handlers

BOOL CLogViewer::OnInitDialog()
{
    CDialog::OnInitDialog();
    m_bKillInitialSelection = TRUE;

    //
    // Set FONT to fixed, for formatting reasons
    //

    HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    if(hFixedFont != NULL)
        m_LogViewer.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);

    //
    // Get Windows Directory
    //

    TCHAR szLogFilePath[MAX_PATH];

    DWORD dwLength = 0;
    dwLength = ::GetWindowsDirectory(szLogFilePath,sizeof(szLogFilePath));
    if (( dwLength == 0) || !*szLogFilePath ) {
        OutputDebugString(TEXT("Could not GetWindowsDirectory()"));
        return TRUE;
    }

    //
    // Add log file name to Windows Directory
    //

    lstrcat(lstrcat(szLogFilePath,TEXT("\\")),TEXT("wiaservc.log"));

    // The file from which to load the contents of the rich edit control.
    CFile cFile(szLogFilePath, CFile::shareDenyNone|CFile::modeRead);
    EDITSTREAM es;

    es.dwCookie = (DWORD) (DWORD_PTR)&cFile;
    es.pfnCallback = MyStreamInCallback;
    m_LogViewer.StreamIn(SF_TEXT, es);
    UpdateData(TRUE);

    if(m_bColorizeLog)
        ParseLogToColor();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

static DWORD CALLBACK MyStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    CFile* pFile = (CFile*) dwCookie;
    *pcb = pFile->Read(pbBuff, cb);
    return 0;
}

void CLogViewer::OnSize(UINT nType, int cx, int cy)
{
    CDialog::OnSize(nType, cx, cy);
    if(m_LogViewer.m_hWnd != NULL) {
        m_LogViewer.MoveWindow(0, 0, cx, cy);
    }
}

void CLogViewer::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CDialog::OnShowWindow(bShow, nStatus);
    if(m_bKillInitialSelection) {
        m_LogViewer.SetSel(0,0);
        m_bKillInitialSelection = FALSE;
    }
}

void CLogViewer::ColorizeText(BOOL bColorize)
{
    m_bColorizeLog = bColorize;
}
void CLogViewer::ColorLine(int LineNumber, COLORREF rgbColor)
{
    int iStartSel = 0;
    int iEndSel   = -1;

    if(LineNumber >0) {
        iStartSel = m_LogViewer.LineIndex(LineNumber);
        iEndSel   = iStartSel + m_LogViewer.LineLength(iStartSel);
    }


    CHARFORMAT cf;
    memset(&cf,0,sizeof(cf));
    cf.cbSize       = sizeof(CHARFORMAT);
    cf.dwMask       = CFM_COLOR | CFM_UNDERLINE | CFM_BOLD;
    cf.dwEffects    =(unsigned long) ~( CFE_AUTOCOLOR | CFE_UNDERLINE | CFE_BOLD);
    cf.crTextColor  = rgbColor;

    m_LogViewer.SetSel(iStartSel,iEndSel);
    m_LogViewer.SetSelectionCharFormat(cf);
}

void CLogViewer::ColorLine(int iStartSel, int iEndSel, COLORREF rgbColor)
{
    CHARFORMAT cf;
    memset(&cf,0,sizeof(cf));
    cf.cbSize       = sizeof(CHARFORMAT);
    cf.dwMask       = CFM_COLOR | CFM_UNDERLINE | CFM_BOLD;
    cf.dwEffects    =(unsigned long) ~( CFE_AUTOCOLOR | CFE_UNDERLINE | CFE_BOLD);
    cf.crTextColor  = rgbColor;

    m_LogViewer.SetSel(iStartSel,iEndSel);
    m_LogViewer.SetSelectionCharFormat(cf);
}

void CLogViewer::ParseLogToColor()
{
    TCHAR szBuffer[MAX_PATH];
    int NumLines = m_LogViewer.GetLineCount();
    int iStartSel = 0;
    int iEndSel = 0;
    BOOL bTrace = FALSE;
    BOOL bError = FALSE;
    BOOL bhResult = FALSE;
    BOOL bWarning = FALSE;

    if(m_pProgDlg != NULL) {

        PROGCTRL_SETUP_INFO SetupInfo;
        SetupInfo.iMinRange = 0;
        SetupInfo.iMaxRange = NumLines;
        SetupInfo.iStepValue = 1;

        m_pProgDlg->SetupProgressCtrl(&SetupInfo);

        for(int LineNumber = 0;LineNumber < NumLines;LineNumber++) {

            m_pProgDlg->StepIt();

            //
            // get line to parse
            //

            int CharactersWritten = m_LogViewer.GetLine(LineNumber,szBuffer,MAX_PATH);
            szBuffer[CharactersWritten] = '\0';

            //
            // Search for TRACE
            //

            if(strstr(szBuffer,TEXT("TRACE"))!= NULL) {
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }

                if(bTrace == FALSE) {
                    bTrace = TRUE;
                }
            }

            //
            // Search for ERROR
            //

            if(strstr(szBuffer,TEXT("ERROR")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bError == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bError = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Search for HRESULT
            //

            if(strstr(szBuffer,TEXT("HRESULT")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bhResult == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bhResult = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Search for WARNING
            //

            if(strstr(szBuffer,TEXT("WARNING")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bWarning = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Column separators
            //

            if(strstr(szBuffer,TEXT("=====")) != NULL){
                ColorLine(LineNumber,RGB(0,0,255));
                ColorLine(LineNumber+1,RGB(0,0,255));
                ColorLine(LineNumber+2,RGB(0,0,255));
                LineNumber+=3;
            }
    }

    if(bError)
        ColorLine(iStartSel,iEndSel,RGB(255,0,0));
    else if (bhResult)
        ColorLine(iStartSel,iEndSel,RGB(255,0,0));
    else if (bWarning)
        ColorLine(iStartSel,iEndSel,RGB(255,110,0));

    m_pProgDlg->DestroyME();
    }
}

void CLogViewer::SetProgressCtrl(CProgCtrl *pProgCtrl)
{
    m_pProgDlg = pProgCtrl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WiaLogCFG.rc
//
#define REGSTR_PATH_STICONTROL          1
#define REGSTR_VAL_LOG_LEVEL            2
#define REGSTR_VAL_MODE                 3
#define REGSTR_VAL_MAXSIZE              4
#define REGSTR_VAL_TRUNCATE_ON_BOOT     5
#define REGSTR_VAL_DETAIL               6
#define REGSTR_VAL_LOGGING              7
#define REGSTR_VAL_CLEARLOG_ON_BOOT     8
#define REGSTR_VAL_LOG_TO_DEBUGGER      9
#define IDD_WIALOGCFG_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDD_ADD_REMOVE_DIALOG           129
#define IDD_VIEW_LOG_DIALOG             130
#define IDD_PARSE_PROGRESS_DIALOG       131
#define IDC_LOG_LEVEL_TRACE             1000
#define IDC_LOG_LEVEL_WARNING           1001
#define IDC_LOG_LEVEL_ERROR             1002
#define IDC_FILTER_OFF                  1004
#define IDC_FILTER_1                    1005
#define IDC_FILTER_2                    1006
#define IDC_FILTER_3                    1007
#define IDC_FILTER_CUSTOM               1008
#define IDC_EDIT_CUSTOM_LEVEL           1009
#define IDC_ADD_TIME                    1010
#define IDC_ADD_MODULENAME              1011
#define IDC_ADD_THREADID                1012
#define IDC_SELECT_MODULE_COMBOBOX      1013
#define IDC_ADD_MODULE_BUTTON           1014
#define IDC_DELETE_MODULE_BUTTON        1015
#define IDC_TRUNCATE_ON_BOOT            1016
#define IDC_WRITE_SETTINGS_BUTTON       1018
#define IDC_EDIT_KEYNAME                1019
#define IDC_STATUS_TEXT                 1020
#define IDC_CLEARLOG_BUTTON             1021
#define IDC_VIEW_LOG_BUTTON             1023
#define IDC_RICHEDIT_LOGVIEWER          1024
#define IDC_PROGRESS1                   1025
#define IDC_PARSE_PROGRESS              1025
#define IDC_CANCEL_PARSING_BUTTON       1026
#define IDC_PARSE_TEXT_STATUS           1027
#define IDC_CLEARLOG_ON_BOOT            1028
#define IDC_LOG_TO_DEBUGGER             1030
#define IDC_COLOR_CODE_LOGVIEWER_TEXT   1031

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wialogcfg
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\wialogcfg.cpp        \
        ..\wialogcfgdlg.cpp     \
        ..\registry.cpp         \
        ..\logviewer.cpp        \
        ..\addremove.cpp        \
        ..\wialogcfg.rc


# Add interlac.cpp if the PNG support is ever fixed

MISCFILES = ..\wialogcfg.htm

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\logviewer.h ===
#if !defined(AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_)
#define AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogViewer.h : header file
//

typedef struct _PROGCTRL_SETUP_INFO {	
	int iMaxRange;
	int iMinRange;
	int iStepValue;
}PROGCTRL_SETUP_INFO;

class CProgCtrl
{
public:
	CProgCtrl();
	~CProgCtrl();
	void SetControl(CProgressCtrl *pProgressCtrl);
	void SetupProgressCtrl(PROGCTRL_SETUP_INFO *pSetupInfo);
	void StepIt();
	void DestroyME();
	int m_MaxRange;
	BOOL bCancel;
private:
	 CProgressCtrl *m_pProgressCtrl;
	 CStatic  *m_pStaticText;
};

/////////////////////////////////////////////////////////////////////////////
// CLogViewer dialog

class CLogViewer : public CDialog
{
// Construction
public:
	void ColorizeText(BOOL bColorize);
	CProgCtrl *m_pProgDlg;
	void SetProgressCtrl(CProgCtrl *pProgCtrl);
	void ParseLogToColor();
	void ColorLine(int LineNumber, COLORREF rgbColor);
	void ColorLine(int iStartSel, int iEndSel, COLORREF rgbColor);
	BOOL m_bKillInitialSelection;
	BOOL m_bColorizeLog;
	CLogViewer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLogViewer)
	enum { IDD = IDD_VIEW_LOG_DIALOG };
	CRichEditCtrl	m_LogViewer;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogViewer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support	
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLogViewer)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WiaLogCFG.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_)
#define AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\registry.h ===
#ifndef REGISTRY_H
#define REGISRTY_H

#if _MSC_VER > 1000
#pragma once
#endif

#include "resource.h"

class CRegistry
{
    public:
        CRegistry();
        CRegistry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~CRegistry();
        BOOL Open(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
		BOOL CreateKey(const TCHAR *pszSubKey);
		BOOL DeleteKey(const TCHAR *pszSubKey);
        BOOL Close();
        
        LONG SetValue(const TCHAR *pszValue, DWORD dwNumber);
        LONG GetValue(const TCHAR *pszValue,DWORD dwDefault);
        VOID MoveToSubKey(const TCHAR *pszSubKeyName);
        
        HKEY GetKey()      { return m_hkey;    };
        BOOL IsValid()     { return bhkeyValid;};
		LONG GetError()    { return m_error;   };
		VOID ClearErrors() { m_error = 0;      };
		LONG EnumerateKeys(DWORD dwIndex,TCHAR *pszKeyName, DWORD dwSize);
    private:
        HKEY m_hkey;
        long m_error;
        BOOL bhkeyValid;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\registry.cpp ===
//
// Registry.cpp
//

#include "stdafx.h"
#include "Registry.h"

CRegistry::CRegistry()
{
	m_hkey = NULL;
    bhkeyValid = FALSE;
}

CRegistry::~CRegistry()
{
	Close();
}

CRegistry::CRegistry(const TCHAR *pszSubKey, HKEY hkey)
{
	m_hkey = NULL;
    bhkeyValid = FALSE;
    Open(pszSubKey, hkey);
}

BOOL CRegistry::Open(const TCHAR *pszSubKey, HKEY hkey)
{
	Close();
    m_error = RegCreateKey(hkey, pszSubKey, &m_hkey);
    if (m_error)
        bhkeyValid = FALSE;    
    else
        bhkeyValid = TRUE;
    return bhkeyValid;
}

BOOL CRegistry::Close()
{
    if (bhkeyValid)
        RegCloseKey(m_hkey);
    m_hkey = NULL;
    bhkeyValid = FALSE;
    return TRUE;
}

BOOL CRegistry::CreateKey(const TCHAR *pszSubKey)
{
	HKEY hKey;
	m_error = RegCreateKey(m_hkey, pszSubKey, &hKey);
	if(m_error)
		return FALSE;
	return TRUE;
}

BOOL CRegistry::DeleteKey(const TCHAR *pszSubKey)
{
	m_error = RegDeleteKey(m_hkey,pszSubKey);
	if(m_error)
		return FALSE;
	else
		return TRUE;
}

LONG CRegistry::SetValue(const TCHAR *pszValue, DWORD dwNumber)
{
    if (bhkeyValid) {
        m_error = RegSetValueEx(m_hkey,
			                    pszValue,
								0,
								REG_DWORD,
								(BYTE *)&dwNumber,
								sizeof(dwNumber));
    }
    return m_error;
}

LONG CRegistry::GetValue(const TCHAR *pszValue, DWORD dwDefault)
{
	DWORD   dwType = REG_DWORD;
    long    dwNumber = 0L;
    DWORD   dwSize = sizeof(dwNumber);
	
    if (bhkeyValid) {
        m_error = RegQueryValueEx(m_hkey,
			                     (LPTSTR) pszValue,
								  0,
								  &dwType,
								  (LPBYTE)&dwNumber,
								  &dwSize);
    }
    if (m_error)
        dwNumber = dwDefault;	
    return dwNumber;
}

VOID CRegistry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY _hNewKey;
    if (bhkeyValid) {
        m_error = RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
            RegCloseKey(m_hkey);
            m_hkey = _hNewKey;
        }
    }
}

LONG CRegistry::EnumerateKeys(DWORD dwIndex,TCHAR *pszKeyName, DWORD dwSize)
{
	FILETIME ft;
	LONG lError = 0;
	memset(pszKeyName,0,sizeof(pszKeyName));

	lError =  RegEnumKeyEx(m_hkey,       // handle to key to enumerate
					    dwIndex,      // index of subkey to enumerate
					    pszKeyName,   // address of buffer for subkey name
					    &dwSize,      // address for size of subkey buffer
					    NULL,         // reserved
					    NULL,         // address of buffer for class string
					    NULL,         // address for size of class buffer
					    &ft           // address for time key last written to
		);

	return lError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\wialogcfg.cpp ===
// WiaLogCFG.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "WiaLogCFG.h"
#include "WiaLogCFGDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp

BEGIN_MESSAGE_MAP(CWiaLogCFGApp, CWinApp)
    //{{AFX_MSG_MAP(CWiaLogCFGApp)
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp construction

CWiaLogCFGApp::CWiaLogCFGApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWiaLogCFGApp object

CWiaLogCFGApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp initialization

BOOL CWiaLogCFGApp::InitInstance()
{
    AfxInitRichEdit();
    // Standard initialization

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CWiaLogCFGDlg dlg;
    m_pMainWnd = &dlg;
    dlg.DoModal();

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\wialogcfg.h ===
// WiaLogCFG.h : main header file for the WIALOGCFG application
//

#if !defined(AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_)
#define AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp:
// See WiaLogCFG.cpp for the implementation of this class
//

class CWiaLogCFGApp : public CWinApp
{
public:
	CWiaLogCFGApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaLogCFGApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWiaLogCFGApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\wialogcfgdlg.cpp ===
// WiaLogCFGDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WiaLogCFG.h"
#include "WiaLogCFGDlg.h"
#include "AddRemove.h"
#include "LogViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg dialog

CWiaLogCFGDlg::CWiaLogCFGDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CWiaLogCFGDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaLogCFGDlg)
    m_dwCustomLevel = 0;
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_bColorCodeLogViewerText = FALSE;
}

void CWiaLogCFGDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaLogCFGDlg)
	DDX_Control(pDX, IDC_COLOR_CODE_LOGVIEWER_TEXT, m_ColorCodeLogViewerTextCheckBox);
	DDX_Control(pDX, IDC_LOG_TO_DEBUGGER, m_LogToDebuggerCheckBox);
	DDX_Control(pDX, IDC_CLEARLOG_ON_BOOT, m_ClearLogOnBootCheckBox);
	DDX_Control(pDX, IDC_PARSE_PROGRESS, m_ProgressCtrl);
    DDX_Control(pDX, IDC_ADD_TIME, m_AddTimeCheckBox);
    DDX_Control(pDX, IDC_ADD_THREADID, m_AddThreadIDCheckBox);
    DDX_Control(pDX, IDC_ADD_MODULENAME, m_AddModuleCheckBox);
    DDX_Control(pDX, IDC_TRUNCATE_ON_BOOT, m_TruncateOnBootCheckBox);
    DDX_Control(pDX, IDC_SELECT_MODULE_COMBOBOX, m_ModuleComboBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_WARNING, m_WarningCheckBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_ERROR, m_ErrorCheckBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_TRACE, m_TraceCheckBox);
    DDX_Control(pDX, IDC_FILTER_OFF, m_FilterOff);
    DDX_Control(pDX, IDC_FILTER_1, m_Filter1);
    DDX_Control(pDX, IDC_FILTER_2, m_Filter2);
    DDX_Control(pDX, IDC_FILTER_3, m_Filter3);
    DDX_Control(pDX, IDC_FILTER_CUSTOM, m_FilterCustom);
    DDX_Text(pDX, IDC_EDIT_CUSTOM_LEVEL, m_dwCustomLevel);
    DDV_MinMaxDWord(pDX, m_dwCustomLevel, 0, 9999);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWiaLogCFGDlg, CDialog)
    //{{AFX_MSG_MAP(CWiaLogCFGDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_ADD_MODULE_BUTTON, OnAddModuleButton)
    ON_BN_CLICKED(IDC_DELETE_MODULE_BUTTON, OnDeleteModuleButton)
    ON_BN_CLICKED(IDC_WRITE_SETTINGS_BUTTON, OnWriteSettingsButton)
    ON_CBN_SELCHANGE(IDC_SELECT_MODULE_COMBOBOX, OnSelchangeSelectModuleCombobox)
	ON_BN_CLICKED(IDC_CLEARLOG_BUTTON, OnClearlogButton)
	ON_BN_CLICKED(IDC_VIEW_LOG_BUTTON, OnViewLogButton)
	ON_CBN_SETFOCUS(IDC_SELECT_MODULE_COMBOBOX, OnSetfocusSelectModuleCombobox)
	ON_CBN_DROPDOWN(IDC_SELECT_MODULE_COMBOBOX, OnDropdownSelectModuleCombobox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg message handlers

BOOL CWiaLogCFGDlg::OnInitDialog()
{
    m_hInstance = NULL;
    m_hInstance = AfxGetInstanceHandle();
    CDialog::OnInitDialog();
	
	ShowProgress(FALSE);
	
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    
    m_LogInfo.dwLevel          = 0;
    m_LogInfo.dwMaxSize        = 100000;
    m_LogInfo.dwMode           = 0;
    m_LogInfo.dwTruncateOnBoot = 0;
    memset(m_LogInfo.szKeyName,0,sizeof(m_LogInfo.szKeyName));

    m_CurrentSelection = 0;
    
    InitializeDialogSettings(SETTINGS_RESET_DIALOG);
    RegistryOperation(REG_READ);
    InitializeDialogSettings(SETTINGS_TO_DIALOG);

	CheckGlobalServiceSettings();

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWiaLogCFGDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

HCURSOR CWiaLogCFGDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CWiaLogCFGDlg::OnAddModuleButton() 
{
	CAddRemove AddRemoveDlg;
	AddRemoveDlg.SetTitle(TEXT("Add a Module"));
	AddRemoveDlg.SetStatusText(TEXT("Enter a Module Name:"));
	if(AddRemoveDlg.DoModal() == IDOK) {
		m_TruncateOnBootCheckBox.SetCheck(0);
		m_ClearLogOnBootCheckBox.SetCheck(0);
		AddRemoveDlg.GetNewKeyName(m_LogInfo.szKeyName);
		RegistryOperation(REG_ADD_KEY);		
		RegistryOperation(REG_READ);
		CheckGlobalServiceSettings();
	}
}

void CWiaLogCFGDlg::OnDeleteModuleButton() 
{
	if(MessageBox(TEXT("Are you sure you want to DELETE this module?"),
		          TEXT("Delete Module"),
				  MB_YESNO|MB_ICONQUESTION) == IDYES) {

		//
		// Delete this module
		//
		
		RegistryOperation(REG_DELETE_KEY);
		RegistryOperation(REG_READ);
	}
}

void CWiaLogCFGDlg::RegistryOperation(ULONG ulFlags)
{   
    TCHAR szAppRegistryKey[MAX_PATH];
    TCHAR szValueName[MAX_PATH];
        
    LoadString(m_hInstance, REGSTR_PATH_STICONTROL, szAppRegistryKey, MAX_PATH);
    CRegistry Registry(szAppRegistryKey,HKEY_LOCAL_MACHINE);

    //
    // move to logging
    //

    LoadString(m_hInstance,REGSTR_VAL_LOGGING , szValueName, MAX_PATH);
    Registry.MoveToSubKey(szValueName);

	if(ulFlags == REG_ADD_KEY) {

		//
		// Add a new key
		//

		Registry.CreateKey(m_LogInfo.szKeyName);
		
		//
		// change current selection to an invalid selection
		//

		m_CurrentSelection = -99;
		return;
	}
	
	if( ulFlags == REG_DELETE_KEY) {

		//
		// delete a Key
		//

		Registry.DeleteKey(m_LogInfo.szKeyName);
		return;
	}

    //
    // enumerate keys
    //

    DWORD dwIndex = 0;
    TCHAR pszKeyName[64];

    m_ModuleComboBox.ResetContent();
    
    while(Registry.EnumerateKeys(dwIndex++,pszKeyName, sizeof(pszKeyName)) != ERROR_NO_MORE_ITEMS) {
        m_ModuleComboBox.AddString(pszKeyName); 
    }
    
	if(m_CurrentSelection == -99){
		INT nIndex = m_ModuleComboBox.FindString(-1, m_LogInfo.szKeyName);
		m_CurrentSelection = nIndex;
		m_ModuleComboBox.SetCurSel(nIndex);

	} else {		
		m_ModuleComboBox.GetLBText(m_CurrentSelection,m_LogInfo.szKeyName);
	}

    m_ModuleComboBox.SetCurSel(m_CurrentSelection);
    
	//
    // move to DLL specifc subkey
    //

    Registry.MoveToSubKey(m_LogInfo.szKeyName);    

    switch(ulFlags) {
    case REG_WRITE:        
        LoadString(m_hInstance,REGSTR_VAL_LOG_LEVEL , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwLevel);
        
        LoadString(m_hInstance,REGSTR_VAL_MODE , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwMode);
        
        LoadString(m_hInstance,REGSTR_VAL_MAXSIZE , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwMaxSize);
        
        LoadString(m_hInstance,REGSTR_VAL_TRUNCATE_ON_BOOT , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwTruncateOnBoot);

		LoadString(m_hInstance,REGSTR_VAL_CLEARLOG_ON_BOOT , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwClearLogOnBoot);

        LoadString(m_hInstance,REGSTR_VAL_DETAIL , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwDetail);

		LoadString(m_hInstance,REGSTR_VAL_LOG_TO_DEBUGGER, szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwLogToDebugger);
		
        break;    
	case REG_READ:
    default:        
        LoadString(m_hInstance,REGSTR_VAL_LOG_LEVEL , szValueName, MAX_PATH);
        m_LogInfo.dwLevel = Registry.GetValue(szValueName,WIALOG_NO_LEVEL);
        
        LoadString(m_hInstance,REGSTR_VAL_MODE , szValueName, MAX_PATH);
        m_LogInfo.dwMode = Registry.GetValue(szValueName,WIALOG_ADD_MODULE|WIALOG_ADD_THREAD);
        
        LoadString(m_hInstance,REGSTR_VAL_MAXSIZE , szValueName, MAX_PATH);
        m_LogInfo.dwMaxSize = Registry.GetValue(szValueName,100000);
        
        LoadString(m_hInstance,REGSTR_VAL_TRUNCATE_ON_BOOT, szValueName, MAX_PATH);
        m_LogInfo.dwTruncateOnBoot = Registry.GetValue(szValueName,0);

		LoadString(m_hInstance,REGSTR_VAL_CLEARLOG_ON_BOOT, szValueName, MAX_PATH);
        m_LogInfo.dwClearLogOnBoot = Registry.GetValue(szValueName,0);
		
        LoadString(m_hInstance,REGSTR_VAL_DETAIL , szValueName, MAX_PATH);
        m_LogInfo.dwDetail = Registry.GetValue(szValueName,0);

		LoadString(m_hInstance,REGSTR_VAL_LOG_TO_DEBUGGER, szValueName, MAX_PATH);
		m_LogInfo.dwLogToDebugger = Registry.GetValue(szValueName,0);

        break;
    }
}

void CWiaLogCFGDlg::InitializeDialogSettings(ULONG ulFlags)
{
    switch (ulFlags) {
    case SETTINGS_TO_DIALOG:

        //
        // set level of detail
        //

        switch (m_LogInfo.dwDetail) {
        case WIALOG_NO_LEVEL:
            m_FilterOff.SetCheck(1);
            break;
        case WIALOG_LEVEL1 :
            m_Filter1.SetCheck(1);
            break;
        case WIALOG_LEVEL2:
            m_Filter2.SetCheck(1);
            break;
        case WIALOG_LEVEL3:
            m_Filter3.SetCheck(1);
            break;      
        default:
            m_FilterCustom.SetCheck(1);
            m_dwCustomLevel = m_LogInfo.dwDetail;
            UpdateData(FALSE);          
            break;
        }

        //
        // set truncate on boot check box
        //

        if (m_LogInfo.dwTruncateOnBoot != 0)
            m_TruncateOnBootCheckBox.SetCheck(1);
        else
            m_TruncateOnBootCheckBox.SetCheck(0);

		//
        // set clear log on boot check box
        //

        if (m_LogInfo.dwClearLogOnBoot != 0)
            m_ClearLogOnBootCheckBox.SetCheck(1);
        else
            m_ClearLogOnBootCheckBox.SetCheck(0);

		//
		// set log to debugger check box
		//

		if (m_LogInfo.dwLogToDebugger != 0)
            m_LogToDebuggerCheckBox.SetCheck(1);
        else
            m_LogToDebuggerCheckBox.SetCheck(0);



        //
        // set trace level check boxes
        //

        if (m_LogInfo.dwLevel & WIALOG_TRACE)
            m_TraceCheckBox.SetCheck(1);
        if (m_LogInfo.dwLevel & WIALOG_ERROR)
            m_ErrorCheckBox.SetCheck(1);
        if (m_LogInfo.dwLevel & WIALOG_WARNING)
            m_WarningCheckBox.SetCheck(1);

        //
        // set additional details check boxes
        //

        if (m_LogInfo.dwMode & WIALOG_ADD_TIME)
            m_AddTimeCheckBox.SetCheck(1);
        if (m_LogInfo.dwMode & WIALOG_ADD_MODULE)
            m_AddModuleCheckBox.SetCheck(1);
        if (m_LogInfo.dwMode & WIALOG_ADD_THREAD)
            m_AddThreadIDCheckBox.SetCheck(1);
    break;
    case SETTINGS_FROM_DIALOG:

        //
        // get level of detail
        //

        if (m_FilterOff.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_NO_LEVEL;
        if (m_Filter1.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL1;
        if (m_Filter2.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL2;
        if (m_Filter3.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL3;
        if (m_FilterCustom.GetCheck() == 1) {
            UpdateData(TRUE);
            m_LogInfo.dwDetail = m_dwCustomLevel;
        }

        //
        // get truncate on boot check box
        //

        if (m_TruncateOnBootCheckBox.GetCheck() == 1)
            m_LogInfo.dwTruncateOnBoot = 1;
        else
            m_LogInfo.dwTruncateOnBoot = 0;

		//
        // get clear log on boot check box
        //

        if (m_ClearLogOnBootCheckBox.GetCheck() == 1)
            m_LogInfo.dwClearLogOnBoot = 1;
        else
            m_LogInfo.dwClearLogOnBoot = 0;

        
		//
		// get log to debugger check box
		//

		if(m_LogToDebuggerCheckBox.GetCheck() == 1)
			m_LogInfo.dwLogToDebugger = 1;
		else
			m_LogInfo.dwLogToDebugger = 0;


		//
        // get trace level check boxes
        //

        m_LogInfo.dwLevel = 0;

        if (m_TraceCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_TRACE;
        if (m_ErrorCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_ERROR;
        if (m_WarningCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_WARNING;

        //
        // set additional details check boxes
        //

		m_LogInfo.dwMode = 0;

        if (m_AddTimeCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_TIME;
        if (m_AddModuleCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_MODULE;
        if (m_AddThreadIDCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_THREAD;
    break;
    default:        
        m_FilterOff.SetCheck(0);                
        m_Filter1.SetCheck(0);              
        m_Filter2.SetCheck(0);              
        m_Filter3.SetCheck(0);          
        m_FilterCustom.SetCheck(0);                         
        m_TruncateOnBootCheckBox.SetCheck(0);       
        m_TraceCheckBox.SetCheck(0);        
        m_ErrorCheckBox.SetCheck(0);        
        m_WarningCheckBox.SetCheck(0);              
        m_AddTimeCheckBox.SetCheck(0);
        m_AddModuleCheckBox.SetCheck(0);
        m_AddThreadIDCheckBox.SetCheck(0);
		m_dwCustomLevel = 0;
		UpdateData(FALSE);
    break;
    }
}

void CWiaLogCFGDlg::OnOK() 
{   
    InitializeDialogSettings(SETTINGS_FROM_DIALOG);
    RegistryOperation(REG_WRITE);
    CDialog::OnOK();
}

void CWiaLogCFGDlg::OnWriteSettingsButton() 
{
    InitializeDialogSettings(SETTINGS_FROM_DIALOG);
    RegistryOperation(REG_WRITE);
}

void CWiaLogCFGDlg::OnSelchangeSelectModuleCombobox() 
{
    m_CurrentSelection = m_ModuleComboBox.GetCurSel();
    if(m_CurrentSelection < 0)
        return;
    
	CheckGlobalServiceSettings();

    InitializeDialogSettings(SETTINGS_RESET_DIALOG);    
    RegistryOperation(REG_READ);
    InitializeDialogSettings(SETTINGS_TO_DIALOG);   
}

void CWiaLogCFGDlg::OnClearlogButton() 
{
	//
    // Get Windows Directory
    //
	
	TCHAR szLogFilePath[MAX_PATH];

	DWORD dwLength = 0;
    dwLength = ::GetWindowsDirectory(szLogFilePath,sizeof(szLogFilePath));
    if (( dwLength == 0) || !*szLogFilePath ) {
        OutputDebugString(TEXT("Could not GetWindowsDirectory()"));
        return;
    }

    //
    // Add log file name to Windows Directory
    //

    lstrcat(lstrcat(szLogFilePath,TEXT("\\")),TEXT("wiaservc.log"));

    //
    // Create / open Log file
    //


    HANDLE hLogFile = ::CreateFile(szLogFilePath,
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              NULL,       // security attributes
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);      // template file handle

    if(hLogFile != NULL)
		CloseHandle(hLogFile);
}

void CWiaLogCFGDlg::OnViewLogButton() 
{
	CLogViewer LogViewer;
	
	if (m_ColorCodeLogViewerTextCheckBox.GetCheck() == 1)
            m_bColorCodeLogViewerText = TRUE;
        else
            m_bColorCodeLogViewerText = FALSE;
	
	LogViewer.ColorizeText(m_bColorCodeLogViewerText);
	
	//
	// initialize progress
	//
	
	m_ProgCtrl.SetControl(&m_ProgressCtrl);

	LogViewer.SetProgressCtrl(&m_ProgCtrl);
	ShowProgress(TRUE);	
	LogViewer.DoModal();
	ShowProgress(FALSE);	
}

void CWiaLogCFGDlg::ShowProgress(BOOL bShow)
{
	if(bShow) {
		m_ProgressCtrl.ShowWindow(SW_SHOW);
	} else {
		m_ProgressCtrl.ShowWindow(SW_HIDE);
	}
	
}

void CWiaLogCFGDlg::OnSetfocusSelectModuleCombobox() 
{
	OnWriteSettingsButton();
}

void CWiaLogCFGDlg::OnDropdownSelectModuleCombobox() 
{
	OnWriteSettingsButton();	
}

void CWiaLogCFGDlg::CheckGlobalServiceSettings()
{
	TCHAR szKeyName[MAX_PATH];
	m_ModuleComboBox.GetLBText(m_CurrentSelection,szKeyName);
	if(lstrcmp(szKeyName,TEXT("WIASERVC")) == 0) {
		m_TruncateOnBootCheckBox.EnableWindow(TRUE);
		m_ClearLogOnBootCheckBox.EnableWindow(TRUE);
	} else {
		m_TruncateOnBootCheckBox.EnableWindow(FALSE);
		m_ClearLogOnBootCheckBox.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\resource.h ===
#define IDD_OPTIONS                 100
#define IDC_TESTALL                 101
#define IDC_TESTLIST                102
#define IDC_LOGALL                  103
#define IDC_LOGTIMES                104
#define IDC_LOGFILE                 105
#define IDC_GETFILE                 106
#define IDC_LOGFILENAME             107
#define IDC_TESTS                   109
#define ID_ITERATIONS               110
#define IDC_EXIT                    111

#define IDM_MAINMENU               1001
#define IDM_TESTS_OPTIONS          1002
#define IDM_TESTS_EXECUTE          1003
#define IDM_EXIT                   1004

#define IDD_SHOWTHUMBS              201
#define IDC_THUMBS                 2000

#define IDI_APPICON                10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wialogcfg\wialogcfgdlg.h ===
// WiaLogCFGDlg.h : header file
//

#if !defined(AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_)
#define AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0


// format details for logging
#define WIALOG_ADD_TIME           0x00010000
#define WIALOG_ADD_MODULE         0x00020000
#define WIALOG_ADD_THREAD         0x00040000
#define WIALOG_ADD_THREADTIME     0x00080000
#define WIALOG_LOG_TOUI           0x00100000
                                       
#define WIALOG_MESSAGE_TYPE_MASK  0x0000ffff
#define WIALOG_MESSAGE_FLAGS_MASK 0xffff0000
#define WIALOG_CHECK_TRUNCATE_ON_BOOT   0x00000001

#define WIALOG_DEBUGGER           0x00000008
#define WIALOG_UI                 0x00000016

#define REG_READ		0
#define REG_WRITE		1
#define REG_ADD_KEY		2
#define REG_DELETE_KEY	3

#define SETTINGS_RESET_DIALOG  -1
#define SETTINGS_TO_DIALOG		0
#define SETTINGS_FROM_DIALOG	1


typedef struct _LOG_INFO {
	DWORD dwDetail;			 // Logging Detail
	DWORD dwLevel;           // Logging Level
	DWORD dwMode;            // Logging Mode
	DWORD dwTruncateOnBoot;  // Truncate on Boot
	DWORD dwClearLogOnBoot;  // Clear Log on Boot
	DWORD dwMaxSize;         // Max Log size
	DWORD dwLogToDebugger;   // Log to Debugger
	TCHAR szKeyName[64];	 // Module Name / Key Name
} LOG_INFO;

#include "registry.h"
#include "LogViewer.h"

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg dialog

class CWiaLogCFGDlg : public CDialog
{
// Construction
public:
	BOOL m_bColorCodeLogViewerText;
	void CheckGlobalServiceSettings();
	void ShowProgress(BOOL bShow);
	CProgCtrl m_ProgCtrl;
	LONG m_CurrentSelection;
	void InitializeDialogSettings(ULONG ulFlags = SETTINGS_TO_DIALOG);
	HINSTANCE m_hInstance;
	LOG_INFO  m_LogInfo;
	void RegistryOperation(ULONG  ulFlags);
	CWiaLogCFGDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaLogCFGDlg)
	enum { IDD = IDD_WIALOGCFG_DIALOG };
	CButton	m_ColorCodeLogViewerTextCheckBox;
	CButton	m_LogToDebuggerCheckBox;
	CButton	m_ClearLogOnBootCheckBox;
	CProgressCtrl	m_ProgressCtrl;
	CButton	m_AddTimeCheckBox;
	CButton	m_AddThreadIDCheckBox;
	CButton	m_AddModuleCheckBox;
	CButton	m_TruncateOnBootCheckBox;
	CComboBox	m_ModuleComboBox;
	CButton	m_WarningCheckBox;
	CButton	m_ErrorCheckBox;
	CButton	m_TraceCheckBox;
	CButton m_FilterOff;
	CButton	m_Filter1;
	CButton	m_Filter2;
	CButton	m_Filter3;
	CButton	m_FilterCustom;
	DWORD	m_dwCustomLevel;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaLogCFGDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWiaLogCFGDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnAddModuleButton();
	afx_msg void OnDeleteModuleButton();		
	virtual void OnOK();
	afx_msg void OnWriteSettingsButton();
	afx_msg void OnSelchangeSelectModuleCombobox();
	afx_msg void OnClearlogButton();
	afx_msg void OnViewLogButton();
	afx_msg void OnSetfocusSelectModuleCombobox();
	afx_msg void OnDropdownSelectModuleCombobox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\download.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "resource.h"
#include "wia.h"
#include "classes.h"

#include "commctrl.h"

extern CComPtr<IWiaDevMgr> g_pDevMgr;
LPCTSTR cszFilePath = TEXT("%temp%\\foobar.img");
TCHAR szFilePath[MAX_PATH] = TEXT("\0");

class CDataCallback : public IWiaDataCallback
{
public:
    HRESULT STDMETHODCALLTYPE BandedDataCallback(LONG lMessage,
                                                 LONG lStatus,
                                                 LONG lPercentComplete,
                                                 LONG lOffset,
                                                 LONG lLength,
                                                 LONG lReserved,
                                                 LONG lResLength,
                                                 BYTE *pbBuffer);

    HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, OUT PVOID *ppvObj)
    {
        *ppvObj = NULL;
        if (IsEqualGUID(riid, IID_IUnknown))
        {
            *ppvObj = static_cast<IUnknown*>(this);
        }
        else if (IsEqualGUID(riid, IID_IWiaDataCallback))
        {
            *ppvObj = static_cast<IWiaDataCallback*>(this);
        }
        else return E_NOINTERFACE;
        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef(THIS) {
        return InterlockedIncrement (reinterpret_cast<LONG*>(&m_cRef));
    }

    ULONG STDMETHODCALLTYPE Release(void) {
        ULONG ulRet = InterlockedDecrement (reinterpret_cast<LONG*>(&m_cRef));
        if (!ulRet)
        {
            delete this;
        }
        return ulRet;
    }

    CDataCallback () : m_cRef(1), m_pBits(NULL) {};

private:
    ~CDataCallback () {if (m_pBits) delete [] m_pBits;}

    ULONG m_cRef;
    PBYTE m_pBits;
    PBYTE m_pWrite;
    LONG m_lSize;

};

STDMETHODIMP
CDataCallback::BandedDataCallback(LONG lMessage,
                                  LONG lStatus,
                                  LONG lPercentComplete,
                                  LONG lOffset,
                                  LONG lLength,
                                  LONG lReserved,
                                  LONG lResLength,
                                  BYTE *pbData)
{
    switch (lMessage)
    {
        case IT_MSG_DATA_HEADER:
        {

            WIA_DATA_CALLBACK_HEADER *pHead= reinterpret_cast<WIA_DATA_CALLBACK_HEADER*>(pbData);
            m_pBits = new BYTE[pHead->lBufferSize];
            if (!m_pBits)
            {
                return E_OUTOFMEMORY;
            }
            m_lSize = pHead->lBufferSize;
            m_pWrite = m_pBits;

        }
        break;
        case IT_MSG_DATA:
        {
            CopyMemory (m_pWrite, pbData, lLength);
            m_pWrite+=lLength;

        }
        break;
        case IT_MSG_TERMINATION:
        {
            if (m_pBits)
            {
                HANDLE hFile = CreateFile (szFilePath, GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           CREATE_ALWAYS,
                                           0,
                                           NULL);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    DWORD dw = 0;
                    WriteFile (hFile, m_pBits, static_cast<DWORD>(m_lSize), &dw, NULL);
                    CloseHandle (hFile);
                }
            }
        }
        break;
    }
    return S_OK;
}
VOID
CTest::DownloadItem (IWiaItem *pItem, DWORD &dwPix, ULONG &ulSize, bool bBanded)
{
    HRESULT hr;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    STGMEDIUM stg;
    PROPSPEC ps[2];
    PROPVARIANT pv[2];
    GUID guidFmt;
    WIA_DATA_TRANSFER_INFO wdti;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    CComQIPtr<IWiaDataTransfer, &IID_IWiaDataTransfer> pXfer;
    CDataCallback *pDataCallback = NULL;

    QueryPerformanceCounter (&liStart);
    PropVariantInit (&pv[0]);
    if (!bBanded)
    {
        ZeroMemory (&stg, sizeof(stg));
        stg.pUnkForRelease = NULL;
        stg.tymed = TYMED_FILE;
        #ifdef UNICODE
        stg.lpszFileName = szFilePath;
        #else
        WCHAR szPath[MAX_PATH];
        MultiByteToWideChar (CP_ACP, 0, szFilePath, -1, szPath, MAX_PATH);
        stg.lpszFileName = szPath;
        #endif
//        stg.lpszFileName = NULL;

    }
    else
    {
        ZeroMemory (&wdti, sizeof(wdti));
        wdti.ulSize = sizeof(wdti);
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = WIA_IPA_MIN_BUFFER_SIZE;

        hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
        LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple (WIA_IPA_MIN_BUFFER_SIZE)"), hr);
        if (hr == NOERROR)
        {
            wdti.ulBufferSize = 2*pv[0].ulVal;

        }
        else
        {
            wdti.ulBufferSize = 65536;
        }
        wdti.bDoubleBuffer = TRUE;
        PropVariantClear (&pv[0]);
        pDataCallback = new CDataCallback;
    }
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_PREFERRED_FORMAT;

    hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
    LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple (WIA_IPA_PREFERRED_FORMAT)"), hr);
    if (NOERROR == hr)
    {
        guidFmt = *(pv[0].puuid);
        PropVariantClear (&pv[0]);
        ps[0].propid = WIA_IPA_FORMAT;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = WIA_IPA_TYMED;
        pv[0].vt = VT_CLSID;
        pv[0].puuid = &guidFmt;
        pv[1].vt = VT_I4;
        pv[1].intVal = bBanded?TYMED_CALLBACK:TYMED_FILE;
        hr = pps->WriteMultiple (2, ps, pv, 2);
        LogAPI (TEXT("IWiaPropertyStorage::WriteMultiple(WIA_IPA_FORMAT, WIA_IPA_TYMED)"), hr);
        ps[0].propid = WIA_IPA_ITEM_SIZE;
        PropVariantInit (&pv[0]);
        hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
        LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple(WIA_IPA_ITEM_SIZE)"), hr);
        ulSize += pv[0].ulVal;
        dwPix++;
        pXfer = pItem;
        if (!pXfer)
        {
            LogString (TEXT("Unable to QI for IWiaDataTransfer!"));
        }
        else if (!bBanded)
        {
            hr = pXfer->idtGetData (&stg, NULL);
            LogAPI (TEXT("IWiaDataTransfer::idtGetData"), hr);
        }
        else if (pDataCallback)
        {
            CComQIPtr<IWiaDataCallback, &IID_IWiaDataCallback> pcb(pDataCallback);
            hr = pXfer->idtGetBandedData (&wdti, pcb);
            LogAPI (TEXT("IWiaDataTransfer::idtGetBandedData"), hr);
        }
    }
    QueryPerformanceCounter (&liEnd);
    if (!bBanded)
    {
        DeleteFileW (const_cast<LPCWSTR>(stg.lpszFileName));

    }
    DeleteFile (const_cast<LPCTSTR>(szFilePath));
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    LogTime (TEXT("Download time for image "), liEnd);
    if (pDataCallback)
    {
        pDataCallback->Release();
    }
}


VOID
CTest::RecursiveDownload (IWiaItem *pFolder, DWORD &dwPix, ULONG &ulSize, bool bBanded)
{
    HRESULT hr;
    CComPtr<IEnumWiaItem> pEnum;
    DWORD dw;
    CComPtr<IWiaItem> pItem;
    LONG lItemType;
    hr = pFolder->EnumChildItems(&pEnum);
    LogAPI(TEXT("IWiaItem::EnumChildItems"), hr);
    while (NOERROR == hr)
    {
        hr = pEnum->Next (1,&pItem, &dw);
        if (dw)
        {
            hr = pItem->GetItemType (&lItemType);
            LogAPI (TEXT("IWiaItem::GetItemType"), hr);
            if (lItemType & WiaItemTypeFolder)
            {
                RecursiveDownload (pItem, dwPix, ulSize);
            }
            else
            {
                DownloadItem (pItem, dwPix, ulSize, bBanded);
            }
        }
    }
}
VOID
CTest::TstDownload (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    ULONG ulTotalSize = 0;
    DWORD dwPix = 0;
    HRESULT hr;
    TCHAR sz[200];
    CComPtr<IWiaItem> pRoot;
    ExpandEnvironmentStrings (cszFilePath, szFilePath, MAX_PATH);
    pThis->LogString (TEXT("--> Start test for idtGetData (no callback)"));
    pThis->LogString (TEXT("Note that the total log time in this test includes time for logging!"));
    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {

        pThis->RecursiveDownload (pRoot, dwPix, ulTotalSize);


    }
    QueryPerformanceCounter (&liEnd);
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    wsprintf (sz, TEXT("Total pix:%d, Total size:%d kilobytes"), dwPix, ulTotalSize/1024);
    pThis->LogTime (sz, liEnd);
}

VOID
CTest::TstBandedDownload (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    ULONG ulTotalSize = 0;
    DWORD dwPix = 0;
    HRESULT hr;
    TCHAR sz[200];
    CComPtr<IWiaItem> pRoot;
    ExpandEnvironmentStrings (cszFilePath, szFilePath, MAX_PATH);
    pThis->LogString (TEXT("--> Start test for idtGetBandedData "));
    pThis->LogString (TEXT("Note that the total log time in this test includes time for logging!"));
    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {

        pThis->RecursiveDownload (pRoot, dwPix, ulTotalSize, true);


    }
    QueryPerformanceCounter (&liEnd);
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    wsprintf (sz, TEXT("Total pix:%d, Total size:%d kilobytes"), dwPix, ulTotalSize/1024);
    pThis->LogTime (sz, liEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\thumbs.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "resource.h"
#include "wia.h"
#include "classes.h"

#include "commctrl.h"

extern CComPtr<IWiaDevMgr> g_pDevMgr;

LARGE_INTEGER li1;
LARGE_INTEGER li2;
LARGE_INTEGER li3;
LARGE_INTEGER liDiff;

struct DRAWINFO
{
    HBITMAP hbmp;
    LPVOID  pBitmap;
    INT iWidth;
    INT iHeight;
};
#define GETDIFF(x,y) (liDiff.QuadPart = (x).QuadPart -(y).QuadPart)

class CThumbsDlg
{
public:
    CThumbsDlg (CTest *pTest, BSTR strDeviceId);
    VOID ShowDlg ();


private:
    INT m_iWidth;
    INT m_iHeight;

    HWND m_hwnd;
    HIMAGELIST m_himl;
    CTest *m_pTest;
    CComPtr<IWiaItem> m_pDevice;
    BSTR m_strDeviceId;
    VOID TimeEnumThumbnails ();
    static INT_PTR CALLBACK ShowThumbsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    INT_PTR RealDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    VOID RenderThumbnail ();
};

VOID
GetThumbSize (IWiaItem *pItem, INT *piWidth, INT *piHeight)
{
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>  pstg(pItem);
    PROPVARIANT pv[2];
    PROPSPEC    ps[2];

    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DPC_THUMB_WIDTH;
    ps[1].propid = WIA_DPC_THUMB_HEIGHT;


    if (SUCCEEDED( pstg->ReadMultiple (2, ps, pv)))
    {

        *piWidth = pv[0].ulVal;
        *piHeight = pv[1].ulVal;
    }
    else
    {
        *piWidth = 0;
        *piHeight = 0;
    }
    FreePropVariantArray (2, pv);
}
HRESULT
GetNameAndThumbnail (IWiaItem *pItem, LPTSTR szName, DRAWINFO *pInfo)
{
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>  pstg(pItem);
    PROPVARIANT pv[4];
    PROPSPEC    ps[4];
    HRESULT hr;
    BITMAPINFO bmi;
    HWND hwnd;
    HDC hdc;

    ps[0].ulKind = ps[1].ulKind = ps[2].ulKind = ps[3].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_ITEM_NAME;
    ps[1].propid = WIA_IPC_THUMBNAIL;
    ps[2].propid = WIA_IPC_THUMB_WIDTH;
    ps[3].propid = WIA_IPC_THUMB_HEIGHT;


    hr = pstg->ReadMultiple (4, ps, pv);
    if (SUCCEEDED(hr))
    {
        #ifdef UNICODE
        lstrcpy (szName, pv[0].pwszVal);
        #else
        WideCharToMultiByte (CP_ACP, 0, pv[0].pwszVal, -1, szName, MAX_PATH,
                             NULL,NULL);
        #endif
        bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth           = pv[2].ulVal;
        bmi.bmiHeader.biHeight          = pv[3].ulVal;
        bmi.bmiHeader.biPlanes          = 1;
        bmi.bmiHeader.biBitCount        = 24;
        bmi.bmiHeader.biCompression     = BI_RGB;
        bmi.bmiHeader.biSizeImage       = 0;
        bmi.bmiHeader.biXPelsPerMeter   = 0;
        bmi.bmiHeader.biYPelsPerMeter   = 0;
        bmi.bmiHeader.biClrUsed         = 0;
        bmi.bmiHeader.biClrImportant    = 0;

        hwnd   = GetDesktopWindow();
        hdc    = GetDC( hwnd );
        pInfo->hbmp = CreateDIBSection( hdc, &bmi, DIB_RGB_COLORS, &pInfo->pBitmap, NULL, 0 );
        pInfo->iHeight = bmi.bmiHeader.biHeight;
        pInfo->iWidth = bmi.bmiHeader.biWidth;

        //
        // Transfer thumbnail bits to bitmap bits
        //

        CopyMemory( pInfo->pBitmap, pv[1].caub.pElems, pv[1].caub.cElems );
        FreePropVariantArray (4, pv);
        ReleaseDC (hwnd, hdc);

    }
    return hr;
}

VOID
CThumbsDlg::TimeEnumThumbnails ()
{

    CComPtr<IEnumWiaItem> pEnum;
    HWND hList = GetDlgItem (m_hwnd, IDC_THUMBS);



    QueryPerformanceCounter (&li3);

    if (SUCCEEDED(m_pDevice->EnumChildItems (&pEnum)))
    {
        ULONG ul;

        CComPtr<IWiaItem> pItem;
        LVITEM lvi;
        TCHAR szName[MAX_PATH];
        HBITMAP hbmp;
        DRAWINFO *pInfo;
        QueryPerformanceCounter (&li2);
        GETDIFF(li2, li3);
        m_pTest->LogTime(TEXT("IWiaItem::EnumChildItems"), liDiff);
        m_pTest->LogAPI(TEXT("IWiaItem::EnumChildItems"), NOERROR);
        ZeroMemory (&lvi, sizeof(lvi));
        lvi.mask = LVIF_IMAGE | LVIF_TEXT;
        QueryPerformanceCounter (&li2);
        while (NOERROR == pEnum->Next (1, &pItem, &ul))
        {

            DRAWINFO Info;
            if (SUCCEEDED(GetNameAndThumbnail (pItem, szName, &Info)))
            {

                lvi.pszText = szName;
                lvi.iImage = ImageList_Add (m_himl, Info.hbmp, NULL);

                ListView_InsertItem (hList, &lvi);
                DeleteObject (Info.hbmp);
            }
            pItem = NULL;
        }
        ListView_SetIconSpacing (hList, m_iWidth+16, m_iHeight+32);
        ListView_SetImageList (hList, m_himl, LVSIL_NORMAL);
        QueryPerformanceCounter (&li3);
        GETDIFF (li3, li2);
        m_pTest->LogTime(TEXT("Add thumbnails to listview"), liDiff);

    }

}



INT_PTR CALLBACK
CThumbsDlg::ShowThumbsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);

            break;

    }
    CThumbsDlg *pThis = reinterpret_cast<CThumbsDlg*>(GetWindowLongPtr(hwnd, DWLP_USER));
    return pThis->RealDlgProc (hwnd, msg ,wp ,lp);

}

INT_PTR
CThumbsDlg::RealDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{

    switch (msg)
    {
        case WM_INITDIALOG:
            m_hwnd = hwnd;
            PostMessage (hwnd, WM_USER+10, 0, 0);

            return TRUE;

        case WM_USER+10:
            TimeEnumThumbnails ();
            PostMessage (hwnd, WM_CLOSE, 0, 0);

            return TRUE;

        case WM_CLOSE:

            EndDialog (hwnd, 0);
            return TRUE;
    }
    return FALSE;
}

VOID
CThumbsDlg::ShowDlg()
{

    HRESULT hr;
    QueryPerformanceCounter (&li1);

    hr = g_pDevMgr->CreateDevice (m_strDeviceId, &m_pDevice);
    if (SUCCEEDED(hr))
    {
        QueryPerformanceCounter (&li2);
        GETDIFF (li2, li1);
        m_pTest->LogTime(TEXT("IWiaDevMgr::CreateDevice"), liDiff);
    }

    m_pTest->LogAPI (TEXT("IWiaDevMgr::CreateDevice"), hr);

    GetThumbSize (m_pDevice, &m_iWidth, &m_iHeight);

    m_himl = ImageList_Create (m_iWidth, m_iHeight, ILC_COLOR24, 10, 50);

    DialogBoxParam (GetModuleHandle (NULL),
                    MAKEINTRESOURCE (IDD_SHOWTHUMBS),
                    NULL,
                    ShowThumbsDlgProc,
                    reinterpret_cast<LPARAM>(this));
    QueryPerformanceCounter (&li2);
    GETDIFF (li2, li1);
    m_pTest->LogTime (TEXT("Complete enumeration of thumbnails"), liDiff);
}

CThumbsDlg::CThumbsDlg(CTest *pTest, BSTR strDeviceId)
{
    m_pTest = pTest;
    m_strDeviceId = strDeviceId;

}
VOID
CTest::TstShowThumbs(CTest *pThis, BSTR strDeviceId)
{
    INITCOMMONCONTROLSEX ice;

    CThumbsDlg dlg(pThis, strDeviceId);
    ice.dwSize = sizeof(ice);
    ice.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx (&ice);
    pThis->LogString(TEXT("-->Begin thumbnail enumeration test"));

    dlg.ShowDlg ();
    pThis->LogString(TEXT("<--End thumbnail enumeration test"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\tests.cpp ===
#include <windows.h>
#include "resource.h"
#include "wia.h"
#include <atlbase.h>
#include "classes.h"
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

CComPtr<IWiaDevMgr> g_pDevMgr;
LARGE_INTEGER liTimerFreq;

struct TESTENTRY
{
    LPCTSTR szName;
    TESTPROC pfnTest;
    bool  bRunMe;
} TESTLIST[] =
{
    {TEXT("CreateDevice only"), CTest::TstCreateDevice, false},
    {TEXT("Display Thumbnails"), CTest::TstShowThumbs, false},
    {TEXT("Enum device commands"), CTest::TstEnumCmds, false},
    {TEXT("idtGetData for all images"), CTest::TstDownload, false},
    {TEXT("idtGetBandedData for all images"), CTest::TstBandedDownload, false},

};


CPerfTest::CPerfTest () : m_hwnd(NULL), m_hEdit(NULL)
{
    ZeroMemory (&m_settings, sizeof(m_settings));
}


static TCHAR cszWndClass[] = TEXT("TestWindow");
static TCHAR cszWndName[] = TEXT("WIA Perf Measurement");

bool
CPerfTest::Init (HINSTANCE hInst)
{
    WNDCLASS wc;
    m_hInst = hInst;

    // make sure WIA is around
    if (FAILED(CoCreateInstance (CLSID_WiaDevMgr,
                  NULL,
                  CLSCTX_LOCAL_SERVER,
                  IID_IWiaDevMgr,
                  reinterpret_cast<LPVOID*>(&g_pDevMgr))))
    {
        MessageBox (NULL,
                    TEXT("Unable to create WIA!"),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return false;
    }

    // verify high resolution timer available
    if (!QueryPerformanceFrequency(&liTimerFreq))
    {
        MessageBox (NULL,
                    TEXT("No performance counter available."),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return false;
    }

    ZeroMemory (&wc, sizeof(wc));
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.hCursor = LoadCursor (NULL, IDC_ARROW);
    wc.hInstance = m_hInst;
    wc.lpfnWndProc = WndProc;
    wc.hIcon = LoadIcon (m_hInst, MAKEINTRESOURCE(IDI_APPICON));
    wc.lpszClassName = cszWndClass;
    wc.lpszMenuName = MAKEINTRESOURCE(IDM_MAINMENU);


    RegisterClass (&wc);

    m_hwnd = CreateWindow (cszWndClass,
                           cszWndName,
                           WS_OVERLAPPEDWINDOW | WS_VISIBLE |WS_CLIPCHILDREN,
                           CW_USEDEFAULT, 0,
                           CW_USEDEFAULT, 0,
                           NULL,
                           NULL,
                           m_hInst,
                           reinterpret_cast<LPVOID>(this));
   if (IsWindow (m_hwnd))
   {
       ShowWindow (m_hwnd, SW_SHOW);
       UpdateWindow (m_hwnd);
       return true;
   }
   return false;

}


LRESULT CALLBACK
CPerfTest::WndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CPerfTest *pThis;

    if (WM_CREATE == msg)
    {
        // store our "this" pointer
        SetWindowLongPtr (hwnd,
                          GWLP_USERDATA,
                          reinterpret_cast<LONG_PTR>(reinterpret_cast<LPCREATESTRUCT>(lp)->lpCreateParams));

    }
    pThis = reinterpret_cast<CPerfTest*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    return pThis->RealWndProc (hwnd, msg, wp, lp);
}

LRESULT
CPerfTest::RealWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{

    switch (msg)
    {
        case WM_CREATE:
            m_hwnd = hwnd;
            return OnCreate ();

        case WM_COMMAND:
            return OnCommand (wp, lp);

        case WM_DESTROY:
            PostQuitMessage (0);
            return 0;

        case WM_SIZE:
            // size the edit control to match
            MoveWindow (m_hEdit, 0,0,LOWORD(lp), HIWORD(lp), TRUE);
            break;
        default:
            break;
    }
    return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
}

LRESULT
CPerfTest::OnCreate ()
{
    // Create our child edit control. Used to display logging output
    m_hEdit = CreateWindow (TEXT("edit"), TEXT(""),
                            WS_BORDER | ES_READONLY | WS_CHILD|WS_VISIBLE|ES_MULTILINE | WS_VSCROLL | WS_HSCROLL,
                            0,0,0,0,m_hwnd,
                            reinterpret_cast<HMENU>(1),
                            m_hInst,NULL);

    GetSettings ();
    return 0;
}

LRESULT
CPerfTest::OnCommand (WPARAM wp, LPARAM lp)
{
    switch (LOWORD(wp))
    {
        case IDM_TESTS_OPTIONS:
            GetSettings ();
            return 0;

        case IDM_TESTS_EXECUTE:
            RunTests ();
            return 0;

        case IDM_EXIT:
            DestroyWindow (m_hwnd);
            return 0;

    }
    return 1;
}

VOID
CPerfTest::RunTests ()
{
    UINT nRun;
    size_t nTest;
    UINT nDevice;
    CTest TheTest(&m_settings);
    for (nDevice=0; m_settings.pstrDevices[nDevice];nDevice++)

    {
        for (nRun = 0;nRun < m_settings.nIter; nRun++)
        {
            for (nTest=0;nTest<ARRAYSIZE(TESTLIST);nTest++)
            {
                if (TESTLIST[nTest].bRunMe)
                {
                    (TESTLIST[nTest].pfnTest)(&TheTest, m_settings.pstrDevices[nDevice]);
                }
            }
        }
        TheTest.LogDevInfo (m_settings.pstrDevices[nDevice]);
    }
}

VOID
CPerfTest::GetSettings ()
{
    m_settings.hEdit = m_hEdit;
    if (m_settings.pstrDevices)
    {
        delete [] m_settings.pstrDevices;
        m_settings.pstrDevices = NULL;
    }
    DialogBoxParam (m_hInst,
                    MAKEINTRESOURCE(IDD_OPTIONS),
                    m_hwnd,
                    SettingsDlgProc,
                    reinterpret_cast<LPARAM>(&m_settings));
    // hide or show "Execute!" depending on settings
    HMENU hmenu = GetSubMenu (GetMenu(m_hwnd), 0);
    if (m_settings.nIter)
    {
        EnableMenuItem (hmenu, IDM_TESTS_EXECUTE, MF_BYCOMMAND|MF_ENABLED);
    }
    else
    {
        EnableMenuItem (hmenu, IDM_TESTS_EXECUTE, MF_BYCOMMAND|MF_DISABLED);
    }

}

INT_PTR CALLBACK
SettingsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    TESTSETTINGS *pSettings;
    pSettings = reinterpret_cast<TESTSETTINGS*>(GetWindowLongPtr(hwnd, DWLP_USER));

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            pSettings = reinterpret_cast<TESTSETTINGS*>(lp);
            InitControls (hwnd, pSettings);
            return TRUE;

        case WM_COMMAND:
            if (IDOK == LOWORD(wp))
            {
                FillSettings (hwnd, pSettings);

            }
            if (IDOK == LOWORD(wp) || IDCANCEL == LOWORD(wp))
            {
                FreeDialogData (hwnd);
                EndDialog (hwnd, 1);
                return TRUE;
            }
            if (IDC_GETFILE == LOWORD(wp))
            {
                TCHAR szFileName[MAX_PATH];
                OPENFILENAME ofn;
                ZeroMemory (&ofn, sizeof(ofn));
                ofn.hInstance = GetModuleHandle (NULL);
                ofn.hwndOwner = hwnd;
                ofn.lpstrFile = szFileName;
                ofn.lpstrFilter = TEXT("LOG file\0*.log\0Text file\0*.txt\0");
                ofn.lpstrDefExt = TEXT("log");
                ofn.lStructSize = sizeof(ofn);
                ofn.nMaxFile = MAX_PATH;
                if (GetOpenFileName(&ofn))
                {
                    SetDlgItemText (hwnd, IDC_LOGFILENAME, szFileName);
                }
                return TRUE;
            }
            return FALSE;
    }
    return FALSE;
}

VOID
InitControls (HWND hwnd, TESTSETTINGS *pSettings)
{
    //
    // First, enum the WIA devices available and put their names in the listbox
    //

    CComPtr<IEnumWIA_DEV_INFO> pEnum;
    CComPtr<IWiaPropertyStorage> pStg;
    PROPVARIANT pv[2];
    PROPSPEC ps[2];
    ULONG ul;
    BSTR strID;
    TCHAR szName[MAX_PATH];
    LRESULT lItem;

    if (FAILED(g_pDevMgr->EnumDeviceInfo(0, &pEnum)))
    {
        MessageBox (hwnd,
                    TEXT("Unable to enum WIA devices!"),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return;
    }
    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DIP_DEV_NAME;
    ps[1].propid = WIA_DIP_DEV_ID;

    while (NOERROR == pEnum->Next (1, &pStg, &ul))
    {
        if (NOERROR == pStg->ReadMultiple (2, ps, pv))
        {
            strID = SysAllocString (pv[1].pwszVal);
            #ifdef UNICODE
            wcscpy (szName, pv[0].pwszVal);
            #else
            WideCharToMultiByte (CP_ACP, 0, pv[0].pwszVal, -1,
                                 szName, MAX_PATH, NULL, NULL);
            #endif
            lItem = SendDlgItemMessage (hwnd,
                                        IDC_TESTLIST,
                                        CB_ADDSTRING,
                                        0,
                                        reinterpret_cast<LPARAM>(szName));
            if (lItem >= 0)
            {
                SendDlgItemMessage (hwnd,
                                    IDC_TESTLIST,
                                    CB_SETITEMDATA,
                                    lItem,
                                    reinterpret_cast<LPARAM>(strID));
            }
        }
    }

    SendDlgItemMessage (hwnd,
                        IDC_TESTLIST,
                        CB_SETCURSEL,
                        0, 0);


    // Fill the test names listbox
    for (INT i=0;i<ARRAYSIZE(TESTLIST);i++)
    {
        lItem = SendDlgItemMessage (hwnd,
                                    IDC_TESTS,
                                    LB_ADDSTRING,
                                    0,
                                    reinterpret_cast<LPARAM>(TESTLIST[i].szName));
        SendDlgItemMessage (hwnd,
                            IDC_TESTS,
                            LB_SETITEMDATA,
                            lItem,
                            reinterpret_cast<LPARAM>(TESTLIST[i].pfnTest));

    }
    CheckDlgButton (hwnd, IDC_EXIT, pSettings->bExit);

    //
    // Set some defaults
    CheckDlgButton (hwnd, IDC_LOGFILE, pSettings->fLogMask & LOG_FILE);
    SetDlgItemText (hwnd, IDC_LOGFILENAME, pSettings->szLogFile);
    CheckDlgButton (hwnd, IDC_LOGTIMES, pSettings->fLogMask & LOG_TIME);
    SetDlgItemInt (hwnd, ID_ITERATIONS,pSettings->nIter ? pSettings->nIter : 1, FALSE);
}


VOID
FillSettings (HWND hwnd, TESTSETTINGS *pSettings)
{
    //
    // Read the list of device id's selected
    //
    BOOL bAddAll = IsDlgButtonChecked (hwnd, IDC_TESTALL);
    if (bAddAll)
    {
        LRESULT lDevices = SendDlgItemMessage (hwnd, IDC_TESTLIST,
                                               CB_GETCOUNT, 0, 0);
        if (lDevices > 0)
        {
            pSettings->pstrDevices = new BSTR[lDevices+1];

            for (LRESULT i=0;i<lDevices;i++)
            {
                pSettings->pstrDevices[i] = reinterpret_cast<BSTR>(SendDlgItemMessage (
                                                                        hwnd,
                                                                        IDC_TESTLIST,
                                                                        CB_GETITEMDATA,
                                                                        i, 0));
            }
            pSettings->pstrDevices[i] = NULL;
        }
    }
    else
    {
        LRESULT lItem = SendDlgItemMessage (hwnd, IDC_TESTLIST, CB_GETCURSEL, 0, 0);
        if (lItem >=0 )
        {
            pSettings->pstrDevices = new BSTR[2];
            pSettings->pstrDevices[0] = reinterpret_cast<BSTR>(SendDlgItemMessage (
                                                                  hwnd,
                                                                  IDC_TESTLIST,
                                                                  CB_GETITEMDATA,
                                                                  lItem,
                                                                  0));
            pSettings->pstrDevices[1] = NULL;
        }
    }

    //
    // Get the log settings
    //
    pSettings->fLogMask = LOG_WINDOW_ONLY;
    if (IsDlgButtonChecked (hwnd, IDC_LOGALL))
    {
        pSettings->fLogMask |= LOG_APIS;
    }
    if (IsDlgButtonChecked (hwnd, IDC_LOGTIMES))
    {
        pSettings->fLogMask |= LOG_TIME;
    }
    if (IsDlgButtonChecked (hwnd, IDC_LOGFILE))
    {
        pSettings->fLogMask |= LOG_FILE;
    }
    // get the file path
    GetDlgItemText (hwnd, IDC_LOGFILENAME, pSettings->szLogFile, MAX_PATH);
    // how many times to run
    pSettings->nIter = GetDlgItemInt (hwnd, ID_ITERATIONS, NULL, FALSE);
    // Whether to exit on test complete
    pSettings->bExit = IsDlgButtonChecked (hwnd, IDC_EXIT);

    //
    // Cycle through the tests in the list and check which ones to run
    for (size_t i=0;i<ARRAYSIZE(TESTLIST);i++)
    {
        if (SendDlgItemMessage (hwnd, IDC_TESTS, LB_GETSEL, i, 0) > 0)
        {
            TESTLIST[i].bRunMe = true;
        }
        else
        {
            TESTLIST[i].bRunMe = false;
        }
    }
}


VOID FreeDialogData (HWND hwnd)
{
    LRESULT lDevices = SendDlgItemMessage (hwnd, IDC_TESTLIST,
                                               CB_GETCOUNT, 0, 0);
    BSTR str;
    if (lDevices > 0)
    {

        for (LRESULT i=0;i<lDevices;i++)
        {
        str = reinterpret_cast<BSTR>(SendDlgItemMessage (hwnd,
                                                         IDC_TESTLIST,
                                                         CB_GETITEMDATA,
                                                         i, 0));
        SysFreeString (str);
        }
    }
}



CTest::CTest (TESTSETTINGS *pSettings)
{
    m_pSettings = pSettings;
    OpenLogFile ();
}

CTest::~CTest ()
{
    CloseLogFile ();
}

void
CTest::OpenLogFile ()
{

    m_hLogFile = CreateFile (m_pSettings->szLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
    #ifdef UNICODE
    // write the UNICODE header
    if (m_hLogFile != INVALID_HANDLE_VALUE)
    {
        WCHAR bom = 0xFEFF;
        DWORD dw;
        WriteFile (m_hLogFile, &bom, sizeof(WCHAR), &dw, NULL);
    }
    #endif
    LogString (TEXT("******* WIA Perf Test Starting. ********"));
}

void
CTest::CloseLogFile ()
{
    LogString (TEXT("******* WIA Perf Test Ending. *******"));
    if (INVALID_HANDLE_VALUE != m_hLogFile)
    {
        CloseHandle (m_hLogFile);
    }

}

// LogTime assumes the number of seconds will fit in a long
//
void
CTest::LogTime (LPTSTR szAction,LARGE_INTEGER &liTimeElapsed)
{
    LARGE_INTEGER liSeconds;
    if (m_pSettings->fLogMask & LOG_TIME)
    {
        liSeconds.QuadPart = (1000*liTimeElapsed.QuadPart)/liTimerFreq.QuadPart;
        LogString (TEXT("Time for %s:%lu milliseconds"), szAction, liSeconds.LowPart);
    }
}

void
CTest::LogAPI (LPTSTR szAPI, HRESULT hr)
{
    if (m_pSettings->fLogMask & LOG_APIS)
    {
        if (FAILED(hr))
        {
            LogString (TEXT("API call: %s failed %x"), szAPI, hr);
        }
        else
        {
            LogString (TEXT("API call: %s succeeded %x"), szAPI, hr);
        }
    }
}

void
CTest::LogString (LPTSTR sz, ...)
{
    TCHAR szOut[1024];
    va_list args;

    va_start (args, sz);
    wvsprintf (szOut, sz, args);
    va_end(args);

    // Note that we can write past the end of this buffer.
    lstrcat (szOut, TEXT("\r\n"));

    SendMessage (m_pSettings->hEdit,
                 EM_REPLACESEL,
                 0,
                 reinterpret_cast<LPARAM>(szOut));



    if (m_pSettings->fLogMask & LOG_FILE && INVALID_HANDLE_VALUE != m_hLogFile)
    {
        DWORD dw;
        WriteFile (m_hLogFile, szOut, sizeof(TCHAR)*(lstrlen(szOut)+1), &dw, NULL);
    }
}

VOID
CTest::TstCreateDevice (CTest *pThis, BSTR strDeviceId)
{

    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    HRESULT hr;
    CComPtr<IWiaItem> pRoot;
    pThis->LogString (TEXT("--> Start test for CreateDevice"));

    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    QueryPerformanceCounter (&liEnd);
    pRoot = NULL;
    liEnd.QuadPart = liEnd.QuadPart-liStart.QuadPart;
    pThis->LogTime (TEXT("CreateDevice"), liEnd);
    pThis->LogAPI (TEXT("IWiaDevMgr::CreateDevice"), hr);

    pThis->LogString (TEXT("<-- End test for CreateDevice"));
}

VOID
CTest::LogDevInfo(BSTR strDeviceId)
{
    CComPtr<IWiaItem> pRoot;
    if (SUCCEEDED(g_pDevMgr->CreateDevice (strDeviceId, &pRoot)))
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pstg(pRoot);
        PROPVARIANT pv[3];
        PROPSPEC    ps[3];
        ps[0].ulKind = ps[1].ulKind = ps[2].ulKind = PRSPEC_PROPID;
        ps[0].propid = WIA_DIP_DEV_NAME;
        ps[1].propid = WIA_DPC_PICTURES_TAKEN;
        ps[2].propid = WIA_DIP_PORT_NAME;
        if (NOERROR == pstg->ReadMultiple (3, ps, pv))
        {
            LogString (TEXT("Device ID : %ls"), strDeviceId);
            LogString (TEXT("Device Name : %ls"), pv[0].pwszVal);
            LogString (TEXT("On Port : %ls"), pv[2].pwszVal);
            LogString (TEXT("Number of stored images : %d"), pv[1].ulVal);
        }
    }
}

// Enumerate commands supported by the device
VOID
CTest::TstEnumCmds (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    HRESULT hr;
    CComPtr<IWiaItem> pRoot;
    pThis->LogString (TEXT("--> Start test for EnumWIA_DEV_CAPS(WIA_DEVICE_COMMANDS)"));
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {
        CComPtr<IEnumWIA_DEV_CAPS> pCaps;
        WIA_DEV_CAP wdc;
        TCHAR sz[200];
        DWORD dwCmds = 0;
        DWORD dw;
        QueryPerformanceCounter (&liStart);
        hr = pRoot->EnumDeviceCapabilities (WIA_DEVICE_COMMANDS, &pCaps);
        QueryPerformanceCounter (&liEnd);
        liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
        pThis->LogTime (TEXT("IWiaItem::EnumDeviceCapabilities (WIA_DEVICE_COMMANDS)"), liEnd);
        pThis->LogAPI (TEXT("IWiaItem::EnumDeviceCapabilities (WIA_DEVICE_COMMANDS)"), hr);
        QueryPerformanceCounter (&liStart);
        while (NOERROR == hr)
        {
            hr = pCaps->Next (1, &wdc, &dw);
            dwCmds+=dw;
            if (wdc.bstrCommandline)
            {
                SysFreeString (wdc.bstrCommandline);
            }
            if (wdc.bstrDescription)
            {
                SysFreeString (wdc.bstrDescription);
            }
            if (wdc.bstrIcon)
            {
                SysFreeString (wdc.bstrIcon);
            }
        }
        QueryPerformanceCounter (&liEnd);
        liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
        wsprintf (sz, TEXT("%d commands from IEnumWIA_DEV_CAPS::Next"), dwCmds);
        pThis->LogTime (sz, liEnd);

    }
    pThis->LogString (TEXT("<-- End test for EnumWIA_DEV_CAPS(WIA_DEVICE_COMMANDS)"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\classes.h ===
#ifndef _CLASSES_H_
#define _CLASSES_H_

#include <wtypes.h>
struct TESTSETTINGS
{
    BSTR *pstrDevices; // array of device IDs, NULL terminated
    LONG fLogMask;     // what to log
    TCHAR szLogFile[MAX_PATH]; // where to log
    UINT nIter;// number of iterations to run
    HWND hEdit; // edit window for logging
    BOOL bExit; // exit when complete
    BOOL bManual; // whether to wait for user input
};

#define LOG_WINDOW_ONLY      0
#define LOG_APIS             1
#define LOG_FILE             2
#define LOG_TIME             4
//
// log settings

#define TESTFUNC(x) static VOID (x)(CTest *pThis, BSTR strDeviceId);
class CTest
{
public:
    CTest (TESTSETTINGS *pSettings);
    // LIST TESTS HERE
    TESTFUNC( TstCreateDevice)
    TESTFUNC( TstShowThumbs )
    TESTFUNC( TstEnumCmds )
    TESTFUNC( TstDownload )
    TESTFUNC( TstBandedDownload)
    // END TESTS LIST
    void LogTime (LPTSTR szAction, LARGE_INTEGER &liTimeElapsed);
    void LogString (LPTSTR sz, ...);
    void LogAPI (LPTSTR szApi, HRESULT hr);
    void LogDevInfo (BSTR strDeviceId);
    ~CTest ();
    private:
    void OpenLogFile ();
    void CloseLogFile ();

    void RecursiveDownload (IWiaItem *pFolder, DWORD &dwPix, ULONG &ulSize, bool bBanded=false);
    void DownloadItem (IWiaItem *pItem, DWORD &dwPix, ULONG &ulSize, bool bBanded=false);

    HANDLE m_hLogFile;
    TESTSETTINGS *m_pSettings;

};

typedef VOID (*TESTPROC)(CTest* pTest, BSTR strDeviceId);



class CPerfTest
{
public:
    bool Init (HINSTANCE hInst);
    CPerfTest ();
    ~CPerfTest () {};
private:
    HWND m_hwnd;
    HWND m_hEdit;
    HINSTANCE m_hInst;
    TESTSETTINGS m_settings;
    VOID RunTests ();
    VOID GetSettings ();
    static LRESULT CALLBACK WndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    LRESULT RealWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    LRESULT OnCreate ();
    LRESULT OnCommand (WPARAM wp, LPARAM lp);
};

// These functions manage the settings dialog
INT_PTR CALLBACK SettingsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
VOID InitControls (HWND hwnd, TESTSETTINGS *pSettings);
VOID FillSettings (HWND hwnd, TESTSETTINGS *pSettings);
VOID FreeDialogData (HWND hwnd) ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_)
#define AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:
    
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:	
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_)
#define AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaeventcallback.h"

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:
    void RegisterForEvents();
    CWiaEventCallback m_WiaEventCallback;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "wiatest.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	
}

CChildFrame::~CChildFrame()
{    
        
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiaperf\wmain.cpp ===
#include <windows.h>
#include "wia.h"
#include "classes.h"

#include "atlbase.h"


extern CComPtr<IWiaDevMgr> g_pDevMgr;
INT WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hUnused, LPSTR pCmdLine, int nCmdShow)
{
    CPerfTest TestObj;

    MSG msg;
    CoInitialize (NULL);
    if (TestObj.Init (hInstance))
    {
        while (GetMessage (&msg, NULL, 0, 0) > 0)
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }
    g_pDevMgr=NULL;
    CoUninitialize ();
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wiatest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiatest
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\ChildFrm.cpp \
        ..\MainFrm.cpp \
        ..\WiaAcquireDlg.cpp \
        ..\WiacapDlg.cpp \
        ..\WiaDataCallback.cpp \
        ..\WiaEventCallback.cpp \
        ..\WiaeditpropDlg.cpp \
        ..\Wiaeditpropflags.cpp \
        ..\Wiaeditproplist.cpp \
        ..\Wiaeditpropnone.cpp \
        ..\Wiaeditproprange.cpp \
        ..\wiahelper.cpp \
        ..\WiaitemListCtrl.cpp \
        ..\Wiaselect.cpp \
        ..\wiatest.cpp \
        ..\wiatestDoc.cpp \
        ..\wiatestView.cpp \
        ..\WiaDocAcqSettings.cpp \
        ..\WiaSimpleDocPg.cpp \
        ..\WiaAdvancedDocPg.cpp \
        ..\wiatest.rc

# Add interlac.cpp if the PNG support is ever fixed

MISCFILES = ..\wiatest.htm

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\irnotif.lib     \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib     \
        $(SDK_LIB_PATH)\atl.lib         \
        $(SDK_LIB_PATH)\mscms.lib       \
        $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiatest.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_WIATEST_FORM                101
#define IDD_PROPPAGE_SIMPLE_DOCUMENT_SCANNERS_SETTINGS 102
#define IDR_MAINFRAME                   128
#define IDR_WIATESTYPE                  129
#define IDD_SELECTDEVICE_DIALOG         130
#define IDD_EDIT_WIAPROP_NONE_DIALOG    131
#define IDD_EDIT_WIAPROP_LIST_DIALOG    132
#define IDD_EDIT_WIAPROP_FLAGS_DIALOG   133
#define IDD_EDIT_WIAPROP_RANGE_DIALOG   134
#define IDD_EDIT_WIAPROP_NONE_SYSTEMTIME_DIALOG 135
#define IDR_PROPERTY_EDIT_POPUPMENU     136
#define IDD_CAPABILITIES_DIALOG         137
#define IDR_ITEMTREE_POPUPMENU          138
#define IDD_DATA_ACQUISITION_DIALOG     139
#define IDD_DOCUMENT_ACQUISITION_SETTINGS_DIALOG 140
#define IDD_PROPPAGE_HIGHSPEED_DOCUMENT_SCANNERS_SETTINGS 141
#define IDD_PROPPAGE_ADVANCED_DOCUMENT_SCANNERS_SETTINGS 141
#define IDB_THUMBNAIL_MISSING_BITMAP    142
#define IDC_ITEM_TREECTRL               1000
#define IDC_ITEMPROPERTIES_LISTCTRL     1001
#define IDC_SUPPORTEDTYMED_LISTBOX      1002
#define IDC_SUPPORTEDFORMATS_LISTBOX    1003
#define IDC_THUMBNAIL_PREVIEW           1004
#define IDC_THUMNAIL_PREVIEW_CHECKBOX   1005
#define IDC_WIADEVICE_LISTBOX           1007
#define IDC_NONE_PROPERTYVALUE_EDITBOX  1008
#define IDC_NONE_PROPERTY_NAME          1009
#define IDC_LIST_PROPERTY_NAME          1010
#define IDC_LIST_PROPERTYVALUE_EDITBOX  1011
#define IDC_FLAGS_PROPERTYVALUE_LISTBOX 1012
#define IDC_LIST_PROPERTYVALUE_NUMITEMSTEXT 1013
#define IDC_FLAGS_PROPERTY_NAME         1014
#define IDC_FLAGS_PROPERTYVALUE_EDITBOX 1015
#define IDC_LIST_PROPERTYVALUE_LISTBOX  1016
#define IDC_RANGE_PROPERTY_NAME         1017
#define IDC_RANGE_PROPERTYVALUE_EDITBOX 1018
#define RANGE_PROPERTY_MINVALUE         1019
#define RANGE_PROPERTY_MAXVALUE         1020
#define RANGE_PROPERTY_NOMVALUE         1021
#define RANGE_PROPERTY_INCVALUE         1022
#define IDC_NONE_SYSTEMTIME_PROPERTY_NAME 1023
#define IDC_NONE_SYSTEMTIME_PROPERTYVALUE_EDITBOX 1024
#define IDC_NONE_PROPERTY_FORMATTING_TEXT 1025
#define IDC_CAPABILITIES_LISTCTRL       1027
#define IDC_SEND_COMMAND_BUTTON         1028
#define IDC_ACQUIRE_PROGRESS            1029
#define IDC_DATA_ACQUSITION_PERCENTCOMPLETE 1030
#define IDC_DATA_ACQUISITION_MESSAGE    1031
#define IDC_APPLY_SETTINGS              1034
#define IDC_NUMBEROF_PAGES_EDITBOX      1036
#define IDC_DUPLEX_CHECKBOX             1037
#define IDC_DOCUMENT_SOURCE_COMBOBOX    1038
#define IDC_NUMBEROF_PAGES_EDITBOX_TEXT 1039
#define IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX 1040
#define IDM_ACQUIREIMAGE                32771
#define IDM_LOAD_WIAPROPERTYSTREAM      32772
#define IDM_SAVE_WIAPROPERTYSTREAM      32773
#define ID_PROPERTYEDITPOPUPMENU_EDITPROPERTYVALUE 32775
#define IDM_VIEW_CAPABILITIES           32776
#define IDM_VIEW_DISPLAYIMAGE           32777
#define IDM_DELETE_ITEM                 32779
#define IDM_ACQUIREIMAGE_COMMONUI       32780
#define IDM_EDIT_DEBUGOUT               32781
#define IDM_DOCUMENT_ACQUISITION_SETTINGS 32782
#define IDM_SHOWTHUMBNAIL_ACTUALSIZE    32784
#define IDS_WIAERROR_DEVICEBUSY         61446
#define IDS_WIAERROR_GENERAL            61447
#define IDS_WIAERROR_PAPERJAM           61448
#define IDS_WIAERROR_PAPEREMPTY         61449
#define IDS_WIAERROR_PAPERPROBLEM       61450
#define IDS_WIAERROR_DEVICEOFFLINE      61451
#define IDS_WIAERROR_WARMINGUP          61452
#define IDS_WIAERROR_USERINTERVENTION   61453
#define IDS_WIAERROR_ITEMDELETED        61454
#define IDS_WIAERROR_DEVICECOMMUNICATION 61455
#define IDS_WIAERROR_INVALIDCOMMAND     61456
#define IDS_WIAERROR_DIALOGTITLE        61457
#define IDS_WIATESTERROR_COCREATEWIADEVMGR 61458
#define IDS_WIATESTERROR_CREATEDEVICE   61459
#define IDS_WIATESTCOLUMN_PROPERTY      61460
#define IDS_WIATESTCOLUMN_VARTYPE       61461
#define IDS_WIATESTCOLUMN_VALUE         61462
#define IDS_WIATESTCOLUMN_ACCESSFLAGS   61463
#define IDS_WIATESTERROR_ITEMNOTFOUND   61464
#define IDS_WIATESTERROR_WRITING_PROPERTY 61465
#define IDS_WIATESTWARNING_ADDITIONAL_PROPERTY 61466
#define IDS_WIATESTERROR_ENUMFORMATS    61467
#define IDS_WIATESTERROR_IWIADATATRANSFER 61468
#define IDS_WIATESTERROR_NOTIMPLEMENTED 61469
#define IDS_WIATESTINFO_SYSTEMTIME_FORMATTING 61470
#define IDS_WIATESTCOLUMN_CAPABILITYNAME 61471
#define IDS_WIATESTCOLUMN_CAPABILITYDESCRIPTION 61472
#define IDS_WIATESTCOLUMN_CAPABILITYTYPE 61473
#define IDS_WIATESTCOLUMN_CAPABILITYVALUE 61474
#define IDS_WIATESTEVENT                61475
#define IDS_WIATESTCOMMAND              61476
#define IDS_WIATESTERROR_ACQUISITION    61477
#define IDS_WIATESTERROR_CANCEL_ACQUISITION 61478
#define IDS_WIATESTERROR_WRITINGTYMED   61479
#define IDS_WIATESTERROR_WRITINGFORMAT  61480
#define IDS_WIATESTERROR_UNSUPPORTEDTYMED 61481
#define IDS_WIATESTERROR_READINGTYMED   61482
#define IDS_WIATESTERROR_READINGMINBUFFERSIZE 61483
#define IDS_WIATEST_MEMORYTRANSFER_FILENAME 61484
#define IDS_WIATEST_FILETRANSFER_FILENAME 61485
#define IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT 61486
#define IDS_WIATESTERROR_SYSTEMTIMEFORMATTING 61487
#define IDS_WIATESTERROR_DEVICECOMMAND  61488
#define IDS_WIATESTERROR_NOCOMMANDGUID  61489
#define IDS_WIATESTSUCCESS_COMMAND      61490
#define IDS_WIATESTERROR_DELETEROOTITEM 61491
#define IDS_WIATESTERROR_READINGFORMAT  61492
#define IDS_WIATESTERROR_THUMBNAILHEIGHT 61493
#define IDS_WIATESTERROR_THUMBNAILWIDTH 61494
#define IDS_WIATESTERROR_THUMBNAILDATA  61495
#define IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK 61496
#define IDS_WIATESTSTATUS_REGISTER_EVENT_DEVICE_CONNECTED 61497
#define IDS_WIATESTSTATUS_REGISTER_EVENT_DEVICE_DISCONNECTED 61498
#define IDS_WIATESTSTATUS_REGISTER_EVENT_ITEM_CREATED 61499
#define IDS_WIATESTSTATUS_REGISTER_EVENT_ITEM_DELETED 61500
#define IDS_WIATESTSTATUS_REGISTER_EVENT_STORAGE_CREATED 61501
#define IDS_WIATESTSTATUS_REGISTER_EVENT_STORAGE_DELETED 61502
#define IDS_WIATESTSTATUS_REGISTER_EVENT_TREE_UPDATED 61503
#define IDS_WIATESTSTATUS_REGISTER_EVENT_UNKNOWN 61504
#define IDS_MYAPPLICATION_NAME          61507
#define IDS_WIATESTERROR_ENUMERATE_PROPERTIES 61509
#define IDS_WIATESTERROR_READINGTYMED_EXIST 61510
#define IDS_WIATESTWARNING_NEGATIVE_HEIGHTBITMAP 61511
#define IDS_WIATESTSAVEPROPSTREAM_DIALOGTITLE 61512
#define IDS_WIATESTLOADPROPSTREAM_DIALOGTITLE 61513
#define IDS_WIATESTERROR_READPROPERTYSTREAMFILE 61514
#define IDS_WIATESTERROR_WRITEPROPERTYSTREAMFILE 61515
#define IDS_WIASTATUS_DIALOGTITLE       61516
#define IDS_WIATESTERROR_DEVICEID       61517
#define IDS_WIATESTERROR_WIAPROPERTYSTORAGE 61518
#define IDS_WIATEST_DOCUMENT_SETTINGS_TITLE 61519
#define IDS_WIATESTERROR_WRITINGDOCHANDLINGSELECT 61520
#define IDS_WIATESTERROR_WRITINGPAGES   61521
#define IDS_WIATESTERROR_READINGDOCHANDLINGSELECT 61522
#define IDS_WIATESTERROR_READINGPAGES   61523
#define IDS_WIATESTWARNING_ZERO_HEIGHTBITMAP 61524
#define IDS_WIATESTERROR_PROCESSING_THUMBNAILDATA 61525

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "wiatest.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    // register for events
    RegisterForEvents();
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::RegisterForEvents()
{
    HRESULT hr = S_OK;

    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);
        return;
    }

    IWiaEventCallback* pIWiaEventCallback = NULL;

    hr = m_WiaEventCallback.QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
    if (SUCCEEDED(hr)) {
        GUID guidEvent = WIA_EVENT_DEVICE_CONNECTED;

        BOOL bFailedOnce = FALSE;
        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                         NULL,
                                                         &guidEvent,
                                                         pIWiaEventCallback,
                                                         &m_WiaEventCallback.m_pIUnkRelease[0]);
        if (FAILED(hr)) {
            // display one error message... instead of one for each event.
            if (!bFailedOnce) {
                ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
            }
            bFailedOnce = TRUE;
        }

        guidEvent = WIA_EVENT_DEVICE_DISCONNECTED;

        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                         NULL,
                                                         &guidEvent,
                                                         pIWiaEventCallback,
                                                         &m_WiaEventCallback.m_pIUnkRelease[1]);
        if (FAILED(hr)) {
            // display one error message... instead of one for each event.
            if (!bFailedOnce) {
                ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
            }
            bFailedOnce = TRUE;
        }
    }

    m_WiaEventCallback.SetViewWindowHandle(m_hWnd);

    //
    // register for action events by command-line
    //

    WCHAR szMyApplicationLaunchPath[MAX_PATH + 1];
    memset(szMyApplicationLaunchPath,0,sizeof(szMyApplicationLaunchPath));
    GetModuleFileNameW(NULL,szMyApplicationLaunchPath,(sizeof(szMyApplicationLaunchPath)/sizeof(szMyApplicationLaunchPath[0])) - 1);
    BSTR bstrMyApplicationLaunchPath = SysAllocString(szMyApplicationLaunchPath);

    WCHAR szMyApplicationName[MAX_PATH];
    memset(szMyApplicationName,0,sizeof(szMyApplicationName));
    HINSTANCE hInst = AfxGetInstanceHandle();
    if (hInst) {
        LoadStringW(hInst, IDS_MYAPPLICATION_NAME, szMyApplicationName, (sizeof(szMyApplicationName)/sizeof(WCHAR)));

        BSTR bstrMyApplicationName = SysAllocString(szMyApplicationName);

        GUID guidScanButtonEvent = WIA_EVENT_SCAN_IMAGE;
        hr = pIWiaDevMgr->RegisterEventCallbackProgram(
                                                        WIA_REGISTER_EVENT_CALLBACK,
                                                        NULL,
                                                        &guidScanButtonEvent,
                                                        bstrMyApplicationLaunchPath,
                                                        bstrMyApplicationName,
                                                        bstrMyApplicationName,
                                                        bstrMyApplicationLaunchPath);
        if (FAILED(hr)) {
        }

        SysFreeString(bstrMyApplicationName);
        bstrMyApplicationName = NULL;

    }
    SysFreeString(bstrMyApplicationLaunchPath);
    bstrMyApplicationLaunchPath = NULL;

    // release DevMgr
    pIWiaDevMgr->Release();
    pIWiaDevMgr = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaacquiredlg.h ===
#if !defined(AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_)
#define AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CWiaAcquireDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg dialog

class CWiaAcquireDlg : public CDialog
{
// Construction
public:
	void SetPercentComplete(LONG lPercentComplete);
	void SetCallbackMessage(TCHAR *szCallbackMessage);
	BOOL CheckCancelButton();
	BOOL m_bCanceled;
    CWiaAcquireDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaAcquireDlg)
	enum { IDD = IDD_DATA_ACQUISITION_DIALOG };
	CProgressCtrl	m_AcquireProgressCtrl;
	CString	m_szAcquisitionCallbackMessage;
	CString	m_szPercentComplete;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaAcquireDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaAcquireDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();	
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaadvanceddocpg.h ===
#if !defined(AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_)
#define AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaAdvancedDocPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg dialog

class CWiaAdvancedDocPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CWiaAdvancedDocPg)

// Construction
public:
	IWiaItem *m_pIRootItem;
	CWiaAdvancedDocPg();
	~CWiaAdvancedDocPg();

// Dialog Data
	//{{AFX_DATA(CWiaAdvancedDocPg)
	enum { IDD = IDD_PROPPAGE_ADVANCED_DOCUMENT_SCANNERS_SETTINGS };
	CButton	m_DuplexSetting;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWiaAdvancedDocPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWiaAdvancedDocPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiacapdlg.h ===
#if !defined(AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_)
#define AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiacapDlg.h : header file
//

#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME        0
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION 1
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE        2
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE       3

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg dialog

class CWiacapDlg : public CDialog
{
// Construction
public:
	BOOL m_bCommandSent;
	INT GetSelectedCapability();
	void GetCommandGUID(INT iItem, GUID *pguid);
	BOOL IsCommand(INT iItem);
	void SetIWiaItem(IWiaItem *pIWiaItem);
	CWiacapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiacapDlg)
	enum { IDD = IDD_CAPABILITIES_DIALOG };
	CButton	m_SendCommandButton;
	CListCtrl	m_CapablitiesListCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiacapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiacapDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	afx_msg void OnSendCommandButton();
	afx_msg void OnClickCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	LONG m_NumCaps;
	IWiaItem *m_pIWiaItem;
	void AddCapabilitiesToListBox(LONG lType);
	void SetupColumnHeaders();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiacapdlg.cpp ===
// WiacapDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiacapDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg dialog


CWiacapDlg::CWiacapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CWiacapDlg::IDD, pParent)
{
    m_pIWiaItem = NULL;
    m_NumCaps = 0;
    m_bCommandSent = FALSE;
    //{{AFX_DATA_INIT(CWiacapDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CWiacapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiacapDlg)
    DDX_Control(pDX, IDC_SEND_COMMAND_BUTTON, m_SendCommandButton);
    DDX_Control(pDX, IDC_CAPABILITIES_LISTCTRL, m_CapablitiesListCtrl);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiacapDlg, CDialog)
    //{{AFX_MSG_MAP(CWiacapDlg)
    ON_WM_CLOSE()
    ON_BN_CLICKED(IDC_SEND_COMMAND_BUTTON, OnSendCommandButton)
    ON_NOTIFY(NM_CLICK, IDC_CAPABILITIES_LISTCTRL, OnClickCapabilitiesListctrl)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_CAPABILITIES_LISTCTRL, OnItemchangedCapabilitiesListctrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg message handlers

BOOL CWiacapDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    SetupColumnHeaders();
    AddCapabilitiesToListBox(WIA_DEVICE_EVENTS);
    AddCapabilitiesToListBox(WIA_DEVICE_COMMANDS);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiacapDlg::SetupColumnHeaders()
{
    LVCOLUMN lv;
    TCHAR szColumnName[MAX_PATH];
    memset(szColumnName,0,sizeof(szColumnName));
    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(hInstance){
        int i = 0;
        // initialize item property list control column headers

        // Capability name

        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYNAME,szColumnName,MAX_PATH);

        lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lv.fmt          = LVCFMT_LEFT ;
        lv.cx           = 100;
        lv.pszText      = szColumnName;
        lv.cchTextMax   = 0;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
        lv.iImage       = 0;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME,&lv);

        // Capability description
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYDESCRIPTION,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION,&lv);

        // Capability Value
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYVALUE,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE,&lv);

        // Capability type (event or command)
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYTYPE,szColumnName,MAX_PATH);
        lv.cx           = 85;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE,&lv);
    }
}

void CWiacapDlg::AddCapabilitiesToListBox(LONG lType)
{
    WIA_DEV_CAP DevCap;
    IEnumWIA_DEV_CAPS* pIEnumWiaDevCaps = NULL;
    HRESULT hr = S_OK;
    INT ItemNumber = m_NumCaps;
    hr = m_pIWiaItem->EnumDeviceCapabilities(lType,&pIEnumWiaDevCaps);
    if(S_OK == hr){
        do {
            memset(&DevCap,0,sizeof(DevCap));
            hr = pIEnumWiaDevCaps->Next(1,&DevCap,NULL);
            if (S_OK == hr){
                // DevCap.ulFlags;
                // DevCap.bstrIcon;
                // DevCap.bstrCommanline;

                //DevCap.guid;

                TCHAR  szText[MAX_PATH];
                memset(szText,0,sizeof(szText));

                LV_ITEM         lvitem;

                lvitem.mask     = LVIF_TEXT;
                lvitem.iItem    = ItemNumber;
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
                lvitem.pszText  = szText;
                lvitem.iImage   = NULL;

                // Write capability name to list control
#ifndef UNICODE
                WideCharToMultiByte(CP_ACP,0,DevCap.bstrName,-1,szText,MAX_PATH,NULL,NULL);
#else
                lstrcpy(szText,DevCap.bstrName);
#endif
                m_CapablitiesListCtrl.InsertItem(&lvitem);

                // Write capability description to list control
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
#ifndef UNICODE
                WideCharToMultiByte(CP_ACP,0,DevCap.bstrDescription,-1,szText,MAX_PATH,NULL,NULL);
#else
                lstrcpy(szText,DevCap.bstrDescription);
#endif
                m_CapablitiesListCtrl.SetItem(&lvitem);

                // Write capability value
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
                UCHAR *pwszUUID = NULL;
                long lerror = UuidToString(&DevCap.guid,&pwszUUID);
                //TSPRINTF(szText,"%s",pwszUUID);
                lstrcpy(szText,(LPCSTR)pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                m_CapablitiesListCtrl.SetItem(&lvitem);

                // Write capability type
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
                if(lType == WIA_DEVICE_COMMANDS){
                    RC2TSTR(IDS_WIATESTCOMMAND,szText, sizeof(szText));
                } else {
                    RC2TSTR(IDS_WIATESTEVENT,szText, sizeof(szText));
                }
                m_CapablitiesListCtrl.SetItem(&lvitem);

                // increment Row counter
                ItemNumber++;

                // free allocated strings
                if(DevCap.bstrName){
                    SysFreeString(DevCap.bstrName);
                }
                if(DevCap.bstrDescription){
                    SysFreeString(DevCap.bstrDescription);
                }
            }
        }while(hr == S_OK);
        pIEnumWiaDevCaps->Release();
        pIEnumWiaDevCaps = NULL;
    }

    // auto resize columns
    for (int Col = 0; Col <4;Col++){
        m_CapablitiesListCtrl.SetColumnWidth(Col, LVSCW_AUTOSIZE);
    }

    m_NumCaps = ItemNumber;
}

void CWiacapDlg::SetIWiaItem(IWiaItem *pIWiaItem)
{
    pIWiaItem->AddRef();
    m_pIWiaItem = pIWiaItem;
}

void CWiacapDlg::OnClose()
{
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }
    CDialog::OnClose();
}

void CWiacapDlg::OnSendCommandButton()
{
    HRESULT hr = S_OK;
    GUID guidCommand;
    memset(&guidCommand,0,sizeof(GUID));
    IWiaItem *pIWiaItem = NULL;
    GetCommandGUID(GetSelectedCapability(),&guidCommand);
    if(guidCommand != GUID_NULL){
        hr = m_pIWiaItem->DeviceCommand(0,&guidCommand,&pIWiaItem);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_DEVICECOMMAND,hr);
        } else {
            //m_bCommandSent = TRUE;
            if(pIWiaItem){
                pIWiaItem->Release();
                pIWiaItem = NULL;
            }
            TCHAR szCommandSuccess[MAX_PATH];
            memset(szCommandSuccess,0,sizeof(szCommandSuccess));
            RC2TSTR(IDS_WIATESTSUCCESS_COMMAND,szCommandSuccess,sizeof(szCommandSuccess));
            MessageBox(szCommandSuccess);
        }
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_NOCOMMANDGUID);
    }
}

void CWiacapDlg::OnClickCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    HD_NOTIFY*  phdn = (HD_NOTIFY *) pNMHDR;
    if(IsCommand(phdn->iItem)){
        m_SendCommandButton.EnableWindow(TRUE);
    } else {
        m_SendCommandButton.EnableWindow(FALSE);
    }
    *pResult = 0;
}

BOOL CWiacapDlg::IsCommand(INT iItem)
{
    // is an item selected?
    if (iItem < ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME)
        return FALSE;

    TCHAR pszCapabilityType[MAX_PATH];
    TCHAR szCapTypeText[MAX_PATH];
    memset(pszCapabilityType,0,sizeof(pszCapabilityType));
    memset(szCapTypeText,0,sizeof(szCapTypeText));

    // load "Command" text label
    RC2TSTR(IDS_WIATESTCOMMAND,szCapTypeText,sizeof(szCapTypeText));
    m_CapablitiesListCtrl.GetItemText(iItem, ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE,
                                      pszCapabilityType, sizeof(pszCapabilityType));

    return (lstrcmpi(pszCapabilityType,szCapTypeText) == 0);
}

void CWiacapDlg::GetCommandGUID(INT iItem, GUID *pguid)
{
    memset(pguid,0,sizeof(GUID));
    TCHAR szGUID[MAX_PATH];
    memset(szGUID,0,sizeof(szGUID));
    m_CapablitiesListCtrl.GetItemText(iItem, ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE,
                                      szGUID, sizeof(szGUID));
#ifndef UNICODE
        long lErrorCode = UuidFromString((UCHAR*)szGUID,pguid);
#else
        WideCharToMultiByte(CP_ACP, 0,szGUID,-1,szbuffer,MAX_PATH,NULL,NULL);
        UuidFromString((UCHAR*)szbuffer,pguid);
#endif

}

void CWiacapDlg::OnItemchangedCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    if(IsCommand(GetSelectedCapability())){
        m_SendCommandButton.EnableWindow(TRUE);
    } else {
        m_SendCommandButton.EnableWindow(FALSE);
    }
    *pResult = 0;
}

INT CWiacapDlg::GetSelectedCapability()
{
    INT iItem = 0;
    POSITION pos = NULL;
    pos = m_CapablitiesListCtrl.GetFirstSelectedItemPosition();
    if (NULL != pos){
        iItem = m_CapablitiesListCtrl.GetNextSelectedItem(pos);
    }
    return iItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_)
#define AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <wia.h>            // WIA support for applications
#include "wiahelper.h"      // WIA helper class for reading/writing properties
#include "wiadbg.h"         // WIA debug logging

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaacquiredlg.cpp ===
// CWiaAcquireDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "wiaacquiredlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg dialog


CWiaAcquireDlg::CWiaAcquireDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaAcquireDlg::IDD, pParent)
{
	m_bCanceled = FALSE;
    //{{AFX_DATA_INIT(CWiaAcquireDlg)
	m_szAcquisitionCallbackMessage = _T("");
	m_szPercentComplete = _T("");
	//}}AFX_DATA_INIT
}


void CWiaAcquireDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaAcquireDlg)
	DDX_Control(pDX, IDC_ACQUIRE_PROGRESS, m_AcquireProgressCtrl);
	DDX_Text(pDX, IDC_DATA_ACQUISITION_MESSAGE, m_szAcquisitionCallbackMessage);
	DDX_Text(pDX, IDC_DATA_ACQUSITION_PERCENTCOMPLETE, m_szPercentComplete);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaAcquireDlg, CDialog)
	//{{AFX_MSG_MAP(CWiaAcquireDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg message handlers

void CWiaAcquireDlg::OnCancel() 
{	
    m_bCanceled = TRUE;
}

BOOL CWiaAcquireDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_AcquireProgressCtrl.SetPos(0);
    m_AcquireProgressCtrl.SetRange(0,100); 
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CWiaAcquireDlg::CheckCancelButton()
{

    MSG msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!m_hWnd || !IsDialogMessage(&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return m_bCanceled;    
}

void CWiaAcquireDlg::SetCallbackMessage(TCHAR *szCallbackMessage)
{
    m_szAcquisitionCallbackMessage = szCallbackMessage;
    UpdateData(FALSE);
}

void CWiaAcquireDlg::SetPercentComplete(LONG lPercentComplete)
{
    m_szPercentComplete.Format(TEXT("%d%%"),lPercentComplete);
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaadvanceddocpg.cpp ===
// WiaAdvancedDocPg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaAdvancedDocPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg property page

IMPLEMENT_DYNCREATE(CWiaAdvancedDocPg, CPropertyPage)

CWiaAdvancedDocPg::CWiaAdvancedDocPg() : CPropertyPage(CWiaAdvancedDocPg::IDD)
{
	//{{AFX_DATA_INIT(CWiaHighSpeedDocPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWiaAdvancedDocPg::~CWiaAdvancedDocPg()
{
}

void CWiaAdvancedDocPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaAdvancedDocPg)
	DDX_Control(pDX, IDC_DUPLEX_CHECKBOX, m_DuplexSetting);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaAdvancedDocPg, CPropertyPage)
	//{{AFX_MSG_MAP(CWiaAdvancedDocPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg message handlers

BOOL CWiaAdvancedDocPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
    
    // disable Duplex setting
	m_DuplexSetting.EnableWindow(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiadatacallback.cpp ===
// WiaDataCallback.cpp: implementation of the CWiaDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaDataCallback.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaDataCallback::CWiaDataCallback()
{
    m_cRef              = 0;
    m_pBuffer           = NULL;
    m_BytesTransferred  = 0;
    m_pAcquireDlg       = NULL;
    m_lBufferSize       = 65535; // default
    m_bBitmapData       = FALSE;
    m_bNewPageArrived   = TRUE;

    // initialize progress dialog
    m_pAcquireDlg = new CWiaAcquireDlg();
    if(m_pAcquireDlg){
        m_pAcquireDlg->Create(IDD_DATA_ACQUISITION_DIALOG,NULL);
        m_pAcquireDlg->ShowWindow(TRUE);
    }
}

CWiaDataCallback::~CWiaDataCallback()
{
    if (m_pBuffer != NULL){
        LocalFree(m_pBuffer);
        m_pBuffer = NULL;
    }
    if(m_pAcquireDlg){
        m_pAcquireDlg->DestroyWindow();
        delete m_pAcquireDlg;
        m_pAcquireDlg = NULL;
    }
}

HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
        *ppv = (IWiaDataCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

HRESULT _stdcall CWiaDataCallback::BandedDataCallback(LONG lMessage, LONG lStatus,
                                                      LONG lPercentComplete, LONG  lOffset,
                                                      LONG lLength, LONG lReserved, LONG lResLength, BYTE* pbBuffer)
{
    // check for cancel button presses
    if(m_pAcquireDlg->CheckCancelButton()){
        return S_FALSE;
    }

    PWIA_DATA_CALLBACK_HEADER pHeader = NULL;
    switch (lMessage) {
    case IT_MSG_DATA_HEADER:
        pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
        if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
            m_bBitmapData = TRUE;
        }
        m_MemBlockSize      = pHeader->lBufferSize;
        if(m_MemBlockSize <= 0)
            m_MemBlockSize = m_lBufferSize;

        m_pBuffer           = (PBYTE)LocalAlloc(LPTR,m_MemBlockSize);
        m_BytesTransferred  = 0;
        UpdateAcqusitionDialog(TEXT("IT_MSG_DATA_HEADER"),lPercentComplete);
        break;
    case IT_MSG_DATA:
        if(m_bNewPageArrived){
            m_BytesTransferred = 0;
            m_bNewPageArrived = FALSE;
        }
        if (m_pBuffer != NULL) {
            m_BytesTransferred += lLength;
            if(m_BytesTransferred >= m_MemBlockSize){
                m_MemBlockSize += (lLength * MEMORY_BLOCK_FACTOR);

                //
                // catch LocalReAlloc() call, and check returned memory pointer.
                // if the pointer is NULL, then free any allocated memory and
                // return E_OUTOFMEMORY to the caller.
                //

                PBYTE pTempBuffer = NULL;
                pTempBuffer = (PBYTE)LocalReAlloc(m_pBuffer,m_MemBlockSize,LMEM_MOVEABLE);
                if(NULL != pTempBuffer){
                    m_pBuffer = pTempBuffer;
                } else {
                    if(m_pBuffer){
                        LocalFree(m_pBuffer);
                        m_pBuffer = NULL;
                    }
                    return E_OUTOFMEMORY;
                }
            }
            memcpy(m_pBuffer + lOffset, pbBuffer, lLength);
        }
        UpdateAcqusitionDialog(TEXT("IT_MSG_DATA"),lPercentComplete);
        break;
    case IT_MSG_STATUS:
        if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE){
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_TRANSFER_FROM_DEVICE)"),lPercentComplete);
        } else if (lStatus & IT_STATUS_PROCESSING_DATA){
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_PROCESSING_DATA)"),lPercentComplete);
        } else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_TRANSFER_TO_CLIENT)"),lPercentComplete);
        }
        break;
    case IT_MSG_NEW_PAGE:
        UpdateAcqusitionDialog(TEXT("IT_MSG_NEWPAGE"),0);
        pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
        m_lPageCount =  pHeader->lPageCount;
        m_bNewPageArrived = TRUE;
        break;
    case IT_MSG_FILE_PREVIEW_DATA:
        UpdateAcqusitionDialog(TEXT("IT_MSG_FILE_PREVIEW_DATA"),-1);
        break;
    case IT_MSG_FILE_PREVIEW_DATA_HEADER:
        UpdateAcqusitionDialog(TEXT("IT_MSG_FILE_PREVIEW_DATA_HEADER"),-1);
        break;
    case IT_MSG_TERMINATION:
        UpdateAcqusitionDialog(TEXT("IT_MSG_TERMINATION"),-1);
        break;
    default:
        break;
    }
    return S_OK;
}

void CWiaDataCallback::UpdateAcqusitionDialog(TCHAR *szMessage, LONG lPercentComplete)
{
    m_pAcquireDlg->SetCallbackMessage(szMessage);
    if(lPercentComplete > -1){
        m_pAcquireDlg->SetPercentComplete(lPercentComplete);
        m_pAcquireDlg->m_AcquireProgressCtrl.SetPos(lPercentComplete);
    }
}

void CWiaDataCallback::SetBufferSizeRequest(LONG lBufferSize)
{
    m_lBufferSize = lBufferSize;
}

BYTE* CWiaDataCallback::GetCallbackMemoryPtr(LONG *plDataSize)
{
    *plDataSize = m_BytesTransferred;
    return m_pBuffer;
}

BOOL CWiaDataCallback::IsBITMAPDATA()
{
    return m_bBitmapData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiadatacallback.h ===
// WiaDataCallback.h: interface for the CWiaDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
#define AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_

#include "WiaAcquireDlg.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MEMORY_BLOCK_FACTOR 2

class CWiaDataCallback : public IWiaDataCallback
{
public:
	BOOL IsBITMAPDATA();
	BYTE* GetCallbackMemoryPtr(LONG *plDataSize);
	void SetBufferSizeRequest(LONG lBufferSize);
	void SetDialog(CWiaAcquireDlg *pAcquireDlg);
	CWiaAcquireDlg *m_pAcquireDlg;
	CWiaDataCallback();
	virtual ~CWiaDataCallback();
    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(HWND hPreviewWnd = NULL);
    HRESULT _stdcall BandedDataCallback(LONG lMessage, LONG lStatus, LONG lPercentComplete,
                                        LONG lOffset, LONG lLength, LONG lReserved,
                                        LONG lResLength, BYTE* pbBuffer);
private:
	void UpdateAcqusitionDialog(TCHAR *szMessage, LONG lPercentComplete);
   ULONG m_cRef;         // Object reference count.  
   PBYTE m_pBuffer;      // complete data buffer
   LONG  m_MemBlockSize;
   LONG  m_BytesTransferred;   
   long  m_lPageCount;
   LONG  m_lBufferSize;
   BOOL  m_bBitmapData;
   BOOL  m_bNewPageArrived;
};

#endif // !defined(AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiadocacqsettings.cpp ===
// WiaDocAcqSettings.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaDocAcqSettings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings

IMPLEMENT_DYNAMIC(CWiaDocAcqSettings, CPropertySheet)

CWiaDocAcqSettings::CWiaDocAcqSettings(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
}

CWiaDocAcqSettings::CWiaDocAcqSettings(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
}

CWiaDocAcqSettings::CWiaDocAcqSettings(UINT nIDCaption, IWiaItem *pIRootItem, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
    m_pIRootItem = pIRootItem;
    m_SimpleDocumentScannerSettings.m_pIRootItem = pIRootItem;
    m_AdvancedDocumentScannerSettings.m_pIRootItem = pIRootItem;
}

CWiaDocAcqSettings::~CWiaDocAcqSettings()
{
}


BEGIN_MESSAGE_MAP(CWiaDocAcqSettings, CPropertySheet)
	//{{AFX_MSG_MAP(CWiaDocAcqSettings)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiadbg.h ===
#pragma once
// this is incompatible with stidebug.h, so don't include stidebug.h
#define _STIDEBUG_H_ 
#undef ASSERT
#undef REQUIRE
#undef DPRINTF
#undef DPRINTF2
#undef DPRINTF_NOINFO

//
// predefined bits in debug flags
//

// something is really wrong, should not go unnoticed
#define COREDBG_ERRORS                  0x00000001

// something that may be of interest to debugging person
#define COREDBG_WARNINGS                0x00000002

// trace random low-priority things with DBG_TRC
#define COREDBG_TRACES                  0x00000004

// trace function entries, exits (if so equipped) 
// with DBG_FN
#define COREDBG_FNS                     0x00000008

// break on errors
#define COREDBG_BREAK_ON_ERRORS         0x80000000

// log to file (default) 
#define COREDBG_DONT_LOG_TO_FILE        0x40000000

// log to debugger (default)
#define COREDBG_DONT_LOG_TO_DEBUGGER    0x20000000


// debug log is saved to this file 
#define COREDBG_FILE_NAME "%systemroot%\\wiatest.log"
// registry key location
#define COREDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define COREDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define COREDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define COREDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes

#ifdef DEBUG
// by default, log errors only in debug builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#else
// by default log nothing in free builds
#define COREDBG_DEFAULT_FLAGS 0
#endif

/****************************************************************************

HOW TO USE WIA CORE DEBUG (main macros)
======================================

- DBG_INIT(hInstance)
  Call from WinMain or DllMain to enable debug flags on a per module
  basis.  If you don't call it, all DLLs will inherit the debug flags
  of the process that creates them.

- DBG_ERR(("Something happened, hr = 0x%x", hr));
  Use when an error condition occurred.
  
- DBG_WRN(("Warning, something happening, Value=%d", iValue));
  Use in a situation warranting a warning.
  
- DBG_TRC(("Random trace statement, Value=%s", szValue));
  Use sparingly to trace certain parts of your code.  Minimize spew!!!
  
- DBG_PRT(("Output without standard File,Line,ThreadID info, Value=%d", iValue));
  Same as DBG_TRC, but doesn't output the File,Line,ThreadID line.  
  ***Use this only if you are doing some special formatting (use sparingly)***
  
- DBG_FN(FnName)
  Tracks entry and exits from a given scope.
  
- CHECK_NOERR   (VarName)
  CHECK_NOERR2  (VarName, (YourMsg,...))
  Does GetLastError and if not 0, outputs error.
    
- CHECK_S_OK    (hr)
  CHECK_S_OK2   (hr, (YourMsg,...))
  Checks if hr == S_OK, if not, outputs error.
    
- CHECK_SUCCESS (lResult)
  CHECK_SUCCESS2(lResult, (YourMsg,...))
  Checks if lResult == ERROR_SUCCESS, if not, outputs error.
    
- REQUIRE_NOERR   (VarName)
  REQUIRE_NOERR2  (VarName, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_S_OK    (hr)
  REQUIRE_S_OK2   (hr, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_SUCCESS (lResult)
  REQUIRE_SUCCESS2(lResult, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well    
  
HOW TO TURN ON WIA CORE DEBUG (3 ways)
======================================

1) Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>, 
   DWORD value "DebugFlags" to an OR'd value of above COREDBG_* flags.  
   Need to restart app to pick up new settings. Key is auto created the first time
   the app is run.  (Note: <ModuleName> above is the name 
   of your DLL or EXE.  e.g. wiavusd.dll has a registry key of 
   "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll")

                            OR

2) In the debugger, set g_dwDebugFlags to OR'd value of COREDBG_* flags above.
   You can do this anytime during the debug session.
   
                            OR

3) Call in your code WIA_SET_FLAGS(COREDBG_ERRORS | COREDBG_WARNINGS | COREDBG_TRACES);
   or any combo of the COREDBG_* flags.
   
*****************************************************************************/


#define DBG_INIT(x) DINIT(x)
#define DBG_ERR(x)  DPRINTF(COREDBG_ERRORS, x)
#define DBG_WRN(x)  DPRINTF(COREDBG_WARNINGS, x)
#define DBG_TRC(x)  DPRINTF(COREDBG_TRACES, x)
#define DBG_PRT(x)  DPRINTF_NOINFO(COREDBG_TRACES, x)
#define DBG_SET_FLAGS(x) g_dwDebugFlags = (x)

#ifdef __cplusplus
extern "C" {
#endif

    //
    // accessible to your startup code and at runtime in debugger
    // defined in wia\common\stirt\coredbg.cpp
    //
    extern DWORD  g_dwDebugFlags; 
    extern HANDLE g_hDebugFile;
    extern DWORD  g_dwDebugFileSizeLimit;
    extern BOOL   g_bDebugInited;
    void CoreDbgTrace(LPCSTR fmt, ...);
    void CoreDbgTraceWithTab(LPCSTR fmt, ...);
    void CoreDbgInit(HINSTANCE hInstance);


#ifdef DEBUG

#define DINIT(x) CoreDbgInit(x)

#define ASSERT(x) \
    if(!(x)) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId, #x); \
        CoreDbgTraceWithTab("ASSERT FAILED. '%s'", #x); \
        DebugBreak(); \
    }

    
#undef VERIFY
#define VERIFY(x) ASSERT(x)
#define REQUIRE(x) ASSERT(x)
    
#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif
        

#else // begin NODEBUG

#define DINIT(x)    
#define ASSERT(x)
#undef VERIFY
#define VERIFY(x) x
#define REQUIRE(x) x    

#define DPRINTF(flags, x) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }
    
#define DPRINTF2(flags, x, y) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
    }

#define DPRINTF_NOINFO(flags, x) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif

#endif // end NODEBUG

#define COREDBG_MFMT_FLAGS (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | \
    FORMAT_MESSAGE_MAX_WIDTH_MASK)

#define REQUIRE_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
        goto Cleanup; \
    }

#define REQUIRE_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError), y); \
        goto Cleanup; \
    }
    
#define REQUIRE_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
        goto Cleanup; \
    } \
}

#define REQUIRE_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define CHECK_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
    }

#define CHECK_NOERR2(x, y) \
    if(!(x)) { \
        DWORD dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error", __dwCoreDbgLastError, __dwCoreDbgLastError); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, szError), y); \
    }

#define CHECK_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
    } \
}

#define CHECK_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
    } \
}

#define CHECK_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
    } \
} 

#define CHECK_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
    } \
} 

#ifdef __cplusplus
    class CoreDbgFn {
    private:
        LPCSTR m_fn;
        DWORD m_threadId;
    public:

        CoreDbgFn(LPCSTR fn)
        { 
            m_fn = fn;
            m_threadId = GetCurrentThreadId();
            if(!g_bDebugInited) 
            {
                CoreDbgInit(NULL);
            }
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Entering %s", m_threadId, m_threadId, m_fn);
            }
        } 
        
        ~CoreDbgFn() 
        { 
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Leaving  %s", m_threadId, m_threadId, m_fn); 
            }
        }
    };
#endif



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiadocacqsettings.h ===
#if !defined(AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_)
#define AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_

#include "WiaSimpleDocPg.h"	// Added by ClassView
#include "WiaAdvancedDocPg.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaDocAcqSettings.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings

class CWiaDocAcqSettings : public CPropertySheet
{
	DECLARE_DYNAMIC(CWiaDocAcqSettings)

// Construction
public:
	CWiaDocAcqSettings(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CWiaDocAcqSettings(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CWiaDocAcqSettings(UINT nIDCaption, IWiaItem *pIRootItem, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaDocAcqSettings)
	//}}AFX_VIRTUAL

// Implementation
public:
	IWiaItem *m_pIRootItem;
	CWiaAdvancedDocPg m_AdvancedDocumentScannerSettings;
	CWiaSimpleDocPg m_SimpleDocumentScannerSettings;
	virtual ~CWiaDocAcqSettings();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWiaDocAcqSettings)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropdlg.cpp ===
// WiaeditpropDlg.cpp: implementation of the CWiaeditpropDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaeditpropDlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaeditpropDlg::CWiaeditpropDlg()
{

}

CWiaeditpropDlg::~CWiaeditpropDlg()
{

}

UINT CWiaeditpropDlg::DoModal(TCHAR *szPropertyName, TCHAR *szPropertyValue)
{
    UINT nResponse = 0;
    if(m_ulAttributes & WIA_PROP_NONE){
        CWiaeditpropnone EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        TCHAR szFormatting[MAX_PATH];
        memset(szFormatting,0,sizeof(szFormatting));
        if(lstrcmp(szPropertyName,TEXT("Device Time")) == 0){
            RC2TSTR(IDS_WIATESTINFO_SYSTEMTIME_FORMATTING,szFormatting,sizeof(szFormatting));
        }
        EditPropDlg.SetPropertyFormattingInstructions(szFormatting);
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_LIST){
        CWiaeditproplist EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        VALID_LIST_VALUES ValidValues;

        ValidValues.vt = m_vt;
        ValidValues.lNumElements = WIA_PROP_LIST_COUNT(m_pPropVar);
        if(ValidValues.vt == VT_CLSID){
            ValidValues.pList = (BYTE*)m_pPropVar->cauuid.pElems;
        } else {
            ValidValues.pList = (BYTE*)m_pPropVar->caul.pElems;
        }

        EditPropDlg.SetPropertyValidValues(&ValidValues);

        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_FLAG){
        CWiaeditpropflags EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        if(m_ulAttributes & WIA_PROP_WRITE){
            EditPropDlg.SetPropertyValidValues(m_pPropVar->caul.pElems[WIA_FLAG_VALUES]);
        } else {
            LONG lCurrentValue = 0;
            int iError = TSSCANF(szPropertyValue,"%d",&lCurrentValue);
            EditPropDlg.SetPropertyValidValues(lCurrentValue);
        }
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_RANGE){
        CWiaeditproprange EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        VALID_RANGE_VALUES ValidValues;

        ValidValues.lMin = m_pPropVar->caul.pElems[WIA_RANGE_MIN];
        ValidValues.lMax = m_pPropVar->caul.pElems[WIA_RANGE_MAX];
        ValidValues.lNom = m_pPropVar->caul.pElems[WIA_RANGE_NOM];
        ValidValues.lInc = m_pPropVar->caul.pElems[WIA_RANGE_STEP];

        EditPropDlg.SetPropertyValidValues(&ValidValues);
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    }
    return nResponse;
}

void CWiaeditpropDlg::SetAttributes(ULONG ulAttributes, PROPVARIANT *pPropVar)
{
    m_pPropVar     = pPropVar;
    m_ulAttributes = ulAttributes;
}

void CWiaeditpropDlg::GetPropertyValue(TCHAR *szPropertyValue)
{
    lstrcpy(szPropertyValue,m_szPropertyValue.GetBuffer(MAX_PATH));
}

void CWiaeditpropDlg::SetVarType(VARTYPE vt)
{
    m_vt = vt;
}

VARTYPE CWiaeditpropDlg::GetVarType()
{
    return m_vt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropdlg.h ===
// WiaeditpropDlg.h: interface for the CWiaeditpropDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_)
#define AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaeditpropflags.h"
#include "wiaeditpropnone.h"
#include "wiaeditproplist.h"
#include "wiaeditproprange.h"

class CWiaeditpropDlg  
{
public:	
	void SetAttributes(ULONG ulAttributes,  PROPVARIANT *pPropVar);
    void SetVarType(VARTYPE vt);
    VARTYPE GetVarType();
    void GetPropertyValue(TCHAR *szPropertyValue);
	UINT DoModal(TCHAR *szPropertyName, TCHAR *szPropertyValue);
	CWiaeditpropDlg();
	virtual ~CWiaeditpropDlg();

private:
    VARTYPE m_vt;               // variant type
	PROPVARIANT *m_pPropVar;    // valid values propvariant( IN )
    ULONG m_ulAttributes;       // attributes
    CString m_szPropertyValue;  // property value
};

#endif // !defined(AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropflags.h ===
#if !defined(AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_)
#define AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditpropflags.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags dialog

class CWiaeditpropflags : public CDialog
{
// Construction
public:
    void AddValidValuesToListBox();
    void SelectCurrentValue();
    void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(LONG lPropertyValidValues);
    CWiaeditpropflags(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CWiaeditpropflags)
    enum { IDD = IDD_EDIT_WIAPROP_FLAGS_DIALOG };
    CListBox    m_PropertyValidValuesListBox;
    CString m_szPropertyName;
    CString m_szPropertyValue;
    LONG m_lValidValues;
    LONG m_lCurrentValue;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiaeditpropflags)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWiaeditpropflags)
    afx_msg void OnSelchangeFlagsPropertyvalueListbox();
    virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropflags.cpp ===
// Wiaeditpropflags.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditpropflags.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags dialog


CWiaeditpropflags::CWiaeditpropflags(CWnd* pParent /*=NULL*/)
: CDialog(CWiaeditpropflags::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaeditpropflags)
    m_szPropertyName = _T("");
    m_szPropertyValue = _T("");
    m_lValidValues = 0;
    m_lCurrentValue = 0;
    //}}AFX_DATA_INIT
}


void CWiaeditpropflags::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaeditpropflags)
    DDX_Control(pDX, IDC_FLAGS_PROPERTYVALUE_LISTBOX, m_PropertyValidValuesListBox);
    DDX_Text(pDX, IDC_FLAGS_PROPERTY_NAME, m_szPropertyName);
    DDX_Text(pDX, IDC_FLAGS_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditpropflags, CDialog)
//{{AFX_MSG_MAP(CWiaeditpropflags)
ON_LBN_SELCHANGE(IDC_FLAGS_PROPERTYVALUE_LISTBOX, OnSelchangeFlagsPropertyvalueListbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags message handlers

void CWiaeditpropflags::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditpropflags::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
    int iErrorCode = TSSCANF(szPropertyValue,TEXT("%d"),&m_lCurrentValue);
    m_szPropertyValue.Format("0x%08X",m_lCurrentValue);
}

void CWiaeditpropflags::SetPropertyValidValues(LONG lPropertyValidValues)
{
    m_lValidValues = lPropertyValidValues;
}

void CWiaeditpropflags::OnSelchangeFlagsPropertyvalueListbox()
{
    m_lCurrentValue = 0;
    TCHAR szListBoxValue[MAX_PATH];
    LONG lListBoxValue = 0;
    int indexArray[100];

    memset(indexArray,0,sizeof(indexArray));
    int iNumItemsSelected = m_PropertyValidValuesListBox.GetSelItems(100,indexArray);
    for(int i = 0; i < iNumItemsSelected; i++){
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        m_PropertyValidValuesListBox.GetText(indexArray[i],szListBoxValue);
        if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szListBoxValue,&lListBoxValue)){
            m_lCurrentValue |= lListBoxValue;
        } else {
            LONG lVal = 0;
            int iErrorCode = TSSCANF(szListBoxValue, TEXT("0x%08X"),&lVal);
            m_lCurrentValue |= lVal;
        }
    }

    m_szPropertyValue.Format("0x%08X",m_lCurrentValue);
    UpdateData(FALSE);
}

BOOL CWiaeditpropflags::OnInitDialog()
{
    CDialog::OnInitDialog();

    AddValidValuesToListBox();
    SelectCurrentValue();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaeditpropflags::SelectCurrentValue()
{
    //
    // TO DO: Fix this code to make the current value match
    //        the current selection.
    //

    /*
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    lstrcpy(szCurrentValue,m_szPropertyValue);
    LONG lVal = 0;
    TSSCANF(szCurrentValue,TEXT("%d"),&lVal);
    INT iNumItemsInListBox = m_PropertyValidValuesListBox.GetCount();
    while(iNumItemsInListBox > 0){
        TCHAR szListBoxValue[MAX_PATH];
        LONG lListBoxValue = 0;
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        m_PropertyValidValuesListBox.GetText((iNumItemsInListBox-1),szListBoxValue);
        if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szListBoxValue,&lListBoxValue)){
            if(lListBoxValue & lVal){
                m_PropertyValidValuesListBox.SetSel(iNumItemsInListBox-1);
            }
        }
        iNumItemsInListBox--;
    }
    */
}

void CWiaeditpropflags::AddValidValuesToListBox()
{
    int iStartIndex = FindStartIndexInTable(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()));
    int iEndIndex = FindEndIndexInTable(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()));
    TCHAR szListBoxValue[MAX_PATH];
    LONG x = 1;
    for (LONG bit = 0; bit<32; bit++) {
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        // check to see if the bit is set
        if (m_lValidValues & x) {
            // the bit is set, so find it in the table
            if (iStartIndex >= 0) {
                // we have a table for this property, use it
                TCHAR *pszListBoxValue = NULL;
                for (int index = iStartIndex; index <= iEndIndex;index++) {
                    if (x == WIACONSTANT_VALUE_FROMINDEX(index)) {
                        pszListBoxValue = WIACONSTANT_TSTR_FROMINDEX(index);
                    }
                }
                if(pszListBoxValue != NULL){
                    // we found the item in the table
                    lstrcpy(szListBoxValue,pszListBoxValue);
                } else {
                    // we could not find the item in the table, so use
                    // the actual value
                    TSPRINTF(szListBoxValue,TEXT("0x%08X"),x);
                }
            } else {
                // we have no items in the table for this property, so use
                // the actual value
                TSPRINTF(szListBoxValue,TEXT("0x%08X"),x);
            }
            // add the string to the list box
            m_PropertyValidValuesListBox.AddString(szListBoxValue);
        }
        x <<= 1;
    }
}

void CWiaeditpropflags::OnOK()
{
    m_szPropertyValue.Format(TEXT("%d"),m_lCurrentValue);
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropnone.cpp ===
// Wiaeditpropnone.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditpropnone.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone dialog


CWiaeditpropnone::CWiaeditpropnone(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaeditpropnone::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWiaeditpropnone)
	m_szPropertyName = _T("");
	m_szPropertyValue = _T("");
	m_szFormattingInstructions = _T("");
	//}}AFX_DATA_INIT
}


void CWiaeditpropnone::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaeditpropnone)
	DDX_Text(pDX, IDC_NONE_PROPERTY_NAME, m_szPropertyName);
	DDX_Text(pDX, IDC_NONE_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
	DDX_Text(pDX, IDC_NONE_PROPERTY_FORMATTING_TEXT, m_szFormattingInstructions);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditpropnone, CDialog)
	//{{AFX_MSG_MAP(CWiaeditpropnone)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone message handlers

void CWiaeditpropnone::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditpropnone::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditpropnone::SetPropertyFormattingInstructions(TCHAR *szFormatting)
{
    m_szFormattingInstructions = szFormatting;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditproplist.h ===
#if !defined(AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_)
#define AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditproplist.h : header file
//

typedef struct _VALID_LIST_VALUES {
    VARTYPE vt;
    LONG lNumElements;
    BYTE *pList;
}VALID_LIST_VALUES, *PVALID_LIST_VALUES;

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist dialog

class CWiaeditproplist : public CDialog
{
// Construction
public:
	void GUID2TSTR(GUID *pGUID, TCHAR *szValue);
	void SelectCurrentValue();
	void AddValidValuesToListBox();
	void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(PVALID_LIST_VALUES pValidListValues);
	CWiaeditproplist(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditproplist)
	enum { IDD = IDD_EDIT_WIAPROP_LIST_DIALOG };
	CListBox	m_PropertyValidValuesListBox;
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szNumListValues;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditproplist)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	PVALID_LIST_VALUES m_pValidListValues;

	// Generated message map functions
	//{{AFX_MSG(CWiaeditproplist)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListPropertyvalueListbox();
	afx_msg void OnDblclkListPropertyvalueListbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditpropnone.h ===
#if !defined(AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_)
#define AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditpropnone.h : header file
//

/*
typedef struct _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    } 	SYSTEMTIME;
*/

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone dialog

class CWiaeditpropnone : public CDialog
{
// Construction
public:
	void SetPropertyFormattingInstructions(TCHAR *szFormatting);
	void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
	CWiaeditpropnone(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditpropnone)
	enum { IDD = IDD_EDIT_WIAPROP_NONE_DIALOG };
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szFormattingInstructions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditpropnone)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaeditpropnone)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditproplist.cpp ===
// Wiaeditproplist.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditproplist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist dialog


CWiaeditproplist::CWiaeditproplist(CWnd* pParent /*=NULL*/)
    : CDialog(CWiaeditproplist::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaeditproplist)
    m_szPropertyName = _T("");
    m_szPropertyValue = _T("");
    m_szNumListValues = _T("");
    //}}AFX_DATA_INIT
}


void CWiaeditproplist::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaeditproplist)
    DDX_Control(pDX, IDC_LIST_PROPERTYVALUE_LISTBOX, m_PropertyValidValuesListBox);
    DDX_Text(pDX, IDC_LIST_PROPERTY_NAME, m_szPropertyName);
    DDX_Text(pDX, IDC_LIST_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
    DDX_Text(pDX, IDC_LIST_PROPERTYVALUE_NUMITEMSTEXT, m_szNumListValues);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditproplist, CDialog)
    //{{AFX_MSG_MAP(CWiaeditproplist)
    ON_LBN_SELCHANGE(IDC_LIST_PROPERTYVALUE_LISTBOX, OnSelchangeListPropertyvalueListbox)
    ON_LBN_DBLCLK(IDC_LIST_PROPERTYVALUE_LISTBOX, OnDblclkListPropertyvalueListbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist message handlers

void CWiaeditproplist::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditproplist::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditproplist::SetPropertyValidValues(PVALID_LIST_VALUES pValidListValues)
{
    m_pValidListValues = pValidListValues;
    m_szNumListValues.Format(TEXT("%d item(s) in List"),pValidListValues->lNumElements);
}

void CWiaeditproplist::AddValidValuesToListBox()
{
    TCHAR szValidValue[MAX_PATH];

    for (LONG i = 0;i < m_pValidListValues->lNumElements ; i++) {
        memset(szValidValue,0,sizeof(szValidValue));

        switch (m_pValidListValues->vt) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            if (!WIACONSTANT2TSTR(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),((LONG*)m_pValidListValues->pList)[WIA_LIST_VALUES + i],szValidValue)) {
                TSPRINTF(szValidValue,TEXT("%d"),((INT*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            }
            break;
        case VT_R4:
        case VT_R8:
            TSPRINTF(szValidValue,TEXT("%3.3f"),((float*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            break;
        case VT_BSTR:
            {
                CString TempString = ((BSTR*)m_pValidListValues->pList)[WIA_LIST_VALUES + i];
                lstrcpy(szValidValue,TempString);
                //TSPRINTF(szValidValue,TEXT("%ws"),((BSTR*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            }
            break;
        case VT_CLSID:
            GUID2TSTR(&((GUID*)m_pValidListValues->pList)[WIA_LIST_VALUES + i],szValidValue);
            break;
        case VT_UINT:
        default:
            TSPRINTF(szValidValue,TEXT("%d"),((UINT*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            break;
        }
        // add value to listbox
        m_PropertyValidValuesListBox.AddString(szValidValue);
    }
}

BOOL CWiaeditproplist::OnInitDialog()
{
    CDialog::OnInitDialog();
    AddValidValuesToListBox();
    SelectCurrentValue();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaeditproplist::OnSelchangeListPropertyvalueListbox()
{
    INT iCurrentSelection = 0;
    iCurrentSelection = m_PropertyValidValuesListBox.GetCurSel();
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    m_PropertyValidValuesListBox.GetText(iCurrentSelection,szCurrentValue);

    LONG lVal = 0;
    if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szCurrentValue,&lVal)){
        TSPRINTF(szCurrentValue,TEXT("%d"),lVal);
    }

    m_szPropertyValue = szCurrentValue;
    UpdateData(FALSE);
}

void CWiaeditproplist::SelectCurrentValue()
{
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    lstrcpy(szCurrentValue,m_szPropertyValue);
    INT iSelection = m_PropertyValidValuesListBox.FindString(-1,szCurrentValue);
    if(iSelection >= 0){
        m_PropertyValidValuesListBox.SetCurSel(iSelection);
    } else {
        int iErrorCode = 0;
        LONG lVal = 0;
        TCHAR szTempValue[MAX_PATH];
        memset(szTempValue,0,sizeof(szTempValue));
        switch (m_pValidListValues->vt) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            // try to select a converted type
            iErrorCode = TSSCANF(szCurrentValue,TEXT("%d"),&lVal);
            if (!WIACONSTANT2TSTR(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),lVal,szTempValue)) {
                m_PropertyValidValuesListBox.SetCurSel(0);
            } else {
                iSelection = m_PropertyValidValuesListBox.FindString(-1,szTempValue);
                if(iSelection >= 0){
                    m_PropertyValidValuesListBox.SetCurSel(iSelection);
                } else {
                    m_PropertyValidValuesListBox.SetCurSel(0);
                }
            }
            break;
        default:
            m_PropertyValidValuesListBox.SetCurSel(0);
            break;
        }
    }
}

void CWiaeditproplist::OnDblclkListPropertyvalueListbox()
{
    CDialog::OnOK();
}

void CWiaeditproplist::GUID2TSTR(GUID *pGUID, TCHAR *szValue)
{
    UCHAR *pwszUUID = NULL;
    long lErrorCode = UuidToString(pGUID,&pwszUUID);
    lstrcpy(szValue,(LPCTSTR)pwszUUID);
    //TSPRINTF(szValue,"%s",pwszUUID);
    // free allocated string
    RpcStringFree(&pwszUUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditproprange.cpp ===
// Wiaeditproprange.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditproprange.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange dialog


CWiaeditproprange::CWiaeditproprange(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaeditproprange::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWiaeditproprange)
	m_szPropertyName = _T("");
	m_szPropertyValue = _T("");
	m_szPropertyIncValue = _T("");
	m_szPropertyMaxValue = _T("");
	m_szPropertyMinValue = _T("");
	m_szPropertyNomValue = _T("");
	//}}AFX_DATA_INIT
}


void CWiaeditproprange::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaeditproprange)
	DDX_Text(pDX, IDC_RANGE_PROPERTY_NAME, m_szPropertyName);
	DDX_Text(pDX, IDC_RANGE_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
	DDX_Text(pDX, RANGE_PROPERTY_INCVALUE, m_szPropertyIncValue);
	DDX_Text(pDX, RANGE_PROPERTY_MAXVALUE, m_szPropertyMaxValue);
	DDX_Text(pDX, RANGE_PROPERTY_MINVALUE, m_szPropertyMinValue);
	DDX_Text(pDX, RANGE_PROPERTY_NOMVALUE, m_szPropertyNomValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditproprange, CDialog)
	//{{AFX_MSG_MAP(CWiaeditproprange)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange message handlers

void CWiaeditproprange::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditproprange::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditproprange::SetPropertyValidValues(PVALID_RANGE_VALUES pValidRangeValues)
{
    m_szPropertyMinValue.Format(TEXT("%d"),pValidRangeValues->lMin);
    m_szPropertyMaxValue.Format(TEXT("%d"),pValidRangeValues->lMax);
    m_szPropertyNomValue.Format(TEXT("%d"),pValidRangeValues->lNom);
    m_szPropertyIncValue.Format(TEXT("%d"),pValidRangeValues->lInc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditproptable.h ===
#ifndef _WIAEDITPROPTABLE_H
#define _WIAEDITPROPTABLE_H

typedef struct _WIA_EDIT_PROPERTY_TABLE_ENTRY {
    LONG lVal;
    TCHAR *pszValName;
    TCHAR *pszPropertyName;
}WIA_EDIT_PROPERTY_TABLE_ENTRY,*PWIA_EDIT_PROPERTY_TABLE_ENTRY;

/////////////////////////////////////////////////////////////////////////////////////////////////
// { [Property Value],               [Property Value contant name],         [Property Name] }
/////////////////////////////////////////////////////////////////////////////////////////////////
// Template: {,TEXT(""),TEXT("")},

WIA_EDIT_PROPERTY_TABLE_ENTRY g_EditPropTable[] = 
{
    {WIA_INTENT_NONE,                TEXT("WIA_INTENT_NONE"),                TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_COLOR,    TEXT("WIA_INTENT_IMAGE_TYPE_COLOR"),    TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_GRAYSCALE,TEXT("WIA_INTENT_IMAGE_TYPE_GRAYSCALE"),TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_TEXT,     TEXT("WIA_INTENT_IMAGE_TYPE_TEXT"),     TEXT("Current Intent")},
    {WIA_INTENT_MINIMIZE_SIZE,       TEXT("WIA_INTENT_MINIMIZE_SIZE"),       TEXT("Current Intent")},
    {WIA_INTENT_MAXIMIZE_QUALITY,    TEXT("WIA_INTENT_MAXIMIZE_QUALITY"),    TEXT("Current Intent")},
    {TYMED_CALLBACK,                 TEXT("TYMED_CALLBACK"),                 TEXT("Media Type")},
    {TYMED_FILE,                     TEXT("TYMED_FILE"),                     TEXT("Media Type")},
    {TYMED_MULTIPAGE_CALLBACK,       TEXT("TYMED_MULTIPAGE_CALLBACK"),       TEXT("Media Type")},
    {TYMED_MULTIPAGE_FILE,           TEXT("TYMED_MULTIPAGE_FILE"),           TEXT("Media Type")},
    {WIA_COMPRESSION_NONE,           TEXT("WIA_COMPRESSION_NONE"),           TEXT("Compression")},
    {WIA_COMPRESSION_BI_RLE4,        TEXT("WIA_COMPRESSION_BI_RLE4"),        TEXT("Compression")},
    {WIA_COMPRESSION_BI_RLE8,        TEXT("WIA_COMPRESSION_BI_RLE8"),        TEXT("Compression")},
    {WIA_COMPRESSION_G3,             TEXT("WIA_COMPRESSION_G3"),             TEXT("Compression")},
    {WIA_FINAL_SCAN,                 TEXT("WIA_FINAL_SCAN"),                 TEXT("Preview")},
    {WIA_PREVIEW_SCAN,               TEXT("WIA_PREVIEW_SCAN"),               TEXT("Preview")},
    {FEEDER,                         TEXT("FEEDER"),                         TEXT("Document Handling Select")},
    {FLATBED,                        TEXT("FLATBED"),                        TEXT("Document Handling Select")},
    {DUPLEX,                         TEXT("DUPLEX"),                         TEXT("Document Handling Select")},
    {FRONT_FIRST,                    TEXT("FRONT_FIRST"),                    TEXT("Document Handling Select")},
    {BACK_FIRST,                     TEXT("BACK_FIRST"),                     TEXT("Document Handling Select")},
    {FRONT_ONLY,                     TEXT("FRONT_ONLY"),                     TEXT("Document Handling Select")},
    {BACK_ONLY,                      TEXT("BACK_ONLY"),                      TEXT("Document Handling Select")},
    {NEXT_PAGE,                      TEXT("NEXT_PAGE"),                      TEXT("Document Handling Select")},
    {PREFEED,                        TEXT("PREFEED"),                        TEXT("Document Handling Select")},
    {AUTO_ADVANCE,                   TEXT("AUTO_ADVANCE"),                   TEXT("Document Handling Select")},    
    {FEED,                           TEXT("FEED"),                           TEXT("Document Handling Capabilities")},
    {FLAT,                           TEXT("FLAT"),                           TEXT("Document Handling Capabilities")},
    {DUP,                            TEXT("DUP"),                            TEXT("Document Handling Capabilities")},
    {DETECT_FLAT,                    TEXT("DETECT_FLAT"),                    TEXT("Document Handling Capabilities")},
    {DETECT_SCAN,                    TEXT("DETECT_SCAN"),                    TEXT("Document Handling Capabilities")},
    {DETECT_FEED,                    TEXT("DETECT_FEED"),                    TEXT("Document Handling Capabilities")},
    {DETECT_DUP,                     TEXT("DETECT_DUP"),                     TEXT("Document Handling Capabilities")},
    {DETECT_FEED_AVAIL,              TEXT("DETECT_FEED_AVAIL"),              TEXT("Document Handling Capabilities")},
    {DETECT_DUP_AVAIL,               TEXT("DETECT_DUP_AVAIL"),               TEXT("Document Handling Capabilities")},
    {FEED_READY,                     TEXT("FEED_READY"),                     TEXT("Document Handling Status")},
    {FLAT_READY,                     TEXT("FLAT_READY"),                     TEXT("Document Handling Status")},
    {DUP_READY,                      TEXT("DUP_READY"),                      TEXT("Document Handling Status")},
    {FLAT_COVER_UP,                  TEXT("FLAT_COVER_UP"),                  TEXT("Document Handling Status")},
    {PATH_COVER_UP,                  TEXT("PATH_COVER_UP"),                  TEXT("Document Handling Status")},
    {PAPER_JAM,                      TEXT("PAPER_JAM"),                      TEXT("Document Handling Status")},
    {WIA_DATA_THRESHOLD,             TEXT("WIA_DATA_THRESHOLD"),             TEXT("Data Type")},
    {WIA_DATA_DITHER,                TEXT("WIA_DATA_DITHER"),                TEXT("Data Type")},
    {WIA_DATA_GRAYSCALE,             TEXT("WIA_DATA_GRAYSCALE"),             TEXT("Data Type")},
    {WIA_DATA_COLOR,                 TEXT("WIA_DATA_COLOR"),                 TEXT("Data Type")},
    {WIA_DATA_COLOR_THRESHOLD,       TEXT("WIA_DATA_COLOR_THRESHOLD"),       TEXT("Data Type")},
    {WIA_DATA_COLOR_DITHER,          TEXT("WIA_DATA_COLOR_DITHER"),          TEXT("Data Type")},
    {WiaItemTypeFree,                TEXT("WiaItemTypeFree"),                TEXT("Item Flags")},
    {WiaItemTypeImage,               TEXT("WiaItemTypeImage"),               TEXT("Item Flags")},
    {WiaItemTypeFile,                TEXT("WiaItemTypeFile"),                TEXT("Item Flags")},
    {WiaItemTypeFolder,              TEXT("WiaItemTypeFolder"),              TEXT("Item Flags")},
    {WiaItemTypeRoot,                TEXT("WiaItemTypeRoot"),                TEXT("Item Flags")},
    {WiaItemTypeAnalyze,             TEXT("WiaItemTypeAnalyze"),             TEXT("Item Flags")},
    {WiaItemTypeAudio,               TEXT("WiaItemTypeAudio"),               TEXT("Item Flags")},
    {WiaItemTypeDevice,              TEXT("WiaItemTypeDevice"),              TEXT("Item Flags")},
    {WiaItemTypeDeleted,             TEXT("WiaItemTypeDeleted"),             TEXT("Item Flags")},
    {WiaItemTypeDisconnected,        TEXT("WiaItemTypeDisconnected"),        TEXT("Item Flags")},
    {WiaItemTypeHPanorama,           TEXT("WiaItemTypeHPanorama"),           TEXT("Item Flags")},
    {WiaItemTypeVPanorama,           TEXT("WiaItemTypeVPanorama"),           TEXT("Item Flags")},
    {WiaItemTypeBurst,               TEXT("WiaItemTypeBurst"),               TEXT("Item Flags")},
    {WiaItemTypeStorage,             TEXT("WiaItemTypeStorage"),             TEXT("Item Flags")},
    {WiaItemTypeTransfer,            TEXT("WiaItemTypeTransfer"),            TEXT("Item Flags")},
    {WiaItemTypeGenerated,           TEXT("WiaItemTypeGenerated"),           TEXT("Item Flags")},
    {WiaItemTypeHasAttachments,      TEXT("WiaItemTypeHasAttachments"),      TEXT("Item Flags")},    
    {WIA_ITEM_READ,                  TEXT("WIA_ITEM_READ"),                  TEXT("Access Rights")},
    {WIA_ITEM_WRITE,                 TEXT("WIA_ITEM_WRITE"),                 TEXT("Access Rights")},
    {WIA_ITEM_CAN_BE_DELETED,        TEXT("WIA_ITEM_CAN_BE_DELETED"),        TEXT("Access Rights")},    
    {0,                              NULL,                                   NULL}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeventcallback.cpp ===
// WiaDataCallback.cpp: implementation of the CWiaEventCallback class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaEventCallback.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaEventCallback::CWiaEventCallback()
{
    m_cRef = 0;
    for(LONG lEventIndex = 0; lEventIndex < MAX_REGISTERED_EVENTS; lEventIndex++){
        if(m_pIUnkRelease[lEventIndex]){            
            m_pIUnkRelease[lEventIndex] = NULL;
        }
    }

    memset(m_szWindowText,0,sizeof(m_szWindowText));
}

CWiaEventCallback::~CWiaEventCallback()
{    
    for(LONG lEventIndex = 0; lEventIndex < MAX_REGISTERED_EVENTS; lEventIndex++){
        if(m_pIUnkRelease[lEventIndex]){
            m_pIUnkRelease[lEventIndex]->Release();
            m_pIUnkRelease[lEventIndex] = NULL;
        }
    }
    
}

HRESULT _stdcall CWiaEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback)
        *ppv = (IWiaEventCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaEventCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaEventCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

HRESULT _stdcall CWiaEventCallback::ImageEventCallback(
    const GUID                      *pEventGUID,
    BSTR                            bstrEventDescription,
    BSTR                            bstrDeviceID,
    BSTR                            bstrDeviceDescription,
    DWORD                           dwDeviceType,
    BSTR                            bstrFullItemName,
    ULONG                           *plEventType,
    ULONG                           ulReserved)
{

    TCHAR szStatusText[255];
    memset(szStatusText,0,sizeof(szStatusText));

    TSPRINTF(szStatusText,TEXT("Description: %ws\nDeviceID: %ws\nDevice Description: %ws\nDevice Type: %d\nFull Item Name: %ws"),
             bstrEventDescription, 
             bstrDeviceID,         
             bstrDeviceDescription,
             dwDeviceType,         
             bstrFullItemName);
    
    if(lstrlen(m_szWindowText) == 0){
        SetViewWindowHandle(m_hViewWindow);
    }

    ::MessageBox(m_hViewWindow,szStatusText, m_szWindowText, MB_ICONINFORMATION);
    
    if (NULL != m_hViewWindow) {
        BSTR bstrTargetDevice = SysAllocString(bstrDeviceID);
        // handle known events    
        if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
            ::PostMessage(m_hViewWindow,WM_DEVICE_DISCONNECTED,0,(LPARAM)bstrTargetDevice);
        } else if (*pEventGUID == WIA_EVENT_DEVICE_CONNECTED) {
            ::PostMessage(m_hViewWindow,WM_DEVICE_CONNECTED,0,0);
        } else if (*pEventGUID == WIA_EVENT_ITEM_DELETED) {
            ::PostMessage(m_hViewWindow,WM_ITEM_DELETED,0,0);
        } else if (*pEventGUID == WIA_EVENT_ITEM_CREATED) {
            ::PostMessage(m_hViewWindow,WM_ITEM_CREATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_TREE_UPDATED) {
            ::PostMessage(m_hViewWindow,WM_TREE_UPDATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_STORAGE_CREATED) {
            ::PostMessage(m_hViewWindow,WM_STORAGE_CREATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_STORAGE_DELETED) {
            ::PostMessage(m_hViewWindow,WM_STORAGE_DELETED,0,0);
        }
    }
    return S_OK;
}

void CWiaEventCallback::SetViewWindowHandle(HWND hWnd)
{
    m_hViewWindow = hWnd;
    TCHAR szWindowText[MAX_PATH];
    memset(szWindowText,0,sizeof(szWindowText));
    GetWindowText(hWnd,szWindowText,(sizeof(szWindowText)/sizeof(TCHAR)));
    TSPRINTF(m_szWindowText,TEXT("Event Notification [%s]"),szWindowText);    
}

void CWiaEventCallback::SetNumberOfEventsRegistered(LONG lEventsRegistered)
{
    m_lNumEventsRegistered = lEventsRegistered;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeventcallback.h ===
// WiaEventCallback.h: interface for the CWiaEventCallback class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
#define AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MAX_REGISTERED_EVENTS   50

class CWiaEventCallback : public IWiaEventCallback
{
public:	
	CWiaEventCallback();
	virtual ~CWiaEventCallback();
    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall ImageEventCallback(
                                        const GUID *pEventGUID,
                                        BSTR       bstrEventDescription,
                                        BSTR       bstrDeviceID,
                                        BSTR       bstrDeviceDescription,
                                        DWORD      dwDeviceType,
                                        BSTR       bstrFullItemName,
                                        ULONG      *plEventType,
                                        ULONG      ulReserved);
    IUnknown* m_pIUnkRelease[MAX_REGISTERED_EVENTS];
    void SetViewWindowHandle(HWND hWnd);
    void SetNumberOfEventsRegistered(LONG lEventsRegistered);
private:
   ULONG m_cRef;         // Object reference count.  
   HWND m_hViewWindow;
   LONG m_lNumEventsRegistered;
   TCHAR m_szWindowText[MAX_PATH];
};

#endif // !defined(AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaeditproprange.h ===
#if !defined(AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_)
#define AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditproprange.h : header file
//

typedef struct _VALID_RANGE_VALUES {
    LONG lMin;
    LONG lMax;
    LONG lNom;
    LONG lInc;
}VALID_RANGE_VALUES, *PVALID_RANGE_VALUES;

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange dialog

class CWiaeditproprange : public CDialog
{
// Construction
public:    
    void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(PVALID_RANGE_VALUES pValidRangeValues);
	CWiaeditproprange(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditproprange)
	enum { IDD = IDD_EDIT_WIAPROP_RANGE_DIALOG };
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szPropertyIncValue;
	CString	m_szPropertyMaxValue;
	CString	m_szPropertyMinValue;
	CString	m_szPropertyNomValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditproprange)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaeditproprange)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiahelper.cpp ===
// CWiahelper.cpp: implementation of the CWiahelper class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "wiahelper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiahelper::CWiahelper()
{
    m_pIWiaItem = NULL;    
    m_pIWiaPropStg = NULL;
}

CWiahelper::~CWiahelper()
{
    
    // release property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release item
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }
}

HRESULT CWiahelper::SetIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    
    // release old property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release old item pointer
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }

    // add ref item pointer (because we are storing it in this object)
    if(pIWiaItem){
        // get property storage interface
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(VOID**)&m_pIWiaPropStg);
        if(SUCCEEDED(hr)){
            pIWiaItem->AddRef();
            m_pIWiaItem = pIWiaItem;
        }        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {

#ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,PropVar[0].bstrVal,-1,szPropertyValue,MAX_PATH,NULL,NULL);
#else            
            lstrcpy(szPropertyValue,PropVar[0].bstrVal);
#endif
            PropVariantClear(PropVar);
        }
        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue)
{
    HRESULT hr = S_OK;    
    if (m_pIWiaPropStg) {
    
        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *plPropertyValue = PropVar[0].lVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pfPropertyValue = PropVar[0].fltVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            memcpy(pguidPropertyValue,PropVar[0].puuid,sizeof(GUID));            
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pDataSize = PropVar[0].caub.cElems;
            *ppData = (BYTE*)GlobalAlloc(GPTR,PropVar[0].caub.cElems);
            memcpy(*ppData,PropVar[0].caub.pElems,PropVar[0].caub.cElems);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;    
}

HRESULT CWiahelper::ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pbstrPropertyValue = SysAllocString(PropVar[0].bstrVal);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyStreamFile(TCHAR *szPropertyStreamFile)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        HGLOBAL hMem = NULL;
        LPSTREAM pstmProp = NULL;
        LPBYTE pStreamData = NULL;
        CFile StreamFile;
        CFileException Exception;

        if (StreamFile.Open(szPropertyStreamFile,CFile::modeRead,&Exception)) {                        
            DWORD dwSize = 0;
            StreamFile.Read(&dwSize,sizeof(DWORD));
            if (dwSize) {
                hMem = GlobalAlloc(GMEM_MOVEABLE, dwSize);
                if (hMem) {
                    pStreamData = (LPBYTE)GlobalLock(hMem);
                    if (pStreamData != NULL) {
                        DWORD dwReadSize = 0;
                        dwReadSize = StreamFile.Read(pStreamData,dwSize);
                        GlobalUnlock(hMem);
                        if(dwSize == dwReadSize){
                            hr = CreateStreamOnHGlobal(hMem, TRUE, &pstmProp);
                            if (SUCCEEDED(hr)) {
                                hr = m_pIWiaPropStg->SetPropertyStream((GUID*) &GUID_NULL, pstmProp);                                
                                pstmProp->Release();
                            }
                        } else {
                            hr = E_INVALIDARG;
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    GlobalFree(hMem);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }            
            StreamFile.Close();
        } else {
            AfxThrowFileException(Exception.m_cause);
        }        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt      = VT_BSTR;
        
#ifndef UNICODE
        WCHAR wszPropertyValue[MAX_PATH];
        memset(wszPropertyValue,0,sizeof(wszPropertyValue));
        MultiByteToWideChar(CP_ACP, 0,szPropertyValue,-1,wszPropertyValue,MAX_PATH);
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(wszPropertyValue);
#else
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(szPropertyValue);
#endif    
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
        
        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyLong(PROPID PropertyID, LONG lPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt   = VT_I4;
        propvar[0].lVal = lPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt     = VT_R4;
        propvar[0].fltVal = fPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt     = VT_CLSID;
        propvar[0].puuid  = &guidPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt      = VT_BSTR;
        
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(bstrPropertyValue);
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
        
        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyStreamFile(TCHAR *szPropertyStreamFile)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        IStream *pIStrm  = NULL;
        CFile StreamFile;
        CFileException Exception;                
        GUID guidCompatId = GUID_NULL;

        hr = m_pIWiaPropStg->GetPropertyStream(&guidCompatId, &pIStrm);
        if (S_OK == hr) {
            if (StreamFile.Open(szPropertyStreamFile,CFile::modeCreate|CFile::modeWrite,&Exception)) {
                ULARGE_INTEGER uliSize  = {0,0};
                LARGE_INTEGER  liOrigin = {0,0};
                pIStrm->Seek(liOrigin, STREAM_SEEK_END, &uliSize);
                DWORD dwSize = uliSize.u.LowPart;
                if (dwSize) {
                    StreamFile.Write(&dwSize, sizeof(DWORD));
                    PBYTE pBuf = (PBYTE) LocalAlloc(LPTR, dwSize);
                    if (pBuf) {
                        pIStrm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                        ULONG ulRead = 0;
                        pIStrm->Read(pBuf, dwSize, &ulRead);
                        StreamFile.Write(pBuf, ulRead);
                        LocalFree(pBuf);
                    }
                }
                StreamFile.Close();
            } else {
                AfxThrowFileException(Exception.m_cause);
            }
            pIStrm->Release();
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaitemlistctrl.cpp ===
// WiaitemListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaitemListCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl

CWiaitemListCtrl::CWiaitemListCtrl()
{
}

CWiaitemListCtrl::~CWiaitemListCtrl()
{
}


BEGIN_MESSAGE_MAP(CWiaitemListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CWiaitemListCtrl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl message handlers

void CWiaitemListCtrl::SetupColumnHeaders()
{
    LVCOLUMN lv;
    TCHAR szColumnName[MAX_PATH];
    memset(szColumnName,0,sizeof(szColumnName));
    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(hInstance){
        int i = 0;
        // initialize item property list control column headers
        
        // Property name
        
        LoadString(hInstance,IDS_WIATESTCOLUMN_PROPERTY,szColumnName,MAX_PATH);
        
        lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lv.fmt          = LVCFMT_LEFT ;
        lv.cx           = 100;
        lv.pszText      = szColumnName;
        lv.cchTextMax   = 0;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
        lv.iImage       = 0;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,&lv);
        
        // Property Value (current)
        LoadString(hInstance,IDS_WIATESTCOLUMN_VALUE,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,&lv);
        
        // VT_???
        LoadString(hInstance,IDS_WIATESTCOLUMN_VARTYPE,szColumnName,MAX_PATH);
        lv.cx           = 85;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE,&lv);
        
        // Property access Flags
        LoadString(hInstance,IDS_WIATESTCOLUMN_ACCESSFLAGS,szColumnName,MAX_PATH);
        lv.cx           = 500;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS,&lv);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiahelper.h ===
// CWiahelper.h: interface for the cwiahelper class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_)
#define AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MIN_PROPID 2

class CWiahelper  
{
public:
	CWiahelper();
	virtual ~CWiahelper();
    
    HRESULT SetIWiaItem(IWiaItem *pIWiaItem);

    HRESULT ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue);
    HRESULT ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue);
    HRESULT ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue);
    HRESULT ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize);
    HRESULT ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue);
    HRESULT ReadPropertyStreamFile(TCHAR *szPropertyStreamFile);

    HRESULT WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT WritePropertyLong(PROPID PropertyID, LONG lPropertyValue);
    HRESULT WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue);
    HRESULT WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue);
    HRESULT WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue);
    HRESULT WritePropertyStreamFile(TCHAR *szPropertyStreamFile);


private:
    IWiaItem *m_pIWiaItem;
    IWiaPropertyStorage *m_pIWiaPropStg;
};

#endif // !defined(AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaitemlistctrl.h ===
#if !defined(AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_)
#define AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaitemListCtrl.h : header file
//

#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME    0
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE   1
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE 2
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS  3

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl window

class CWiaitemListCtrl : public CListCtrl
{
// Construction
public:
	CWiaitemListCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaitemListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:	
	void SetupColumnHeaders();
	virtual ~CWiaitemListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWiaitemListCtrl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaselect.h ===
#if !defined(AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_)
#define AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaselect.h : header file
//

#define MAX_WIA_DEVICES 50

/////////////////////////////////////////////////////////////////////////////
// CWiaselect dialog

class CWiaselect : public CDialog
{
// Construction
public:
	CWiaselect(CWnd* pParent = NULL);   // standard constructor
    BSTR m_bstrSelectedDeviceID;

// Dialog Data
	//{{AFX_DATA(CWiaselect)
	enum { IDD = IDD_SELECTDEVICE_DIALOG };
	CListBox	m_WiaDeviceListBox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaselect)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    LONG m_lDeviceCount;
    BSTR m_bstrDeviceIDArray[MAX_WIA_DEVICES];
    void FreebstrDeviceIDArray();
	// Generated message map functions
	//{{AFX_MSG(CWiaselect)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnDblclkWiadeviceListbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiasimpledocpg.h ===
#if !defined(AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_)
#define AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaSimpleDocPg.h : header file
//

#define DOCUMENT_SOURCE_FLATBED 0
#define DOCUMENT_SOURCE_FEEDER  1

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg dialog

class CWiaSimpleDocPg : public CPropertyPage
{
    DECLARE_DYNCREATE(CWiaSimpleDocPg)

// Construction
public:
    IWiaItem *m_pIRootItem;
    CWiaSimpleDocPg();
    ~CWiaSimpleDocPg();

// Dialog Data
    //{{AFX_DATA(CWiaSimpleDocPg)
    enum { IDD = IDD_PROPPAGE_SIMPLE_DOCUMENT_SCANNERS_SETTINGS };
    CEdit   m_lPages;
    CStatic m_lPagesText;
    CComboBox   m_DocumentSourceComboBox;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWiaSimpleDocPg)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bFirstInit;
    int GetSelectedDocumentSource();
    int GetNumberOfPagesToAcquire();
    // Generated message map functions
    //{{AFX_MSG(CWiaSimpleDocPg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeDocumentSourceCombobox();
    afx_msg void OnUpdateNumberofPagesEditbox();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiasimpledocpg.cpp ===
// WiaSimpleDocPg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaSimpleDocPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg property page

IMPLEMENT_DYNCREATE(CWiaSimpleDocPg, CPropertyPage)

CWiaSimpleDocPg::CWiaSimpleDocPg() : CPropertyPage(CWiaSimpleDocPg::IDD)
{
        //{{AFX_DATA_INIT(CWiaSimpleDocPg)
        //}}AFX_DATA_INIT
}

CWiaSimpleDocPg::~CWiaSimpleDocPg()
{
}

void CWiaSimpleDocPg::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CWiaSimpleDocPg)
        DDX_Control(pDX, IDC_NUMBEROF_PAGES_EDITBOX, m_lPages);
        DDX_Control(pDX, IDC_NUMBEROF_PAGES_EDITBOX_TEXT, m_lPagesText);
        DDX_Control(pDX, IDC_DOCUMENT_SOURCE_COMBOBOX, m_DocumentSourceComboBox);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaSimpleDocPg, CPropertyPage)
        //{{AFX_MSG_MAP(CWiaSimpleDocPg)
        ON_CBN_SELCHANGE(IDC_DOCUMENT_SOURCE_COMBOBOX, OnSelchangeDocumentSourceCombobox)
        ON_EN_UPDATE(IDC_NUMBEROF_PAGES_EDITBOX, OnUpdateNumberofPagesEditbox)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg message handlers

BOOL CWiaSimpleDocPg::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    m_bFirstInit = TRUE;
    CWiahelper WIA;
    WIA.SetIWiaItem(m_pIRootItem);
    HRESULT hr = S_OK;

    // set current settings
    LONG lDocumentHandlingSelect = 0;
    hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGDOCHANDLINGSELECT,hr);
    }

    if(lDocumentHandlingSelect & FEEDER){
        // default to feeder settings
        m_DocumentSourceComboBox.SetCurSel(DOCUMENT_SOURCE_FEEDER);
    } else {
        // default to flatbed settings
        m_DocumentSourceComboBox.SetCurSel(DOCUMENT_SOURCE_FLATBED);
    }

    LONG lPages = 0;
    hr = WIA.ReadPropertyLong(WIA_DPS_PAGES,&lPages);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGPAGES,hr);
    }

    TCHAR szPages[MAX_PATH];
    memset(szPages,0,sizeof(szPages));
    TSPRINTF(szPages,TEXT("%d"),lPages);
    m_lPages.SetWindowText(szPages);

    // adjust UI
    OnSelchangeDocumentSourceCombobox();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaSimpleDocPg::OnSelchangeDocumentSourceCombobox()
{
    if(m_bFirstInit){
        m_bFirstInit = FALSE;
    } else {
        SetModified();
    }
    if (m_pIRootItem) {
        INT iCurSel = DOCUMENT_SOURCE_FLATBED;
        iCurSel = m_DocumentSourceComboBox.GetCurSel();
        switch (iCurSel) {
        case DOCUMENT_SOURCE_FLATBED:
            m_lPagesText.EnableWindow(FALSE);
            m_lPages.EnableWindow(FALSE);
            break;
        case DOCUMENT_SOURCE_FEEDER:
            m_lPagesText.EnableWindow(TRUE);
            m_lPages.EnableWindow(TRUE);
            break;
        default:
            break;
        }
    }
}

BOOL CWiaSimpleDocPg::OnApply()
{
    HRESULT hr = S_OK;
    CWiahelper WIA;
    WIA.SetIWiaItem(m_pIRootItem);

    // set pages property
    LONG lPages = 0;
    lPages = (LONG)GetNumberOfPagesToAcquire();
    hr = WIA.WritePropertyLong(WIA_DPS_PAGES,lPages);
    if (FAILED(hr)) {
        ErrorMessageBox(IDS_WIATESTERROR_WRITINGPAGES,hr);
    }

    // set Document Handling Select property
    if(GetSelectedDocumentSource() == DOCUMENT_SOURCE_FLATBED){
        hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,FLATBED);
    } else {
        hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,FEEDER);
    }

    if (FAILED(hr)) {
        ErrorMessageBox(IDS_WIATESTERROR_WRITINGDOCHANDLINGSELECT,hr);
    }

    return CPropertyPage::OnApply();
}

int CWiaSimpleDocPg::GetSelectedDocumentSource()
{
    return m_DocumentSourceComboBox.GetCurSel();
}

int CWiaSimpleDocPg::GetNumberOfPagesToAcquire()
{
    int iPagesToAcquire = 1;
    TCHAR szPages[MAX_PATH];
    memset(szPages,0,sizeof(szPages));
    UpdateData();
    m_lPages.GetWindowText(szPages,(sizeof(szPages)/sizeof(TCHAR)));
    int iErrorCode = TSSCANF(szPages,TEXT("%d"),&iPagesToAcquire);
    return iPagesToAcquire;
}

void CWiaSimpleDocPg::OnUpdateNumberofPagesEditbox()
{
    SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiaselect.cpp ===
// Wiaselect.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaselect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaselect dialog


CWiaselect::CWiaselect(CWnd* pParent /*=NULL*/)
    : CDialog(CWiaselect::IDD, pParent)
{
    m_bstrSelectedDeviceID = NULL;
    m_lDeviceCount = 0;
    //{{AFX_DATA_INIT(CWiaselect)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CWiaselect::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaselect)
    DDX_Control(pDX, IDC_WIADEVICE_LISTBOX, m_WiaDeviceListBox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaselect, CDialog)
    //{{AFX_MSG_MAP(CWiaselect)
    ON_LBN_DBLCLK(IDC_WIADEVICE_LISTBOX, OnDblclkWiadeviceListbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaselect message handlers

BOOL CWiaselect::OnInitDialog()
{
    CDialog::OnInitDialog();

    // a WIA device was selected, so continue
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue
        ErrorMessageBox(TEXT("CoCreateInstance failed trying to create the WIA device manager"),hr);
        return FALSE;
    } else {

        // enumerate devices, and fill WIA Device listbox
        m_lDeviceCount = 0;
        ULONG ulFetched   = 0;

        IWiaPropertyStorage *pIWiaPropStg = NULL;
        IEnumWIA_DEV_INFO *pWiaEnumDevInfo = NULL;
        hr = pIWiaDevMgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL,&pWiaEnumDevInfo);
        if (SUCCEEDED(hr)){
            hr = pWiaEnumDevInfo->Reset();
            if (SUCCEEDED(hr)) {
                do {
                    hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg,&ulFetched);
                    if (hr == S_OK) {

                        PROPSPEC    PropSpec[2];
                        PROPVARIANT PropVar [2];

                        memset(PropVar,0,sizeof(PropVar));

                        PropSpec[0].ulKind = PRSPEC_PROPID;
                        PropSpec[0].propid = WIA_DIP_DEV_ID;

                        PropSpec[1].ulKind = PRSPEC_PROPID;
                        PropSpec[1].propid = WIA_DIP_DEV_NAME;

                        hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC), PropSpec, PropVar);
                        if (hr == S_OK) {

                            // Device ID
                            // PropVar[0].bstrVal

                            // Device Name
                            // PropVar[1].bstrVal

                            TCHAR szDeviceName[MAX_PATH];
                            memset(szDeviceName,0,sizeof(szDeviceName));

                            //TSPRINTF(szDeviceName,TEXT("%ws"),PropVar[1].bstrVal);
                            CString TempString = PropVar[1].bstrVal;
                            lstrcpy(szDeviceName,TempString);

                            // add name to listbox
                            m_WiaDeviceListBox.AddString(szDeviceName);

                            // add device ID to array
                            m_bstrDeviceIDArray[m_lDeviceCount] = SysAllocString(PropVar[0].bstrVal);

                            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                        }
                        // release property storage interface
                        pIWiaPropStg->Release();

                        // increment device counter
                        m_lDeviceCount++;
                    }
                } while (hr == S_OK);
            }
        }

        if(m_lDeviceCount <= 0){
            // no devices found?...
            // disable OK button
            CWnd *pOKButton = NULL;
            pOKButton = GetDlgItem(IDOK);
            if(NULL != pOKButton){
                pOKButton->EnableWindow(FALSE);
            }

            // add no device message
            m_WiaDeviceListBox.AddString(TEXT("<No WIA Devices Detected>"));
        }

        if(pIWiaDevMgr){
            pIWiaDevMgr->Release();
            pIWiaDevMgr = NULL;
        }
    }

    m_WiaDeviceListBox.SetCurSel(0);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaselect::OnOK()
{
    INT SelectedDeviceIndex = m_WiaDeviceListBox.GetCurSel();
    if(SelectedDeviceIndex >= 0){
        m_bstrSelectedDeviceID = SysAllocString(m_bstrDeviceIDArray[SelectedDeviceIndex]);
    }

    FreebstrDeviceIDArray();
    CDialog::OnOK();
}

void CWiaselect::FreebstrDeviceIDArray()
{
    for(LONG i = 0; i < m_lDeviceCount; i++){
        if(NULL != m_bstrDeviceIDArray[i]){
            SysFreeString(m_bstrDeviceIDArray[i]);
            m_bstrDeviceIDArray[i] = NULL;
        }
    }
}

void CWiaselect::OnCancel()
{
    FreebstrDeviceIDArray();
    CDialog::OnCancel();
}

void CWiaselect::OnDblclkWiadeviceListbox()
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatest.h ===
// wiatest.h : main header file for the WIATEST application
//

#if !defined(AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_)
#define AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
    #define TSPRINTF swprintf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
    #define TSPRINTF sprintf
#endif

#define WM_DEVICE_DISCONNECTED WM_USER + 900
#define WM_DEVICE_CONNECTED    WM_USER + 901
#define WM_ITEM_DELETED        WM_USER + 902
#define WM_ITEM_CREATED        WM_USER + 903
#define WM_TREE_UPDATED        WM_USER + 904
#define WM_STORAGE_CREATED     WM_USER + 905
#define WM_STORAGE_DELETED     WM_USER + 906

void Trace(LPCTSTR format,...);
LONG WIACONSTANT_VALUE_FROMINDEX(int index);
TCHAR *WIACONSTANT_TSTR_FROMINDEX(int index);
INT FindEndIndexInTable(TCHAR *pszPropertyName);
INT FindStartIndexInTable(TCHAR *pszPropertyName);
BOOL WIACONSTANT2TSTR(TCHAR *pszPropertyName, LONG lValue, TCHAR *pszValName);
BOOL TSTR2WIACONSTANT(TCHAR *pszPropertyName, TCHAR *pszValName, LONG *plVal);
void RC2TSTR(UINT uResourceID, TCHAR *szString, LONG size);
void StatusMessageBox(HWND hWnd, UINT uResourceID);
void StatusMessageBox(HWND hWnd, LPTSTR szStatusText);
void StatusMessageBox(UINT uResourceID);
void StatusMessageBox(LPTSTR szStatusText);
void ErrorMessageBox(UINT uResourceID, HRESULT hrError = S_OK);
void ErrorMessageBox(LPTSTR szErrorText, HRESULT hrError = S_OK);

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp:
// See wiatest.cpp for the implementation of this class
//

class CWiatestApp : public CWinApp
{
public:
    CWiatestApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiatestApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CWiatestApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatest.cpp ===
// wiatest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wiatest.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "wiatestDoc.h"
#include "wiatestView.h"
#include "WiaeditpropTable.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG WIACONSTANT_VALUE_FROMINDEX(int index)
{
    return g_EditPropTable[index].lVal;
}

TCHAR *WIACONSTANT_TSTR_FROMINDEX(int index)
{
    return g_EditPropTable[index].pszValName;
}

INT FindEndIndexInTable(TCHAR *pszPropertyName)
{
    int index = FindStartIndexInTable(pszPropertyName);
    if(index >=0){
        while((g_EditPropTable[index].pszPropertyName != NULL) && (lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0)){
            index++;
        }
    }
    return (index - 1);
}

INT FindStartIndexInTable(TCHAR *pszPropertyName)
{
    int index = 0;
    BOOL bFound = FALSE;
    while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE) ){
        // check for property name
        if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
            // we found property name
            bFound = TRUE;
        } else {
            index++;
        }
    }
    if(!bFound){
        index = -1;
    }
    return index;
}

BOOL WIACONSTANT2TSTR(TCHAR *pszPropertyName, LONG lValue, TCHAR *pszValName)
{
    BOOL bFound = FALSE;
    if(pszValName){
        int index = 0;
        while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE) ){
            // check for property name
            if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
                // we found property name
                if(g_EditPropTable[index].lVal == lValue){
                    lstrcpy(pszValName,g_EditPropTable[index].pszValName);
                    bFound = TRUE;
                }
            }
            index++;
        }
    }
    return bFound;
}

BOOL TSTR2WIACONSTANT(TCHAR *pszPropertyName, TCHAR *pszValName, LONG *plVal)
{
    BOOL bFound = FALSE;
    if(pszValName){
        int index = 0;
        while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE)){
            // check for property name
            if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
                // we found property name
                if(lstrcmpi(g_EditPropTable[index].pszValName,pszValName) == 0){
                    *plVal = g_EditPropTable[index].lVal;
                    bFound = TRUE;
                }
            }
            index++;
        }
    }
    return bFound;
}

void RC2TSTR(UINT uResourceID, TCHAR *szString, LONG size)
{
    memset(szString,0,size);
    INT iNumTCHARSWritten = 0;

    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(!hInstance){
        MessageBox(NULL,TEXT("Could not get WIATEST's HINSTANCE for string loading."),TEXT("WIATEST Error"),MB_ICONERROR);
        return;
    }

    iNumTCHARSWritten = LoadString(hInstance,uResourceID,szString,(size / (sizeof(TCHAR))));
}

void StatusMessageBox(HWND hWnd, UINT uResourceID)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));
    StatusMessageBox(hWnd,szResourceString);
}

void StatusMessageBox(HWND hWnd, LPTSTR szStatusText)
{
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));

    // load status dialog title
    RC2TSTR(IDS_WIASTATUS_DIALOGTITLE,Title,sizeof(Title));
    MessageBox(hWnd,szStatusText,Title, MB_ICONINFORMATION);
}

void StatusMessageBox(UINT uResourceID)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));
    StatusMessageBox(szResourceString);
}

void StatusMessageBox(LPTSTR szStatusText)
{
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));

    // load status dialog title
    RC2TSTR(IDS_WIASTATUS_DIALOGTITLE,Title,sizeof(Title));
    MessageBox(NULL,szStatusText,Title, MB_ICONINFORMATION);
}

void ErrorMessageBox(UINT uResourceID, HRESULT hrError)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));
    ErrorMessageBox(szResourceString,hrError);
}

void ErrorMessageBox(LPTSTR szErrorText, HRESULT hrError)
{
    ULONG ulLen = MAX_PATH;
    TCHAR MsgBuf[MAX_PATH];
    TCHAR *pAllocMsgBuf = NULL;
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));
    memset(MsgBuf,0,sizeof(MsgBuf));

    // load error dialog title
    RC2TSTR(IDS_WIAERROR_DIALOGTITLE,Title,sizeof(Title));

    // attempt to handle WIA custom errors first
    switch (hrError) {
    case WIA_ERROR_GENERAL_ERROR:
        RC2TSTR(IDS_WIAERROR_GENERAL,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_JAM:
        RC2TSTR(IDS_WIAERROR_PAPERJAM ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_EMPTY:
        RC2TSTR(IDS_WIAERROR_PAPEREMPTY ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_PROBLEM:
        RC2TSTR(IDS_WIAERROR_PAPERPROBLEM ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_OFFLINE:
        RC2TSTR(IDS_WIAERROR_DEVICEOFFLINE ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_BUSY:
        RC2TSTR(IDS_WIAERROR_DEVICEBUSY,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_WARMING_UP:
        RC2TSTR(IDS_WIAERROR_WARMINGUP,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_USER_INTERVENTION:
        RC2TSTR(IDS_WIAERROR_USERINTERVENTION,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_ITEM_DELETED:
        RC2TSTR(IDS_WIAERROR_ITEMDELETED,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_DEVICE_COMMUNICATION:
        RC2TSTR(IDS_WIAERROR_DEVICECOMMUNICATION,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_INVALID_COMMAND:
        RC2TSTR(IDS_WIAERROR_INVALIDCOMMAND,MsgBuf,sizeof(MsgBuf));
        break;
    case S_OK:
        if(szErrorText)
            lstrcpy(MsgBuf,szErrorText);
        break;
    default:

        ulLen = 0;
        ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, hrError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPTSTR)&pAllocMsgBuf, 0, NULL);
        break;
    }

    if (ulLen <= 0) {
        // just use the HRESULT as a formatted string
        TSPRINTF(MsgBuf,TEXT("HRESULT = 0x%08X"),hrError);
    } else {
        if(pAllocMsgBuf){
            // trim right (remove \r\n from formatted string)
            pAllocMsgBuf[ulLen - (2 * sizeof(TCHAR))] = 0;  // reterminate the string
            // copy string into message buffer
            lstrcpy(MsgBuf,pAllocMsgBuf);
            // FormatMessage allocated a buffer to display
            LocalFree(pAllocMsgBuf);
        }
    }

    if(S_OK != hrError){
        TCHAR szFinalText[MAX_PATH];
        memset(szFinalText,0,sizeof(szFinalText));

#ifndef UNICODE
        TSPRINTF(szFinalText,TEXT("%s\n(%s)"),szErrorText,MsgBuf);
#else
        TSPRINTF(szFinalText,TEXT("%ws\n(%ws)"),szErrorText,MsgBuf);
#endif
        MessageBox(NULL,szFinalText,Title,MB_ICONERROR);
    } else {
        MessageBox(NULL,szErrorText,Title,MB_ICONWARNING);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp

BEGIN_MESSAGE_MAP(CWiatestApp, CWinApp)
    //{{AFX_MSG_MAP(CWiatestApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp construction

CWiatestApp::CWiatestApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWiatestApp object

CWiatestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp initialization

BOOL CWiatestApp::InitInstance()
{

    // initialize COM
    CoInitialize(NULL);

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    SetRegistryKey(_T("Microsoft"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_WIATESTYPE,
        RUNTIME_CLASS(CWiatestDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CWiatestView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

#ifdef _OPEN_NEW_DEVICE_ON_STARTUP
    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
#endif

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWiatestApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp message handlers


int CWiatestApp::ExitInstance()
{
    // uninitialize COM
    CoUninitialize();
    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatestdoc.cpp ===
// wiatestDoc.cpp : implementation of the CWiatestDoc class
//

#include "stdafx.h"
#include "wiatest.h"

#include "wiatestDoc.h"
#include "wiaselect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc

IMPLEMENT_DYNCREATE(CWiatestDoc, CDocument)

BEGIN_MESSAGE_MAP(CWiatestDoc, CDocument)
	//{{AFX_MSG_MAP(CWiatestDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc construction/destruction

CWiatestDoc::CWiatestDoc()
{
	m_pIRootItem    = NULL;
    m_pICurrentItem = NULL;
}

CWiatestDoc::~CWiatestDoc()
{
    ReleaseItems();
}

BOOL CWiatestDoc::OnNewDocument()
{
	BOOL bSuccess = FALSE;

    if (!CDocument::OnNewDocument())
		return bSuccess;
    
    // select a WIA device
    CWiaselect SelectDeviceDlg;
    if(SelectDeviceDlg.DoModal() != IDOK){
        // no device was selected, so do not create a new document
        return bSuccess;
    }

    // a WIA device was selected, so continue
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue        
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);        
        return bSuccess;
    }
    
    // create WIA device   
    hr = pIWiaDevMgr->CreateDevice(SelectDeviceDlg.m_bstrSelectedDeviceID, &m_pIRootItem);
    if(FAILED(hr)){
    
        bSuccess = FALSE;        
        // creation of device failed, so we can not continue
        ErrorMessageBox(IDS_WIATESTERROR_CREATEDEVICE,hr);
    } else {
        bSuccess = TRUE;
    }

    // release WIA device manager
    pIWiaDevMgr->Release();
    
    // set document's title to be the WIA device's name
    TCHAR szDeviceName[MAX_PATH];
    GetDeviceName(szDeviceName);
    SetTitle(szDeviceName);
    
	return bSuccess;
}



/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc serialization

void CWiatestDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc diagnostics

#ifdef _DEBUG
void CWiatestDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWiatestDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc commands

void CWiatestDoc::ReleaseItems()
{
    // is CurrentItem different from RootItem?
    if(m_pICurrentItem != m_pIRootItem){
        
        // release CurrentItem
        if(m_pICurrentItem){
            m_pICurrentItem->Release();            
        }

        // release RootItem
        if(m_pIRootItem){
            m_pIRootItem->Release();            
        }

    } else {
        // CurrentItem is the RootItem
        // release RootItem and set CurrentItem to NULL
        if(m_pIRootItem){
            m_pIRootItem->Release();            
        }
    }

    m_pIRootItem    = NULL;
    m_pICurrentItem = NULL;
}

HRESULT CWiatestDoc::GetDeviceName(LPTSTR szDeviceName)
{
    HRESULT hr = S_OK;
        
    if(NULL == m_pIRootItem){
        return E_FAIL;
    }
    
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pIRootItem);
    if(SUCCEEDED(hr)){
        hr = WIA.ReadPropertyString(WIA_DIP_DEV_NAME,szDeviceName);
    }
    
    return hr;
}

HRESULT CWiatestDoc::SetCurrentIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    if(m_pICurrentItem){
        m_pICurrentItem->Release();
        m_pICurrentItem = NULL;
    }

    // AddRef the item, becuase we are storing it
    pIWiaItem->AddRef();
    // set the current item
    m_pICurrentItem = pIWiaItem;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatestdoc.h ===
// wiatestDoc.h : interface of the CWiatestDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_)
#define AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CWiatestDoc : public CDocument
{
protected: // create from serialization only
	CWiatestDoc();
	DECLARE_DYNCREATE(CWiatestDoc)

// Attributes
public:
    IWiaItem *m_pIRootItem;     // WIA Root Item
    IWiaItem *m_pICurrentItem;  // WIA Active Item (used for property manipulation)
// Operations
public:
    void ReleaseItems();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiatestDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	HRESULT SetCurrentIWiaItem(IWiaItem *pIWiaItem);
	HRESULT GetDeviceName(LPTSTR szDeviceName);
	virtual ~CWiatestDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWiatestDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\apputil.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       AppUtil.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Misc application utilities
 *
 *****************************************************************************/
#ifndef _APPUTIL_H_
#define _APPUTIL_H_

HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                                    WCHAR         *pwszString,
                                    UINT          cchString);

HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                               TCHAR         *pszString,
                               UINT          cchString);

int AppUtil_MsgBox(UINT     uiCaption,
                   UINT     uiTextResID,
                   UINT     uiStyle,
                   ...);
                           



#endif // _APPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\imagelst.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ImageLst.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Handles WIA side of things
 *
 *****************************************************************************/
#ifndef _IMAGELST_H_
#define _IMAGELST_H_

HRESULT ImageLst_PostAddImageRequest(BSTR bstrNewImage);
HRESULT ImageLst_AddImageToList(BSTR bstrNewImage);
HRESULT ImageLst_PopulateWiaItemList(IGlobalInterfaceTable *pGIT,
                                     DWORD                 dwCookie);
HRESULT ImageLst_PopulateDShowItemList(const TCHAR *pszImagesDirectory);
HRESULT ImageLst_Clear();
HRESULT ImageLst_CancelLoadAndWait(DWORD dwTimeout);



#endif // _IMAGELST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatestview.h ===
// wiatestView.h : interface of the CWiatestView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_)
#define AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaitemlistctrl.h"
#include "wiaacquiredlg.h"
#include "wiaeventcallback.h"

#define MIN_BUFFER_FACTOR 4
#define BMPFILE_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#define NUMSYSTEMTIME_COLONS 7
#define MIN_CLIENT_WINDOW_WIDTH 580

////////////////////////////////////////////////////////////
// from sti.h
#define GET_STIDEVICE_TYPE(dwDevType)    HIWORD(dwDevType)
#define GET_STIDEVICE_SUBTYPE(dwDevType) LOWORD(dwDevType)

#define StiDeviceTypeDefault        0
#define StiDeviceTypeScanner        1
#define StiDeviceTypeDigitalCamera  2
#define StiDeviceTypeStreamingVideo 3

//
////////////////////////////////////////////////////////////

class CWiatestView : public CFormView
{
protected: // create from serialization only
    CWiatestView();
    DECLARE_DYNCREATE(CWiatestView)

public:
    //{{AFX_DATA(CWiatestView)
	enum { IDD = IDD_WIATEST_FORM };
	CListBox	m_SupportedTymedAndFormatsListBox;    
    CStatic m_ThumbnailPreviewWindow;    
    CWiaitemListCtrl    m_ItemPropertiesListCtrl;
    CTreeCtrl   m_ItemTreeCtrl;
	//}}AFX_DATA

// Attributes
public:
    CWiatestDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiatestView)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnInitialUpdate(); // called first time after construct
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    BOOL m_bHasDocumentFeeder;
    LONG m_lDeviceType;
    
    // Event helpers
    void RegisterForEvents();
    CWiaEventCallback m_WiaEventCallback;

    // Thumbnailing helpers
    HBITMAP m_hThumbNailBitmap;    
    void DisplayThumbnail(IWiaItem *pIWiaItem);
    void DisplayMissingThumbnail();

    // User interface
    void AdjustViewForDeviceType();
    void SetCurrentSelectionForTYMEDAndFormat();    
    
    void AddSupportedTYMEDAndFormatsToListBox(IWiaItem *pIWiaItem);    
    void AddWiaItemPropertiesToListControl(IWiaItem *pIWiaItem);
    void AddWiaItemsToTreeControl(HTREEITEM hParent, IWiaItem *pIWiaItem);
    
    // converison helpers
    void FORMAT2TSTR(GUID guidFormat, TCHAR* pszFormat);
    void VT2TSTR(TCHAR *pszText,ULONG VarType);
    void AccessFlags2TSTR(TCHAR *pszText,ULONG AccessFlags);
    void PROPVAR2TSTR(PROPVARIANT *pPropVar,TCHAR *szValue);
    void TSTR2PROPVAR(TCHAR *szValue, PROPVARIANT *pPropVar);

    // data acquisition helpers
    void RenameTempDataTransferFilesAndLaunchViewer(TCHAR *szFileName, GUID guidFormat, LONG lTymed);   
    void RenameTempDataTransferFilesAndLaunchViewer(GUID guidFormat, LONG lTymed);
    void DeleteTempDataTransferFiles(); 
    ULONG ReadMinBufferSizeProperty(IWiaItem *pIWiaItem);
    HRESULT TransferToMemory(TCHAR *szFileName, IWiaItem *pIWiaItem);
    HRESULT TransferToFile(TCHAR *szFileName, IWiaItem *pIWiaItem);
    LONG CalculateWidthBytes(LONG lWidthPixels, LONG lbpp);

    // debugging helpers    
    BOOL m_bOutputToDebuggerON;         
                
    virtual ~CWiatestView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CWiatestView)
    afx_msg void OnSelchangedItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDblclkItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);    
    afx_msg void OnAcquireimage();
    afx_msg void OnLoadWiapropertystream();
    afx_msg void OnSaveWiapropertystream();
    afx_msg void OnRclickItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnPropertyeditpopupmenuEditpropertyvalue();
    afx_msg void OnViewCapabilities();
    afx_msg void OnRclickItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult);    
    afx_msg void OnDeleteItem();
    afx_msg void OnAcquireimageCommonui();
    afx_msg void OnEditDebugout();
    afx_msg void OnUpdateEditDebugout(CCmdUI* pCmdUI);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnDocumentAcquisitionSettings();
    afx_msg void OnUpdateDocumentAcquisitionSettings(CCmdUI* pCmdUI);
	afx_msg void OnSelchangeSupportedTymedAndFormatListbox();
	afx_msg void OnThumbnailPreview();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wiatestView.cpp
inline CWiatestDoc* CWiatestView::GetDocument()
   { return (CWiatestDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiatest2\wiatestview.cpp ===
// wiatestView.cpp : implementation of the CWiatestView class
//

#include "stdafx.h"
#include "wiatest.h"

#include "wiatestDoc.h"
#include "wiatestView.h"
#include "wiaeditpropdlg.h"
#include "wiacapdlg.h"
#include "wiaacquiredlg.h"
#include "wiadatacallback.h"

#include "wiadocacqsettings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiatestView

IMPLEMENT_DYNCREATE(CWiatestView, CFormView)

BEGIN_MESSAGE_MAP(CWiatestView, CFormView)
    //{{AFX_MSG_MAP(CWiatestView)
    ON_NOTIFY(TVN_SELCHANGED, IDC_ITEM_TREECTRL, OnSelchangedItemTreectrl)
    ON_WM_SIZE()
    ON_NOTIFY(NM_DBLCLK, IDC_ITEMPROPERTIES_LISTCTRL, OnDblclkItempropertiesListctrl)
    ON_COMMAND(IDM_ACQUIREIMAGE, OnAcquireimage)
    ON_COMMAND(IDM_LOAD_WIAPROPERTYSTREAM, OnLoadWiapropertystream)
    ON_COMMAND(IDM_SAVE_WIAPROPERTYSTREAM, OnSaveWiapropertystream)
    ON_NOTIFY(NM_RCLICK, IDC_ITEMPROPERTIES_LISTCTRL, OnRclickItempropertiesListctrl)
    ON_COMMAND(ID_PROPERTYEDITPOPUPMENU_EDITPROPERTYVALUE, OnPropertyeditpopupmenuEditpropertyvalue)
    ON_COMMAND(IDM_VIEW_CAPABILITIES, OnViewCapabilities)
    ON_NOTIFY(NM_RCLICK, IDC_ITEM_TREECTRL, OnRclickItemTreectrl)
    ON_COMMAND(IDM_DELETE_ITEM, OnDeleteItem)
    ON_COMMAND(IDM_ACQUIREIMAGE_COMMONUI, OnAcquireimageCommonui)
    ON_COMMAND(IDM_EDIT_DEBUGOUT, OnEditDebugout)
    ON_UPDATE_COMMAND_UI(IDM_EDIT_DEBUGOUT, OnUpdateEditDebugout)
    ON_WM_SHOWWINDOW()
    ON_COMMAND(IDM_DOCUMENT_ACQUISITION_SETTINGS, OnDocumentAcquisitionSettings)
    ON_UPDATE_COMMAND_UI(IDM_DOCUMENT_ACQUISITION_SETTINGS, OnUpdateDocumentAcquisitionSettings)
    ON_LBN_SELCHANGE(IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX, OnSelchangeSupportedTymedAndFormatListbox)
    ON_BN_CLICKED(IDC_THUMBNAIL_PREVIEW, OnThumbnailPreview)
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestView construction/destruction

CWiatestView::CWiatestView()
    : CFormView(CWiatestView::IDD)
{
    m_bOutputToDebuggerON = FALSE;
    m_hThumbNailBitmap = NULL;
    m_bHasDocumentFeeder = FALSE;
    //{{AFX_DATA_INIT(CWiatestView)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // TODO: add construction code here

}

CWiatestView::~CWiatestView()
{
}

void CWiatestView::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiatestView)
    DDX_Control(pDX, IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX, m_SupportedTymedAndFormatsListBox);
    DDX_Control(pDX, IDC_THUMBNAIL_PREVIEW, m_ThumbnailPreviewWindow);
    DDX_Control(pDX, IDC_ITEMPROPERTIES_LISTCTRL, m_ItemPropertiesListCtrl);
    DDX_Control(pDX, IDC_ITEM_TREECTRL, m_ItemTreeCtrl);
    //}}AFX_DATA_MAP
}

BOOL CWiatestView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CFormView::PreCreateWindow(cs);
}

void CWiatestView::OnInitialUpdate()
{
    CFormView::OnInitialUpdate();
    GetParentFrame()->RecalcLayout();
    ResizeParentToFit(FALSE);

    // get associated document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        // initialize item tree control
        AddWiaItemsToTreeControl(TVI_ROOT, pDocument->m_pIRootItem);
        // initialize property list control
        m_ItemPropertiesListCtrl.SetupColumnHeaders();
        // initialize supported TYMED and formats list box
        AddSupportedTYMEDAndFormatsToListBox(pDocument->m_pIRootItem);
        // initialize device type specifics for UI
        AdjustViewForDeviceType();
        // register for events
        RegisterForEvents();
        // maximize window
        CWnd* Parent = GetParent();
        Parent->ShowWindow(SW_SHOWMAXIMIZED);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestView printing

BOOL CWiatestView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CWiatestView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CWiatestView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

void CWiatestView::OnPrint(CDC* pDC, CPrintInfo* /*pInfo*/)
{
    // TODO: add customized printing code here
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestView diagnostics

#ifdef _DEBUG
void CWiatestView::AssertValid() const
{
    CFormView::AssertValid();
}

void CWiatestView::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}

CWiatestDoc* CWiatestView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWiatestDoc)));
    return (CWiatestDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWiatestView message handlers

void CWiatestView::AddWiaItemsToTreeControl(HTREEITEM hParent, IWiaItem *pIWiaItem)
{
    if(hParent == TVI_ROOT){
        // delete any old items in tree
        m_ItemTreeCtrl.DeleteAllItems();
    }

    TV_INSERTSTRUCT tv;
    HRESULT hr = S_OK;
    IEnumWiaItem* pIEnumWiaItem = NULL;
    LONG lItemType              = 0;
    HTREEITEM hNewParent = NULL;
    TCHAR szItemName[MAX_PATH];
    CWiahelper WIA;
    memset(szItemName,0,sizeof(szItemName));

    tv.hParent              = hParent;
    tv.hInsertAfter         = TVI_LAST;
    tv.item.mask            = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tv.item.hItem           = NULL;
    tv.item.state           = TVIS_EXPANDED;
    tv.item.stateMask       = TVIS_STATEIMAGEMASK;
    tv.item.cchTextMax      = 6;
    tv.item.cChildren       = 0;
    tv.item.lParam          = 0;

    // get item's full name
    WIA.SetIWiaItem(pIWiaItem);
    WIA.ReadPropertyString(WIA_IPA_FULL_ITEM_NAME,szItemName);
    tv.item.pszText = szItemName;

    // insert item into tree
    hNewParent = m_ItemTreeCtrl.InsertItem(&tv);

    // check item type to see if it is a parent
    hr = pIWiaItem->GetItemType(&lItemType);
    if(SUCCEEDED(hr)){
        if(lItemType & (WiaItemTypeFolder | WiaItemTypeHasAttachments)){
            // we have a potential parent
            hr = pIWiaItem->EnumChildItems(&pIEnumWiaItem);
            if(S_OK == hr){
                ULONG ulFetched = 0;
                IWiaItem *pFoundIWiaItem = NULL;
                // we have a parent with children
                hr = pIEnumWiaItem->Next(1,&pFoundIWiaItem,&ulFetched);
                while(S_OK == hr){
                    // add item to tree
                    AddWiaItemsToTreeControl(hNewParent,pFoundIWiaItem);
                    // release enumerated item
                    pFoundIWiaItem->Release();
                    hr = pIEnumWiaItem->Next(1,&pFoundIWiaItem,&ulFetched);
                }
            }
        }
    }
}

void CWiatestView::OnSelchangedItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    HTREEITEM hTreeItem = NULL;
    hTreeItem = m_ItemTreeCtrl.GetSelectedItem();
    if(hTreeItem){
        CString cszItemName = m_ItemTreeCtrl.GetItemText(hTreeItem);
        if(cszItemName.GetLength() > 0){
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                BSTR bstrFullItemName = NULL;
                bstrFullItemName = cszItemName.AllocSysString();
                if(bstrFullItemName){
                    HRESULT hr = S_OK;
                    IWiaItem *pFoundIWiaItem = NULL;
                    hr = pDocument->m_pIRootItem->FindItemByName(0,bstrFullItemName,&pFoundIWiaItem);
                    if(SUCCEEDED(hr)){
                        if(NULL != pFoundIWiaItem){
                            hr = pDocument->SetCurrentIWiaItem(pFoundIWiaItem);
                            if(SUCCEEDED(hr)){
                                // update list control with properties of the selected (found) item
                                AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                                // update valid TYMED/Formats listbox selections
                                AddSupportedTYMEDAndFormatsToListBox(pDocument->m_pICurrentItem);
                                // disable supported TYMED and format selection if the item selected
                                // is a root item.
                                if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
                                    m_SupportedTymedAndFormatsListBox.SetCurSel(-1);
                                    m_SupportedTymedAndFormatsListBox.EnableWindow(FALSE);
                                } else {
                                    m_SupportedTymedAndFormatsListBox.EnableWindow(TRUE);
                                    // set current selection for TYMED and format listbox
                                    SetCurrentSelectionForTYMEDAndFormat();
                                }
                                // display thumbnail if one exists
                                DisplayThumbnail(pDocument->m_pICurrentItem);
                                // release IWiaItem
                                pFoundIWiaItem->Release();
                                pFoundIWiaItem = NULL;
                            }
                        } else {
                            ErrorMessageBox(IDS_WIATESTERROR_ITEMNOTFOUND,hr);
                        }
                    } else {
                        ErrorMessageBox(IDS_WIATESTERROR_ITEMNOTFOUND,hr);
                    }
                    SysFreeString(bstrFullItemName);
                    bstrFullItemName = NULL;
                }
            }
        }
    }
    *pResult = 0;
}

void CWiatestView::AddWiaItemPropertiesToListControl(IWiaItem *pIWiaItem)
{
    // erase any old properties
    m_ItemPropertiesListCtrl.DeleteAllItems();
    // insert new properties
    HRESULT hr = S_OK;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    INT ItemNumber = 0;

    hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if(hr == S_OK) {
        IEnumSTATPROPSTG  *pIPropEnum = NULL;
        hr = pIWiaPropStg->Enum(&pIPropEnum);
        if(hr == S_OK) {
            STATPROPSTG StatPropStg;
            memset(&StatPropStg,0,sizeof(StatPropStg));
            do {
                hr = pIPropEnum->Next(1,&StatPropStg,NULL);
                if (hr == S_OK) {
                    if (StatPropStg.lpwstrName != NULL) {
                        // read property value
                        PROPSPEC        PropSpec;
                        PROPVARIANT     PropVar;

                        PropSpec.ulKind = PRSPEC_PROPID;
                        PropSpec.propid = StatPropStg.propid;

                        hr = pIWiaPropStg->ReadMultiple(1,&PropSpec,&PropVar);
                        if (hr == S_OK) {

                            TCHAR  szPropName[MAX_PATH];
                            memset(szPropName,0,sizeof(szPropName));
                            TCHAR  szValue[MAX_PATH];
                            memset(szValue,0,sizeof(szValue));
                            TCHAR  szText[MAX_PATH];
                            memset(szText,0,sizeof(szText));

                            LV_ITEM         lvitem;

                            lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
                            lvitem.iItem    = ItemNumber;
                            lvitem.iSubItem = 0;
                            lvitem.pszText  = szText;
                            lvitem.iImage   = NULL;
                            lvitem.lParam   = StatPropStg.propid;

                            // Write property name to list control
                            if (WideCharToMultiByte(CP_ACP, 0,StatPropStg.lpwstrName,-1,
                                                    szPropName, MAX_PATH,NULL,NULL) > 0) {
                                lstrcpy(szText,szPropName);

                                // insert name into list control
                                m_ItemPropertiesListCtrl.InsertItem(&lvitem);

                                // move to next column for setting the value
                                lvitem.mask     = LVIF_TEXT;
                                lvitem.iSubItem = 1;
                            } else {
                                lstrcpy(szPropName,TEXT("<MISSING NAME>"));
                            }

                            // Write property value to list control
                            PROPVAR2TSTR(&PropVar,szText);
                            m_ItemPropertiesListCtrl.SetItem(&lvitem);

                            // display access flags and var type
                            ULONG AccessFlags = 0;
                            ULONG VarType     = 0;
                            PROPVARIANT AttrPropVar; // not used at this time
                            hr = pIWiaPropStg->GetPropertyAttributes(1, &PropSpec,&AccessFlags,&AttrPropVar);
                            if (hr != S_OK) {
                                hr = S_OK; // do this to continue property traversal
                            } else {
                                // display access flags
                                lvitem.mask     = LVIF_TEXT;
                                lvitem.iSubItem = 3;
                                memset(lvitem.pszText,0,sizeof(szText));
                                AccessFlags2TSTR(lvitem.pszText,AccessFlags);
                                m_ItemPropertiesListCtrl.SetItem(&lvitem);
                            }

                            // display var type
                            lvitem.mask     = LVIF_TEXT;
                            lvitem.iSubItem = 2;

                            VT2TSTR(lvitem.pszText,PropVar.vt);
                            m_ItemPropertiesListCtrl.SetItem(&lvitem);

                            // increment Row counter
                            ItemNumber++;
                        }
                    } else {

                    }
                }

                // clean up property name
                CoTaskMemFree(StatPropStg.lpwstrName);
            } while (hr == S_OK);
            pIPropEnum->Release();
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_ENUMERATE_PROPERTIES,hr);
        }
        pIWiaPropStg->Release();
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_WIAPROPERTYSTORAGE,hr);
    }

    // auto resize columns
    for (int Col = 0; Col <4;Col++){
        m_ItemPropertiesListCtrl.SetColumnWidth(Col, LVSCW_AUTOSIZE);
    }
}

void CWiatestView::VT2TSTR(TCHAR *pszText,ULONG VarType)
{
    if (pszText == NULL)
        return;
    switch (VarType) {
    case VT_EMPTY:              // nothing
        lstrcpy(pszText,TEXT("VT_EMPTY"));
        break;
    case VT_NULL:               // SQL style Null
        lstrcpy(pszText,TEXT("VT_NULL"));
        break;
    case VT_I2:                 // 2 byte signed int
        lstrcpy(pszText,TEXT("VT_I2"));
        break;
    case VT_I4:                 // 4 byte signed int
        lstrcpy(pszText,TEXT("VT_I4"));
        break;
    case VT_R4:                 // 4 byte real
        lstrcpy(pszText,TEXT("VT_R4"));
        break;
    case VT_R8:                 // 8 byte real
        lstrcpy(pszText,TEXT("VT_R8"));
        break;
    case VT_CY:                 // currency
        lstrcpy(pszText,TEXT("VT_CY"));
        break;
    case VT_DATE:               // date
        lstrcpy(pszText,TEXT("VT_DATE"));
        break;
    case VT_BSTR:               // OLE Automation string
        lstrcpy(pszText,TEXT("VT_BSTR"));
        break;
    case VT_DISPATCH:           // IDispatch *
        lstrcpy(pszText,TEXT("VT_DISPATCH"));
        break;
    case VT_ERROR:              // SCODE
        lstrcpy(pszText,TEXT("VT_ERROR"));
        break;
    case VT_BOOL:               // True=-1, False=0
        lstrcpy(pszText,TEXT("VT_BOOL"));
        break;
    case VT_VARIANT:            // VARIANT *
        lstrcpy(pszText,TEXT("VT_VARIANT"));
        break;
    case VT_UNKNOWN:            // IUnknown *
        lstrcpy(pszText,TEXT("VT_UNKNOWN"));
        break;
    case VT_DECIMAL:            // 16 byte fixed point
        lstrcpy(pszText,TEXT("VT_DECIMAL"));
        break;
    case VT_RECORD:             // user defined type
        lstrcpy(pszText,TEXT("VT_RECORD"));
        break;
    case VT_I1:                 // signed char
        lstrcpy(pszText,TEXT("VT_I1"));
        break;
    case VT_UI1:                // unsigned char
        lstrcpy(pszText,TEXT("VT_UI1"));
        break;
    case VT_UI2:                // unsigned short
        lstrcpy(pszText,TEXT("VT_UI2"));
        break;
    case VT_UI4:                // unsigned short
        lstrcpy(pszText,TEXT("VT_UI4"));
        break;
    case VT_I8:                 // signed 64-bit int
        lstrcpy(pszText,TEXT("VT_I8"));
        break;
    case VT_UI8:                // unsigned 64-bit int
        lstrcpy(pszText,TEXT("VT_UI8"));
        break;
    case VT_INT:                // signed machine int
        lstrcpy(pszText,TEXT("VT_INT"));
        break;
    case VT_UINT:               // unsigned machine int
        lstrcpy(pszText,TEXT("VT_UINT"));
        break;
    case VT_VOID:               // C style void
        lstrcpy(pszText,TEXT("VT_VOID"));
        break;
    case VT_HRESULT:            // Standard return type
        lstrcpy(pszText,TEXT("VT_HRESULT"));
        break;
    case VT_PTR:                // pointer type
        lstrcpy(pszText,TEXT("VT_PTR"));
        break;
    case VT_SAFEARRAY:          // (use VT_ARRAY in VARIANT)
        lstrcpy(pszText,TEXT("VT_SAFEARRAY"));
        break;
    case VT_CARRAY:             // C style array
        lstrcpy(pszText,TEXT("VT_CARRAY"));
        break;
    case VT_USERDEFINED:        // user defined type
        lstrcpy(pszText,TEXT("VT_USERDEFINED"));
        break;
    case VT_LPSTR:              // null terminated string
        lstrcpy(pszText,TEXT("VT_LPSTR"));
        break;
    case VT_LPWSTR:             // wide null terminated string
        lstrcpy(pszText,TEXT("VT_LPWSTR"));
        break;
    case VT_FILETIME:           // FILETIME
        lstrcpy(pszText,TEXT("VT_FILETIME"));
        break;
    case VT_BLOB:               // Length prefixed bytes
        lstrcpy(pszText,TEXT("VT_BLOB"));
        break;
    case VT_STREAM:             // Name of the stream follows
        lstrcpy(pszText,TEXT("VT_STREAM"));
        break;
    case VT_STORAGE:            // Name of the storage follows
        lstrcpy(pszText,TEXT("VT_STORAGE"));
        break;
    case VT_STREAMED_OBJECT:    // Stream contains an object
        lstrcpy(pszText,TEXT("VT_STREAMED_OBJECT"));
        break;
    case VT_STORED_OBJECT:      // Storage contains an object
        lstrcpy(pszText,TEXT("VT_STORED_OBJECT"));
        break;
    case VT_VERSIONED_STREAM:   // Stream with a GUID version
        lstrcpy(pszText,TEXT("VT_VERSIONED_STREAM"));
        break;
    case VT_BLOB_OBJECT:        // Blob contains an object
        lstrcpy(pszText,TEXT("VT_BLOB_OBJECT"));
        break;
    case VT_CF:                 // Clipboard format
        lstrcpy(pszText,TEXT("VT_CF"));
        break;
    case VT_CLSID:              // A Class ID
        lstrcpy(pszText,TEXT("VT_CLSID"));
        break;
    case VT_VECTOR:             // simple counted array
        lstrcpy(pszText,TEXT("VT_VECTOR"));
        break;
    case VT_ARRAY:              // SAFEARRAY*
        lstrcpy(pszText,TEXT("VT_ARRAY"));
        break;
    case VT_BYREF:              // void* for local use
        lstrcpy(pszText,TEXT("VT_BYREF"));
        break;
    case VT_BSTR_BLOB:          // Reserved for system use
        lstrcpy(pszText,TEXT("VT_BSTR_BLOB"));
        break;
    case VT_VECTOR|VT_I4:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_I4"));
        break;
    case VT_VECTOR | VT_UI1:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI1"));
        break;
    case VT_VECTOR | VT_UI2:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI2"));
        break;
    case VT_VECTOR | VT_UI4:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI4"));
        break;
    default:                    // unknown type detected!!
        lstrcpy(pszText,TEXT("VT_UNKNOWNTYPE"));
        break;
    }
}

void CWiatestView::AccessFlags2TSTR(TCHAR *pszText,ULONG AccessFlags)
{
    if (pszText == NULL)
        return;

    if ((AccessFlags & WIA_PROP_READ) == WIA_PROP_READ){
        lstrcat(pszText,TEXT("WIA_PROP_READ | "));
    }

    if ((AccessFlags & WIA_PROP_WRITE) == WIA_PROP_WRITE){
        lstrcat(pszText,TEXT("WIA_PROP_WRITE | "));
    }

    if (lstrcmp(pszText,TEXT("WIA_PROP_READ | WIA_PROP_WRITE | ")) == 0){
        lstrcpy(pszText,TEXT("WIA_PROP_RW | "));
    }

    if ((AccessFlags & WIA_PROP_NONE) == WIA_PROP_NONE){
        lstrcat(pszText,TEXT("WIA_PROP_NONE | "));
    }

    if ((AccessFlags & WIA_PROP_RANGE) == WIA_PROP_RANGE){
        lstrcat(pszText,TEXT("WIA_PROP_RANGE | "));
    }

    if ((AccessFlags & WIA_PROP_LIST) == WIA_PROP_LIST){
        lstrcat(pszText,TEXT("WIA_PROP_LIST | "));
    }

    if ((AccessFlags & WIA_PROP_FLAG) == WIA_PROP_FLAG){
        lstrcat(pszText,TEXT("WIA_PROP_FLAG | "));
    }

    LONG lLen = 0;
    lLen = lstrlen(pszText);

    // check for unknown access flags
    if (lLen == 0){
        TSPRINTF(pszText,TEXT("WIA_PROP_UNKNOWN = %d "),AccessFlags);
        return;
    }

    pszText[lLen - (2 * sizeof(TCHAR))] = 0;
}

void CWiatestView::PROPVAR2TSTR(PROPVARIANT *pPropVar,TCHAR *szValue)
{
    SYSTEMTIME *pSystemTime = NULL;
    switch (pPropVar->vt) {
    case VT_I1:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->cVal);
        break;
    case VT_UI1:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->bVal);
        break;
    case VT_I2:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->iVal);
        break;
    case VT_UI2:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->uiVal);
        break;
    case VT_UI4:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->ulVal);
        break;
    case VT_UI8:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    case VT_INT:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->intVal);
        break;
    case VT_I4:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    case VT_R4:
        TSPRINTF(szValue,TEXT("%2.5f"),pPropVar->fltVal);
        break;
    case VT_R8:
        TSPRINTF(szValue,TEXT("%2.5f"),pPropVar->dblVal);
        break;
    case VT_BSTR:
#ifndef UNICODE
        WideCharToMultiByte(CP_ACP, 0,pPropVar->bstrVal, -1, szValue, MAX_PATH,NULL,NULL);
#else
        TSPRINTF(szValue,TEXT("%ws"),pPropVar->bstrVal);
#endif
        break;
    case VT_LPWSTR:
        {
            //TSPRINTF(szValue,TEXT("%ws"),pPropVar->pwszVal);
            CString TempString = pPropVar->pwszVal;
            lstrcpy(szValue,TempString);
        }
        break;
    case VT_UINT:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->uintVal);
        break;
    case VT_CLSID:
        {
            UCHAR *pwszUUID = NULL;
            long lErrorCode = UuidToString(pPropVar->puuid,&pwszUUID);
            if(NULL != pwszUUID){
                //TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                lstrcpy(szValue,(LPCTSTR)pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
            }
        }
        break;
    case VT_VECTOR | VT_UI2:
        pSystemTime = (SYSTEMTIME*)pPropVar->caui.pElems;
        if(NULL != pSystemTime){
        // ( YYYY:MM:W:DD:HH:MM:SS:ms )
        TSPRINTF(szValue,TEXT("%d:%d:%d:%d:%d:%d:%d:%d"),pSystemTime->wYear,
                                                         pSystemTime->wMonth,
                                                         pSystemTime->wDay,
                                                         pSystemTime->wDayOfWeek,
                                                         pSystemTime->wHour,
                                                         pSystemTime->wMinute,
                                                         pSystemTime->wSecond,
                                                         pSystemTime->wMilliseconds);
        }
        break;
    default:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    }
}

void CWiatestView::TSTR2PROPVAR(TCHAR *szValue, PROPVARIANT *pPropVar)
{
    WCHAR wszbuffer[MAX_PATH];
    CHAR szbuffer[MAX_PATH];
    memset(wszbuffer,0,sizeof(wszbuffer));
    memset(szbuffer,0,sizeof(szbuffer));
    int iErrorCode = 0;
    long lErrorCode = 0;
    switch (pPropVar->vt) {
    case VT_I1:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->cVal);
        break;
    case VT_I2:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->bVal);
        break;
    case VT_I4:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->lVal);
        break;
    case VT_I8:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->hVal);
        break;
    case VT_UI1:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->bVal);
        break;
    case VT_UI2:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->uiVal);
        break;
    case VT_UI4:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->ulVal);
        break;
    case VT_UI8:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->lVal);
        break;
    case VT_INT:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->intVal);
        break;
    case VT_R4:
        iErrorCode = TSSCANF(szValue,TEXT("%f"),&pPropVar->fltVal);
        break;
    case VT_R8:
        iErrorCode = TSSCANF(szValue,TEXT("%f"),&pPropVar->fltVal);
        break;
    case VT_BSTR:
#ifndef UNICODE
        MultiByteToWideChar(CP_ACP, 0,szValue,-1,wszbuffer,MAX_PATH);
        pPropVar->bstrVal = SysAllocString(wszbuffer);
#else
        pPropVar->bstrVal = SysAllocString(szValue);
#endif
        break;
    case VT_CLSID:
#ifndef UNICODE
        pPropVar->puuid = (GUID*)CoTaskMemAlloc(sizeof(UUID));
        lErrorCode = UuidFromString((UCHAR*)szValue,pPropVar->puuid);
#else
        pPropVar->puuid = CoTaskMemAlloc(sizeof(UUID));
        WideCharToMultiByte(CP_ACP, 0,szValue,-1,szbuffer,MAX_PATH,NULL,NULL);
        UuidFromString((UCHAR*)szbuffer,pPropVar->puuid);
#endif
        break;
    case VT_UINT:
        iErrorCode = TSSCANF(szValue,TEXT("%li"),&pPropVar->uintVal);
        break;
    case VT_VECTOR | VT_UI2:
        {
            TCHAR *psz = NULL;
            // is this a SYSTEMTIME formatted string?
            psz = TSTRSTR(szValue,TEXT(":"));
            if(NULL != psz){
                SYSTEMTIME *pSystemTime = NULL;
                pSystemTime = (SYSTEMTIME*)CoTaskMemAlloc(sizeof(SYSTEMTIME));
                if(pSystemTime){
                    memset(pSystemTime,0,sizeof(SYSTEMTIME));
                    // fill out SYSTEMTIME structure
                    iErrorCode = TSSCANF(szValue,TEXT("%hd:%hd:%hd:%hd:%hd:%hd:%hd:%hd"),&pSystemTime->wYear,
                                                                            &pSystemTime->wMonth,
                                                                            &pSystemTime->wDay,
                                                                            &pSystemTime->wDayOfWeek,
                                                                            &pSystemTime->wHour,
                                                                            &pSystemTime->wMinute,
                                                                            &pSystemTime->wSecond,
                                                                            &pSystemTime->wMilliseconds);
                    // set count
                    pPropVar->caui.cElems = (sizeof(SYSTEMTIME) / sizeof(WORD));
                    // set pointer (array of WORD values)
                    pPropVar->caui.pElems = (WORD*)pSystemTime;
                }
            }
        }
        break;
    default:
        iErrorCode = TSSCANF(szValue,"%li",&pPropVar->lVal);
        break;
    }
}

void CWiatestView::OnSize(UINT nType, int cx, int cy)
{
    CFormView::OnSize(nType, cx, cy);

    CRect ParentWindowRect;
    LONG lOffset = 0;
    // get parent window rect
    GetWindowRect(ParentWindowRect);
    ScreenToClient(ParentWindowRect);

    // resize property list control
    if(NULL != m_ItemPropertiesListCtrl.m_hWnd){
        CRect ListBoxRect;

        // get list control rect
        m_ItemPropertiesListCtrl.GetWindowRect(ListBoxRect);
        ScreenToClient(ListBoxRect);

        // adjust width

        ListBoxRect.right  = ParentWindowRect.right - 10;
        lOffset = ListBoxRect.right;

        // adjust height
        ListBoxRect.bottom = ParentWindowRect.bottom - 10;
        m_ItemPropertiesListCtrl.MoveWindow(ListBoxRect);
    }

    if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeDigitalCamera){

        // move thumbnail control
        if(NULL != m_ThumbnailPreviewWindow.m_hWnd){
            CRect ThumbnailRect;

            // get thumbnail rect
            m_ThumbnailPreviewWindow.GetWindowRect(ThumbnailRect);
            ScreenToClient(ThumbnailRect);

            // adjust position
            INT iWidth = ThumbnailRect.Width();
            ThumbnailRect.right = lOffset;
            ThumbnailRect.left  = (ThumbnailRect.right - iWidth);

            m_ThumbnailPreviewWindow.MoveWindow(ThumbnailRect);
        }

        // resize supported TYMED and Format listbox
        if(NULL != m_SupportedTymedAndFormatsListBox.m_hWnd){
            CRect ListBoxRect;
            CRect ThumbnailRect;

            // get list box rect
            m_SupportedTymedAndFormatsListBox.GetWindowRect(ListBoxRect);
            ScreenToClient(ListBoxRect);

            // get thumbnail rect
            m_ThumbnailPreviewWindow.GetWindowRect(ThumbnailRect);
            ScreenToClient(ThumbnailRect);

            // adjust width
            ListBoxRect.right  = ThumbnailRect.left - 10;

            m_SupportedTymedAndFormatsListBox.MoveWindow(ListBoxRect);
        }

    } else {
        // resize supported TYMED listbox
        if(NULL != m_SupportedTymedAndFormatsListBox.m_hWnd){
            CRect ListBoxRect;
            CRect ThumbnailRect;

            // get list box rect
            m_SupportedTymedAndFormatsListBox.GetWindowRect(ListBoxRect);
            ScreenToClient(ListBoxRect);

            // adjust width
            ListBoxRect.right  = lOffset;

            m_SupportedTymedAndFormatsListBox.MoveWindow(ListBoxRect);
        }
    }
}

void CWiatestView::OnDblclkItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    // find out what property is selected
    HD_NOTIFY*  phdn = (HD_NOTIFY *) pNMHDR;
    TCHAR pszPropertyName[MAX_PATH];
    memset(pszPropertyName,0,sizeof(pszPropertyName));
    TCHAR pszPropertyValue[MAX_PATH];
    memset(pszPropertyValue,0,sizeof(pszPropertyValue));

    LV_ITEM lvitem;
    lvitem.mask     = LVIF_PARAM;
    lvitem.iItem    = phdn->iItem;
    lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
    lvitem.pszText  = NULL;

    // is an item selected?
    if (phdn->iItem < ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME)
        return;

    m_ItemPropertiesListCtrl.GetItem(&lvitem);
    // get stored property ID
    LONG iProp = 0;
    iProp = (LONG)lvitem.lParam;

    m_ItemPropertiesListCtrl.GetItemText(phdn->iItem,
                                         ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,
                                         pszPropertyName,
                                         sizeof(pszPropertyName));

    m_ItemPropertiesListCtrl.GetItemText(phdn->iItem,
                                         ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
                                         pszPropertyValue,
                                         sizeof(pszPropertyValue));

    // get document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        IWiaPropertyStorage *pIWiaPropStg = NULL;
        HRESULT hr = S_OK;
        hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if(SUCCEEDED(hr)) {
            // read property value for type and current value
            PROPVARIANT PropVar[1];
            PROPVARIANT AttrPropVar[1];
            PROPSPEC PropSpec[1];
            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = iProp;

            ULONG ulAttributes = 0;
            CWiaeditpropDlg PropertyEditDlg;
            hr = pIWiaPropStg->ReadMultiple(1,PropSpec,PropVar);
            if (S_OK == hr) {
                PropertyEditDlg.SetVarType(PropVar[0].vt);
                // clear variant
                PropVariantClear(PropVar);
                hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec,&ulAttributes,AttrPropVar);
                if(S_OK == hr){
                    PropertyEditDlg.SetAttributes(ulAttributes, (PROPVARIANT*)AttrPropVar);
                    BOOL bRefreshCurrentTYMEDAndFormatSelection = FALSE;
                    if((lstrcmp(pszPropertyName,TEXT("Format")) == 0) || (lstrcmp(pszPropertyName,TEXT("Media Type")) == 0)){
                        bRefreshCurrentTYMEDAndFormatSelection = TRUE;
                    }
                    if(PropertyEditDlg.DoModal(pszPropertyName,pszPropertyValue) == IDOK){
                        memset(pszPropertyValue,0,sizeof(pszPropertyValue));
                        PropertyEditDlg.GetPropertyValue(pszPropertyValue);
                        PropVar[0].vt = PropertyEditDlg.GetVarType();
                        TSTR2PROPVAR(pszPropertyValue,(PROPVARIANT*)PropVar);
                        hr = pIWiaPropStg->WriteMultiple(1,PropSpec,PropVar,MIN_PROPID);
                        if(S_OK == hr){
                            // get current document, and refresh the property list with the current
                            // selected item
                            CWiatestDoc* pCurrentDocument = NULL;
                            pCurrentDocument = (CWiatestDoc*)m_pDocument;
                            if(pCurrentDocument){
                                // update list control with properties
                                AddWiaItemPropertiesToListControl(pCurrentDocument->m_pICurrentItem);
                                if(bRefreshCurrentTYMEDAndFormatSelection){
                                    SetCurrentSelectionForTYMEDAndFormat();
                                }
                            }
                        } else if FAILED(hr){
                            // failure
                            ErrorMessageBox(IDS_WIATESTERROR_WRITING_PROPERTY,hr);
                        } else {
                            // S_FALSE
                            ErrorMessageBox(IDS_WIATESTWARNING_ADDITIONAL_PROPERTY);
                        }
                        // clear variant
                        PropVariantClear(PropVar);
                    } else {
                        // user decided not to write the property
                    }
                }
            }
            // release property storage
            pIWiaPropStg->Release();
            pIWiaPropStg = NULL;
        }
    }
    *pResult = 0;
}

void CWiatestView::AddSupportedTYMEDAndFormatsToListBox(IWiaItem *pIWiaItem)
{
    m_SupportedTymedAndFormatsListBox.ResetContent();
    HRESULT hr = S_OK;
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (S_OK == hr) {
        IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO = NULL;
        WIA_FORMAT_INFO pfe;
        hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
        if (SUCCEEDED(hr)) {
            do {
                memset(&pfe,0,sizeof(pfe));
                hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                if (hr == S_OK) {
                    TCHAR szFormat[MAX_PATH];
                    TCHAR szGuid[MAX_PATH];
                    TCHAR szTYMED[MAX_PATH];
                    memset(szFormat,0,sizeof(szFormat));
                    memset(szGuid,0,sizeof(szGuid));
                    memset(szTYMED,0,sizeof(szTYMED));
                    if(!WIACONSTANT2TSTR(TEXT("Media Type"),(LONG)pfe.lTymed,szTYMED)){
                        lstrcpy(szTYMED,TEXT("TYMED_UNKNOWN"));
                    }
                    FORMAT2TSTR(pfe.guidFormatID,szGuid);
                    TSPRINTF(szFormat,TEXT("%s - %s"),szTYMED,szGuid);
                    m_SupportedTymedAndFormatsListBox.AddString(szFormat);
                } else {
                    if (FAILED(hr)) {
                        ErrorMessageBox(IDS_WIATESTERROR_ENUMFORMATS,hr);
                    }
                }
            } while (hr == S_OK);
            pIEnumWIA_FORMAT_INFO->Release();
            pIEnumWIA_FORMAT_INFO = NULL;
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_ENUMFORMATS,hr);
        }
        pIWiaDataTransfer->Release();
        pIWiaDataTransfer = NULL;
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_IWIADATATRANSFER,hr);
    }
}

void CWiatestView::FORMAT2TSTR(GUID guidFormat, TCHAR *pszFormat)
{
    if(guidFormat == WiaImgFmt_UNDEFINED)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_UNDEFINED:"));
    else if(guidFormat == WiaImgFmt_MEMORYBMP)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_MEMORYBMP:"));
    else if(guidFormat == WiaImgFmt_BMP)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_BMP:"));
    else if(guidFormat == WiaImgFmt_EMF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_EMF:"));
    else if(guidFormat == WiaImgFmt_WMF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_WMF:"));
    else if(guidFormat == WiaImgFmt_JPEG)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_JPEG:"));
    else if(guidFormat == WiaImgFmt_PNG)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_PNG:"));
    else if(guidFormat == WiaImgFmt_GIF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_GIF:"));
    else if(guidFormat == WiaImgFmt_TIFF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_TIFF:"));
    else if(guidFormat == WiaImgFmt_EXIF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_EXIF:"));
    else if(guidFormat == WiaImgFmt_PHOTOCD)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_PHOTOCD:"));
    else if(guidFormat == WiaImgFmt_FLASHPIX)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_FLASHPIX:"));
    else {
        lstrcpy(pszFormat,TEXT("Custom Format:"));
    }

    TCHAR szGUID[MAX_PATH];
    memset(szGUID,0,sizeof(szGUID));
    UCHAR *pwszUUID = NULL;
    long lErrorCode = UuidToString(&guidFormat,&pwszUUID);
    TSPRINTF(szGUID," (%s)",pwszUUID);
    lstrcat(pszFormat,szGUID);
    // free allocated string
    RpcStringFree(&pwszUUID);
}

void CWiatestView::OnAcquireimage()
{
    // delete old temp image files
    DeleteTempDataTransferFiles();

    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
            // use the common UI, because we can not transfer from the root item
            OnAcquireimageCommonui();
            return;
        }
        TCHAR szFileName[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];
        memset(szFileName,0,sizeof(szFileName));
        memset(szTempFile,0,sizeof(szTempFile));
        CWiahelper WIA;
        HRESULT hr = S_OK;
        LONG lTymed = 0;
        hr = WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        if (SUCCEEDED(hr)) {
            hr = WIA.ReadPropertyLong(WIA_IPA_TYMED,&lTymed);
            if (S_OK == hr) {
                switch (lTymed) {
                case TYMED_CALLBACK:
                case TYMED_MULTIPAGE_CALLBACK:
                    GetTempPath(sizeof(szFileName),szFileName);
                    RC2TSTR(IDS_WIATEST_MEMORYTRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
                    lstrcat(szFileName,szTempFile);
                    hr = TransferToMemory(szFileName, pDocument->m_pICurrentItem);
                    break;
                case TYMED_FILE:
                case TYMED_MULTIPAGE_FILE:
                    GetTempPath(sizeof(szFileName),szFileName);
                    RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
                    lstrcat(szFileName,szTempFile);
                    hr = TransferToFile(szFileName,pDocument->m_pICurrentItem);
                    break;
                default:
                    ErrorMessageBox(IDS_WIATESTERROR_UNSUPPORTEDTYMED);
                    break;
                }
            } else if (S_FALSE == hr) {
                ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED_EXIST,hr);
            } else {
                ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED,hr);
            }
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED,hr);
        }

        if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
            CWiahelper WIA;
            WIA.SetIWiaItem(pDocument->m_pICurrentItem);
            GUID guidFormat;
            memset(&guidFormat,0,sizeof(guidFormat));
            hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidFormat);
            if(S_OK == hr){
                RenameTempDataTransferFilesAndLaunchViewer(guidFormat,lTymed);
            }
        }
    }
}

HRESULT CWiatestView::TransferToFile(TCHAR *szFileName, IWiaItem *pIWiaItem)
{
    STGMEDIUM StgMedium;

    HRESULT hr = S_OK;
    // get IWiaDatatransfer interface
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (SUCCEEDED(hr)) {
        WCHAR wszFileName[MAX_PATH];
        memset(wszFileName,0,sizeof(wszFileName));
#ifndef UNICODE
        MultiByteToWideChar(CP_ACP, 0,szFileName,-1,wszFileName,MAX_PATH);
#else
        lstrcpy(wszFileName,szFileName);
#endif
        CWiahelper  WIA;
        LONG lTymed = TYMED_FILE;

        WIA.SetIWiaItem(pIWiaItem);
        hr = WIA.ReadPropertyLong(WIA_IPA_TYMED, &lTymed);
        if (SUCCEEDED(hr)) {

            StgMedium.tymed          = lTymed;
            StgMedium.pUnkForRelease = NULL;
            StgMedium.hGlobal        = NULL;
            StgMedium.lpszFileName   = wszFileName;

            IWiaDataCallback* pIWiaDataCallback = NULL;
            CWiaDataCallback WiaDataCallback;
            hr = WiaDataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (hr == S_OK) {
                hr = pIWiaDataTransfer->idtGetData(&StgMedium,pIWiaDataCallback);
                if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                    // successful transfer
                } else if (S_FALSE == hr) {
                    ErrorMessageBox(IDS_WIATESTERROR_CANCEL_ACQUISITION);
                } else {
                    ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
                }
                pIWiaDataTransfer->Release();
                //WiaDataCallback.Release();
            }
        }
    }
    return hr;
}

HRESULT CWiatestView::TransferToMemory(TCHAR *szFileName, IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    // get IWiaDatatransfer interface
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (SUCCEEDED(hr)) {
        WIA_DATA_TRANSFER_INFO WiaDataTransferInformation;
        memset(&WiaDataTransferInformation,0,sizeof(WiaDataTransferInformation));
        WiaDataTransferInformation.ulSize       = sizeof(WiaDataTransferInformation);
        WiaDataTransferInformation.ulBufferSize = (ReadMinBufferSizeProperty(pIWiaItem) * MIN_BUFFER_FACTOR);
        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback WiaDataCallback;
        hr = WiaDataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
        if (hr == S_OK) {
            hr = pIWiaDataTransfer->idtGetBandedData(&WiaDataTransferInformation,pIWiaDataCallback);
            if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                HANDLE hMemoryDataFile = NULL;
                hMemoryDataFile = CreateFile(szFileName,
                                             GENERIC_WRITE,FILE_SHARE_READ,NULL,
                                             CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
                if (hMemoryDataFile != INVALID_HANDLE_VALUE && hMemoryDataFile != NULL) {
                    LONG lDataSize = 0;
                    BYTE *pData    = WiaDataCallback.GetCallbackMemoryPtr(&lDataSize);
                    DWORD dwBytesWritten = 0;
                    if (lDataSize > 0) {
                        // handle BITMAP DATA (special case)
                        if (WiaDataCallback.IsBITMAPDATA()) {
                            // we need to adjust any headers, because the height and image size information
                            // could be incorrect. (this will handle infinite page length devices)

                            BITMAPFILEHEADER bmfh;
                            BITMAPINFOHEADER *pbmh = NULL;
                            pbmh = (BITMAPINFOHEADER*)pData;
                            if(pbmh->biHeight < 0){
                                StatusMessageBox(IDS_WIATESTWARNING_NEGATIVE_HEIGHTBITMAP);
                                pbmh->biHeight = abs(pbmh->biHeight);
                            }
                            LONG lPaletteSize = pbmh->biClrUsed * sizeof(RGBQUAD);
                            bmfh.bfType       = BMPFILE_HEADER_MARKER;
                            bmfh.bfOffBits    = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + lPaletteSize;
                            bmfh.bfSize       = sizeof(BITMAPFILEHEADER) + lDataSize;
                            bmfh.bfReserved1  = 0;
                            bmfh.bfReserved2  = 0;

                            // only fix the BITMAPINFOHEADER if height needs to be calculated
                            if (pbmh->biHeight == 0) {
                                StatusMessageBox(IDS_WIATESTWARNING_ZERO_HEIGHTBITMAP);
                                LONG lWidthBytes      = CalculateWidthBytes(pbmh->biWidth,pbmh->biBitCount);
                                pbmh->biSizeImage     = lDataSize - lPaletteSize - sizeof(BITMAPINFOHEADER);
                                pbmh->biHeight        = LONG(pbmh->biSizeImage/lWidthBytes);
                                pbmh->biXPelsPerMeter = 0;  // zero out
                                pbmh->biYPelsPerMeter = 0;  // zero out
                            }

                            WriteFile(hMemoryDataFile,&bmfh,sizeof(bmfh),&dwBytesWritten,NULL);
                        }

                        // write data to disk
                        WriteFile(hMemoryDataFile,pData,lDataSize,&dwBytesWritten,NULL);
                    }
                    // flush and close
                    FlushFileBuffers(hMemoryDataFile);
                    CloseHandle(hMemoryDataFile);
                }
            } else if (S_FALSE == hr) {
                ErrorMessageBox(IDS_WIATESTERROR_CANCEL_ACQUISITION);
            } else {
                ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
            }
            pIWiaDataTransfer->Release();
            //WiaDataCallback.Release();
        }
    }
    return hr;
}

void CWiatestView::OnLoadWiapropertystream()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        HRESULT hr = S_OK;
        TCHAR szPropertyStreamFile[MAX_PATH];
        memset(szPropertyStreamFile,0,sizeof(szPropertyStreamFile));

        // select saving location

        OPENFILENAME ofn;      // common dialog box structure
        TCHAR szLoadPropStreamTitle[MAX_PATH];
        memset(szLoadPropStreamTitle,0,sizeof(szLoadPropStreamTitle));
        RC2TSTR(IDS_WIATESTLOADPROPSTREAM_DIALOGTITLE,szLoadPropStreamTitle,sizeof(szLoadPropStreamTitle));

        memset(&ofn,0,sizeof(OPENFILENAME));
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = m_hWnd;
        ofn.lpstrFile       = szPropertyStreamFile;
        ofn.nMaxFile        = sizeof(szPropertyStreamFile);
        ofn.lpstrFilter     = "*.wia\0*.wia\0";
        ofn.nFilterIndex    = 1;
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = szLoadPropStreamTitle;
        ofn.Flags           = 0;
        ofn.lpstrDefExt     = "wia";

        if (!GetOpenFileName(&ofn)) {
            return;
        }

        hr = WIA.ReadPropertyStreamFile(szPropertyStreamFile);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_READPROPERTYSTREAMFILE,hr);
        } else {
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
    }
}

void CWiatestView::OnSaveWiapropertystream()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        HRESULT hr = S_OK;
        TCHAR szPropertyStreamFile[MAX_PATH];
        memset(szPropertyStreamFile,0,sizeof(szPropertyStreamFile));

        // select saving location

        OPENFILENAME ofn;      // common dialog box structure
        TCHAR szSavePropStreamTitle[MAX_PATH];
        memset(szSavePropStreamTitle,0,sizeof(szSavePropStreamTitle));
        RC2TSTR(IDS_WIATESTSAVEPROPSTREAM_DIALOGTITLE,szSavePropStreamTitle,sizeof(szSavePropStreamTitle));

        memset(&ofn,0,sizeof(OPENFILENAME));
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = m_hWnd;
        ofn.lpstrFile       = szPropertyStreamFile;
        ofn.nMaxFile        = sizeof(szPropertyStreamFile);
        ofn.lpstrFilter     = "*.wia\0*.wia\0";
        ofn.nFilterIndex    = 1;
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = szSavePropStreamTitle;
        ofn.Flags           = 0;
        ofn.lpstrDefExt     = "wia";

        if (!GetSaveFileName(&ofn)) {
            return;
        }

        hr = WIA.WritePropertyStreamFile(szPropertyStreamFile);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_WRITEPROPERTYSTREAMFILE,hr);
        }
    }
}

void CWiatestView::OnRclickItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT MousePos;
    CMenu PopupMenu;
    CMenu *pEditMenu = NULL;
    if(PopupMenu.LoadMenu(IDR_PROPERTY_EDIT_POPUPMENU)){
        GetCursorPos(&MousePos);
        pEditMenu = PopupMenu.GetSubMenu(0);
        if(pEditMenu){
            pEditMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, MousePos.x, MousePos.y, this);
        }
    }
    *pResult = 0;
}


void CWiatestView::OnPropertyeditpopupmenuEditpropertyvalue()
{
    PROPVARIANT *pPropertyVariants = NULL;
    PROPSPEC *pPropertySpecs = NULL;
    UINT uiNumProperties = m_ItemPropertiesListCtrl.GetSelectedCount();
    if(uiNumProperties <=0){
        return;
    }
    BOOL bWriteProperties = TRUE;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    HRESULT hr = S_OK;
    UINT iPropertyIndex = 0;
    pPropertyVariants = new PROPVARIANT[uiNumProperties];
    if(pPropertyVariants){
        pPropertySpecs = new PROPSPEC[uiNumProperties];
        if(pPropertySpecs){
            POSITION pos = NULL;
            pos = m_ItemPropertiesListCtrl.GetFirstSelectedItemPosition();
            if (NULL != pos){
                while (pos && bWriteProperties){
                    int iItem = m_ItemPropertiesListCtrl.GetNextSelectedItem(pos);

                    // find out what property is selected
                    TCHAR pszPropertyName[MAX_PATH];
                    memset(pszPropertyName,0,sizeof(pszPropertyName));
                    TCHAR pszPropertyValue[MAX_PATH];
                    memset(pszPropertyValue,0,sizeof(pszPropertyValue));

                    LV_ITEM lvitem;
                    lvitem.mask     = LVIF_PARAM;
                    lvitem.iItem    = iItem;
                    lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
                    lvitem.pszText  = NULL;

                    // is an item selected?
                    if (iItem < ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME)
                        return;

                    m_ItemPropertiesListCtrl.GetItem(&lvitem);
                    // get stored property ID
                    LONG iProp = 0;
                    iProp = (LONG)lvitem.lParam;

                    m_ItemPropertiesListCtrl.GetItemText(iItem,
                        ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,
                        pszPropertyName,
                        sizeof(pszPropertyName));

                    m_ItemPropertiesListCtrl.GetItemText(iItem,
                        ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
                        pszPropertyValue,
                        sizeof(pszPropertyValue));

                    // get document
                    CWiatestDoc* pDocument = NULL;
                    pDocument = (CWiatestDoc*)m_pDocument;
                    if(pDocument){
                        hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
                        if(SUCCEEDED(hr)) {
                            // read property value for type and current value
                            PROPVARIANT PropVar[1];
                            PROPVARIANT AttrPropVar[1];
                            PROPSPEC PropSpec[1];
                            PropSpec[0].ulKind = PRSPEC_PROPID;
                            PropSpec[0].propid = iProp;

                            // set propspec
                            pPropertySpecs[iPropertyIndex].ulKind = PRSPEC_PROPID;
                            pPropertySpecs[iPropertyIndex].propid = iProp;

                            ULONG ulAttributes = 0;
                            CWiaeditpropDlg PropertyEditDlg;
                            hr = pIWiaPropStg->ReadMultiple(1,PropSpec,PropVar);
                            if (S_OK == hr) {
                                PropertyEditDlg.SetVarType(PropVar[0].vt);
                                // clear variant
                                PropVariantClear(PropVar);
                                hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec,&ulAttributes,AttrPropVar);
                                if(S_OK == hr){
                                    PropertyEditDlg.SetAttributes(ulAttributes, (PROPVARIANT*)AttrPropVar);
                                    if(PropertyEditDlg.DoModal(pszPropertyName,pszPropertyValue) == IDOK){
                                        memset(pszPropertyValue,0,sizeof(pszPropertyValue));
                                        PropertyEditDlg.GetPropertyValue(pszPropertyValue);
                                        // set variant
                                        pPropertyVariants[iPropertyIndex].vt = PropertyEditDlg.GetVarType();
                                        TSTR2PROPVAR(pszPropertyValue,(PROPVARIANT*)&pPropertyVariants[iPropertyIndex]);
                                        iPropertyIndex++;
                                    } else {
                                        // user decided not to write the property
                                        bWriteProperties = FALSE;
                                    }
                                }
                            }
                            // release property storage
                            pIWiaPropStg->Release();
                            pIWiaPropStg = NULL;
                        }
                    }
                }
            }
        }

        if(bWriteProperties){
            // get current document, and refresh the property list with the current
            // selected item
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
                if(SUCCEEDED(hr)) {
                    hr = pIWiaPropStg->WriteMultiple(uiNumProperties,pPropertySpecs,pPropertyVariants,MIN_PROPID);
                    if(S_OK == hr){
                        // success
                    } else if FAILED(hr){
                        // failure
                        ErrorMessageBox(IDS_WIATESTERROR_WRITING_PROPERTY,hr);
                    } else {
                        // S_FALSE
                        ErrorMessageBox(IDS_WIATESTWARNING_ADDITIONAL_PROPERTY);
                    }
                    pIWiaPropStg->Release();
                    pIWiaPropStg = NULL;
                }
                // update list control with properties
                AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                // update TYMED and format selection listbox
                SetCurrentSelectionForTYMEDAndFormat();
            }
        }

        if(pPropertyVariants){
            PropVariantClear(pPropertyVariants);
            delete [] pPropertyVariants;
            pPropertyVariants = NULL;
        }

        if(pPropertySpecs){
            delete [] pPropertySpecs;
            pPropertySpecs = NULL;
        }
    }
}

void CWiatestView::OnViewCapabilities()
{
    CWiacapDlg CapabilitiesDlg;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CapabilitiesDlg.SetIWiaItem(pDocument->m_pIRootItem);
        CapabilitiesDlg.DoModal();

#ifdef FORCE_UPDATE
        if(CapabilitiesDlg.m_bCommandSent){
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
#endif

    }
}

void CWiatestView::OnRclickItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT MousePos;
    CMenu PopupMenu;
    CMenu *pEditMenu = NULL;
    if(PopupMenu.LoadMenu(IDR_ITEMTREE_POPUPMENU)){
        GetCursorPos(&MousePos);
        pEditMenu = PopupMenu.GetSubMenu(0);
        if(pEditMenu){
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
                    pEditMenu->EnableMenuItem(IDM_DELETE_ITEM,MF_BYCOMMAND|MF_GRAYED);
                    pEditMenu->RemoveMenu(IDM_ACQUIREIMAGE,MF_BYCOMMAND);
                } else {
                    pEditMenu->RemoveMenu(IDM_ACQUIREIMAGE_COMMONUI,MF_BYCOMMAND);
                }
                pEditMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, MousePos.x, MousePos.y, this);
            }
        }
    }
    *pResult = 0;
}

ULONG CWiatestView::ReadMinBufferSizeProperty(IWiaItem *pIWiaItem)
{
    LONG lMinBufferSize = 0;
    CWiahelper WIA;
    WIA.SetIWiaItem(pIWiaItem);
    HRESULT hr = S_OK;
    hr = WIA.ReadPropertyLong(WIA_IPA_MIN_BUFFER_SIZE,&lMinBufferSize);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGMINBUFFERSIZE,hr);
    }
    return lMinBufferSize;
}

void CWiatestView::SetCurrentSelectionForTYMEDAndFormat()
{
    TCHAR szTymed[MAX_PATH];
    memset(szTymed,0,sizeof(szTymed));
    TCHAR szFormat[MAX_PATH];
    memset(szFormat,0,sizeof(szFormat));

    INT iItem = 0;
    LVFINDINFO info;
    info.flags = LVFI_PARTIAL|LVFI_STRING;

    // find current TYMED setting
    info.psz = TEXT("Media Type");
    iItem = m_ItemPropertiesListCtrl.FindItem(&info,-1);
    if(iItem != -1){
        // item Found
        // get current value from control
        m_ItemPropertiesListCtrl.GetItemText(iItem,ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
            szTymed, sizeof(szTymed));
        LONG lTymed = 0;
        int iErrorCode = TSSCANF(szTymed,"%d",&lTymed);
        WIACONSTANT2TSTR(TEXT("Media Type"), lTymed, szTymed);
    }

    // find current Format setting
    info.psz = TEXT("Format");
    iItem = m_ItemPropertiesListCtrl.FindItem(&info,-1);
    if(iItem != -1){
        // item Found
        // get current value from control
        m_ItemPropertiesListCtrl.GetItemText(iItem,ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
            szFormat, sizeof(szFormat));
    }

    // find and select the current TYMED / format pair in the selection control.
    INT iNumListBoxItems = 0;
    iNumListBoxItems = m_SupportedTymedAndFormatsListBox.GetCount();
    if(iNumListBoxItems > 0){
        for(INT i = 0; i < iNumListBoxItems; i++){
            TCHAR szText[MAX_PATH];
            memset(szText,0,sizeof(szText));
            m_SupportedTymedAndFormatsListBox.GetText(i,szText);
            if(TSTRSTR(szText,szTymed) != NULL){
                // found TYMED
                if(TSTRSTR(szText,szFormat) != NULL){
                    // found format
                    m_SupportedTymedAndFormatsListBox.SetCurSel(i);
                    // exit loop
                    i = iNumListBoxItems;
                }
            }
        }
    }
}

void CWiatestView::DeleteTempDataTransferFiles()
{

}

void CWiatestView::RenameTempDataTransferFilesAndLaunchViewer(GUID guidFormat, LONG lTymed)
{
    TCHAR *pszFileExt = NULL;
    TCHAR szOriginalFileName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    TCHAR szFullLaunchPath[MAX_PATH];
    TCHAR szOriginalFullLaunchPath[MAX_PATH];
    memset(szFileName,0,sizeof(szFileName));
    memset(szTempPath,0,sizeof(szTempPath));
    memset(szFullLaunchPath,0,sizeof(szFullLaunchPath));
    memset(szOriginalFileName,0,sizeof(szOriginalFileName));
    memset(szOriginalFullLaunchPath,0,sizeof(szOriginalFullLaunchPath));

    GetTempPath(sizeof(szTempPath),szTempPath);
    BOOL bKnownFormat = TRUE;

    switch(lTymed){
    case TYMED_CALLBACK:
    case TYMED_MULTIPAGE_CALLBACK:
        RC2TSTR(IDS_WIATEST_MEMORYTRANSFER_FILENAME,szOriginalFileName,sizeof(szOriginalFileName));
        lstrcpy(szFileName,szOriginalFileName);
        pszFileExt = TSTRSTR(szFileName,TEXT("mem"));
        break;
    case TYMED_FILE:
    case TYMED_MULTIPAGE_FILE:
        RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szOriginalFileName,sizeof(szOriginalFileName));
        lstrcpy(szFileName,szOriginalFileName);
        pszFileExt = TSTRSTR(szFileName,TEXT("fil"));
        break;
    default:
        break;
    }

    if(lstrlen(szFileName) > 0){
        if(pszFileExt){
            // rename to known image formats
            if(guidFormat == WiaImgFmt_UNDEFINED)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_MEMORYBMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_BMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_EMF)
                lstrcpy(pszFileExt,TEXT("emf"));
            else if(guidFormat == WiaImgFmt_WMF)
                lstrcpy(pszFileExt,TEXT("wmf"));
            else if(guidFormat == WiaImgFmt_JPEG)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PNG)
                lstrcpy(pszFileExt,TEXT("png"));
            else if(guidFormat == WiaImgFmt_GIF)
                lstrcpy(pszFileExt,TEXT("gif"));
            else if(guidFormat == WiaImgFmt_TIFF)
                lstrcpy(pszFileExt,TEXT("tif"));
            else if(guidFormat == WiaImgFmt_EXIF)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PHOTOCD)
                lstrcpy(pszFileExt,TEXT("pcd"));
            else if(guidFormat == WiaImgFmt_FLASHPIX)
                lstrcpy(pszFileExt,TEXT("fpx"));
            else {
                TCHAR szValue[MAX_PATH];
                memset(szValue,0,sizeof(szValue));
                UCHAR *pwszUUID = NULL;
                long lErrorCode = UuidToString(&guidFormat,&pwszUUID);

                //TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                lstrcpy(szValue,(LPCTSTR)pwszUUID);
                //  (TEXT("(Unknown Image type) GUID: %s"),pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                bKnownFormat = FALSE;
            }
        }
    }

    if(bKnownFormat){
        // launch viewer
        lstrcpy(szFullLaunchPath,szTempPath);
        lstrcat(szFullLaunchPath,szFileName);

        lstrcpy(szOriginalFullLaunchPath,szTempPath);
        lstrcat(szOriginalFullLaunchPath,szOriginalFileName);
        // delete any duplicates
        DeleteFile(szFullLaunchPath);
        // rename file
        MoveFile(szOriginalFullLaunchPath,szFullLaunchPath);
        HINSTANCE hInst = NULL;
        hInst = ShellExecute(m_hWnd,NULL,szFullLaunchPath,NULL,szTempPath,SW_SHOW);
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT);
    }
}

LONG CWiatestView::CalculateWidthBytes(LONG lWidthPixels, LONG lbpp)
{
    LONG lWidthBytes = 0;
    lWidthBytes = (lWidthPixels * lbpp) + 31;
    lWidthBytes = ((lWidthBytes/8) & 0xfffffffc);
    return lWidthBytes;
}

void CWiatestView::OnDeleteItem()
{
    HRESULT hr = S_OK;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        if(pDocument->m_pICurrentItem != pDocument->m_pIRootItem){
            pDocument->m_pICurrentItem->DeleteItem(0);
            pDocument->m_pICurrentItem->Release();
            pDocument->m_pICurrentItem = NULL;
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_DELETEROOTITEM);
        }
    }
}

void CWiatestView::OnAcquireimageCommonui()
{
    // delete old temp image files
    DeleteTempDataTransferFiles();

    HRESULT hr = S_OK;
    IWiaItem **pIWiaItemArray = NULL;
    LONG lItemCount = 0;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        hr = pDocument->m_pIRootItem->DeviceDlg(m_hWnd,0,WIA_INTENT_MINIMIZE_SIZE,&lItemCount,&pIWiaItemArray);
        if(S_OK == hr){
            // get temp file name
            TCHAR szTempFile[MAX_PATH];
            memset(szTempFile,0,sizeof(szTempFile));
            RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
            for(LONG lItem = 0; lItem < lItemCount; lItem++){
                // get temp path
                TCHAR szFileName[MAX_PATH];
                memset(szFileName,0,sizeof(szFileName));
                GetTempPath(sizeof(szFileName),szFileName);
                // create new temp file with image index number
                TCHAR szFinalFileName[MAX_PATH];
                memset(szFinalFileName,0,sizeof(szFinalFileName));
                TSPRINTF(szFinalFileName,TEXT("%d%s"),lItem,szTempFile);
                // add new temp file to temp path
                lstrcat(szFileName,szFinalFileName);
                // set TYMED_FILE
                CWiahelper WIA;
                WIA.SetIWiaItem(pIWiaItemArray[lItem]);
                hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_FILE);
                if (S_OK == hr) {
                    // transfer to this file
                    hr = TransferToFile(szFileName,pIWiaItemArray[lItem]);
                    if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                        GUID guidFormat;
                        memset(&guidFormat,0,sizeof(guidFormat));
                        hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidFormat);
                        if (S_OK == hr) {
                            RenameTempDataTransferFilesAndLaunchViewer(szFileName,guidFormat,TYMED_FILE);
                        } else {
                            ErrorMessageBox(IDS_WIATESTERROR_READINGFORMAT,hr);
                        }
                    } else if (FAILED(hr)) {
                        ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
                    }
                } else {
                    ErrorMessageBox(IDS_WIATESTERROR_WRITINGTYMED,hr);
                }
                // release item after acquisition
                pIWiaItemArray[lItem]->Release();
            }
        }
    }
}

void CWiatestView::OnEditDebugout()
{
}

void CWiatestView::OnUpdateEditDebugout(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bOutputToDebuggerON);
}

void CWiatestView::RenameTempDataTransferFilesAndLaunchViewer(TCHAR *szFileName, GUID guidFormat, LONG lTymed)
{
    if(!szFileName)
        return;

    TCHAR *pszFileExt = NULL;
    TCHAR szOriginalFileName[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    memset(szTempPath,0,sizeof(szTempPath));
    memset(szOriginalFileName,0,sizeof(szOriginalFileName));

    // copy original filename
    lstrcpy(szOriginalFileName,szFileName);

    // get temp launch path
    GetTempPath(sizeof(szTempPath),szTempPath);
    BOOL bKnownFormat = TRUE;

    switch(lTymed){
    case TYMED_CALLBACK:
    case TYMED_MULTIPAGE_CALLBACK:
        pszFileExt = TSTRSTR(szFileName,TEXT("mem"));
        break;
    case TYMED_FILE:
    case TYMED_MULTIPAGE_FILE:
        pszFileExt = TSTRSTR(szFileName,TEXT("fil"));
        break;
    default:
        break;
    }

    if(lstrlen(szFileName) > 0){
        if(pszFileExt){
            // rename to known image formats
            if(guidFormat == WiaImgFmt_UNDEFINED)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_MEMORYBMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_BMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_EMF)
                lstrcpy(pszFileExt,TEXT("emf"));
            else if(guidFormat == WiaImgFmt_WMF)
                lstrcpy(pszFileExt,TEXT("wmf"));
            else if(guidFormat == WiaImgFmt_JPEG)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PNG)
                lstrcpy(pszFileExt,TEXT("png"));
            else if(guidFormat == WiaImgFmt_GIF)
                lstrcpy(pszFileExt,TEXT("gif"));
            else if(guidFormat == WiaImgFmt_TIFF)
                lstrcpy(pszFileExt,TEXT("tif"));
            else if(guidFormat == WiaImgFmt_EXIF)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PHOTOCD)
                lstrcpy(pszFileExt,TEXT("pcd"));
            else if(guidFormat == WiaImgFmt_FLASHPIX)
                lstrcpy(pszFileExt,TEXT("fpx"));
            else {
                TCHAR szValue[MAX_PATH];
                memset(szValue,0,sizeof(szValue));
                UCHAR *pwszUUID = NULL;
                long lErrorCode = UuidToString(&guidFormat,&pwszUUID);
                //TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                lstrcpy(szValue,(LPCTSTR)pwszUUID);
                //  (TEXT("(Unknown Image type) GUID: %s"),pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                bKnownFormat = FALSE;
            }
        }
    }

    if(bKnownFormat){
        // delete any duplicates
        DeleteFile(szFileName);
        // rename file
        MoveFile(szOriginalFileName,szFileName);
        HINSTANCE hInst = NULL;
        hInst = ShellExecute(m_hWnd,NULL,szFileName,NULL,szTempPath,SW_SHOW);
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT);
    }
}

void CWiatestView::DisplayMissingThumbnail()
{
    //m_hThumbNailBitmap = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_THUMBNAIL_MISSING_BITMAP));
    //if(m_hThumbNailBitmap){
        // display thumbnail(deleting any old one)
        HBITMAP hPreviousBitmap = NULL;
        //hPreviousBitmap = m_ThumbnailPreviewWindow.SetBitmap(m_hThumbNailBitmap);
        hPreviousBitmap = m_ThumbnailPreviewWindow.GetBitmap();
        if(hPreviousBitmap){
            DeleteObject(hPreviousBitmap);
            hPreviousBitmap = NULL;
        }
        m_ThumbnailPreviewWindow.Invalidate();
        Invalidate();
    //}
}

void CWiatestView::DisplayThumbnail(IWiaItem *pIWiaItem)
{

    if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeDigitalCamera){
        HRESULT hr = S_OK;
        BYTE *pThumbNail = NULL;
        CWiahelper WIA;
        WIA.SetIWiaItem(pIWiaItem);

        long lThumbNailHeight = 0;
        long lThumbNailWidth  = 0;
        long lThumbNailSize   = 0;

        //
        // read thumbnail height
        //

        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&lThumbNailHeight);
        if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILHEIGHT,hr);
            }
            DisplayMissingThumbnail();
            return;
        }

        //
        // read thumbnail width
        //

        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&lThumbNailWidth);
        if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILWIDTH,hr);
            }
            DisplayMissingThumbnail();
            return;
        }

        //
        // read thumbnail data
        //

        LONG lDataSize = 0;
        BYTE *pData = NULL;
        hr = WIA.ReadPropertyData(WIA_IPC_THUMBNAIL,&pData,&lDataSize);
        if (hr == S_OK) {
            lThumbNailSize = lThumbNailWidth * lThumbNailHeight * 3;
            if (lThumbNailSize != lDataSize) {
                TCHAR szErrorResourceText[MAX_PATH];
                memset(szErrorResourceText,0,sizeof(szErrorResourceText));
                TCHAR szErrorText[MAX_PATH];
                memset(szErrorText,0,sizeof(szErrorText));

                RC2TSTR(IDS_WIATESTERROR_PROCESSING_THUMBNAILDATA,szErrorResourceText,sizeof(szErrorResourceText));
                TSPRINTF(szErrorText,szErrorResourceText,lThumbNailSize,lDataSize);
                ErrorMessageBox(szErrorText);
                // free temp memory
                if(pData){
                    GlobalFree(pData);
                    pData = NULL;
                }
                DisplayMissingThumbnail();
                return;
            }

            BITMAPINFO bmi;
            memset(&bmi,0,sizeof(bmi));
            bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth           = lThumbNailWidth;
            bmi.bmiHeader.biHeight          = lThumbNailHeight;
            bmi.bmiHeader.biPlanes          = 1;
            bmi.bmiHeader.biBitCount        = 24;
            bmi.bmiHeader.biCompression     = BI_RGB;
            bmi.bmiHeader.biSizeImage       = 0;
            bmi.bmiHeader.biXPelsPerMeter   = 0;
            bmi.bmiHeader.biYPelsPerMeter   = 0;
            bmi.bmiHeader.biClrUsed         = 0;
            bmi.bmiHeader.biClrImportant    = 0;

            PBYTE pThumbNailData = NULL;

            HDC hdc  = ::GetDC(NULL);
            if(hdc){
                HDC hdcm = CreateCompatibleDC(hdc);
            }
            m_hThumbNailBitmap = CreateDIBSection(hdc,&bmi,DIB_RGB_COLORS,(void **)&pThumbNailData,NULL,0);
            if(m_hThumbNailBitmap){
                memcpy(pThumbNailData,pData,lDataSize);
            }

            // free temp memory
            if(pData){
                GlobalFree(pData);
                pData = NULL;
            }

            // display thumbnail(deleting any old one)
            HBITMAP hPreviousBitmap = NULL;
            hPreviousBitmap = m_ThumbnailPreviewWindow.SetBitmap(m_hThumbNailBitmap);
            if(hPreviousBitmap){
                DeleteObject(hPreviousBitmap);
                hPreviousBitmap = NULL;
            }
            m_ThumbnailPreviewWindow.Invalidate();

        } else if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILDATA,hr);
            }
            DisplayMissingThumbnail();
            return;
        }
    }
}

void CWiatestView::AdjustViewForDeviceType()
{
    // get associated document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        m_lDeviceType = 0;
        CWiahelper WIA;
        HRESULT hr = S_OK;
        WIA.SetIWiaItem(pDocument->m_pIRootItem);
        hr = WIA.ReadPropertyLong(WIA_DIP_DEV_TYPE,&m_lDeviceType);
        if(S_OK == hr){
            if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeScanner){
                // disable thumbnail preview window
                m_ThumbnailPreviewWindow.ShowWindow(SW_HIDE);
                LONG lDocHandlingSelect = 0;
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocHandlingSelect);
                if(S_OK == hr){
                    // enable Document Acquisition settings menu option, and toolbar
                    m_bHasDocumentFeeder = TRUE;
                }
            }
        } else {
            // error?
        }
    }
}

void CWiatestView::RegisterForEvents()
{

    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);
        return;
    }

    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if (pDocument) {

        // read device ID
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pIRootItem);
        BSTR bstrDeviceID = NULL;
        hr = WIA.ReadPropertyBSTR(WIA_DIP_DEV_ID,&bstrDeviceID);
        if (FAILED(hr)) {
            ErrorMessageBox(IDS_WIATESTERROR_DEVICEID,hr);
            return;
        }

        WIA_DEV_CAP DevCap;
        IEnumWIA_DEV_CAPS* pIEnumWiaDevCaps = NULL;

        // enumerate all device events supported
        hr = pDocument->m_pIRootItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,&pIEnumWiaDevCaps);
        if (S_OK == hr) {
            LONG lEventIndex = 0;
            IWiaEventCallback* pIWiaEventCallback = NULL;
            hr = m_WiaEventCallback.QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
            if (SUCCEEDED(hr)) {
                do {
                    memset(&DevCap,0,sizeof(DevCap));
                    hr = pIEnumWiaDevCaps->Next(1,&DevCap,NULL);
                    if (S_OK == hr) {

                        // DevCap.ulFlags;
                        // DevCap.bstrIcon;
                        // DevCap.bstrCommanline;
                        // DevCap.guid;

                        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                                         bstrDeviceID,
                                                                         &DevCap.guid,
                                                                         pIWiaEventCallback,
                                                                         &m_WiaEventCallback.m_pIUnkRelease[lEventIndex]);
                        if (FAILED(hr)) {
                            ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
                        } else {
                            // increment index
                            lEventIndex++;
                        }

                        // free allocated strings
                        if (DevCap.bstrName) {
                            SysFreeString(DevCap.bstrName);
                        }
                        if (DevCap.bstrDescription) {
                            SysFreeString(DevCap.bstrDescription);
                        }
                    }
                }while (hr == S_OK);
            }
            pIEnumWiaDevCaps->Release();
            pIEnumWiaDevCaps = NULL;
        }
    }
    pIWiaDevMgr->Release();
    pIWiaDevMgr = NULL;

    //CWnd* pParent = GetParent();
    m_WiaEventCallback.SetViewWindowHandle(m_hWnd);
}


LRESULT CWiatestView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bProcessMessage = FALSE;

    // is it one of the user defined messages??

    switch (message) {
    case WM_DEVICE_DISCONNECTED:
    case WM_DEVICE_CONNECTED:
    case WM_ITEM_DELETED:
    case WM_ITEM_CREATED:
    case WM_TREE_UPDATED:
    case WM_STORAGE_CREATED:
    case WM_STORAGE_DELETED:
        bProcessMessage = TRUE;
        break;
    default:
        break;
    }

    // if it is process it...
    if (bProcessMessage) {
        HRESULT hr = S_OK;
        CWnd *pParent = GetParent();
        if (pParent) {
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if (pDocument) {
                switch (message) {
                case WM_DEVICE_DISCONNECTED:
                    return pParent->PostMessage(WM_CLOSE,0,0);
                    break;
                case WM_DEVICE_CONNECTED:
                    break;
                case WM_ITEM_DELETED:
                case WM_ITEM_CREATED:
                case WM_TREE_UPDATED:
                case WM_STORAGE_CREATED:
                case WM_STORAGE_DELETED:
                    // refresh the item tree
                    AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
                    // refresh the properties
                    AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
                    break;
                default:
                    break;
                }
            }
        }
    }

    // do default processing
    return CFormView::WindowProc(message, wParam, lParam);
}

void CWiatestView::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CFormView::OnShowWindow(bShow, nStatus);
}

void CWiatestView::OnDocumentAcquisitionSettings()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if (pDocument) {
        CWiaDocAcqSettings DocumentAcquisitionSettingsDlg(IDS_WIATEST_DOCUMENT_SETTINGS_TITLE, pDocument->m_pIRootItem);
        if (DocumentAcquisitionSettingsDlg.DoModal() != IDCANCEL) {
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
    }
}

void CWiatestView::OnUpdateDocumentAcquisitionSettings(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bHasDocumentFeeder);
}

void CWiatestView::OnSelchangeSupportedTymedAndFormatListbox()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        TCHAR szTymedAndFormat[MAX_PATH];
        memset(szTymedAndFormat,0,sizeof(szTymedAndFormat));
        INT iCurrentSelection = 0;
        iCurrentSelection = m_SupportedTymedAndFormatsListBox.GetCurSel();
        if(iCurrentSelection != -1){
            m_SupportedTymedAndFormatsListBox.GetText(iCurrentSelection,szTymedAndFormat);

            // find current TYMED selection (located in selected string)
            LONG lTymed = TYMED_CALLBACK;

            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_CALLBACK")) != NULL){
                lTymed = TYMED_CALLBACK;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_FILE")) != NULL){
                lTymed = TYMED_FILE;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_MULTIPAGE_CALLBACK")) != NULL){
                lTymed = TYMED_MULTIPAGE_CALLBACK;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_MULTIPAGE_FILE")) != NULL){
                lTymed = TYMED_MULTIPAGE_FILE;
            }

            HRESULT hr = S_OK;
            CWiahelper WIA;
            WIA.SetIWiaItem(pDocument->m_pICurrentItem);

            // write TYMED to device

            hr = WIA.WritePropertyLong(WIA_IPA_TYMED,lTymed);
            if (FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_WRITINGTYMED,hr);
                return;
            }

            // find current format selection
            TCHAR *pszGUID = NULL;
            // trim off trailing ')' on guid string
            LONG lLen = 0;
            lLen = lstrlen(szTymedAndFormat);
            szTymedAndFormat[(lLen * sizeof(TCHAR)) - sizeof(TCHAR)] = 0;
            pszGUID = TSTRSTR(szTymedAndFormat,TEXT("("));
            if(pszGUID){
                pszGUID+=sizeof(TCHAR);
                // we are on the GUID
                GUID guidFormat = GUID_NULL;
                memset(&guidFormat,0,sizeof(guidFormat));
#ifndef UNICODE
                long lErrorCode = UuidFromString((UCHAR*)pszGUID,&guidFormat);
#else
                WideCharToMultiByte(CP_ACP, 0,pszGUID,-1,szbuffer,MAX_PATH,NULL,NULL);
                UuidFromString((UCHAR*)szbuffer,&guidFormat);
#endif
                if(guidFormat != GUID_NULL){
                    hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,guidFormat);
                    if(SUCCEEDED(hr)){
                        AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                    } else {
                        ErrorMessageBox(IDS_WIATESTERROR_WRITINGFORMAT,hr);
                    }
                }
            }

        }
    }
}

void CWiatestView::OnThumbnailPreview()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WiaVideoTest.rc
//
#define IDD_MAIN_DLG                    101
#define IDD_STRESSDLG                   102
#define IDD_DIALOG_TAKE_PICTURE_MULTIPLE 103
#define IDC_VIDEO_PREVIEW_WINDOW        1000
#define IDC_LIST_WIA_DEVICES            1001
#define IDC_BUTTON_CREATE_VIDEO_WIA     1002
#define IDC_BUTTON_DESTROY_VIDEO        1003
#define IDC_BUTTON_PLAY                 1004
#define IDC_BUTTON_PAUSE                1005
#define IDC_BUTTON_TAKE_PICTURE         1006
#define IDC_BUTTON_TAKE_PICTURE_DRIVER  1007
#define IDC_BUTTON_SHOW_VIDEO_TOGGLE    1008
#define IDC_BUTTON_RESIZE_TOGGLE        1009
#define IDC_BUTTON_TAKE_PICTURE_STRESS  1011
#define IDC_LIST_NEW_IMAGES             1012
#define IDC_EDIT_IMAGES_DIR             1013
#define IDC_EDIT_CURRENT_STATE          1014
#define IDC_BUTTON_TAKE_PICTURE_MULTIPLE 1015
#define IDC_EDIT_NUM_THREADS            1016
#define IDC_EDIT_NUM_STRESS_THREADS     1016
#define IDC_EDIT_NUM_IMAGES_PER_THREAD  1017
#define IDC_EDIT_NUM_PICTURES_TAKEN     1017
#define IDC_EDIT_NUM_PICTURES_TO_TAKE   1018
#define IDC_EDIT_GRAPH_BUILD_TIME       1018
#define IDC_EDIT_TAKE_PICTURE_FREQUENCY 1019
#define IDC_EDIT_LIST_LOAD_TIME         1019
#define IDC_BUTTON_CREATE_VIDEO_ENUM_POS 1020
#define IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME 1021
#define IDC_RADIO_WIA_DEVICE_LIST       1022
#define IDC_RADIO_DSHOW_DEVICE_LIST     1023
#define IDS_ERROR                       2000
#define IDS_FAILED_TO_CREATE_VIDEO      2001
#define IDS_DISCONNECTED                2002
#define IDS_VIDEO_STREAM_SHUTDOWN       2003
#define IDS_NO_VIDEO                    2004
#define IDS_CREATING_VIDEO              2005
#define IDS_VIDEO_CREATED               2006
#define IDS_PLAYING_VIDEO               2007
#define IDS_VIDEO_PAUSED                2008
#define IDS_DESTROYING_VIDEO            2009
#define IDS_STATE_UNKNOWN               2010
#define IDS_VIDEO_STILL_ACTIVE          2011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\apputil.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       AppUtil.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Misc application utilities
 *
 *****************************************************************************/
#include <stdafx.h>

#include "wiavideotest.h"


/****************************Local Function Prototypes********************/


///////////////////////////////
// AppUtil_ConvertToWideString
//
HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                                    WCHAR         *pwszString,
                                    UINT          cchString)
{
    HRESULT hr = S_OK;

    if ((pszStringToConvert == NULL) ||
        (pwszString         == NULL))
    {
        return E_POINTER;
    }

#ifdef UNICODE
    wcsncpy(pwszString, pszStringToConvert, cchString);
#else
        
    MultiByteToWideChar(CP_ACP, 0, pszStringToConvert, -1, 
                        pwszString, cchString);
#endif

    return hr;            
}

///////////////////////////////
// AppUtil_ConvertToTCHAR
//
HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                               TCHAR         *pszString,
                               UINT          cchString)
{
    HRESULT hr = S_OK;

    if ((pwszStringToConvert == NULL) ||
        (pszString          == NULL))
    {
        return E_POINTER;
    }

#ifdef UNICODE
    wcsncpy(pszString, pwszStringToConvert, cchString);
#else
    WideCharToMultiByte(CP_ACP, 0, pwszStringToConvert,
                        -1, pszString, cchString * sizeof(TCHAR), NULL, NULL);
#endif

    return hr;            
}

///////////////////////////////
// AppUtil_MsgBox
//
int AppUtil_MsgBox(UINT     uiCaption,
                   UINT     uiTextResID,
                   UINT     uiStyle,
                   ...)
{
    HRESULT hr                 = S_OK;
    TCHAR   szCaption[255 + 1] = {0};
    TCHAR   szFmt[511 + 1]     = {0};
    TCHAR   szMsg[1023 + 1]    = {0};
    int     iResult            = 0;
    va_list vArgs;

    if (uiCaption != 0)
    {
        iResult = LoadString(APP_GVAR.hInstance, uiCaption, szCaption,
                             sizeof(szCaption) / sizeof(TCHAR));
    }

    if (uiTextResID != 0)
    {
        iResult = LoadString(APP_GVAR.hInstance, uiTextResID, szFmt,
                             sizeof(szFmt) / sizeof(TCHAR));
    }

    va_start(vArgs, uiStyle);
    _vsntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), szFmt, vArgs);
    va_end(vArgs);

    return MessageBox(APP_GVAR.hwndMainDlg, szMsg, szCaption, uiStyle); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\imagelst.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ImageLst.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages Images Item List
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>
#include "wiavideotest.h"

static struct 
{
    UINT                    uiNumPicturesInList;
    BOOL                    bExitThread;
    HANDLE                  hItemListThread;
} LOCAL_GVAR = 
{
    0,
    FALSE,
    NULL
};

typedef struct tagThreadArgs_t
{
    BOOL bWiaDeviceListMode;

    union
    {
        struct
        {
            DWORD                   dwWiaCookie;
            IGlobalInterfaceTable   *pGIT;
        } WiaItemList;

        struct 
        {
            TCHAR szImagesDirectory[255 + 1];
        } DShowItemList;
    };
} ThreadArgs_t;


/****************************Local Function Prototypes********************/
void IncNumPicsInList();
DWORD WINAPI LoadListWithWiaItems(IGlobalInterfaceTable *pGIT,
                                  DWORD                 dwCookie);

DWORD WINAPI LoadListWithFileItems(const TCHAR *pszImagesDirectory);
DWORD WINAPI ItemListThreadProc(void *pArgs);

///////////////////////////////
// IncNumPicsInList
//
void IncNumPicsInList()
{
    InterlockedIncrement((LONG*) &LOCAL_GVAR.uiNumPicturesInList);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    return;
}

///////////////////////////////
// ImageLst_PostAddImageRequest
//
HRESULT ImageLst_PostAddImageRequest(BSTR bstrNewImage)
{
    HRESULT hr = S_OK;

    if (bstrNewImage == NULL)
    {
        return E_POINTER;
    }

    //
    // This will be freed by the AddImageToList function below.
    //
    BSTR bstrPosted = ::SysAllocString(bstrNewImage);

    PostMessage(APP_GVAR.hwndMainDlg, WM_CUSTOM_ADD_IMAGE, 0,
                (LPARAM)bstrPosted);

    return hr;
}


///////////////////////////////
// ImageLst_AddImageToList
//
HRESULT ImageLst_AddImageToList(BSTR bstrNewImage)
{
    HRESULT hr = S_OK;
    TCHAR   szNewImage[MAX_PATH] = {0};

    if (bstrNewImage == NULL)
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = AppUtil_ConvertToTCHAR((WCHAR*) bstrNewImage, 
                                    szNewImage,
                                    sizeof(szNewImage) / sizeof(TCHAR));
    }
    
    if (hr == S_OK)
    {
        //
        // Insert at the top of the list.
        //
        LRESULT lResult = 0;

        lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                                          IDC_LIST_NEW_IMAGES,
                                          LB_ADDSTRING,
                                          0,
                                          (LPARAM) szNewImage);

        WPARAM Index = (WPARAM) lResult;
    
        IncNumPicsInList();

        SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                           IDC_LIST_NEW_IMAGES,
                           LB_SETCURSEL,
                           Index,
                           0);
    }

    if (bstrNewImage)
    {
        ::SysFreeString(bstrNewImage);
    }

    return hr;
}

///////////////////////////////
// LoadListWithWiaItems
//

DWORD WINAPI LoadListWithWiaItems(IGlobalInterfaceTable *pGIT,
                                  DWORD                 dwCookie)
{
    HRESULT         hr                     = S_OK;
    IWiaItem        *pSelectedDevice       = NULL;
    IEnumWiaItem    *pIEnumItem            = NULL;

    if ((pGIT == NULL) || (dwCookie == 0))
    {
        return -1;
    }

    hr = pGIT->GetInterfaceFromGlobal(dwCookie,
                                      IID_IWiaItem,
                                      (void**)&pSelectedDevice);

    if (pSelectedDevice == NULL)
    {
        return -1;
    }

    hr = pSelectedDevice->EnumChildItems(&pIEnumItem);

    if (hr == S_OK)
    {
        hr = pIEnumItem->Reset();
    }

    DWORD dwStartTime = 0;
    DWORD dwEndTime   = 0;

    dwStartTime = timeGetTime();

    if (hr == S_OK)
    {
        BOOL bDone = LOCAL_GVAR.bExitThread;

        while (!bDone)
        {
            IWiaItem            *pIWiaItem = NULL;
            IWiaPropertyStorage *pStorage  = NULL;
            TCHAR               szItemName[MAX_PATH] = {0};

            hr = pIEnumItem->Next(1, &pIWiaItem, NULL);

            if (LOCAL_GVAR.bExitThread)
            {
                //
                // Exit the thread
                //
                hr = E_FAIL;
            }

            if (hr == S_OK)
            {
                hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pStorage);
            }

            if (hr == S_OK)
            {
                PROPVARIANT pv;
                PropVariantInit(&pv);

                hr = WiaProc_GetProperty(pStorage, WIA_IPA_FULL_ITEM_NAME, &pv);

                if (pv.vt == VT_BSTR)
                {
                    ImageLst_PostAddImageRequest(pv.bstrVal);
                }

                PropVariantClear(&pv);
            }

            if (pIWiaItem)
            {
                pIWiaItem->Release();
                pIWiaItem = NULL;
            }

            if (pStorage)
            {
                pStorage->Release();
                pStorage = NULL;
            }
            
            if (hr != S_OK)
            {
                bDone = TRUE;
            }
            else if (LOCAL_GVAR.bExitThread)
            {
                bDone = TRUE;
            }
        }
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (pIEnumItem)
    {
        pIEnumItem->Release();
        pIEnumItem = NULL;
    }

    return 0;
}

///////////////////////////////
// LoadListWithFileItems
//

DWORD WINAPI LoadListWithFileItems(const TCHAR *pszImagesDirectory)
{
    HRESULT         hr                         = S_OK;
    TCHAR           szSearchPath[MAX_PATH + 1] = {0};
    HANDLE          hFindHandle                = NULL;
    BOOL            bDone                      = FALSE;
    WIN32_FIND_DATA FindData;


    if (pszImagesDirectory == NULL)
    {
        return -1;
    }

    _sntprintf(szSearchPath, sizeof(szSearchPath) / sizeof(TCHAR),
               TEXT("%s\\*.jpg"), pszImagesDirectory);


    hFindHandle = FindFirstFile(szSearchPath, &FindData);

    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        bDone = TRUE;
    }

    DWORD dwStartTime = 0;
    DWORD dwEndTime   = 0;

    dwStartTime = timeGetTime();

    while ((!bDone) && (!LOCAL_GVAR.bExitThread))
    {
        BOOL  bSuccess     = FALSE;
        BSTR  bstrFileName = NULL;
        TCHAR szFileName[_MAX_FNAME + MAX_PATH + 1] = {0};
        WCHAR wszFileName[_MAX_FNAME + MAX_PATH + 1] = {0};

        _sntprintf(szFileName, sizeof(szFileName) / sizeof(TCHAR),
                   TEXT("%s\\%s"), pszImagesDirectory, FindData.cFileName);

        AppUtil_ConvertToWideString(szFileName,
                                    wszFileName,
                                    sizeof(wszFileName) / sizeof(WCHAR));

        //
        // This is relased by the post processor function
        //
        bstrFileName = ::SysAllocString(wszFileName);

        ImageLst_PostAddImageRequest(bstrFileName);

        bSuccess = FindNextFile(hFindHandle, &FindData);

        if (!bSuccess)
        {
            bDone = TRUE;
        }
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hFindHandle)
    {
        FindClose(hFindHandle);
        hFindHandle = NULL;
    }

    return 0;
}


///////////////////////////////
// ItemListThreadProc
//
DWORD WINAPI ItemListThreadProc(void *pArgs)
{
    HRESULT         hr                     = S_OK;
    ThreadArgs_t    *pThreadArgs           = (ThreadArgs_t*) pArgs;

    if (pThreadArgs == NULL)
    {
        return -1;
    }

    if (pThreadArgs->bWiaDeviceListMode == TRUE)
    {
        LoadListWithWiaItems(pThreadArgs->WiaItemList.pGIT,
                             pThreadArgs->WiaItemList.dwWiaCookie);

        if (pThreadArgs->WiaItemList.pGIT)
        {
            pThreadArgs->WiaItemList.pGIT->Release();
            pThreadArgs->WiaItemList.pGIT = NULL;
        }
    }
    else
    {
        LoadListWithFileItems(pThreadArgs->DShowItemList.szImagesDirectory);
    }

    delete pThreadArgs;
    pThreadArgs = NULL;

    return 0;
}

///////////////////////////////
// ImageLst_PopulateWiaItemList
//
HRESULT ImageLst_PopulateWiaItemList(IGlobalInterfaceTable *pGIT,
                                     DWORD                 dwCookie)
{
    HRESULT         hr         = S_OK;
    DWORD           dwThreadID = 0;
    ThreadArgs_t    *pArgs     = NULL;

    if ((pGIT     == NULL) ||
        (dwCookie == 0))
    {
        return E_POINTER;
    }

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);

    pArgs = new ThreadArgs_t;

    if (pArgs == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pArgs, sizeof(*pArgs));

    pGIT->AddRef();
    pArgs->bWiaDeviceListMode       = TRUE;
    pArgs->WiaItemList.pGIT         = pGIT;
    pArgs->WiaItemList.dwWiaCookie  = dwCookie;

    LOCAL_GVAR.bExitThread = FALSE;
    LOCAL_GVAR.hItemListThread = CreateThread(NULL, 0, ItemListThreadProc,
                                              (void*) pArgs,
                                              0, &dwThreadID);

    return hr;
}

///////////////////////////////
// ImageLst_PopulateDShowItemList
//
HRESULT ImageLst_PopulateDShowItemList(const TCHAR *pszImagesDirectory)
{
    HRESULT         hr         = S_OK;
    DWORD           dwThreadID = 0;
    ThreadArgs_t    *pArgs     = NULL;

    if (pszImagesDirectory == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);

    pArgs = new ThreadArgs_t;

    if (pArgs == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pArgs, sizeof(*pArgs));

    pArgs->bWiaDeviceListMode       = FALSE;
    _tcsncpy(pArgs->DShowItemList.szImagesDirectory,
             pszImagesDirectory,
             sizeof(pArgs->DShowItemList.szImagesDirectory) / sizeof(TCHAR));

    LOCAL_GVAR.bExitThread = FALSE;
    LOCAL_GVAR.hItemListThread = CreateThread(NULL, 0, ItemListThreadProc,
                                              (void*) pArgs,
                                              0, &dwThreadID);

    return hr;
}


///////////////////////////////
// ImageLst_Clear
//
HRESULT ImageLst_Clear()
{
    HRESULT hr = S_OK;

    //
    // Clear the New Image List
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_NEW_IMAGES,
                       LB_RESETCONTENT,
                       0,
                       0);

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    return hr;
}

///////////////////////////////
// ImageLst_CancelLoadAndWait
//
HRESULT ImageLst_CancelLoadAndWait(DWORD dwTimeout)
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.hItemListThread)
    {
        LOCAL_GVAR.bExitThread = TRUE;
        WaitForSingleObject(LOCAL_GVAR.hItemListThread, dwTimeout);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <tchar.h>
#include "wia.h"
#include "wiavideo.h"
#include "resource.h"
#include "apputil.h"
#include "WiaProc.h"
#include "ImageLst.h"
#include "VideoProc.h"
#include "wiaevent.h"
#include "vcamprop.h"


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClientApp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\videoproc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       VideoProc.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Maintains the WiaVideo object
 *
 *****************************************************************************/
#ifndef _VIDEOPROC_H_
#define _VIDEOPROC_H_

HRESULT     VideoProc_Init();
HRESULT     VideoProc_Term();
HRESULT VideoProc_DShowListInit();
HRESULT VideoProc_DShowListTerm();
UINT_PTR    VideoProc_ProcessMsg(UINT   uiControlID);
HRESULT     VideoProc_TakePicture();
void        VideoProc_IncNumPicsTaken();



#endif // _VIDEOPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\videoproc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       VideoProc.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages WiaVideo object.
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>
#include <streams.h>
#include <mmreg.h>
#include "wiavideotest.h"

///////////////////////////////
// LOCAL_GVAR
//
static struct
{
    IWiaVideo           *pWiaVideo;
    BOOL                bPreviewVisible;
    INT                 iNumThreads;
    UINT                uiNumImagesPerThread;
    UINT                uiTakePictureInterval;
    BOOL                bExitThreads;
    BOOL                bVideoStretched;
} LOCAL_GVAR = 
{
    NULL,
    TRUE,
    0,
    0,
    0,
    FALSE,
    FALSE
};

///////////////////////////////
// ThreadArgs_t
//
typedef struct ThreadArgs_t
{
    UINT uiNumPicturesToTake;
    UINT uiThreadSleepTime;     // if 0, calc'd as a random number.
} ThreadArgs_t;


/****************************Local Function Prototypes********************/
HRESULT CreateWiaVideoObject();
HRESULT CreateVideoEnumPos();
HRESULT CreateVideoFriendlyName();
HRESULT CreateVideoWia();
HRESULT DestroyVideo();
HRESULT Play();
HRESULT Pause();
HRESULT TakePicture(BOOL bTakePictureThroughDriver);
HRESULT ShowVideo();
HRESULT ResizeVideo(BOOL bStretchToFitWindow);
HRESULT ShowCurrentState();
HRESULT TakePictureMultiple();
HRESULT TakePictureStress();
DWORD WINAPI TakePictureThreadProc(void *pArgs);
INT_PTR CALLBACK MultipleDlgProc(HWND     hDlg,
                                 UINT     message,
                                 WPARAM   wParam,
                                 LPARAM   lParam);
INT_PTR CALLBACK StressDlgProc(HWND     hDlg,
                               UINT     message,
                               WPARAM   wParam,
                               LPARAM   lParam);

BOOL GetDeviceProperty(IPropertyBag         *pPropertyBag,
                       LPCWSTR              pwszProperty,
                       TCHAR                *pszProperty,
                       DWORD                cchProperty);


///////////////////////////////
// VideoProc_Init
//
HRESULT VideoProc_Init()
{
    HRESULT hr = S_OK;

    hr = CreateWiaVideoObject();

    return hr;
}

///////////////////////////////
// VideoProc_Term
//
HRESULT VideoProc_Term()
{
    HRESULT hr = S_OK;

    LOCAL_GVAR.bExitThreads = TRUE;

    //
    // Crude, but for a test app, it is easier than creating an
    // array of thread handles and waiting for each one to finish.
    //
    INT iLoops = 0;
    while ((LOCAL_GVAR.iNumThreads > 0) && (iLoops < 50))
    {
        ++iLoops;
        Sleep(100);
    }

    DestroyVideo();

    if (LOCAL_GVAR.pWiaVideo)
    {
        LOCAL_GVAR.pWiaVideo->Release();
        LOCAL_GVAR.pWiaVideo = NULL;
    }

    return hr;
}

///////////////////////////////
// VideoProc_DShowListInit
//
HRESULT VideoProc_DShowListInit()
{
    HRESULT                 hr = S_OK;
    LONG                    lPosNum = 0;
    ICreateDevEnum          *pCreateDevEnum = NULL;
    IEnumMoniker            *pEnumMoniker   = NULL;

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    if (hr == S_OK)
    {
    
        // 
        // Create the device enumerator
        //
        hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum,
                              (void**)&pCreateDevEnum);
    }

    if (hr == S_OK)
    {
        hr = pCreateDevEnum->CreateClassEnumerator(
                                            CLSID_VideoInputDeviceCategory,
                                            &pEnumMoniker,
                                            0);
    }

    //
    // Loop through all the devices
    //

    while (hr == S_OK)
    {
        TCHAR                   szFriendlyName[255 + 1] = {0};
        IMoniker                *pMoniker       = NULL;
        IPropertyBag            *pPropertyBag   = NULL;

        hr = pEnumMoniker->Next(1, &pMoniker, NULL);

        if (hr == S_OK)
        {
            //
            // Get property storage for this DS device so we can get it's
            // device id...
            //
    
            hr = pMoniker->BindToStorage(0, 
                                         0,
                                         IID_IPropertyBag,
                                         (void **)&pPropertyBag);
        }

        if (hr == S_OK)
        {
            hr = GetDeviceProperty(pPropertyBag, 
                                   L"FriendlyName",
                                   szFriendlyName,
                                   sizeof(szFriendlyName) / sizeof(TCHAR));
        }

        if (hr == S_OK)
        {
            SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                               IDC_LIST_WIA_DEVICES,
                               LB_ADDSTRING,
                               0, 
                               (LPARAM) szFriendlyName);
        }

        if (pMoniker)
        {
            pMoniker->Release();
            pMoniker = NULL;
        }

        if (pPropertyBag)
        {
            pPropertyBag->Release();
            pPropertyBag = NULL;
        }
    }

    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_WIA_DEVICES,
                       LB_SETCURSEL,
                       0,
                       0);

    if (pEnumMoniker)
    {
        pEnumMoniker->Release();
        pEnumMoniker = NULL;
    }

    if (pCreateDevEnum)
    {
        pCreateDevEnum->Release();
        pCreateDevEnum = NULL;
    }

    return hr;
}

///////////////////////////////
// VideoProc_DShowListTerm
//
HRESULT VideoProc_DShowListTerm()
{
    HRESULT hr = S_OK;

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    return hr;
}



///////////////////////////////
// VideoProc_TakePicture
//
HRESULT VideoProc_TakePicture()
{
    HRESULT hr = S_OK;

    hr = TakePicture(FALSE);

    return hr;
}


///////////////////////////////
// VideoProc_ProcessMsg
//
UINT_PTR VideoProc_ProcessMsg(UINT   uiControlID)
{
    HRESULT     hr = S_OK;
    UINT_PTR    uiReturn = 0;

    switch (uiControlID)
    {
        case IDC_BUTTON_CREATE_VIDEO_WIA:
            hr = CreateVideoWia();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_CREATE_VIDEO_ENUM_POS:
            hr = CreateVideoEnumPos();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME:
            hr = CreateVideoFriendlyName();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_TAKE_PICTURE_STRESS:
            TakePictureStress();
        break;

        case IDC_BUTTON_TAKE_PICTURE_MULTIPLE:
            TakePictureMultiple();
        break;

        case IDC_BUTTON_DESTROY_VIDEO:
            SetCursor( LoadCursor(NULL, IDC_WAIT));

            DestroyVideo();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), TRUE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), TRUE);

            SetCursor( LoadCursor(NULL, IDC_ARROW));
        break;

        case IDC_BUTTON_PLAY:
            Play();
        break;

        case IDC_BUTTON_PAUSE:
            Pause();
        break;

        case IDC_BUTTON_TAKE_PICTURE:
            TakePicture(FALSE);
        break;

        case IDC_BUTTON_TAKE_PICTURE_DRIVER:
            TakePicture(TRUE);
        break;

        case IDC_BUTTON_SHOW_VIDEO_TOGGLE:
            ShowVideo();
        break;

        case IDC_BUTTON_RESIZE_TOGGLE:
            LOCAL_GVAR.bVideoStretched = (LOCAL_GVAR.bVideoStretched ? FALSE : TRUE);
            ResizeVideo(LOCAL_GVAR.bVideoStretched);
        break;

        default:
        break;

    }

    ShowCurrentState();

    return uiReturn;
}

///////////////////////////////
// CreateVideoWia
//
HRESULT CreateVideoWia()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szDeviceID[MAX_PATH]        = {0};
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    BSTR            bstrImagesDir               = NULL;
    BSTR            bstrDeviceID                = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR,
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    //
    // We need to do this first, otherwise the driver is not loaded yet,
    // and therefore the images directory property will have not been set
    //
    if (hr == S_OK)
    {
        hr = WiaProc_CreateSelectedDevice(szDeviceID,
                                          sizeof(szDeviceID) / sizeof(TCHAR));
    }

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //
    if (hr == S_OK)
    {
        hr = WiaProc_GetImageDirectory(szImagesDirectory,
                                       sizeof(szImagesDirectory) / sizeof(TCHAR));
    }

    if (hr == S_OK)
    {
        WCHAR wszDeviceID[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szDeviceID, wszDeviceID,
                                    sizeof(wszDeviceID) / sizeof(WCHAR));


        bstrDeviceID = ::SysAllocString(wszDeviceID);
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir,
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Create Video.
    //
    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByWiaDevID(bstrDeviceID,
                                                         GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                    IDC_VIDEO_PREVIEW_WINDOW),
                                                         FALSE,
                                                         TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = WiaProc_PopulateItemList();
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    if (bstrDeviceID)
    {
        ::SysFreeString(bstrDeviceID);
        bstrDeviceID = NULL;
    }

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR,
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// CreateVideoEnumPos
//
HRESULT CreateVideoEnumPos()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    TCHAR           szFriendlyName[255 + 1]     = {0};
    BSTR            bstrImagesDir               = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    WPARAM Index = (WPARAM) lResult;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETTEXT,
                                 Index,
                                 (LPARAM) szFriendlyName);

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //

    TCHAR szTempPath[MAX_PATH] = {0};

    if (hr == S_OK)
    {
        GetTempPath(MAX_PATH, szTempPath);
        _sntprintf(szImagesDirectory, sizeof(szImagesDirectory) / sizeof(TCHAR),
                   TEXT("%s\\WiaVideoTest\\%s"), szTempPath, szFriendlyName);
                   
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir, 
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Create Video.
    // 
    if (hr == S_OK)
    {
        UINT uiDeviceNumber = (UINT) Index;

        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByDevNum(uiDeviceNumber,
                                                       GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                  IDC_VIDEO_PREVIEW_WINDOW),
                                                       FALSE,
                                                       TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = ImageLst_PopulateDShowItemList(szImagesDirectory);
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// CreateVideoFriendlyName
//
HRESULT CreateVideoFriendlyName()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    TCHAR           szFriendlyName[255 + 1]     = {0};
    BSTR            bstrFriendlyName            = NULL;
    BSTR            bstrImagesDir               = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    WPARAM Index = (WPARAM) lResult;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETTEXT,
                                 Index,
                                 (LPARAM) szFriendlyName);

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //

    TCHAR szTempPath[MAX_PATH] = {0};

    if (hr == S_OK)
    {
        GetTempPath(MAX_PATH, szTempPath);
        _sntprintf(szImagesDirectory, sizeof(szImagesDirectory) / sizeof(TCHAR),
                   TEXT("%s\\WiaVideoTest\\%s"), szTempPath, szFriendlyName);
                   
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir, 
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszFriendlyName[255 + 1] = {0};

        AppUtil_ConvertToWideString(szFriendlyName, wszFriendlyName, 
                                    sizeof(wszFriendlyName) / sizeof(WCHAR));

        bstrFriendlyName = ::SysAllocString(wszFriendlyName);
    }

    //
    // Create Video.
    // 
    if (hr == S_OK)
    {
        UINT uiDeviceNumber = (UINT) lResult;

        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByName(bstrFriendlyName,
                                                     GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                IDC_VIDEO_PREVIEW_WINDOW),
                                                     FALSE,
                                                     TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = ImageLst_PopulateDShowItemList(szImagesDirectory);
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    if (bstrFriendlyName)
    {
        ::SysFreeString(bstrFriendlyName);
        bstrFriendlyName = NULL;
    }


    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
HRESULT DestroyVideo()
{
    HRESULT hr = S_OK;
    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->DestroyVideo();

    if (APP_GVAR.bWiaDeviceListMode)
    {
        hr = WiaProc_DestroySelectedDevice();
        ImageLst_Clear();
    }
    else
    {
        ImageLst_Clear();
    }

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  0,
                  FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);


    return hr;
}

///////////////////////////////
// Play
//
HRESULT Play()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.pWiaVideo->Play();

    return hr;
}

///////////////////////////////
// Pause
//
HRESULT Pause()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.pWiaVideo->Pause();

    return hr;
}

///////////////////////////////
// TakePicture
//
HRESULT TakePicture(BOOL bTakePictureThroughDriver)
{
    HRESULT hr = S_OK;

    if (APP_GVAR.bWiaDeviceListMode)
    {
        if (bTakePictureThroughDriver)
        {
            //
            // send DeviceCommand to driver.  This is an async call for
            // the Wia Video Driver which means we will NOT receive a 
            // WiaItem object back.
            //
    
            hr = WiaProc_DeviceTakePicture();
        }
        else
        {
            if (LOCAL_GVAR.pWiaVideo)
            {
                BSTR bstrNewImage = NULL;
    
                hr = LOCAL_GVAR.pWiaVideo->TakePicture(&bstrNewImage);
    
                if (hr == S_OK)
                {
                    WiaProc_SetLastSavedImage(bstrNewImage);
                }
    
                if (bstrNewImage)
                {
                    ::SysFreeString(bstrNewImage);
                    bstrNewImage = NULL;
                }
            }
            else
            {
                hr = E_POINTER;
            }
    
        }
    }
    else
    {
        if (LOCAL_GVAR.pWiaVideo)
        {
            BSTR bstrNewImage = NULL;

            hr = LOCAL_GVAR.pWiaVideo->TakePicture(&bstrNewImage);

            if (hr == S_OK)
            {
                ImageLst_PostAddImageRequest(bstrNewImage);

                if (bstrNewImage)
                {
                    ::SysFreeString(bstrNewImage);
                    bstrNewImage = NULL;
                }
            }
        }
    }

    return hr;
}

///////////////////////////////
// ShowVideo
//
HRESULT ShowVideo()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    if (LOCAL_GVAR.bPreviewVisible)
    {
        LOCAL_GVAR.bPreviewVisible = FALSE;
    }
    else
    {
        LOCAL_GVAR.bPreviewVisible = TRUE;
    }

    hr = LOCAL_GVAR.pWiaVideo->put_PreviewVisible(LOCAL_GVAR.bPreviewVisible);

    return hr;
}

///////////////////////////////
// ResizeVideo
//
HRESULT ResizeVideo(BOOL bStretchToFitWindow)
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->ResizeVideo(bStretchToFitWindow);

    return hr;
}

///////////////////////////////
// ShowCurrentState
//
HRESULT ShowCurrentState()
{
    HRESULT         hr         = S_OK;
    WIAVIDEO_STATE  VideoState = WIAVIDEO_NO_VIDEO;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (hr == S_OK)
    {
        UINT  uiResID = 0;
        TCHAR szState[63 + 1] = {0};

        switch (VideoState)
        {
            case WIAVIDEO_NO_VIDEO:
                uiResID = IDS_NO_VIDEO;
            break;

            case WIAVIDEO_CREATING_VIDEO:
                uiResID = IDS_CREATING_VIDEO;
            break;

            case WIAVIDEO_VIDEO_CREATED:
                uiResID = IDS_VIDEO_CREATED;
            break;

            case WIAVIDEO_VIDEO_PLAYING:
                uiResID = IDS_PLAYING_VIDEO;
            break;

            case WIAVIDEO_VIDEO_PAUSED:
                uiResID = IDS_VIDEO_PAUSED;
            break;

            case WIAVIDEO_DESTROYING_VIDEO:
                uiResID = IDS_DESTROYING_VIDEO;
            break;

            default:
                uiResID = IDS_STATE_UNKNOWN;
            break;
        }

        LoadString(APP_GVAR.hInstance,
                   uiResID,
                   szState,
                   sizeof(szState) / sizeof(TCHAR));

        if (szState[0] != 0)
        {
            SetDlgItemText(APP_GVAR.hwndMainDlg,
                           IDC_EDIT_CURRENT_STATE,
                           szState);
        }
    }

    return hr;
}

///////////////////////////////
// CreateWiaVideoObject
//
HRESULT CreateWiaVideoObject()
{
    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        // Create the WiaVideo object
        hr = CoCreateInstance(CLSID_WiaVideo, NULL, CLSCTX_INPROC_SERVER,
                              IID_IWiaVideo, (LPVOID *)&LOCAL_GVAR.pWiaVideo);
    }

    return hr;
}

///////////////////////////////
// TakePictureStress
//
HRESULT TakePictureStress()
{
    HRESULT hr      = S_OK;
    INT_PTR iReturn = 0;

    //
    // Ask user how many threads to use and how many
    // pictures each thread should take.
    //

    LOCAL_GVAR.iNumThreads         = 0;
    LOCAL_GVAR.uiNumImagesPerThread = 0;

    iReturn = DialogBox(APP_GVAR.hInstance,
                        MAKEINTRESOURCE(IDD_STRESSDLG),
                        APP_GVAR.hwndMainDlg,
                        StressDlgProc);


    if (iReturn == IDOK)
    {
        SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                      LOCAL_GVAR.iNumThreads, FALSE);

        UINT uiNumThreads = (UINT) LOCAL_GVAR.iNumThreads;

        for (UINT i = 0; (i < uiNumThreads) && (hr == S_OK); i++)
        {
            ThreadArgs_t *pArgs = new ThreadArgs_t;

            if (pArgs)
            {
                DWORD dwThreadID = 0;

                ZeroMemory(pArgs, sizeof(ThreadArgs_t));

                pArgs->uiNumPicturesToTake = LOCAL_GVAR.uiNumImagesPerThread;
                pArgs->uiThreadSleepTime   = (rand() % 100) + 25;    // 25 - 125 ms sleeptime.

                CreateThread(NULL,
                             0,
                             TakePictureThreadProc,
                             (void*) pArgs,
                             0,
                             &dwThreadID);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;

}


///////////////////////////////
// StressDlgProc
//
// Mesage handler for Stress Dialog Box
//
INT_PTR CALLBACK StressDlgProc(HWND     hDlg,
                               UINT     message,
                               WPARAM   wParam,
                               LPARAM   lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;
        break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                BOOL bTranslated = TRUE;

                LOCAL_GVAR.iNumThreads = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_THREADS,
                                                        &bTranslated,
                                                        FALSE);

                LOCAL_GVAR.uiNumImagesPerThread = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_IMAGES_PER_THREAD,
                                                        &bTranslated,
                                                        FALSE);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

        break;
    }

    return FALSE;
}

///////////////////////////////
// TakePictureMultiple
//
HRESULT TakePictureMultiple()
{
    HRESULT hr      = S_OK;
    INT_PTR iReturn = 0;

    //
    // Ask user how many threads to use and how many
    // pictures each thread should take.
    //

    LOCAL_GVAR.iNumThreads         = 0;
    LOCAL_GVAR.uiNumImagesPerThread = 0;

    iReturn = DialogBox(APP_GVAR.hInstance,
                        MAKEINTRESOURCE(IDD_DIALOG_TAKE_PICTURE_MULTIPLE),
                        APP_GVAR.hwndMainDlg,
                        MultipleDlgProc);


    if (iReturn == IDOK)
    {
        SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                      1, FALSE);

        //
        // uiNumThreads should be 1.
        //
        UINT uiNumThreads = 1;

        for (UINT i = 0; i < uiNumThreads; i++)
        {
            ThreadArgs_t *pArgs = new ThreadArgs_t;

            if (pArgs)
            {
                ZeroMemory(pArgs, sizeof(ThreadArgs_t));
                pArgs->uiNumPicturesToTake = LOCAL_GVAR.uiNumImagesPerThread;
                pArgs->uiThreadSleepTime   = LOCAL_GVAR.uiTakePictureInterval;

                DWORD dwThreadID = 0;
    
                CreateThread(NULL, 
                             0, 
                             TakePictureThreadProc, 
                             (void*) pArgs,
                             0, 
                             &dwThreadID);
            }
        }
    }

    return hr;

}


///////////////////////////////
// MultipleDlgProc
//
// Mesage handler for Stress Dialog Box
//
INT_PTR CALLBACK MultipleDlgProc(HWND     hDlg,
                                 UINT     message,
                                 WPARAM   wParam,
                                 LPARAM   lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;
        break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                BOOL bTranslated = TRUE;

                LOCAL_GVAR.iNumThreads = 1;

                LOCAL_GVAR.uiNumImagesPerThread = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_PICTURES_TO_TAKE,
                                                        &bTranslated,
                                                        FALSE);

                LOCAL_GVAR.uiTakePictureInterval = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_TAKE_PICTURE_FREQUENCY,
                                                        &bTranslated,
                                                        FALSE);

                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

        break;
    }

    return FALSE;
}

///////////////////////////////
// TakePictureThreadProc
//
DWORD WINAPI TakePictureThreadProc(void *pArgs)
{
    HRESULT hr                = S_OK;
    BOOL bDone                = FALSE;
    ThreadArgs_t *pThreadArgs = (ThreadArgs_t*) pArgs;

    if (pThreadArgs == NULL)
    {
        return E_POINTER;
    }

    UINT uiNumPicturesToTake = pThreadArgs->uiNumPicturesToTake;
    UINT uiSleepTime         = pThreadArgs->uiThreadSleepTime;
    UINT uiNumPicturesTaken  = 0;

    delete pThreadArgs;
    pThreadArgs = NULL;

    while (!bDone)
    {
        if ((LOCAL_GVAR.pWiaVideo    == NULL) ||
            (LOCAL_GVAR.bExitThreads == TRUE))
        {
            bDone = TRUE;
        }

        if (!bDone)
        {
            hr = TakePicture(FALSE);

            if (hr != S_OK)
            {
                bDone = TRUE;
            }

            Sleep(uiSleepTime);

            ++uiNumPicturesTaken;

            if (uiNumPicturesTaken >= uiNumPicturesToTake)
            {
                bDone = TRUE;
            }
        }
    }

    InterlockedDecrement((LONG*) &LOCAL_GVAR.iNumThreads);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                  LOCAL_GVAR.iNumThreads, FALSE);

    return 0;
}

///////////////////////////////
// GetDeviceProperty
//
// Static Fn
//
BOOL GetDeviceProperty(IPropertyBag         *pPropertyBag,
                       LPCWSTR              pwszProperty,
                       TCHAR                *pszProperty,
                       DWORD                cchProperty)
{
    HRESULT hr = S_OK;

    VARIANT VarName;

    if ((pPropertyBag == NULL) || 
        (pwszProperty == NULL) ||
        (pszProperty  == NULL))
    {
        hr = E_POINTER;
    }
    
    if (SUCCEEDED(hr))
    {
        VariantInit(&VarName);
        VarName.vt = VT_BSTR;
        hr = pPropertyBag->Read(pwszProperty, &VarName, 0);
    }

    if (SUCCEEDED(hr))
    {
        hr = AppUtil_ConvertToTCHAR(VarName.bstrVal,
                                    pszProperty,
                                    cchProperty);

        VariantClear(&VarName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiavideotest
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMENTRY=winmain

INCLUDES=$(INCLUDES); \
        $(BASEDIR)\public\sdk\amovie\inc;

SOURCES= \
        ..\wiavideotest.cpp \
        ..\wiaproc.cpp      \
        ..\videoproc.cpp    \
	..\imagelst.cpp     \
        ..\apputil.cpp      \
        ..\wiaevent.cpp     \
        ..\wiavideotest.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

!if ("$(NTDEBUG)" == "") || ("$(NTDEBUG)" == "ntsdnodbg")
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbase.lib
!ELSE
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbasd.lib
!ENDIF

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\comctl32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiaevent.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaEvent.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Implements callback for receiving WIA events.
 *
 *****************************************************************************/
#ifndef _WIAEVENT_H_
#define _WIAEVENT_H_

class CWiaEvent : public IWiaEventCallback
{
public:
    CWiaEvent();
    ~CWiaEvent();

    // IUnknown
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObject );
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWiaEventCallback
    STDMETHODIMP ImageEventCallback(const GUID  *pEventGUID, 
                                    BSTR        bstrEventDescription, 
                                    BSTR        bstrDeviceID, 
                                    BSTR        bstrDeviceDescription, 
                                    DWORD       dwDeviceType, 
                                    BSTR        bstrFullItemName, 
                                    ULONG       *pulEventType, 
                                    ULONG       ulReserved);

    static HRESULT RegisterForWiaEvent(LPCWSTR pwszDeviceId, 
                                       const GUID &guidEvent, 
                                       IUnknown **ppUnknown);

private:
    LONG m_cRef;

};

#endif //_WIAEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiaevent.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaEvent.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Implements callback for receiving WIA events.
 *
 *****************************************************************************/
#include <stdafx.h>

#include "wiavideotest.h"

///////////////////////////////
// Constructor
//
CWiaEvent::CWiaEvent(void) :
    m_cRef(0)
{
}

///////////////////////////////
// Destructor
//
CWiaEvent::~CWiaEvent(void)
{
}

///////////////////////////////
// QueryInterface
//
STDMETHODIMP CWiaEvent::QueryInterface(REFIID riid, 
                                       LPVOID *ppvObject )
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else if (IsEqualIID(riid, IID_IWiaEventCallback))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();

    return S_OK;
}


///////////////////////////////
// AddRef
//
STDMETHODIMP_(ULONG) CWiaEvent::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

///////////////////////////////
// Release
//
STDMETHODIMP_(ULONG) CWiaEvent::Release(void)
{
    LONG nRefCount = InterlockedDecrement(&m_cRef);

    if (!nRefCount)
    {
        delete this;
    }

    return nRefCount;
}

///////////////////////////////
// ImageEventCallback
//
STDMETHODIMP CWiaEvent::ImageEventCallback(const GUID   *pEventGUID, 
                                           BSTR         bstrEventDescription, 
                                           BSTR         bstrDeviceID, 
                                           BSTR         bstrDeviceDescription, 
                                           DWORD        dwDeviceType, 
                                           BSTR         bstrFullItemName, 
                                           ULONG        *pulEventType, 
                                           ULONG        ulReserved)
{
    HRESULT hr = S_OK;

    if (pEventGUID == NULL)
    {
        return E_POINTER;
    }

    if (IsEqualIID(*pEventGUID, WIA_EVENT_ITEM_CREATED))
    {
        hr = ImageLst_PostAddImageRequest(bstrFullItemName);
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_ITEM_DELETED))
    {
        // do nothing for now.
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_DEVICE_CONNECTED))
    {
        WiaProc_PopulateDeviceList();
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_DEVICE_DISCONNECTED))
    {
        //
        // Simulate a push of the DestroyVideo Button.
        //
        VideoProc_ProcessMsg(IDC_BUTTON_DESTROY_VIDEO);

        AppUtil_MsgBox(IDS_DISCONNECTED, IDS_VIDEO_STREAM_SHUTDOWN,
                       MB_OK | MB_ICONINFORMATION);

        WiaProc_PopulateDeviceList();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\afilter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    afilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

    Alireza Dabagh creation-date 3-22-1993, mostly borrowed from efilter.h

Revision History:

--*/

#ifndef _ARC_FILTER_DEFS_
#define _ARC_FILTER_DEFS_

//
// Number of Ndis buffers in the buffer pool
//
#define ARC_RECEIVE_BUFFERS 64

//
// Linked list Structure for keeping track of allocated memory so we can free them later
//
typedef struct _ARC_BUFFER_LIST
{
    PVOID                   Buffer;
    UINT                    Size;
    UINT                    BytesLeft;
    struct _ARC_BUFFER_LIST *Next;
} ARC_BUFFER_LIST, *PARC_BUFFER_LIST;

//
// This is the structure that is passed to the protocol as the packet
// header during receive indication. It is also the header expected from the protocol.
// This header is NOT the same as the header passed to the mac driver
//

#define ARCNET_ADDRESS_LEN                   1

typedef struct _ARC_PROTOCOL_HEADER
{
    UCHAR                   SourceId[ARCNET_ADDRESS_LEN];   // Source Address
    UCHAR                   DestId[ARCNET_ADDRESS_LEN];     // Destination Address
    UCHAR                   ProtId;                         // Protocol ID
} ARC_PROTOCOL_HEADER, *PARC_PROTOCOL_HEADER;

//
// This structure keeps track of information about a received packet
//
typedef struct _ARC_PACKET_HEADER
{
    ARC_PROTOCOL_HEADER     ProtHeader;         // Protocol header
    USHORT                  FrameSequence;      // Frame sequence Number
    UCHAR                   SplitFlag;          // Split flag
    UCHAR                   LastSplitFlag;      // Split Flag for the last frame
    UCHAR                   FramesReceived;     // Frames in This Packet
} ARC_PACKET_HEADER, * PARC_PACKET_HEADER;

//
// Arcnet specific packet header
//
typedef struct _ARC_PACKET
{
    ARC_PACKET_HEADER       Header;             // Information about the packet
    struct _ARC_PACKET *    Next;               // Next packet in use by filter
    ULONG                   TotalLength;
    BOOLEAN                 LastFrame;
    PARC_BUFFER_LIST        FirstBuffer;
    PARC_BUFFER_LIST        LastBuffer;
    NDIS_PACKET             TmpNdisPacket;
} ARC_PACKET, * PARC_PACKET;


#define ARC_PROTOCOL_HEADER_SIZE        (sizeof(ARC_PROTOCOL_HEADER))
#define ARC_MAX_FRAME_SIZE              504
#define ARC_MAX_ADDRESS_IDS             256
#define ARC_MAX_FRAME_HEADER_SIZE       6
#define ARC_MAX_PACKET_SIZE             576


//
// Check whether an address is broadcast.
//

#define ARC_IS_BROADCAST(Address) \
    (BOOLEAN)(!(Address))


typedef ULONG MASK,*PMASK;

//
// Maximum number of opens the filter package will support.  This is
// the max so that bit masks can be used instead of a spaghetti of
// pointers.
//
#define ARC_FILTER_MAX_OPENS (sizeof(ULONG) * 8)


//
// The binding info is threaded on two lists.  When
// the binding is free it is on a single freelist.
//
// When the binding is being used it is on an index list.
//
typedef struct _ARC_BINDING_INFO
{
    PNDIS_OPEN_BLOCK            NdisBindingHandle;
    PVOID                       Reserved;
    UINT                        PacketFilters;
    ULONG                       References;
    struct _ARC_BINDING_INFO *  NextOpen;
    BOOLEAN                     ReceivedAPacket;
    UINT                        OldPacketFilters;
} ARC_BINDING_INFO,*PARC_BINDING_INFO;

//
// An opaque type that contains a filter database.
// The MAC need not know how it is structured.
//
typedef struct _ARC_FILTER
{
    struct _NDIS_MINIPORT_BLOCK *Miniport;

    //
    // Combination of all the filters of all the open bindings.
    //
    UINT                CombinedPacketFilter;

    //
    // Pointer for traversing the open list.
    //
    PARC_BINDING_INFO   OpenList;

    //
    // Bit mask of opens that are available.
    //
    // ULONG FreeBindingMask;

    NDIS_HANDLE ReceiveBufferPool;

    PARC_BUFFER_LIST FreeBufferList;
    PARC_PACKET FreePackets;

    PARC_PACKET OutstandingPackets;

    //
    // Address of the adapter.
    //
    UCHAR   AdapterAddress;

    UINT    OldCombinedPacketFilter;

} ARC_FILTER,*PARC_FILTER;




//
//UINT
//ARC_QUERY_FILTER_CLASSES(
//  IN  PARC_FILTER             Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ARC_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//ARC_QUERY_PACKET_FILTER(
//  IN  ARC_FILTER              Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ARC_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PARC_BINDING_INFO)(NdisFilterHandle))->PacketFilters)

//
// Exported routines
//
DECLSPEC_DEPRECATED_DDK
BOOLEAN
ArcCreateFilter(
    IN  struct _NDIS_MINIPORT_BLOCK *Miniport,
    IN  UCHAR                   AdapterAddress,
    OUT PARC_FILTER *           Filter
    );

DECLSPEC_DEPRECATED_DDK
VOID
ArcDeleteFilter(
    IN  PARC_FILTER Filter
    );

DECLSPEC_DEPRECATED_DDK
BOOLEAN
ArcNoteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    );

DECLSPEC_DEPRECATED_DDK
NDIS_STATUS
ArcDeleteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );

DECLSPEC_DEPRECATED_DDK
NDIS_STATUS
ArcFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    );

DECLSPEC_DEPRECATED_DDK
VOID
ArcFilterDprIndicateReceiveComplete(
    IN  PARC_FILTER             Filter
    );

DECLSPEC_DEPRECATED_DDK
VOID
ArcFilterDprIndicateReceive(
    IN  PARC_FILTER             Filter,
    IN  PUCHAR                  pRawHeader,
    IN  PUCHAR                  pData,
    IN  UINT                    Length
    );

DECLSPEC_DEPRECATED_DDK
NDIS_STATUS
ArcFilterTransferData(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransfered
    );

DECLSPEC_DEPRECATED_DDK
VOID
ArcFreeNdisPacket(
    IN  PARC_PACKET             Packet
    );
    
DECLSPEC_DEPRECATED_DDK
VOID
ArcFilterDoIndication(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    );

VOID
ArcDestroyPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    );

#endif // _ARC_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\amtvuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//

//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
	#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// -------------------------------------------------------------------------
// TVTuner GUIDS
// -------------------------------------------------------------------------

// {266EEE40-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilter, 
0x266eee40, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilterPropertyPage, 
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE44-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_AnalogVideoStandard, 
0x266eee44, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE46-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_TunerInputType, 
0x266eee46, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);


// -------------------------------------------------------------------------
// Crossbar (XBar) GUIDS
// -------------------------------------------------------------------------

// {71F96460-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilter,
0x71f96460, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96462-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilter,
0x71f96462, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiaproc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaProc.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages Wia side of things
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>

#include "wiavideotest.h"

static struct 
{
    DWORD                   dwWiaDevMgrCookie;
    DWORD                   dwSelectedDeviceCookie;
    IUnknown                *pCreateCallback;
    IUnknown                *pDeleteCallback;
    IUnknown                *pDisconnectedCallback;
    IUnknown                *pConnectedCallback;
    IGlobalInterfaceTable   *pGIT;
    CRITICAL_SECTION        CritSec;
} LOCAL_GVAR = 
{
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    FALSE,
    NULL
};


/****************************Local Function Prototypes********************/
HRESULT ClearDeviceList();
HRESULT AddItemToList(IWiaPropertyStorage *pItem,
                      TCHAR               *pszFriendlyName,
                      TCHAR               *pszDeviceID);

WPARAM GetNumDevicesInList();

IWiaPropertyStorage* GetWiaStorage(WPARAM uiIndex);

HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr);

HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    LONG                *pnValue);

HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    TCHAR               *pszBuffer,
                    UINT                cbBuffer);

HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID,
                    const PROPVARIANT   *ppv, 
                    PROPID              nNameFirst);


HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                            WCHAR         *pwszString,
                            UINT          cchString);

HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                       TCHAR         *pszString,
                       UINT          cchString);

HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                       const TCHAR         *pszWiaDeviceID,
                       IWiaItem            **ppRootItem);

HRESULT RegisterForEvents(IWiaDevMgr *pDevMgr);



///////////////////////////////
// WiaProc_Init
//
HRESULT WiaProc_Init()
{
    HRESULT     hr          = S_OK;
    IWiaDevMgr  *pWiaDevMgr = NULL;

    if (LOCAL_GVAR.dwWiaDevMgrCookie != 0)
    {
        return S_OK;
    }

    __try 
    {
        if (!InitializeCriticalSectionAndSpinCount(&LOCAL_GVAR.CritSec, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        hr = E_OUTOFMEMORY;
    }

    if (hr == S_OK)
    {
        hr = CreateWiaDevMgr(&pWiaDevMgr);
    }

    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalInterfaceTable,
                              (void **)&LOCAL_GVAR.pGIT);
    }

    if (hr == S_OK)
    {
        LOCAL_GVAR.pGIT->RegisterInterfaceInGlobal(pWiaDevMgr, 
                                                   IID_IWiaDevMgr,
                                                   &LOCAL_GVAR.dwWiaDevMgrCookie);
    }

    if (hr == S_OK)
    {
        hr = RegisterForEvents(pWiaDevMgr);
    }

    if (hr == S_OK)
    {
        WiaProc_PopulateDeviceList();
    }

    if (pWiaDevMgr)
    {
        pWiaDevMgr->Release();
        pWiaDevMgr = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_Term
//
HRESULT WiaProc_Term()
{
    HRESULT hr = S_OK;

    ClearDeviceList();

    if (LOCAL_GVAR.dwSelectedDeviceCookie != 0)
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie);
        LOCAL_GVAR.dwSelectedDeviceCookie = 0;
    }

    if (LOCAL_GVAR.dwWiaDevMgrCookie != 0)
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie);
        LOCAL_GVAR.dwWiaDevMgrCookie = 0;

        DeleteCriticalSection(&LOCAL_GVAR.CritSec);
    }

    if (LOCAL_GVAR.pCreateCallback)
    {
        LOCAL_GVAR.pCreateCallback->Release();
        LOCAL_GVAR.pCreateCallback = NULL;
    }

    if (LOCAL_GVAR.pDeleteCallback)
    {
        LOCAL_GVAR.pDeleteCallback->Release();
        LOCAL_GVAR.pDeleteCallback = NULL;
    }

    if (LOCAL_GVAR.pConnectedCallback)
    {
        LOCAL_GVAR.pConnectedCallback->Release();
        LOCAL_GVAR.pConnectedCallback = NULL;
    }

    if (LOCAL_GVAR.pDisconnectedCallback)
    {
        LOCAL_GVAR.pDisconnectedCallback->Release();
        LOCAL_GVAR.pDisconnectedCallback = NULL;
    }

    if (LOCAL_GVAR.pGIT)
    {
        LOCAL_GVAR.pGIT->Release();
        LOCAL_GVAR.pGIT = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_CreateSelectedDevice
//
HRESULT WiaProc_CreateSelectedDevice(TCHAR  *pszDeviceID,
                                     UINT   cchDeviceID)
{
    HRESULT             hr                   = S_OK;
    WPARAM              Index                = 0;
    TCHAR               szDeviceID[MAX_PATH] = {0};
    IWiaDevMgr          *pWiaDevMgr          = NULL;

    if ((LOCAL_GVAR.dwWiaDevMgrCookie == 0) ||
        (LOCAL_GVAR.pGIT              == NULL))
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie,
                                                 IID_IWiaDevMgr,
                                                 (void**)&pWiaDevMgr);

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    Index = (WPARAM) lResult;

    if (Index == LB_ERR)
    {
        hr = E_FAIL;
    }

    if (hr == S_OK)
    {
        IWiaItem    *pSelectedDevice = NULL;
        LPARAM      lParam           = 0;

        lParam = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                    IDC_LIST_WIA_DEVICES,
                                    LB_GETITEMDATA,
                                    Index,
                                    0);

        IWiaPropertyStorage *pItem = (IWiaPropertyStorage*)lParam;

        if (pItem)
        {

            hr = GetProperty(pItem, WIA_DIP_DEV_ID, szDeviceID, 
                             sizeof(szDeviceID)/sizeof(TCHAR));

            if (hr == S_OK)
            {
                hr = CreateRootItem(pWiaDevMgr,
                                    szDeviceID,
                                    &pSelectedDevice);
            }

            if (hr == S_OK)
            {
                hr = LOCAL_GVAR.pGIT->RegisterInterfaceInGlobal(pSelectedDevice,
                                                                IID_IWiaItem,
                                                                &LOCAL_GVAR.dwSelectedDeviceCookie);
            }

            if (pszDeviceID)
            {
                _tcsncpy(pszDeviceID, szDeviceID, cchDeviceID);
            }

            if (pSelectedDevice)
            {
                pSelectedDevice->Release();
                pSelectedDevice = NULL;
            }
        }
    }

    if (pWiaDevMgr)
    {
        pWiaDevMgr->Release();
        pWiaDevMgr = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_GetImageDirectory
//
HRESULT WiaProc_GetImageDirectory(TCHAR *pszImageDirectory,
                                  UINT  cchImageDirectory)
{
    HRESULT             hr               = S_OK;
    IWiaPropertyStorage *pStorage        = NULL;
    IWiaItem            *pSelectedDevice = NULL;

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0)    ||
        (LOCAL_GVAR.pGIT                   == NULL) ||
        (pszImageDirectory                 == NULL))
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = pSelectedDevice->QueryInterface(IID_IWiaPropertyStorage,
                                             (void**) &pStorage);
    }

    if (hr == S_OK)
    {
        hr = GetProperty(pStorage, WIA_DPV_IMAGES_DIRECTORY, pszImageDirectory, 
                         cchImageDirectory);
    }

    if (pStorage)
    {
        pStorage->Release();
        pStorage = NULL;
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_DeviceTakePicture
//
HRESULT WiaProc_DeviceTakePicture()
{
    HRESULT     hr               = S_OK;
    IWiaItem    *pSelectedDevice = NULL;

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0) ||
        (LOCAL_GVAR.pGIT                   == NULL))
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        IWiaItem    *pUnused = NULL;
        hr = pSelectedDevice->DeviceCommand(0,
                                            &WIA_CMD_TAKE_PICTURE,
                                            &pUnused);

        if (pUnused)
        {
            pUnused->Release();
            pUnused = NULL;
        }
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    return hr;
}


///////////////////////////////
// ClearDeviceList
//
HRESULT ClearDeviceList()
{
    HRESULT hr = S_OK;
    WPARAM  NumDevices = 0;

    NumDevices = GetNumDevicesInList();

    //
    // Free all the IWiaItem pointers we saved in our 
    // list box.
    //
    if (NumDevices != LB_ERR)
    {
        for (WPARAM i = 0; i < NumDevices; i++)
        {
            IWiaPropertyStorage *pItem = NULL;

            pItem = GetWiaStorage(i);

            if (pItem)
            {
                pItem->Release();
            }
        }
    }

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    return hr;
}

///////////////////////////////
// WiaProc_PopulateDeviceList
//
HRESULT WiaProc_PopulateDeviceList()
{
    HRESULT           hr            = S_OK;
    IEnumWIA_DEV_INFO *pEnum        = NULL;
    IWiaDevMgr        *pWiaDevMgr   = NULL;

    hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie,
                                                 IID_IWiaDevMgr,
                                                 (void**)&pWiaDevMgr);

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    //
    // Clear out the device list if it has any items in it.
    //
    ClearDeviceList();

    if (hr == S_OK)
    {
        hr = pWiaDevMgr->EnumDeviceInfo(0, &pEnum);
    }

    while (hr == S_OK) 
    {
        IWiaItem             *pRootItem    = NULL;
        IWiaPropertyStorage  *pPropStorage = NULL;
        TCHAR                szFriendlyName[MAX_PATH + 1] = {0};
        TCHAR                szWiaDeviceID[MAX_PATH + 1]  = {0};

        //
        // Get the next device in the enumeration.
        //
        hr = pEnum->Next(1, &pPropStorage, NULL);

        //
        // Get the device's Wia Device ID
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_ID, szWiaDeviceID, 
                             sizeof(szWiaDeviceID)/sizeof(TCHAR));
        }

        //
        // Get the device's Wia Device Name
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_NAME, szFriendlyName, 
                             sizeof(szFriendlyName)/sizeof(TCHAR));
        }

        //
        // We do not relesae the propstorage item because we store the pointer
        // in our list until we shutdown the app.
        //

        if (hr == S_OK)
        {
            AddItemToList(pPropStorage, szFriendlyName, szWiaDeviceID);
        }
    }

    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_WIA_DEVICES,
                       LB_SETCURSEL,
                       0,
                       0);

    return hr;
}

///////////////////////////////
// RegisterForEvents
//
HRESULT RegisterForEvents(IWiaDevMgr    *pWiaDevMgr)
{
    HRESULT             hr          = S_OK;
    CWiaEvent           *pWiaEvent  = NULL;
    IWiaEventCallback   *pIWiaEvent = NULL;

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    //
    // Register our callback events
    //
    if (hr == S_OK)
    {
        // create the WiaEvent
        pWiaEvent = new CWiaEvent();

        if (pWiaEvent == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (hr == S_OK)
    {
        hr = pWiaEvent->QueryInterface(IID_IWiaEventCallback, 
                                       (void**)&pIWiaEvent);
    }

    if (hr == S_OK)
    {
        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_DEVICE_CONNECTED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pConnectedCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_DEVICE_DISCONNECTED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pDisconnectedCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_ITEM_CREATED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pCreateCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_ITEM_DELETED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pDeleteCallback);
    }

    //
    // We don't need to delete pWiaEvent since we are releasing it.
    //
    if (pIWiaEvent)
    {
        pIWiaEvent->Release();
        pIWiaEvent = NULL;
    }

    return hr;
}


///////////////////////////////
// AddItemToList
//
HRESULT AddItemToList(IWiaPropertyStorage *pItem,
                      TCHAR               *pszFriendlyName,
                      TCHAR               *pszDeviceID)
{
    HRESULT hr = S_OK;
    WPARAM  Index = 0;

    if ((pItem           == NULL) ||
        (pszFriendlyName == NULL) ||
        (pszDeviceID     == NULL))
    {
        hr = E_POINTER;
        return hr;
    }

    TCHAR szNewItem[MAX_PATH * 2] = {0};

    _sntprintf(szNewItem, sizeof(szNewItem)/sizeof(TCHAR),
               TEXT("%s (%s)"), pszFriendlyName, pszDeviceID);

    LRESULT lResult = 0;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_ADDSTRING,
                                 0, 
                                 (LPARAM) szNewItem);

    Index = (WPARAM) lResult;
    
    //
    // pItem already has an AddRef on it.
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_SETITEMDATA,
                       Index, 
                       (LPARAM) pItem);

    return hr;
}


///////////////////////////////
// GetNumDevicesInList
//
WPARAM GetNumDevicesInList()
{
    LRESULT lResult = 0;
    WPARAM  NumItems = 0;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCOUNT,
                                 0, 
                                 0);

    NumItems = (WPARAM) lResult;

    return NumItems;
}

///////////////////////////////
// GetWiaStorage
//
IWiaPropertyStorage* GetWiaStorage(WPARAM Index)
{
    LPARAM                  lParam     = 0;
    IWiaPropertyStorage     *pItem     = NULL;

    lParam = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                IDC_LIST_WIA_DEVICES,
                                LB_GETITEMDATA,
                                Index, 
                                0);

    pItem = (IWiaPropertyStorage*)lParam;

    return pItem;
}

///////////////////////////////
// CreateWiaDevMgr
//
HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr)
{
    HRESULT hr = S_OK;

    if (ppDevMgr == NULL)
    {
        hr = E_POINTER;

        return hr;
    }

    hr = CoCreateInstance(CLSID_WiaDevMgr, 
                          NULL, 
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**) ppDevMgr);

    return hr;
}

///////////////////////////////
// WiaProc_GetProperty
//
// Generic
//
HRESULT WiaProc_GetProperty(IWiaPropertyStorage *pPropStorage, 
                            PROPID              nPropID,
                            PROPVARIANT         *pPropVar)
{
    HRESULT hr = S_OK;

    if ((pPropStorage == NULL) ||
        (pPropVar     == NULL))
    {
        hr = E_POINTER;
        return hr;
    }

    PropVariantInit(pPropVar);

    PROPSPEC ps = {0};

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (SUCCEEDED(hr))
    {
        hr = pPropStorage->ReadMultiple(1, &ps, pPropVar);
    }

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'long' properties
//
HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    LONG                *pnValue)
{
    HRESULT hr = S_OK;

    if ((pPropStorage == NULL) ||
        (pnValue      == NULL))
    {
        hr = E_POINTER;
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pnValue = 0;

    PropVariantInit(&pvPropValue);

    hr = WiaProc_GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_I4) || 
            (pvPropValue.vt == VT_UI4))
        {
            *pnValue = pvPropValue.lVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'string' properties
//
HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    TCHAR               *pszBuffer,
                    UINT                cbBuffer)
{
    HRESULT hr = S_OK;

    if ((pPropStorage      == NULL) ||
        (pszBuffer         == NULL))
    {
        hr = E_POINTER;
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    PropVariantInit(&pvPropValue);

    hr = WiaProc_GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_LPWSTR) || 
            (pvPropValue.vt == VT_BSTR))
        {
            AppUtil_ConvertToTCHAR(pvPropValue.pwszVal, pszBuffer, cbBuffer);
        }
    }

    //
    // This frees the BSTR
    //
    PropVariantClear(&pvPropValue);

    return hr;
}



///////////////////////////////
// CreateRootItem
//
HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                       const TCHAR         *pszWiaDeviceID,
                       IWiaItem            **ppRootItem)
{
    HRESULT hr = S_OK;

    if ((pDevMgr         == NULL) ||
        (pszWiaDeviceID  == NULL) ||
        (ppRootItem      == NULL))
    {
        hr = E_POINTER;

        return hr;
    }

    if (hr == S_OK)
    {
        BOOL bRetry = TRUE;

        BSTR bstrDeviceID = NULL;
        WCHAR wszWiaDeviceID[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(pszWiaDeviceID, wszWiaDeviceID,
                            sizeof(wszWiaDeviceID) / sizeof(WCHAR));

        bstrDeviceID = SysAllocString(wszWiaDeviceID);

        for (UINT uiRetryCount = 0;
             (uiRetryCount < 5) && (bRetry);
             ++uiRetryCount)
        {

            hr = pDevMgr->CreateDevice(bstrDeviceID,
                                       ppRootItem);

            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = FALSE;
            }
            else if (hr == WIA_ERROR_BUSY)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(200);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = FALSE;
            }
        }

        if (bstrDeviceID)
        {
            SysFreeString(bstrDeviceID);
            bstrDeviceID = NULL;
        }
    }

    return hr;
}

///////////////////////////////
// SetProperty
//
// Generic
//
HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID,
                    const PROPVARIANT   *ppv, 
                    PROPID              nNameFirst)
{
    HRESULT  hr = 0;
    PROPSPEC ps = {0};

    if ((pPropStorage == NULL) ||
        (ppv          == NULL))
    {
        return E_POINTER;
    }

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (hr == S_OK)
    {
        hr = pPropStorage->WriteMultiple(1, &ps, ppv, nNameFirst);
    }

    return hr;
}

///////////////////////////////
// WiaProc_SetLastSavedImage
//
// For 'string' properties
//
HRESULT WiaProc_SetLastSavedImage(BSTR bstrLastSavedImage)
{
    HRESULT             hr               = S_OK;
    IWiaItem            *pSelectedDevice = NULL;
    IWiaPropertyStorage *pStorage        = NULL;
    PROPVARIANT         pv = {0};

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0) ||
        (LOCAL_GVAR.pGIT                   == NULL))
    {
        return E_POINTER;
    }

    EnterCriticalSection(&LOCAL_GVAR.CritSec);

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = pSelectedDevice->QueryInterface(IID_IWiaPropertyStorage, 
                                             (void**)&pStorage);
    }

    if (hr == S_OK)
    {
        PropVariantInit(&pv);

        pv.vt        = VT_BSTR;
        pv.bstrVal   = bstrLastSavedImage;

        hr = SetProperty(pStorage, WIA_DPV_LAST_PICTURE_TAKEN, &pv, 2);
    }

    if (pStorage)
    {
        pStorage->Release();
        pStorage = NULL;
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    LeaveCriticalSection(&LOCAL_GVAR.CritSec);

    return hr;
}

///////////////////////////////
// WiaProc_PopulateItemList
//
HRESULT WiaProc_PopulateItemList()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.dwSelectedDeviceCookie == 0)
    {
        return E_POINTER;
    }

    hr = ImageLst_PopulateWiaItemList(LOCAL_GVAR.pGIT,
                                      LOCAL_GVAR.dwSelectedDeviceCookie);

    return hr;
}

///////////////////////////////
// WiaProc_DestroySelectedDevice
//
HRESULT WiaProc_DestroySelectedDevice()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.dwSelectedDeviceCookie == 0)
    {
        return E_POINTER;
    }

    ImageLst_CancelLoadAndWait(5000);

    if ((LOCAL_GVAR.dwSelectedDeviceCookie != 0) &&
        (LOCAL_GVAR.pGIT                   != NULL))
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie);
        LOCAL_GVAR.dwSelectedDeviceCookie = 0;
    }

    ImageLst_Clear();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiavideotest.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideoTest.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Creates the dialog used by the app
 *
 *****************************************************************************/
#ifndef _WIAVIDEOTEST_H_
#define _WIAVIDEOTEST_H_

///////////////////////////////
// APP_GVAR
//
// Global variables used across
// the application.
//
// If INCL_APP_GVAR_OWNERSHIP is NOT defined 
// by the CPP file including this header, then 
// this struct will be "extern" to them. WiaVideoTest.cpp 
// defines INCL_APP_GVAR_OWNERSHIP, in which case it will not
// be extern'd to it.
//
#ifndef INCL_APP_GVAR_OWNERSHIP
extern
#endif
struct
{
    HINSTANCE   hInstance;
    HWND        hwndMainDlg;
    BOOL        bWiaDeviceListMode; // TRUE if WIA Device List radio button is selected, FALSE otherwise
} APP_GVAR;

#endif // _WIAVIDEOTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiaproc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaProc.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Handles WIA side of things
 *
 *****************************************************************************/
#ifndef _WIAPROC_H_
#define _WIAPROC_H_

#define WM_CUSTOM_ADD_IMAGE     WM_USER + 101

HRESULT WiaProc_Init();
HRESULT WiaProc_Term();

HRESULT WiaProc_CreateSelectedDevice(TCHAR  *pszDeviceID,
                                     UINT   cchDeviceID);

HRESULT WiaProc_PopulateDeviceList();
HRESULT WiaProc_PopulateItemList();

HRESULT WiaProc_DestroySelectedDevice();

HRESULT WiaProc_GetImageDirectory(TCHAR *pszImageDirectory,
                                  UINT  cchImageDirectory);

HRESULT WiaProc_DeviceTakePicture();

HRESULT WiaProc_SetLastSavedImage(BSTR bstrLastSavedImage);

HRESULT WiaProc_GetProperty(IWiaPropertyStorage *pPropStorage, 
                            PROPID              nPropID,
                            PROPVARIANT         *pPropVar);



#endif // _WIAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\wiavideotest\wiavideotest.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideoTest.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Creates the dialog used by the app
 *
 *****************************************************************************/
 
#include <stdafx.h>

#define INCL_APP_GVAR_OWNERSHIP 
#include "WiaVideoTest.h"

///////////////////////////////
// Constants
//
const UINT WM_CUSTOM_INIT = WM_USER + 100;


/****************************Local Function Prototypes********************/

INT_PTR CALLBACK MainDlgProc(HWND   hDlg, 
                             UINT   uiMessage, 
                             WPARAM wParam, 
                             LPARAM lParam);

INT_PTR  ProcessWMCommand(HWND   hWnd,
                          UINT   uiMessage, 
                          WPARAM wParam,
                          LPARAM lParam);

INT_PTR  ProcessWMNotify(HWND   hWnd,
                         UINT   uiMessage, 
                         WPARAM wParam,
                         LPARAM lParam);

BOOL InitApp(HINSTANCE hInstance);
void TermApp(void);
BOOL InitInstance(HINSTANCE    hInstance, 
                  int          nCmdShow);

void InitDlg(HWND hwndDlg);
void TermDlg(HWND hwndDlg);


int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpCmdLine,
                   int       nCmdShow);

///////////////////////////////
// WinMain
//
int WINAPI WinMain(HINSTANCE  hInstance,
                   HINSTANCE  hPrevInstance,
                   LPSTR      lpCmdLine,
                   int        nCmdShow)
{
    MSG          msg;
    BOOL         bSuccess       = TRUE;
    TCHAR        *pszBaseDir    = NULL;
    INITCOMMONCONTROLSEX    CommonControls = {0};

    lpCmdLine     = lpCmdLine; 
    hPrevInstance = hPrevInstance;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    CommonControls.dwSize = sizeof(CommonControls);
    CommonControls.dwICC  = ICC_WIN95_CLASSES;

    bSuccess = InitCommonControlsEx(&CommonControls);

    if (bSuccess)
    {
        bSuccess =InitApp(hInstance);
    }

    if (bSuccess)
    {
         // create the window
        bSuccess = InitInstance(hInstance, nCmdShow);
    }

    if (bSuccess)
    {
        while (GetMessage(&msg, NULL, 0, 0)) 
        {    
            if ((APP_GVAR.hwndMainDlg == NULL) || 
                (!IsDialogMessage(APP_GVAR.hwndMainDlg, &msg)))
            {
                 TranslateMessage(&msg);
                 DispatchMessage(&msg);
            }
        }    
    }

   // Terminate the application.
   TermApp();

   CoUninitialize();

   return 0;
}


///////////////////////////////
//  InitApp(HANDLE)
//
//  Initializes window data and 
//  registers window class
//
BOOL InitApp(HINSTANCE hInstance)
{
    BOOL       bSuccess = TRUE;
    WNDCLASSEX wc;

    if (bSuccess)
    {
        // Fill in window class structure with parameters that describe
        // the main window.

        wc.style         = 0;
        wc.cbSize        = sizeof(wc);
        wc.lpfnWndProc   = MainDlgProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = DLGWINDOWEXTRA;
        wc.hInstance     = hInstance;
        wc.hIcon         = NULL;
        wc.hIconSm       = NULL;
        wc.hCursor       = 0;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = 0;
        wc.lpszClassName = TEXT("WIAVIDEOTEST");
    }

    if (bSuccess)
    {
        RegisterClassEx(&wc);
    }

    return bSuccess;
}

///////////////////////////////
// InitInstance(HANDLE, int)
//
// Saves instance handle and
// creates main window
//
BOOL InitInstance(HINSTANCE hInstance, 
                  int       nCmdShow)
{
    BOOL    bSuccess  = TRUE;
    HWND    hwnd      = NULL;

    // create the window and all its controls.

    if (bSuccess)
    {
        // create a modeless dialog box.
        hwnd  = CreateDialog(hInstance,
                             MAKEINTRESOURCE(IDD_MAIN_DLG),
                             HWND_DESKTOP,
                             NULL);

        if (!hwnd) 
        {
            bSuccess = FALSE;
        }
    }

    if (bSuccess)
    {
        APP_GVAR.hwndMainDlg = hwnd;

        ShowWindow(hwnd, nCmdShow);
    }

    return bSuccess;
}

///////////////////////////////
//  InitDlg(HWND)
//
//  Initializes the main dlg 
//
void InitDlg(HWND hwndDlg)
{
    SetCursor( LoadCursor(NULL, IDC_WAIT));

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS, 
                  0, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN, 
                  0, FALSE);

    //
    // Set the WIA Device List Radio box to checked and the DShow 
    // Device List Radio box to unchecked.
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                       BM_SETCHECK, BST_CHECKED, 0);

    SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                       BM_SETCHECK, BST_UNCHECKED, 0);

    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), TRUE);
    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), FALSE);
    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), FALSE);

    //
    // initialize WiaProc_Init because by default we are in WIA Device List
    // Mode.
    //
    APP_GVAR.bWiaDeviceListMode = TRUE;

    WiaProc_Init();
    VideoProc_Init();

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    return;
}

///////////////////////////////
//  TermDlg(HWND)
//
void TermDlg(HWND hwndDlg)
{
    SetCursor( LoadCursor(NULL, IDC_WAIT));

    VideoProc_Term();
    WiaProc_Term();

    SetCursor( LoadCursor(NULL, IDC_ARROW));
}

///////////////////////////////
// TermApp
//
void TermApp(void)
{
}

//////////////////////////////////////////////////////////////////////
//  MainDlgProc
//
INT_PTR CALLBACK MainDlgProc(HWND   hDlg, 
                             UINT   uiMessage, 
                             WPARAM wParam, 
                             LPARAM lParam)
{
    INT_PTR     iReturn         = 0;

    switch (uiMessage) 
    {
        case WM_CREATE:
            PostMessage(hDlg,
                        WM_CUSTOM_INIT,
                        0,
                        0);
            return 0;
        break;

        case WM_CUSTOM_INIT:
            InitDlg(hDlg);
        break;

        //
        // Defined in WiaProc.h
        //
        case WM_CUSTOM_ADD_IMAGE:
            ImageLst_AddImageToList((BSTR)lParam);
        break;
    
        case WM_CLOSE:
            // terminate the dialog subsystems
            TermDlg(hDlg); 

            DestroyWindow(hDlg);
        break;
        
        case WM_DESTROY:
            // terminate the application
            PostQuitMessage(0);
        break;
       
        case WM_COMMAND:
            iReturn = ProcessWMCommand(hDlg,
                                       uiMessage,
                                       wParam,
                                       lParam);
        break;
  
        case WM_NOTIFY:
            iReturn = ProcessWMNotify(hDlg,
                                      uiMessage,
                                      wParam,
                                      lParam);
        break;

        default:
            iReturn = DefDlgProc(hDlg,
                                 uiMessage,
                                 wParam,
                                 lParam);
        break;
    }

    return iReturn;
}

///////////////////////////////
// ProcessWMCommand
//
//
INT_PTR ProcessWMCommand(HWND hWnd,
                         UINT uiMessage, 
                         WPARAM wParam,
                         LPARAM lParam)
{
   int      iId;
   int      iEvent;
   INT_PTR  iReturn = 0;

   iId    = LOWORD(wParam); 
   iEvent = HIWORD(wParam); 

   //Parse the menu selections:
   switch (iId) 
   {
       case IDC_BUTTON_CREATE_VIDEO_WIA:
       case IDC_BUTTON_CREATE_VIDEO_ENUM_POS:
       case IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME:
       case IDC_BUTTON_DESTROY_VIDEO:
       case IDC_BUTTON_PLAY:
       case IDC_BUTTON_PAUSE:
       case IDC_BUTTON_TAKE_PICTURE:
       case IDC_BUTTON_TAKE_PICTURE_DRIVER:
       case IDC_BUTTON_SHOW_VIDEO_TOGGLE:
       case IDC_BUTTON_RESIZE_TOGGLE:
       case IDC_BUTTON_TAKE_PICTURE_STRESS:
       case IDC_BUTTON_TAKE_PICTURE_MULTIPLE:

           VideoProc_ProcessMsg(iId);

       break;

       case IDC_RADIO_WIA_DEVICE_LIST:

           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), TRUE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), FALSE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), FALSE);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                              BM_SETCHECK, BST_CHECKED, 0);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                              BM_SETCHECK, BST_UNCHECKED, 0);

           APP_GVAR.bWiaDeviceListMode = TRUE;
           VideoProc_DShowListTerm();
           WiaProc_Init();
       break;

       case IDC_RADIO_DSHOW_DEVICE_LIST:

           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), FALSE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), TRUE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), TRUE);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                              BM_SETCHECK, BST_UNCHECKED, 0);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                              BM_SETCHECK, BST_CHECKED, 0);

           APP_GVAR.bWiaDeviceListMode = FALSE;
           WiaProc_Term();
           VideoProc_DShowListInit();
       break;

       default:
       break;
   }

   UNREFERENCED_PARAMETER(hWnd);
   UNREFERENCED_PARAMETER(uiMessage);
   UNREFERENCED_PARAMETER(lParam);

   return iReturn;
}

///////////////////////////////
// ProcessWMNotify
//
INT_PTR ProcessWMNotify(HWND    hWnd,
                        UINT    uiMessage, 
                        WPARAM  wParam,
                        LPARAM  lParam)
{
    INT_PTR              iReturn          = 0;
    NMHDR                *pNotifyHdr      = NULL;
    UINT                 uiNotifyCode     = 0;
    int                  iIDCtrl          = 0;

//    iIDCtrl = wParam;
//                                
//    pNotifyHdr   = (LPNMHDR) lParam;
//    uiNotifyCode = pNotifyHdr->code;

//    switch (uiNotifyCode) 
//    {
//        default:
//        break;
//    }


    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(uiMessage);

    return iReturn;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\atm.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	atm.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ATM aware components.

Author:

	NDIS/ATM Development Team
	

Revision History:

	Initial Version - March 1996

--*/

#ifndef	_ATM_H_
#define	_ATM_H_

//
// Address type
//
typedef ULONG	ATM_ADDRESSTYPE;

#define	ATM_NSAP				0
#define	ATM_E164				1

//
// ATM Address
//
#define	ATM_MAC_ADDRESS_LENGTH	6		// Same as 802.x
#define	ATM_ADDRESS_LENGTH		20

//
//  Special characters in ATM address string used in textual representations
//
#define ATM_ADDR_BLANK_CHAR				L' '
#define ATM_ADDR_PUNCTUATION_CHAR		L'.'
#define ATM_ADDR_E164_START_CHAR		L'+'

typedef struct _ATM_ADDRESS
{
	ATM_ADDRESSTYPE				AddressType;
	ULONG						NumberOfDigits;
	UCHAR						Address[ATM_ADDRESS_LENGTH];
} ATM_ADDRESS, *PATM_ADDRESS;



//
// AAL types that the miniport supports
//
#define	AAL_TYPE_AAL0			1
#define	AAL_TYPE_AAL1			2
#define	AAL_TYPE_AAL34			4
#define	AAL_TYPE_AAL5			8

typedef ULONG	ATM_AAL_TYPE, *PATM_AAL_TYPE;


//
// Types of Information Elements
//
typedef enum
{
	IE_AALParameters,
	IE_TrafficDescriptor,
	IE_BroadbandBearerCapability,
	IE_BHLI,
	IE_BLLI,
	IE_CalledPartyNumber,
	IE_CalledPartySubaddress,
	IE_CallingPartyNumber,
	IE_CallingPartySubaddress,
	IE_Cause,
	IE_QOSClass,
	IE_TransitNetworkSelection,
	IE_BroadbandSendingComplete,
	IE_LIJCallId,
	IE_Raw
} Q2931_IE_TYPE;


//
// Common header for each Information Element
//
typedef struct _Q2931_IE
{
	Q2931_IE_TYPE				IEType;
	ULONG						IELength;	// Bytes, including IEType and IELength fields
	UCHAR						IE[1];
} Q2931_IE, *PQ2931_IE;


//
// Definitions for SapType in CO_SAP
//
#define SAP_TYPE_NSAP			0x00000001
#define SAP_TYPE_E164			0x00000002

//
// Values used for the Mode field in AAL5_PARAMETERS
//
#define AAL5_MODE_MESSAGE			0x01
#define AAL5_MODE_STREAMING			0x02

//
// Values used for the SSCSType field in AAL5_PARAMETERS
//
#define AAL5_SSCS_NULL				0x00
#define AAL5_SSCS_SSCOP_ASSURED		0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED	0x02
#define AAL5_SSCS_FRAME_RELAY		0x04


//
// AAL Parameters
//
typedef struct _AAL1_PARAMETERS
{
	UCHAR						Subtype;
	UCHAR						CBRRate;
	USHORT						Multiplier;
	UCHAR						SourceClockRecoveryMethod;
	UCHAR						ErrorCorrectionMethod;
	USHORT						StructuredDataTransferBlocksize;
	UCHAR						PartiallyFilledCellsMethod;
} AAL1_PARAMETERS, *PAAL1_PARAMETERS;

typedef struct _AAL34_PARAMETERS
{
	USHORT						ForwardMaxCPCSSDUSize;
	USHORT						BackwardMaxCPCSSDUSize;
	USHORT						LowestMID;
	USHORT						HighestMID;
	UCHAR						SSCSType;
} AAL34_PARAMETERS, *PAAL34_PARAMETERS;

typedef struct _AAL5_PARAMETERS
{
	ULONG						ForwardMaxCPCSSDUSize;
	ULONG						BackwardMaxCPCSSDUSize;
	UCHAR						Mode;
	UCHAR						SSCSType;
} AAL5_PARAMETERS, *PAAL5_PARAMETERS;

typedef struct _AALUSER_PARAMETERS
{
	ULONG						UserDefined;
} AALUSER_PARAMETERS, *PAALUSER_PARAMETERS;

typedef struct _AAL_PARAMETERS_IE
{
	ATM_AAL_TYPE				AALType;
	union
	{
		AAL1_PARAMETERS			AAL1Parameters;
		AAL34_PARAMETERS		AAL34Parameters;
		AAL5_PARAMETERS			AAL5Parameters;
		AALUSER_PARAMETERS		AALUserParameters;
	} AALSpecificParameters;

} AAL_PARAMETERS_IE, *PAAL_PARAMETERS_IE;

//
// ATM Traffic Descriptor
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;
	ULONG						PeakCellRateCLP01;
	ULONG						SustainableCellRateCLP0;
	ULONG						SustainableCellRateCLP01;
	ULONG						MaximumBurstSizeCLP0;
	ULONG						MaximumBurstSizeCLP01;
	BOOLEAN						Tagging;
} ATM_TRAFFIC_DESCRIPTOR, *PATM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR		BackwardTD;
	BOOLEAN						BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE, *PATM_TRAFFIC_DESCRIPTOR_IE;


//
// values used for the BearerClass field in the Broadband Bearer Capability IE
//


#define BCOB_A					0x00	// Bearer class A
#define BCOB_C					0x01	// Bearer class C
#define BCOB_X					0x02	// Bearer class X

//
// values used for the TrafficType field in the Broadband Bearer Capability IE
//
#define TT_NOIND				0x00	// No indication of traffic type
#define TT_CBR					0x04	// Constant bit rate
#define TT_VBR					0x08	// Variable bit rate

//
// values used for the TimingRequirements field in the Broadband Bearer Capability IE
//
#define TR_NOIND				0x00	// No timing requirement indication
#define TR_END_TO_END			0x01	// End-to-end timing required
#define TR_NO_END_TO_END		0x02	// End-to-end timing not required

//
// values used for the ClippingSusceptability field in the Broadband Bearer Capability IE
//
#define CLIP_NOT				0x00	// Not susceptible to clipping
#define CLIP_SUS				0x20	// Susceptible to clipping

//
// values used for the UserPlaneConnectionConfig field in
// the Broadband Bearer Capability IE
//
#define UP_P2P					0x00	// Point-to-point connection
#define UP_P2MP					0x01	// Point-to-multipoint connection

//
// Broadband Bearer Capability
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE
{
	UCHAR			BearerClass;
	UCHAR			TrafficType;
	UCHAR			TimingRequirements;
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE, *PATM_BROADBAND_BEARER_CAPABILITY_IE;

//
// values used for the HighLayerInfoType field in ATM_BHLI
//
#define BHLI_ISO				0x00	// ISO
#define BHLI_UserSpecific		0x01	// User Specific
#define BHLI_HighLayerProfile	0x02	// High layer profile (only in UNI3.0)
#define BHLI_VendorSpecificAppId 0x03	// Vendor-Specific Application ID

//
// Broadband High layer Information
//
typedef struct _ATM_BHLI_IE
{
	ULONG			HighLayerInfoType;		// High Layer Information Type
	ULONG			HighLayerInfoLength;	// number of bytes in HighLayerInfo
	UCHAR			HighLayerInfo[8];		// The value dependent on the
											// HighLayerInfoType field
} ATM_BHLI_IE, *PATM_BHLI_IE;

//
// values used for Layer2Protocol in B-LLI
//
#define BLLI_L2_ISO_1745		0x01	// Basic mode ISO 1745
#define BLLI_L2_Q921			0x02	// CCITT Rec. Q.921
#define BLLI_L2_X25L			0x06	// CCITT Rec. X.25, link layer
#define BLLI_L2_X25M			0x07	// CCITT Rec. X.25, multilink
#define BLLI_L2_ELAPB			0x08	// Extended LAPB; for half duplex operation
#define BLLI_L2_HDLC_ARM		0x09	// HDLC ARM (ISO 4335)
#define BLLI_L2_HDLC_NRM		0x0A	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0B	// HDLC ABM (ISO 4335)
#define BLLI_L2_LLC				0x0C	// LAN logical link control (ISO 8802/2)
#define BLLI_L2_X75				0x0D	// CCITT Rec. X.75, single link procedure
#define BLLI_L2_Q922			0x0E	// CCITT Rec. Q.922
#define BLLI_L2_USER_SPECIFIED	0x10	// User Specified
#define BLLI_L2_ISO_7776		0x11	// ISO 7776 DTE-DTE operation

//
// values used for Layer3Protocol in B-LLI
//
#define BLLI_L3_X25				0x06	// CCITT Rec. X.25, packet layer
#define BLLI_L3_ISO_8208		0x07	// ISO/IEC 8208 (X.25 packet layer for DTE
#define BLLI_L3_X223			0x08	// X.223/ISO 8878
#define BLLI_L3_SIO_8473		0x09	// ISO/IEC 8473 (OSI connectionless)
#define BLLI_L3_T70				0x0A	// CCITT Rec. T.70 min. network layer
#define BLLI_L3_ISO_TR9577		0x0B	// ISO/IEC TR 9577 Network Layer Protocol ID
#define BLLI_L3_USER_SPECIFIED	0x10	// User Specified

//
// values used for Layer3IPI in struct B-LLI
//
#define BLLI_L3_IPI_SNAP		0x80	// IEEE 802.1 SNAP identifier
#define BLLI_L3_IPI_IP			0xCC	// Internet Protocol (IP) identifier

//
// Broadband Lower Layer Information
//
typedef struct _ATM_BLLI_IE
{
	ULONG						Layer2Protocol;
	UCHAR						Layer2Mode;
	UCHAR						Layer2WindowSize;
	ULONG						Layer2UserSpecifiedProtocol;
	ULONG						Layer3Protocol;
	UCHAR						Layer3Mode;
	UCHAR						Layer3DefaultPacketSize;
	UCHAR						Layer3PacketWindowSize;
	ULONG						Layer3UserSpecifiedProtocol;
	ULONG						Layer3IPI;
	UCHAR						SnapId[5];
} ATM_BLLI_IE, *PATM_BLLI_IE;


//
// Called Party Number
//
// If present, this IE overrides the Called Address specified in
// the main parameter block.
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_NUMBER_IE;


//
// Called Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_SUBADDRESS_IE;



//
// Calling Party Number
//
typedef struct _ATM_CALLING_PARTY_NUMBER_IE
{
	ATM_ADDRESS					Number;
	UCHAR						PresentationIndication;
	UCHAR						ScreeningIndicator;
} ATM_CALLING_PARTY_NUMBER_IE, *PATM_CALLING_PARTY_NUMBER_IE;


//
// Calling Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLING_PARTY_SUBADDRESS_IE;


//
// Values used for the QOSClassForward and QOSClassBackward
// fields in ATM_QOS_CLASS_IE
//
#define QOS_CLASS0				0x00
#define QOS_CLASS1				0x01
#define QOS_CLASS2				0x02
#define QOS_CLASS3				0x03
#define QOS_CLASS4				0x04

//
// QOS Class
//
typedef struct _ATM_QOS_CLASS_IE
{
	UCHAR						QOSClassForward;
	UCHAR						QOSClassBackward;
} ATM_QOS_CLASS_IE, *PATM_QOS_CLASS_IE;

//
// Broadband Sending Complete
//
typedef struct _ATM_BROADBAND_SENDING_COMPLETE_IE
{
	UCHAR						SendingComplete;
} ATM_BROADBAND_SENDING_COMPLETE_IE, *PATM_BROADBAND_SENDING_COMPLETE_IE;


//
// Values used for the TypeOfNetworkId field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_TYPE_NATIONAL			0x40

//
// Values used for the NetworkIdPlan field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_PLAN_CARRIER_ID_CODE	0x01

//
// Transit Network Selection
//
typedef struct _ATM_TRANSIT_NETWORK_SELECTION_IE
{
	UCHAR						TypeOfNetworkId;
	UCHAR						NetworkIdPlan;
	UCHAR						NetworkIdLength;
	UCHAR						NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE, *PATM_TRANSIT_NETWORK_SELECTION_IE;


// 
// Values used for the Location field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_LOC_USER							0x00
#define ATM_CAUSE_LOC_PRIVATE_LOCAL					0x01
#define ATM_CAUSE_LOC_PUBLIC_LOCAL					0x02
#define ATM_CAUSE_LOC_TRANSIT_NETWORK				0x03
#define ATM_CAUSE_LOC_PUBLIC_REMOTE					0x04
#define ATM_CAUSE_LOC_PRIVATE_REMOTE				0x05
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x07
#define ATM_CAUSE_LOC_BEYOND_INTERWORKING			0x0A

// 
// Values used for the Cause field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x33
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x5D
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F

//
// Values used for the Condition portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_COND_UNKNOWN						0x00
#define ATM_CAUSE_COND_PERMANENT					0x01
#define ATM_CAUSE_COND_TRANSIENT					0x02

//
// Values used for the Rejection Reason portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_REASON_USER						0x00
#define ATM_CAUSE_REASON_IE_MISSING					0x04
#define ATM_CAUSE_REASON_IE_INSUFFICIENT			0x08

//
// Values used for the P-U flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_PU_PROVIDER						0x00
#define ATM_CAUSE_PU_USER							0x08

//
// Values used for the N-A flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_NA_NORMAL							0x00
#define ATM_CAUSE_NA_ABNORMAL						0x04

//
// Cause
//
typedef struct _ATM_CAUSE_IE
{
	UCHAR						Location;
	UCHAR						Cause;
	UCHAR						DiagnosticsLength;
	UCHAR						Diagnostics[4];
} ATM_CAUSE_IE, *PATM_CAUSE_IE;


//
// Leaf Initiated Join (LIJ) Identifier
//
typedef struct _ATM_LIJ_CALLID_IE
{
	ULONG						Identifier;
} ATM_LIJ_CALLID_IE, *PATM_LIJ_CALLID_IE;


//
// Raw Information Element - the user can fill in whatever he wants
//
typedef struct _ATM_RAW_IE
{
	ULONG						RawIELength;
	ULONG						RawIEType;
	UCHAR						RawIEValue[1];
} ATM_RAW_IE, *PATM_RAW_IE;


//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains ATM media specific values in the structure
// ATM_MEDIA_PARAMETERS.
//
#define ATM_MEDIA_SPECIFIC		0x00000001

//
// The Q2931 Call Manager Specific parameters that goes into the
// CallMgrParameters->CallMgrSpecific.Parameters
//
typedef struct _Q2931_CALLMGR_PARAMETERS
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_PARAMETERS, *PQ2931_CALLMGR_PARAMETERS;


//
// This is the specific portion of either the Media parameters or the CallMgr
// Parameters. The following two defines are used in the ParamType field
// depending on the signaling type.
//
#define CALLMGR_SPECIFIC_Q2931	0x00000001

typedef struct _ATM_VPIVCI
{
	ULONG						Vpi;
	ULONG						Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

//
// ATM Service Category
//
#define	ATM_SERVICE_CATEGORY_CBR	1	// Constant Bit Rate
#define	ATM_SERVICE_CATEGORY_VBR	2	// Variable Bit Rate
#define	ATM_SERVICE_CATEGORY_UBR	4	// Unspecified Bit Rate
#define	ATM_SERVICE_CATEGORY_ABR	8	// Available Bit Rate

typedef ULONG	ATM_SERVICE_CATEGORY, *PATM_SERVICE_CATEGORY;


//
// ATM flow parameters for use in specifying Media parameters
//
typedef struct _ATM_FLOW_PARAMETERS
{
	ATM_SERVICE_CATEGORY		ServiceCategory;
	ULONG						AverageCellRate;			// in cells/sec
	ULONG						PeakCellRate;				// in cells/sec
	ULONG						MinimumCellRate;			// in cells/sec (ABR MCR)
	ULONG						InitialCellRate;			// in cells/sec (ABR ICR)
	ULONG						BurstLengthCells;			// in cells
	ULONG						MaxSduSize;					// MTU in bytes
	ULONG						TransientBufferExposure;	// in cells (ABR TBE)
	ULONG						CumulativeRMFixedRTT;		// in microseconds (ABR FRTT)
	UCHAR						RateIncreaseFactor;			// UNI 4.0 coding (ABR RIF)
	UCHAR						RateDecreaseFactor;			// UNI 4.0 coding (ABR RDF)
	USHORT						ACRDecreaseTimeFactor;		// UNI 4.0 coding (ABR ADTF)
	UCHAR						MaximumCellsPerForwardRMCell; // UNI 4.0 coding (ABR Nrm)
	UCHAR						MaximumForwardRMCellInterval; // UNI 4.0 coding (ABR Trm)
	UCHAR						CutoffDecreaseFactor;		// UNI 4.0 coding (ABR CDF)
	UCHAR						Reserved1;					// padding
	ULONG						MissingRMCellCount;			// (ABR CRM)
	ULONG						Reserved2;
	ULONG						Reserved3;
} ATM_FLOW_PARAMETERS, *PATM_FLOW_PARAMETERS;




//
// ATM Specific Media parameters - this is the Media specific structure for ATM
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _ATM_MEDIA_PARAMETERS
{
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ULONG						CellDelayVariationCLP0;
	ULONG						CellDelayVariationCLP1;
	ULONG						CellLossRatioCLP0;
	ULONG						CellLossRatioCLP1;
	ULONG						CellTransferDelayCLP0;
	ULONG						CellTransferDelayCLP1;
	ULONG						DefaultCLP;
	ATM_FLOW_PARAMETERS			Transmit;
	ATM_FLOW_PARAMETERS			Receive;
} ATM_MEDIA_PARAMETERS, *PATM_MEDIA_PARAMETERS;


//  Bit 0 in Reserved1 in ATM_FLOW_PARAMETERS is reserved.
#define ATM_FLOW_PARAMS_RSVD1_MPP	0x01

#ifndef SAP_FIELD_ABSENT
#define SAP_FIELD_ABSENT		((ULONG)0xfffffffe)
#endif

#ifndef SAP_FIELD_ANY
#define SAP_FIELD_ANY			((ULONG)0xffffffff)
#endif

#define SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

//
// The ATM Specific SAP definition
//
typedef struct _ATM_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
	ULONG						NumberOfAddresses;
	UCHAR						Addresses[1];	// each of type ATM_ADDRESS
} ATM_SAP, *PATM_SAP;

//
// The ATM Specific SAP definition when adding PVCs
//
typedef struct _ATM_PVC_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
} ATM_PVC_SAP, *PATM_PVC_SAP;

//
// The structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an ADD PVC request for Q.2931
//
typedef struct _Q2931_ADD_PVC
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ATM_FLOW_PARAMETERS			ForwardFP;
	ATM_FLOW_PARAMETERS			BackwardFP;
	ULONG						Flags;
	ATM_PVC_SAP					LocalSap;
	ATM_PVC_SAP					DestinationSap;
	BOOLEAN						LIJIdPresent;
	ATM_LIJ_CALLID_IE			LIJId;
} Q2931_ADD_PVC, *PQ2931_ADD_PVC;

//
// These flags are defined to be used with Q2931_ADD_PVC above
//
// this VC should be used by the CallMgr as the signaling VC now
#define CO_FLAG_SIGNALING_VC	0x00000001

//
// Use this flag for a PVC that cannot be used for a MakeCall - incoming call only
// the call mgr can then be optimized not to search these PVCs during make call
// processing.
#define CO_FLAG_NO_DEST_SAP		0x00000002

//
//  Use this flag for a PVC that cannot be used to indicate an incoming call.
//
#define CO_FLAG_NO_LOCAL_SAP	0x00000004

//
// the structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an NDIS_CO_PVC request for Q2931
//
typedef struct _Q2931_DELETE_PVC
{
	ATM_VPIVCI					ConnectionId;
} Q2931_DELETE_PVC, *PQ2931_DELETE_PVC;

typedef struct _CO_GET_CALL_INFORMATION
{
	ULONG						CallInfoType;
	ULONG						CallInfoLength;
	PVOID						CallInfoBuffer;
} CO_GET_CALL_INFORMATION, *PCO_GET_CALL_INFORMATION;

//
// the structure for returning the supported VC rates from the miniport,
// returned in response to OID_ATM_SUPPORTED_VC_RATES
//
typedef struct _ATM_VC_RATES_SUPPORTED
{
	ULONG						MinCellRate;
	ULONG						MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
//	NDIS_PACKET out of band information for ATM.
//
typedef struct _ATM_AAL_OOB_INFO
{
	ATM_AAL_TYPE		AalType;
	union
	{
		struct _ATM_AAL5_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		UserToUserIndication;
			UCHAR		CommonPartIndicator;
		} ATM_AAL5_INFO;

		struct _ATM_AAL0_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		PayLoadTypeIdentifier;
		} ATM_AAL0_INFO;
	};
} ATM_AAL_OOB_INFO, *PATM_AAL_OOB_INFO;


//
//  Physical Line Speeds in bits/sec.
//
#define ATM_PHYS_RATE_SONET_STS3C						155520000
#define ATM_PHYS_RATE_IBM_25						 	 25600000

//
//  ATM cell layer transfer capacities in bits/sec. This is the throughput
//  available for ATM cells, after allowing for physical framing overhead.
//
#define ATM_CELL_TRANSFER_CAPACITY_SONET_STS3C			149760000
#define ATM_CELL_TRANSFER_CAPACITY_IBM_25			 	 25125926



//
//  User data rate in units of 100 bits/sec. This is returned in response to
//  the OID_GEN_CO_LINK_SPEED query. This is the effective rate of
//  transfer of data available to the ATM layer user, after allowing for
//  the ATM cell header.
//
#define ATM_USER_DATA_RATE_SONET_155					  1356317
#define ATM_USER_DATA_RATE_IBM_25			               227556



//
//  The ATM Service Registry MIB Table is used to locate ATM network
//  services. OID_ATM_GET_SERVICE_ADDRESS is used by clients to access
//  this table.
//

typedef ULONG		ATM_SERVICE_REGISTRY_TYPE;

#define ATM_SERVICE_REGISTRY_LECS		1	// LAN Emulation Configuration Server
#define ATM_SERVICE_REGISTRY_ANS		2	// ATM Name Server

//
//  Structure passed to OID_ATM_GET_SERVICE_ADDRESS.
//
typedef struct _ATM_SERVICE_ADDRESS_LIST
{
	ATM_SERVICE_REGISTRY_TYPE	ServiceRegistryType;
	ULONG						NumberOfAddressesAvailable;
	ULONG						NumberOfAddressesReturned;
	ATM_ADDRESS					Address[1];
} ATM_SERVICE_ADDRESS_LIST, *PATM_SERVICE_ADDRESS_LIST;

#endif	//	_ATM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\csq.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    csq.h

Abstract:

    This header exposes the cancel safe queue DDIs for use on Win2K at later.
    Drivers that use this header should link to csq.lib. If a driver only needs
    to work on XP or later, neither this header or the lib are required (the
    XP kernel supports the cancel safe queue DDIs natively.)

Author:

    Nar Ganapathy (narg) 1-Jan-1999

Revision History:

--*/

// Cancel SAFE DDI set start
//
// The following DDIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of DDIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue DDI set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel DDI code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel DDI set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//

#ifndef _CSQ_H_
#define _CSQ_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// If the wdm.h/ntddk.h we're including already defines cancel safe DDIs, we
// can skip the structure definitions. Otherwise, we do the rest here:
//
#ifndef IO_TYPE_CSQ_IRP_CONTEXT

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

#endif // IO_TYPE_CSQ_IRP_CONTEXT


//
// Add in new extensions to the csq.h library.
//

#ifndef IO_TYPE_CSQ_EX

#define IO_TYPE_CSQ_EX          3

typedef NTSTATUS
(*PIO_CSQ_INSERT_IRP_EX)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp,
    IN PVOID             InsertContext
    );

#endif // IO_TYPE_CSQ_EX


//
// These defines ensure the backward compatible CSQ library can be used within
// the XP build environment in which the kernel supports the functions natively.
//

#define CSQLIB_DDI(x)   Wdmlib##x

//
// Initializes the cancel queue structure.
//

#undef IoCsqInitialize
#define IoCsqInitialize         WdmlibIoCsqInitialize

NTSTATUS
CSQLIB_DDI(IoCsqInitialize)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


#undef IoCsqInitializeEx
#define IoCsqInitializeEx       WdmlibIoCsqInitializeEx

NTSTATUS
CSQLIB_DDI(IoCsqInitializeEx)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP_EX            CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

#undef IoCsqInsertIrp
#define IoCsqInsertIrp          WdmlibIoCsqInsertIrp

VOID
CSQLIB_DDI(IoCsqInsertIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );


#undef IoCsqInsertIrpEx
#define IoCsqInsertIrpEx        WdmlibIoCsqInsertIrpEx

NTSTATUS
CSQLIB_DDI(IoCsqInsertIrpEx)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context,
    IN  PVOID               InsertContext
    );

//
// Returns an IRP if one can be found. NULL otherwise.
//

#undef IoCsqRemoveNextIrp
#define IoCsqRemoveNextIrp      WdmlibIoCsqRemoveNextIrp

PIRP
CSQLIB_DDI(IoCsqRemoveNextIrp)(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    );

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

#undef IoCsqRemoveIrp
#define IoCsqRemoveIrp          WdmlibIoCsqRemoveIrp

PIRP
CSQLIB_DDI(IoCsqRemoveIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _CSQ_H_

// Cancel SAFE DDI set end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\cfg.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfg.h

Abstract:

    This module contains the common Configuration Manager definitions for
    both user mode and kernel mode code.

Author:

    Paula Tomlinson (paulat) 06/19/1995

Revision History:

--*/

#ifndef _CFG_INCLUDED_
#define _CFG_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

//
// The following definitions are also used by kernel mode code to
// set up the registry.
//
//
// VetoType used in
//      CM_Disable_DevNode
//      CM_Uninstall_DevNode
//      CM_Query_And_Remove_SubTree
//
typedef enum    _PNP_VETO_TYPE {
    PNP_VetoTypeUnknown,            // Name is unspecified
    PNP_VetoLegacyDevice,           // Name is an Instance Path
    PNP_VetoPendingClose,           // Name is an Instance Path
    PNP_VetoWindowsApp,             // Name is a Module
    PNP_VetoWindowsService,         // Name is a Service
    PNP_VetoOutstandingOpen,        // Name is an Instance Path
    PNP_VetoDevice,                 // Name is an Instance Path
    PNP_VetoDriver,                 // Name is a Driver Service Name
    PNP_VetoIllegalDeviceRequest,   // Name is an Instance Path
    PNP_VetoInsufficientPower,      // Name is unspecified
    PNP_VetoNonDisableable,         // Name is an Instance Path
    PNP_VetoLegacyDriver,           // Name is a Service
    PNP_VetoInsufficientRights      // Name is unspecified
}   PNP_VETO_TYPE, *PPNP_VETO_TYPE;


//
// DevInst problem values, returned by call to CM_Get_DevInst_Status
//
#define CM_PROB_NOT_CONFIGURED             (0x00000001)   // no config for device
#define CM_PROB_DEVLOADER_FAILED           (0x00000002)   // service load failed
#define CM_PROB_OUT_OF_MEMORY              (0x00000003)   // out of memory
#define CM_PROB_ENTRY_IS_WRONG_TYPE        (0x00000004)   //
#define CM_PROB_LACKED_ARBITRATOR          (0x00000005)   //
#define CM_PROB_BOOT_CONFIG_CONFLICT       (0x00000006)   // boot config conflict
#define CM_PROB_FAILED_FILTER              (0x00000007)   //
#define CM_PROB_DEVLOADER_NOT_FOUND        (0x00000008)   // Devloader not found
#define CM_PROB_INVALID_DATA               (0x00000009)   // Invalid ID
#define CM_PROB_FAILED_START               (0x0000000A)   //
#define CM_PROB_LIAR                       (0x0000000B)   //
#define CM_PROB_NORMAL_CONFLICT            (0x0000000C)   // config conflict
#define CM_PROB_NOT_VERIFIED               (0x0000000D)   //
#define CM_PROB_NEED_RESTART               (0x0000000E)   // requires restart
#define CM_PROB_REENUMERATION              (0x0000000F)   //
#define CM_PROB_PARTIAL_LOG_CONF           (0x00000010)   //
#define CM_PROB_UNKNOWN_RESOURCE           (0x00000011)   // unknown res type
#define CM_PROB_REINSTALL                  (0x00000012)   //
#define CM_PROB_REGISTRY                   (0x00000013)   //
#define CM_PROB_VXDLDR                     (0x00000014)   // WINDOWS 95 ONLY
#define CM_PROB_WILL_BE_REMOVED            (0x00000015)   // devinst will remove
#define CM_PROB_DISABLED                   (0x00000016)   // devinst is disabled
#define CM_PROB_DEVLOADER_NOT_READY        (0x00000017)   // Devloader not ready
#define CM_PROB_DEVICE_NOT_THERE           (0x00000018)   // device doesn't exist
#define CM_PROB_MOVED                      (0x00000019)   //
#define CM_PROB_TOO_EARLY                  (0x0000001A)   //
#define CM_PROB_NO_VALID_LOG_CONF          (0x0000001B)   // no valid log config
#define CM_PROB_FAILED_INSTALL             (0x0000001C)   // install failed
#define CM_PROB_HARDWARE_DISABLED          (0x0000001D)   // device disabled
#define CM_PROB_CANT_SHARE_IRQ             (0x0000001E)   // can't share IRQ
#define CM_PROB_FAILED_ADD                 (0x0000001F)   // driver failed add
#define CM_PROB_DISABLED_SERVICE           (0x00000020)   // service's Start = 4
#define CM_PROB_TRANSLATION_FAILED         (0x00000021)   // resource translation failed
#define CM_PROB_NO_SOFTCONFIG              (0x00000022)   // no soft config
#define CM_PROB_BIOS_TABLE                 (0x00000023)   // device missing in BIOS table
#define CM_PROB_IRQ_TRANSLATION_FAILED     (0x00000024)   // IRQ translator failed
#define CM_PROB_FAILED_DRIVER_ENTRY        (0x00000025)   // DriverEntry() failed.
#define CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD (0x00000026)   // Driver should have unloaded.
#define CM_PROB_DRIVER_FAILED_LOAD         (0x00000027)   // Driver load unsuccessful.
#define CM_PROB_DRIVER_SERVICE_KEY_INVALID (0x00000028)   // Error accessing driver's service key
#define CM_PROB_LEGACY_SERVICE_NO_DEVICES  (0x00000029)   // Loaded legacy service created no devices
#define CM_PROB_DUPLICATE_DEVICE           (0x0000002A)   // Two devices were discovered with the same name
#define CM_PROB_FAILED_POST_START          (0x0000002B)   // The drivers set the device state to failed
#define CM_PROB_HALTED                     (0x0000002C)   // This device was failed post start via usermode
#define CM_PROB_PHANTOM                    (0x0000002D)   // The devinst currently exists only in the registry
#define CM_PROB_SYSTEM_SHUTDOWN            (0x0000002E)   // The system is shutting down
#define CM_PROB_HELD_FOR_EJECT             (0x0000002F)   // The device is offline awaiting removal
#define CM_PROB_DRIVER_BLOCKED             (0x00000030)   // One or more drivers is blocked from loading
#define CM_PROB_REGISTRY_TOO_LARGE         (0x00000031)   // System hive has grown too large
#define CM_PROB_SETPROPERTIES_FAILED       (0x00000032)   // Failed to apply one or more registry properties  
#define NUM_CM_PROB                        (0x00000033)

//
// Configuration Manager Global State Flags (returned by CM_Get_Global_State)
//
#define CM_GLOBAL_STATE_CAN_DO_UI            (0x00000001) // Can  do UI?
#define CM_GLOBAL_STATE_ON_BIG_STACK         (0x00000002) // WINDOWS 95 ONLY
#define CM_GLOBAL_STATE_SERVICES_AVAILABLE   (0x00000004) // CM APIs available?
#define CM_GLOBAL_STATE_SHUTTING_DOWN        (0x00000008) // CM shutting down
#define CM_GLOBAL_STATE_DETECTION_PENDING    (0x00000010) // detection pending

//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be disabled
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed

//
// Windows 4 OPK2 Flags
//
#define DN_NOT_FIRST_TIMEE  0x00080000  // S: Has received a config enumerate
#define DN_STOP_FREE_RES    0x00100000  // S: When child is stopped, free resources
#define DN_REBAL_CANDIDATE  0x00200000  // S: Don't skip during rebalance
#define DN_BAD_PARTIAL      0x00400000  // S: This devnode's log_confs do not have same resources
#define DN_NT_ENUMERATOR    0x00800000  // S: This devnode's is an NT enumerator
#define DN_NT_DRIVER        0x01000000  // S: This devnode's is an NT driver
//
// Windows 4.1 Flags
//
#define DN_NEEDS_LOCKING    0x02000000  // S: Devnode need lock resume processing
#define DN_ARM_WAKEUP       0x04000000  // S: Devnode can be the wakeup device
#define DN_APM_ENUMERATOR   0x08000000  // S: APM aware enumerator
#define DN_APM_DRIVER       0x10000000  // S: APM aware driver
#define DN_SILENT_INSTALL   0x20000000  // S: Silent install
#define DN_NO_SHOW_IN_DM    0x40000000  // S: No show in device manager
#define DN_BOOT_LOG_PROB    0x80000000  // S: Had a problem during preassignment of boot log conf

//
// Windows NT Flags
//
// These are overloaded on top of unused Win 9X flags
//
//#define DN_LIAR                       (0x00000100)            // Lied about can reconfig once
#define DN_NEED_RESTART                 DN_LIAR                 // System needs to be restarted for this Devnode to work properly
// #define DN_NOT_FIRST_TIME            (0x00000040)            // Has Register_Enumerator
#define DN_DRIVER_BLOCKED               DN_NOT_FIRST_TIME       // One or more drivers are blocked from loading for this Devnode
//#define DN_MOVED                      (0x00001000)            // Has been moved
#define DN_LEGACY_DRIVER                DN_MOVED                // This device is using a legacy driver
//#define DN_HAS_MARK                   (0x00000200)            // Not CM_Create_DevInst lately
#define DN_CHILD_WITH_INVALID_ID        DN_HAS_MARK             // One or more children have invalid ID(s)

#define DN_CHANGEABLE_FLAGS (DN_NOT_FIRST_TIME+\
                DN_HARDWARE_ENUM+\
                DN_HAS_MARK+\
                DN_DISABLEABLE+\
                DN_REMOVABLE+\
                DN_MF_CHILD+\
                DN_MF_PARENT+\
                DN_NOT_FIRST_TIMEE+\
                DN_STOP_FREE_RES+\
                DN_REBAL_CANDIDATE+\
                DN_NT_ENUMERATOR+\
                DN_NT_DRIVER+\
                DN_SILENT_INSTALL+\
                DN_NO_SHOW_IN_DM)

//
// Logical configuration Priority values
//
// These priority values are used in user-mode calls to CM_Add_Empty_Log_Conf.
// Drivers may also specify priority values for a given IO_RESOURCE_LIST
// structure by including a ConfigData member union as the first
// IO_RESOURCE_DESCRIPTOR in the IO_RESOURCE_LIST. In this case, the descriptor
// type would be CmResourceTypeConfigData.
//
#define LCPRI_FORCECONFIG     (0x00000000) // Coming from a forced config
#define LCPRI_BOOTCONFIG      (0x00000001) // Coming from a boot config
#define LCPRI_DESIRED         (0x00002000) // Preferable (better performance)
#define LCPRI_NORMAL          (0x00003000) // Workable (acceptable performance)
#define LCPRI_LASTBESTCONFIG  (0x00003FFF) // CM only--do not use
#define LCPRI_SUBOPTIMAL      (0x00005000) // Not desired, but will work
#define LCPRI_LASTSOFTCONFIG  (0x00007FFF) // CM only--do not use
#define LCPRI_RESTART         (0x00008000) // Need to restart
#define LCPRI_REBOOT          (0x00009000) // Need to reboot
#define LCPRI_POWEROFF        (0x0000A000) // Need to shutdown/power-off
#define LCPRI_HARDRECONFIG    (0x0000C000) // Need to change a jumper
#define LCPRI_HARDWIRED       (0x0000E000) // Cannot be changed
#define LCPRI_IMPOSSIBLE      (0x0000F000) // Impossible configuration
#define LCPRI_DISABLED        (0x0000FFFF) // Disabled configuration
#define MAX_LCPRI             (0x0000FFFF) // Maximum known LC Priority

#endif // _CFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\d3dhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dhal.h
 *  Content:    Direct3D HAL include file
 *
 ***************************************************************************/

#ifndef _D3DHAL_H_
#define _D3DHAL_H_
#include "ddraw.h"
#include "d3dtypes.h"
#include "d3dcaps.h"
#include "d3d.h"
#include "d3d8.h"

struct _D3DHAL_CALLBACKS;
typedef struct _D3DHAL_CALLBACKS D3DHAL_CALLBACKS, *LPD3DHAL_CALLBACKS;

struct _D3DHAL_CALLBACKS2;
typedef struct _D3DHAL_CALLBACKS2 D3DHAL_CALLBACKS2, *LPD3DHAL_CALLBACKS2;

struct _D3DHAL_CALLBACKS3;
typedef struct _D3DHAL_CALLBACKS3 D3DHAL_CALLBACKS3, *LPD3DHAL_CALLBACKS3;

typedef struct _DDRAWI_DIRECTDRAW_GBL FAR *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR *LPDDRAWI_DIRECTDRAW_LCL;
struct _DDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR *LPDDRAWI_DDRAWSURFACE_LCL;

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DHAL_NUMCLIPVERTICES  20

/*
 * These are a few special internal renderstates etc. that would
 * logically be in d3dtypes.h, but that file is external, so they are
 * here.
 */
#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)29)

/*
 * If DX8 driver wants to support pre-DX8 applications, it should use these
 * definitions for pre-DX8 world matrices
*/
#define D3DTRANSFORMSTATE_WORLD_DX7  1
#define D3DTRANSFORMSTATE_WORLD1_DX7 4
#define D3DTRANSFORMSTATE_WORLD2_DX7 5
#define D3DTRANSFORMSTATE_WORLD3_DX7 6

/*
 * Generally needed maximum state structure sizes.  Note that the copy of
 * these in refrasti.hpp must be kept in sync with these.
 */

#define D3DHAL_MAX_RSTATES (D3DRENDERSTATE_WRAPBIAS + 128)
/* Last state offset for combined render state and texture stage array + 1 */
#define D3DHAL_MAX_RSTATES_AND_STAGES \
    (D3DHAL_TSS_RENDERSTATEBASE + \
     D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)
/* Last texture state ID */
#define D3DHAL_MAX_TEXTURESTATES (13)
/* Last texture state ID + 1 */
#define D3DHAL_TEXTURESTATEBUF_SIZE (D3DHAL_MAX_TEXTURESTATES+1)

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM   ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM    ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DDEVICEDESC together using the D3DDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V1 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */
} D3DDEVICEDESC_V1, *LPD3DDEVICEDESC_V1;

#define D3DDEVICEDESCSIZE_V1 (sizeof(D3DDEVICEDESC_V1))

/*
 * This is equivalent to the D3DDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX5.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V2 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

} D3DDEVICEDESC_V2, *LPD3DDEVICEDESC_V2;

#define D3DDEVICEDESCSIZE_V2 (sizeof(D3DDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX6.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V3 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DDEVICEDESC_V3, *LPD3DDEVICEDESC_V3;

#define D3DDEVICEDESCSIZE_V3 (sizeof(D3DDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 */
typedef struct _D3DHAL_GLOBALDRIVERDATA {
    DWORD       dwSize;         // Size of this structure
    D3DDEVICEDESC_V1    hwCaps;                 // Capabilities of the hardware
    DWORD       dwNumVertices;      // see following comment
    DWORD       dwNumClipVertices;  // see following comment
    DWORD       dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;   // Pointer to texture formats
} D3DHAL_GLOBALDRIVERDATA;

typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;

#define D3DHAL_GLOBALDRIVERDATASIZE (sizeof(D3DHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

#if(DIRECT3D_VERSION >= 0x0700)
    /* fields added for DX7 */
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DHAL_D3DEXTENDEDCAPS;

typedef D3DHAL_D3DEXTENDEDCAPS *LPD3DHAL_D3DEXTENDEDCAPS;
#define D3DHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DEXTENDEDCAPS))

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DHAL_D3DDX6EXTENDEDCAPS *LPD3DHAL_D3DDX6EXTENDEDCAPS;
#define D3DHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 *
 * !!! When this structure is changed, D3DHAL_CONTEXTCREATEDATA in 
 *  windows\published\ntgdistr.h also must be changed to be the same size !!!
 *
 */

typedef struct _D3DHAL_CONTEXTCREATEDATA
{
    union
    {
        LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    // in:  Driver struct (legacy)
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl;    // in:  For DX7 driver onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDS;      // in:  Surface to be used as target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl; // For DX7 onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;     // in:  Surface to be used as Z
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl; // For DX7 onwards
    };

    union
    {
        DWORD       dwPID;      // in:  Current process id
        ULONG_PTR dwrstates;  // Must be larger enough to hold a pointer as
                              // we can return a pointer in this field
    };
    ULONG_PTR       dwhContext; // out: Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTCREATEDATA;
typedef D3DHAL_CONTEXTCREATEDATA *LPD3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYDATA;
typedef D3DHAL_CONTEXTDESTROYDATA *LPD3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA
{
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DHAL_CONTEXTDESTROYALLDATA *LPD3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DHAL_SCENECAPTUREDATA;
typedef D3DHAL_SCENECAPTUREDATA *LPD3DHAL_SCENECAPTUREDATA;

typedef struct _D3DHAL_RENDERSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find states in buffer
    DWORD       dwCount;    // in:  How many states to process
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERSTATEDATA;
typedef D3DHAL_RENDERSTATEDATA *LPD3DHAL_RENDERSTATEDATA;

typedef struct _D3DHAL_RENDERPRIMITIVEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find primitive data in buffer
    DWORD       dwStatus;   // in/out: Condition branch status
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    DWORD       dwTLOffset; // in:  Byte offset in lpTLBuf for start of vertex data
    LPDIRECTDRAWSURFACE lpTLBuf;    // in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION  diInstruction;  // in:  Primitive instruction
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERPRIMITIVEDATA;
typedef D3DHAL_RENDERPRIMITIVEDATA *LPD3DHAL_RENDERPRIMITIVEDATA;

typedef struct _D3DHAL_TEXTURECREATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    LPDIRECTDRAWSURFACE lpDDS;      // in:  Pointer to surface object
    DWORD       dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURECREATEDATA;
typedef D3DHAL_TEXTURECREATEDATA *LPD3DHAL_TEXTURECREATEDATA;

typedef struct _D3DHAL_TEXTUREDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREDESTROYDATA;
typedef D3DHAL_TEXTUREDESTROYDATA *LPD3DHAL_TEXTUREDESTROYDATA;

typedef struct _D3DHAL_TEXTURESWAPDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle1;  // in:  Handle to texture 1
    DWORD       dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURESWAPDATA;
typedef D3DHAL_TEXTURESWAPDATA *LPD3DHAL_TEXTURESWAPDATA;

typedef struct _D3DHAL_TEXTUREGETSURFDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    ULONG_PTR    lpDDS;      // out: Pointer to surface object
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREGETSURFDATA;
typedef D3DHAL_TEXTUREGETSURFDATA *LPD3DHAL_TEXTUREGETSURFDATA;

typedef struct _D3DHAL_GETSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwWhich;    // in:  Transform, lighting or render?
    D3DSTATE        ddState;    // in/out: State.
    HRESULT     ddrval;     // out: Return value
} D3DHAL_GETSTATEDATA;
typedef D3DHAL_GETSTATEDATA *LPD3DHAL_GETSTATEDATA;


/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTCREATECB)   (LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYCB)  (LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYALLCB) (LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (__stdcall *LPD3DHAL_SCENECAPTURECB)    (LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERSTATECB) (LPD3DHAL_RENDERSTATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERPRIMITIVECB) (LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURECREATECB)   (LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREDESTROYCB)  (LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURESWAPCB) (LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREGETSURFCB)  (LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD   (__stdcall *LPD3DHAL_GETSTATECB)    (LPD3DHAL_GETSTATEDATA);


/*
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */

typedef struct _D3DHAL_CALLBACKS
{
    DWORD           dwSize;

    // Device context
    LPD3DHAL_CONTEXTCREATECB    ContextCreate;
    LPD3DHAL_CONTEXTDESTROYCB   ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DHAL_SCENECAPTURECB SceneCapture;

    LPVOID                      lpReserved10;           // Must be zero
    LPVOID                      lpReserved11;           // Must be zero

    // Execution
    LPD3DHAL_RENDERSTATECB  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB  RenderPrimitive;

    DWORD           dwReserved;     // Must be zero

    // Textures
    LPD3DHAL_TEXTURECREATECB    TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB   TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB   TextureGetSurf;

    LPVOID                      lpReserved12;           // Must be zero
    LPVOID                      lpReserved13;           // Must be zero
    LPVOID                      lpReserved14;           // Must be zero
    LPVOID                      lpReserved15;           // Must be zero
    LPVOID                      lpReserved16;           // Must be zero
    LPVOID                      lpReserved17;           // Must be zero
    LPVOID                      lpReserved18;           // Must be zero
    LPVOID                      lpReserved19;           // Must be zero
    LPVOID                      lpReserved20;           // Must be zero
    LPVOID                      lpReserved21;           // Must be zero

    // Pipeline state
    LPD3DHAL_GETSTATECB     GetState;

    DWORD           dwReserved0;        // Must be zero
    DWORD           dwReserved1;        // Must be zero
    DWORD           dwReserved2;        // Must be zero
    DWORD           dwReserved3;        // Must be zero
    DWORD           dwReserved4;        // Must be zero
    DWORD           dwReserved5;        // Must be zero
    DWORD           dwReserved6;        // Must be zero
    DWORD           dwReserved7;        // Must be zero
    DWORD           dwReserved8;        // Must be zero
    DWORD           dwReserved9;        // Must be zero

} D3DHAL_CALLBACKS;
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;

#define D3DHAL_SIZE_V1 sizeof( D3DHAL_CALLBACKS )


typedef struct _D3DHAL_SETRENDERTARGETDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle
    union
    {
        LPDIRECTDRAWSURFACE lpDDS;          // in:  new render target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl;
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;         // in:  new Z buffer
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl;
    };

    HRESULT             ddrval;         // out: Return value
} D3DHAL_SETRENDERTARGETDATA;
typedef D3DHAL_SETRENDERTARGETDATA FAR *LPD3DHAL_SETRENDERTARGETDATA;

// This bit is the same as D3DCLEAR_RESERVED0 in d3d8types.h
// When set it means that driver has to cull rects against current viewport.
// The bit is set only for pure devices
//
#define D3DCLEAR_COMPUTERECTS   0x00000008l  

typedef struct _D3DHAL_CLEARDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;

typedef struct _D3DHAL_DRAWONEPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;        // in:  flags

    D3DPRIMITIVETYPE    PrimitiveType;  // in:  type of primitive to draw
    union{
    D3DVERTEXTYPE       VertexType;     // in:  type of vertices
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };
    LPVOID              lpvVertices;    // in:  pointer to vertices
    DWORD               dwNumVertices;  // in:  number of vertices

    DWORD               dwReserved;     // in:  reserved

    HRESULT             ddrval;         // out: Return value

} D3DHAL_DRAWONEPRIMITIVEDATA;
typedef D3DHAL_DRAWONEPRIMITIVEDATA *LPD3DHAL_DRAWONEPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in: Context handle

    DWORD               dwFlags;        // in: flags word

    // Primitive and vertex type
    D3DPRIMITIVETYPE    PrimitiveType;  // in: primitive type
    union{
    D3DVERTEXTYPE       VertexType;     // in: vertex type
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };

    // Vertices
    LPVOID              lpvVertices;    // in: vertex data
    DWORD               dwNumVertices;  // in: vertex count

    // Indices
    LPWORD              lpwIndices;     // in: index data
    DWORD               dwNumIndices;   // in: index count

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;
typedef D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA *LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWPRIMCOUNTS
{
    WORD wNumStateChanges;
    WORD wPrimitiveType;
    WORD wVertexType;
    WORD wNumVertices;
} D3DHAL_DRAWPRIMCOUNTS, *LPD3DHAL_DRAWPRIMCOUNTS;

typedef struct _D3DHAL_DRAWPRIMITIVESDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;

    //
    // Data block:
    //
    // Consists of interleaved D3DHAL_DRAWPRIMCOUNTS, state change pairs,
    // and primitive drawing commands.
    //
    //  D3DHAL_DRAWPRIMCOUNTS: gives number of state change pairs and
    //          the information on the primitive to draw.
    //          wPrimitiveType is of type D3DPRIMITIVETYPE. Drivers
    //              must support all 7 of the primitive types specified
    //              in the DrawPrimitive API.
    //          Currently, wVertexType will always be D3DVT_TLVERTEX.
    //          If the wNumVertices member is 0, then the driver should
    //              return after doing the state changing. This is the
    //              terminator for the command stream.
    // state change pairs: DWORD pairs specify the state changes that
    //          the driver should effect before drawing the primitive.
    //          wNumStateChanges can be 0, in which case the next primitive
    //          should be drawn without any state changes in between.
    //          If present, the state change pairs are NOT aligned, they
    //          immediately follow the PRIMCOUNTS structure.
    // vertex data (if any): is 32-byte aligned.
    //
    // If a primcounts structure follows (i.e. if wNumVertices was nonzero
    // in the previous one), then it will immediately follow the state
    // changes or vertex data with no alignment padding.
    //

    LPVOID              lpvData;

    DWORD               dwFVFControl;   // in:  FVF control DWORD

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWPRIMITIVESDATA;
typedef D3DHAL_DRAWPRIMITIVESDATA *LPD3DHAL_DRAWPRIMITIVESDATA;

typedef DWORD (CALLBACK *LPD3DHAL_SETRENDERTARGETCB) (LPD3DHAL_SETRENDERTARGETDATA);
typedef DWORD (CALLBACK *LPD3DHAL_CLEARCB)           (LPD3DHAL_CLEARDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEPRIMITIVECB)   (LPD3DHAL_DRAWONEPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB) (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVESCB)   (LPD3DHAL_DRAWPRIMITIVESDATA);

typedef struct _D3DHAL_CALLBACKS2
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks
    LPD3DHAL_SETRENDERTARGETCB  SetRenderTarget;
    LPD3DHAL_CLEARCB            Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB    DrawPrimitives;
} D3DHAL_CALLBACKS2;
typedef D3DHAL_CALLBACKS2 *LPD3DHAL_CALLBACKS2;

#define D3DHAL_CALLBACKS2SIZE       sizeof(D3DHAL_CALLBACKS2)

#define D3DHAL2_CB32_SETRENDERTARGET    0x00000001L
#define D3DHAL2_CB32_CLEAR              0x00000002L
#define D3DHAL2_CB32_DRAWONEPRIMITIVE   0x00000004L
#define D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE 0x00000008L
#define D3DHAL2_CB32_DRAWPRIMITIVES     0x00000010L

/* --------------------------------------------------------------
 * D3DCallbacks3 - queried with GetDriverInfo (GUID_D3DCallbacks3).
 *
 * Clear2 - enables stencil clears (exposed to the API in
 *      IDirect3DViewport3::Clear2
 * ValidateTextureStageState - evaluates the context's current state (including
 *      multitexture) and returns an error if the hardware cannot
 *      accelerate the current state vector.
 * DrawPrimitives2 - Renders primitives, and changes device state specified
 *                   in the command buffer.
 *
 * Multitexture-aware drivers must implement both ValidateTextureStageState.
 */

typedef struct _D3DHAL_CLEAR2DATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle

  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEAR2DATA;
typedef D3DHAL_CLEAR2DATA FAR *LPD3DHAL_CLEAR2DATA;

typedef struct _D3DHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle
    DWORD               dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR           dwReserved;     //
    DWORD               dwNumPasses;    // out: Number of passes the hardware
                                        //      can perform the operation in
    HRESULT             ddrval;         // out: return value
} D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DHAL_VALIDATETEXTURESTAGESTATEDATA *LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DHAL_DP2COMMAND
{
    BYTE bCommand;           // vertex command
    BYTE bReserved;
    union
    {
        WORD wPrimitiveCount;   // primitive count for unconnected primitives
        WORD wStateCount;     // count of render states to follow
    };
} D3DHAL_DP2COMMAND, *LPD3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DHAL_DP2OPERATION
{
    D3DDP2OP_POINTS               = 1,
    D3DDP2OP_INDEXEDLINELIST      = 2,
    D3DDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DDP2OP_RESERVED0            = 4,      // Used by the front-end only
    D3DDP2OP_RENDERSTATE          = 8,
    D3DDP2OP_LINELIST             = 15,
    D3DDP2OP_LINESTRIP            = 16,
    D3DDP2OP_INDEXEDLINESTRIP     = 17,
    D3DDP2OP_TRIANGLELIST         = 18,
    D3DDP2OP_TRIANGLESTRIP        = 19,
    D3DDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DDP2OP_TRIANGLEFAN          = 21,
    D3DDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DDP2OP_LINELIST_IMM         = 24,
    D3DDP2OP_TEXTURESTAGESTATE    = 25,     // Has edge flags and called from Execute
    D3DDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DDP2OP_INDEXEDLINELIST2     = 27,
    D3DDP2OP_VIEWPORTINFO         = 28,
    D3DDP2OP_WINFO                = 29,
// two below are for pre-DX7 interface apps running DX7 driver
    D3DDP2OP_SETPALETTE           = 30,
    D3DDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    // New for DX7
    D3DDP2OP_ZRANGE               = 32,
    D3DDP2OP_SETMATERIAL          = 33,
    D3DDP2OP_SETLIGHT             = 34,
    D3DDP2OP_CREATELIGHT          = 35,
    D3DDP2OP_SETTRANSFORM         = 36,
    D3DDP2OP_EXT                  = 37,
    D3DDP2OP_TEXBLT               = 38,
    D3DDP2OP_STATESET             = 39,
    D3DDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DDP2OP_SETRENDERTARGET      = 41,
    D3DDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DDP2OP_SETTEXLOD            = 43,
    D3DDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
    D3DDP2OP_CREATEVERTEXSHADER   = 45,
    D3DDP2OP_DELETEVERTEXSHADER   = 46,
    D3DDP2OP_SETVERTEXSHADER      = 47,
    D3DDP2OP_SETVERTEXSHADERCONST = 48,
    D3DDP2OP_SETSTREAMSOURCE      = 49,
    D3DDP2OP_SETSTREAMSOURCEUM    = 50,
    D3DDP2OP_SETINDICES           = 51,
    D3DDP2OP_DRAWPRIMITIVE        = 52,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE = 53,
    D3DDP2OP_CREATEPIXELSHADER    = 54,
    D3DDP2OP_DELETEPIXELSHADER    = 55,
    D3DDP2OP_SETPIXELSHADER       = 56,
    D3DDP2OP_SETPIXELSHADERCONST  = 57,
    D3DDP2OP_CLIPPEDTRIANGLEFAN   = 58,
    D3DDP2OP_DRAWPRIMITIVE2       = 59,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
    D3DDP2OP_DRAWRECTPATCH        = 61,
    D3DDP2OP_DRAWTRIPATCH         = 62,
    D3DDP2OP_VOLUMEBLT            = 63,
    D3DDP2OP_BUFFERBLT            = 64,
    D3DDP2OP_MULTIPLYTRANSFORM    = 65,
    D3DDP2OP_ADDDIRTYRECT         = 66,
    D3DDP2OP_ADDDIRTYBOX          = 67
#endif /* DIRECT3D_VERSION >= 0x0800 */
} D3DHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DHAL_DP2POINTS, *LPD3DHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DHAL_DP2STARTVERTEX
{
    WORD wVStart;
} D3DHAL_DP2STARTVERTEX, *LPD3DHAL_DP2STARTVERTEX;

typedef struct _D3DHAL_DP2LINELIST
{
    WORD wVStart;
} D3DHAL_DP2LINELIST, *LPD3DHAL_DP2LINELIST;

typedef struct _D3DHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DHAL_DP2INDEXEDLINELIST, *LPD3DHAL_DP2INDEXEDLINELIST;

typedef struct _D3DHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DHAL_DP2LINESTRIP, *LPD3DHAL_DP2LINESTRIP;

typedef struct _D3DHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DHAL_DP2INDEXEDLINESTRIP, *LPD3DHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLELIST, *LPD3DHAL_DP2TRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DHAL_DP2INDEXEDTRIANGLELIST, *LPD3DHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST2
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLESTRIP, *LPD3DHAL_DP2TRIANGLESTRIP;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLESTRIP, *LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLEFAN, *LPD3DHAL_DP2TRIANGLEFAN;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLEFAN, *LPD3DHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2TRIANGLEFAN_IMM
{
    DWORD dwEdgeFlags;
} D3DHAL_DP2TRIANGLEFAN_IMM;

typedef D3DHAL_DP2TRIANGLEFAN_IMM  *LPD3DHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE dvState;
        DWORD dwState;
    };
} D3DHAL_DP2RENDERSTATE;
typedef D3DHAL_DP2RENDERSTATE  * LPD3DHAL_DP2RENDERSTATE;

typedef struct _D3DHAL_DP2TEXTURESTAGESTATE
{
    WORD wStage;
    WORD TSState;
    DWORD dwValue;
} D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DHAL_DP2TEXTURESTAGESTATE  *LPD3DHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DHAL_DP2VIEWPORTINFO
{
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DHAL_DP2VIEWPORTINFO;
typedef D3DHAL_DP2VIEWPORTINFO  *LPD3DHAL_DP2VIEWPORTINFO;

typedef struct _D3DHAL_DP2WINFO
{
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DHAL_DP2WINFO;
typedef D3DHAL_DP2WINFO  *LPD3DHAL_DP2WINFO;

typedef struct _D3DHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DHAL_DP2SETPALETTE;
typedef D3DHAL_DP2SETPALETTE  *LPD3DHAL_DP2SETPALETTE;

typedef struct _D3DHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DHAL_DP2UPDATEPALETTE;
typedef D3DHAL_DP2UPDATEPALETTE  *LPD3DHAL_DP2UPDATEPALETTE;

typedef struct _D3DHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DHAL_DP2SETRENDERTARGET;
typedef D3DHAL_DP2SETRENDERTARGET  *LPD3DHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
#define D3DHAL_STATESETCREATE    5
#endif /* DIRECT3D_VERSION >= 0x0800 */
#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DHAL_DP2STATESET
{
    DWORD               dwOperation;
    DWORD               dwParam;  // State set handle passed with D3DHAL_STATESETBEGIN,
                                  // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                  // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType;   // Type use with D3DHAL_STATESETBEGIN/END
} D3DHAL_DP2STATESET;
typedef D3DHAL_DP2STATESET  *LPD3DHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DHAL_DP2ZRANGE;
typedef D3DHAL_DP2ZRANGE  *LPD3DHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DHAL_DP2SETMATERIAL, *LPD3DHAL_DP2SETMATERIAL;

// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

typedef struct _D3DHAL_DP2SETLIGHT
{
    DWORD     dwIndex;
    DWORD     dwDataType;
} D3DHAL_DP2SETLIGHT;
typedef D3DHAL_DP2SETLIGHT  *LPD3DHAL_DP2SETLIGHT;

typedef struct _D3DHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DHAL_DP2SETCLIPPLANE;
typedef D3DHAL_DP2SETCLIPPLANE  *LPD3DHAL_DP2SETCLIPPLANE;

typedef struct _D3DHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DHAL_DP2CREATELIGHT;
typedef D3DHAL_DP2CREATELIGHT  *LPD3DHAL_DP2CREATELIGHT;

typedef struct _D3DHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2SETTRANSFORM;
typedef D3DHAL_DP2SETTRANSFORM  *LPD3DHAL_DP2SETTRANSFORM;

typedef struct _D3DHAL_DP2MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2MULTIPLYTRANSFORM;
typedef D3DHAL_DP2MULTIPLYTRANSFORM  *LPD3DHAL_DP2MULTIPLYTRANSFORM;

typedef struct _D3DHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DHAL_DP2EXT;
typedef D3DHAL_DP2EXT  *LPD3DHAL_DP2EXT;

typedef struct _D3DHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DHAL_DP2TEXBLT;
typedef D3DHAL_DP2TEXBLT  *LPD3DHAL_DP2TEXBLT;

typedef struct _D3DHAL_DP2SETPRIORITY
{
    DWORD dwDDSurface;
    DWORD dwPriority;
} D3DHAL_DP2SETPRIORITY;
typedef D3DHAL_DP2SETPRIORITY  *LPD3DHAL_DP2SETPRIORITY;
#endif /* DIRECT3D_VERSION >= 0x0700 */

typedef struct _D3DHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DHAL_DP2CLEAR;
typedef D3DHAL_DP2CLEAR  *LPD3DHAL_DP2CLEAR;


#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DHAL_DP2SETTEXLOD;
typedef D3DHAL_DP2SETTEXLOD  *LPD3DHAL_DP2SETTEXLOD;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0800)

// Used by SetVertexShader and DeleteVertexShader
typedef struct _D3DHAL_DP2VERTEXSHADER
{
    // Vertex shader handle.
    // The handle could be 0, meaning that the current vertex shader is invalid
    // (not set). When driver recieves handle 0, it should invalidate all
    // streams pointer
    DWORD dwHandle;
} D3DHAL_DP2VERTEXSHADER;
typedef D3DHAL_DP2VERTEXSHADER  *LPD3DHAL_DP2VERTEXSHADER;

typedef struct _D3DHAL_DP2CREATEVERTEXSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwDeclSize;   // Shader declaration size in bytes
    DWORD dwCodeSize;   // Shader code size in bytes
    // Declaration follows
    // Shader code follows
} D3DHAL_DP2CREATEVERTEXSHADER;
typedef D3DHAL_DP2CREATEVERTEXSHADER  *LPD3DHAL_DP2CREATEVERTEXSHADER;

typedef struct _D3DHAL_DP2SETVERTEXSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DHAL_DP2SETVERTEXSHADERCONST;
typedef D3DHAL_DP2SETVERTEXSHADERCONST  *LPD3DHAL_DP2SETVERTEXSHADERCONST;

typedef struct _D3DHAL_DP2SETSTREAMSOURCE
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCE;
typedef D3DHAL_DP2SETSTREAMSOURCE  *LPD3DHAL_DP2SETSTREAMSOURCE;

typedef struct _D3DHAL_DP2SETSTREAMSOURCEUM
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCEUM;
typedef D3DHAL_DP2SETSTREAMSOURCEUM  *LPD3DHAL_DP2SETSTREAMSOURCEUM;

typedef struct _D3DHAL_DP2SETINDICES
{
    DWORD dwVBHandle;           // Index buffer handle
    DWORD dwStride;             // Index size in bytes (2 or 4)
} D3DHAL_DP2SETINDICES;
typedef D3DHAL_DP2SETINDICES  *LPD3DHAL_DP2SETINDICES;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    DWORD VStart;
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE;
typedef D3DHAL_DP2DRAWPRIMITIVE  *LPD3DHAL_DP2DRAWPRIMITIVE;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    INT   BaseVertexIndex;          // Vertex which corresponds to index 0
    DWORD MinIndex;                 // Min vertex index in the vertex buffer
    DWORD NumVertices;              // Number of vertices starting from MinIndex
    DWORD StartIndex;               // Start index in the index buffer
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE;

typedef struct _D3DHAL_CLIPPEDTRIANGLEFAN
{
    DWORD FirstVertexOffset;            // Offset in bytes in the current stream 0
    DWORD dwEdgeFlags;
    DWORD PrimitiveCount;
} D3DHAL_CLIPPEDTRIANGLEFAN;
typedef D3DHAL_CLIPPEDTRIANGLEFAN  *LPD3DHAL_CLIPPEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    DWORD FirstVertexOffset;            // Offset in bytes in the stream 0
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE2;
typedef D3DHAL_DP2DRAWPRIMITIVE2  *LPD3DHAL_DP2DRAWPRIMITIVE2;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    INT   BaseVertexOffset;     // Stream 0 offset of the vertex which
                                // corresponds to index 0. This offset could be
                                // negative, but when an index is added to the
                                // offset the result is positive
    DWORD MinIndex;             // Min vertex index in the vertex buffer
    DWORD NumVertices;          // Number of vertices starting from MinIndex
    DWORD StartIndexOffset;     // Offset of the start index in the index buffer
    DWORD PrimitiveCount;       // Number of triangles (points, lines)
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE2  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2;

// Used by SetPixelShader and DeletePixelShader
typedef struct _D3DHAL_DP2PIXELSHADER
{
    // Pixel shader handle.
    // The handle could be 0, meaning that the current pixel shader is invalid
    // (not set).
    DWORD dwHandle;
} D3DHAL_DP2PIXELSHADER;
typedef D3DHAL_DP2PIXELSHADER  *LPD3DHAL_DP2PIXELSHADER;

typedef struct _D3DHAL_DP2CREATEPIXELSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwCodeSize;   // Shader code size in bytes
    // Shader code follows
} D3DHAL_DP2CREATEPIXELSHADER;
typedef D3DHAL_DP2CREATEPIXELSHADER  *LPD3DHAL_DP2CREATEPIXELSHADER;

typedef struct _D3DHAL_DP2SETPIXELSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DHAL_DP2SETPIXELSHADERCONST;
typedef D3DHAL_DP2SETPIXELSHADERCONST  *LPD3DHAL_DP2SETPIXELSHADERCONST;

// Flags that can be supplied to DRAWRECTPATCH and DRAWTRIPATCH
#define RTPATCHFLAG_HASSEGS  0x00000001L
#define RTPATCHFLAG_HASINFO  0x00000002L

typedef struct _D3DHAL_DP2DRAWRECTPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[4] NumSegments and/or D3DRECTPATCH_INFO
} D3DHAL_DP2DRAWRECTPATCH;
typedef D3DHAL_DP2DRAWRECTPATCH  *LPD3DHAL_DP2DRAWRECTPATCH;

typedef struct _D3DHAL_DP2DRAWTRIPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[3] NumSegments and/or D3DTRIPATCH_INFO
} D3DHAL_DP2DRAWTRIPATCH;
typedef D3DHAL_DP2DRAWTRIPATCH  *LPD3DHAL_DP2DRAWTRIPATCH;

typedef struct _D3DHAL_DP2VOLUMEBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    DWORD   dwDestX;        // dest X (width)
    DWORD   dwDestY;        // dest Y (height)
    DWORD   dwDestZ;        // dest Z (depth)
    D3DBOX  srcBox;         // src box
    DWORD   dwFlags;        // blt flags
} D3DHAL_DP2VOLUMEBLT;
typedef D3DHAL_DP2VOLUMEBLT  *LPD3DHAL_DP2VOLUMEBLT;

typedef struct _D3DHAL_DP2BUFFERBLT
{
    DWORD     dwDDDestSurface; // dest surface
    DWORD     dwDDSrcSurface;  // src surface
    DWORD     dwOffset;        // Offset in the dest surface (in BYTES)
    D3DRANGE  rSrc;            // src range
    DWORD     dwFlags;         // blt flags
} D3DHAL_DP2BUFFERBLT;
typedef D3DHAL_DP2BUFFERBLT  *LPD3DHAL_DP2BUFFERBLT;

typedef struct _D3DHAL_DP2ADDDIRTYRECT
{
    DWORD     dwSurface;      // Driver managed surface
    RECTL     rDirtyArea;     // Area marked dirty
} D3DHAL_DP2ADDDIRTYRECT;
typedef D3DHAL_DP2ADDDIRTYRECT  *LPD3DHAL_DP2ADDDIRTYRECT;

typedef struct _D3DHAL_DP2ADDDIRTYBOX
{
    DWORD     dwSurface;      // Driver managed volume
    D3DBOX    DirtyBox;       // Box marked dirty
} D3DHAL_DP2ADDDIRTYBOX;
typedef D3DHAL_DP2ADDDIRTYBOX  *LPD3DHAL_DP2ADDDIRTYBOX;

#endif /* DIRECT3D_VERSION >= 0x0800 */

typedef struct _D3DHAL_DRAWPRIMITIVES2DATA {
    ULONG_PTR             dwhContext;           // in: Context handle
    DWORD             dwFlags;              // in: flags
    DWORD             dwVertexType;         // in: vertex type
    LPDDRAWI_DDRAWSURFACE_LCL lpDDCommands; // in: vertex buffer command data
    DWORD             dwCommandOffset;      // in: offset to start of vertex buffer commands
    DWORD             dwCommandLength;      // in: number of bytes of command data
    union
    { // based on D3DHALDP2_USERMEMVERTICES flag
       LPDDRAWI_DDRAWSURFACE_LCL lpDDVertex;// in: surface containing vertex data
       LPVOID lpVertices;                   // in: User mode pointer to vertices
    };
    DWORD             dwVertexOffset;       // in: offset to start of vertex data
    DWORD             dwVertexLength;       // in: number of vertices of vertex data
    DWORD             dwReqVertexBufSize;   // in: number of bytes required for the next vertex buffer
    DWORD             dwReqCommandBufSize;  // in: number of bytes required for the next commnand buffer
    LPDWORD           lpdwRStates;          // in: Pointer to the array where render states are updated
    union
    {
       DWORD          dwVertexSize;         // in: Size of each vertex in bytes
       HRESULT        ddrval;               // out: return value
    };
    DWORD             dwErrorOffset;        // out: offset in lpDDCommands to
                                            //      first D3DHAL_COMMAND not handled
} D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DHAL_DRAWPRIMITIVES2DATA  *LPD3DHAL_DRAWPRIMITIVES2DATA;

// Macros to access vertex shader binary code

#define D3DSI_GETREGTYPE(token) (token & D3DSP_REGTYPE_MASK)
#define D3DSI_GETREGNUM(token)  (token & D3DSP_REGNUM_MASK)
#define D3DSI_GETOPCODE(command) (command & D3DSI_OPCODE_MASK)
#define D3DSI_GETWRITEMASK(token) (token & D3DSP_WRITEMASK_ALL)
#define D3DVS_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define D3DVS_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define D3DVS_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define D3DVS_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DHALDP2_EXECUTEBUFFER     0x00000002L
// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Used by the driver to ask runtime to parse the execute buffer
#define D3DERR_COMMAND_UNPARSED              MAKE_DDHRESULT(3000)

typedef DWORD (CALLBACK *LPD3DHAL_CLEAR2CB)        (LPD3DHAL_CLEAR2DATA);
typedef DWORD (CALLBACK *LPD3DHAL_VALIDATETEXTURESTAGESTATECB)(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVES2CB)  (LPD3DHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DHAL_CALLBACKS3
{
    DWORD   dwSize;         // size of struct
    DWORD   dwFlags;        // flags for callbacks
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPVOID                                  lpvReserved;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;
} D3DHAL_CALLBACKS3;
typedef D3DHAL_CALLBACKS3 *LPD3DHAL_CALLBACKS3;
#define D3DHAL_CALLBACKS3SIZE       sizeof(D3DHAL_CALLBACKS3)

//  bit definitions for D3DHAL
#define D3DHAL3_CB32_CLEAR2                      0x00000001L
#define D3DHAL3_CB32_RESERVED                    0x00000002L
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE   0x00000004L
#define D3DHAL3_CB32_DRAWPRIMITIVES2             0x00000008L

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#define D3DTSS_TEXTUREMAP 0

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DHAL_SCENE_CAPTURE_START  0x00000000L
#define D3DHAL_SCENE_CAPTURE_END    0x00000001L

/*
 * Execute()
 */

/*
 * Use the instruction stream starting at dwOffset.
 */
#define D3DHAL_EXECUTE_NORMAL       0x00000000L

/*
 * Use the optional instruction override (diInstruction) and return
 * after completion.  dwOffset is the offset to the first primitive.
 */
#define D3DHAL_EXECUTE_OVERRIDE     0x00000001L

/*
 * GetState()
 * The driver will get passed a flag in dwWhich specifying which module
 * the state must come from.  The driver then fills in ulArg[1] with the
 * appropriate value depending on the state type given in ddState.
 */

/*
 * The following are used to get the state of a particular stage of the
 * pipeline.
 */
#define D3DHALSTATE_GET_TRANSFORM   0x00000001L
#define D3DHALSTATE_GET_LIGHT       0x00000002L
#define D3DHALSTATE_GET_RENDER      0x00000004L


/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DHAL_CONTEXT_BAD      0x000000200L

/*
 * No more contexts left.
 */
#define D3DHAL_OUTOFCONTEXTS        0x000000201L

/*
 * Execute() and ExecuteClipped()
 */

/*
 * Executed to completion via early out.
 *  (e.g. totally clipped)
 */
#define D3DHAL_EXECUTE_ABORT        0x00000210L

/*
 * An unhandled instruction code was found (e.g. D3DOP_TRANSFORM).
 * The dwOffset parameter must be set to the offset of the unhandled
 * instruction.
 *
 * Only valid from Execute()
 */
#define D3DHAL_EXECUTE_UNHANDLED    0x00000211L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                         LPVOID *lplpvReturnedCommand);

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE     62      // DDI only to replace SceneCapture
#define D3DRS_DELETERTPATCH       169     // DDI only to delete high order patch

//-----------------------------------------------------------------------------
//
// DirectX 8.0's new driver info querying mechanism.
//
// How to handle the new driver info query mechanism.
//
// DirectX 8.0 utilizes an extension to GetDriverInfo() to query for
// additional information from the driver. Currently this mechanism is only
// used for querying for DX8 style D3D caps but it may be used for other
// information over time.
//
// This extension to GetDriverInfo takes the form of a GetDriverInfo call
// with the GUID GUID_GetDriverInfo2. When a GetDriverInfo call with this
// GUID is received by the driver the driver must check the data passed
// in the lpvData field of the DD_GETDRIVERINFODATA data structure to see
// what information is being requested.
//
// It is important to note that the GUID GUID_GetDriverInfo2 is, in fact,
// the same as the GUID_DDStereoMode. If you driver doesn't handle
// GUID_DDStereoMode this is not an issue. However, if you wish your driver
// to handle GUID_DDStereoMode as well as GUID_GetDriverInfo2 special action
// must be taken. When a call tp GetDriverInfo with the GUID
// GUID_GetDriverInfo2/GUID_DDStereoMode is made the runtime sets the
// dwHeight field of the DD_STEREOMODE structure to the special value
// D3DGDI2_MAGIC. In this way you can determine when the request is a
// stereo mode call or a GetDriverInfo2 call. The dwHeight field of
// DD_STEREOMODE corresponds to the dwMagic field of the
// DD_GETDRIVERINFO2DATA structure.
//
// The dwExpectedSize field of the DD_GETDRIVERINFODATA structure is not
// used by when a GetDriverInfo2 request is being made and should be
// ignored. The actual expected size of the data is found in the
// dwExpectedSize of the DD_GETDRIVERINFO2DATA structure.
//
// Once the driver has determined that this is a call to
// GetDriverInfo2 it must then determine the type of information being
// requested by the runtime. This type is contained in the dwType field
// of the DD_GETDRIVERINFO2DATA data structure.
//
// Finally, once the driver knows this is a GetDriverInfo2 request of a
// particular type it can copy the requested data into the data buffer.
// It is important to note that the lpvData field of the DD_GETDRIVERINFODATA
// data structure points to data buffer in which to copy your data. lpvData
// also points to the DD_GETDRIVERINFO2DATA structure. This means that the
// data returned by the driver will overwrite the DD_GETDRIVERINFO2DATA
// structure and, hence, the DD_GETDRIVERINFO2DATA structure occupies the
// first few DWORDs of the buffer.
//
// The following code fragment demonstrates how to handle GetDriverInfo2.
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (((DD_GETDRIVERINFO2DATA*)(lpData->lpvData))->dwMagic == D3DGDI2_MAGIC)
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = lpData->lpvData;
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = lpData->lpvData;
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// The data structure which is passed to the driver when GetDriverInfo is
// called with a GUID of GUID_GetDriverInfo2.
//
// NOTE: Although the fields listed below are all read only this data
// structure is actually the first four DWORDs of the data buffer into
// which the driver writes the requested infomation. As such, these fields
// (and the entire data structure) are overwritten by the data returned by
// the driver.
//
typedef struct _DD_GETDRIVERINFO2DATA
{
    DWORD       dwReserved;     // Reserved Field.
                                // Driver should not read or write this field.

    DWORD       dwMagic;        // Magic Number. Has the value D3DGDI2_MAGIC if
                                // this is a GetDriverInfo2 call. Otherwise
                                // this structure is, in fact, a DD_STEREOMODE
                                // call.
                                // Driver should only read this field.

    DWORD       dwType;         // Type of information requested. This field
                                // contains one of the DDGDI2_TYPE_ #defines
                                // listed below.
                                // Driver should only read (not write) this
                                // field.

    DWORD       dwExpectedSize; // Expected size of the information requested.
                                // Driver should only read (not write) this
                                // field.

    // The remainder of the data buffer (beyond the first four DWORDs)
    // follows here.
} DD_GETDRIVERINFO2DATA;

//
// IMPORTANT NOTE: This GUID has exactly the same value as GUID_DDStereoMode
// and as such you must be very careful when using it. If your driver needs
// to handle both GetDriverInfo2 and DDStereoMode it must have a single
// check for the shared GUID and then distinguish between which use of that
// GUID is being requested.
//
#define GUID_GetDriverInfo2 (GUID_DDStereoMode)

//
// Magic value used to determine whether a GetDriverInfo call with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode is a GetDriverInfo2 request
// or a query about stereo capabilities. This magic number is stored in
// the dwHeight field of the DD_STEREOMODE data structure.
//
#define D3DGDI2_MAGIC       (0xFFFFFFFFul)

//
// The types of information which can be requested from the driver via
// GetDriverInfo2.
//

#define D3DGDI2_TYPE_GETD3DCAPS8    (0x00000001ul)  // Return the D3DCAPS8 data
#define D3DGDI2_TYPE_GETFORMATCOUNT (0x00000002ul)  // Return the number of supported formats
#define D3DGDI2_TYPE_GETFORMAT      (0x00000003ul)  // Return a particular format
#define D3DGDI2_TYPE_DXVERSION      (0x00000004ul)  // Notify driver of current DX Version
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE     (0x00000018ul) // Runtime is aware of deferred AGP frees, and will send following (NT only)
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP      (0x00000019ul) // Free any deferred-freed AGP allocations for this process (NT only)
#define D3DGDI2_TYPE_DEFER_AGP_FREES        (0x00000020ul) // Start defering AGP frees for this process

//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETFORMATCOUNT. It simply
// gives the number of surface formats supported by the driver. Currently this
// structure consists of a single member giving the number of supported
// surface formats.
//
typedef struct _DD_GETFORMATCOUNTDATA
{
    DD_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatCount; // [out]    Number of supported surface formats
    DWORD                 dwReserved;    // Reserved
} DD_GETFORMATCOUNTDATA;

//
// This data structure is used to request a specific surface format from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETFORMATCOUNT request.
//
typedef struct _DD_GETFORMATDATA
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatIndex;    // [in]     The format to return
    DDPIXELFORMAT         format;           // [out]    The actual format
} DD_GETFORMATDATA;

//
// This data structure is used to notify drivers about the DirectX version
// number. This is the value that is denoted as DD_RUNTIME_VERSION in the
// DDK headers.
//
typedef struct _DD_DXVERSION
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwDXVersion;      // [in]     The Version of DX
    DWORD                 dwReserved;       // Reserved
} DD_DXVERSION;

// Informs driver that runtime will send a notification after last outstanding AGP
// lock has been released. 
typedef struct _DD_DEFERRED_AGP_AWARE_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
} DD_DEFERRED_AGP_AWARE_DATA;

// Notification that the last AGP lock has been released. Driver can free all deferred AGP 
// allocations for this process.
typedef struct _DD_FREE_DEFERRED_AGP_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
    DWORD dwProcessId;                   // [in] Process ID for whom to free deferred AGP
} DD_FREE_DEFERRED_AGP_DATA;

// New Caps that are not API visible that the driver exposes.
#define D3DDEVCAPS_HWVERTEXBUFFER       0x02000000L /* Device supports Driver Allocated Vertex Buffers*/
#define D3DDEVCAPS_HWINDEXBUFFER        0x04000000L /* Device supports Driver Allocated Index Buffers*/
#define D3DDEVCAPS_SUBVOLUMELOCK        0x08000000L /* Device supports locking a part of volume texture*/
#ifndef D3DPMISCCAPS_FOGINFVF
#define D3DPMISCCAPS_FOGINFVF           0x00002000L /* Device supports separate fog value in the FVF */
#endif
#ifndef D3DFVF_FOG
#define D3DFVF_FOG                      0x00002000L /* There is a separate fog value in the FVF vertex */
#endif

//
// This stuff is not API visible but should be DDI visible.
// Should be in Sync with d3d8types.h
//
#define D3DFMT_D32    (D3DFORMAT)71
#define D3DFMT_S1D15  (D3DFORMAT)72
#define D3DFMT_D15S1  (D3DFORMAT)73
#define D3DFMT_S8D24  (D3DFORMAT)74
#define D3DFMT_D24S8  (D3DFORMAT)75
#define D3DFMT_X8D24  (D3DFORMAT)76
#define D3DFMT_D24X8 (D3DFORMAT)77
#define D3DFMT_X4S4D24 (D3DFORMAT)78
#define D3DFMT_D24X4S4 (D3DFORMAT)79

// Vertex Shader 1.1 register limits. D3D device must provide at least
// specified number of registers
//
#define D3DVS_INPUTREG_MAX_V1_1         16
#define D3DVS_TEMPREG_MAX_V1_1          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_MAX_V1_1         96
#define D3DVS_TCRDOUTREG_MAX_V1_1       8
#define D3DVS_ADDRREG_MAX_V1_1          1
#define D3DVS_ATTROUTREG_MAX_V1_1       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_1  128

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


#endif /* _D3DHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\d3dhalex.h ===
#ifndef _D3DHALEX_H
#define _D3DHALEX_H

//-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dhalex.h
//  Content:    Direct3D HAL Extensions and Helpers include file
//              This file contains definitions and macros which although not
//              essential for building a driver are useful helpers and
//              utilities.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Macros to help with handling the new GetDriverInfo2 mechanism. The following
// macros assist with handling the GetDriverInfo2 sub-call of GetDriverInfo.
// Two of the macros are simplified ways of differentiating between
// GetDriverInfo2 calls and DDStereoMode calls. The others are simplified ways
// of getting the data structures associated with those two calls.
//
// The following code fragment demonstrates how to handle GetDriverInfo2 using
// these macros. Compare this with the code fragment in d3dhal.h
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK 
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (D3DGDI_IS_GDI2(lpData))
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = D3DGDI_GET_GDI2_DATA(lpData);
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = D3DGDI_GET_STEREOMODE_DATA(pData);
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// Macros to determine what type of call a call to GetDriverInfo with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode. A GetDriverInfo2 call or
// a DDStereoMode call.
//
#define D3DGDI_IS_GDI2(pData) \
    ((((DD_GETDRIVERINFO2DATA*)(pData->lpvData))->dwMagic)  == D3DGDI2_MAGIC)

#define D3DGDI_IS_STEREOMODE(pData) \
    ((((DD_STEREOMODE*)        (pData->lpvData))->dwHeight) != D3DGDI2_MAGIC)

//
// Macros to return the appropriate GetDriverInfo data structure for a
// call to GetDriverInfo with the GUID GUID_GetDriverInfo2/GUID_DDStereoMode.
//
#define D3DGDI_GET_GDI2_DATA(pData) \
    (D3DGDI_IS_GDI2(pData) ? (((DD_GETDRIVERINFO2DATA*)(pData->lpvData))) : NULL)

#define D3DGDI_GET_STEREOMODE_DATA(pData) \
    (D3DGDI_IS_STEREOMODE(pData) ? (((DD_STEREOMODE*)(pData->lpvData)))   : NULL)

#endif /* _D3DHALEX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\cfgmgr32.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfgmgr32.h

Abstract:

    This module contains the user APIs for the Configuration Manager,
    along with any public data structures needed to call these APIs.

--*/

#ifndef _CFGMGR32_H_
#define _CFGMGR32_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <cfg.h>

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifdef __cplusplus
extern "C" {
#endif

#if !defined (_CFGMGR32_)
#define CMAPI     DECLSPEC_IMPORT
#else
#define CMAPI
#endif

typedef  CONST VOID *PCVOID;



//--------------------------------------------------------------
// General size definitions
//--------------------------------------------------------------

#define MAX_DEVICE_ID_LEN     200
#define MAX_DEVNODE_ID_LEN    MAX_DEVICE_ID_LEN

#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null
#define MAX_CLASS_NAME_LEN    32
#define MAX_PROFILE_LEN       80

#define MAX_CONFIG_VALUE      9999
#define MAX_INSTANCE_VALUE    9999

#define MAX_MEM_REGISTERS     9     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IO_PORTS          20    // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IRQS              7     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_DMA_CHANNELS      7     // Win95 compatibility--not applicable to 32-bit ConfigMgr

#define DWORD_MAX             0xFFFFFFFF
#define DWORDLONG_MAX         0xFFFFFFFFFFFFFFFF

#define CONFIGMG_VERSION      0x0400


//--------------------------------------------------------------
// Data types
//--------------------------------------------------------------


//
// Work around weirdness with Win32 typedef...
//
#ifdef NT_INCLUDED

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef unsigned __int64 DWORDLONG;
#else
typedef double DWORDLONG;
#endif
typedef DWORDLONG *PDWORDLONG;

#endif /* NT_INCLUDED */


//
// Standardized Return Value data type
//
typedef DWORD        RETURN_TYPE;
typedef RETURN_TYPE  CONFIGRET;

//
// Device Instance Handle data type
//
typedef DWORD       DEVNODE, DEVINST;
typedef DEVNODE    *PDEVNODE, *PDEVINST;

//
// Device Instance Identifier data type
// The device instance ID specifies the registry path, relative to the
// Enum key , for a device instance.  For example:  \Root\*PNP0500\0000.
//
typedef CHAR          *DEVNODEID_A, *DEVINSTID_A; // Device ID ANSI name.
typedef WCHAR         *DEVNODEID_W, *DEVINSTID_W; // Device ID Unicode name.
#ifdef UNICODE
typedef DEVNODEID_W DEVNODEID;
typedef DEVINSTID_W DEVINSTID;
#else
typedef DEVNODEID_A DEVNODEID;
typedef DEVINSTID_A DEVINSTID;
#endif

//
// Logical Configuration Handle data type
//
typedef DWORD_PTR    LOG_CONF;
typedef LOG_CONF    *PLOG_CONF;

//
// Resource Descriptor Handle data type
//
typedef DWORD_PTR    RES_DES;
typedef RES_DES     *PRES_DES;

//
// Resource ID data type (may take any of the ResType_* values)
//
typedef ULONG        RESOURCEID;
typedef RESOURCEID  *PRESOURCEID;

//
// Priority data type (may take any of the LCPRI_* values)
//
typedef ULONG        PRIORITY;
typedef PRIORITY     *PPRIORITY;

//
// Range List Handle data type
//
typedef DWORD_PTR          RANGE_LIST;
typedef RANGE_LIST        *PRANGE_LIST;

//
// Range Element Handle data type
//
typedef DWORD_PTR          RANGE_ELEMENT;
typedef RANGE_ELEMENT     *PRANGE_ELEMENT;

//
// Machine Handle data type
//
typedef  HANDLE             HMACHINE;
typedef  HMACHINE          *PHMACHINE;

//
// Conflict List data types
//
typedef ULONG_PTR           CONFLICT_LIST;
typedef CONFLICT_LIST      *PCONFLICT_LIST;

typedef struct _CONFLICT_DETAILS_A {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    CHAR        CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_A , *PCONFLICT_DETAILS_A;

typedef struct _CONFLICT_DETAILS_W {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    WCHAR       CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_W , *PCONFLICT_DETAILS_W;

#ifdef UNICODE
typedef CONFLICT_DETAILS_W CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_W PCONFLICT_DETAILS;
#else
typedef CONFLICT_DETAILS_A CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_A PCONFLICT_DETAILS;
#endif

#define CM_CDMASK_DEVINST      (0x00000001)   // mask to retrieve CD_dnDevInst attribute for conflict
#define CM_CDMASK_RESDES       (0x00000002)   // mask to retrieve CD_rdResDes attribute for conflict
#define CM_CDMASK_FLAGS        (0x00000004)   // mask to retrieve CD_ulFlags attribute for conflict
#define CM_CDMASK_DESCRIPTION  (0x00000008)   // mask to retrieve CD_szDescription attribute for conflict
#define CM_CDMASK_VALID        (0x0000000F)   // valid bits

#define CM_CDFLAGS_DRIVER      (0x00000001)     // CD_ulFlags: CD_szDescription reports back legacy driver name
#define CM_CDFLAGS_ROOT_OWNED  (0x00000002)     // CD_ulFlags: Root owned device
#define CM_CDFLAGS_RESERVED    (0x00000004)     // CD_ulFlags: Specified range is not available for use

typedef  ULONG             REGDISPOSITION;



//
// use 1 byte packing for the data structures
//
#include "pshpack1.h"



//--------------------------------------------------------------
// Memory resource
//--------------------------------------------------------------

//
// Define the attribute flags for memory ranges.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define mMD_MemoryType              (0x1) // Bitmask, whether memory is writable
#define fMD_MemoryType              mMD_MemoryType // compatibility
#define fMD_ROM                     (0x0) // Memory range is read-only
#define fMD_RAM                     (0x1) // Memory range may be written to

#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
#define fMD_32_24                   mMD_32_24 // compatibility
#define fMD_24                      (0x0) // Memory range is 24-bit
#define fMD_32                      (0x2) // Memory range is 32-bit

#define mMD_Prefetchable            (0x4) // Bitmask,whether memory prefetchable
#define fMD_Prefetchable            mMD_Prefetchable // compatibility
#define fMD_Pref                    mMD_Prefetchable // compatibility
#define fMD_PrefetchDisallowed      (0x0) // Memory range is not prefetchable
#define fMD_PrefetchAllowed         (0x4) // Memory range is prefetchable

#define mMD_Readable                (0x8) // Bitmask,whether memory is readable
#define fMD_Readable                mMD_Readable // compatibility
#define fMD_ReadAllowed             (0x0) // Memory range is readable
#define fMD_ReadDisallowed          (0x8) // Memory range is write-only

#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
#define fMD_Cacheable               (0x20) // Memory range is cacheable

//
// MEM_RANGE Structure
//
typedef struct Mem_Range_s {
   DWORDLONG MR_Align;     // specifies mask for base alignment
   ULONG     MR_nBytes;    // specifies number of bytes required
   DWORDLONG MR_Min;       // specifies minimum address of the range
   DWORDLONG MR_Max;       // specifies maximum address of the range
   DWORD     MR_Flags;     // specifies flags describing range (fMD flags)
   DWORD     MR_Reserved;
} MEM_RANGE, *PMEM_RANGE;

//
// MEM_DES structure
//
typedef struct Mem_Des_s {
   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
   DWORDLONG MD_Alloc_End;    // end of allocated range
   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
   DWORD     MD_Reserved;
} MEM_DES, *PMEM_DES;

//
// MEM_RESOURCE structure
//
typedef struct Mem_Resource_s {
   MEM_DES   MEM_Header;               // info about memory range list
   MEM_RANGE MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE, *PMEM_RESOURCE;

//
// Define the size of each range structure
//
#define MType_Range     sizeof(struct Mem_Range_s)



//--------------------------------------------------------------
// I/O Port Resource
//--------------------------------------------------------------

//
// Define the attribute flags for port resources.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
#define fIOD_Memory     (0x0) // Port resource really uses memory
#define fIOD_IO         (0x1) // Port resource uses IO ports
#define fIOD_DECODE     (0x00fc) // decode flags
#define fIOD_10_BIT_DECODE    (0x0004)
#define fIOD_12_BIT_DECODE    (0x0008)
#define fIOD_16_BIT_DECODE    (0x0010)
#define fIOD_POSITIVE_DECODE  (0x0020)
#define fIOD_PASSIVE_DECODE   (0x0040)
#define fIOD_WINDOW_DECODE    (0x0080)

//
// these are for compatiblity
//
#define IO_ALIAS_10_BIT_DECODE      (0x00000004)
#define IO_ALIAS_12_BIT_DECODE      (0x00000010)
#define IO_ALIAS_16_BIT_DECODE      (0x00000000)
#define IO_ALIAS_POSITIVE_DECODE    (0x000000FF)

//
// IO_RANGE structure
//
typedef struct IO_Range_s {
   DWORDLONG IOR_Align;      // mask for base alignment
   DWORD     IOR_nPorts;     // number of ports
   DWORDLONG IOR_Min;        // minimum port address
   DWORDLONG IOR_Max;        // maximum port address
   DWORD     IOR_RangeFlags; // flags for this port range
   DWORDLONG IOR_Alias;      // multiplier that generates aliases for port(s)
} IO_RANGE, *PIO_RANGE;

//
// IO_DES structure
//
typedef struct IO_Des_s {
   DWORD     IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   DWORD     IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   DWORDLONG IOD_Alloc_Base;     // base of allocated port range
   DWORDLONG IOD_Alloc_End;      // end of allocated port range
   DWORD     IOD_DesFlags;       // flags relating to allocated port range
} IO_DES, *PIO_DES;

//
// IO_RESOURCE
//
typedef struct IO_Resource_s {
   IO_DES   IO_Header;                 // info about I/O port range list
   IO_RANGE IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE, *PIO_RESOURCE;

#define IOA_Local       0xff

//
// Define the size of each range structure
//
#define IOType_Range    sizeof(struct IO_Range_s)



//--------------------------------------------------------------
// DMA Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a DMA resource range.  Each bit flag is
// identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
#define fDD_BYTE          (0x0)    //   8-bit DMA channel
#define fDD_WORD          (0x1)    //   16-bit DMA channel
#define fDD_DWORD         (0x2)    //   32-bit DMA channel
#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
#define fDD_NoBusMaster   (0x0)    //   no bus mastering
#define fDD_BusMaster     (0x4)    //   bus mastering

#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
#define fDD_TypeStandard (0x00)    //   standard DMA
#define fDD_TypeA        (0x08)    //   Type-A DMA
#define fDD_TypeB        (0x10)    //   Type-B DMA
#define fDD_TypeF        (0x18)    //   Type-F DMA


//
// DMA_RANGE structure
//
typedef struct DMA_Range_s {
   ULONG DR_Min;     // minimum DMA port in the range
   ULONG DR_Max;     // maximum DMA port in the range
   ULONG DR_Flags;   // flags describing the range (fDD flags)
} DMA_RANGE, *PDMA_RANGE;

//
// DMA_DES structure
//
typedef struct DMA_Des_s {
   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
} DMA_DES, *PDMA_DES;

//
// DMA_RESOURCE
//
typedef struct DMA_Resource_s {
   DMA_DES   DMA_Header;               // info about DMA channel range list
   DMA_RANGE DMA_Data[ANYSIZE_ARRAY];  // list of DMA ranges
} DMA_RESOURCE, *PDMA_RESOURCE;

//
// Define the size of each range structure
//
#define DType_Range     sizeof(struct DMA_Range_s)



//--------------------------------------------------------------
// Interrupt Resource
//--------------------------------------------------------------

//
// Define the attribute flags for an interrupt resource range.  Each bit flag
// is identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mIRQD_Share        (0x1) // Bitmask,whether the IRQ may be shared:
#define fIRQD_Exclusive    (0x0) //   The IRQ may not be shared
#define fIRQD_Share        (0x1) //   The IRQ may be shared

#define fIRQD_Share_Bit    0     // compatibility
#define fIRQD_Level_Bit    1     // compatibility

//
// ** NOTE: 16-bit ConfigMgr uses fIRQD_Level_Bit being set to indicate that the
// ** interrupt is _level-sensitive_.  For 32-bit ConfigMgr, if this bit is set,
// ** then the interrupt is _edge-sensitive_.
//
#define mIRQD_Edge_Level   (0x2) // Bitmask,whether edge or level triggered:
#define fIRQD_Level        (0x0) //   The IRQ is level-sensitive
#define fIRQD_Edge         (0x2) //   The IRQ is edge-sensitive

//
// IRQ_RANGE
//
typedef struct IRQ_Range_s {
   ULONG IRQR_Min;      // minimum IRQ in the range
   ULONG IRQR_Max;      // maximum IRQ in the range
   ULONG IRQR_Flags;    // flags describing the range (fIRQD flags)
} IRQ_RANGE, *PIRQ_RANGE;

//
// IRQ_DES structure
//
typedef struct IRQ_Des_32_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG32 IRQD_Affinity;
} IRQ_DES_32, *PIRQ_DES_32;

typedef struct IRQ_Des_64_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG64 IRQD_Affinity;
} IRQ_DES_64, *PIRQ_DES_64;

#ifdef _WIN64
typedef IRQ_DES_64   IRQ_DES;
typedef PIRQ_DES_64  PIRQ_DES;
#else
typedef IRQ_DES_32   IRQ_DES;
typedef PIRQ_DES_32  PIRQ_DES;
#endif

//
// IRQ_RESOURCE structure
//
typedef struct IRQ_Resource_32_s {
   IRQ_DES_32   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_32, *PIRQ_RESOURCE_32;

typedef struct IRQ_Resource_64_s {
   IRQ_DES_64   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_64, *PIRQ_RESOURCE_64;

#ifdef _WIN64
typedef IRQ_RESOURCE_64  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_64 PIRQ_RESOURCE;
#else
typedef IRQ_RESOURCE_32  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_32 PIRQ_RESOURCE;
#endif

//
// Define the size of each range structure
//
#define IRQType_Range   sizeof(struct IRQ_Range_s)

//
// Flags for resource descriptor APIs indicating the width of certain
// variable-size resource descriptor structure fields, where applicable.
//
#define CM_RESDES_WIDTH_DEFAULT (0x00000000)  // 32 or 64-bit IRQ_RESOURCE / IRQ_DES, based on client
#define CM_RESDES_WIDTH_32      (0x00000001)  // 32-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_64      (0x00000002)  // 64-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_BITS    (0x00000003)

//--------------------------------------------------------------
// Device Private Resource
//--------------------------------------------------------------

//
// DEVICEPRIVATE_RANGE structure
//

typedef struct DevPrivate_Range_s {
   DWORD    PR_Data1;     // mask for base alignment
   DWORD    PR_Data2;     // number of bytes
   DWORD    PR_Data3;     // minimum address
} DEVPRIVATE_RANGE, *PDEVPRIVATE_RANGE;

//
// DEVPRIVATE_DES structure
//
typedef struct DevPrivate_Des_s {
   DWORD     PD_Count;
   DWORD     PD_Type;
   DWORD     PD_Data1;
   DWORD     PD_Data2;
   DWORD     PD_Data3;
   DWORD     PD_Flags;
} DEVPRIVATE_DES, *PDEVPRIVATE_DES;

//
// DEVPRIVATE_RESOURCE
//
typedef struct DevPrivate_Resource_s {
   DEVPRIVATE_DES   PRV_Header;
   DEVPRIVATE_RANGE PRV_Data[ANYSIZE_ARRAY];
} DEVPRIVATE_RESOURCE, *PDEVPRIVATE_RESOURCE;

//
// Define the size of each range structure
//
#define PType_Range    sizeof(struct DevPrivate_Range_s)



//--------------------------------------------------------------
// Class-Specific Resource
//--------------------------------------------------------------

typedef struct CS_Des_s {
   DWORD    CSD_SignatureLength;
   DWORD    CSD_LegacyDataOffset;
   DWORD    CSD_LegacyDataSize;
   DWORD    CSD_Flags;
   GUID     CSD_ClassGuid;
   BYTE     CSD_Signature[ANYSIZE_ARRAY];
} CS_DES, *PCS_DES;

typedef struct CS_Resource_s {
   CS_DES   CS_Header;
} CS_RESOURCE, *PCS_RESOURCE;



//--------------------------------------------------------------
// PC Card Configuration Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a PC Card configuration resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
#define mPCD_IO_8_16        (0x1)   // Bitmask, whether I/O is 8 or 16 bits
#define fPCD_IO_8           (0x0)   // I/O is 8-bit
#define fPCD_IO_16          (0x1)   // I/O is 16-bit
#define mPCD_MEM_8_16       (0x2)   // Bitmask, whether MEM is 8 or 16 bits
#define fPCD_MEM_8          (0x0)   // MEM is 8-bit
#define fPCD_MEM_16         (0x2)   // MEM is 16-bit
#define mPCD_MEM_A_C        (0xC)   // Bitmask, whether MEMx is Attribute or Common
#define fPCD_MEM1_A         (0x4)   // MEM1 is Attribute
#define fPCD_MEM2_A         (0x8)   // MEM2 is Attribute
#define fPCD_IO_ZW_8        (0x10)  // zero wait on 8 bit I/O
#define fPCD_IO_SRC_16      (0x20)  // iosrc 16
#define fPCD_IO_WS_16       (0x40)  // wait states on 16 bit io
#define mPCD_MEM_WS         (0x300) // Bitmask, for additional wait states on memory windows
#define fPCD_MEM_WS_ONE     (0x100) // 1 wait state
#define fPCD_MEM_WS_TWO     (0x200) // 2 wait states
#define fPCD_MEM_WS_THREE   (0x300) // 3 wait states

#define fPCD_MEM_A          (0x4)   // MEM is Attribute

#define fPCD_ATTRIBUTES_PER_WINDOW (0x8000)

#define fPCD_IO1_16         (0x00010000)  // I/O window 1 is 16-bit
#define fPCD_IO1_ZW_8       (0x00020000)  // I/O window 1 zero wait on 8 bit I/O
#define fPCD_IO1_SRC_16     (0x00040000)  // I/O window 1 iosrc 16
#define fPCD_IO1_WS_16      (0x00080000)  // I/O window 1 wait states on 16 bit io

#define fPCD_IO2_16         (0x00100000)  // I/O window 2 is 16-bit
#define fPCD_IO2_ZW_8       (0x00200000)  // I/O window 2 zero wait on 8 bit I/O
#define fPCD_IO2_SRC_16     (0x00400000)  // I/O window 2 iosrc 16
#define fPCD_IO2_WS_16      (0x00800000)  // I/O window 2 wait states on 16 bit io

#define mPCD_MEM1_WS        (0x03000000)  // MEM window 1 Bitmask, for additional wait states on memory windows
#define fPCD_MEM1_WS_ONE    (0x01000000)  // MEM window 1, 1 wait state
#define fPCD_MEM1_WS_TWO    (0x02000000)  // MEM window 1, 2 wait states
#define fPCD_MEM1_WS_THREE  (0x03000000)  // MEM window 1, 3 wait states
#define fPCD_MEM1_16        (0x04000000)  // MEM window 1 is 16-bit

#define mPCD_MEM2_WS        (0x30000000)  // MEM window 2 Bitmask, for additional wait states on memory windows
#define fPCD_MEM2_WS_ONE    (0x10000000)  // MEM window 2, 1 wait state
#define fPCD_MEM2_WS_TWO    (0x20000000)  // MEM window 2, 2 wait states
#define fPCD_MEM2_WS_THREE  (0x30000000)  // MEM window 2, 3 wait states
#define fPCD_MEM2_16        (0x40000000)  // MEM window 2 is 16-bit

#define PCD_MAX_MEMORY   2
#define PCD_MAX_IO       2


typedef struct PcCard_Des_s {
    DWORD    PCD_Count;
    DWORD    PCD_Type;
    DWORD    PCD_Flags;
    BYTE     PCD_ConfigIndex;
    BYTE     PCD_Reserved[3];
    DWORD    PCD_MemoryCardBase1;
    DWORD    PCD_MemoryCardBase2;
    DWORD    PCD_MemoryCardBase[PCD_MAX_MEMORY];            // will soon be removed
    WORD     PCD_MemoryFlags[PCD_MAX_MEMORY];               // will soon be removed
    BYTE     PCD_IoFlags[PCD_MAX_IO];                       // will soon be removed
} PCCARD_DES, *PPCCARD_DES;

typedef struct PcCard_Resource_s {
   PCCARD_DES   PcCard_Header;
} PCCARD_RESOURCE, *PPCCARD_RESOURCE;

//--------------------------------------------------------------
// MF (multifunction) PCCard Configuration Resource
//--------------------------------------------------------------

#define mPMF_AUDIO_ENABLE   (0x8)   // Bitmask, whether audio is enabled or not
#define fPMF_AUDIO_ENABLE   (0x8)   // Audio is enabled

typedef struct MfCard_Des_s {
    DWORD    PMF_Count;
    DWORD    PMF_Type;
    DWORD    PMF_Flags;
    BYTE     PMF_ConfigOptions;
    BYTE     PMF_IoResourceIndex;
    BYTE     PMF_Reserved[2];
    DWORD    PMF_ConfigRegisterBase;
} MFCARD_DES, *PMFCARD_DES;

typedef struct MfCard_Resource_s {
   MFCARD_DES   MfCard_Header;
} MFCARD_RESOURCE, *PMFCARD_RESOURCE;


//--------------------------------------------------------------
// Bus Number Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a Bus Number resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
// Currently unused.
//

//
// BUSNUMBER_RANGE
//
typedef struct BusNumber_Range_s {
   ULONG BUSR_Min;          // minimum Bus Number in the range
   ULONG BUSR_Max;          // maximum Bus Number in the range
   ULONG BUSR_nBusNumbers;  // specifies number of buses required
   ULONG BUSR_Flags;        // flags describing the range (currently unused)
} BUSNUMBER_RANGE, *PBUSNUMBER_RANGE;

//
// BUSNUMBER_DES structure
//
typedef struct BusNumber_Des_s {
   DWORD BUSD_Count;       // number of BUSNUMBER_RANGE structs in BUSNUMBER_RESOURCE
   DWORD BUSD_Type;        // size (in bytes) of BUSNUMBER_RANGE (BusNumberType_Range)
   DWORD BUSD_Flags;       // flags describing the range (currently unused)
   ULONG BUSD_Alloc_Base;  // specifies the first Bus that was allocated
   ULONG BUSD_Alloc_End;   // specifies the last Bus number that was allocated
} BUSNUMBER_DES, *PBUSNUMBER_DES;

//
// BUSNUMBER_RESOURCE structure
//
typedef struct BusNumber_Resource_s {
   BUSNUMBER_DES   BusNumber_Header;               // info about Bus Number range list
   BUSNUMBER_RANGE BusNumber_Data[ANYSIZE_ARRAY];  // list of Bus Number ranges
} BUSNUMBER_RESOURCE, *PBUSNUMBER_RESOURCE;

//
// Define the size of each range structure
//
#define BusNumberType_Range   sizeof(struct BusNumber_Range_s)



//--------------------------------------------------------------
// Hardware Profile Information
//--------------------------------------------------------------

//
// Define flags relating to hardware profiles
//
#define CM_HWPI_NOT_DOCKABLE  (0x00000000)   // machine is not dockable
#define CM_HWPI_UNDOCKED      (0x00000001)   // hw profile for docked config
#define CM_HWPI_DOCKED        (0x00000002)   // hw profile for undocked config

//
// HWPROFILEINFO structure
//
typedef struct HWProfileInfo_sA {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   CHAR   HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_A, *PHWPROFILEINFO_A;

typedef struct HWProfileInfo_sW {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   WCHAR  HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_W, *PHWPROFILEINFO_W;

#ifdef UNICODE
typedef HWPROFILEINFO_W   HWPROFILEINFO;
typedef PHWPROFILEINFO_W  PHWPROFILEINFO;
#else
typedef HWPROFILEINFO_A   HWPROFILEINFO;
typedef PHWPROFILEINFO_A  PHWPROFILEINFO;
#endif


//
// revert back to normal default packing
//
#include "poppack.h"



//--------------------------------------------------------------
// Miscellaneous
//--------------------------------------------------------------


//
// Resource types
//
#define ResType_All           (0x00000000)   // Return all resource types
#define ResType_None          (0x00000000)   // Arbitration always succeeded
#define ResType_Mem           (0x00000001)   // Physical address resource
#define ResType_IO            (0x00000002)   // Physical I/O address resource
#define ResType_DMA           (0x00000003)   // DMA channels resource
#define ResType_IRQ           (0x00000004)   // IRQ resource
#define ResType_DoNotUse      (0x00000005)   // Used as spacer to sync subsequent ResTypes w/NT
#define ResType_BusNumber     (0x00000006)   // bus number resource
#define ResType_MAX           (0x00000006)   // Maximum known (arbitrated) ResType
#define ResType_Ignored_Bit   (0x00008000)   // Ignore this resource
#define ResType_ClassSpecific (0x0000FFFF)   // class-specific resource
#define ResType_Reserved      (0x00008000)   // reserved for internal use
#define ResType_DevicePrivate (0x00008001)   // device private data
#define ResType_PcCardConfig  (0x00008002)   // PC Card configuration data
#define ResType_MfCardConfig  (0x00008003)   // MF Card configuration data


//
// Flags specifying options for ranges that conflict with ranges already in
// the range list (CM_Add_Range)
//
#define CM_ADD_RANGE_ADDIFCONFLICT        (0x00000000) // merg with conflicting range
#define CM_ADD_RANGE_DONOTADDIFCONFLICT   (0x00000001) // error if range conflicts
#define CM_ADD_RANGE_BITS                 (0x00000001)


//
// Logical Config Flags (specified in call to CM_Get_First_Log_Conf
//
#define BASIC_LOG_CONF    0x00000000  // Specifies the req list.
#define FILTERED_LOG_CONF 0x00000001  // Specifies the filtered req list.
#define ALLOC_LOG_CONF    0x00000002  // Specifies the Alloc Element.
#define BOOT_LOG_CONF     0x00000003  // Specifies the RM Alloc Element.
#define FORCED_LOG_CONF   0x00000004  // Specifies the Forced Log Conf
#define OVERRIDE_LOG_CONF 0x00000005  // Specifies the Override req list.
#define NUM_LOG_CONF      0x00000006  // Number of Log Conf type
#define LOG_CONF_BITS     0x00000007  // The bits of the log conf type.

#define PRIORITY_EQUAL_FIRST  (0x00000008) // Same priority, new one first
#define PRIORITY_EQUAL_LAST   (0x00000000) // Same priority, new one last
#define PRIORITY_BIT          (0x00000008)

//
// Registry disposition values
// (specified in call to CM_Open_DevNode_Key and CM_Open_Class_Key)
//
#define RegDisposition_OpenAlways   (0x00000000)   // open if exists else create
#define RegDisposition_OpenExisting (0x00000001)   // open key only if exists
#define RegDisposition_Bits         (0x00000001)

//
// ulFlags values for CM API routines
//

//
// Flags for CM_Add_ID
//
#define CM_ADD_ID_HARDWARE                (0x00000000)
#define CM_ADD_ID_COMPATIBLE              (0x00000001)
#define CM_ADD_ID_BITS                    (0x00000001)


//
// Device Node creation flags
//
#define CM_CREATE_DEVNODE_NORMAL          (0x00000000)   // install later
#define CM_CREATE_DEVNODE_NO_WAIT_INSTALL (0x00000001)   // NOT SUPPORTED ON NT
#define CM_CREATE_DEVNODE_PHANTOM         (0x00000002)
#define CM_CREATE_DEVNODE_GENERATE_ID     (0x00000004)
#define CM_CREATE_DEVNODE_DO_NOT_INSTALL  (0x00000008)
#define CM_CREATE_DEVNODE_BITS            (0x0000000F)

#define CM_CREATE_DEVINST_NORMAL          CM_CREATE_DEVNODE_NORMAL
#define CM_CREATE_DEVINST_NO_WAIT_INSTALL CM_CREATE_DEVNODE_NO_WAIT_INSTALL
#define CM_CREATE_DEVINST_PHANTOM         CM_CREATE_DEVNODE_PHANTOM
#define CM_CREATE_DEVINST_GENERATE_ID     CM_CREATE_DEVNODE_GENERATE_ID
#define CM_CREATE_DEVINST_DO_NOT_INSTALL  CM_CREATE_DEVNODE_DO_NOT_INSTALL
#define CM_CREATE_DEVINST_BITS            CM_CREATE_DEVNODE_BITS


//
// Flags for CM_Delete_Class_Key
//
#define CM_DELETE_CLASS_ONLY        (0x00000000)
#define CM_DELETE_CLASS_SUBKEYS     (0x00000001)
#define CM_DELETE_CLASS_BITS        (0x00000001)


//
// Detection reason flags (specified in call to CM_Run_Detection)
//
#define CM_DETECT_NEW_PROFILE       (0x00000001) // detection for new hw profile
#define CM_DETECT_CRASHED           (0x00000002) // Previous detection crashed
#define CM_DETECT_HWPROF_FIRST_BOOT (0x00000004)
#define CM_DETECT_RUN               (0x80000000)
#define CM_DETECT_BITS              (0x80000007)

#define CM_DISABLE_POLITE           (0x00000000)    // Ask the driver
#define CM_DISABLE_ABSOLUTE         (0x00000001)    // Don't ask the driver
#define CM_DISABLE_HARDWARE         (0x00000002)    // Don't ask the driver, and won't be restarteable
#define CM_DISABLE_UI_NOT_OK        (0x00000004)    // Don't popup any veto API
#define CM_DISABLE_BITS             (0x00000007)    // The bits for the disable function


//
// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)

//
// Registry properties (specified in call to CM_Get_DevInst_Registry_Property or CM_Get_Class_Registry_Property,
// some are allowed in calls to CM_Set_DevInst_Registry_Property and CM_Set_Class_Registry_Property)
// CM_DRP_xxxx values should be used for CM_Get_DevInst_Registry_Property / CM_Set_DevInst_Registry_Property
// CM_CRP_xxxx values should be used for CM_Get_Class_Registry_Property / CM_Set_Class_Registry_Property
// DRP/CRP values that overlap must have a 1:1 correspondence with each other
//
#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID                  (0x00000002) // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS               (0x00000003) // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_UNUSED0                     (0x00000004) // unused
#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
#define CM_DRP_UNUSED1                     (0x00000006) // unused
#define CM_DRP_UNUSED2                     (0x00000007) // unused
#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS                 (0x0000000B) // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES                (0x00000010) // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER                   (0x00000011) // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS                (0x00000012) // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS                (0x00000013) // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID                 (0x00000014) // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE               (0x00000015) // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER                   (0x00000016) // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME             (0x00000017) // Enumerator Name REG_SZ property (R)
#define CM_DRP_SECURITY                    (0x00000018) // Security - Device override (RW)
#define CM_CRP_SECURITY                    CM_DRP_SECURITY   // Class default security (RW)
#define CM_DRP_SECURITY_SDS                (0x00000019) // Security - Device override (RW)
#define CM_CRP_SECURITY_SDS                CM_DRP_SECURITY_SDS // Class default security (RW)
#define CM_DRP_DEVTYPE                     (0x0000001A) // Device Type - Device override (RW)
#define CM_CRP_DEVTYPE                     CM_DRP_DEVTYPE    // Class default Device-type (RW)
#define CM_DRP_EXCLUSIVE                   (0x0000001B) // Exclusivity - Device override (RW)
#define CM_CRP_EXCLUSIVE                   CM_DRP_EXCLUSIVE  // Class default (RW)
#define CM_DRP_CHARACTERISTICS             (0x0000001C) // Characteristics - Device Override (RW)
#define CM_CRP_CHARACTERISTICS             CM_DRP_CHARACTERISTICS  // Class default (RW)
#define CM_DRP_ADDRESS                     (0x0000001D) // Device Address (R)
#define CM_DRP_UI_NUMBER_DESC_FORMAT       (0x0000001E) // UINumberDescFormat REG_SZ property (RW)
#define CM_DRP_DEVICE_POWER_DATA           (0x0000001F) // CM_POWER_DATA REG_BINARY property (R)
#define CM_DRP_REMOVAL_POLICY              (0x00000020) // CM_DEVICE_REMOVAL_POLICY REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_HW_DEFAULT   (0x00000021) // CM_DRP_REMOVAL_POLICY_HW_DEFAULT REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_OVERRIDE     (0x00000022) // CM_DRP_REMOVAL_POLICY_OVERRIDE REG_DWORD (RW)
#define CM_DRP_INSTALL_STATE               (0x00000023) // CM_DRP_INSTALL_STATE REG_DWORD (R)
#define CM_DRP_LOCATION_PATHS              (0x00000024) // CM_DRP_LOCATION_PATHS REG_MULTI_SZ (R)

#define CM_DRP_MIN                         (0x00000001) // First device register
#define CM_CRP_MIN                         CM_DRP_MIN   // First class register
#define CM_DRP_MAX                         (0x00000024) // Last device register
#define CM_CRP_MAX                         CM_DRP_MAX   // Last class register

//
// Capabilities bits (the capability value is returned from calling
// CM_Get_DevInst_Registry_Property with CM_DRP_CAPABILITIES property)
//
#define CM_DEVCAP_LOCKSUPPORTED     (0x00000001)
#define CM_DEVCAP_EJECTSUPPORTED    (0x00000002)
#define CM_DEVCAP_REMOVABLE         (0x00000004)
#define CM_DEVCAP_DOCKDEVICE        (0x00000008)
#define CM_DEVCAP_UNIQUEID          (0x00000010)
#define CM_DEVCAP_SILENTINSTALL     (0x00000020)
#define CM_DEVCAP_RAWDEVICEOK       (0x00000040)
#define CM_DEVCAP_SURPRISEREMOVALOK (0x00000080)
#define CM_DEVCAP_HARDWAREDISABLED  (0x00000100)
#define CM_DEVCAP_NONDYNAMIC        (0x00000200)

//
// Removal policies (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_REMOVAL_POLICY, CM_DRP_REMOVAL_POLICY_OVERRIDE, or
// CM_DRP_REMOVAL_POLICY_HW_DEFAULT properties)
//
#define CM_REMOVAL_POLICY_EXPECT_NO_REMOVAL             1
#define CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL        2
#define CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL       3

//
// Device install states (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_INSTALL_STATE properties)
//
#define CM_INSTALL_STATE_INSTALLED                      0
#define CM_INSTALL_STATE_NEEDS_REINSTALL                1
#define CM_INSTALL_STATE_FAILED_INSTALL                 2
#define CM_INSTALL_STATE_FINISH_INSTALL                 3

//
// Flags for CM_Locate_DevNode
//
#define CM_LOCATE_DEVNODE_NORMAL       0x00000000
#define CM_LOCATE_DEVNODE_PHANTOM      0x00000001
#define CM_LOCATE_DEVNODE_CANCELREMOVE 0x00000002
#define CM_LOCATE_DEVNODE_NOVALIDATION 0x00000004
#define CM_LOCATE_DEVNODE_BITS         0x00000007

#define CM_LOCATE_DEVINST_NORMAL       CM_LOCATE_DEVNODE_NORMAL
#define CM_LOCATE_DEVINST_PHANTOM      CM_LOCATE_DEVNODE_PHANTOM
#define CM_LOCATE_DEVINST_CANCELREMOVE CM_LOCATE_DEVNODE_CANCELREMOVE
#define CM_LOCATE_DEVINST_NOVALIDATION CM_LOCATE_DEVNODE_NOVALIDATION
#define CM_LOCATE_DEVINST_BITS         CM_LOCATE_DEVNODE_BITS

//
// Flags for CM_Open_Class_Key
//
#define CM_OPEN_CLASS_KEY_INSTALLER        (0x00000000)
#define CM_OPEN_CLASS_KEY_INTERFACE        (0x00000001)
#define CM_OPEN_CLASS_KEY_BITS             (0x00000001)

//
// Flags for CM_Query_And_Remove_SubTree
//
#define CM_REMOVE_UI_OK             0x00000000
#define CM_REMOVE_UI_NOT_OK         0x00000001
#define CM_REMOVE_NO_RESTART        0x00000002
#define CM_REMOVE_BITS              0x00000003

//
// Backward compatibility--do not use
// (use above CM_REMOVE_* flags instead)
//
#define CM_QUERY_REMOVE_UI_OK       (CM_REMOVE_UI_OK)
#define CM_QUERY_REMOVE_UI_NOT_OK   (CM_REMOVE_UI_NOT_OK)
#define CM_QUERY_REMOVE_BITS        (CM_QUERY_REMOVE_UI_OK|CM_QUERY_REMOVE_UI_NOT_OK)

//
// Flags for CM_Reenumerate_DevNode
//
#define CM_REENUMERATE_NORMAL                   0x00000000
#define CM_REENUMERATE_SYNCHRONOUS              0x00000001
#define CM_REENUMERATE_RETRY_INSTALLATION       0x00000002
#define CM_REENUMERATE_ASYNCHRONOUS             0x00000004
#define CM_REENUMERATE_BITS                     0x00000007

//
// Flags for CM_Register_Device_Driver
//
#define CM_REGISTER_DEVICE_DRIVER_STATIC        (0x00000000)
#define CM_REGISTER_DEVICE_DRIVER_DISABLEABLE   (0x00000001)
#define CM_REGISTER_DEVICE_DRIVER_REMOVABLE     (0x00000002)
#define CM_REGISTER_DEVICE_DRIVER_BITS          (0x00000003)

//
// Registry Branch Locations (for CM_Open_DevNode_Key)
//
#define CM_REGISTRY_HARDWARE        (0x00000000)
#define CM_REGISTRY_SOFTWARE        (0x00000001)
#define CM_REGISTRY_USER            (0x00000100)
#define CM_REGISTRY_CONFIG          (0x00000200)
#define CM_REGISTRY_BITS            (0x00000301)

//
// Flags for CM_Set_DevNode_Problem
//
#define CM_SET_DEVNODE_PROBLEM_NORMAL    (0x00000000)  // only set problem if currently no problem
#define CM_SET_DEVNODE_PROBLEM_OVERRIDE  (0x00000001)  // override current problem with new problem
#define CM_SET_DEVNODE_PROBLEM_BITS      (0x00000001)

#define CM_SET_DEVINST_PROBLEM_NORMAL    CM_SET_DEVNODE_PROBLEM_NORMAL
#define CM_SET_DEVINST_PROBLEM_OVERRIDE  CM_SET_DEVNODE_PROBLEM_OVERRIDE
#define CM_SET_DEVINST_PROBLEM_BITS      CM_SET_DEVNODE_PROBLEM_BITS

//
// Flags for CM_Set_HW_Prof_Flags
//
#define CM_SET_HW_PROF_FLAGS_UI_NOT_OK  (0x00000001)    // Don't popup any veto UI
#define CM_SET_HW_PROF_FLAGS_BITS       (0x00000001)

//
// Re-enable and configuration actions (specified in call to CM_Setup_DevInst)
//
#define CM_SETUP_DEVNODE_READY   (0x00000000) // Reenable problem devinst
#define CM_SETUP_DEVINST_READY   CM_SETUP_DEVNODE_READY
#define CM_SETUP_DOWNLOAD        (0x00000001) // Get info about devinst
#define CM_SETUP_WRITE_LOG_CONFS (0x00000002)
#define CM_SETUP_PROP_CHANGE     (0x00000003)
#define CM_SETUP_DEVNODE_RESET   (0x00000004) // Reset problem devinst without starting
#define CM_SETUP_DEVINST_RESET   CM_SETUP_DEVNODE_RESET
#define CM_SETUP_BITS            (0x00000007)

//
// Flags for CM_Query_Arbitrator_Free_Data and
// CM_Query_Arbitrator_Free_Data_Size.
//
#define CM_QUERY_ARBITRATOR_RAW         (0x00000000)
#define CM_QUERY_ARBITRATOR_TRANSLATED  (0x00000001)
#define CM_QUERY_ARBITRATOR_BITS        (0x00000001)

//
// Flags for CM_Get_DevNode_Custom_Property
//
#define CM_CUSTOMDEVPROP_MERGE_MULTISZ  (0x00000001)
#define CM_CUSTOMDEVPROP_BITS           (0x00000001)


//--------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------



CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_IDA(
             IN DEVINST dnDevInst,
             IN PSTR    pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_IDW(
             IN DEVINST dnDevInst,
             IN PWSTR   pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExA(
             IN DEVINST  dnDevInst,
             IN PSTR     pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExW(
             IN DEVINST  dnDevInst,
             IN PWSTR    pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Add_ID             CM_Add_IDW
#define CM_Add_ID_Ex          CM_Add_ID_ExW
#else
#define CM_Add_ID             CM_Add_IDA
#define CM_Add_ID_Ex          CM_Add_ID_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Add_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des_Ex(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineA(
             IN  PCSTR     UNCServerName,
             OUT PHMACHINE phMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineW(
             IN  PCWSTR    UNCServerName,
             OUT PHMACHINE phMachine
             );
#ifdef UNICODE
#define CM_Connect_Machine       CM_Connect_MachineW
#else
#define CM_Connect_Machine       CM_Connect_MachineA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
#define CM_Create_DevInstW       CM_Create_DevNodeW
#define CM_Create_DevInstA       CM_Create_DevNodeA
#define CM_Create_DevInst_ExW    CM_Create_DevNode_ExW
#define CM_Create_DevInst_ExA    CM_Create_DevNode_ExA
#ifdef UNICODE
#define CM_Create_DevNode        CM_Create_DevNodeW
#define CM_Create_DevInst        CM_Create_DevNodeW
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExW
#define CM_Create_DevInst_Ex     CM_Create_DevInst_ExW
#else
#define CM_Create_DevNode        CM_Create_DevNodeA
#define CM_Create_DevInst        CM_Create_DevNodeA
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExA
#define CM_Create_DevInst_Ex     CM_Create_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Create_Range_List(
             OUT PRANGE_LIST prlh,
             IN  ULONG       ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key_Ex(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HANDLE     hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key_Ex(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Delete_DevInst_Key       CM_Delete_DevNode_Key
#define CM_Delete_DevInst_Key_Ex    CM_Delete_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Delete_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Disable_DevInst       CM_Disable_DevNode
#define CM_Disable_DevInst_Ex    CM_Disable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Disconnect_Machine(
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Dup_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Enable_DevInst        CM_Enable_DevNode
#define CM_Enable_DevInst_Ex     CM_Enable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes_Ex(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsW
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExW
#else
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsA
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Find_Range(
             OUT PDWORDLONG pullStart,
             IN  DWORDLONG  ullStart,
             IN  ULONG      ulLength,
             IN  DWORDLONG  ullAlignment,
             IN  DWORDLONG  ullEnd,
             IN  RANGE_LIST rlh,
             IN  ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_First_Range(
             IN  RANGE_LIST     rlh,
             OUT PDWORDLONG     pullStart,
             OUT PDWORDLONG     pullEnd,
             OUT PRANGE_ELEMENT preElement,
             IN  ULONG          ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Ex(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
            IN  LOG_CONF  lcLogConf
            );


CMAPI
CONFIGRET
WINAPI
CM_Free_Range_List(
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des(
             OUT PRES_DES prdResDes,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Ex(
             OUT PRES_DES prdResDes,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Handle(
            IN  RES_DES    rdResDes
            );


CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Child_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Name        CM_Get_Class_NameW
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExW
#else
#define CM_Get_Class_Name        CM_Get_Class_NameA
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameW
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExW
#else
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameA
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Depth(
             OUT PULONG  pulDepth,
             IN  DEVINST dnDevInst,
             IN  ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Depth_Ex(
             OUT PULONG   pulDepth,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID         CM_Get_Device_IDW
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExW
#else
#define CM_Get_Device_ID         CM_Get_Device_IDA
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListW
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExW
#else
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListA
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeW
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExW
#else
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeA
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size_Ex(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Get_DevInst_Registry_PropertyW     CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_PropertyA     CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_ExW  CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevInst_Registry_Property_ExA  CM_Get_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#else
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  PCSTR       pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  PCSTR       pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Get_DevInst_Custom_PropertyW     CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_PropertyA     CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_ExW  CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevInst_Custom_Property_ExA  CM_Get_DevNode_Custom_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#else
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#define CM_Get_DevInst_Status    CM_Get_DevNode_Status
#define CM_Get_DevInst_Status_Ex CM_Get_DevNode_Status_Ex


CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State(
             OUT PULONG pulState,
             IN  ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State_Ex(
             OUT PULONG   pulState,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
#ifdef UNICODE
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoW
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExW
#else
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoA
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsW
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExW
#else
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsA
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    IN     LPCSTR  pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPSTR   pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    IN     LPCWSTR pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPWSTR  pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    IN     LPCWSTR  pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPWSTR   pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasW
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExW
#else
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasA
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListW
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExW
#else
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListA
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeW
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExW
#else
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeA
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags
        );
CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags,
        IN  HMACHINE  hMachine
        );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
             OUT PLOG_CONF plcLogConf,  OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Parent(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Ex(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size_Ex(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
WORD
WINAPI
CM_Get_Version(
             VOID
             );
CMAPI
WORD
WINAPI
CM_Get_Version_Ex(
             IN  HMACHINE    hMachine
             );



CMAPI
BOOL
WINAPI
CM_Is_Version_Available(
             IN  WORD       wVersion
             );
CMAPI
BOOL
WINAPI
CM_Is_Version_Available_Ex(
             IN  WORD       wVersion,
             IN  HMACHINE   hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Intersect_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Invert_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN DWORDLONG  ullMaxValue,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Locate_DevInstA       CM_Locate_DevNodeA
#define CM_Locate_DevInstW       CM_Locate_DevNodeW
#define CM_Locate_DevInst_ExA    CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_ExW    CM_Locate_DevNode_ExW
#ifdef UNICODE
#define CM_Locate_DevNode        CM_Locate_DevNodeW
#define CM_Locate_DevInst        CM_Locate_DevNodeW
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExW
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExW
#else
#define CM_Locate_DevNode        CM_Locate_DevNodeA
#define CM_Locate_DevInst        CM_Locate_DevNodeA
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Merge_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des_Ex(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode_Ex(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Move_DevInst          CM_Move_DevNode
#define CM_Move_DevInst_Ex       CM_Move_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Next_Range(
             IN OUT PRANGE_ELEMENT preElement,
             OUT PDWORDLONG        pullStart,
             OUT PDWORDLONG        pullEnd,
             IN  ULONG             ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des_Ex(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyA(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyW(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExA(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExW(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Open_Class_Key        CM_Open_Class_KeyW
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExW
#else
#define CM_Open_Class_Key        CM_Open_Class_KeyA
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key_Ex(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
#define CM_Open_DevInst_Key      CM_Open_DevNode_Key
#define CM_Open_DevInst_Key_Ex   CM_Open_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data_Ex(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size_Ex(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeA(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExA(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeW(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExW(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeW
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExW
#else
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeA
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectA(
            IN  DEVINST         dnDevInst,
            OUT PPNP_VETO_TYPE  pVetoType,
            OUT LPSTR           pszVetoName,
            IN  ULONG           ulNameLength,
            IN  ULONG           ulFlags
            );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExA(
             IN  DEVINST        dnDevInst,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectW(
            IN  DEVINST         dnDevInst,
            OUT PPNP_VETO_TYPE  pVetoType,
            OUT LPWSTR          pszVetoName,
            IN  ULONG           ulNameLength,
            IN  ULONG           ulFlags
            );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExW(
             IN  DEVINST        dnDevInst,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Request_Device_Eject         CM_Request_Device_EjectW
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExW
#else
#define CM_Request_Device_Eject         CM_Request_Device_EjectA
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Reenumerate_DevInst      CM_Reenumerate_DevNode
#define CM_Reenumerate_DevInst_Ex   CM_Reenumerate_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
#ifdef UNICODE
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceW
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExW
#else
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceA
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags
    );
#define CM_Set_DevInst_Problem      CM_Set_DevNode_Problem
#define CM_Set_DevInst_Problem_Ex   CM_Set_DevNode_Problem_Ex


CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
             IN LPCSTR pszDeviceInterface,
             IN ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
             IN LPCWSTR pszDeviceInterface,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
             IN LPCSTR   pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
             IN LPCWSTR  pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceW
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExW
#else
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceA
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags
            );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver_Ex(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags,
            IN HMACHINE hMachine
            );

CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Set_DevInst_Registry_PropertyW     CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_PropertyA     CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_ExW  CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevInst_Registry_Property_ExA  CM_Set_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#else
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
             OUT PBOOL pbPresent
             );

CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present_Ex(
             OUT PBOOL pbPresent,
             IN HMACHINE    hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC(
             VOID
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC_Ex(
             IN HMACHINE    hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsW
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExW
#else
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsA
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Setup_DevInst         CM_Setup_DevNode
#define CM_Setup_DevInst_Ex      CM_Setup_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Test_Range_Available(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode_Ex(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Uninstall_DevInst     CM_Uninstall_DevNode
#define CM_Uninstall_DevInst_Ex  CM_Uninstall_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Run_Detection(
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Run_Detection_Ex(
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Ex(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsW(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_W pConflictDetails
             );

#ifdef UNICODE
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsW
#else
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyW(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyW(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

#ifdef UNICODE
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyW
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyW
#else
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyA
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyA
#endif // UNICODE

#define CM_WaitNoPendingInstallEvents CMP_WaitNoPendingInstallEvents

DWORD
WINAPI
CM_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

//--------------------------------------------------------------
// Configuration Manager return status codes
//--------------------------------------------------------------

#define CR_SUCCESS                  (0x00000000)
#define CR_DEFAULT                  (0x00000001)
#define CR_OUT_OF_MEMORY            (0x00000002)
#define CR_INVALID_POINTER          (0x00000003)
#define CR_INVALID_FLAG             (0x00000004)
#define CR_INVALID_DEVNODE          (0x00000005)
#define CR_INVALID_DEVINST          CR_INVALID_DEVNODE
#define CR_INVALID_RES_DES          (0x00000006)
#define CR_INVALID_LOG_CONF         (0x00000007)
#define CR_INVALID_ARBITRATOR       (0x00000008)
#define CR_INVALID_NODELIST         (0x00000009)
#define CR_DEVNODE_HAS_REQS         (0x0000000A)
#define CR_DEVINST_HAS_REQS         CR_DEVNODE_HAS_REQS
#define CR_INVALID_RESOURCEID       (0x0000000B)
#define CR_DLVXD_NOT_FOUND          (0x0000000C)   // WIN 95 ONLY
#define CR_NO_SUCH_DEVNODE          (0x0000000D)
#define CR_NO_SUCH_DEVINST          CR_NO_SUCH_DEVNODE
#define CR_NO_MORE_LOG_CONF         (0x0000000E)
#define CR_NO_MORE_RES_DES          (0x0000000F)
#define CR_ALREADY_SUCH_DEVNODE     (0x00000010)
#define CR_ALREADY_SUCH_DEVINST     CR_ALREADY_SUCH_DEVNODE
#define CR_INVALID_RANGE_LIST       (0x00000011)
#define CR_INVALID_RANGE            (0x00000012)
#define CR_FAILURE                  (0x00000013)
#define CR_NO_SUCH_LOGICAL_DEV      (0x00000014)
#define CR_CREATE_BLOCKED           (0x00000015)
#define CR_NOT_SYSTEM_VM            (0x00000016)   // WIN 95 ONLY
#define CR_REMOVE_VETOED            (0x00000017)
#define CR_APM_VETOED               (0x00000018)
#define CR_INVALID_LOAD_TYPE        (0x00000019)
#define CR_BUFFER_SMALL             (0x0000001A)
#define CR_NO_ARBITRATOR            (0x0000001B)
#define CR_NO_REGISTRY_HANDLE       (0x0000001C)
#define CR_REGISTRY_ERROR           (0x0000001D)
#define CR_INVALID_DEVICE_ID        (0x0000001E)
#define CR_INVALID_DATA             (0x0000001F)
#define CR_INVALID_API              (0x00000020)
#define CR_DEVLOADER_NOT_READY      (0x00000021)
#define CR_NEED_RESTART             (0x00000022)
#define CR_NO_MORE_HW_PROFILES      (0x00000023)
#define CR_DEVICE_NOT_THERE         (0x00000024)
#define CR_NO_SUCH_VALUE            (0x00000025)
#define CR_WRONG_TYPE               (0x00000026)
#define CR_INVALID_PRIORITY         (0x00000027)
#define CR_NOT_DISABLEABLE          (0x00000028)
#define CR_FREE_RESOURCES           (0x00000029)
#define CR_QUERY_VETOED             (0x0000002A)
#define CR_CANT_SHARE_IRQ           (0x0000002B)
#define CR_NO_DEPENDENT             (0x0000002C)
#define CR_SAME_RESOURCES           (0x0000002D)
#define CR_NO_SUCH_REGISTRY_KEY     (0x0000002E)
#define CR_INVALID_MACHINENAME      (0x0000002F)   // NT ONLY
#define CR_REMOTE_COMM_FAILURE      (0x00000030)   // NT ONLY
#define CR_MACHINE_UNAVAILABLE      (0x00000031)   // NT ONLY
#define CR_NO_CM_SERVICES           (0x00000032)   // NT ONLY
#define CR_ACCESS_DENIED            (0x00000033)   // NT ONLY
#define CR_CALL_NOT_IMPLEMENTED     (0x00000034)
#define CR_INVALID_PROPERTY         (0x00000035)
#define CR_DEVICE_INTERFACE_ACTIVE  (0x00000036)
#define CR_NO_SUCH_DEVICE_INTERFACE (0x00000037)
#define CR_INVALID_REFERENCE_STRING (0x00000038)
#define CR_INVALID_CONFLICT_LIST    (0x00000039)
#define CR_INVALID_INDEX            (0x0000003A)
#define CR_INVALID_STRUCTURE_SIZE   (0x0000003B)
#define NUM_CR_RESULTS              (0x0000003C)

#ifdef __cplusplus
}
#endif


#endif // _CFGMGR32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\d4iface.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4iface.h

Abstract:

    DOT4 Interface


--*/

#ifndef _DOT4_IFACE_H
#define _DOT4_IFACE_H

#ifdef __cplusplus
extern "C" {      
#endif
//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define DOT4_MAX_CHANNELS            128

#define NO_TIMEOUT                  0


//
// DOT4 Channel types
//
#define STREAM_TYPE_CHANNEL         1
#define PACKET_TYPE_CHANNEL         2


//
// DOT4 broadcast Activity messages
//
#define DOT4_STREAM_RECEIVED    0x100
#define DOT4_STREAM_CREDITS     0x101
#define DOT4_MESSAGE_RECEIVED   0x102       // Message is received
#define DOT4_DISCONNECT         0x103       // The link was disconnected
#define DOT4_CHANNEL_CLOSED     0x105       // A channel was closed

//
// DOT4 Channels
//
#define DOT4_CHANNEL                 0
#define HP_MESSAGE_PROCESSOR        1
#define PRINTER_CHANNEL             2
// As of revision 3.7 of the DOT4 specification, socket 3 had no assignment
#define SCANNER_CHANNEL             4
#define MIO_COMMAND_PROCESSOR       5
#define ECHO_CHANNEL                6
#define FAX_SEND_CHANNEL            7
#define FAX_RECV_CHANNEL            8
#define DIAGNOSTIC_CHANNEL          9
#define HP_RESERVED                 10
#define IMAGE_DOWNLOAD              11
#define HOST_DATASTORE_UPLOAD       12
#define HOST_DATASTORE_DOWNLOAD     13
#define CONFIG_UPLOAD               14
#define CONFIG_DOWNLOAD             15


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////
typedef unsigned long CHANNEL_HANDLE;

typedef CHANNEL_HANDLE *PCHANNEL_HANDLE;


typedef struct _DOT4_ACTIVITY
{
    ULONG ulMessage;

    ULONG ulByteCount;

    CHANNEL_HANDLE hChannel;

} DOT4_ACTIVITY, *PDOT4_ACTIVITY;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
// end of extern "C"
}
#endif

#endif // _DOT4_IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\d4drvif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4drvif.h

Abstract:

    DOT4 Driver Interface


--*/

#ifndef _DOT4DRVIF_H
#define _DOT4DRVIF_H

//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define MAX_SERVICE_LENGTH      40


#ifndef CTL_CODE

  //
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#endif

#define FILE_DEVICE_DOT4         0x3a
#define IOCTL_DOT4_USER_BASE     2049
#define IOCTL_DOT4_LAST          IOCTL_DOT4_USER_BASE + 9

#define IOCTL_DOT4_CREATE_SOCKET                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  7, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_DESTROY_SOCKET                CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  9, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_FOR_CHANNEL              CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  8, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_OPEN_CHANNEL                  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  0, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_CLOSE_CHANNEL                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_READ                          CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  2, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WRITE                         CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_ADD_ACTIVITY_BROADCAST        CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_REMOVE_ACTIVITY_BROADCAST     CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_ACTIVITY_BROADCAST       CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  6, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////

typedef struct _DOT4_DRIVER_CMD
{
    // Handle to channel
    CHANNEL_HANDLE hChannelHandle;

    // Length of request
    ULONG ulSize;

    // Offset into buffer
    ULONG ulOffset;

    // Timeout of operation. Can be INFINITE.
    ULONG ulTimeout;

} DOT4_DRIVER_CMD, *PDOT4_DRIVER_CMD;


typedef struct _DOT4_DC_OPEN_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

    // TRUE to immediately add activity broadcast upon creation
    unsigned char fAddActivity;

    // Handle to channel returned
    CHANNEL_HANDLE hChannelHandle;

} DOT4_DC_OPEN_DATA, *PDOT4_DC_OPEN_DATA;


typedef struct _DOT4_DC_CREATE_DATA
{
    // This or service name sent
    unsigned char bPsid;

    CHAR pServiceName[MAX_SERVICE_LENGTH + 1];

    // Type (stream or packet) of channels on socket
    unsigned char bType;

    // Size of read buffer for channels on socket
    ULONG ulBufferSize;

    USHORT usMaxHtoPPacketSize;

    USHORT usMaxPtoHPacketSize;

    // Host socket id returned
    unsigned char bHsid;

} DOT4_DC_CREATE_DATA, *PDOT4_DC_CREATE_DATA;


typedef struct _DOT4_DC_DESTROY_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

} DOT4_DC_DESTROY_DATA, *PDOT4_DC_DESTROY_DATA;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\classpnp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    classpnp.h

Abstract:

    These are the structures and defines that are used in the
    SCSI class drivers.

Author:

    Mike Glass (mglass)
    Jeff Havens (jhavens)

Revision History:

--*/

#ifndef _CLASS_
#define _CLASS_

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddtape.h>
#include <ntddscsi.h>
#include "ntddstor.h"

#include <stdio.h>

#include <scsi.h>

#if defined DebugPrint
    #undef DebugPrint
#endif

#ifdef TRY
    #undef TRY
#endif
#ifdef LEAVE
    #undef LEAVE
#endif
#ifdef FINALLY
    #undef FINALLY
#endif

#define TRY
#define LEAVE   goto __tryLabel;
#define FINALLY __tryLabel:

// #define ALLOCATE_SRB_FROM_POOL

//
// describes the well-known bit masks for ClassDebug, and describes the bits
// to enable in the debugger to view just those messages.  ClassDebugExternalX
// are reserved for third-party components' debugging use.  Anything above
// 16 will only be printed if the lower two bytes of ClassDebug are higher
// than the given level (no masking will be available).
//

typedef enum _CLASS_DEBUG_LEVEL {
    ClassDebugError        = 0,  // always printed
    ClassDebugWarning      = 1,  // set bit 0x00010000 in ClassDebug
    ClassDebugTrace        = 2,  // set bit 0x00020000 in ClassDebug
    ClassDebugInfo         = 3,  // set bit 0x00040000 in ClassDebug
#if 0
    ClassDebug Internal    = 4,  // set bit 0x00080000 in ClassDebug

    ClassDebug Internal    = 5,  // set bit 0x00100000 in ClassDebug
    ClassDebug Internal    = 6,  // set bit 0x00200000 in ClassDebug
    ClassDebug Internal    = 7,  // set bit 0x00400000 in ClassDebug
#endif // 0
    ClassDebugMediaLocks   = 8,  // set bit 0x00800000 in ClassDebug

    ClassDebugMCN          = 9,  // set bit 0x01000000 in ClassDebug
    ClassDebugDelayedRetry = 10, // set bit 0x02000000 in ClassDebug
    ClassDebugSenseInfo    = 11, // set bit 0x04000000 in ClassDebug
    ClassDebugRemoveLock   = 12, // set bit 0x08000000 in ClassDebug

    ClassDebugExternal4    = 13, // set bit 0x10000000 in ClassDebug
    ClassDebugExternal3    = 14, // set bit 0x20000000 in ClassDebug
    ClassDebugExternal2    = 15, // set bit 0x40000000 in ClassDebug
    ClassDebugExternal1    = 16  // set bit 0x80000000 in ClassDebug
} CLASS_DEBUG_LEVEL, *PCLASS_DEBUG_LEVEL;

#if DBG

#define DebugPrint(x) ClassDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

#define DEBUG_BUFFER_LENGTH 256

//
// Define our private SRB flags.  The high nibble of the flag field is
// reserved for class drivers's private use.
//

//
// Used to indicate that this request shouldn't invoke any power type operations
// like spinning up the drive.
//

#define SRB_CLASS_FLAGS_LOW_PRIORITY      0x10000000

//
// Used to indicate that the completion routine should not free the srb.
//

#define SRB_CLASS_FLAGS_PERSISTANT        0x20000000

//
// Used to indicate that an SRB is the result of a paging operation.
//

#define SRB_CLASS_FLAGS_PAGING            0x40000000

//
// Random macros which should probably be in the system header files
// somewhere.
//

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// neat little hacks to count number of bits set efficiently
//
__inline ULONG CountOfSetBitsUChar(UCHAR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsUlongPtr(ULONG_PTR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }


//
// Helper macros to verify data types and cleanup the code.
//

#define ASSERT_FDO(x) \
    ASSERT(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo)

#define ASSERT_PDO(x) \
    ASSERT(!(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo))

#define IS_CLEANUP_REQUEST(majorFunction)   \
        ((majorFunction == IRP_MJ_CLOSE) ||     \
         (majorFunction == IRP_MJ_CLEANUP) ||   \
         (majorFunction == IRP_MJ_SHUTDOWN))

#define DO_MCD(fdoExtension)                                        \
    (((fdoExtension)->MediaChangeDetectionInfo != NULL) &&          \
     ((fdoExtension)->MediaChangeDetectionInfo->MediaChangeDetectionDisableCount == 0))

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nUcS')
//#define ExAllocatePool(a,b) #assert(0)
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'nUcS')
#endif

#define CLASS_TAG_AUTORUN_DISABLE           'ALcS'
#define CLASS_TAG_FILE_OBJECT_EXTENSION     'FLcS'
#define CLASS_TAG_MEDIA_CHANGE_DETECTION    'MLcS'
#define CLASS_TAG_MOUNT                     'mLcS'
#define CLASS_TAG_RELEASE_QUEUE             'qLcS'
#define CLASS_TAG_POWER                     'WLcS'
#define CLASS_TAG_WMI                       'wLcS'
#define CLASS_TAG_FAILURE_PREDICT           'fLcS'
#define CLASS_TAG_DEVICE_CONTROL            'OIcS'

#define MAXIMUM_RETRIES 4

#define CLASS_DRIVER_EXTENSION_KEY ((PVOID) ClassInitialize)

struct _CLASS_INIT_DATA;
typedef struct _CLASS_INIT_DATA
                CLASS_INIT_DATA,
                *PCLASS_INIT_DATA;

//
// our first attempt at keeping private data actually private....
//

struct _CLASS_PRIVATE_FDO_DATA;
typedef struct _CLASS_PRIVATE_FDO_DATA
                CLASS_PRIVATE_FDO_DATA,
              *PCLASS_PRIVATE_FDO_DATA;

struct _CLASS_PRIVATE_PDO_DATA;
typedef struct _CLASS_PRIVATE_PDO_DATA
                CLASS_PRIVATE_PDO_DATA,
              *PCLASS_PRIVATE_PDO_DATA;

struct _CLASS_PRIVATE_COMMON_DATA;
typedef struct _CLASS_PRIVATE_COMMON_DATA
                CLASS_PRIVATE_COMMON_DATA,
              *PCLASS_PRIVATE_COMMON_DATA;

//
// Possible values for the IsRemoved flag
//

#define NO_REMOVE 0
#define REMOVE_PENDING 1
#define REMOVE_COMPLETE 2


#define ClassAcquireRemoveLock(devobj, tag) \
    ClassAcquireRemoveLockEx(devobj, tag, __FILE__, __LINE__)

//
// Define start unit timeout to be 4 minutes.
//

#define START_UNIT_TIMEOUT  (60 * 4)

//
// Define media change test time to be 1 second for quicker response

#define MEDIA_CHANGE_DEFAULT_TIME    1

#ifdef DBG

//
// Used to detect the loss of the autorun irp.  The driver prints out a message
// (debug level 0) if this timeout ever occurs
//
#define MEDIA_CHANGE_TIMEOUT_TIME  300

#endif


//
// Define the various states that media can be in for autorun.
//
typedef enum _MEDIA_CHANGE_DETECTION_STATE {
    MediaUnknown,
    MediaPresent,
    MediaNotPresent,
    MediaUnavailable   // e.g. cd-r media undergoing burn
} MEDIA_CHANGE_DETECTION_STATE, *PMEDIA_CHANGE_DETECTION_STATE;


struct _MEDIA_CHANGE_DETECTION_INFO;
typedef struct _MEDIA_CHANGE_DETECTION_INFO
    MEDIA_CHANGE_DETECTION_INFO, *PMEDIA_CHANGE_DETECTION_INFO;

//
// Structures for maintaining a dictionary list (list of objects
// referenced by a key value)
//

struct _DICTIONARY_HEADER;
typedef struct _DICTIONARY_HEADER DICTIONARY_HEADER, *PDICTIONARY_HEADER;

typedef struct _DICTIONARY {
    ULONGLONG Signature;
    PDICTIONARY_HEADER List;
    KSPIN_LOCK SpinLock;
} DICTIONARY, *PDICTIONARY;


//
// structures to simplify matching devices, ids, and hacks required for
// these ids.
//

typedef struct _CLASSPNP_SCAN_FOR_SPECIAL_INFO {

    //
    // * NULL pointers indicates that no match is required.
    // * empty string will only match an empty string.  non-existant strings
    //   in the device descriptor are considered empty strings for this match.
    //   (ie. "" will only match "")
    // * all other strings will do partial matches, based upon
    //   string provided (ie. "hi" will match "hitazen" and "higazui")
    // * array must end with all three PCHARs being set to NULL.
    //

    PCHAR      VendorId;
    PCHAR      ProductId;
    PCHAR      ProductRevision;

    //
    // marked as a ULONG_PTR to allow use as either a ptr to a data block
    // or 32 bits worth of flags. (64 bits on 64 bit systems)  no longer a
    // const so that it may be dynamically built.
    //

    ULONG_PTR  Data;

} CLASSPNP_SCAN_FOR_SPECIAL_INFO, *PCLASSPNP_SCAN_FOR_SPECIAL_INFO;




#ifdef ALLOCATE_SRB_FROM_POOL

#define ClasspAllocateSrb(ext)
    ExAllocatePoolWithTag(NonPagedPool,                 \
                          sizeof(SCSI_REQUEST_BLOCK),   \
                          'sBRS')

#define ClasspFreeSrb(ext, srb)     ExFreePool((srb));

#else

#define ClasspAllocateSrb(ext)                      \
    ExAllocateFromNPagedLookasideList(              \
        &((ext)->CommonExtension.SrbLookasideList))

#define ClasspFreeSrb(ext, srb)                     \
    ExFreeToNPagedLookasideList(                    \
        &((ext)->CommonExtension.SrbLookasideList), \
        (srb))

#endif


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_ERROR()

Routine Description:

    This routine is a callback into the driver to handle errors.  The queue
    shall not be unfrozen when this error handler is called, even though the
    SRB flags may mark the queue as having been frozen due to this SRB.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object the error occurred on.

    Srb is the Srb that was being processed when the error occurred.

    Status may be overwritten by the routine if it decides that the error
        was benign, or otherwise wishes to change the returned status code
        for this command

    Retry may be overwritten to specify that this command should or should
        not be retried (if the callee supports retrying commands)

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_ERROR) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT NTSTATUS *Status,
    IN OUT BOOLEAN *Retry
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_ADD_DEVICE()

Routine Description:

    This routine is a callback into the driver to create and initialize a new
    FDO for the corresponding PDO.  It may perform property queries on the PDO
    but cannot do any media access operations.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DriverObject is the class driver object this callback is registered for.

    PDO is the physical device object being added to.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_ADD_DEVICE) (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_POWER_DEVICE()

Routine Description:

    This routine is a callback into the driver to handle power up and
    power down requests.  Most drivers can set this to ClassPowerHandler,
    which will send a STOP_UNIT on powerdown, and a START_UNIT on powerup.
    ClassMinimalPowerHandler() may also be used to do nothing for power
    operations (except succeed them).  Please see the DDK for proper handling
    of IRP_MN_DEVICE_USAGE_NOTIFICATION for details regarding interaction
    of paging device notifications and the IRQL at which this routine will
    be called.

Irql:

    This routine will be called at PASSIVE_LEVEL if DO_POWER_PAGABLE is set.
    This code should NOT be pagable to prevent race conditions during the
    setting and clearing of the DO_POWER_PAGABLE bit.

Arguments:

    DeviceObject is the device that has the pending power request

    Irp is the power irp that needs to be handled

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_POWER_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

/*++////////////////////////////////////////////////////////////////////////////

CLASS_START_DEVICE()

Routine Description:

    This routine is a callback into the driver to initialize the FDO or PDO for
    all requests, typically due to a IRP_MN_START_DEVICE.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being started

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_START_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_STOP_DEVICE()

Routine Description:

    This routine is a callback into the driver to stop the device.
    For the storage stack, unless there are known issues, this routine
    need only return.  All queueing shall be handled by the lower device
    drivers.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being stopped/query stopped.

    Type is the IRP_MN_ type that must be handled.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_STOP_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_INIT_DEVICE()

Routine Description:

    This routine is a callback into the driver to do one-time initialization
    of new device objects.  It shall be called exactly once per device object,
    and it shall be called prior to CLASS_START_DEVICE() routine.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object to be initialized

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_INIT_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_ENUM_DEVICE()

Routine Description:

    This routine is a callback into the driver to update the list of PDOs for
    a given FDO.  See DISK.SYS's DiskEnumerateDevice for an example of use.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the FDO which is being enumerated.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_ENUM_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_READ_WRITE()

Routine Description:

    This routine is a callback into the driver to verify READ and WRITE irps.
    If the READ or WRITE request is failed, this routine shall set the Irp's
    IoStatus.Status to the returned error code and the IoStatus.Information
    field as appropriate for the given error.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object being read from or written to

    Irp is the read or write request being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_READ_WRITE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_DEVICE_CONTROL()

Routine Description:

    This routine is a callback into the driver to

Irql:

    This routine will only be called at PASSIVE_LEVEL for storage IOCTLs.
    The code must therefore not be paged, but may call paged code for those
    ioctls which have been defined to be sent at PASSIVE_LEVEL, such as the
    storage IOCTLS.  Otherwise KIRQL <= DISPATCH_LEVEL.

Arguments:

    DeviceObject is the device object the IOCTL may be for

    Irp is the IOCTL request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_DEVICE_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SHUTDOWN_FLUSH()

Routine Description:

    This routine is a callback into the driver to handle shutdown and flush
    irps.  These are sent by the system before it actually shuts down or when
    the file system does a flush.

    This routine may synchronize the device's media / cache and ensure the
    device is not locked if the system is in the process of shutting down.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object that needs to be flushed

    Irp is the shutdown or flush request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SHUTDOWN_FLUSH) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_CREATE_CLOSE()

Routine Description:

    This routine is a callback into the driver when the device is opened or
    closed.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject that is handling the request

    Irp is the create or close request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_CREATE_CLOSE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_ID()

Routine Description:

    This routine generates the PNP id's for the device's enumerated PDOs.
    If the specified ID is one that cannot be generated, then the return
    status shall be STATUS_NOT_IMPLEMENTED so that classpnp shall not
    handle the request.  This routine shall allocate the buffer in the unicode
    string "IdString" upon success; it is the caller's responsibility to free
    this buffer when it is done.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the PDO to generate an ID for

    IdType is the type of ID to be generated

    UnicodeIdString is the string to place the results into

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_ID) (
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING IdString
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_REMOVE_DEVICE()

Routine Description:

    This routine is a callback into the driver to release any resources the
    device may have allocated for the device object.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being removed/query removed/etc.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_REMOVE_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_UNLOAD()

Routine Description:

    This routine is a callback into the driver to unload itself.  It must free
    any resources allocated in the DriverEntry portion of the driver.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    X

    Irp is the IOCTL request currently being processed

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_UNLOAD) (
    IN PDRIVER_OBJECT DriverObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_PNP_CAPABILITIES()

Routine Description:

    ISSUE-2000/02/18-henrygab - description required

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    PhysicalDeviceObject is the PDO for which this query shall occur

    Capabilities is a structure that shall be modified by this routine
        to report the device's capabilities.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_PNP_CAPABILITIES) (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_TICK()

Routine Description:

    This routine is a callback into the driver that is called once per second.

Irql:

    This routine will be called at DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object for which the timer has fired

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_TICK) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_REGINFO_EX()

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    Name returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    MofResourceName returns filled with a static string that contains
        the name of the MOF resource attached to the drivers image. The
        caller does not free the buffer as it is expected that the
        caller will use RtlInitializeUnicodeString to populate it.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_REGINFO_EX) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING Name,
    OUT PUNICODE_STRING MofResouceName
    );

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_REGINFO()

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    Name returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_REGINFO) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING Name
    );

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_DATABLOCK()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SET_WMI_DATABLOCK()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SET_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SET_WMI_DATAITEM()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SET_WMI_DATAITEM) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_EXECUTE_WMI_METHOD()

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_EXECUTE_WMI_METHOD) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );



//
// used by PCLASS_WMI_FUNCTION_CONTROL
//
typedef enum {
    EventGeneration,
    DataBlockCollection
} CLASSENABLEDISABLEFUNCTION;

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_WMI_FUNCTION_CONTROL()

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_WMI_FUNCTION_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );



//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct {
    GUID Guid;               // Guid to registered
    ULONG InstanceCount;     // Count of Instances of Datablock
    ULONG Flags;             // Additional flags (see WMIREGINFO in wmistr.h)
} GUIDREGINFO, *PGUIDREGINFO;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_WMI_INFO {
    ULONG GuidCount;
    PGUIDREGINFO GuidRegInfo;

    PCLASS_QUERY_WMI_REGINFO      ClassQueryWmiRegInfo;
    PCLASS_QUERY_WMI_DATABLOCK    ClassQueryWmiDataBlock;
    PCLASS_SET_WMI_DATABLOCK      ClassSetWmiDataBlock;
    PCLASS_SET_WMI_DATAITEM       ClassSetWmiDataItem;
    PCLASS_EXECUTE_WMI_METHOD     ClassExecuteWmiMethod;
    PCLASS_WMI_FUNCTION_CONTROL   ClassWmiFunctionControl;
} CLASS_WMI_INFO, *PCLASS_WMI_INFO;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_DEV_INFO {

    //
    // Bytes needed by the class driver
    // for it's extension.
    // If this is zero, the driver does not expect to have any PDO's
    //

    ULONG DeviceExtensionSize;

    DEVICE_TYPE DeviceType;

    UCHAR StackSize;

    //
    // Device Characteristics flags
    //  eg.:
    //
    //  FILE_REMOVABLE_MEDIA
    //  FILE_READ_ONLY_DEVICE
    //  FILE_FLOPPY_DISKETTE
    //  FILE_WRITE_ONCE_MEDIA
    //  FILE_REMOTE_DEVICE
    //  FILE_DEVICE_IS_MOUNTED
    //  FILE_VIRTUAL_VOLUME
    //

    ULONG DeviceCharacteristics;

    PCLASS_ERROR                    ClassError;
    PCLASS_READ_WRITE               ClassReadWriteVerification;
    PCLASS_DEVICE_CONTROL           ClassDeviceControl;
    PCLASS_SHUTDOWN_FLUSH           ClassShutdownFlush;
    PCLASS_CREATE_CLOSE             ClassCreateClose;

    PCLASS_INIT_DEVICE              ClassInitDevice;
    PCLASS_START_DEVICE             ClassStartDevice;
    PCLASS_POWER_DEVICE             ClassPowerDevice;
    PCLASS_STOP_DEVICE              ClassStopDevice;
    PCLASS_REMOVE_DEVICE            ClassRemoveDevice;

    PCLASS_QUERY_PNP_CAPABILITIES   ClassQueryPnpCapabilities;

    //
    // Registered Data Block info for wmi
    //
    CLASS_WMI_INFO                  ClassWmiInfo;

} CLASS_DEV_INFO, *PCLASS_DEV_INFO;

//
// Restricted - May only append to this structure for backwards compatibility
//
struct _CLASS_INIT_DATA {

    //
    // This structure size - version checking.
    //

    ULONG InitializationDataSize;

    //
    // Specific init data for functional and physical device objects.
    //

    CLASS_DEV_INFO FdoData;
    CLASS_DEV_INFO PdoData;

    //
    // Device-specific driver routines
    //

    PCLASS_ADD_DEVICE             ClassAddDevice;
    PCLASS_ENUM_DEVICE            ClassEnumerateDevice;

    PCLASS_QUERY_ID               ClassQueryId;

    PDRIVER_STARTIO               ClassStartIo;
    PCLASS_UNLOAD                 ClassUnload;

    PCLASS_TICK                   ClassTick;
};

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef struct _FILE_OBJECT_EXTENSION {
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    ULONG LockCount;
    ULONG McnDisableCount;
} FILE_OBJECT_EXTENSION, *PFILE_OBJECT_EXTENSION;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_DRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

    CLASS_INIT_DATA InitData;

    ULONG DeviceCount;

    PCLASS_QUERY_WMI_REGINFO_EX   ClassFdoQueryWmiRegInfoEx;
    PCLASS_QUERY_WMI_REGINFO_EX   ClassPdoQueryWmiRegInfoEx;

} CLASS_DRIVER_EXTENSION, *PCLASS_DRIVER_EXTENSION;

typedef struct _COMMON_DEVICE_EXTENSION COMMON_DEVICE_EXTENSION, *PCOMMON_DEVICE_EXTENSION;
typedef struct _FUNCTIONAL_DEVICE_EXTENSION FUNCTIONAL_DEVICE_EXTENSION, *PFUNCTIONAL_DEVICE_EXTENSION;
typedef struct _PHYSICAL_DEVICE_EXTENSION PHYSICAL_DEVICE_EXTENSION, *PPHYSICAL_DEVICE_EXTENSION;

//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _COMMON_DEVICE_EXTENSION {

    //
    // Version control field
    //
    // Note - this MUST be the first thing in the device extension
    // for any class driver using classpnp or a later version.
    //

    ULONG Version;

    //
    // Back pointer to device object
    //
    // NOTE - this MUST be the second field in the common device extension.
    // Users of this structure will include it in a union with the DeviceObject
    // pointer so they can reference this with a bit of syntactic sugar.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to lower device object - send all requests through this
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Pointer to the partition zero device extension.
    // There are several flags stored there that pdo
    // routines need to access
    //

    PFUNCTIONAL_DEVICE_EXTENSION PartitionZeroExtension;

    //
    // Pointer to the initialization data for this driver.  This is more
    // efficient than constantly getting the driver extension.
    //

    PCLASS_DRIVER_EXTENSION DriverExtension;

    //
    // INTERLOCKED counter of the number of requests/function calls outstanding
    // which will need to use this device object.  When this count goes to
    // zero the RemoveEvent will be set.
    //
    // This variable is only manipulated by ClassIncrementRemoveLock and
    // ClassDecrementRemoveLock.
    //

    LONG RemoveLock;

    //
    // This event will be signalled when it is safe to remove the device object
    //

    KEVENT RemoveEvent;

    //
    // The spinlock and the list are only used in checked builds to track
    // who has acquired the remove lock.  Free systems will leave these
    // initialized to ff
    //

    KSPIN_LOCK RemoveTrackingSpinlock;

    PVOID RemoveTrackingList;

    LONG RemoveTrackingUntrackedCount;

    //
    // Pointer to the driver specific data area
    //

    PVOID DriverData;

    //
    // Flag indicates whether this device object is
    // an FDO or a PDO
    //

    struct {
        BOOLEAN IsFdo : 1;
        BOOLEAN IsInitialized : 1;

        //
        // Flag indicating whether the lookaside listhead for srbs has been
        // initialized.
        //

        BOOLEAN IsSrbLookasideListInitialized : 1;
    };

    //
    // Contains the IRP_MN_CODE of the last state-changing pnp irps we
    // recieved (XXX_STOP, XXX_REMOVE, START, etc...).  Used in concert
    // with IsRemoved.
    //

    UCHAR PreviousState;
    UCHAR CurrentState;

    //
    // interlocked flag indicating that the device has been removed.
    //

    ULONG IsRemoved;

    //
    // The name of the object
    //
    UNICODE_STRING DeviceName;

    //
    // The next child device (or if this is an FDO, the first child device).
    //

    PPHYSICAL_DEVICE_EXTENSION ChildList;

    //
    // Number of the partition or -1L if not partitionable.
    //

    ULONG PartitionNumber;

    //
    // Length of partition in bytes
    //

    LARGE_INTEGER PartitionLength;

    //
    // Number of bytes before start of partition
    //

    LARGE_INTEGER StartingOffset;

    //
    // Dev-Info structure for this type of device object
    // Contains call-out routines for the class driver.
    //

    PCLASS_DEV_INFO DevInfo;

    //
    // Count of page files going through this device object
    // and event to synchronize them with.
    //

    ULONG PagingPathCount;
    ULONG DumpPathCount;
    ULONG HibernationPathCount;
    KEVENT PathCountEvent;

#ifndef ALLOCATE_SRB_FROM_POOL
    //
    // Lookaside listhead for srbs.
    //

    NPAGED_LOOKASIDE_LIST SrbLookasideList;
#endif

    //
    // Interface name string returned by IoRegisterDeviceInterface.
    //

    UNICODE_STRING MountedDeviceInterfaceName;


    //
    // Registered Data Block info for wmi
    //
    ULONG GuidCount;
    PGUIDREGINFO GuidRegInfo;

    //
    // File object dictionary for this device object.  Extensions are stored
    // in here rather than off the actual file object.
    //

    DICTIONARY FileObjectDictionary;

    //
    // The following will be in the released product as reserved.
    // Leave these at the end of the structure.
    //

    PCLASS_PRIVATE_COMMON_DATA PrivateCommonData;

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} COMMON_DEVICE_EXTENSION, *PCOMMON_DEVICE_EXTENSION;

typedef enum {
    FailurePredictionNone = 0,     // No failure detection polling needed
    FailurePredictionIoctl,        // Do failure detection via IOCTL
    FailurePredictionSmart,        // Do failure detection via SMART
    FailurePredictionSense         // Do failure detection via sense data
} FAILURE_PREDICTION_METHOD, *PFAILURE_PREDICTION_METHOD;

//
// Default failure prediction polling interval is every hour
//

#define DEFAULT_FAILURE_PREDICTION_PERIOD 60 * 60 * 1

//
// The failure prediction structure is internal to classpnp - drivers do not
// need to know what it contains.
//

struct _FAILURE_PREDICTION_INFO;
typedef struct _FAILURE_PREDICTION_INFO *PFAILURE_PREDICTION_INFO;

//
// this is to allow for common code to handle
// every option.
//

typedef struct _CLASS_POWER_OPTIONS {
    ULONG PowerDown              :  1;
    ULONG LockQueue              :  1;
    ULONG HandleSpinDown         :  1;
    ULONG HandleSpinUp           :  1;
    ULONG Reserved               : 27;
} CLASS_POWER_OPTIONS, *PCLASS_POWER_OPTIONS;

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef enum {
    PowerDownDeviceInitial,
    PowerDownDeviceLocked,
    PowerDownDeviceStopped,
    PowerDownDeviceOff,
    PowerDownDeviceUnlocked
} CLASS_POWER_DOWN_STATE;

//
// same as above, but with an extra state for whistler
// should be ok to change the above structure, but that
// would break someone somewhere who ignore the PRIVATE
// nature of the structure.
//

typedef enum {
    PowerDownDeviceInitial2,
    PowerDownDeviceLocked2,
    PowerDownDeviceFlushed2,
    PowerDownDeviceStopped2,
    PowerDownDeviceOff2,
    PowerDownDeviceUnlocked2
} CLASS_POWER_DOWN_STATE2;

//
// this is a private enum, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef enum {
    PowerUpDeviceInitial,
    PowerUpDeviceLocked,
    PowerUpDeviceOn,
    PowerUpDeviceStarted,
    PowerUpDeviceUnlocked
} CLASS_POWER_UP_STATE;

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef struct _CLASS_POWER_CONTEXT {

    union {
        CLASS_POWER_DOWN_STATE PowerDown;
        CLASS_POWER_DOWN_STATE2 PowerDown2; // whistler
        CLASS_POWER_UP_STATE PowerUp;
    } PowerChangeState;

    CLASS_POWER_OPTIONS Options;

    BOOLEAN InUse;
    BOOLEAN QueueLocked;

    NTSTATUS FinalStatus;

    ULONG RetryCount;
    ULONG RetryInterval;

    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;

    SCSI_REQUEST_BLOCK Srb;

} CLASS_POWER_CONTEXT, *PCLASS_POWER_CONTEXT;

//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _FUNCTIONAL_DEVICE_EXTENSION {

    //
    // Common device extension header
    //

    union {
        struct {
            ULONG Version;
            PDEVICE_OBJECT DeviceObject;
        };
        COMMON_DEVICE_EXTENSION CommonExtension;
    };

    //
    // Pointer to the physical device object we attached to - use this
    // for Pnp calls which need a PDO
    //

    PDEVICE_OBJECT LowerPdo;

    //
    // Device capabilities
    //

    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;

    //
    // SCSI port driver capabilities
    //

    PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptor;

    //
    // Current Power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Bytes to skew all requests
    //

    ULONG DMByteSkew;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Sectors to skew all requests.
    //

    ULONG DMSkew;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Flag to indicate whether DM driver has been located on an IDE drive.
    //

    BOOLEAN DMActive;

    //
    // Buffer for drive parameters returned in IO device control.
    //

    DISK_GEOMETRY DiskGeometry;

    //
    // Request Sense Buffer
    //

    PSENSE_DATA SenseData;

    //
    // Request timeout in seconds;
    //

    ULONG TimeOutValue;

    //
    // System device number
    //

    ULONG DeviceNumber;

    //
    // Add default Srb Flags.
    //

    ULONG SrbFlags;

    //
    // Total number of SCSI protocol errors on the device.
    //

    ULONG ErrorCount;

    //
    // Lock count for removable media.
    //

    LONG LockCount;
    LONG ProtectedLockCount;
    LONG InternalLockCount;

    KEVENT EjectSynchronizationEvent;

    //
    // Values for the flags are below.
    //

    USHORT  DeviceFlags;

    //
    // Log2 of sector size
    //

    UCHAR SectorShift;

    UCHAR ReservedByte;

    //
    // Indicates that the necessary data structures for media change
    // detection have been initialized.
    //

    PMEDIA_CHANGE_DETECTION_INFO MediaChangeDetectionInfo;

    PKEVENT Unused1;
    HANDLE  Unused2;

    //
    // File system context. Used for kernel-mode requests to disable autorun.
    //

    FILE_OBJECT_EXTENSION KernelModeMcnContext;

    //
    // Count of media changes.  This field is only valid for the root partition
    // (ie. if PhysicalDevice == NULL).
    //

    ULONG MediaChangeCount;

    //
    // Storage for a handle to the directory the PDO's are placed in
    //

    HANDLE DeviceDirectory;

    //
    // Storage for a release queue request.
    //

    KSPIN_LOCK ReleaseQueueSpinLock;

    PIRP ReleaseQueueIrp;

    SCSI_REQUEST_BLOCK ReleaseQueueSrb;

    BOOLEAN ReleaseQueueNeeded;

    BOOLEAN ReleaseQueueInProgress;

    BOOLEAN ReleaseQueueIrpFromPool;
    //
    // Failure detection storage
    //

    BOOLEAN FailurePredicted;

    ULONG FailureReason;
    PFAILURE_PREDICTION_INFO FailurePredictionInfo;

    BOOLEAN PowerDownInProgress;

    //
    // Interlock for ensuring we don't recurse during enumeration.
    //

    ULONG EnumerationInterlock;

    //
    // Synchronization object for manipulating the child list.
    //

    KEVENT ChildLock;

    //
    // The thread which currently owns the ChildLock.  This is used to
    // avoid recursive acquisition.
    //

    PKTHREAD ChildLockOwner;

    //
    // The number of times this event has been acquired.
    //

    ULONG ChildLockAcquisitionCount;

    //
    // Flags for special behaviour required by
    // different hardware, such as never spinning down
    // or disabling advanced features such as write cache
    //

    ULONG ScanForSpecialFlags;

    //
    // For delayed retry of power requests at DPC level
    //

    KDPC PowerRetryDpc;
    KTIMER PowerRetryTimer;

    //
    // Context structure for power operations.  Since we can only have
    // one D irp at any time in the stack we don't need to worry about
    // allocating multiple of these structures.
    //

    CLASS_POWER_CONTEXT PowerContext;

    //
    // Hold new private data that only classpnp should modify
    // in this structure.
    //

    PCLASS_PRIVATE_FDO_DATA PrivateFdoData;

    //
    // For future expandability
    // leave these at the end of the structure.
    //

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} FUNCTIONAL_DEVICE_EXTENSION, *PFUNCTIONAL_DEVICE_EXTENSION;

//
// The following CLASS_SPECIAL_ flags are set in ScanForSpecialFlags
// in the FdoExtension
//

// Never Spin Up/Down the drive (may not handle properly)
#define CLASS_SPECIAL_DISABLE_SPIN_DOWN                 0x00000001
#define CLASS_SPECIAL_DISABLE_SPIN_UP                   0x00000002

// Don't bother to lock the queue when powering down
// (used mostly to send a quick stop to a cdrom to abort audio playback)
#define CLASS_SPECIAL_NO_QUEUE_LOCK                     0x00000008

// Disable write cache due to known bugs
#define CLASS_SPECIAL_DISABLE_WRITE_CACHE               0x00000010

//
// Special interpretation of "device not ready / cause not reportable" for
// devices which don't tell us they need to be spun up manually after they
// spin themselves down behind our back.
//
// The down side of this is that if the drive chooses to report
// "device not ready / cause not reportable" to mean "no media in device"
// or any other error which really does require user intervention NT will
// waste a large amount of time trying to spin up a disk which can't be spun
// up.
//

#define CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK         0x00000020

#define CLASS_SPECIAL_MODIFY_CACHE_UNSUCCESSFUL         0x00000040
#define CLASS_SPECIAL_FUA_NOT_SUPPORTED                 0x00000080

#define CLASS_SPECIAL_VALID_MASK                        0x000000FB
#define CLASS_SPECIAL_RESERVED         (~CLASS_SPECIAL_VALID_MASK)


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _PHYSICAL_DEVICE_EXTENSION {

    //
    // Common extension data
    //

    union {
        struct {
            ULONG Version;
            PDEVICE_OBJECT DeviceObject;
        };
        COMMON_DEVICE_EXTENSION CommonExtension;
    };

    //
    // Indicates that the pdo no longer physically exits.
    //

    BOOLEAN IsMissing;

    //
    // Indicates that the PDO has been handed out to the PNP system.
    //

    BOOLEAN IsEnumerated;

    //
    // Hold new private data that only classpnp should modify
    // in this structure.
    //

    PCLASS_PRIVATE_PDO_DATA PrivatePdoData;

    //
    // for future expandability
    // leave these at the end of the structure.
    //

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} PHYSICAL_DEVICE_EXTENSION, *PPHYSICAL_DEVICE_EXTENSION;

//
// Indicates that the device has write caching enabled.
//

#define DEV_WRITE_CACHE     0x00000001

//
// Build SCSI 1 or SCSI 2 CDBs
//

#define DEV_USE_SCSI1       0x00000002

//
// Indicates whether is is safe to send StartUnit commands
// to this device. It will only be off for some removeable devices.
//

#define DEV_SAFE_START_UNIT 0x00000004

//
// Indicates whether it is unsafe to send SCSIOP_MECHANISM_STATUS commands to
// this device.  Some devices don't like these 12 byte commands
//

#define DEV_NO_12BYTE_CDB   0x00000008

//
// Indicates that the device is connected to a backup power supply
// and hence write-through and synch cache requests may be ignored
//

#define DEV_POWER_PROTECTED 0x00000010

//
// Define context structure for asynchronous completions.
//

typedef struct _COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    SCSI_REQUEST_BLOCK Srb;
}COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassInitialize(
    IN  PVOID            Argument1,
    IN  PVOID            Argument2,
    IN  PCLASS_INIT_DATA InitializationData
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/

//
// The Data Parameter contains a pointer to a CLASS_QUERY_WMI_REGINFO_EX_LIST
// structure that specifies callbacks that are used instead of the
// PCLASS_QUERY_WMI_REGINFO callbacks.
//
// {00E34B11-2444-4745-A53D-620100CD82F7}
#define GUID_CLASSPNP_QUERY_REGINFOEX { 0xe34b11, 0x2444, 0x4745, { 0xa5, 0x3d, 0x62, 0x1, 0x0, 0xcd, 0x82, 0xf7 } }

typedef struct _CLASS_QUERY_WMI_REGINFO_EX_LIST
{
    ULONG Size;          // Should be sizeof(CLASS_QUERY_REGINFO_EX_LIST)

    PCLASS_QUERY_WMI_REGINFO_EX   ClassFdoQueryWmiRegInfoEx;
    PCLASS_QUERY_WMI_REGINFO_EX   ClassPdoQueryWmiRegInfoEx;

} CLASS_QUERY_WMI_REGINFO_EX_LIST, *PCLASS_QUERY_WMI_REGINFO_EX_LIST;



SCSIPORT_API
ULONG
ClassInitializeEx(
    IN  PDRIVER_OBJECT   DriverObject,
    IN  LPGUID           Guid,
    IN  PVOID            Data
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassCreateDeviceObject(
    IN PDRIVER_OBJECT          DriverObject,
    IN PCCHAR                  ObjectNameBuffer,
    IN PDEVICE_OBJECT          LowerDeviceObject,
    IN BOOLEAN                 IsFdo,
    IN OUT PDEVICE_OBJECT      *DeviceObject
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassReadDriveCapacity(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseQueue(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassSplitRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassIoComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassIoCompleteAssociated(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
BOOLEAN
ClassInterpretSenseInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status,
    OUT ULONG *RetryInterval
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
VOID
ClassSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendIrpSynchronous(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassForwardIrpSynchronous(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendSrbSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendSrbAsynchronous(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    PIRP Irp,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassBuildRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassModeSense(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode,
    IN BOOLEAN Use6Byte
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassClaimDevice(
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN BOOLEAN Release
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassInternalIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInitializeSrbLookasideList(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN ULONG NumberElements
    );

/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDeleteSrbLookasideList(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassQueryTimeOutRegistryValue(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PVOID *Descriptor
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInvalidateBusRelations(
    IN PDEVICE_OBJECT Fdo
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassMarkChildrenMissing(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
BOOLEAN
ClassMarkChildMissing(
    IN PPHYSICAL_DEVICE_EXTENSION PdoExtension,
    IN BOOLEAN AcquireChildLock
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDebugPrint(
    CLASS_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PCLASS_DRIVER_EXTENSION
ClassGetDriverExtension(
    IN PDRIVER_OBJECT DriverObject
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PIRP Irp
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    );




/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassUpdateInformationInRegistry(
    IN PDEVICE_OBJECT     Fdo,
    IN PCHAR              DeviceName,
    IN ULONG              DeviceNumber,
    IN PINQUIRYDATA       InquiryData,
    IN ULONG              InquiryDataLength
    );


/*++

Internal function - described in classpnp\classwmi.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassWmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );


/*++

Internal function - described in classpnp\classwmi.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassWmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassResetMediaChangeTimer(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInitializeMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUCHAR EventPrefix
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassInitializeTestUnitPolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN BOOLEAN AllowDriveToSleep
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PVPB
ClassGetVpb(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\power.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSpinDownPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\power.c in ddk sources

--*/
NTSTATUS
ClassStopUnitPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
NTSTATUS
ClassSetFailurePredictionPoll(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    FAILURE_PREDICTION_METHOD FailurePredictionMethod,
    ULONG PollingPeriod
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
VOID
ClassNotifyFailurePredicted(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PUCHAR Buffer,
    ULONG BufferSize,
    BOOLEAN LogError,
    ULONG UniqueErrorValue,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassAcquireChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
NTSTATUS
ClassSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
VOID
ClassSendStartUnit(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR RemoveType
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCheckMediaState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassCheckVerifyComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassSetMediaChangeState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE State,
    IN BOOLEAN Wait
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassEnableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDisableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCleanupMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
VOID
ClassGetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN OUT PULONG ParameterValue
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
NTSTATUS
ClassSetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    );


//
// could be #define, but this allows typechecking
//

__inline
BOOLEAN
PORT_ALLOCATED_SENSE(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return ((BOOLEAN)((TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) &&
             TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER)) &&
            (Srb->SenseInfoBuffer != FdoExtension->SenseData))
            );
}

__inline
VOID
FREE_PORT_ALLOCATED_SENSE_BUFFER(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(Srb->SenseInfoBuffer != FdoExtension->SenseData);

    ExFreePool(Srb->SenseInfoBuffer);
    Srb->SenseInfoBuffer = FdoExtension->SenseData;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE; // should be variable?
    CLEAR_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);
    return;
}



/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SCAN_FOR_SPECIAL_HANDLER()

Routine Description:

    This routine is a callback into the driver to set device-specific
    flags based upon matches made to the device's inquiry data.  Drivers
    register for this callback using ClassRegisterScanForSpecial().

Irql:

    This routine will be called at KIRQL == PASSIVE_LEVEL

Arguments:

    DeviceObject is the device object the error occurred on.

    Srb is the Srb that was being processed when the error occurred.

    Status may be overwritten by the routine if it decides that the error
        was benign, or otherwise wishes to change the returned status code
        for this command

    Retry may be overwritten to specify that this command should or should
        not be retried (if the callee supports retrying commands)

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_SCAN_FOR_SPECIAL_HANDLER) (
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    );

VOID
ClassScanForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN CLASSPNP_SCAN_FOR_SPECIAL_INFO DeviceList[],
    IN PCLASS_SCAN_FOR_SPECIAL_HANDLER Function
    );


#endif /* _CLASS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ddk_ext.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Copyright 1997-2002 OSR, Open Systems Resources, Inc. All rights Reserved.
// 
// Module Name:
// 
//     ddk_ext.h
// 
// Abstract:
// 
//     This module defines the Driver Vefifier Extensions that live
//     as part of the Windows DDK.
// 
// Author:
//    v-markca    6-Jun-2002  Initial Version
//
// Revision History:
//
#include <ntverp.h>

#if (VER_PRODUCTBUILD >= 2600) && !defined(_WDMDDK_)

VOID
DDK_KeAcquireInStackQueuedSpinLock(
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle,
    PVOID F, ULONG L);

VOID
DDK_KeReleaseInStackQueuedSpinLock(
    IN PKLOCK_QUEUE_HANDLE LockHandle,
    PVOID F, ULONG L);

VOID
DDK_KeAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle,
    PVOID F, ULONG L);

VOID
DDK_KeReleaseInStackQueuedSpinLockFromDpcLevel(
    IN PKLOCK_QUEUE_HANDLE LockHandle,
    PVOID F, ULONG L);

#endif


//
//
//
VOID
NTAPI
DDK_KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock,
    PVOID F, ULONG L);

//
//
//
VOID 
DDK_KeAcquireSpinLock(
    IN PKSPIN_LOCK  SpinLock,
    OUT PKIRQL  OldIrql,
    PVOID F, ULONG L);

//
//
//
VOID
DDK_KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql,
    PVOID F, ULONG L);

//
//
//
VOID
DDK_KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    PVOID F, ULONG L);

//
//
//
VOID
DDK_KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    PVOID F, ULONG L);

KIRQL
DDK_KeAcquireInterruptSpinLock (
    IN PKINTERRUPT Interrupt,
    PVOID F, ULONG L);

VOID
DDK_KeReleaseInterruptSpinLock (
    IN PKINTERRUPT Interrupt,
    IN KIRQL OldIrql,
    PVOID F, ULONG L);

//
#if _WIN32_WINNT >= 0x0501 

#ifdef KeAcquireInStackQueuedSpinLock
    #undef KeAcquireInStackQueuedSpinLock
#endif
#define KeAcquireInStackQueuedSpinLock(a,b) DDK_KeAcquireInStackQueuedSpinLock(a,b,__FILE__,__LINE__)

#ifdef KeReleaseInStackQueuedSpinLock
    #undef KeReleaseInStackQueuedSpinLock
#endif
#define KeReleaseInStackQueuedSpinLock(a) DDK_KeReleaseInStackQueuedSpinLock(a,__FILE__,__LINE__)

#ifdef KeAcquireInStackQueuedSpinLockAtDpcLevel
    #undef KeAcquireInStackQueuedSpinLockAtDpcLevel
#endif
#define KeAcquireInStackQueuedSpinLockAtDpcLevel(a,b) DDK_KeAcquireInStackQueuedSpinLockAtDpcLevel(a,b,__FILE__,__LINE__)

#ifdef KeReleaseInStackQueuedSpinLockFromDpcLevel
    #undef KeReleaseInStackQueuedSpinLockFromDpcLevel
#endif
#define KeReleaseInStackQueuedSpinLockFromDpcLevel(a) DDK_KeReleaseInStackQueuedSpinLockFromDpcLevel(a,__FILE__,__LINE__)

#endif 

#ifdef KeAcquireSpinLock
    #undef KeAcquireSpinLock
#endif
#define KeAcquireSpinLock(a,b) DDK_KeAcquireSpinLock(a,b,__FILE__,__LINE__)

#ifdef KeReleaseSpinLock
    #undef KeReleaseSpinLock
#endif
#define KeReleaseSpinLock(a,b) DDK_KeReleaseSpinLock(a,b,__FILE__,__LINE__)

#ifdef KeAcquireSpinLockAtDpcLevel
    #undef KeAcquireSpinLockAtDpcLevel
#endif
#define KeAcquireSpinLockAtDpcLevel(a) DDK_KeAcquireSpinLockAtDpcLevel(a,__FILE__,__LINE__)

#ifdef KeReleaseSpinLockFromDpcLevel
    #undef KeReleaseSpinLockFromDpcLevel
#endif
#define KeReleaseSpinLockFromDpcLevel(a) DDK_KeReleaseSpinLockFromDpcLevel(a,__FILE__,__LINE__)

#ifdef KeInitializeSpinLock
    #undef KeInitializeSpinLock
#endif
#define KeInitializeSpinLock(a) DDK_KeInitializeSpinLock(a,__FILE__,__LINE__)

NTSTATUS
DDK_IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave,
    PVOID F, ULONG L);

//
#ifdef IoConnectInterrupt
    #undef IoConnectInterrupt
#endif
#define IoConnectInterrupt(a,b,c,d,e,f,g,h,i,j,k) DDK_IoConnectInterrupt(a,b,c,d,e,f,g,h,i,j,k,__FILE__,__LINE__)

#if _WIN32_WINNT < 0x0501 
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY
#define SLIST_ENTRY  SINGLE_LIST_ENTRY
#endif

VOID
DDK_ExInitializeSListHead(
    IN PSLIST_HEADER  SListHead,
    PVOID F,ULONG L);

USHORT
DDK_ExQueryDepthSList(
    IN PSLIST_HEADER  SListHead,
    PVOID F, ULONG L);

PSLIST_ENTRY
DDK_ExInterlockedPopEntrySList(
    IN PSLIST_HEADER  ListHead,
    IN PKSPIN_LOCK  Lock,
    PVOID F, ULONG L);

PSLIST_ENTRY
DDK_ExInterlockedPushEntrySList(
    IN PSLIST_HEADER  ListHead,
    IN PSLIST_ENTRY  ListEntry,
    IN PKSPIN_LOCK  Lock,
    PVOID F, ULONG L);

PSLIST_ENTRY
DDK_ExInterlockedFlushSList(
    IN PSLIST_HEADER  ListHead,
    PVOID F, ULONG L);

PSINGLE_LIST_ENTRY
DDK_ExInterlockedPushEntryList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK,
    PVOID F, ULONG L);

PSINGLE_LIST_ENTRY
DDK_ExInterlockedPopEntryList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK,
    PVOID F, ULONG L);

VOID
DDK_InitializeListHead(
    IN PLIST_ENTRY  ListHead,
    PVOID F, ULONG L);

VOID
DDK_InsertHeadList(
    IN PLIST_ENTRY  ListHead,
    IN PLIST_ENTRY Entry,
    PVOID F, ULONG L);

VOID
DDK_InsertTailList(
    IN PLIST_ENTRY  ListHead,
    IN PLIST_ENTRY Entry,
    PVOID F, ULONG L);

PLIST_ENTRY
DDK_RemoveHeadList(
    IN PLIST_ENTRY  ListHead,
    PVOID F, ULONG L);

PLIST_ENTRY
DDK_RemoveTailList(
    IN PLIST_ENTRY  ListHead,
    PVOID F, ULONG L);

BOOLEAN
DDK_IsListEmpty(
    IN PLIST_ENTRY  ListHead,
    PVOID F, ULONG L);

PLIST_ENTRY
DDK_ExInterlockedInsertHeadList(
    IN PLIST_ENTRY  ListHead,
    IN PLIST_ENTRY  ListEntry,
    IN PKSPIN_LOCK  Lock,
    PVOID F, ULONG L);

PLIST_ENTRY
DDK_ExInterlockedInsertTailList(
    IN PLIST_ENTRY  ListHead,
    IN PLIST_ENTRY  ListEntry,
    IN PKSPIN_LOCK  Lock,
    PVOID F, ULONG L);

PLIST_ENTRY
DDK_ExInterlockedRemoveHeadList(
    IN PLIST_ENTRY  ListHead,
    IN PKSPIN_LOCK  Lock,
    PVOID F, ULONG L);

#ifdef ExInitializeSListHead
    #undef ExInitializeSListHead
#endif
#define ExInitializeSListHead(ListHead) DDK_ExInitializeSListHead(ListHead,__FILE__,__LINE__)

#ifdef ExQueryDepthSList
    #undef ExQueryDepthSList
#endif
#define ExQueryDepthSList(ListHead) DDK_ExQueryDepthSList(ListHead,__FILE__,__LINE__)

#ifdef ExInterlockedPopEntrySList
    #undef ExInterlockedPopEntrySList
#endif
#define ExInterlockedPopEntrySList(ListHead,Lock) DDK_ExInterlockedPopEntrySList(ListHead,Lock,__FILE__,__LINE__)

#ifdef ExInterlockedPushEntrySList
    #undef ExInterlockedPushEntrySList
#endif
#define ExInterlockedPushEntrySList(ListHead,Entry,Lock) DDK_ExInterlockedPushEntrySList(ListHead,Entry,Lock,__FILE__,__LINE__)

#ifdef ExInterlockedFlushSList
    #undef ExInterlockedFlushSList
#endif
#define ExInterlockedFlushSList(ListHead) DDK_ExInterlockedFlushSList(ListHead,__FILE__,__LINE__)


//
// Doubly Linked List Routines
//
#ifdef InitializeListHead
    #undef InitializeListHead
#endif
#define InitializeListHead(ListHead) DDK_InitializeListHead(ListHead,__FILE__,__LINE__)

#ifdef InsertHeadList
    #undef InsertHeadList
#endif
#define InsertHeadList(ListHead,Entry) DDK_InsertHeadList(ListHead,Entry,__FILE__,__LINE__)

#ifdef InsertTailList
    #undef InsertTailList
#endif
#define InsertTailList(ListHead,Entry) DDK_InsertTailList(ListHead,Entry,__FILE__,__LINE__)

#ifdef RemoveHeadList
    #undef RemoveHeadList
#endif
#define RemoveHeadList(ListHead) DDK_RemoveHeadList(ListHead,__FILE__,__LINE__)

#ifdef RemoveTailList
    #undef RemoveTailList
#endif
#define RemoveTailList(ListHead) DDK_RemoveTailList(ListHead,__FILE__,__LINE__)

#ifdef IsListEmpty
    #undef IsListEmpty
#endif
#define IsListEmpty(ListHead) DDK_IsListEmpty(ListHead,__FILE__,__LINE__)

//
// Interlocked List Routines
//

#ifdef ExInterlockedInsertHeadList
    #undef ExInterlockedInsertHeadList
#endif
#define ExInterlockedInsertHeadList(_ListHead,_ListEntry,_SpinLock) DDK_ExInterlockedInsertHeadList(_ListHead,_ListEntry,_SpinLock,__FILE__,__LINE__)

#ifdef ExInterlockedInsertTailList
    #undef ExInterlockedInsertTailList
#endif
#define ExInterlockedInsertTailList(_ListHead,_ListEntry,_SpinLock) DDK_ExInterlockedInsertTailList(_ListHead,_ListEntry,_SpinLock,__FILE__,__LINE__)

#ifdef ExInterlockedRemoveHeadList
    #undef ExInterlockedRemoveHeadList
#endif
#define ExInterlockedRemoveHeadList(_ListHead,_SpinLock) DDK_ExInterlockedRemoveHeadList(_ListHead,_SpinLock,__FILE__,__LINE__)

//
// Lookaside List Routines
//
VOID
NTAPI
DDK_ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth,
    PVOID F, ULONG L);

VOID
NTAPI
DDK_ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    PVOID F, ULONG L);

VOID
NTAPI
DDK_ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth,
    PVOID F, ULONG L);


VOID
NTAPI
DDK_ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    PVOID F, ULONG L);

PVOID
NTAPI
DDK_ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    PVOID F, ULONG L);


VOID
NTAPI
DDK_ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry,
    PVOID F, ULONG L);

PVOID
NTAPI
DDK_ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    PVOID F, ULONG L);

VOID
NTAPI
DDK_ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry,
    PVOID F, ULONG L);


//
#ifdef ExInitializePagedLookasideList
    #undef ExInitializePagedLookasideList
#endif
#define ExInitializePagedLookasideList(a,b,c,d,e,f,g) DDK_ExInitializePagedLookasideList(a,b,c,d,e,f,g,__FILE__,__LINE__)

#ifdef ExDeletePagedLookasideList
    #undef ExDeletePagedLookasideList
#endif
#define ExDeletePagedLookasideList(a) DDK_ExDeletePagedLookasideList(a,__FILE__,__LINE__)

#ifdef ExInitializeNPagedLookasideList
    #undef ExInitializeNPagedLookasideList
#endif
#define ExInitializeNPagedLookasideList(a,b,c,d,e,f,g) DDK_ExInitializeNPagedLookasideList(a,b,c,d,e,f,g,__FILE__,__LINE__)

#ifdef ExDeleteNPagedLookasideList
    #undef ExDeleteNPagedLookasideList
#endif
#define ExDeleteNPagedLookasideList(a) DDK_ExDeleteNPagedLookasideList(a,__FILE__,__LINE__)

#ifdef ExAllocateFromPagedLookasideList
    #undef ExAllocateFromPagedLookasideList
#endif
#define ExAllocateFromPagedLookasideList(a) DDK_ExAllocateFromPagedLookasideList(a,__FILE__,__LINE__)

#ifdef ExFreeToPagedLookasideList
    #undef ExFreeToPagedLookasideList
#endif
#define ExFreeToPagedLookasideList(a,b) DDK_ExFreeToPagedLookasideList(a,b,__FILE__,__LINE__)

#ifdef ExAllocateFromNPagedLookasideList
    #undef ExAllocateFromNPagedLookasideList
#endif
#define ExAllocateFromNPagedLookasideList(a) DDK_ExAllocateFromNPagedLookasideList(a,__FILE__,__LINE__)

#ifdef ExFreeToNPagedLookasideList
    #undef ExFreeToNPagedLookasideList
#endif
#define ExFreeToNPagedLookasideList(a,b) DDK_ExFreeToNPagedLookasideList(a,b,__FILE__,__LINE__)

//IoGetCurrentIrpStackLocation;
PIO_STACK_LOCATION 
DDK_IoGetCurrentIrpStackLocation(
    IN PIRP  Irp,
    PVOID F, ULONG L);
 
//IoGetNextIrpStackLocation; 
PIO_STACK_LOCATION 
DDK_IoGetNextIrpStackLocation(
    IN PIRP  Irp,
    PVOID F, ULONG L);

//IoMarkIrpPending; 
VOID 
DDK_IoMarkIrpPending(
    IN OUT PIRP  Irp,
    PVOID F, ULONG L);

//IoSetCancelRoutine; 
PDRIVER_CANCEL 
DDK_IoSetCancelRoutine(
    IN PIRP  Irp,
    IN PDRIVER_CANCEL  CancelRoutine,
    PVOID F, ULONG L);

//IoSetCompletionRoutine; 
VOID 
DDK_IoSetCompletionRoutine(
    IN PIRP  Irp,
    IN PIO_COMPLETION_ROUTINE  CompletionRoutine,
    IN PVOID  Context,
    IN BOOLEAN    InvokeOnSuccess,
    IN BOOLEAN  InvokeOnError,
    IN BOOLEAN  InvokeOnCancel,
    PVOID F, ULONG L);

VOID 
DDK_IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP  Irp,
    IN PIO_COMPLETION_ROUTINE  CompletionRoutine,
    IN PVOID  Context,
    IN BOOLEAN    InvokeOnSuccess,
    IN BOOLEAN  InvokeOnError,
    IN BOOLEAN  InvokeOnCancel,
    PVOID F, ULONG L);


//IoSetNextIrpStackLocation; 
VOID 
DDK_IoSetNextIrpStackLocation(
    IN OUT PIRP  Irp,
    PVOID F, ULONG L);

//IoCopyCurrentIrpStackLocationToNext; 
VOID 
DDK_IoCopyCurrentIrpStackLocationToNext(
    IN PIRP  Irp,
    PVOID F, ULONG L);

//IoSkipCurrentIrpStackLocation
VOID 
DDK_IoSkipCurrentIrpStackLocation(
    IN PIRP  Irp,
    PVOID F, ULONG L);

//
#ifdef IoGetCurrentIrpStackLocation
    #undef IoGetCurrentIrpStackLocation
#endif
#define IoGetCurrentIrpStackLocation(a) DDK_IoGetCurrentIrpStackLocation(a,__FILE__,__LINE__)

#ifdef IoGetNextIrpStackLocation
    #undef IoGetNextIrpStackLocation
#endif
#define IoGetNextIrpStackLocation(a) DDK_IoGetNextIrpStackLocation(a,__FILE__,__LINE__)

#ifdef IoMarkIrpPending
    #undef IoMarkIrpPending
#endif
#define IoMarkIrpPending(a) DDK_IoMarkIrpPending(a,__FILE__,__LINE__)

#ifdef IoSetCancelRoutine
    #undef IoSetCancelRoutine
#endif
#define IoSetCancelRoutine(a,b) DDK_IoSetCancelRoutine(a,b,__FILE__,__LINE__)

#ifdef IoSetCompletionRoutine
    #undef IoSetCompletionRoutine
#endif
#define IoSetCompletionRoutine(a,b,c,d,e,f) DDK_IoSetCompletionRoutine(a,b,c,d,e,f,__FILE__,__LINE__)

#ifdef IoSetCompletionRoutineEx
    #undef IoSetCompletionRoutineEx
#endif
#define IoSetCompletionRoutineEx(a,b,c,d,e,f,g) DDK_IoSetCompletionRoutineEx(a,b,c,d,e,f,g,__FILE__,__LINE__)

#ifdef IoSetNextIrpStackLocation
    #undef IoSetNextIrpStackLocation
#endif
#define IoSetNextIrpStackLocation(a) DDK_IoSetNextIrpStackLocation(a,__FILE__,__LINE__)

#ifdef IoCopyCurrentIrpStackLocationToNext
    #undef IoCopyCurrentIrpStackLocationToNext
#endif
#define IoCopyCurrentIrpStackLocationToNext(a) DDK_IoCopyCurrentIrpStackLocationToNext(a,__FILE__,__LINE__)

#ifdef IoSkipCurrentIrpStackLocation
    #undef IoSkipCurrentIrpStackLocation
#endif
#define IoSkipCurrentIrpStackLocation(a) DDK_IoSkipCurrentIrpStackLocation(a,__FILE__,__LINE__)



//
//
PVOID
NTAPI
DDK_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    PVOID F, ULONG L);

#ifdef ExAllocatePool
    #undef ExAllocatePool
#endif
#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocatePool)      // Use ExAllocatePoolWithTag
#endif
#define ExAllocatePool(a, b) DDK_ExAllocatePool(a,b,__FILE__,__LINE__)

PVOID
NTAPI
DDK_ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    PVOID F, ULONG L);
#ifdef ExAllocatePoolWithQuota
    #undef ExAllocatePoolWithQuota
#endif
#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocatePoolWithQuota)      // Use ExAllocatePoolWithQuotaTag
#endif
#define ExAllocatePoolWithQuota(a,b) DDK_ExAllocatePoolWithQuota(a,b,__FILE__,__LINE__)

PVOID
NTAPI
DDK_ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    PVOID F, ULONG L);

#ifdef ExAllocatePoolWithTag
    #undef ExAllocatePoolWithTag
#endif
#define ExAllocatePoolWithTag(a,b,c) DDK_ExAllocatePoolWithTag(a,b,c,__FILE__,__LINE__)

PVOID
NTAPI
DDK_ExAllocatePoolWithTagPriority(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority,
    PVOID F, ULONG L);

#ifdef ExAllocatePoolWithTagPriority
    #undef ExAllocatePoolWithTagPriority
#endif
#define ExAllocatePoolWithTagPriority(a,b,c,d) DDK_ExAllocatePoolWithTagPriority(a,b,c,d,__FILE__,__LINE__)

PVOID
NTAPI
DDK_ExAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    PVOID F, ULONG L);

#ifdef ExAllocatePoolWithQuotaTag
    #undef ExAllocatePoolWithQuotaTag
#endif
#define ExAllocatePoolWithQuotaTag(a,b,c) DDK_ExAllocatePoolWithQuotaTag(a,b,c,__FILE__,__LINE__)

VOID
NTAPI
DDK_ExFreePool(
    IN PVOID P,
    PVOID F, ULONG L);
#ifdef ExFreePool
    #undef ExFreePool
#endif
#define ExFreePool(a) DDK_ExFreePool(a,__FILE__,__LINE__) 

VOID
NTAPI
DDK_ExFreePoolWithTag(
    IN PVOID P,
    IN ULONG Tag,
    PVOID F, ULONG L);

#ifdef ExFreePoolWithTag
    #undef ExFreePoolWithTag
#endif
#define ExFreePoolWithTag(a,b) DDK_ExFreePoolWithTag(a,b,__FILE__,__LINE__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dciman.h ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1999 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight,
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dciddi.h ===
/*******************************************************************
 *
 *      FILE:           dciddi.h
 *
 *      DESCRIPTION:    definitions for MS/Intel-defined DCI interface
 *
 *      Copyright (C) 1994-1999 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */
#define DCICOMMAND                      3075
#define DCI_VERSION                     0x0100

#define DCICREATEPRIMARYSURFACE         1
#define DCICREATEOFFSCREENSURFACE       2
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                                  0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN                      -17
#define DCI_ERR_YALIGN                      -18
#define DCI_ERR_XYALIGN                     -19
#define DCI_ERR_WIDTHALIGN                  -20
#define DCI_ERR_HEIGHTALIGN                 -21

/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16
#define DCI_STATUS_WASSTILLDRAWING         32

#define DCI_SUCCESS(error)  (((DCIRVAL)error) >= 0)

/* DCI Capability Flags */
#define DCI_SURFACE_TYPE                        0x0000000F
#define DCI_PRIMARY                             0x00000000
#define DCI_OFFSCREEN                           0x00000001
#define DCI_OVERLAY                             0x00000002

#define DCI_VISIBLE                             0x00000010
#define DCI_CHROMAKEY                           0x00000020
#define DCI_1632_ACCESS                         0x00000040
#define DCI_DWORDSIZE                           0x00000080
#define DCI_DWORDALIGN                          0x00000100
#define DCI_WRITEONLY                           0x00000200
#define DCI_ASYNC                               0x00000400

#define DCI_CAN_STRETCHX                        0x00001000
#define DCI_CAN_STRETCHY                        0x00002000
#define DCI_CAN_STRETCHXY                       (DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN                       0x00004000
#define DCI_CAN_STRETCHYN                       0x00008000
#define DCI_CAN_STRETCHXYN                      (DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *      input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
        DWORD   dwCommand;
        DWORD   dwParam1;
        DWORD   dwParam2;
        DWORD   dwVersion;
        DWORD   dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for
 * the DCICREATE... calls.  The fields that are actually relevant differ for
 * each of the three calls.  Details are in the DCI Spec chapter providing
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        DWORD   dwCompression;                          /* format of surface to be created                      */
        DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
        DWORD   dwWidth;                        /* height of the surface to be created          */
        DWORD   dwHeight;                       /* width of input surfaces                                      */
        DWORD   dwDCICaps;                                              /* capabilities of surface wanted */
        DWORD   dwBitCount;                                     /* bit depth of format to be created */
        LPVOID  lpSurface;                      /* pointer to an associated surface             */
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;


/**************************************************************************
 *      surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary
 * surface, and as a member of the larger structures returned by the
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
        DWORD   dwSize;                         /* size of structure                                            */
        DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
        DWORD   dwCompression;                  /* format of surface to be created                      */
        DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

        DWORD   dwWidth;                    /* width of surface                                             */
        DWORD   dwHeight;                   /* height of surface                                            */
        LONG    lStride;                    /* distance in bytes betw. one pixel            */
                                                                                /* and the pixel directly below it                      */
        DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        ULONG_PTR dwOffSurface;             /* offset of surface pointer                            */
        WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;

        DWORD   dwReserved1;                /* reserved for provider */
        DWORD   dwReserved2;                /* reserved for DCIMAN */
        DWORD   dwReserved3;                /* reserved for future */
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
        void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */
        void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;


/*
 * This structure is used by a DCI client to provide input parameters for the
 * DCIEnumSurface call.
 */

typedef
void
(*ENUM_CALLBACK) (
    LPDCISURFACEINFO lpSurfaceInfo,
    LPVOID lpContext
    );

typedef struct _DCIENUMINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        RECT    rSrc;                           /* source rect. for stretch  */
        RECT    rDst;                           /* dest. rect. for stretch       */
        void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
        LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;


/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;

/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

        DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

        DCISURFACEINFO  dciInfo;                                                /* surface info                  */
        DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
        DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dderror.h ===
/*++ BUILD Version: ????     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

#define NO_ERROR 0L                                                 
#define ERROR_INVALID_FUNCTION           1L    
#define ERROR_NOT_ENOUGH_MEMORY          8L    
#define ERROR_DEV_NOT_EXIST              55L    
#define ERROR_INVALID_PARAMETER          87L    
#define ERROR_INSUFFICIENT_BUFFER        122L    
#define ERROR_INVALID_NAME               123L    
#define ERROR_BUSY                       170L    
#define ERROR_MORE_DATA                  234L    
#define WAIT_TIMEOUT                     258L    
#define ERROR_IO_PENDING                 997L    
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    
#define ERROR_CONTINUE                   1246L    
#define ERROR_NO_MORE_DEVICES            1248L    

#endif /* _DDERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE; 

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;                                           
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\diskguid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    diskguid.h

Abstract:

    GPT disk GUIDs.

Revision History:

--*/

//
// GPT Partition Type GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntdddisk.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntdddisk.h> in that source file a second time to instantiate the GUIDs
//

#ifdef DEFINE_GUID

//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif


//
// Define the GPT partition guids known by disk drivers and volume managers.
//

DEFINE_GUID(PARTITION_ENTRY_UNUSED_GUID,   0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);    // Entry unused
DEFINE_GUID(PARTITION_SYSTEM_GUID,         0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B);    // EFI system partition
DEFINE_GUID(PARTITION_MSFT_RESERVED_GUID,  0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE);    // Microsoft reserved space                                        
DEFINE_GUID(PARTITION_BASIC_DATA_GUID,     0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7);    // Basic data partition
DEFINE_GUID(PARTITION_LDM_METADATA_GUID,   0x5808C8AAL, 0x7E8F, 0x42E0, 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3);    // Logical Disk Manager metadata partition
DEFINE_GUID(PARTITION_LDM_DATA_GUID,       0xAF9B60A0L, 0x1431, 0x4F62, 0xBC, 0x68, 0x33, 0x11, 0x71, 0x4A, 0x69, 0xAD);    // Logical Disk Manager data partition
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dmusicks.h ===
/***************************************************************************
*                                                                          *
*   DMusicKS.h -- This module defines the the DirectMusic WDM interface.   *
*                                                                          *
*   Copyright (c) Microsoft Corp. All rights reserved.                     *
*                                                                          *
***************************************************************************/

#ifndef _DMUSICKS_
#define _DMUSICKS_

#include <dmusprop.h>

#define DONT_HOLD_FOR_SEQUENCING 0x8000000000000000

typedef struct _DMUS_KERNEL_EVENT
{                                           //  this    offset
    BYTE            bReserved;              //  1       0
    BYTE            cbStruct;               //  1       1
    USHORT          cbEvent;                //  2       2
    USHORT          usChannelGroup;         //  2       4
    USHORT          usFlags;                //  2       6
    REFERENCE_TIME  ullPresTime100ns;       //  8       8
    ULONGLONG       ullBytePosition;        //  8      16
    _DMUS_KERNEL_EVENT *pNextEvt;           //  4 (8)  24
    union
    {
        BYTE        abData[sizeof(PBYTE)];  //  4 (8)  28 (32)
        PBYTE       pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;   //         32 (40)

#define DMUS_KEF_EVENT_COMPLETE     0x0000
#define DMUS_KEF_EVENT_INCOMPLETE   0x0001  //  This event is an incomplete package or sysex.
                                            //  Do not use this data.

#define DMUS_KEF_PACKAGE_EVENT      0x0002  //  This event is a package. The uData.pPackageEvt
                                            //  field contains a pointer to a chain of events.

#define kBytePositionNone   (~(ULONGLONG)0) //  This message has no meaningful byte position

#define SHORT_EVT(evt)       ((evt)->cbEvent <= sizeof(PBYTE))
#define PACKAGE_EVT(evt)     ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)
#define INCOMPLETE_EVT(evt)  ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)    (((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE) == 0)

#define SET_INCOMPLETE_EVT(evt) ((evt)->usFlags |= DMUS_KEF_EVENT_INCOMPLETE)
#define SET_COMPLETE_EVT(evt)   ((evt)->usFlags &= (~DMUS_KEF_EVENT_INCOMPLETE))
#define SET_PACKAGE_EVT(evt)    ((evt)->usFlags |= DMUS_KEF_PACKAGE_EVENT)
#define CLEAR_PACKAGE_EVT(evt)  ((evt)->usFlags &= (~DMUS_KEF_PACKAGE_EVENT))


#define STATIC_CLSID_PortDMus\
    0xb7902fe9, 0xfb0a, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("b7902fe9-fb0a-11d1-81b0-0060083316c1", CLSID_PortDMus);
#define CLSID_PortDMus DEFINE_GUIDNAMED(CLSID_PortDMus)

#define STATIC_CLSID_MiniportDriverDMusUART\
    0xd3f0ce1c, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1c-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUART);
#define CLSID_MiniportDriverDMusUART DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUART)

#define STATIC_CLSID_MiniportDriverDMusUARTCapture\
    0xd3f0ce1d, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1d-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUARTCapture);
#define CLSID_MiniportDriverDMusUARTCapture DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUARTCapture)

#define STATIC_IID_IPortDMus\
    0xc096df9c, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9c-fb09-11d1-81b0-0060083316c1", IID_IPortDMus);
#define IID_IPortDMus DEFINE_GUIDNAMED(IID_IPortDMus)

#define STATIC_IID_IMiniportDMus\
    0xc096df9d, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9d-fb09-11d1-81b0-0060083316c1", IID_IMiniportDMus);
#define IID_IMiniportDMus DEFINE_GUIDNAMED(IID_IMiniportDMus)

#define STATIC_IID_IMXF\
    0xc096df9e, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9e-fb09-11d1-81b0-0060083316c1", IID_IMXF);
#define IID_IMXF DEFINE_GUIDNAMED(IID_IMXF)

#define STATIC_IID_IAllocatorMXF\
    0xa5f0d62c, 0xb30f, 0x11d2, 0xb7, 0xa3, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("a5f0d62c-b30f-11d2-b7a3-0060083316c1", IID_IAllocatorMXF);
#define IID_IAllocatorMXF DEFINE_GUIDNAMED(IID_IAllocatorMXF)

#define STATIC_IID_ISynthSinkDMus\
    0x1f476974, 0x679b, 0x11d2, 0x8f, 0x7d, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("1f476974-679b-11d2-8f7d-00c04fbf8fef", IID_ISynthSinkDMus);
#define IID_ISynthSinkDMus DEFINE_GUIDNAMED(IID_ISynthSinkDMus)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_OUT\
    0xA4DF0EB5, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("A4DF0EB5-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_OUT);
#define KSAUDFNAME_DMUSIC_MPU_OUT DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_OUT)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_IN\
    0xB2EC0A7D, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("B2EC0A7D-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_IN);
#define KSAUDFNAME_DMUSIC_MPU_IN DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_IN)


/*****************************************************************************
 * IPortDMus
 *****************************************************************************
 * Interface for DMusic port lower edge.
 */
DECLARE_INTERFACE_(IPortDMus,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortDMus
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
    )   PURE;

    STDMETHOD_(void,RegisterServiceGroup)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;
};

typedef IPortDMus *PPORTDMUS;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortDMus\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup    OPTIONAL\
    );\
    STDMETHODIMP_(void) RegisterServiceGroup\
    (   IN      PSERVICEGROUP   ServiceGroup\
    )
#endif  /* PC_IMPLEMENTATION */


/*****************************************************************************
 * IMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IMXF;
typedef IMXF *PMXF;

#if !defined(DEFINE_ABSTRACT_MXF)

#define DEFINE_ABSTRACT_MXF()                                   \
    STDMETHOD_(NTSTATUS,SetState)                               \
    (   THIS_                                                   \
        IN      KSSTATE State                                   \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,PutMessage)                             \
    (   THIS_                                                   \
        IN      PDMUS_KERNEL_EVENT  pDMKEvt                     \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,ConnectOutput)                          \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,DisconnectOutput)                       \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_MXF)

DECLARE_INTERFACE_(IMXF,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF
};

#define IMP_IMXF\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE State\
    );\
    STDMETHODIMP_(NTSTATUS) PutMessage\
    (   IN      PDMUS_KERNEL_EVENT  pDMKEvt\
    );\
    STDMETHODIMP_(NTSTATUS) ConnectOutput\
    (   IN      PMXF    sinkMXF\
    );\
    STDMETHODIMP_(NTSTATUS) DisconnectOutput\
    (   IN      PMXF    sinkMXF\
    );\

/*****************************************************************************
 * IAllocatorMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IAllocatorMXF;
typedef IAllocatorMXF *PAllocatorMXF;

DECLARE_INTERFACE_(IAllocatorMXF,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For IAllocatorMXF
    STDMETHOD_(NTSTATUS,GetMessage)
    (   THIS_
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt
    )   PURE;

    STDMETHOD_(USHORT,GetBufferSize)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,GetBuffer)
    (   THIS_
        OUT     PBYTE * ppBuffer
    )   PURE;

    STDMETHOD_(NTSTATUS,PutBuffer)
    (   THIS_
        IN      PBYTE   pBuffer
    )   PURE;
};

#define IMP_IAllocatorMXF\
    IMP_IMXF;\
    STDMETHODIMP_(NTSTATUS) GetMessage\
    (   OUT     PDMUS_KERNEL_EVENT * ppDMKEvt\
    );\
    STDMETHODIMP_(USHORT) GetBufferSize\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) GetBuffer\
    (   OUT     PBYTE * ppBuffer\
    );\
    STDMETHODIMP_(NTSTATUS) PutBuffer\
    (   IN      PBYTE   pBuffer\
    );\


typedef enum
{
    DMUS_STREAM_MIDI_INVALID = -1,
    DMUS_STREAM_MIDI_RENDER = 0,
    DMUS_STREAM_MIDI_CAPTURE,
    DMUS_STREAM_WAVE_SINK
} DMUS_STREAM_TYPE;

/*****************************************************************************
 * ISynthSinkDMus
 *****************************************************************************
 * Interface for synth wave out.
 */
DECLARE_INTERFACE_(ISynthSinkDMus,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For ISynthSinkDMus
    STDMETHOD_(void,Render)
    (   THIS_
        IN      PBYTE       pBuffer,
        IN      DWORD       dwLength,
        IN      LONGLONG    llPosition
    )   PURE;

    STDMETHOD_(NTSTATUS,SyncToMaster)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        IN      BOOL            fStart
    )   PURE;

    STDMETHOD_(NTSTATUS,SampleToRefTime)
    (   THIS_
        IN      LONGLONG         llSampleTime,
        OUT     REFERENCE_TIME * prfTime
    )   PURE;

    STDMETHOD_(NTSTATUS,RefTimeToSample)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        OUT     LONGLONG *      pllSampleTime
    )   PURE;
};

typedef ISynthSinkDMus * PSYNTHSINKDMUS;

#define IMP_ISynthSinkDMus\
    IMP_IMXF;\
    STDMETHODIMP_(void) Render\
    (   IN      PBYTE       pBuffer,\
        IN      DWORD       dwLength,\
        IN      LONGLONG    llPosition\
    );\
    STDMETHODIMP_(NTSTATUS) SyncToMaster\
    (   IN      REFERENCE_TIME  rfTime,\
        IN      BOOL            fStart\
    );\
    STDMETHODIMP_(NTSTATUS) SampleToRefTime\
    (   IN      LONGLONG         llSampleTime,\
        OUT     REFERENCE_TIME * prfTime\
    );\
    STDMETHODIMP_(NTSTATUS) RefTimeToSample\
    (   IN      REFERENCE_TIME  rfTime,\
        OUT     LONGLONG *      pllSampleTime\
    )


/*****************************************************************************
 * IMasterClock
 *****************************************************************************
 * Master clock for MXF graph
 */
DECLARE_INTERFACE_(IMasterClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,GetTime)
    (   THIS_
        OUT     REFERENCE_TIME  * pTime
    )   PURE;
};

typedef IMasterClock *PMASTERCLOCK;

#define IMP_IMasterClock               \
    STDMETHODIMP_(NTSTATUS) GetTime               \
    (   THIS_                          \
        OUT     REFERENCE_TIME * pTime \
    );                                 \


/*****************************************************************************
 * IMiniportDMus
 *****************************************************************************
 * Interface for DMusic miniports.
 */
DECLARE_INTERFACE_(IMiniportDMus,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportDMus
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMXF                  * MXF,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    )   PURE;
};

typedef IMiniportDMus *PMINIPORTDMUS;

#define IMP_IMiniportDMus\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTDMUS       Port,\
        OUT     PSERVICEGROUP * ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMXF                  * MXF,                        \
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,   \
        IN      POOL_TYPE               PoolType,                   \
        IN      ULONG                   PinID,                      \
        IN      DMUS_STREAM_TYPE        StreamType,                 \
        IN      PKSDATAFORMAT           DataFormat,                 \
        OUT     PSERVICEGROUP         * ServiceGroup,               \
        IN      PAllocatorMXF           AllocatorMXF,               \
        IN      PMASTERCLOCK            MasterClock,                \
        OUT     PULONGLONG              SchedulePreFetch            \
    )

DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb, 0x04cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_Effects,     0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x00, 0x60, 0x08, 0x93, 0xb1, 0xbd);

#ifndef DMUS_EFFECT_NONE
#define DMUS_EFFECT_NONE    0x00000000
#endif

#ifndef DMUS_EFFECT_REVERB
#define DMUS_EFFECT_REVERB  0x00000001
#endif

#ifndef DMUS_EFFECT_CHORUS
#define DMUS_EFFECT_CHORUS  0x00000002
#endif


#endif  /* _DMUSICKS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    devioctl.h

Abstract:

    This module contains

Author:

    Andre Vachon (andreva) 21-Feb-1992


Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define some easier to comprehend aliases:
//   METHOD_DIRECT_TO_HARDWARE (writes, aka METHOD_IN_DIRECT)
//   METHOD_DIRECT_FROM_HARDWARE (reads, aka METHOD_OUT_DIRECT)
//

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_wdm end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dxapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxapi.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXAPI class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
);

ULONG
DxApiGetVersion(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\dmusprop.h ===
/***************************************************************************
*                                                                          *
*   DMusProp.h -- This module defines property items for DirectMusic WDM   *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusProp_
#define _DMusProp_

#include "dmusbuff.h"

/*
    Formats
*/
#define STATIC_KSDATAFORMAT_SUBTYPE_DIRECTMUSIC\
    0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("1a82f8bc-3f8b-11d2-b774-0060083316c1", KSDATAFORMAT_SUBTYPE_DIRECTMUSIC);
#define KSDATAFORMAT_SUBTYPE_DIRECTMUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC)


/*
    Topology
*/
#define STATIC_KSNODETYPE_DMSYNTH\
    0x94824f88, 0x6183, 0x11d2, 0x8f, 0x7a, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("94824F88-6183-11d2-8F7A-00C04FBF8FEF", KSNODETYPE_DMSYNTH);
#define KSNODETYPE_DMSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH)

/*
    Caps node (per pin)
*/
#define STATIC_KSNODETYPE_DMSYNTH_CAPS\
    0xbca2a2f1, 0x93c6, 0x11d2, 0xba, 0x1d, 0x0, 0x0, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("bca2a2f1-93c6-11d2-ba1d-0000f875ac12", KSNODETYPE_DMSYNTH_CAPS);
#define KSNODETYPE_DMSYNTH_CAPS DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH_CAPS)

/*
    DDK Property sets and items
*/
#define STATIC_KSPROPSETID_Synth_Dls\
    0xd523fa2c, 0xdee3, 0x11d1, 0xa7, 0x89, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("d523fa2c-dee3-11d1-a789-0000f875ac12", KSPROPSETID_Synth_Dls);
#define KSPROPSETID_Synth_Dls DEFINE_GUIDNAMED(KSPROPSETID_Synth_Dls)

typedef enum
{
    KSPROPERTY_SYNTH_DLS_DOWNLOAD = 0,
    KSPROPERTY_SYNTH_DLS_UNLOAD,
    KSPROPERTY_SYNTH_DLS_COMPACT,
    KSPROPERTY_SYNTH_DLS_APPEND,
    KSPROPERTY_SYNTH_DLS_WAVEFORMAT
} KSPROPERTY_SYNTH_DLS;

typedef struct _SYNTH_BUFFER
{
    ULONG   BufferSize;
    PVOID   BufferAddress;
} SYNTH_BUFFER, *PSYNTH_BUFFER;

typedef struct _SYNTHDOWNLOAD
{
    HANDLE  DownloadHandle;
    BOOL    Free;               /* the client buffer can be freed */
} SYNTHDOWNLOAD, *PSYNTHDOWNLOAD;


#define STATIC_KSPROPSETID_Synth\
    0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae25-e46e-11d1-aace-0000f875ac12", KSPROPSETID_Synth);
#define KSPROPSETID_Synth DEFINE_GUIDNAMED(KSPROPSETID_Synth)

typedef enum
{
    KSPROPERTY_SYNTH_VOLUME = 0,  /* must be first */
    KSPROPERTY_SYNTH_VOLUMEBOOST,
    KSPROPERTY_SYNTH_CAPS,
    KSPROPERTY_SYNTH_PORTPARAMETERS,
    KSPROPERTY_SYNTH_CHANNELGROUPS,
    KSPROPERTY_SYNTH_VOICEPRIORITY,
    KSPROPERTY_SYNTH_LATENCYCLOCK,
    KSPROPERTY_SYNTH_RUNNINGSTATS
} KSPROPERTY_SYNTH;

#define SYNTH_PC_DLS                (0x00000001)
#define SYNTH_PC_EXTERNAL           (0x00000002)
#define SYNTH_PC_SOFTWARESYNTH      (0x00000004)
#define SYNTH_PC_MEMORYSIZEFIXED    (0x00000008)
#define SYNTH_PC_GMINHARDWARE       (0x00000010)
#define SYNTH_PC_GSINHARDWARE       (0x00000020)
#define SYNTH_PC_XGINHARDWARE       (0x00000040)
// 0x80 used in user mode
// 0x100 used in user mode
#define SYNTH_PC_DLS2               (0x00000200)
// 0x400 used in user mode
// 0x800 used in user mode
#define SYNTH_PC_REVERB             (0x40000000)

#define SYNTH_PC_SYSTEMMEMORY       (0x7fffffff)

typedef struct _SYNTHCAPS
{
    GUID    Guid;
    DWORD   Flags;
    DWORD   MemorySize;
    DWORD   MaxChannelGroups;
    DWORD   MaxVoices;
    DWORD   MaxAudioChannels;
    DWORD   EffectFlags;
    WCHAR   Description[128];
} SYNTHCAPS, *PSYNTHCAPS;


typedef struct _SYNTH_PORTPARAMS
{
    DWORD   ValidParams;
    DWORD   Voices;
    DWORD   ChannelGroups;
    DWORD   AudioChannels;
    DWORD   SampleRate;
    DWORD   EffectsFlags;
    DWORD   Share;
} SYNTH_PORTPARAMS, *PSYNTH_PORTPARAMS;

/*  These flags (set in ValidParams) indicate which
 *  other members of the SYNTH_PORTPARAMS are valid
 */
#define SYNTH_PORTPARAMS_VOICES           0x00000001
#define SYNTH_PORTPARAMS_CHANNELGROUPS    0x00000002
#define SYNTH_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define SYNTH_PORTPARAMS_SAMPLERATE       0x00000008
#define SYNTH_PORTPARAMS_EFFECTS          0x00000020
#define SYNTH_PORTPARAMS_SHARE            0x00000040

/* SYNTH_EFFECT_ flags are used in the
 * EffectFlags fields of SYNTH_PORTPARAMS.
 */

#define SYNTH_EFFECT_NONE             0x00000000
#define SYNTH_EFFECT_REVERB           0x00000001
#define SYNTH_EFFECT_CHORUS           0x00000002
#define SYNTH_EFFECT_DELAY            0x00000004

/*
 * Instance data for KSPROPERTY_ITEM_SynthVoicePriority
 */
typedef struct _SYNTHVOICEPRIORITY_INSTANCE
{
    DWORD   ChannelGroup;
    DWORD   Channel;
} SYNTHVOICEPRIORITY_INSTANCE, *PSYNTHVOICEPRIORITY_INSTANCE;

/*
 * Data returned by KSPROPERTY_SYNTH_RUNNINGSTATS
 */
typedef struct _SYNTH_STATS
{
    DWORD   ValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   Voices;           /* Average number of voices playing. */
    DWORD   TotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   CPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   LostNotes;        /* Number of notes lost in 1 second. */
    DWORD   FreeMemory;       /* Free memory in bytes */
    LONG    PeakVolume;       /* Decibel level * 100. */
} SYNTH_STATS, *PSYNTH_STATS;


#define SYNTH_STATS_VOICES          (1 << 0)
#define SYNTH_STATS_TOTAL_CPU       (1 << 1)
#define SYNTH_STATS_CPU_PER_VOICE   (1 << 2)
#define SYNTH_STATS_LOST_NOTES      (1 << 3)
#define SYNTH_STATS_PEAK_VOLUME     (1 << 4)
#define SYNTH_STATS_FREE_MEMORY     (1 << 5)

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000)

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)


#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */

/*
    SDK Property sets and items
*/
typedef struct _SYNTH_REVERB_PARAMS
{
    float   fInGain;            /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;         /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal).
                                   Negative values gives less wet signal.  The coeficients are
                                   calculated so that the overall output level stays (approximately)
                                   constant regardless of the ammount of reverb mix. */
    float   fReverbTime;        /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio;   /* The ratio of the high frequencies to the global reverb time.
                                   Unless very 'splashy-bright' reverbs are wanted, this should be set to
                                   a value < 1.0.  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1
                                   than the decay time for high frequencies will be 100ms.*/
} SYNTH_REVERB_PARAMS, *PSYNTH_REVERB_PARAMS;


#define STATIC_KSPROPSETID_SynthClock \
    0xfedfae26L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae26-e46e-11d1-aace-0000f875ac12", KSPROPSETID_SynthClock);
#define KSPROPSETID_SynthClock DEFINE_GUIDNAMED(KSPROPSETID_SynthClock)

typedef enum
{
    KSPROPERTY_SYNTH_MASTERCLOCK
} KSPROPERTY_SYNTHCLOCK;
#endif /* _DMusProp_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\gameport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    gameport.h

Abstract:

    This module contains the common public declarations for the game port
    enumerator.

@@BEGIN_DDKSPLIT

Author:

    Kenneth Ray

@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/


#ifndef __GAMEPORT_H
#define __GAMEPORT_H

#define FILE_DEVICE_GAMEENUM         FILE_DEVICE_BUS_EXTENDER

// ***************************************************************************
// IOCTL interface to the bus (fdo)
//
// Clients use this to tell the enumerator what gaming devices on legacy ports
// exist.  (like for instance a control panel)
// ***************************************************************************

//
// Define an Interface Guid to access the game port enumerator
//

#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

DEFINE_GUID (GUID_GAMEENUM_BUS_ENUMERATOR, 0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda);
//  cae56030-684a-11d0-b6f6-00a0c90f57da

#define GAMEENUM_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define GAMEENUM_INTERNAL_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_GAMEENUM_EXPOSE_HARDWARE  GAMEENUM_IOCTL (0x0)
#define IOCTL_GAMEENUM_REMOVE_HARDWARE  GAMEENUM_IOCTL (0x1)
#define IOCTL_GAMEENUM_PORT_DESC        GAMEENUM_IOCTL (0x2)

//
//      Private data storage area for OEM devices. Values preserved if supplied to
// IOCTL_GAMEENUM_EXPOSE_HARDWARE and GAMEENUM_INTERNAL_IOCTL_EXPOSE_SIBLING,
//      and set to zero otherwise on initial mini-driver invocation (DriverEntry).
//

#define SIZE_GAMEENUM_OEM_DATA                  8
typedef ULONG   GAMEENUM_OEM_DATA[SIZE_GAMEENUM_OEM_DATA];

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

typedef struct _GAMEENUM_EXPOSE_HARDWARE
{
    //
    // sizeof (struct _GAMEENUM_HARDWARE)
    //
    IN ULONG Size;

    //
    // The handle of the port found in the port desc
    //
    IN PVOID PortHandle;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // For legacy joysticks only
    //
    IN USHORT NumberJoysticks;

    //
    // legacy joysticks only (joysticks * axis <= 4).
    //
    IN USHORT NumberAxis;

    //
    // Unique ID
    //
    IN USHORT UnitID;

    //
    // Number of buttons present on the device
    //
    IN USHORT NumberButtons;

    //
    // Bit flags controlling the behavior of the device
    //
    USHORT Flags;

    //
    // Reserved for future use
    //
    USHORT Reserved[5];

    //
    // Specific OEM Data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ)
    //
    IN  WCHAR                                   HardwareIDs[];

} GAMEENUM_EXPOSE_HARDWARE, *PGAMEENUM_EXPOSE_HARDWARE;


//
// Bit values defined for the Flags field
//     GAMEENUM_FLAG_NOCOMPATID the default compatibility hardware ID should 
//     not be exposed for this device.
//     GAMEENUM_FLAG_COMPATIDCTRL if this is zero GAMEENUM_FLAG_NOCOMPATID is 
//     ignored
//     GAMEENUM_FLAG_RESERVED reserved bits, should be set to zero
//
#define GAMEENUM_FLAG_NOCOMPATID    0x0001
#define GAMEENUM_FLAG_COMPATIDCTRL  0x0002
#define GAMEENUM_FLAG_RESERVED      0xFFFC


#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _GAMEENUM_REMOVE_HARDWARE
{
    //
    // sizeof (struct _REMOVE_HARDWARE)
    //
    IN ULONG Size;

    //
    // Same value as HardwareHandle in GAMEENUM_EXPOSE_HARDWARE
    //
    IN PVOID HardwareHandle;

} GAMEENUM_REMOVE_HARDWARE, *PGAMEENUM_REMOVE_HARDWARE;

typedef struct _GAMEENUM_PORT_DESC
{
    IN  ULONG               Size;       // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        ULONG               Reserved [5];
} GAMEENUM_PORT_DESC, *PGAMEENUM_PORT_DESC;

// **************************************************************************
// Internal IOCTL interface for (pdo)
// The HID to legacy game port minidriver uses this interface to
// find the address of the device.
// **************************************************************************

#define IOCTL_GAMEENUM_PORT_PARAMETERS          GAMEENUM_INTERNAL_IOCTL (0x100)
#define IOCTL_GAMEENUM_EXPOSE_SIBLING           GAMEENUM_INTERNAL_IOCTL (0x101)
#define IOCTL_GAMEENUM_REMOVE_SELF              GAMEENUM_INTERNAL_IOCTL (0x102)
#define IOCTL_GAMEENUM_ACQUIRE_ACCESSORS        GAMEENUM_INTERNAL_IOCTL (0x103)

// Of which IO_STACK_LOCATION->Parameters.Others.Argument1 is set to
// a pointer to struct _GAMEENUM_GAME_PARAMETERS

typedef
UCHAR
(*PGAMEENUM_READPORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_WRITEPORT) (
    PVOID  GameContext,
    UCHAR   Value
    );

#define GAMEENUM_BUTTON_1   0x01
#define GAMEENUM_BUTTON_2   0x02
#define GAMEENUM_BUTTON_3   0x04
#define GAMEENUM_BUTTON_4   0x08

#define GAMEENUM_AXIS_X     0x10
#define GAMEENUM_AXIS_Y     0x20
#define GAMEENUM_AXIS_R     0x40
#define GAMEENUM_AXIS_Z     0x80

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

typedef
NTSTATUS
(*PGAMEENUM_READPORT_DIGITAL) (
    IN     PVOID   Context,
    IN     UCHAR   ButtonAxisMask,
    IN     BOOLEAN Approximate,
    IN OUT ULONG   AxisState[4],
       OUT UCHAR   ButtonState[4]
    );
/*++
Routine Description.

    Will read from the gameport digitally.

Arguments:

    Context        -    value passed in GAME_PORT_PARAMETERS.GameContext

    ButtonAxisMask -    Mask indicating which axis  and buttons are expected to
                        have valid data

    Approximate    -    OK to approximate (if polling times out, etc)

    AxisState      -    IN  = Last valid axis state
                        OUT = Current Axis state

                        Index       Maps to Axis
                        0           X
                        1           Y
                        2           R
                        3           Z

    ButtonState    -    OUT =  Current button state.

--*/

typedef
NTSTATUS
(*PGAMEENUM_ACQUIRE_PORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_RELEASE_PORT) (
    PVOID  GameContext
    );

typedef enum _GAMEENUM_PORTION
{
        GameenumFirstHalf,
        GameenumSecondHalf,
        GameenumWhole
} GAMEENUM_PORTION;

typedef struct _GAMEENUM_PORT_PARAMETERS
{
    //
    // sizeof (GAMEENUM_GET_PORT_PARAMETERS)
    //
    IN  ULONG Size;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT WriteAccessor;

    //
    // token to read/write this game port
    //
    OUT PVOID GameContext;

    //
    // Which joystick is it?
    //
    OUT GAMEENUM_PORTION Portion;

    //
    // legacy joysticks only
    //
    OUT USHORT NumberAxis;

    //
    // unique id
    //
    IN USHORT UnitID;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // Number of buttons
    //
    OUT USHORT NumberButtons;

    //
    // Reserved for future use
    //
    USHORT Reserved2;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    ULONG Reserved[3];

} GAMEENUM_PORT_PARAMETERS, *PGAMEENUM_PORT_PARAMETERS;

typedef struct _GAMEENUM_EXPOSE_SIBLING
{
    //
    // sizeof (struct _GAMEENUM_EXPOSE_SIBLING)
    //
    IN ULONG Size;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // The id of this device object
    //
    IN USHORT UnitID;

    USHORT Reserved[3];

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ),
    //
    IN PWCHAR HardwareIDs OPTIONAL;

} GAMEENUM_EXPOSE_SIBLING, *PGAMEENUM_EXPOSE_SIBLING;

//
// This struct is sent down to the PDO/lower filters of gameenum via
// the internal IOCTL  IOCTL_GAMEENUM_ACQUIRE_ACCESSORS.  If this IOCTL is
// handled, GameContext, ReadAccessor, and WriteAccessor must be filled in.
// ReadAccessorDigital is optional
//
typedef struct _GAMEENUM_ACQUIRE_ACCESSORS
{
    //
    // sizeof (struct _GAMEENUM_ACQUIRE_ACCESSORS)
    //
    IN ULONG                        Size;

    //
    // token to read/write this game port
    //
    OUT PVOID                       GameContext;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT          ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT         WriteAccessor;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    OUT ULONG                       Reserved[3];

} GAMEENUM_ACQUIRE_ACCESSORS, *PGAMEENUM_ACQUIRE_ACCESSORS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\fltsafe.h ===
// fltsafe.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

// FLOATSAFE
//
// Saves floating point state on construction and restores on destruction.
//
struct FLOATSAFE
{
    KFLOATING_SAVE     FloatSave;
    NTSTATUS           ntStatus;

    FLOATSAFE::FLOATSAFE(void)
    {
        ntStatus = KeSaveFloatingPointState(&FloatSave);
    }

    FLOATSAFE::~FLOATSAFE(void)
    {
        if (NT_SUCCESS(ntStatus))
        {
            KeRestoreFloatingPointState(&FloatSave);
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\hbapiwmi.h ===
#ifndef _hbapiwmi_h_
#define _hbapiwmi_h_

// MSFC_HBAPortStatistics - MSFC_HBAPortStatistics


//***************************************************************************
//
//  hbapiwmi.h
// 
//  Module: WDM classes to expose HBA api data from drivers
//
//  Purpose: Contains WDM classes that specify the HBA data to be exposed 
//           via the HBA api set.
//
//  NOTE: This file contains information that is based upon an earlier
//        revision of the HBAAPI 2.0 specification. Since the
//        specification has not yet been approved, the information may
//        change in the next release of this file.
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************


#define MSFC_HBAPortStatisticsGuid \
    { 0x3ce7904f,0x459f,0x480d, { 0x9a,0x3c,0x01,0x3e,0xde,0x3b,0xdd,0xe8 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAPortStatistics_GUID, \
            0x3ce7904f,0x459f,0x480d,0x9a,0x3c,0x01,0x3e,0xde,0x3b,0xdd,0xe8);
#endif


typedef struct _MSFC_HBAPortStatistics
{
    // 
    LONGLONG SecondsSinceLastReset;
    #define MSFC_HBAPortStatistics_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_SecondsSinceLastReset_ID 1

    // 
    LONGLONG TxFrames;
    #define MSFC_HBAPortStatistics_TxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_TxFrames_ID 2

    // 
    LONGLONG TxWords;
    #define MSFC_HBAPortStatistics_TxWords_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_TxWords_ID 3

    // 
    LONGLONG RxFrames;
    #define MSFC_HBAPortStatistics_RxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_RxFrames_ID 4

    // 
    LONGLONG RxWords;
    #define MSFC_HBAPortStatistics_RxWords_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_RxWords_ID 5

    // 
    LONGLONG LIPCount;
    #define MSFC_HBAPortStatistics_LIPCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LIPCount_ID 6

    // 
    LONGLONG NOSCount;
    #define MSFC_HBAPortStatistics_NOSCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_NOSCount_ID 7

    // 
    LONGLONG ErrorFrames;
    #define MSFC_HBAPortStatistics_ErrorFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_ErrorFrames_ID 8

    // 
    LONGLONG DumpedFrames;
    #define MSFC_HBAPortStatistics_DumpedFrames_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_DumpedFrames_ID 9

    // 
    LONGLONG LinkFailureCount;
    #define MSFC_HBAPortStatistics_LinkFailureCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LinkFailureCount_ID 10

    // 
    LONGLONG LossOfSyncCount;
    #define MSFC_HBAPortStatistics_LossOfSyncCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LossOfSyncCount_ID 11

    // 
    LONGLONG LossOfSignalCount;
    #define MSFC_HBAPortStatistics_LossOfSignalCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_LossOfSignalCount_ID 12

    // 
    LONGLONG PrimitiveSeqProtocolErrCount;
    #define MSFC_HBAPortStatistics_PrimitiveSeqProtocolErrCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_PrimitiveSeqProtocolErrCount_ID 13

    // 
    LONGLONG InvalidTxWordCount;
    #define MSFC_HBAPortStatistics_InvalidTxWordCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_InvalidTxWordCount_ID 14

    // 
    LONGLONG InvalidCRCCount;
    #define MSFC_HBAPortStatistics_InvalidCRCCount_SIZE sizeof(LONGLONG)
    #define MSFC_HBAPortStatistics_InvalidCRCCount_ID 15

} MSFC_HBAPortStatistics, *PMSFC_HBAPortStatistics;

#define MSFC_HBAPortStatistics_SIZE (FIELD_OFFSET(MSFC_HBAPortStatistics, InvalidCRCCount) + MSFC_HBAPortStatistics_InvalidCRCCount_SIZE)

// MSFC_FibrePortHBAStatistics - MSFC_FibrePortHBAStatistics
// This class exposes statistical information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAStatisticsGuid \
    { 0x27efaba4,0x362a,0x4f20, { 0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAStatistics_GUID, \
            0x27efaba4,0x362a,0x4f20,0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5);
#endif


typedef struct _MSFC_FibrePortHBAStatistics
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAStatistics_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAStatistics_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAStatistics_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAStatistics_HBAStatus_ID 2

    // 
    MSFC_HBAPortStatistics Statistics;
    #define MSFC_FibrePortHBAStatistics_Statistics_SIZE sizeof(MSFC_HBAPortStatistics)
    #define MSFC_FibrePortHBAStatistics_Statistics_ID 3

} MSFC_FibrePortHBAStatistics, *PMSFC_FibrePortHBAStatistics;

#define MSFC_FibrePortHBAStatistics_SIZE (FIELD_OFFSET(MSFC_FibrePortHBAStatistics, Statistics) + MSFC_FibrePortHBAStatistics_Statistics_SIZE)

// MSFC_HBAPortAttributesResults - MSFC_HBAPortAttributesResults
#define MSFC_HBAPortAttributesResultsGuid \
    { 0xa76bd4e3,0x9961,0x4d9b, { 0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAPortAttributesResults_GUID, \
            0xa76bd4e3,0x9961,0x4d9b,0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68);
#endif


typedef struct _MSFC_HBAPortAttributesResults
{
    // 
    UCHAR NodeWWN[8];
    #define MSFC_HBAPortAttributesResults_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_NodeWWN_ID 1

    // 
    UCHAR PortWWN[8];
    #define MSFC_HBAPortAttributesResults_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_PortWWN_ID 2

    // 
    ULONG PortFcId;
    #define MSFC_HBAPortAttributesResults_PortFcId_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortFcId_ID 3

    // 
    ULONG PortType;
    #define MSFC_HBAPortAttributesResults_PortType_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortType_ID 4

    // 
    ULONG PortState;
    #define MSFC_HBAPortAttributesResults_PortState_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortState_ID 5

    // 
    ULONG PortSupportedClassofService;
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_ID 6

    // 
    UCHAR PortSupportedFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_ID 7

    // 
    UCHAR PortActiveFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_ID 8

    // 
    ULONG PortSupportedSpeed;
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_ID 9

    // 
    ULONG PortSpeed;
    #define MSFC_HBAPortAttributesResults_PortSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSpeed_ID 10

    // 
    ULONG PortMaxFrameSize;
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_ID 11

    // 
    UCHAR FabricName[8];
    #define MSFC_HBAPortAttributesResults_FabricName_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_FabricName_ID 12

    // 
    ULONG NumberofDiscoveredPorts;
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_ID 13

} MSFC_HBAPortAttributesResults, *PMSFC_HBAPortAttributesResults;

#define MSFC_HBAPortAttributesResults_SIZE (FIELD_OFFSET(MSFC_HBAPortAttributesResults, NumberofDiscoveredPorts) + MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE)

// MSFC_FibrePortHBAAttributes - MSFC_FibrePortHBAAttributes
// This class exposes attribute information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAAttributesGuid \
    { 0x61b397fd,0xf5ae,0x4950, { 0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAAttributes_GUID, \
            0x61b397fd,0xf5ae,0x4950,0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6);
#endif


typedef struct _MSFC_FibrePortHBAAttributes
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAAttributes_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAAttributes_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAAttributes_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults Attributes;
    #define MSFC_FibrePortHBAAttributes_Attributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define MSFC_FibrePortHBAAttributes_Attributes_ID 3

} MSFC_FibrePortHBAAttributes, *PMSFC_FibrePortHBAAttributes;

#define MSFC_FibrePortHBAAttributes_SIZE (FIELD_OFFSET(MSFC_FibrePortHBAAttributes, Attributes) + MSFC_FibrePortHBAAttributes_Attributes_SIZE)

// MSFC_FibrePortHBAMethods - MSFC_FibrePortHBAMethods
// This class exposes operations that can be performed on a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAMethodsGuid \
    { 0xe693553e,0xedf6,0x4d57, { 0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FibrePortHBAMethods_GUID, \
            0xe693553e,0xedf6,0x4d57,0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c);
#endif

//
// Method id definitions for MSFC_FibrePortHBAMethods
#define ResetStatistics     1

// MSFC_FCAdapterHBAAttributes - MSFC_FCAdapterHBAAttributes
// This class exposes attribute information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_FCAdapterHBAAttributesGuid \
    { 0xf8f3ea26,0xab2c,0x4593, { 0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FCAdapterHBAAttributes_GUID, \
            0xf8f3ea26,0xab2c,0x4593,0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb);
#endif


typedef struct _MSFC_FCAdapterHBAAttributes
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_ID 2

    // 
    UCHAR NodeWWN[8];
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_ID 3

    // 
    ULONG VendorSpecificID;
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_ID 4

    // 
    ULONG NumberOfPorts;
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_ID 5

    // 
    WCHAR Manufacturer[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_Manufacturer_ID 6

    // 
    WCHAR SerialNumber[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_SerialNumber_ID 7

    // 
    WCHAR Model[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_Model_ID 8

    // 
    WCHAR ModelDescription[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_ModelDescription_ID 9

    // 
    WCHAR NodeSymbolicName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_NodeSymbolicName_ID 10

    // 
    WCHAR HardwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_HardwareVersion_ID 11

    // 
    WCHAR DriverVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverVersion_ID 12

    // 
    WCHAR OptionROMVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_OptionROMVersion_ID 13

    // 
    WCHAR FirmwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_FirmwareVersion_ID 14

    // 
    WCHAR DriverName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverName_ID 15

    // 
    WCHAR MfgDomain[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_MfgDomain_ID 16

} MSFC_FCAdapterHBAAttributes, *PMSFC_FCAdapterHBAAttributes;

// HBAFC3MgmtInfo - HBAFC3MgmtInfo
// This class exposes FC3 Management information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define HBAFC3MgmtInfoGuid \
    { 0x5966a24f,0x6aa5,0x418e, { 0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFC3MgmtInfo_GUID, \
            0x5966a24f,0x6aa5,0x418e,0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18);
#endif


typedef struct _HBAFC3MgmtInfo
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define HBAFC3MgmtInfo_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define HBAFC3MgmtInfo_UniqueAdapterId_ID 1

    // 
    UCHAR wwn[8];
    #define HBAFC3MgmtInfo_wwn_SIZE sizeof(UCHAR[8])
    #define HBAFC3MgmtInfo_wwn_ID 2

    // 
    ULONG unittype;
    #define HBAFC3MgmtInfo_unittype_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_unittype_ID 3

    // 
    ULONG PortId;
    #define HBAFC3MgmtInfo_PortId_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_PortId_ID 4

    // 
    ULONG NumberOfAttachedNodes;
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_ID 5

    // 
    USHORT IPVersion;
    #define HBAFC3MgmtInfo_IPVersion_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_IPVersion_ID 6

    // 
    USHORT UDPPort;
    #define HBAFC3MgmtInfo_UDPPort_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_UDPPort_ID 7

    // 
    UCHAR IPAddress[16];
    #define HBAFC3MgmtInfo_IPAddress_SIZE sizeof(UCHAR[16])
    #define HBAFC3MgmtInfo_IPAddress_ID 8

    // 
    USHORT reserved;
    #define HBAFC3MgmtInfo_reserved_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_reserved_ID 9

    // 
    USHORT TopologyDiscoveryFlags;
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_ID 10

} HBAFC3MgmtInfo, *PHBAFC3MgmtInfo;

#define HBAFC3MgmtInfo_SIZE (FIELD_OFFSET(HBAFC3MgmtInfo, TopologyDiscoveryFlags) + HBAFC3MgmtInfo_TopologyDiscoveryFlags_SIZE)

// HBAScsiID - HBAScsiID
#define HBAScsiIDGuid \
    { 0xa76f5058,0xb1f0,0x4622, { 0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAScsiID_GUID, \
            0xa76f5058,0xb1f0,0x4622,0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a);
#endif


typedef struct _HBAScsiID
{
    // 
    WCHAR OSDeviceName[256 + 1];
    #define HBAScsiID_OSDeviceName_ID 1

    // 
    ULONG ScsiBusNumber;
    #define HBAScsiID_ScsiBusNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiBusNumber_ID 2

    // 
    ULONG ScsiTargetNumber;
    #define HBAScsiID_ScsiTargetNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiTargetNumber_ID 3

    // 
    ULONG ScsiOSLun;
    #define HBAScsiID_ScsiOSLun_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiOSLun_ID 4

} HBAScsiID, *PHBAScsiID;

#define HBAScsiID_SIZE (FIELD_OFFSET(HBAScsiID, ScsiOSLun) + HBAScsiID_ScsiOSLun_SIZE)

// MSFC_FC4STATISTICS - MSFC_FC4STATISTICS
#define MSFC_FC4STATISTICSGuid \
    { 0xca8e7fe6,0xb85e,0x497f, { 0x88,0x58,0x9b,0x5d,0x93,0xa6,0x6f,0xe1 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_FC4STATISTICS_GUID, \
            0xca8e7fe6,0xb85e,0x497f,0x88,0x58,0x9b,0x5d,0x93,0xa6,0x6f,0xe1);
#endif


typedef struct _MSFC_FC4STATISTICS
{
    // 
    ULONGLONG InputRequests;
    #define MSFC_FC4STATISTICS_InputRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_InputRequests_ID 1

    // 
    ULONGLONG OutputRequests;
    #define MSFC_FC4STATISTICS_OutputRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_OutputRequests_ID 2

    // 
    ULONGLONG ControlRequests;
    #define MSFC_FC4STATISTICS_ControlRequests_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_ControlRequests_ID 3

    // 
    ULONGLONG InputMegabytes;
    #define MSFC_FC4STATISTICS_InputMegabytes_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_InputMegabytes_ID 4

    // 
    ULONGLONG OutputMegabytes;
    #define MSFC_FC4STATISTICS_OutputMegabytes_SIZE sizeof(ULONGLONG)
    #define MSFC_FC4STATISTICS_OutputMegabytes_ID 5

} MSFC_FC4STATISTICS, *PMSFC_FC4STATISTICS;

#define MSFC_FC4STATISTICS_SIZE (FIELD_OFFSET(MSFC_FC4STATISTICS, OutputMegabytes) + MSFC_FC4STATISTICS_OutputMegabytes_SIZE)

// MSFC_TM - MSFC_TM
// 
#define MSFC_TMGuid \
    { 0x8cf4c7eb,0xa286,0x409d, { 0x9e,0xb9,0x29,0xd7,0xe0,0xe9,0xf4,0xfa } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_TM_GUID, \
            0x8cf4c7eb,0xa286,0x409d,0x9e,0xb9,0x29,0xd7,0xe0,0xe9,0xf4,0xfa);
#endif


typedef struct _MSFC_TM
{
    // 
    ULONG tm_sec;
    #define MSFC_TM_tm_sec_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_sec_ID 1

    // 
    ULONG tm_min;
    #define MSFC_TM_tm_min_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_min_ID 2

    // 
    ULONG tm_hour;
    #define MSFC_TM_tm_hour_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_hour_ID 3

    // 
    ULONG tm_mday;
    #define MSFC_TM_tm_mday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_mday_ID 4

    // 
    ULONG tm_mon;
    #define MSFC_TM_tm_mon_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_mon_ID 5

    // 
    ULONG tm_year;
    #define MSFC_TM_tm_year_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_year_ID 6

    // 
    ULONG tm_wday;
    #define MSFC_TM_tm_wday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_wday_ID 7

    // 
    ULONG tm_yday;
    #define MSFC_TM_tm_yday_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_yday_ID 8

    // 
    ULONG tm_isdst;
    #define MSFC_TM_tm_isdst_SIZE sizeof(ULONG)
    #define MSFC_TM_tm_isdst_ID 9

} MSFC_TM, *PMSFC_TM;

#define MSFC_TM_SIZE (FIELD_OFFSET(MSFC_TM, tm_isdst) + MSFC_TM_tm_isdst_SIZE)

// MSFC_EventBuffer - MSFC_EventBuffer
// 
#define MSFC_EventBufferGuid \
    { 0x623f4588,0xcf01,0x4f0e, { 0xb1,0x97,0xab,0xbe,0xe5,0xe0,0xcf,0xf3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_EventBuffer_GUID, \
            0x623f4588,0xcf01,0x4f0e,0xb1,0x97,0xab,0xbe,0xe5,0xe0,0xcf,0xf3);
#endif


typedef struct _MSFC_EventBuffer
{
    // 
    ULONG EventType;
    #define MSFC_EventBuffer_EventType_SIZE sizeof(ULONG)
    #define MSFC_EventBuffer_EventType_ID 1

    // 
    ULONG EventInfo[4];
    #define MSFC_EventBuffer_EventInfo_SIZE sizeof(ULONG[4])
    #define MSFC_EventBuffer_EventInfo_ID 2

} MSFC_EventBuffer, *PMSFC_EventBuffer;

#define MSFC_EventBuffer_SIZE (FIELD_OFFSET(MSFC_EventBuffer, EventInfo) + MSFC_EventBuffer_EventInfo_SIZE)

// MSFC_HBAAdapterMethods - MSFC_HBAAdapterMethods
// This class exposes port discovery operations that can be by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAAdapterMethodsGuid \
    { 0xdf87d4ed,0x4612,0x4d12, { 0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAAdapterMethods_GUID, \
            0xdf87d4ed,0x4612,0x4d12,0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c);
#endif

//
// Method id definitions for MSFC_HBAAdapterMethods
#define GetDiscoveredPortAttributes     1
typedef struct _GetDiscoveredPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define GetDiscoveredPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_PortIndex_ID 1

    // 
    ULONG DiscoveredPortIndex;
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_ID 2

} GetDiscoveredPortAttributes_IN, *PGetDiscoveredPortAttributes_IN;

#define GetDiscoveredPortAttributes_IN_SIZE (FIELD_OFFSET(GetDiscoveredPortAttributes_IN, DiscoveredPortIndex) + GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE)

typedef struct _GetDiscoveredPortAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_ID 3

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_ID 4

} GetDiscoveredPortAttributes_OUT, *PGetDiscoveredPortAttributes_OUT;

#define GetDiscoveredPortAttributes_OUT_SIZE (FIELD_OFFSET(GetDiscoveredPortAttributes_OUT, PortAttributes) + GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE)

#define GetPortAttributesByWWN     2
typedef struct _GetPortAttributesByWWN_IN
{
    // 
    UCHAR wwn[8];
    #define GetPortAttributesByWWN_IN_wwn_SIZE sizeof(UCHAR[8])
    #define GetPortAttributesByWWN_IN_wwn_ID 1

} GetPortAttributesByWWN_IN, *PGetPortAttributesByWWN_IN;

#define GetPortAttributesByWWN_IN_SIZE (FIELD_OFFSET(GetPortAttributesByWWN_IN, wwn) + GetPortAttributesByWWN_IN_wwn_SIZE)

typedef struct _GetPortAttributesByWWN_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetPortAttributesByWWN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPortAttributesByWWN_OUT_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetPortAttributesByWWN_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetPortAttributesByWWN_OUT_PortAttributes_ID 3

} GetPortAttributesByWWN_OUT, *PGetPortAttributesByWWN_OUT;

#define GetPortAttributesByWWN_OUT_SIZE (FIELD_OFFSET(GetPortAttributesByWWN_OUT, PortAttributes) + GetPortAttributesByWWN_OUT_PortAttributes_SIZE)

#define RefreshInformation     3
#define SendCTPassThru     4
typedef struct _SendCTPassThru_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendCTPassThru_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendCTPassThru_IN_PortWWN_ID 2

    // 
    ULONG RequestBufferCount;
    #define SendCTPassThru_IN_RequestBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_IN_RequestBufferCount_ID 3

    // 
    UCHAR RequestBuffer[1];
    #define SendCTPassThru_IN_RequestBuffer_ID 4

} SendCTPassThru_IN, *PSendCTPassThru_IN;

typedef struct _SendCTPassThru_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendCTPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_HBAStatus_ID 1

    // 
    ULONG TotalResponseBufferCount;
    #define SendCTPassThru_OUT_TotalResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_TotalResponseBufferCount_ID 5

    // 
    ULONG ActualResponseBufferCount;
    #define SendCTPassThru_OUT_ActualResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_ActualResponseBufferCount_ID 6

    // 
    UCHAR ResponseBuffer[1];
    #define SendCTPassThru_OUT_ResponseBuffer_ID 7

} SendCTPassThru_OUT, *PSendCTPassThru_OUT;

#define SendRNID     5
typedef struct _SendRNID_IN
{
    // 
    UCHAR wwn[8];
    #define SendRNID_IN_wwn_SIZE sizeof(UCHAR[8])
    #define SendRNID_IN_wwn_ID 1

    // 
    ULONG wwntype;
    #define SendRNID_IN_wwntype_SIZE sizeof(ULONG)
    #define SendRNID_IN_wwntype_ID 2

} SendRNID_IN, *PSendRNID_IN;

#define SendRNID_IN_SIZE (FIELD_OFFSET(SendRNID_IN, wwntype) + SendRNID_IN_wwntype_SIZE)

typedef struct _SendRNID_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRNID_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNID_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendRNID_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendRNID_OUT_ResponseBufferCount_ID 4

    // 
    UCHAR ResponseBuffer[1];
    #define SendRNID_OUT_ResponseBuffer_ID 5

} SendRNID_OUT, *PSendRNID_OUT;

#define SendRNIDV2     6
typedef struct _SendRNIDV2_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRNIDV2_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRNIDV2_IN_PortWWN_ID 2

    // 
    UCHAR DestWWN[8];
    #define SendRNIDV2_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendRNIDV2_IN_DestWWN_ID 3

    // 
    ULONG DestFCID;
    #define SendRNIDV2_IN_DestFCID_SIZE sizeof(ULONG)
    #define SendRNIDV2_IN_DestFCID_ID 4

    // 
    ULONG NodeIdDataFormat;
    #define SendRNIDV2_IN_NodeIdDataFormat_SIZE sizeof(ULONG)
    #define SendRNIDV2_IN_NodeIdDataFormat_ID 5

} SendRNIDV2_IN, *PSendRNIDV2_IN;

#define SendRNIDV2_IN_SIZE (FIELD_OFFSET(SendRNIDV2_IN, NodeIdDataFormat) + SendRNIDV2_IN_NodeIdDataFormat_SIZE)

typedef struct _SendRNIDV2_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRNIDV2_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendRNIDV2_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendRNIDV2_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRNIDV2_OUT_ActualRspBufferSize_ID 7

    // 
    UCHAR RspBuffer[1];
    #define SendRNIDV2_OUT_RspBuffer_ID 8

} SendRNIDV2_OUT, *PSendRNIDV2_OUT;

#define GetFC3MgmtInfo     7
typedef struct _GetFC3MgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC3MgmtInfo_OUT_HBAStatus_ID 1

    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define GetFC3MgmtInfo_OUT_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define GetFC3MgmtInfo_OUT_MgmtInfo_ID 2

} GetFC3MgmtInfo_OUT, *PGetFC3MgmtInfo_OUT;

#define GetFC3MgmtInfo_OUT_SIZE (FIELD_OFFSET(GetFC3MgmtInfo_OUT, MgmtInfo) + GetFC3MgmtInfo_OUT_MgmtInfo_SIZE)

#define SetFC3MgmtInfo     8
typedef struct _SetFC3MgmtInfo_IN
{
    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SetFC3MgmtInfo_IN_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SetFC3MgmtInfo_IN_MgmtInfo_ID 2

} SetFC3MgmtInfo_IN, *PSetFC3MgmtInfo_IN;

#define SetFC3MgmtInfo_IN_SIZE (FIELD_OFFSET(SetFC3MgmtInfo_IN, MgmtInfo) + SetFC3MgmtInfo_IN_MgmtInfo_SIZE)

typedef struct _SetFC3MgmtInfo_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetFC3MgmtInfo_OUT_HBAStatus_ID 1

} SetFC3MgmtInfo_OUT, *PSetFC3MgmtInfo_OUT;

#define SetFC3MgmtInfo_OUT_SIZE (FIELD_OFFSET(SetFC3MgmtInfo_OUT, HBAStatus) + SetFC3MgmtInfo_OUT_HBAStatus_SIZE)

#define SendRTIN     9
typedef struct _SendRTIN_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRTIN_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRTIN_IN_PortWWN_ID 2

    // 
    UCHAR AgentWWN[8];
    #define SendRTIN_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SendRTIN_IN_AgentWWN_ID 3

    // 
    UCHAR ObjectWWN[8];
    #define SendRTIN_IN_ObjectWWN_SIZE sizeof(UCHAR[8])
    #define SendRTIN_IN_ObjectWWN_ID 4

    // 
    BOOLEAN WWNIsDomain;
    #define SendRTIN_IN_WWNIsDomain_SIZE sizeof(BOOLEAN)
    #define SendRTIN_IN_WWNIsDomain_ID 5

} SendRTIN_IN, *PSendRTIN_IN;

#define SendRTIN_IN_SIZE (FIELD_OFFSET(SendRTIN_IN, WWNIsDomain) + SendRTIN_IN_WWNIsDomain_SIZE)

typedef struct _SendRTIN_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRTIN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRTIN_OUT_HBAStatus_ID 1

    // 
    ULONG RspBufferSize;
    #define SendRTIN_OUT_RspBufferSize_SIZE sizeof(ULONG)
    #define SendRTIN_OUT_RspBufferSize_ID 6

    // 
    UCHAR RspBuffer[1];
    #define SendRTIN_OUT_RspBuffer_ID 7

} SendRTIN_OUT, *PSendRTIN_OUT;

#define SendRPL     10
typedef struct _SendRPL_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRPL_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRPL_IN_PortWWN_ID 2

    // 
    UCHAR AgentWWN[8];
    #define SendRPL_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SendRPL_IN_AgentWWN_ID 3

    // 
    ULONG agent_domain;
    #define SendRPL_IN_agent_domain_SIZE sizeof(ULONG)
    #define SendRPL_IN_agent_domain_ID 4

    // 
    ULONG portIndex;
    #define SendRPL_IN_portIndex_SIZE sizeof(ULONG)
    #define SendRPL_IN_portIndex_ID 5

} SendRPL_IN, *PSendRPL_IN;

#define SendRPL_IN_SIZE (FIELD_OFFSET(SendRPL_IN, portIndex) + SendRPL_IN_portIndex_SIZE)

typedef struct _SendRPL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRPL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRPL_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendRPL_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPL_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendRPL_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPL_OUT_ActualRspBufferSize_ID 7

    // 
    UCHAR RspBuffer[1];
    #define SendRPL_OUT_RspBuffer_ID 8

} SendRPL_OUT, *PSendRPL_OUT;

#define SendRPS     11
typedef struct _SendRPS_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRPS_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_PortWWN_ID 2

    // 
    UCHAR AgentWWN[8];
    #define SendRPS_IN_AgentWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_AgentWWN_ID 3

    // 
    UCHAR ObjectWWN[8];
    #define SendRPS_IN_ObjectWWN_SIZE sizeof(UCHAR[8])
    #define SendRPS_IN_ObjectWWN_ID 4

    // 
    ULONG AgentDomain;
    #define SendRPS_IN_AgentDomain_SIZE sizeof(ULONG)
    #define SendRPS_IN_AgentDomain_ID 5

    // 
    ULONG ObjectPortNumber;
    #define SendRPS_IN_ObjectPortNumber_SIZE sizeof(ULONG)
    #define SendRPS_IN_ObjectPortNumber_ID 6

} SendRPS_IN, *PSendRPS_IN;

#define SendRPS_IN_SIZE (FIELD_OFFSET(SendRPS_IN, ObjectPortNumber) + SendRPS_IN_ObjectPortNumber_SIZE)

typedef struct _SendRPS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRPS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRPS_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendRPS_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPS_OUT_TotalRspBufferSize_ID 7

    // 
    ULONG ActualRspBufferSize;
    #define SendRPS_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRPS_OUT_ActualRspBufferSize_ID 8

    // 
    UCHAR RspBuffer[1];
    #define SendRPS_OUT_RspBuffer_ID 9

} SendRPS_OUT, *PSendRPS_OUT;

#define SendSRL     12
typedef struct _SendSRL_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendSRL_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendSRL_IN_PortWWN_ID 2

    // 
    UCHAR WWN[8];
    #define SendSRL_IN_WWN_SIZE sizeof(UCHAR[8])
    #define SendSRL_IN_WWN_ID 3

    // 
    ULONG Domain;
    #define SendSRL_IN_Domain_SIZE sizeof(ULONG)
    #define SendSRL_IN_Domain_ID 4

} SendSRL_IN, *PSendSRL_IN;

#define SendSRL_IN_SIZE (FIELD_OFFSET(SendSRL_IN, Domain) + SendSRL_IN_Domain_SIZE)

typedef struct _SendSRL_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendSRL_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendSRL_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendSRL_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendSRL_OUT_TotalRspBufferSize_ID 5

    // 
    ULONG ActualRspBufferSize;
    #define SendSRL_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendSRL_OUT_ActualRspBufferSize_ID 6

    // 
    UCHAR RspBuffer[1];
    #define SendSRL_OUT_RspBuffer_ID 7

} SendSRL_OUT, *PSendSRL_OUT;

#define SendLIRR     13
typedef struct _SendLIRR_IN
{
    // 
    UCHAR SourceWWN[8];
    #define SendLIRR_IN_SourceWWN_SIZE sizeof(UCHAR[8])
    #define SendLIRR_IN_SourceWWN_ID 2

    // 
    UCHAR DestWWN[8];
    #define SendLIRR_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendLIRR_IN_DestWWN_ID 3

    // 
    UCHAR Function;
    #define SendLIRR_IN_Function_SIZE sizeof(UCHAR)
    #define SendLIRR_IN_Function_ID 4

    // 
    UCHAR Type;
    #define SendLIRR_IN_Type_SIZE sizeof(UCHAR)
    #define SendLIRR_IN_Type_ID 5

} SendLIRR_IN, *PSendLIRR_IN;

#define SendLIRR_IN_SIZE (FIELD_OFFSET(SendLIRR_IN, Type) + SendLIRR_IN_Type_SIZE)

typedef struct _SendLIRR_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendLIRR_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendLIRR_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_TotalRspBufferSize_ID 6

    // 
    ULONG ActualRspBufferSize;
    #define SendLIRR_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendLIRR_OUT_ActualRspBufferSize_ID 7

    // 
    UCHAR RspBuffer[1];
    #define SendLIRR_OUT_RspBuffer_ID 8

} SendLIRR_OUT, *PSendLIRR_OUT;

#define GetFC4Statistics     14
typedef struct _GetFC4Statistics_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetFC4Statistics_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetFC4Statistics_IN_PortWWN_ID 2

    // 
    UCHAR FC4Type;
    #define GetFC4Statistics_IN_FC4Type_SIZE sizeof(UCHAR)
    #define GetFC4Statistics_IN_FC4Type_ID 3

} GetFC4Statistics_IN, *PGetFC4Statistics_IN;

#define GetFC4Statistics_IN_SIZE (FIELD_OFFSET(GetFC4Statistics_IN, FC4Type) + GetFC4Statistics_IN_FC4Type_SIZE)

typedef struct _GetFC4Statistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFC4Statistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC4Statistics_OUT_HBAStatus_ID 1

    // 
    MSFC_FC4STATISTICS FC4Statistics;
    #define GetFC4Statistics_OUT_FC4Statistics_SIZE sizeof(MSFC_FC4STATISTICS)
    #define GetFC4Statistics_OUT_FC4Statistics_ID 4

} GetFC4Statistics_OUT, *PGetFC4Statistics_OUT;

#define GetFC4Statistics_OUT_SIZE (FIELD_OFFSET(GetFC4Statistics_OUT, FC4Statistics) + GetFC4Statistics_OUT_FC4Statistics_SIZE)

#define GetFCPStatistics     15
typedef struct _GetFCPStatistics_IN
{
    // 
    HBAScsiID ScsiId;
    #define GetFCPStatistics_IN_ScsiId_SIZE sizeof(HBAScsiID)
    #define GetFCPStatistics_IN_ScsiId_ID 2

} GetFCPStatistics_IN, *PGetFCPStatistics_IN;

#define GetFCPStatistics_IN_SIZE (FIELD_OFFSET(GetFCPStatistics_IN, ScsiId) + GetFCPStatistics_IN_ScsiId_SIZE)

typedef struct _GetFCPStatistics_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFCPStatistics_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFCPStatistics_OUT_HBAStatus_ID 1

    // 
    MSFC_FC4STATISTICS FC4Statistics;
    #define GetFCPStatistics_OUT_FC4Statistics_SIZE sizeof(MSFC_FC4STATISTICS)
    #define GetFCPStatistics_OUT_FC4Statistics_ID 3

} GetFCPStatistics_OUT, *PGetFCPStatistics_OUT;

#define GetFCPStatistics_OUT_SIZE (FIELD_OFFSET(GetFCPStatistics_OUT, FC4Statistics) + GetFCPStatistics_OUT_FC4Statistics_SIZE)

#define ScsiInquiry     16
typedef struct _ScsiInquiry_IN
{
    // 
    UCHAR Cdb[6];
    #define ScsiInquiry_IN_Cdb_SIZE sizeof(UCHAR[6])
    #define ScsiInquiry_IN_Cdb_ID 2

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiInquiry_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiInquiry_IN_HbaPortWWN_ID 3

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiInquiry_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiInquiry_IN_DiscoveredPortWWN_ID 4

    // 
    ULONGLONG FcLun;
    #define ScsiInquiry_IN_FcLun_SIZE sizeof(ULONGLONG)
    #define ScsiInquiry_IN_FcLun_ID 5

} ScsiInquiry_IN, *PScsiInquiry_IN;

#define ScsiInquiry_IN_SIZE (FIELD_OFFSET(ScsiInquiry_IN, FcLun) + ScsiInquiry_IN_FcLun_SIZE)

typedef struct _ScsiInquiry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiInquiry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_HBAStatus_ID 1

    // 
    ULONG ResponseBufferSize;
    #define ScsiInquiry_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_ResponseBufferSize_ID 6

    // 
    ULONG SenseBufferSize;
    #define ScsiInquiry_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiInquiry_OUT_SenseBufferSize_ID 7

    // 
    UCHAR ScsiStatus;
    #define ScsiInquiry_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiInquiry_OUT_ScsiStatus_ID 8

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiInquiry_OUT_ResponseBuffer_ID 9

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiInquiry_OUT_SenseBuffer_ID 10

} ScsiInquiry_OUT, *PScsiInquiry_OUT;

#define ScsiReadCapacity     17
typedef struct _ScsiReadCapacity_IN
{
    // 
    UCHAR Cdb[10];
    #define ScsiReadCapacity_IN_Cdb_SIZE sizeof(UCHAR[10])
    #define ScsiReadCapacity_IN_Cdb_ID 2

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiReadCapacity_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReadCapacity_IN_HbaPortWWN_ID 3

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiReadCapacity_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReadCapacity_IN_DiscoveredPortWWN_ID 4

    // 
    ULONGLONG FcLun;
    #define ScsiReadCapacity_IN_FcLun_SIZE sizeof(ULONGLONG)
    #define ScsiReadCapacity_IN_FcLun_ID 5

} ScsiReadCapacity_IN, *PScsiReadCapacity_IN;

#define ScsiReadCapacity_IN_SIZE (FIELD_OFFSET(ScsiReadCapacity_IN, FcLun) + ScsiReadCapacity_IN_FcLun_SIZE)

typedef struct _ScsiReadCapacity_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiReadCapacity_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_HBAStatus_ID 1

    // 
    ULONG ResponseBufferSize;
    #define ScsiReadCapacity_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_ResponseBufferSize_ID 6

    // 
    ULONG SenseBufferSize;
    #define ScsiReadCapacity_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReadCapacity_OUT_SenseBufferSize_ID 7

    // 
    UCHAR ScsiStatus;
    #define ScsiReadCapacity_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReadCapacity_OUT_ScsiStatus_ID 8

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiReadCapacity_OUT_ResponseBuffer_ID 9

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiReadCapacity_OUT_SenseBuffer_ID 10

} ScsiReadCapacity_OUT, *PScsiReadCapacity_OUT;

#define ScsiReportLuns     18
typedef struct _ScsiReportLuns_IN
{
    // 
    UCHAR Cdb[12];
    #define ScsiReportLuns_IN_Cdb_SIZE sizeof(UCHAR[12])
    #define ScsiReportLuns_IN_Cdb_ID 2

    // 
    UCHAR HbaPortWWN[8];
    #define ScsiReportLuns_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReportLuns_IN_HbaPortWWN_ID 3

    // 
    UCHAR DiscoveredPortWWN[8];
    #define ScsiReportLuns_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define ScsiReportLuns_IN_DiscoveredPortWWN_ID 4

} ScsiReportLuns_IN, *PScsiReportLuns_IN;

#define ScsiReportLuns_IN_SIZE (FIELD_OFFSET(ScsiReportLuns_IN, DiscoveredPortWWN) + ScsiReportLuns_IN_DiscoveredPortWWN_SIZE)

typedef struct _ScsiReportLuns_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define ScsiReportLuns_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_HBAStatus_ID 1

    // 
    ULONG ResponseBufferSize;
    #define ScsiReportLuns_OUT_ResponseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_ResponseBufferSize_ID 5

    // 
    ULONG SenseBufferSize;
    #define ScsiReportLuns_OUT_SenseBufferSize_SIZE sizeof(ULONG)
    #define ScsiReportLuns_OUT_SenseBufferSize_ID 6

    // 
    UCHAR ScsiStatus;
    #define ScsiReportLuns_OUT_ScsiStatus_SIZE sizeof(UCHAR)
    #define ScsiReportLuns_OUT_ScsiStatus_ID 7

    // 
    UCHAR ResponseBuffer[1];
    #define ScsiReportLuns_OUT_ResponseBuffer_ID 8

    // 
//  UCHAR SenseBuffer[1];
    #define ScsiReportLuns_OUT_SenseBuffer_ID 9

} ScsiReportLuns_OUT, *PScsiReportLuns_OUT;

#define GetVendorLibraryAttributes     19
typedef struct _GetVendorLibraryAttributes_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetVendorLibraryAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetVendorLibraryAttributes_OUT_HBAStatus_ID 1

    // 
    ULONG HbaVersion;
    #define GetVendorLibraryAttributes_OUT_HbaVersion_SIZE sizeof(ULONG)
    #define GetVendorLibraryAttributes_OUT_HbaVersion_ID 2

    // Is Final
    BOOLEAN Final;
    #define GetVendorLibraryAttributes_OUT_Final_SIZE sizeof(BOOLEAN)
    #define GetVendorLibraryAttributes_OUT_Final_ID 3

    // LibPath
    WCHAR LibPath[256 + 1];
    #define GetVendorLibraryAttributes_OUT_LibPath_ID 4

    // Vendor Name
    WCHAR VName[256 + 1];
    #define GetVendorLibraryAttributes_OUT_VName_ID 5

    // Vendor Version
    WCHAR VVersion[256 + 1];
    #define GetVendorLibraryAttributes_OUT_VVersion_ID 6

    // Build date
    MSFC_TM tm;
    #define GetVendorLibraryAttributes_OUT_tm_SIZE sizeof(MSFC_TM)
    #define GetVendorLibraryAttributes_OUT_tm_ID 7

} GetVendorLibraryAttributes_OUT, *PGetVendorLibraryAttributes_OUT;

#define GetVendorLibraryAttributes_OUT_SIZE (FIELD_OFFSET(GetVendorLibraryAttributes_OUT, tm) + GetVendorLibraryAttributes_OUT_tm_SIZE)

#define GetEventBuffer     20
typedef struct _GetEventBuffer_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetEventBuffer_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetEventBuffer_OUT_HBAStatus_ID 1

    // 
    ULONG EventCount;
    #define GetEventBuffer_OUT_EventCount_SIZE sizeof(ULONG)
    #define GetEventBuffer_OUT_EventCount_ID 2

    // 
    MSFC_EventBuffer Events[1];
    #define GetEventBuffer_OUT_Events_ID 3

} GetEventBuffer_OUT, *PGetEventBuffer_OUT;

#define SendRLS     21
typedef struct _SendRLS_IN
{
    // 
    UCHAR PortWWN[8];
    #define SendRLS_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SendRLS_IN_PortWWN_ID 2

    // 
    UCHAR DestWWN[8];
    #define SendRLS_IN_DestWWN_SIZE sizeof(UCHAR[8])
    #define SendRLS_IN_DestWWN_ID 3

} SendRLS_IN, *PSendRLS_IN;

#define SendRLS_IN_SIZE (FIELD_OFFSET(SendRLS_IN, DestWWN) + SendRLS_IN_DestWWN_SIZE)

typedef struct _SendRLS_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SendRLS_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRLS_OUT_HBAStatus_ID 1

    // 
    ULONG TotalRspBufferSize;
    #define SendRLS_OUT_TotalRspBufferSize_SIZE sizeof(ULONG)
    #define SendRLS_OUT_TotalRspBufferSize_ID 4

    // 
    ULONG ActualRspBufferSize;
    #define SendRLS_OUT_ActualRspBufferSize_SIZE sizeof(ULONG)
    #define SendRLS_OUT_ActualRspBufferSize_ID 5

    // 
    UCHAR RspBuffer[1];
    #define SendRLS_OUT_RspBuffer_ID 6

} SendRLS_OUT, *PSendRLS_OUT;


// HBAFCPID - HBAFCPID
#define HBAFCPIDGuid \
    { 0xff02bc96,0x7fb0,0x4bac, { 0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPID_GUID, \
            0xff02bc96,0x7fb0,0x4bac,0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98);
#endif


typedef struct _HBAFCPID
{
    // 
    ULONG Fcid;
    #define HBAFCPID_Fcid_SIZE sizeof(ULONG)
    #define HBAFCPID_Fcid_ID 1

    // 
    UCHAR NodeWWN[8];
    #define HBAFCPID_NodeWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_NodeWWN_ID 2

    // 
    UCHAR PortWWN[8];
    #define HBAFCPID_PortWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_PortWWN_ID 3

    // 
    ULONGLONG FcpLun;
    #define HBAFCPID_FcpLun_SIZE sizeof(ULONGLONG)
    #define HBAFCPID_FcpLun_ID 4

} HBAFCPID, *PHBAFCPID;

#define HBAFCPID_SIZE (FIELD_OFFSET(HBAFCPID, FcpLun) + HBAFCPID_FcpLun_SIZE)

// HBAFCPScsiEntry - HBAFCPScsiEntry
#define HBAFCPScsiEntryGuid \
    { 0x77ca1248,0x1505,0x4221, { 0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPScsiEntry_GUID, \
            0x77ca1248,0x1505,0x4221,0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87);
#endif


typedef struct _HBAFCPScsiEntry
{
    // 
    HBAScsiID ScsiId;
    #define HBAFCPScsiEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPScsiEntry_ScsiId_ID 1

    // 
    HBAFCPID FCPId;
    #define HBAFCPScsiEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPScsiEntry_FCPId_ID 2

    // 
    UCHAR Luid[256];
    #define HBAFCPScsiEntry_Luid_SIZE sizeof(UCHAR[256])
    #define HBAFCPScsiEntry_Luid_ID 3

} HBAFCPScsiEntry, *PHBAFCPScsiEntry;

#define HBAFCPScsiEntry_SIZE (FIELD_OFFSET(HBAFCPScsiEntry, Luid) + HBAFCPScsiEntry_Luid_SIZE)

// HBAFCPBindingEntry - HBAFCPBindingEntry
#define HBAFCPBindingEntryGuid \
    { 0xfceff8b7,0x9d6b,0x4115, { 0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPBindingEntry_GUID, \
            0xfceff8b7,0x9d6b,0x4115,0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29);
#endif


typedef struct _HBAFCPBindingEntry
{
    // 
    ULONG Type;
    #define HBAFCPBindingEntry_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry_Type_ID 1

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry_ScsiId_ID 2

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry_FCPId_ID 3

} HBAFCPBindingEntry, *PHBAFCPBindingEntry;

#define HBAFCPBindingEntry_SIZE (FIELD_OFFSET(HBAFCPBindingEntry, FCPId) + HBAFCPBindingEntry_FCPId_SIZE)

// HBAFCPBindingEntry2 - HBAFCPBindingEntry2
#define HBAFCPBindingEntry2Guid \
    { 0x3a1e7679,0x4b1f,0x4f31, { 0xa8,0xae,0xfe,0x92,0x78,0x73,0x09,0x24 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(HBAFCPBindingEntry2_GUID, \
            0x3a1e7679,0x4b1f,0x4f31,0xa8,0xae,0xfe,0x92,0x78,0x73,0x09,0x24);
#endif


typedef struct _HBAFCPBindingEntry2
{
    // Ways of performing persistent binding
    ULONG Type;
    #define HBAFCPBindingEntry2_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry2_Type_ID 1

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry2_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry2_ScsiId_ID 2

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry2_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry2_FCPId_ID 3

    // 
    UCHAR Luid[256];
    #define HBAFCPBindingEntry2_Luid_SIZE sizeof(UCHAR[256])
    #define HBAFCPBindingEntry2_Luid_ID 4

} HBAFCPBindingEntry2, *PHBAFCPBindingEntry2;

#define HBAFCPBindingEntry2_SIZE (FIELD_OFFSET(HBAFCPBindingEntry2, Luid) + HBAFCPBindingEntry2_Luid_SIZE)

// MSFC_HBAFCPInfo - MSFC_HBAFCPInfo
// This class exposes operations associated with FCP on a Fibre Channel adapter. There should be one instance of this class for each adapter.
#define MSFC_HBAFCPInfoGuid \
    { 0x7a1fc391,0x5b23,0x4c19, { 0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_HBAFCPInfo_GUID, \
            0x7a1fc391,0x5b23,0x4c19,0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3);
#endif

//
// Method id definitions for MSFC_HBAFCPInfo
#define GetFcpTargetMapping     1
typedef struct _GetFcpTargetMapping_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define GetFcpTargetMapping_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define GetFcpTargetMapping_IN_HbaPortWWN_ID 2

    // 
    ULONG TotalEntryCount;
    #define GetFcpTargetMapping_IN_TotalEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_IN_TotalEntryCount_ID 3

} GetFcpTargetMapping_IN, *PGetFcpTargetMapping_IN;

#define GetFcpTargetMapping_IN_SIZE (FIELD_OFFSET(GetFcpTargetMapping_IN, TotalEntryCount) + GetFcpTargetMapping_IN_TotalEntryCount_SIZE)

typedef struct _GetFcpTargetMapping_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFcpTargetMapping_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_HBAStatus_ID 1

    // 
    ULONG TotalEntryCount;
    #define GetFcpTargetMapping_OUT_TotalEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_TotalEntryCount_ID 3

    // 
    ULONG ActualEntryCount;
    #define GetFcpTargetMapping_OUT_ActualEntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_ActualEntryCount_ID 4

    // 
    HBAFCPScsiEntry Entry[1];
    #define GetFcpTargetMapping_OUT_Entry_ID 5

} GetFcpTargetMapping_OUT, *PGetFcpTargetMapping_OUT;

#define GetFcpPersistentBinding     2
typedef struct _GetFcpPersistentBinding_IN
{
    // 
    ULONG EntryCount;
    #define GetFcpPersistentBinding_IN_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_IN_EntryCount_ID 2

} GetFcpPersistentBinding_IN, *PGetFcpPersistentBinding_IN;

#define GetFcpPersistentBinding_IN_SIZE (FIELD_OFFSET(GetFcpPersistentBinding_IN, EntryCount) + GetFcpPersistentBinding_IN_EntryCount_SIZE)

typedef struct _GetFcpPersistentBinding_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetFcpPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetFcpPersistentBinding_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_EntryCount_ID 2

    // 
    HBAFCPBindingEntry Entry[1];
    #define GetFcpPersistentBinding_OUT_Entry_ID 3

} GetFcpPersistentBinding_OUT, *PGetFcpPersistentBinding_OUT;

#define GetBindingCapability     3
typedef struct _GetBindingCapability_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetBindingCapability_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetBindingCapability_IN_PortWWN_ID 2

} GetBindingCapability_IN, *PGetBindingCapability_IN;

#define GetBindingCapability_IN_SIZE (FIELD_OFFSET(GetBindingCapability_IN, PortWWN) + GetBindingCapability_IN_PortWWN_SIZE)

typedef struct _GetBindingCapability_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetBindingCapability_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetBindingCapability_OUT_HBAStatus_ID 1

    // Ways of performing persistent binding
    ULONG BindType;
    #define GetBindingCapability_OUT_BindType_SIZE sizeof(ULONG)
    #define GetBindingCapability_OUT_BindType_ID 3

} GetBindingCapability_OUT, *PGetBindingCapability_OUT;

#define GetBindingCapability_OUT_SIZE (FIELD_OFFSET(GetBindingCapability_OUT, BindType) + GetBindingCapability_OUT_BindType_SIZE)

#define GetBindingSupport     4
typedef struct _GetBindingSupport_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetBindingSupport_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetBindingSupport_IN_PortWWN_ID 2

} GetBindingSupport_IN, *PGetBindingSupport_IN;

#define GetBindingSupport_IN_SIZE (FIELD_OFFSET(GetBindingSupport_IN, PortWWN) + GetBindingSupport_IN_PortWWN_SIZE)

typedef struct _GetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetBindingSupport_OUT_HBAStatus_ID 1

    // Ways of performing persistent binding
    ULONG BindType;
    #define GetBindingSupport_OUT_BindType_SIZE sizeof(ULONG)
    #define GetBindingSupport_OUT_BindType_ID 3

} GetBindingSupport_OUT, *PGetBindingSupport_OUT;

#define GetBindingSupport_OUT_SIZE (FIELD_OFFSET(GetBindingSupport_OUT, BindType) + GetBindingSupport_OUT_BindType_SIZE)

#define SetBindingSupport     5
typedef struct _SetBindingSupport_IN
{
    // 
    UCHAR PortWWN[8];
    #define SetBindingSupport_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SetBindingSupport_IN_PortWWN_ID 2

    // Ways of performing persistent binding
    ULONG BindType;
    #define SetBindingSupport_IN_BindType_SIZE sizeof(ULONG)
    #define SetBindingSupport_IN_BindType_ID 3

} SetBindingSupport_IN, *PSetBindingSupport_IN;

#define SetBindingSupport_IN_SIZE (FIELD_OFFSET(SetBindingSupport_IN, BindType) + SetBindingSupport_IN_BindType_SIZE)

typedef struct _SetBindingSupport_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetBindingSupport_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetBindingSupport_OUT_HBAStatus_ID 1

} SetBindingSupport_OUT, *PSetBindingSupport_OUT;

#define SetBindingSupport_OUT_SIZE (FIELD_OFFSET(SetBindingSupport_OUT, HBAStatus) + SetBindingSupport_OUT_HBAStatus_SIZE)

#define SetPersistentBinding2     6
typedef struct _SetPersistentBinding2_IN
{
    // 
    UCHAR PortWWN[8];
    #define SetPersistentBinding2_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define SetPersistentBinding2_IN_PortWWN_ID 2

    // 
    ULONG EntryCount;
    #define SetPersistentBinding2_IN_EntryCount_SIZE sizeof(ULONG)
    #define SetPersistentBinding2_IN_EntryCount_ID 3

    // 
    HBAFCPBindingEntry2 Bindings[1];
    #define SetPersistentBinding2_IN_Bindings_ID 4

} SetPersistentBinding2_IN, *PSetPersistentBinding2_IN;

typedef struct _SetPersistentBinding2_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetPersistentBinding2_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetPersistentBinding2_OUT_HBAStatus_ID 1

} SetPersistentBinding2_OUT, *PSetPersistentBinding2_OUT;

#define SetPersistentBinding2_OUT_SIZE (FIELD_OFFSET(SetPersistentBinding2_OUT, HBAStatus) + SetPersistentBinding2_OUT_HBAStatus_SIZE)

#define GetPersistentBinding2     7
typedef struct _GetPersistentBinding2_IN
{
    // 
    UCHAR PortWWN[8];
    #define GetPersistentBinding2_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define GetPersistentBinding2_IN_PortWWN_ID 2

    // 
    ULONG EntryCount;
    #define GetPersistentBinding2_IN_EntryCount_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_IN_EntryCount_ID 3

} GetPersistentBinding2_IN, *PGetPersistentBinding2_IN;

#define GetPersistentBinding2_IN_SIZE (FIELD_OFFSET(GetPersistentBinding2_IN, EntryCount) + GetPersistentBinding2_IN_EntryCount_SIZE)

typedef struct _GetPersistentBinding2_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define GetPersistentBinding2_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetPersistentBinding2_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetPersistentBinding2_OUT_EntryCount_ID 3

    // 
    HBAFCPBindingEntry2 Bindings[1];
    #define GetPersistentBinding2_OUT_Bindings_ID 4

} GetPersistentBinding2_OUT, *PGetPersistentBinding2_OUT;

#define SetPersistentEntry     8
typedef struct _SetPersistentEntry_IN
{
    // 
    HBAFCPBindingEntry2 Binding;
    #define SetPersistentEntry_IN_Binding_SIZE sizeof(HBAFCPBindingEntry2)
    #define SetPersistentEntry_IN_Binding_ID 2

} SetPersistentEntry_IN, *PSetPersistentEntry_IN;

#define SetPersistentEntry_IN_SIZE (FIELD_OFFSET(SetPersistentEntry_IN, Binding) + SetPersistentEntry_IN_Binding_SIZE)

typedef struct _SetPersistentEntry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define SetPersistentEntry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetPersistentEntry_OUT_HBAStatus_ID 1

} SetPersistentEntry_OUT, *PSetPersistentEntry_OUT;

#define SetPersistentEntry_OUT_SIZE (FIELD_OFFSET(SetPersistentEntry_OUT, HBAStatus) + SetPersistentEntry_OUT_HBAStatus_SIZE)

#define RemovePersistentEntry     9
typedef struct _RemovePersistentEntry_IN
{
    // 
    HBAFCPBindingEntry2 Binding;
    #define RemovePersistentEntry_IN_Binding_SIZE sizeof(HBAFCPBindingEntry2)
    #define RemovePersistentEntry_IN_Binding_ID 2

} RemovePersistentEntry_IN, *PRemovePersistentEntry_IN;

#define RemovePersistentEntry_IN_SIZE (FIELD_OFFSET(RemovePersistentEntry_IN, Binding) + RemovePersistentEntry_IN_Binding_SIZE)

typedef struct _RemovePersistentEntry_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemovePersistentEntry_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemovePersistentEntry_OUT_HBAStatus_ID 1

} RemovePersistentEntry_OUT, *PRemovePersistentEntry_OUT;

#define RemovePersistentEntry_OUT_SIZE (FIELD_OFFSET(RemovePersistentEntry_OUT, HBAStatus) + RemovePersistentEntry_OUT_HBAStatus_SIZE)


// MSFC_AdapterEvent - MSFC_AdapterEvent
// This class surfaces HBA adapter events




//
// Event types. These match the definitions in hbaapi.h and must be kept in sync
//
	/* Adapter Level Events */
#define HBA_EVENT_ADAPTER_UNKNOWN	0x100
#define HBA_EVENT_ADAPTER_ADD		0x101
#define HBA_EVENT_ADAPTER_REMOVE	0x102
#define HBA_EVENT_ADAPTER_CHANGE	0x103

	/* Port Level Events */
#define HBA_EVENT_PORT_UNKNOWN		0x200
#define HBA_EVENT_PORT_OFFLINE		0x201
#define HBA_EVENT_PORT_ONLINE		0x202
#define HBA_EVENT_PORT_NEW_TARGETS	0x203
#define HBA_EVENT_PORT_FABRIC		0x204
	
	/* Port Statistics Events */
#define HBA_EVENT_PORT_STAT_THRESHOLD	0x301
#define HBA_EVENT_PORT_STAT_GROWTH	0x302

	/* Target Level Events */
#define HBA_EVENT_TARGET_UNKNOWN	0x400
#define HBA_EVENT_TARGET_OFFLINE	0x401
#define HBA_EVENT_TARGET_ONLINE		0x402
#define HBA_EVENT_TARGET_REMOVED	0x403

	/* Fabric Link  Events */
#define HBA_EVENT_LINK_UNKNOWN		0x500
#define HBA_EVENT_LINK_INCIDENT		0x501

#define MSFC_AdapterEventGuid \
    { 0xe9e47403,0xd1d7,0x43f8, { 0x8e,0xe3,0x53,0xcd,0xbf,0xff,0x56,0x46 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_AdapterEvent_GUID, \
            0xe9e47403,0xd1d7,0x43f8,0x8e,0xe3,0x53,0xcd,0xbf,0xff,0x56,0x46);
#endif


typedef struct _MSFC_AdapterEvent
{
    // Event Type
    ULONG EventType;
    #define MSFC_AdapterEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_AdapterEvent_EventType_ID 1

    // Adapter WWN
    UCHAR PortWWN[8];
    #define MSFC_AdapterEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_AdapterEvent_PortWWN_ID 2

} MSFC_AdapterEvent, *PMSFC_AdapterEvent;

#define MSFC_AdapterEvent_SIZE (FIELD_OFFSET(MSFC_AdapterEvent, PortWWN) + MSFC_AdapterEvent_PortWWN_SIZE)

// MSFC_PortEvent - MSFC_PortEvent
// This class surfaces HBA port events
#define MSFC_PortEventGuid \
    { 0x095fbe97,0x3876,0x48ef, { 0x8a,0x04,0x1c,0x55,0x93,0x5d,0x0d,0xf5 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_PortEvent_GUID, \
            0x095fbe97,0x3876,0x48ef,0x8a,0x04,0x1c,0x55,0x93,0x5d,0x0d,0xf5);
#endif


typedef struct _MSFC_PortEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_PortEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_PortEvent_EventType_ID 1

    // Fabric port id
    ULONG FabricPortId;
    #define MSFC_PortEvent_FabricPortId_SIZE sizeof(ULONG)
    #define MSFC_PortEvent_FabricPortId_ID 2

    // Port WWN
    UCHAR PortWWN[8];
    #define MSFC_PortEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_PortEvent_PortWWN_ID 3

} MSFC_PortEvent, *PMSFC_PortEvent;

#define MSFC_PortEvent_SIZE (FIELD_OFFSET(MSFC_PortEvent, PortWWN) + MSFC_PortEvent_PortWWN_SIZE)

// MSFC_TargetEvent - MSFC_TargetEvent
// This class surfaces HBA target events
#define MSFC_TargetEventGuid \
    { 0xcfa6ef26,0x8675,0x4e27, { 0x9a,0x0b,0xb4,0xa8,0x60,0xdd,0xd0,0xf3 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_TargetEvent_GUID, \
            0xcfa6ef26,0x8675,0x4e27,0x9a,0x0b,0xb4,0xa8,0x60,0xdd,0xd0,0xf3);
#endif


typedef struct _MSFC_TargetEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_TargetEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_TargetEvent_EventType_ID 1

    // Port WWN
    UCHAR PortWWN[8];
    #define MSFC_TargetEvent_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_TargetEvent_PortWWN_ID 2

    // Discovered Port WWN
    UCHAR DiscoveredPortWWN[8];
    #define MSFC_TargetEvent_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_TargetEvent_DiscoveredPortWWN_ID 3

} MSFC_TargetEvent, *PMSFC_TargetEvent;

#define MSFC_TargetEvent_SIZE (FIELD_OFFSET(MSFC_TargetEvent, DiscoveredPortWWN) + MSFC_TargetEvent_DiscoveredPortWWN_SIZE)

// MSFC_LinkEvent - MSFC_LinkEvent
// This class surfaces HBA link events
#define MSFC_LinkEventGuid \
    { 0xc66015ee,0x014b,0x498a, { 0x94,0x51,0x99,0xfe,0xad,0x0a,0xb4,0x51 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_LinkEvent_GUID, \
            0xc66015ee,0x014b,0x498a,0x94,0x51,0x99,0xfe,0xad,0x0a,0xb4,0x51);
#endif


typedef struct _MSFC_LinkEvent
{
    // Type of event
    ULONG EventType;
    #define MSFC_LinkEvent_EventType_SIZE sizeof(ULONG)
    #define MSFC_LinkEvent_EventType_ID 1

    // Discovered Port WWN
    UCHAR AdapterWWN[8];
    #define MSFC_LinkEvent_AdapterWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_LinkEvent_AdapterWWN_ID 2

    // Size of RLIR buffer
    ULONG RLIRBufferSize;
    #define MSFC_LinkEvent_RLIRBufferSize_SIZE sizeof(ULONG)
    #define MSFC_LinkEvent_RLIRBufferSize_ID 3

    // Size of RLIR buffer
    UCHAR RLIRBuffer[1];
    #define MSFC_LinkEvent_RLIRBuffer_ID 4

} MSFC_LinkEvent, *PMSFC_LinkEvent;

// MSFC_EventControl - MSFC_EventControl
// This class defines the port statistics thresholds that will cause a HBA_EVENT_PORT_STAT_THRESHOLD event to occur
#define MSFC_EventControlGuid \
    { 0xa251ccb3,0x5ab0,0x411b, { 0x87,0x71,0x54,0x30,0xef,0x53,0xa2,0x6c } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(MSFC_EventControl_GUID, \
            0xa251ccb3,0x5ab0,0x411b,0x87,0x71,0x54,0x30,0xef,0x53,0xa2,0x6c);
#endif

//
// Method id definitions for MSFC_EventControl
#define AddTarget     10
typedef struct _AddTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define AddTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define AddTarget_IN_HbaPortWWN_ID 2

    // 
    UCHAR DiscoveredPortWWN[8];
    #define AddTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define AddTarget_IN_DiscoveredPortWWN_ID 3

    // 
    ULONG AllTargets;
    #define AddTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define AddTarget_IN_AllTargets_ID 4

} AddTarget_IN, *PAddTarget_IN;

#define AddTarget_IN_SIZE (FIELD_OFFSET(AddTarget_IN, AllTargets) + AddTarget_IN_AllTargets_SIZE)

typedef struct _AddTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddTarget_OUT_HBAStatus_ID 1

} AddTarget_OUT, *PAddTarget_OUT;

#define AddTarget_OUT_SIZE (FIELD_OFFSET(AddTarget_OUT, HBAStatus) + AddTarget_OUT_HBAStatus_SIZE)

#define RemoveTarget     11
typedef struct _RemoveTarget_IN
{
    // 
    UCHAR HbaPortWWN[8];
    #define RemoveTarget_IN_HbaPortWWN_SIZE sizeof(UCHAR[8])
    #define RemoveTarget_IN_HbaPortWWN_ID 2

    // 
    UCHAR DiscoveredPortWWN[8];
    #define RemoveTarget_IN_DiscoveredPortWWN_SIZE sizeof(UCHAR[8])
    #define RemoveTarget_IN_DiscoveredPortWWN_ID 3

    // 
    ULONG AllTargets;
    #define RemoveTarget_IN_AllTargets_SIZE sizeof(ULONG)
    #define RemoveTarget_IN_AllTargets_ID 4

} RemoveTarget_IN, *PRemoveTarget_IN;

#define RemoveTarget_IN_SIZE (FIELD_OFFSET(RemoveTarget_IN, AllTargets) + RemoveTarget_IN_AllTargets_SIZE)

typedef struct _RemoveTarget_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemoveTarget_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemoveTarget_OUT_HBAStatus_ID 1

} RemoveTarget_OUT, *PRemoveTarget_OUT;

#define RemoveTarget_OUT_SIZE (FIELD_OFFSET(RemoveTarget_OUT, HBAStatus) + RemoveTarget_OUT_HBAStatus_SIZE)

#define AddPort     20
typedef struct _AddPort_IN
{
    // 
    UCHAR PortWWN[8];
    #define AddPort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define AddPort_IN_PortWWN_ID 2

} AddPort_IN, *PAddPort_IN;

#define AddPort_IN_SIZE (FIELD_OFFSET(AddPort_IN, PortWWN) + AddPort_IN_PortWWN_SIZE)

typedef struct _AddPort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddPort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddPort_OUT_HBAStatus_ID 1

} AddPort_OUT, *PAddPort_OUT;

#define AddPort_OUT_SIZE (FIELD_OFFSET(AddPort_OUT, HBAStatus) + AddPort_OUT_HBAStatus_SIZE)

#define RemovePort     21
typedef struct _RemovePort_IN
{
    // 
    UCHAR PortWWN[8];
    #define RemovePort_IN_PortWWN_SIZE sizeof(UCHAR[8])
    #define RemovePort_IN_PortWWN_ID 2

} RemovePort_IN, *PRemovePort_IN;

#define RemovePort_IN_SIZE (FIELD_OFFSET(RemovePort_IN, PortWWN) + RemovePort_IN_PortWWN_SIZE)

typedef struct _RemovePort_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemovePort_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemovePort_OUT_HBAStatus_ID 1

} RemovePort_OUT, *PRemovePort_OUT;

#define RemovePort_OUT_SIZE (FIELD_OFFSET(RemovePort_OUT, HBAStatus) + RemovePort_OUT_HBAStatus_SIZE)

#define AddLink     30
typedef struct _AddLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define AddLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define AddLink_OUT_HBAStatus_ID 1

} AddLink_OUT, *PAddLink_OUT;

#define AddLink_OUT_SIZE (FIELD_OFFSET(AddLink_OUT, HBAStatus) + AddLink_OUT_HBAStatus_SIZE)

#define RemoveLink     31
typedef struct _RemoveLink_OUT
{
    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define RemoveLink_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define RemoveLink_OUT_HBAStatus_ID 1

} RemoveLink_OUT, *PRemoveLink_OUT;

#define RemoveLink_OUT_SIZE (FIELD_OFFSET(RemoveLink_OUT, HBAStatus) + RemoveLink_OUT_HBAStatus_SIZE)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\drmk.h ===
#ifndef _DRMK_H_
#define _DRMK_H_

#ifdef __cplusplus
extern "C"
{
#endif
    
	
typedef struct tagDRMRIGHTS {
    BOOL  CopyProtect;
    ULONG Reserved;
    BOOL  DigitalOutputDisable;
} DRMRIGHTS , *PDRMRIGHTS;
typedef const DRMRIGHTS *PCDRMRIGHTS;

#define DEFINE_DRMRIGHTS_DEFAULT(DrmRights) const DRMRIGHTS DrmRights = {FALSE, 0, FALSE}


// {1915C967-3299-48cb-A3E4-69FD1D1B306E}
DEFINE_GUID(IID_IDrmAudioStream,
	    0x1915c967, 0x3299, 0x48cb, 0xa3, 0xe4, 0x69, 0xfd, 0x1d, 0x1b, 0x30, 0x6e);

DECLARE_INTERFACE_(IDrmAudioStream, IUnknown)
{
    // IUnknown methods
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_
        REFIID InterfaceId,
        PVOID* Interface
        ) PURE;
        
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    
    // IDrmAudioStream methods                       
    STDMETHOD_(NTSTATUS,SetContentId)(THIS_
	IN ULONG ContentId,
        IN PCDRMRIGHTS DrmRights
        ) PURE;
};

typedef IDrmAudioStream *PDRMAUDIOSTREAM;

#define IMP_IDrmAudioStream\
    STDMETHODIMP_(NTSTATUS) SetContentId\
    (   IN      ULONG	    ContentId,\
        IN      PCDRMRIGHTS DrmRights\
    );

typedef struct tagDRMFORWARD {
    DWORD          Flags;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT   FileObject;
    PVOID          Context;
} DRMFORWARD, *PDRMFORWARD;
typedef const DRMFORWARD *PCDRMFORWARD;

NTSTATUS
NTAPI
DrmAddContentHandlers(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

typedef
NTSTATUS
(NTAPI *PFNDRMADDCONTENTHANDLERS)(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

NTSTATUS
NTAPI
DrmCreateContentMixed(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMCREATECONTENTMIXED)(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

NTSTATUS
NTAPI
DrmDestroyContent(
    IN ULONG ContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMDESTROYCONTENT)(
    IN ULONG ContentId
    );

NTSTATUS
NTAPI
DrmForwardContentToDeviceObject(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTODEVICEOBJECT)(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );


NTSTATUS
NTAPI
DrmForwardContentToFileObject(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOFILEOBJECT)(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
NTAPI
DrmForwardContentToInterface(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOINTERFACE)(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

NTSTATUS
NTAPI
DrmGetContentRights(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );

typedef
NTSTATUS
(NTAPI *PFNDRMGETCONTENTRIGHTS)(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );


//
// Structures for use with KSPROPERY_DRMAUDIOSTREAM_CONTENTID
//

typedef struct {
    ULONG     ContentId;
    DRMRIGHTS DrmRights;
} KSDRMAUDIOSTREAM_CONTENTID, *PKSDRMAUDIOSTREAM_CONTENTID;

typedef struct {
    KSPROPERTY                         Property;
    PVOID                              Context;
    // DRM API callback functions
    PFNDRMADDCONTENTHANDLERS            DrmAddContentHandlers;
    PFNDRMCREATECONTENTMIXED            DrmCreateContentMixed;
    PFNDRMDESTROYCONTENT                DrmDestroyContent;
    PFNDRMFORWARDCONTENTTODEVICEOBJECT  DrmForwardContentToDeviceObject;
    PFNDRMFORWARDCONTENTTOFILEOBJECT    DrmForwardContentToFileObject;
    PFNDRMFORWARDCONTENTTOINTERFACE     DrmForwardContentToInterface;
    PFNDRMGETCONTENTRIGHTS              DrmGetContentRights;
} KSP_DRMAUDIOSTREAM_CONTENTID, *PKSP_DRMAUDIOSTREAM_CONTENTID;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\i2cgpio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//@@BEGIN_DDKSPLIT 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//  The files 
//      \wdm10\ddk\inc\i2cgpio.h
//      \dev\ddk\inc\i2cgpio.h
//  Are the same.
//
//  When changing either file, be sure to update the other file in the other
//  directory. This has been done to ensure that the DirectX DDK can pull
//  I2CGPIO.H into its DDK from \dev\ddk\inc, and not have to enlist in the
//  \wdm10 ddk.
//
//@@END_DDKSPLIT
//==========================================================================;

#if 0
To access the IO functionality in a WDM driver or the VDD, WDM driver sends 
the following IRP to its parent.

MajorFunction = IRP_MJ_PNP;
MinorFunction = IRP_MN_QUERY_INTERFACE;

Guid = DEFINE_GUID( GUID_GPIO_INTERFACE, 
        0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

The QUERY_INTERFACE Irp will return an interface (set of function pointers)
of the type xxxxINTERFACE, defined below. This is essentially a table of
function pointers.

#endif

#ifndef __I2CGPIO_H__
#define __I2CGPIO_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Guids
//
// DEFINE_GUID requires that you include wdm.h before this file.
// #define INITGUID to actually initialize the guid in memory.
//
DEFINE_GUID( GUID_I2C_INTERFACE, 0x02295e86L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_GPIO_INTERFACE,0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_COPYPROTECTION_INTERFACE, 0x02295e88L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

//==========================================================================;
// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif
//==========================================================================;
//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;

// this is the Interface definition for I2C
//
typedef NTSTATUS (STDMETHODCALLTYPE *I2COPEN)(PDEVICE_OBJECT, ULONG, PI2CControl);
typedef NTSTATUS (STDMETHODCALLTYPE *I2CACCESS)(PDEVICE_OBJECT, PI2CControl);

typedef struct {
    INTERFACE _vddInterface;
    I2COPEN   i2cOpen;
    I2CACCESS i2cAccess;
} I2CINTERFACE;

//==========================================================================;
//
// GPIO section
//
// GPIO Commands

#define GPIO_COMMAND_QUERY          0X0001      // get #pins and nBufferSize
#define GPIO_COMMAND_OPEN           0X0001      // old open
#define GPIO_COMMAND_OPEN_PINS      0X0002      // get dwCookie
#define GPIO_COMMAND_CLOSE_PINS     0X0004      // invalidate cookie
#define GPIO_COMMAND_READ_BUFFER    0X0008
#define GPIO_COMMAND_WRITE_BUFFER   0X0010

// The following flags are provided on a READ_BUFFER or WRITE_BUFFER command
// lpPins bits set MUST have contiguous bits set for a read/write command.
//
// On a READ, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, then zeros are returned for those positions. 
// on a WRITE, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, a read/modify/write is done on the port/mmio position
// that represents those bits.

#define GPIO_FLAGS_BYTE             0x0001  // do byte read/write
#define GPIO_FLAGS_WORD             0x0002  // do word read/write
#define GPIO_FLAGS_DWORD            0x0004  // do dword read/write

// The following status flags are returned on completion of the operation
#define GPIO_STATUS_NOERROR     0X0000  
#define GPIO_STATUS_BUSY        0X0001
#define GPIO_STATUS_ERROR       0X0002
#define GPIO_STATUS_NO_ASYNCH   0X0004  // gpio provider does not do asynch xfer

typedef struct _GPIOControl {
    ULONG Command;          // GPIO_COMMAND_*
    ULONG Flags;            // GPIO_FLAGS_*
    DWORD dwCookie;         // Context identifier returned on Open
    ULONG Status;           // GPIO_STATUS_*
    ULONG nBytes;           // # of bytes to send or recieved
    ULONG nBufferSize;      // max size of buffer
    ULONG nPins;            // number of GPIO pins returned by Open
    UCHAR *Pins;            // pointer to bitmask of pins to read/write
    UCHAR *Buffer;          // pointer to GPIO data to send/recieve
    void  (*AsynchCompleteCallback)(UCHAR *Buffer);
                            // NULL if synchronous xfer, valid ptr if asynch.
    GUID  PrivateInterfaceType;
    void  (*PrivateInterface)();
    
} GPIOControl, *PGPIOControl;

// This is the GPIO interface
//
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOOPEN)(PDEVICE_OBJECT, ULONG, PGPIOControl);
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOACCESS)(PDEVICE_OBJECT, PGPIOControl);

typedef struct {
    INTERFACE _vddInterface;
    GPIOOPEN   gpioOpen;
    GPIOACCESS gpioAccess;
} GPIOINTERFACE;

//==========================================================================;
#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__I2CGPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ioaccess.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/

//
// Note: IA64 is for 64 bits Merced. Under Merced compiler option, we don't have
// _X86_, instead, we use _IA64_. Same thing, _AXP64_ is for 64 bits compiler
// option for ALPHA
//
#if defined(_MIPS_) || defined(_X86_) || defined(_AMD64_)

//
// Memory barriers on X86 and MIPS are not required since the Io
// Operations are always garanteed to be executed in order
//

#define MEMORY_BARRIER()    0


#elif defined(_IA64_)

//
// Itanium requires memory barriers
//

void __mf();

#define MEMORY_BARRIER()    __mf()

#elif defined(_PPC_)

//
// A memory barrier function is provided by the PowerPC Enforce
// In-order Execution of I/O instruction (eieio).
//

#if defined(_M_PPC) && defined(_MSC_VER) && (_MSC_VER>=1000)
void __emit( unsigned const __int32 );
#define __builtin_eieio() __emit( 0x7C0006AC )
#else
void __builtin_eieio(void);
#endif

#define MEMORY_BARRIER()        __builtin_eieio()


#elif defined(_ALPHA_) || (_AXP64_)

//
// ALPHA requires memory barriers
//

#define MEMORY_BARRIER()  __MB()



#endif

#ifndef NO_PORT_MACROS



//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate MEMORY registers.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O ports.
//  (Use x86 in/out instructions.)
//


//
// inp(),inpw(), inpd(), outp(), outpw(), outpd() are X86 specific intrinsic
// inline functions. So for IA64, we have to put READ_PORT_USHORT() etc. back
// to it's supposed to be, defined in sdk\inc\wdm.h
//
#if defined(_IA64_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_X86_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  (UCHAR)(inp (Port))
#define READ_PORT_USHORT(Port)                 (USHORT)(inpw (Port))
#define READ_PORT_ULONG(Port)                  (ULONG)(inpd (Port))
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#elif defined(_PPC_) || defined(_MIPS_)

#define READ_REGISTER_UCHAR(x)      (*(volatile UCHAR * const)(x))
#define READ_REGISTER_USHORT(x)     (*(volatile USHORT * const)(x))
#define READ_REGISTER_ULONG(x)      (*(volatile ULONG * const)(x))
#define WRITE_REGISTER_UCHAR(x, y)  (*(volatile UCHAR * const)(x) = (y))
#define WRITE_REGISTER_USHORT(x, y) (*(volatile USHORT * const)(x) = (y))
#define WRITE_REGISTER_ULONG(x, y)  (*(volatile ULONG * const)(x) = (y))
#define READ_PORT_UCHAR(x)          READ_REGISTER_UCHAR(x)
#define READ_PORT_USHORT(x)         READ_REGISTER_USHORT(x)
#define READ_PORT_ULONG(x)          READ_REGISTER_ULONG(x)

//
// All these macros take a ULONG as a parameter so that we don't
// force an extra typecast in the code (which will cause the X86 to
// generate bad code).
//

#define WRITE_PORT_UCHAR(x, y)      WRITE_REGISTER_UCHAR(x, (UCHAR) (y))
#define WRITE_PORT_USHORT(x, y)     WRITE_REGISTER_USHORT(x, (USHORT) (y))
#define WRITE_PORT_ULONG(x, y)      WRITE_REGISTER_ULONG(x, (ULONG) (y))


#elif defined(_ALPHA_) || (_AXP64_)

//
// READ/WRITE_PORT/REGISTER_UCHAR_USHORT_ULONG are all functions that
// go to the HAL on ALPHA
//
// So we only put the prototypes here
//

__declspec(dllimport)
UCHAR
READ_REGISTER_UCHAR(
    PVOID Register
    );

__declspec(dllimport)
USHORT
READ_REGISTER_USHORT(
    PVOID Register
    );

__declspec(dllimport)
ULONG
READ_REGISTER_ULONG(
    PVOID Register
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_UCHAR(
    PVOID Register,
    UCHAR Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_USHORT(
    PVOID  Register,
    USHORT Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_ULONG(
    PVOID Register,
    ULONG Value
    );

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_AMD64_)

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)

LONG
_InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedOr)


__inline
UCHAR
READ_REGISTER_UCHAR (
    PVOID Register
    )
{
    return *(UCHAR volatile *)Register;
}

__inline
USHORT
READ_REGISTER_USHORT (
    PVOID Register
    )
{
    return *(USHORT volatile *)Register;
}

__inline
ULONG
READ_REGISTER_ULONG (
    PVOID Register
    )
{
    return *(ULONG volatile *)Register;
}

__inline
VOID
WRITE_REGISTER_UCHAR (
    PVOID Register,
    UCHAR Value
    )
{
    LONG Synch;

    *(UCHAR volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_USHORT (
    PVOID Register,
    USHORT Value
    )
{
    LONG Synch;

    *(USHORT volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_ULONG (
    PVOID Register,
    ULONG Value
    )
{
    LONG Synch;

    *(ULONG volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
UCHAR
READ_PORT_UCHAR (
    PVOID Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__inline
USHORT
READ_PORT_USHORT (
    PVOID Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__inline
ULONG
READ_PORT_ULONG (
    PVOID Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}

__inline
VOID
WRITE_PORT_UCHAR (
    PVOID Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_USHORT (
    PVOID Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_ULONG (
    PVOID Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

#endif      // NO_PORT_MACROS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\isvbop.inc ===
; This is the inc file for isvbop.h.
; Please refer to isvbop.h for comments and notes on these interfaces
;
BOP_3RDPARTY	EQU	58H
BOP_UNSIMULATE	EQU	0FEH

RegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 1
        endm

DispatchCall macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 2
        endm
 
VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\isvbop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    ISVBOP.H

Abstract:

    This is the header file supporting third party bops.
    isvbop.inc is the inc file for this h file.

Note:
    Following include file uses 'DB' to define assembly macros. Some
    assemblers use 'emit' instead. If you are using such a compiler,
    you will have to change db's to emit's.

--*/


#if _MSC_VER > 1000
#pragma once
#endif

#define BOP_3RDPARTY 0x58
#define BOP_UNSIMULATE 0xFE

/* XLATOFF */

/** RegisterModule - This Bop call is made from the 16 bit module
 *		     to register a third party DLL with the bop
 *		     manager. This call returns a handle to the
 *		     16bit caller which is to be used later to
 *		     dispatch a call to the DLL.
 *
 *  INPUT:
 *	Client DS:SI - asciiz string of DLL name.
 *      Client ES:DI - asciiz string of Init Routine in the DLL. (Optional)
 *	Client DS:BX - asciiz string to Dispatch routine in the DLL.
 *
 *  OUTPUT:
 *	SUCCESS:
 *	    Client Carry Clear
 *	    Client AX = Handle (non Zero)
 *	FAILURE:
 *	    Client Carry Set
 *	    Client AX = Error Code
 *		    AX = 1 - DLL not found
 *		    AX = 2 - Dispacth routine not found.
 *		    AX = 3 - Init Routine Not Found
 *		    AX = 4 - Insufficient Memory
 *
 *  NOTES:
 *	RegisterModule results in loading the DLL (specified in DS:SI).
 *      Its Init routine (specified in ES:DI) is called. Its Dispatch
 *	routine (specified in DS:BX) is stored away and all the calls
 *      made from DispatchCall are dispacthed to this routine.
 *      If ES and DI both are null than the caller did'nt supply the init
 *      routine.
 */

#define RegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x0

/** UnRegisterModule - This Bop call is made from the 16 bit module
 *		       to unregister a third party DLL with the bop
 *		       manager.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it if initialization of 16bit app fails after registering the
 *	Bop.
 */

#define UnRegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x1

/** DispacthCall - This Bop call is made from the 16 bit module
 *		   to pass a request to its DLL.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (DLL should set the proper output registers etc.)
 *	(VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it to pass a request to 32bit DLL. The request index and the
 *	parameters are passed in different registers. These register settings
 *	are private to the 16bit module and its associated VDD. Bop manager
 *	does'nt know anything about these registers.
 */
#define DispatchCall()	 _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x2

/*** VDDUnSimulate16
 *
 *   This service causes the simulation of intel instructions to stop and
 *   control to return to VDD.
 *
 *   INPUT
 *      None
 *
 *   OUTPUT
 *      None
 *
 *   NOTES
 *      This service is a macro intended for 16bit stub-drivers. At the
 *      end of worker routine stub-driver should use it.
 */

#define VDDUnSimulate16() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_UNSIMULATE

/* XLATON */


/* ASM
RegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 1
	endm

DispatchCall macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 2
	endm

VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ia64reg.h ===
#ifndef _IA64REG_
#define _IA64REG_
#if _MSC_VER > 1000
#pragma once
#endif


typedef enum IA64_REG_INDEX {              

    //
    // Register set for Intel IA64              
    //


    // Branch Registers              

    CV_IA64_BrRp     =   512,              
    CV_IA64_BrS0     =   513,              
    CV_IA64_BrS1     =   514,              
    CV_IA64_BrS2     =   515,              
    CV_IA64_BrS3     =   516,              
    CV_IA64_BrS4     =   517,              
    CV_IA64_BrT0     =   518,              
    CV_IA64_BrT1     =   519,              

    // Predicate Registers              

    CV_IA64_Preds     =   768,              

    // Banked General Registers              

    CV_IA64_IntH0    =   832,              
    CV_IA64_IntH1    =   833,              
    CV_IA64_IntH2    =   834,              
    CV_IA64_IntH3    =   835,              
    CV_IA64_IntH4    =   836,              
    CV_IA64_IntH5    =   837,              
    CV_IA64_IntH6    =   838,              
    CV_IA64_IntH7    =   839,              
    CV_IA64_IntH8    =   840,              
    CV_IA64_IntH9    =   841,              
    CV_IA64_IntH10    =   842,              
    CV_IA64_IntH11    =   843,              
    CV_IA64_IntH12    =   844,              
    CV_IA64_IntH13    =   845,              
    CV_IA64_IntH14    =   846,              
    CV_IA64_IntH15    =   847,              

    // Special Registers              

    CV_IA64_Ip     =   1016,              
    CV_IA64_Umask  =   1017,              
    CV_IA64_Cfm    =   1018,              
    CV_IA64_Psr    =   1019,              

    // Banked General Registers              

    CV_IA64_Nats     =   1020,              
    CV_IA64_Nats2    =   1021,              
    CV_IA64_Nats3    =   1022,              

    // General-Purpose Registers              

    // INTEGER REGISTER              
    CV_IA64_IntZero  =   1024,              
    CV_IA64_IntGp    =   1025,              
    CV_IA64_IntT0    =   1026,              
    CV_IA64_IntT1    =   1027,              
    CV_IA64_IntS0    =   1028,              
    CV_IA64_IntS1    =   1029,              
    CV_IA64_IntS2    =   1030,              
    CV_IA64_IntS3    =   1031,              
    CV_IA64_IntV0    =   1032,              
    CV_IA64_IntAp    =   1033,              
    CV_IA64_IntT2    =   1034,              
    CV_IA64_IntT3    =   1035,              
    CV_IA64_IntSp    =   1036,              
    CV_IA64_IntT4    =   1037,              
    CV_IA64_IntT5    =   1038,              
    CV_IA64_IntT6    =   1039,              
    CV_IA64_IntT7    =   1040,              
    CV_IA64_IntT8    =   1041,              
    CV_IA64_IntT9    =   1042,              
    CV_IA64_IntT10   =   1043,              
    CV_IA64_IntT11   =   1044,              
    CV_IA64_IntT12   =   1045,              
    CV_IA64_IntT13   =   1046,              
    CV_IA64_IntT14   =   1047,              
    CV_IA64_IntT15   =   1048,              
    CV_IA64_IntT16   =   1049,              
    CV_IA64_IntT17   =   1050,              
    CV_IA64_IntT18   =   1051,              
    CV_IA64_IntT19   =   1052,              
    CV_IA64_IntT20   =   1053,              
    CV_IA64_IntT21   =   1054,              
    CV_IA64_IntT22   =   1055,              

    // Register Stack              
    CV_IA64_IntR32   =   1056,              
    CV_IA64_IntR33   =   1057,              
    CV_IA64_IntR34   =   1058,              
    CV_IA64_IntR35   =   1059,              
    CV_IA64_IntR36   =   1060,              
    CV_IA64_IntR37   =   1061,              
    CV_IA64_IntR38   =   1062,              
    CV_IA64_IntR39   =   1063,              
    CV_IA64_IntR40   =   1064,              
    CV_IA64_IntR41   =   1065,              
    CV_IA64_IntR42   =   1066,              
    CV_IA64_IntR43   =   1067,              
    CV_IA64_IntR44   =   1068,              
    CV_IA64_IntR45   =   1069,              
    CV_IA64_IntR46   =   1070,              
    CV_IA64_IntR47   =   1071,              
    CV_IA64_IntR48   =   1072,              
    CV_IA64_IntR49   =   1073,              
    CV_IA64_IntR50   =   1074,              
    CV_IA64_IntR51   =   1075,              
    CV_IA64_IntR52   =   1076,              
    CV_IA64_IntR53   =   1077,              
    CV_IA64_IntR54   =   1078,              
    CV_IA64_IntR55   =   1079,              
    CV_IA64_IntR56   =   1080,              
    CV_IA64_IntR57   =   1081,              
    CV_IA64_IntR58   =   1082,              
    CV_IA64_IntR59   =   1083,              
    CV_IA64_IntR60   =   1084,              
    CV_IA64_IntR61   =   1085,              
    CV_IA64_IntR62   =   1086,              
    CV_IA64_IntR63   =   1087,              
    CV_IA64_IntR64   =   1088,              
    CV_IA64_IntR65   =   1089,              
    CV_IA64_IntR66   =   1090,              
    CV_IA64_IntR67   =   1091,              
    CV_IA64_IntR68   =   1092,              
    CV_IA64_IntR69   =   1093,              
    CV_IA64_IntR70   =   1094,              
    CV_IA64_IntR71   =   1095,              
    CV_IA64_IntR72   =   1096,              
    CV_IA64_IntR73   =   1097,              
    CV_IA64_IntR74   =   1098,              
    CV_IA64_IntR75   =   1099,              
    CV_IA64_IntR76   =   1100,              
    CV_IA64_IntR77   =   1101,              
    CV_IA64_IntR78   =   1102,              
    CV_IA64_IntR79   =   1103,              
    CV_IA64_IntR80   =   1104,              
    CV_IA64_IntR81   =   1105,              
    CV_IA64_IntR82   =   1106,              
    CV_IA64_IntR83   =   1107,              
    CV_IA64_IntR84   =   1108,              
    CV_IA64_IntR85   =   1109,              
    CV_IA64_IntR86   =   1110,              
    CV_IA64_IntR87   =   1111,              
    CV_IA64_IntR88   =   1112,              
    CV_IA64_IntR89   =   1113,              
    CV_IA64_IntR90   =   1114,              
    CV_IA64_IntR91   =   1115,              
    CV_IA64_IntR92   =   1116,              
    CV_IA64_IntR93   =   1117,              
    CV_IA64_IntR94   =   1118,              
    CV_IA64_IntR95   =   1119,              
    CV_IA64_IntR96   =   1120,              
    CV_IA64_IntR97   =   1121,              
    CV_IA64_IntR98   =   1122,              
    CV_IA64_IntR99   =   1123,              
    CV_IA64_IntR100   =   1124,              
    CV_IA64_IntR101   =   1125,              
    CV_IA64_IntR102   =   1126,              
    CV_IA64_IntR103   =   1127,              
    CV_IA64_IntR104   =   1128,              
    CV_IA64_IntR105   =   1129,              
    CV_IA64_IntR106   =   1130,              
    CV_IA64_IntR107   =   1131,              
    CV_IA64_IntR108   =   1132,              
    CV_IA64_IntR109   =   1133,              
    CV_IA64_IntR110   =   1134,              
    CV_IA64_IntR111   =   1135,              
    CV_IA64_IntR112   =   1136,              
    CV_IA64_IntR113   =   1137,              
    CV_IA64_IntR114   =   1138,              
    CV_IA64_IntR115   =   1139,              
    CV_IA64_IntR116   =   1140,              
    CV_IA64_IntR117   =   1141,              
    CV_IA64_IntR118   =   1142,              
    CV_IA64_IntR119   =   1143,              
    CV_IA64_IntR120   =   1144,              
    CV_IA64_IntR121   =   1145,              
    CV_IA64_IntR122   =   1146,              
    CV_IA64_IntR123   =   1147,              
    CV_IA64_IntR124   =   1148,              
    CV_IA64_IntR125   =   1149,              
    CV_IA64_IntR126   =   1150,              
    CV_IA64_IntR127   =   1151,              

    // Floating-Point Registers              

    // Low Floating Point Registers              
    CV_IA64_FltZero  =   2048,              
    CV_IA64_FltOne   =   2049,              
    CV_IA64_FltS0    =   2050,              
    CV_IA64_FltS1    =   2051,              
    CV_IA64_FltS2    =   2052,              
    CV_IA64_FltS3    =   2053,              
    CV_IA64_FltT0    =   2054,              
    CV_IA64_FltT1    =   2055,              
    CV_IA64_FltT2    =   2056,              
    CV_IA64_FltT3    =   2057,              
    CV_IA64_FltT4    =   2058,              
    CV_IA64_FltT5    =   2059,              
    CV_IA64_FltT6    =   2060,              
    CV_IA64_FltT7    =   2061,              
    CV_IA64_FltT8    =   2062,              
    CV_IA64_FltT9    =   2063,              
    CV_IA64_FltS4    =   2064,              
    CV_IA64_FltS5    =   2065,              
    CV_IA64_FltS6    =   2066,              
    CV_IA64_FltS7    =   2067,              
    CV_IA64_FltS8    =   2068,              
    CV_IA64_FltS9    =   2069,              
    CV_IA64_FltS10   =   2070,              
    CV_IA64_FltS11   =   2071,              
    CV_IA64_FltS12   =   2072,              
    CV_IA64_FltS13   =   2073,              
    CV_IA64_FltS14   =   2074,              
    CV_IA64_FltS15   =   2075,              
    CV_IA64_FltS16   =   2076,              
    CV_IA64_FltS17   =   2077,              
    CV_IA64_FltS18   =   2078,              
    CV_IA64_FltS19   =   2079,              

    // High Floating Point Registers              
    CV_IA64_FltF32   =   2080,              
    CV_IA64_FltF33   =   2081,              
    CV_IA64_FltF34   =   2082,              
    CV_IA64_FltF35   =   2083,              
    CV_IA64_FltF36   =   2084,              
    CV_IA64_FltF37   =   2085,              
    CV_IA64_FltF38   =   2086,              
    CV_IA64_FltF39   =   2087,              
    CV_IA64_FltF40   =   2088,              
    CV_IA64_FltF41   =   2089,              
    CV_IA64_FltF42   =   2090,              
    CV_IA64_FltF43   =   2091,              
    CV_IA64_FltF44   =   2092,              
    CV_IA64_FltF45   =   2093,              
    CV_IA64_FltF46   =   2094,              
    CV_IA64_FltF47   =   2095,              
    CV_IA64_FltF48   =   2096,              
    CV_IA64_FltF49   =   2097,              
    CV_IA64_FltF50   =   2098,              
    CV_IA64_FltF51   =   2099,              
    CV_IA64_FltF52   =   2100,              
    CV_IA64_FltF53   =   2101,              
    CV_IA64_FltF54   =   2102,              
    CV_IA64_FltF55   =   2103,              
    CV_IA64_FltF56   =   2104,              
    CV_IA64_FltF57   =   2105,              
    CV_IA64_FltF58   =   2106,              
    CV_IA64_FltF59   =   2107,              
    CV_IA64_FltF60   =   2108,              
    CV_IA64_FltF61   =   2109,              
    CV_IA64_FltF62   =   2110,              
    CV_IA64_FltF63   =   2111,              
    CV_IA64_FltF64   =   2112,              
    CV_IA64_FltF65   =   2113,              
    CV_IA64_FltF66   =   2114,              
    CV_IA64_FltF67   =   2115,              
    CV_IA64_FltF68   =   2116,              
    CV_IA64_FltF69   =   2117,              
    CV_IA64_FltF70   =   2118,              
    CV_IA64_FltF71   =   2119,              
    CV_IA64_FltF72   =   2120,              
    CV_IA64_FltF73   =   2121,              
    CV_IA64_FltF74   =   2122,              
    CV_IA64_FltF75   =   2123,              
    CV_IA64_FltF76   =   2124,              
    CV_IA64_FltF77   =   2125,              
    CV_IA64_FltF78   =   2126,              
    CV_IA64_FltF79   =   2127,              
    CV_IA64_FltF80   =   2128,              
    CV_IA64_FltF81   =   2129,              
    CV_IA64_FltF82   =   2130,              
    CV_IA64_FltF83   =   2131,              
    CV_IA64_FltF84   =   2132,              
    CV_IA64_FltF85   =   2133,              
    CV_IA64_FltF86   =   2134,              
    CV_IA64_FltF87   =   2135,              
    CV_IA64_FltF88   =   2136,              
    CV_IA64_FltF89   =   2137,              
    CV_IA64_FltF90   =   2138,              
    CV_IA64_FltF91   =   2139,              
    CV_IA64_FltF92   =   2140,              
    CV_IA64_FltF93   =   2141,              
    CV_IA64_FltF94   =   2142,              
    CV_IA64_FltF95   =   2143,              
    CV_IA64_FltF96   =   2144,              
    CV_IA64_FltF97   =   2145,              
    CV_IA64_FltF98   =   2146,              
    CV_IA64_FltF99   =   2147,              
    CV_IA64_FltF100   =   2148,              
    CV_IA64_FltF101   =   2149,              
    CV_IA64_FltF102   =   2150,              
    CV_IA64_FltF103   =   2151,              
    CV_IA64_FltF104   =   2152,              
    CV_IA64_FltF105   =   2153,              
    CV_IA64_FltF106   =   2154,              
    CV_IA64_FltF107   =   2155,              
    CV_IA64_FltF108   =   2156,              
    CV_IA64_FltF109   =   2157,              
    CV_IA64_FltF110   =   2158,              
    CV_IA64_FltF111   =   2159,              
    CV_IA64_FltF112   =   2160,              
    CV_IA64_FltF113   =   2161,              
    CV_IA64_FltF114   =   2162,              
    CV_IA64_FltF115   =   2163,              
    CV_IA64_FltF116   =   2164,              
    CV_IA64_FltF117   =   2165,              
    CV_IA64_FltF118   =   2166,              
    CV_IA64_FltF119   =   2167,              
    CV_IA64_FltF120   =   2168,              
    CV_IA64_FltF121   =   2169,              
    CV_IA64_FltF122   =   2170,              
    CV_IA64_FltF123   =   2171,              
    CV_IA64_FltF124   =   2172,              
    CV_IA64_FltF125   =   2173,              
    CV_IA64_FltF126   =   2174,              
    CV_IA64_FltF127   =   2175,              

    // Application Registers              

    CV_IA64_ApKR0    =   3072,              
    CV_IA64_ApKR1    =   3073,              
    CV_IA64_ApKR2    =   3074,              
    CV_IA64_ApKR3    =   3075,              
    CV_IA64_ApKR4    =   3076,              
    CV_IA64_ApKR5    =   3077,              
    CV_IA64_ApKR6    =   3078,              
    CV_IA64_ApKR7    =   3079,              
    CV_IA64_AR8      =   3080,              
    CV_IA64_AR9      =   3081,              
    CV_IA64_AR10     =   3082,              
    CV_IA64_AR11     =   3083,              
    CV_IA64_AR12     =   3084,              
    CV_IA64_AR13     =   3085,              
    CV_IA64_AR14     =   3086,              
    CV_IA64_AR15     =   3087,              
    CV_IA64_RsRSC    =   3088,              
    CV_IA64_RsBSP    =   3089,              
    CV_IA64_RsBSPSTORE =   3090,              
    CV_IA64_RsRNAT   =   3091,              
    CV_IA64_AR20     =   3092,              
    CV_IA64_AR21     =   3093,              
    CV_IA64_AR22     =   3094,              
    CV_IA64_AR23     =   3095,              
    CV_IA64_AR24     =   3096,              
    CV_IA64_AR25     =   3097,              
    CV_IA64_AR26     =   3098,              
    CV_IA64_AR27     =   3099,              
    CV_IA64_AR28     =   3100,              
    CV_IA64_AR29     =   3101,              
    CV_IA64_AR30     =   3102,              
    CV_IA64_AR31     =   3103,              
    CV_IA64_ApCCV    =   3104,              
    CV_IA64_AR33     =   3105,              
    CV_IA64_AR34     =   3106,              
    CV_IA64_AR35     =   3107,              
    CV_IA64_ApUNAT   =   3108,              
    CV_IA64_AR37     =   3109,              
    CV_IA64_AR38     =   3110,              
    CV_IA64_AR39     =   3111,              
    CV_IA64_StFPSR   =   3112,              
    CV_IA64_AR41     =   3113,              
    CV_IA64_AR42     =   3114,              
    CV_IA64_AR43     =   3115,              
    CV_IA64_ApITC    =   3116,              
    CV_IA64_AR45     =   3117,              
    CV_IA64_AR46     =   3118,              
    CV_IA64_AR47     =   3119,              
    CV_IA64_AR48     =   3120,              
    CV_IA64_AR49     =   3121,              
    CV_IA64_AR50     =   3122,              
    CV_IA64_AR51     =   3123,              
    CV_IA64_AR52     =   3124,              
    CV_IA64_AR53     =   3125,              
    CV_IA64_AR54     =   3126,              
    CV_IA64_AR55     =   3127,              
    CV_IA64_AR56     =   3128,              
    CV_IA64_AR57     =   3129,              
    CV_IA64_AR58     =   3130,              
    CV_IA64_AR59     =   3131,              
    CV_IA64_AR60     =   3132,              
    CV_IA64_AR61     =   3133,              
    CV_IA64_AR62     =   3134,              
    CV_IA64_AR63     =   3135,              
    CV_IA64_RsPFS    =   3136,              
    CV_IA64_ApLC     =   3137,              
    CV_IA64_ApEC     =   3138,              
    CV_IA64_AR67   =   3139,              
    CV_IA64_AR68   =   3140,              
    CV_IA64_AR69   =   3141,              
    CV_IA64_AR70   =   3142,              
    CV_IA64_AR71   =   3143,              
    CV_IA64_AR72   =   3144,              
    CV_IA64_AR73   =   3145,              
    CV_IA64_AR74   =   3146,              
    CV_IA64_AR75   =   3147,              
    CV_IA64_AR76   =   3148,              
    CV_IA64_AR77   =   3149,              
    CV_IA64_AR78   =   3150,              
    CV_IA64_AR79   =   3151,              
    CV_IA64_AR80   =   3152,              
    CV_IA64_AR81   =   3153,              
    CV_IA64_AR82   =   3154,              
    CV_IA64_AR83   =   3155,              
    CV_IA64_AR84   =   3156,              
    CV_IA64_AR85   =   3157,              
    CV_IA64_AR86   =   3158,              
    CV_IA64_AR87   =   3159,              
    CV_IA64_AR88   =   3160,              
    CV_IA64_AR89   =   3161,              
    CV_IA64_AR90   =   3162,              
    CV_IA64_AR91   =   3163,              
    CV_IA64_AR92   =   3164,              
    CV_IA64_AR93   =   3165,              
    CV_IA64_AR94   =   3166,              
    CV_IA64_AR95   =   3167,              
    CV_IA64_AR96   =   3168,              
    CV_IA64_AR97   =   3169,              
    CV_IA64_AR98   =   3170,              
    CV_IA64_AR99   =   3171,              
    CV_IA64_AR100   =   3172,              
    CV_IA64_AR101   =   3173,              
    CV_IA64_AR102   =   3174,              
    CV_IA64_AR103   =   3175,              
    CV_IA64_AR104   =   3176,              
    CV_IA64_AR105   =   3177,              
    CV_IA64_AR106   =   3178,              
    CV_IA64_AR107   =   3179,              
    CV_IA64_AR108   =   3180,              
    CV_IA64_AR109   =   3181,              
    CV_IA64_AR110   =   3182,              
    CV_IA64_AR111   =   3183,              
    CV_IA64_AR112   =   3184,              
    CV_IA64_AR113   =   3185,              
    CV_IA64_AR114   =   3186,              
    CV_IA64_AR115   =   3187,              
    CV_IA64_AR116   =   3188,              
    CV_IA64_AR117   =   3189,              
    CV_IA64_AR118   =   3190,              
    CV_IA64_AR119   =   3191,              
    CV_IA64_AR120   =   3192,              
    CV_IA64_AR121   =   3193,              
    CV_IA64_AR122   =   3194,              
    CV_IA64_AR123   =   3195,              
    CV_IA64_AR124   =   3196,              
    CV_IA64_AR125   =   3197,              
    CV_IA64_AR126   =   3198,              
    CV_IA64_AR127   =   3199,              

    // CPUID Registers                
    CV_IA64_CPUID0  =   3328,              
    CV_IA64_CPUID1  =   3329,              
    CV_IA64_CPUID2  =   3330,              
    CV_IA64_CPUID3  =   3331,              
    CV_IA64_CPUID4  =   3332,              

    // Control Registers              

    CV_IA64_ApDCR    =   4096,              
    CV_IA64_ApITM    =   4097,              
    CV_IA64_ApIVA    =   4098,              
    CV_IA64_CR3      =   4099,              
    CV_IA64_CR4      =   4100,              
    CV_IA64_CR5      =   4101,              
    CV_IA64_CR6      =   4102,              
    CV_IA64_CR7      =   4103,              
    CV_IA64_ApPTA    =   4104,              
    CV_IA64_ApGPTA   =   4105,              
    CV_IA64_CR10     =   4106,              
    CV_IA64_CR11     =   4107,              
    CV_IA64_CR12     =   4108,              
    CV_IA64_CR13     =   4109,              
    CV_IA64_CR14     =   4110,              
    CV_IA64_CR15     =   4111,              
    CV_IA64_StIPSR   =   4112,              
    CV_IA64_StISR    =   4113,              
    CV_IA64_CR18     =   4114,              
    CV_IA64_StIIP    =   4115,              
    CV_IA64_StIFA    =   4116,              
    CV_IA64_StITIR   =   4117,              
    CV_IA64_StIIPA   =   4118,              
    CV_IA64_StIFS    =   4119,              
    CV_IA64_StIIM    =   4120,              
    CV_IA64_StIHA    =   4121,              
    CV_IA64_CR26     =   4122,              
    CV_IA64_CR27     =   4123,              
    CV_IA64_CR28     =   4124,              
    CV_IA64_CR29     =   4125,              
    CV_IA64_CR30     =   4126,              
    CV_IA64_CR31     =   4127,              
    CV_IA64_CR32     =   4128,              
    CV_IA64_CR33     =   4129,              
    CV_IA64_CR34     =   4130,              
    CV_IA64_CR35     =   4131,              
    CV_IA64_CR36     =   4132,              
    CV_IA64_CR37     =   4133,              
    CV_IA64_CR38     =   4134,              
    CV_IA64_CR39     =   4135,              
    CV_IA64_CR40     =   4136,              
    CV_IA64_CR41     =   4137,              
    CV_IA64_CR42     =   4138,              
    CV_IA64_CR43     =   4139,              
    CV_IA64_CR44     =   4140,              
    CV_IA64_CR45     =   4141,              
    CV_IA64_CR46     =   4142,              
    CV_IA64_CR47     =   4143,              
    CV_IA64_CR48     =   4144,              
    CV_IA64_CR49     =   4145,              
    CV_IA64_CR50     =   4146,              
    CV_IA64_CR51     =   4147,              
    CV_IA64_CR52     =   4148,              
    CV_IA64_CR53     =   4149,              
    CV_IA64_CR54     =   4150,              
    CV_IA64_CR55     =   4151,              
    CV_IA64_CR56     =   4152,              
    CV_IA64_CR57     =   4153,              
    CV_IA64_CR58     =   4154,              
    CV_IA64_CR59     =   4155,              
    CV_IA64_CR60     =   4156,              
    CV_IA64_CR61     =   4157,              
    CV_IA64_CR62     =   4158,              
    CV_IA64_CR63     =   4159,              
    CV_IA64_SaLID    =   4160,              
    CV_IA64_SaIVR    =   4161,              
    CV_IA64_SaTPR    =   4162,              
    CV_IA64_SaEOI    =   4163,              
    CV_IA64_SaIRR0   =   4164,              
    CV_IA64_SaIRR1   =   4165,              
    CV_IA64_SaIRR2   =   4166,              
    CV_IA64_SaIIR3   =   4167,              
    CV_IA64_SaITV    =   4168,              
    CV_IA64_SaPMV    =   4169,              
    CV_IA64_SaCMCV   =   4170,              
    CV_IA64_CR75     =   4171,              
    CV_IA64_CR76     =   4172,              
    CV_IA64_CR77     =   4173,              
    CV_IA64_CR78     =   4174,              
    CV_IA64_CR79     =   4175,              
    CV_IA64_SaLRR0   =   4176,              
    CV_IA64_SaLRR1   =   4177,              
    CV_IA64_CR82     =   4178,              
    CV_IA64_CR83     =   4179,              
    CV_IA64_CR84     =   4180,              
    CV_IA64_CR85     =   4181,              
    CV_IA64_CR86     =   4182,              
    CV_IA64_CR87     =   4183,              
    CV_IA64_CR88     =   4184,              
    CV_IA64_CR89     =   4185,              
    CV_IA64_CR90     =   4186,              
    CV_IA64_CR91     =   4187,              
    CV_IA64_CR92     =   4188,              
    CV_IA64_CR93     =   4189,              
    CV_IA64_CR94     =   4190,              
    CV_IA64_CR95     =   4191,              
    CV_IA64_CR96     =   4192,              
    CV_IA64_CR97     =   4193,              
    CV_IA64_CR98     =   4194,              
    CV_IA64_CR99     =   4195,              
    CV_IA64_CR100    =   4196,              
    CV_IA64_CR101    =   4197,              
    CV_IA64_CR102    =   4198,              
    CV_IA64_CR103    =   4199,              
    CV_IA64_CR104    =   4200,              
    CV_IA64_CR105    =   4201,              
    CV_IA64_CR106    =   4202,              
    CV_IA64_CR107    =   4203,              
    CV_IA64_CR108    =   4204,              
    CV_IA64_CR109    =   4205,              
    CV_IA64_CR110    =   4206,              
    CV_IA64_CR111    =   4207,              
    CV_IA64_CR112    =   4208,              
    CV_IA64_CR113    =   4209,              
    CV_IA64_CR114    =   4210,              
    CV_IA64_CR115    =   4211,              
    CV_IA64_CR116    =   4212,              
    CV_IA64_CR117    =   4213,              
    CV_IA64_CR118    =   4214,              
    CV_IA64_CR119    =   4215,              
    CV_IA64_CR120    =   4216,              
    CV_IA64_CR121    =   4217,              
    CV_IA64_CR122    =   4218,              
    CV_IA64_CR123    =   4219,              
    CV_IA64_CR124    =   4220,              
    CV_IA64_CR125    =   4221,              
    CV_IA64_CR126    =   4222,              
    CV_IA64_CR127    =   4223,              

    // Protection Key Registers              

    CV_IA64_Pkr0     =   5120,              
    CV_IA64_Pkr1     =   5121,              
    CV_IA64_Pkr2     =   5122,              
    CV_IA64_Pkr3     =   5123,              
    CV_IA64_Pkr4     =   5124,              
    CV_IA64_Pkr5     =   5125,              
    CV_IA64_Pkr6     =   5126,              
    CV_IA64_Pkr7     =   5127,              
    CV_IA64_Pkr8     =   5128,              
    CV_IA64_Pkr9     =   5129,              
    CV_IA64_Pkr10    =   5130,              
    CV_IA64_Pkr11    =   5131,              
    CV_IA64_Pkr12    =   5132,              
    CV_IA64_Pkr13    =   5133,              
    CV_IA64_Pkr14    =   5134,              
    CV_IA64_Pkr15    =   5135,              

    // Region Registers

    CV_IA64_Rr0      =   6144,              
    CV_IA64_Rr1      =   6145,              
    CV_IA64_Rr2      =   6146,              
    CV_IA64_Rr3      =   6147,              
    CV_IA64_Rr4      =   6148,              
    CV_IA64_Rr5      =   6149,              
    CV_IA64_Rr6      =   6150,              
    CV_IA64_Rr7      =   6151,              

    // Performance Monitor Data Registers              

    CV_IA64_PFD0     =   7168,              
    CV_IA64_PFD1     =   7169,              
    CV_IA64_PFD2     =   7170,              
    CV_IA64_PFD3     =   7171,              
    CV_IA64_PFD4     =   7172,              
    CV_IA64_PFD5     =   7173,              
    CV_IA64_PFD6     =   7174,              
    CV_IA64_PFD7     =   7175,              

    // Performance Monitor Config Registers              

    CV_IA64_PFC0     =   7424,              
    CV_IA64_PFC1     =   7425,              
    CV_IA64_PFC2     =   7426,              
    CV_IA64_PFC3     =   7427,              
    CV_IA64_PFC4     =   7428,              
    CV_IA64_PFC5     =   7429,              
    CV_IA64_PFC6     =   7430,              
    CV_IA64_PFC7     =   7431,              

    // Instruction Translation Registers              

    CV_IA64_TrI0     =   8192,              
    CV_IA64_TrI1     =   8193,              
    CV_IA64_TrI2     =   8194,              
    CV_IA64_TrI3     =   8195,              
    CV_IA64_TrI4     =   8196,              
    CV_IA64_TrI5     =   8197,              
    CV_IA64_TrI6     =   8198,              
    CV_IA64_TrI7     =   8199,              

    // Data Translation Registers              

    CV_IA64_TrD0     =   8320,              
    CV_IA64_TrD1     =   8321,              
    CV_IA64_TrD2     =   8322,              
    CV_IA64_TrD3     =   8323,              
    CV_IA64_TrD4     =   8324,              
    CV_IA64_TrD5     =   8325,              
    CV_IA64_TrD6     =   8326,              
    CV_IA64_TrD7     =   8327,              

    // Instruction Breakpoint Registers              

    CV_IA64_DbI0     =   8448,              
    CV_IA64_DbI1     =   8449,              
    CV_IA64_DbI2     =   8450,              
    CV_IA64_DbI3     =   8451,              
    CV_IA64_DbI4     =   8452,              
    CV_IA64_DbI5     =   8453,              
    CV_IA64_DbI6     =   8454,              
    CV_IA64_DbI7     =   8455,              

    // Data Breakpoint Registers              

    CV_IA64_DbD0     =   8576,              
    CV_IA64_DbD1     =   8577,              
    CV_IA64_DbD2     =   8578,              
    CV_IA64_DbD3     =   8579,              
    CV_IA64_DbD4     =   8580,              
    CV_IA64_DbD5     =   8581,              
    CV_IA64_DbD6     =   8582,              
    CV_IA64_DbD7     =   8583,              

} IA64_REG_INDEX;              

//
// __lfetch control defines.
//

#define MD_LFHINT_NONE    0x00
#define MD_LFHINT_NT1     0x01
#define MD_LFHINT_NT2     0x02
#define MD_LFHINT_NTA     0x03

#endif // _IA64REG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ioevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioevent.h

Abstract:

    This module contains the GUIDS and event structures for io system
    initiated events.  These events are reported in kernel mode and are
    available to both user mode and kernel mode clients.

Author:

    Mark Zbikowski (markz) 3/18/98


Revision History:


--*/

//
//  Label change event.  This event is signalled upon successful completion
//  of a label change.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_CHANGE, 0x7373654aL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );

//
//  Volume dismount event.  This event is signalled when an attempt is made to
//  dismount a volume.  There is no additional data.  Note that this will not
//  necessarily be preceded by a GUID_IO_VOLUME_LOCK notification.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT, 0xd16a55e8L, 0x1059, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume dismount failed event.  This event is signalled when a volume dismount fails.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT_FAILED, 0xe3c5b178L, 0x105d, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume mount event.  This event is signalled when a volume mount occurs.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_MOUNT, 0xb5804878L, 0x1a96, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock event.  This event is signalled when an attempt is made to
//  lock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK, 0x50708874L, 0xc9af, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock failed event.  This event is signalled when an attempt is made to
//  lock a volume, but it fails.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK_FAILED, 0xae2eed10L, 0x0ba8, 0x11d2, 0x8f, 0xfb, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume unlock event.  This event is signalled when an attempt is made to
//  unlock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_UNLOCK, 0x9a8c3d68L, 0xd0cb, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume name change.  This event is signalled when the list of persistent
//  names (like drive letters) for a volume changes.  There is no additional
//  data.
//

DEFINE_GUID( GUID_IO_VOLUME_NAME_CHANGE, 0x2de97f83, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume physical configuration change.  This event is signalled when the
//  physical makeup or current physical state of the volume changes.
//

DEFINE_GUID( GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE, 0x2de97f84, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume device interface.  This is a device interface GUID that appears
//  when the device object associated with a volume is created and disappears
//  when the device object associated with the volume is destroyed.
//

DEFINE_GUID( GUID_IO_VOLUME_DEVICE_INTERFACE, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);



//
//  Sent when the removable media is changed (added, removed) from a device
//  (such as a CDROM, tape, changer, etc).
//
//  The additional data is a DWORD representing the data event.
//

DEFINE_GUID( GUID_IO_MEDIA_ARRIVAL,         0xd07433c0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_REMOVAL,         0xd07433c1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

//
// Sent when the media is returning that it is not ready right now, but will
// be ready soon. This can be because the drive has spun down to save power
// or because new media has been inserted but is not ready for access yet.
//

DEFINE_GUID( GUID_IO_DEVICE_BECOMING_READY, 0xd07433f0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_BECOMING_READY {
    ULONG Version;
    ULONG Reason;
    ULONG Estimated100msToReady;
} DEVICE_EVENT_BECOMING_READY, *PDEVICE_EVENT_BECOMING_READY;

//
// Sent when the user presses the eject button on the front of the drive,
// or when other buttons on the front are pressed via GESN command polling
// (GESN support to be added)
//

DEFINE_GUID( GUID_IO_DEVICE_EXTERNAL_REQUEST, 0xd07433d0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_EJECT_REQUEST,     0xd07433d1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_EXTERNAL_REQUEST {
    ULONG  Version;
    ULONG  DeviceClass;       // 0 == MMC Storage Devices
    USHORT ButtonStatus;      // 1 == down, 2 == up
    USHORT Request;
    LARGE_INTEGER SystemTime; // for time-related info
} DEVICE_EVENT_EXTERNAL_REQUEST, *PDEVICE_EVENT_EXTERNAL_REQUEST;

//
// Sent when a tape drive requires cleaning
//
DEFINE_GUID(GUID_IO_DRIVE_REQUIRES_CLEANING, 0x7207877c, 0x90ed, 0x44e5, 0xa0, 0x0, 0x81, 0x42, 0x8d, 0x4c, 0x79, 0xbb);

//
// Sent when a tape is erased
//
DEFINE_GUID(GUID_IO_TAPE_ERASE, 0x852d11eb, 0x4bb8, 0x4507, 0x9d, 0x9b, 0x41, 0x7c, 0xc2, 0xb1, 0xb4, 0x38);

typedef struct _DEVICE_EVENT_GENERIC_DATA {
    ULONG EventNumber;
} DEVICE_EVENT_GENERIC_DATA, *PDEVICE_EVENT_GENERIC_DATA;


//
//  Represents any asynchronous notification coming from a device driver whose
//  notification protocol is RBC
//  Additional data is provided

DEFINE_GUID( GUID_DEVICE_EVENT_RBC, 0xd0744792, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_RBC_DATA {
    ULONG EventNumber;
    UCHAR SenseQualifier;
    UCHAR SenseCode;
    UCHAR SenseKey;
    UCHAR Reserved;
    ULONG Information;
} DEVICE_EVENT_RBC_DATA, *PDEVICE_EVENT_RBC_DATA;

//
//  A clone of this disk has just arrived in the system.
//

DEFINE_GUID( GUID_IO_DISK_CLONE_ARRIVAL, 0x6a61885b, 0x7c39, 0x43dd, 0x9b, 0x56, 0xb8, 0xac, 0x22, 0xa5, 0x49, 0xaa);

typedef struct _GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    ULONG DiskNumber;   // The disk number of the new disk arriving in the system.
} GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION, *PGUID_IO_DISK_CLONE_ARRIVAL_INFORMATION;

//
// The disk layout has changed
//

DEFINE_GUID( GUID_IO_DISK_LAYOUT_CHANGE, 0x11dff54c, 0x8469, 0x41f9, 0xb3, 0xde, 0xef, 0x83, 0x64, 0x87, 0xc5, 0x4a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ipfirewall.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    ipfirewall.h

Abstract:

    Header file for IP firewall hook clients.

--*/

#define INVALID_IF_INDEX        0xffffffff
#define LOCAL_IF_INDEX          0

//
// Indicates whether it is a transmitted or received packet.
//

typedef enum _IP_DIRECTION_E {
    IP_TRANSMIT,
    IP_RECEIVE
} DIRECTION_E, *PDIRECTION_E;

typedef struct _FIREWALL_CONTEXT_T {
    DIRECTION_E Direction;
    void        *NTE;
    void        *LinkCtxt;
    NDIS_HANDLE LContext1;
    UINT        LContext2;
} FIREWALL_CONTEXT_T, *PFIREWALL_CONTEXT_T;

//  Definition of an IP receive buffer chain.
typedef struct IPRcvBuf {
    struct IPRcvBuf *ipr_next;          // Next buffer descriptor in chain.
    UINT            ipr_owner;          // Owner of buffer.
    UCHAR           *ipr_buffer;        // Pointer to buffer.
    UINT            ipr_size;           // Buffer size.
    PMDL            ipr_pMdl;
    UINT            *ipr_pClientCnt;
    UCHAR           *ipr_RcvContext;
    UINT            ipr_RcvOffset;
    ULONG           ipr_flags;
} IPRcvBuf;

#define IPR_FLAG_CHECKSUM_OFFLOAD   0x00000002

//
// Enum for values that may be returned from filter routine.
//

typedef enum _FORWARD_ACTION {
    FORWARD         = 0,
    DROP            = 1,
    ICMP_ON_DROP    = 2
} FORWARD_ACTION;


// Definiton for a firewall routine callout.
typedef FORWARD_ACTION
(*IPPacketFirewallPtr)(
    VOID        **pData,
    UINT        RecvInterfaceIndex,
    UINT        *pSendInterfaceIndex,
    UCHAR       *pDestinationType,
    VOID        *pContext,
    UINT        ContextLength,
    IPRcvBuf    **ppRcvBuf
    );

extern
int
IPAllocBuff(
    IPRcvBuf    *pRcvBuf,
    UINT        Size
    );

extern
VOID
IPFreeBuff(
    IPRcvBuf    *pRcvBuf
    );

extern
VOID
FreeIprBuff(
    IPRcvBuf    *pRcvBuf
    );

typedef enum _IPROUTEINFOCLASS {
    IPRouteNoInformation,
    IPRouteOutgoingFirewallContext,
    IPRouteOutgoingFilterContext,
    MaxIPRouteInfoClass
} IPROUTEINFOCLASS;

extern
NTSTATUS
LookupRouteInformation(
    IN      VOID*               RouteLookupData,
    OUT     VOID*               RouteEntry OPTIONAL,
    IN      IPROUTEINFOCLASS    RouteInfoClass OPTIONAL,
    OUT     VOID*               RouteInformation OPTIONAL,
    IN OUT  UINT*               RouteInfoLength OPTIONAL
    );

// Structure passed to the IPSetFirewallHook call

typedef struct _IP_SET_FIREWALL_HOOK_INFO {
    IPPacketFirewallPtr FirewallPtr;    // Packet filter callout.
    UINT                Priority;       // Priority of the hook
    BOOLEAN             Add;            // if TRUE then ADD else DELETE
} IP_SET_FIREWALL_HOOK_INFO, *PIP_SET_FIREWALL_HOOK_INFO;


#define DEST_LOCAL          0           // Destination is local.
#define DEST_BCAST          0x01        // Destination is net or local bcast.
#define DEST_SN_BCAST       0x03        // A subnet bcast.
#define DEST_MCAST          0x05        // A local mcast.
#define DEST_REMOTE         0x08        // Destination is remote.
#define DEST_REM_BCAST      0x0b        // Destination is a remote broadcast
#define DEST_REM_MCAST      0x0d        // Destination is a remote mcast.
#define DEST_INVALID        0xff        // Invalid destination

#define DEST_PROMIS         0x20        // Dest is promiscuous

#define DEST_BCAST_BIT      0x01
#define DEST_OFFNET_BIT     0x10        // Destination is offnet -
                                        // used only by upper layer
                                        // callers.
#define DEST_MCAST_BIT      0x05

#define DD_IP_DEVICE_NAME   L"\\Device\\Ip"

#define FSCTL_IP_BASE       FILE_DEVICE_NETWORK

#define _IP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IP_BASE, function, method, access)

#define IOCTL_IP_SET_FIREWALL_HOOK  \
            _IP_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ksdebug.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksdebug.h

Abstract:

    Debug header.

--*/

#if !defined(_KSDEBUG_)
#define _KSDEBUG_

#if !defined(REMIND)

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

#endif // !defined(REMIND)

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined(_NTDDK_)

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if (DBG)
   #if !defined( DEBUG_LEVEL )
        #if defined( DEBUG_VARIABLE )
            #if defined( KSDEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUGLVL_TERSE;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUGLVL_TERSE
        #endif
   #else
        #if defined( DEBUG_VARIABLE )
            #if defined( KSDEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUG_LEVEL;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUG_LEVEL
        #endif
   #endif

   #define _DbgPrintF(lvl, strings) \
{ \
    if (((lvl)==DEBUG_VARIABLE) || (lvl < DEBUG_VARIABLE)) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        DbgPrint("\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}

   #define _DbgPrintFEx(component, lvl, strings) \
{ \
    if ((lvl) <= DEBUG_VARIABLE) {\
        DbgPrintEx(component, lvl, STR_MODULENAME);\
        DbgPrintEx(component, lvl, strings);\
        DbgPrintEx(component, lvl, "\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}
#else // !DBG
   #define _DbgPrintF(lvl, strings)
   #define _DbgPrintFEx(component, lvl, strings)
#endif // !DBG

#endif // !defined(_NTDDK_)

//
// macros
//

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

//
// constants
//

#if (DBG)

#if defined(IRPMJFUNCDESC)
static const PCHAR IrpMjFuncDesc[] =
{
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_SET_POWER",
   "IRP_MJ_QUERY_POWER"
};
#endif // defined(IRPMJFUNCDESC)

#endif // DBG

#endif // !_KSDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\kcom.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation.

Module Name:

    kcom.h

Abstract:

    Kernel COM

--*/

#if !defined(_KS_)
#error KS.H must be included before KCOM.H
#endif // !defined(_KS_)

#if !defined(_KCOM_)
#define _KCOM_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#define STATIC_KoCreateObject \
    0x72CF721CL, 0x525A, 0x11D1, 0x9A, 0xA1, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("72CF721C-525A-11D1-9AA1-00A0C9223196", KoCreateObject);

#define KOSTRING_CreateObject L"{72CF721C-525A-11D1-9AA1-00A0C9223196}"

#ifndef CLSCTX_KERNEL_SERVER
#define CLSCTX_KERNEL_SERVER    0x00000200
#endif

typedef
NTSTATUS
(*KoCreateObjectHandler)(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );

#undef INTERFACE
#define INTERFACE INonDelegatedUnknown
DECLARE_INTERFACE(INonDelegatedUnknown) {
    STDMETHOD(NonDelegatedQueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;

    STDMETHOD_(ULONG,NonDelegatedAddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG,NonDelegatedRelease)(
        THIS
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IIndirectedUnknown
DECLARE_INTERFACE(IIndirectedUnknown) {
    STDMETHOD(IndirectedQueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;

    STDMETHOD_(ULONG,IndirectedAddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG,IndirectedRelease)(
        THIS
        ) PURE;
};

#if !defined(__cplusplus) || _MSC_VER < 1100
#define STATIC_IID_IKoInitializeParentDeviceObject\
    0x21B36996L, 0x8DE3, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDEX(IID_IKoInitializeParentDeviceObject);
#else
interface __declspec(uuid("21B36996-8DE3-11D1-8AE0-00A0C9223196")) IKoInitializeParentDeviceObject;
#endif
#undef INTERFACE
#define INTERFACE IKoInitializeParentDeviceObject
DECLARE_INTERFACE_(IKoInitializeParentDeviceObject, IUnknown) {
    STDMETHOD(SetParentDeviceObject)(
        THIS_
        IN PDEVICE_OBJECT ParentDeviceObject
        ) PURE;
};

#ifndef COMDDKMETHOD
#ifdef _COMDDK_
#define COMDDKMETHOD
#else // !_COMDDK_
#define COMDDKMETHOD DECLSPEC_IMPORT
#endif // _COMDDK_
#endif // !COMDDKMETHOD

#ifdef _COMDDK_
#define COMDDKAPI
#else // !_COMDDK_
#define COMDDKAPI DECLSPEC_IMPORT
#endif // _COMDDK_

#if defined(__cplusplus)
class CBaseUnknown : public INonDelegatedUnknown, public IIndirectedUnknown {

protected:
    LONG m_RefCount;

private:
    BOOLEAN m_UsingClassId;
    CLSID m_ClassId;

protected:
    IUnknown* m_UnknownOuter;

public:
    COMDDKMETHOD CBaseUnknown(
        IN REFCLSID ClassId,
        IN IUnknown* UnknownOuter OPTIONAL = NULL
        );
    COMDDKMETHOD CBaseUnknown(
        IN IUnknown* UnknownOuter OPTIONAL = NULL
        );
    COMDDKMETHOD virtual ~CBaseUnknown();

    // INonDelegatedUnknown
    COMDDKMETHOD STDMETHODIMP_(ULONG) NonDelegatedAddRef();
    COMDDKMETHOD STDMETHODIMP_(ULONG) NonDelegatedRelease();
    COMDDKMETHOD STDMETHODIMP NonDelegatedQueryInterface(
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );

    //IIndirectedUnknown
    COMDDKMETHOD STDMETHODIMP_(ULONG) IndirectedAddRef();
    COMDDKMETHOD STDMETHODIMP_(ULONG) IndirectedRelease();
    COMDDKMETHOD STDMETHODIMP IndirectedQueryInterface(
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
};

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD(QueryInterface)(THIS_                             \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_STD_UNKNOWN()                                    \
    STDMETHODIMP NonDelegatedQueryInterface(                    \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
    );                                                          \
    STDMETHODIMP QueryInterface(                                \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        );                                                      \
    STDMETHODIMP_(ULONG) AddRef();                              \
    STDMETHODIMP_(ULONG) Release();

#define IMPLEMENT_STD_UNKNOWN(Class)                            \
    STDMETHODIMP Class::QueryInterface(                         \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        )                                                       \
    {                                                           \
        return m_UnknownOuter->QueryInterface(InterfaceId, Interface);\
    }                                                           \
    STDMETHODIMP_(ULONG) Class::AddRef()                        \
    {                                                           \
        return m_UnknownOuter->AddRef();                        \
    }                                                           \
    STDMETHODIMP_(ULONG) Class::Release()                       \
    {                                                           \
        return m_UnknownOuter->Release();                       \
    }
#else // !__cplusplus
COMDDKAPI
void
NTAPI
KoRelease(
    IN REFCLSID ClassId
    );
#endif // !__cplusplus

COMDDKAPI
NTSTATUS
NTAPI
KoCreateInstance(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN ULONG ClsContext,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );
COMDDKAPI
NTSTATUS
NTAPI
KoDriverInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN KoCreateObjectHandler CreateObjectHandler
    );
COMDDKAPI
NTSTATUS
NTAPI
KoDeviceInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#ifdef __cplusplus

#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'wNCK');

    if (result) {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result) {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}

#endif //!_NEW_DELETE_OPERATORS_

#if defined(_SYS_GUID_OPERATOR_EQ_)
// Define _SYS_GUID_OPERATOR_EQ_ before including guiddef.h to get the aligned guid test.
#define _GUID_OPERATORS_
#pragma message("WARNING: Using system operator==/!= for GUIDs")
#endif

#ifndef _GUID_OPERATORS_
#define _GUID_OPERATORS_

__inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
    return IsEqualGUIDAligned(guidOne,guidOther);
}
__inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

#endif // _GUID_OPERATORS_

#endif // __cplusplus

#endif // !_KCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mce.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    mce.h

Abstract:

    This header file defines the Machine Check Errors definitions.

Author:

    David N. Cutler (davec) 


Revision History:

    Creation: 04-Apr-2001

--*/

#ifndef _MCE_
#define _MCE_

//
// HalMcaLogInformation
//

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// ADDR register for each MCA bank
//

typedef union _MCI_ADDR{
    struct {
        ULONG Address;
        ULONG Reserved;
    };

    ULONGLONG   QuadPart;
} MCI_ADDR, *PMCI_ADDR;


typedef enum {
    HAL_MCE_RECORD,
    HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;


#if defined(_AMD64_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaErrorCode;
        USHORT  ModelErrorCode;
        ULONG   OtherInformation : 25;
        ULONG   ContextCorrupt : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   ErrorEnabled : 1;
        ULONG   UncorrectedError : 1;
        ULONG   StatusOverFlow : 1;
        ULONG   Valid : 1;
    } MciStatus;

    ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif // _AMD64_

#if defined(_X86_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // _X86_

//
// MCA exception log entry
// Defined as a union to contain MCA specific log or Pentium style MCE info.
//

#define MCA_EXTREG_V2MAX       24  // X86: Max. Number of extended registers

#if defined(_X86_) || defined(_AMD64_)

typedef struct _MCA_EXCEPTION {

    // Begin Version 1 stuff
    ULONG               VersionNumber;      // Version number of this record type
    MCA_EXCEPTION_TYPE  ExceptionType;      // MCA or MCE
    LARGE_INTEGER       TimeStamp;          // exception recording timestamp
    ULONG               ProcessorNumber;
    ULONG               Reserved1;

    union {
        struct {
            UCHAR           BankNumber;
            UCHAR           Reserved2[7];
            MCI_STATS       Status;
            MCI_ADDR        Address;
            ULONGLONG       Misc;
        } Mca;

        struct {
            ULONGLONG       Address;        // physical addr of cycle causing the error
            ULONGLONG       Type;           // cycle specification causing the error
        } Mce;
    } u;
    // End   Version 1 stuff

#if defined(_X86_)

    // Begin Version 2 stuff
    ULONG                   ExtCnt;
    ULONG                   Reserved3;
    ULONGLONG               ExtReg[MCA_EXTREG_V2MAX];
    // End   Version 2 stuff

#endif

} MCA_EXCEPTION, *PMCA_EXCEPTION;

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#if defined(_X86_)

#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)

#endif

#endif // _X86_ || _AMD64_

//
// ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this
// type of enums (UCHAR, __int64) could be defined...
//

#if defined(_AMD64_) || defined(_IA64_)

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE  {
    ErrorRecoverable = 0,
    ErrorFatal       = 1,
    ErrorCorrected   = 2,
    ErrorOthers      = 3,   // [3,...] values are reserved
} ERROR_SEVERITY_VALUE;

#endif

#if defined(_IA64_)

#if 0
// FIXFIX: This should not be required for IA64.
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // 0

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION, *PERROR_REVISION;

// For Info:
#define ERROR_MAJOR_REVISION_SAL_03_00 0
#define ERROR_MINOR_REVISION_SAL_03_00 2
#define ERROR_REVISION_SAL_03_00 { ERROR_MINOR_REVISION_SAL_03_00, \
                                   ERROR_MAJOR_REVISION_SAL_03_00 }

//
// Section Header revision is fixed at Major == 2 and Minor == 0
//
#define ERROR_FIXED_SECTION_REVISION { 2,\
                                       0 }

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day
        UCHAR   Month;    // Byte5: Month
        UCHAR   Year;     // Byte6: Year
        UCHAR   Century;  // Byte7: Century
    };
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

//
// IA64 ERRORS: ERROR_GUID definitions
//

typedef struct _ERROR_GUID   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_GUID, *PERROR_GUID;

//
// IA64 ERRORS: ERROR GUIDs definitions
//

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

//
// IA64 ERRORS: ERROR_RECORD_HEADER definitions
//

typedef union _ERROR_RECORD_VALID   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved 
    };
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER { // Offsets:
    ULONGLONG          Id;                //   0: Unique identifier
    ERROR_REVISION     Revision;          //   8: Major and Minor revision number of the record
    ERROR_SEVERITY     ErrorSeverity;     //  10: Error Severity
    ERROR_RECORD_VALID Valid;             //  11: Validation bits
    ULONG              Length;            //  12: Length of this record in bytes, including the header
    ERROR_TIMESTAMP    TimeStamp;         //  16: Timestamp recorded when event occured
    UCHAR              OemPlatformId[16]; //  24: Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER    {
    ERROR_DEVICE_GUID   Guid;         // Unique identifier
    ERROR_REVISION      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO RecoveryInfo; // Recovery Information
    UCHAR               Reserved;
    ULONG               Length;       // Length of this error device section in bytes, 
                                      // including the header.
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//

#if !defined(__midl)
__inline
USHORT
GetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    USHORT lid = (USHORT)((UCHAR)(section->Reserved));
    lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
    return( lid );
} // GetFwMceLogProcessorNumber()
#endif // !__midl

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//
// The MCA architecture supports five different types of error reporting functional units
// with the associated error records and its error severity. 
// At any point in time, a processor could encounter an MCA/CMC event due to errors detected 
// in one or more of the following units:
//  - Cache Check
//  - TLB   Check
//  - Bus   Check
//  - Register File
//  - Micro Architectural
//
// Terminology:
//
//  - Target Address:
//      64-bit integer containing the physical address where the data was to be delivered or
//      obtained. This could also be the incoming address for external snoops and TLB shoot-downs.
//
//  - Requestor Identifier:
//      64-bit integer specifying the bus agent that generated the transaction responsible for
//      the Machine Check event.
//                    
//  - Responder Identifier:
//      64-bit integer specifying the bus agent that responded to a transaction responsible for
//      the Machine Check event.
//                    
//  - Precise Instruction Pointer:
//      64-bit integer specifying the virtual address that points to the IA-64 bundle that 
//      contained the instruction responsible for the Machine Check event.
//                    

#define ERROR_PROCESSOR_GUID \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MODINFO_VALID  {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG CheckInfo: 1;             //       0:
        ULONGLONG RequestorIdentifier: 1;   //       1:
        ULONGLONG ResponderIdentifier: 1;   //       2:
        ULONGLONG TargetIdentifier: 1;      //       3:
        ULONGLONG PreciseIP: 1;             //       4:
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS    {
    isIA64 = 0,
    isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION   {
    CacheUnknownOp = 0,
    CacheLoad  = 1,
    CacheStore = 2,
    CacheInstructionFetch = 3,
    CacheDataPrefetch = 4,
    CacheSnoop = 5,
    CacheCastOut = 6,
    CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI    {
    CacheInvalid = 0,
    CacheHeldShared = 1,
    CacheHeldExclusive = 2,
    CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

typedef union _ERROR_CACHE_CHECK    {
    ULONGLONG CacheCheck;
    struct
    {
        ULONGLONG Operation:4;             // bits  0- 3: Cache operation
        ULONGLONG Level:2;                 //       4- 5: Cache Level
        ULONGLONG Reserved1:2;             //       6- 7
        ULONGLONG DataLine:1;              //       8   : Failure data part of cache line
        ULONGLONG TagLine:1;               //       9   : Failure tag part of cache line
        ULONGLONG DataCache:1;             //      10   : Failure in data cache
        ULONGLONG InstructionCache:1;      //      11   : Failure in instruction cache
        ULONGLONG MESI:3;                  //      12-14:
        ULONGLONG MESIValid:1;             //      15   : MESI field is valid
        ULONGLONG Way:5;                   //      16-20: Failure in Way of Cache
        ULONGLONG WayIndexValid:1;         //      21   : Way and Index fields valid
        ULONGLONG Reserved2:10;            //      22-31
        ULONGLONG Index:20;                //      32-51: Index of cache line
        ULONGLONG Reserved3:2;             //      52-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

typedef enum _ERROR_TLB_CHECK_OPERATION   {
    TlbUnknownOp = 0,
    TlbAccessWithLoad  = 1,
    TlbAccessWithStore = 2,
    TlbAccessWithInstructionFetch = 3,
    TlbAccessWithDataPrefetch = 4,
    TlbShootDown = 5,
    TlbProbe = 6,
    TlbVhptFill = 7,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK  {
    ULONGLONG TlbCheck;
    struct
    {
        ULONGLONG TRSlot:8;                // bits  0- 7: Slot number of Translation Register
        ULONGLONG TRSlotValid:1;           //       8   : TRSlot field is valid
        ULONGLONG Reserved1:1;             //       9
        ULONGLONG Level:2;                 //      10-11: TLB Level
        ULONGLONG Reserved2:4;             //      12-15
        ULONGLONG DataTransReg:1;          //      16   : Error in data translation register
        ULONGLONG InstructionTransReg:1;   //      17   : Error in instruction translation register
        ULONGLONG DataTransCache:1;        //      18   : Error in data translation cache
        ULONGLONG InstructionTransCache:1; //      19   : Error in instruction translation cache
        ULONGLONG Operation:4;             //      20-23: Operation
        ULONGLONG Reserved3:30;            //      24-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION   {
    BusUnknownOp = 0,
    BusPartialRead  = 1,
    BusPartialWrite = 2,
    BusFullLineRead = 3,
    BusFullLineWrite = 4,
    BusWriteBack = 5,
    BusSnoopProbe = 6,
    BusIncomingPtcG = 7,
    BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

typedef union _ERROR_BUS_CHECK  {
    ULONGLONG BusCheck;
    struct
    {
        ULONGLONG Size:5;                  // bits  0- 4: Transaction size
        ULONGLONG Internal:1;              //       5   : Internal bus error
        ULONGLONG External:1;              //       6   : External bus error
        ULONGLONG CacheTransfer:1;         //       7   : Error occured in Cache to Cache Transfer 
        ULONGLONG Type:8;                  //       8-15: Transaction type
        ULONGLONG Severity:5;              //      16-20: Error severity - platform specific
        ULONGLONG Hierarchy:2;             //      21-22: Level or Bus hierarchy
        ULONGLONG Reserved1:1;             //      23
        ULONGLONG Status:8;                //      24-31: Bus error status - processor bus specific
        ULONGLONG Reserved2:22;            //      32-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER   {
    RegFileUnknownId = 0,
    GeneralRegisterBank1 = 1,
    GeneralRegisterBank0 = 2,
    FloatingPointRegister = 3,
    BranchRegister = 4,
    PredicateRegister = 5,
    ApplicationRegister = 6,
    ControlRegister = 7,
    RegionRegister = 8,
    ProtectionKeyRegister = 9,
    DataBreakPointRegister = 10,
    InstructionBreakPointRegister = 11,
    PerformanceMonitorControlRegister = 12,
    PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION   {
    RegFileUnknownOp = 0,
    RegFileRead = 1,
    RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK  {
    ULONGLONG RegFileCheck;
    struct
    {
        ULONGLONG Identifier:4;            // bits  0- 3: Register file identifier
        ULONGLONG Operation:4;             //       4- 7: Operation that causes the MC event
        ULONGLONG RegisterNumber:7;        //       8-14: Register number responsible for MC event
        ULONGLONG RegisterNumberValid:1;   //      15   : Register number field is valid
        ULONGLONG Reserved1:38;            //      16-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG Reserved2:3;             //      60-62
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

typedef enum _ERROR_MS_CHECK_OPERATION   {
    MsUnknownOp = 0,
    MsReadOrLoad = 1,
    MsWriteOrStore = 2,
	MsOverTemperature = 3,
	MsNormalTemperature = 4
} ERROR_MS_CHECK_OPERATION;

typedef union _ERROR_MS_CHECK  {
    ULONGLONG MsCheck;
    struct
    {
        ULONGLONG StructureIdentifier:5;   // bits  0- 4: Structure Identifier - impl. specific
        ULONGLONG Level:3;                 //       5- 7: Structure Level where error was generated
        ULONGLONG ArrayId:4;               //       8-11: Identification of the array 
        ULONGLONG Operation:4;             //      12-15: Operation
        ULONGLONG Way:6;                   //      16-21: Way where the error was located
        ULONGLONG WayValid:1;              //      22   : Way field is valid
        ULONGLONG IndexValid:1;            //      23   : Index field is valid
        ULONGLONG Reserved1:8;             //      24-31
        ULONGLONG Index:8;                 //      32-39: Index where the error was located
        ULONGLONG Reserved2:14;            //      40-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO   {
    ULONGLONG             CheckInfo;
    ERROR_CACHE_CHECK     CacheCheck;
    ERROR_TLB_CHECK       TlbCheck;
    ERROR_BUS_CHECK       BusCheck;
    ERROR_REGFILE_CHECK   RegFileCheck;
    ERROR_MS_CHECK        MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO   {
    ERROR_MODINFO_VALID Valid;
    ERROR_CHECK_INFO    CheckInfo;
    ULONGLONG           RequestorId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;      
    };
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
    ULONGLONG   StateParameter;
    struct {
        ULONGLONG reserved0:2;  //   0-1 : reserved
        ULONGLONG rz:1;         //     2 : Rendez-vous successful
        ULONGLONG ra:1;         //     3 : Rendez-vous attempted
        ULONGLONG me:1;         //     4 : Distinct Multiple errors
        ULONGLONG mn:1;         //     5 : Min-state Save Area registered
        ULONGLONG sy:1;         //     6 : Storage integrity synchronized
        ULONGLONG co:1;         //     7 : Continuable
        ULONGLONG ci:1;         //     8 : Machine Check isolated
        ULONGLONG us:1;         //     9 : Uncontained Storage damage
        ULONGLONG hd:1;         //    10 : Hardware damage
        ULONGLONG tl:1;         //    11 : Trap lost
        ULONGLONG mi:1;         //    12 : More Information
        ULONGLONG pi:1;         //    13 : Precise Instruction pointer
        ULONGLONG pm:1;         //    14 : Precise Min-state Save Area
        ULONGLONG dy:1;         //    15 : Processor Dynamic State valid
        ULONGLONG in:1;         //    16 : INIT interruption
        ULONGLONG rs:1;         //    17 : RSE valid
        ULONGLONG cm:1;         //    18 : Machine Check corrected
        ULONGLONG ex:1;         //    19 : Machine Check expected
        ULONGLONG cr:1;         //    20 : Control Registers valid
        ULONGLONG pc:1;         //    21 : Performance Counters valid
        ULONGLONG dr:1;         //    22 : Debug Registers valid
        ULONGLONG tr:1;         //    23 : Translation Registers valid
        ULONGLONG rr:1;         //    24 : Region Registers valid
        ULONGLONG ar:1;         //    25 : Application Registers valid
        ULONGLONG br:1;         //    26 : Branch Registers valid
        ULONGLONG pr:1;         //    27 : Predicate Registers valid
        ULONGLONG fp:1;         //    28 : Floating-Point Registers valid
        ULONGLONG b1:1;         //    29 : Preserved Bank 1 General Registers valid
        ULONGLONG b0:1;         //    30 : Preserved Bank 0 General Registers valid
        ULONGLONG gr:1;         //    31 : General Registers valid
        ULONGLONG dsize:16;     // 47-32 : Processor Dynamic State size
        ULONGLONG reserved1:11; // 48-58 : reserved
        ULONGLONG cc:1;         //    59 : Cache Check
        ULONGLONG tc:1;         //    60 : TLB   Check
        ULONGLONG bc:1;         //    61 : Bus   Check
        ULONGLONG rc:1;         //    62 : Register File Check
        ULONGLONG uc:1;         //    63 : Micro-Architectural Check
    };
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;
    
typedef union _PROCESSOR_LOCAL_ID  {
    ULONGLONG LocalId;
    struct {
        ULONGLONG reserved:16;  //  0-16 : reserved
        ULONGLONG eid:8;        // 16-23 : Extended Id 
        ULONGLONG id:8;         // 24-31 : Id
        ULONGLONG ignored:32;   // 32-63 : ignored
    };
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;                                       

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
    ULONGLONG     Valid;
    struct {                                // Bits
        // Warning: Match the VALID fields with the _ERROR_PROCESSOR_STATIC_INFO members.
        //          KD extensions use the field names to access the PSI structure.
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BR: 1;                    //       1: Branch      Registers valid.
        ULONGLONG CR: 1;                    //       2: Control     Registers valid.
        ULONGLONG AR: 1;                    //       3: Application Registers valid.
        ULONGLONG RR: 1;                    //       4:             Registers valid.
        ULONGLONG FR: 1;                    //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO  {
    ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
    ERROR_SECTION_HEADER              Header;
    ERROR_PROCESSOR_VALID             Valid;
    ERROR_PROCESSOR_ERROR_MAP         ErrorMap;
    ERROR_PROCESSOR_STATE_PARAMETER   StateParameter;
    PROCESSOR_LOCAL_ID                CRLid;
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

//
// IA64 ERROR PROCESSOR State Parameter - GR18 - definitions.
//

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT         59
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK          0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT           60
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT           61
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_SHIFT           62
#define ERROR_PROCESSOR_STATE_PARAMETER_REG_CHECK_MASK            0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT     63
#define ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK      0x1

//
// For legacy consumers
//
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT       ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_SHIFT
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK        ERROR_PROCESSOR_STATE_PARAMETER_MICROARCH_CHECK_MASK

////////////////////////////////////////////////////////////////////
//
// IA64 PLATFORM ERRORS Definitions
//
// We tried to respect the order in which these error devices are 
// presented in the SAL specs.

//
// IA64 ERRORS: _ERR_TYPE definitions
//
// Warning 04/01/01: "ERR_TYPE" or "ERROR_TYPE" are already used in the NT namespace.
//

typedef enum _ERR_TYPES    {
// Generic error types:
    ERR_INTERNAL = 1,         // Error detected internal to the component
    ERR_BUS      = 16,        // Error detected in the bus
// Detailed Internal Error Types:
    ERR_MEM      = 4,         // Storage error in memory (DRAM)
    ERR_TLB      = 5,         // Storage error in TLB
    ERR_CACHE    = 6,         // Storage error in cache
    ERR_FUNCTION = 7,         // Error in one or more functional units
    ERR_SELFTEST = 8,         // Component failed self test
    ERR_FLOW     = 9,         // Overflow or Undervalue of internal queue
// Detailed Bus Error Types:
    ERR_MAP      = 17,        // Virtual address not found on IO-TLB or IO-PDIR
    ERR_IMPROPER = 18,        // Improper access error
    ERR_UNIMPL   = 19,        // Access to a memory address which is not mapped to any component
    ERR_LOL      = 20,        // Loss Of Lockstep
    ERR_RESPONSE = 21,        // Response to which there is no associated request
    ERR_PARITY   = 22,        // Bus parity error
    ERR_PROTOCOL = 23,        // Detection of a protocol error
    ERR_ERROR    = 24,        // Detection of PATH_ERROR
    ERR_TIMEOUT  = 25,        // Bus operation time-out
    ERR_POISONED = 26,        // A read was issued to data which has been poisoned
} _ERR_TYPE;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highest severity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow 
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS, *PERROR_STATUS;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

//
// IA64 ERRORS: Platform ERROR_MEMORY device definitions
//
// With reference to the ACPI Memory Device.
//

#define ERROR_MEMORY_GUID \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MEMORY_VALID    {
    ULONGLONG     Valid;
    struct {                                 // Bits
        ULONGLONG ErrorStatus:1;             //       0: Error Status valid bit
        ULONGLONG PhysicalAddress:1;         //       1: Physical Address valid bit
        ULONGLONG AddressMask:1;             //       2: Address Mask bit
        ULONGLONG Node:1;                    //       3: Node valid bit
        ULONGLONG Card:1;                    //       4: Card valid bit
        ULONGLONG Module:1;                  //       5: Module valid bit
        ULONGLONG Bank:1;                    //       6: Bank valid bit
        ULONGLONG Device:1;                  //       7: Device valid bit
        ULONGLONG Row:1;                     //       8: Row valid bit
        ULONGLONG Column:1;                  //       9: Column valid bit
        ULONGLONG BitPosition:1;             //      10: Bit Position valid bit
        ULONGLONG RequestorId:1;             //      11: Platform Requestor Id valid bit
        ULONGLONG ResponderId:1;             //      12: Platform Respinder Id valid bit
        ULONGLONG TargetId:1;                //      13: Platform Target    Id valid bit
        ULONGLONG BusSpecificData:1;         //      14: Platform Bus specific data valid bit
        ULONGLONG OemId:1;                   //      15: Platform OEM id   valid bit
        ULONGLONG OemData:1;                 //      16: Platform OEM data valid bit
        ULONGLONG Reserved:47;               //   63-17: Reserved
    };
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY    {
    ERROR_SECTION_HEADER  Header;
    ERROR_MEMORY_VALID    Valid;
    ERROR_STATUS          ErrorStatus;         // Memory device error status fields - See ERROR_STATUS defs.
    ULONGLONG             PhysicalAddress;     // Physical Address of the memory error
    ULONGLONG             PhysicalAddressMask; // Valid bits for Physical Address
    USHORT                Node;                // Node identifier in a multi-node system
    USHORT                Card;                // Card   number of the memory error location
    USHORT                Module;              // Module number of the memory error location
    USHORT                Bank;                // Bank   number of the memory error location
    USHORT                Device;              // Device number of the memory error location
    USHORT                Row;                 // Row    number of the memory error location
    USHORT                Column;              // Column number of the memory error location
    USHORT                BitPosition;         // Bit within the word that is in error
    ULONGLONG             RequestorId;         // Hardware address of the device or component initiating transaction
    ULONGLONG             ResponderId;         // Hardware address of the responder to transaction
    ULONGLONG             TargetId;            // Hardware address of intended target of transaction       
    ULONGLONG             BusSpecificData;     // Bus dependent data of the on-board processor. It is a OEM specific field.
    UCHAR                 OemId[16];           // OEM defined identification for memory controller
    ERROR_OEM_DATA        OemData;     // OEM platform specific data. 
} ERROR_MEMORY, *PERROR_MEMORY;

//
// IA64 ERRORS: Platform ERROR_PCI_BUS device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_BUS_GUID \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_BUS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorStatus:1;            //       0: Error Status             valid bit
        ULONGLONG ErrorType:1;              //       1: Error Type               valid bit
        ULONGLONG Id:1;                     //       2: Identifier               valid bit
        ULONGLONG Address:1;                //       3: Address                  valid bit
        ULONGLONG Data:1;                   //       4: Data                     valid bit
        ULONGLONG CmdType:1;                //       5: Command Type             valid bit
        ULONGLONG RequestorId:1;            //       6: Requestor Identifier     valid bit
        ULONGLONG ResponderId:1;            //       7: Responder Identifier     valid bit
        ULONGLONG TargetId:1;               //       8: Target    Identifer      valid bit
        ULONGLONG OemId:1;                  //       9: OEM Identification       valid bit
        ULONGLONG OemData:1;                //      10: OEM Data                 valid bit
        ULONGLONG Reserved:53;              //   11-63: Reserved
    };
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
    UCHAR Type;
    UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)
//      PciOtherErrors           Reserved

typedef struct _ERROR_PCI_BUS_ID    {
    UCHAR BusNumber;         // Bus     Number
    UCHAR SegmentNumber;     // Segment Number
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS    {
    ERROR_SECTION_HEADER  Header;
    ERROR_PCI_BUS_VALID   Valid;
    ERROR_STATUS          ErrorStatus;    // PCI Bus Error Status - See ERROR_STATUS definitions.
    ERROR_PCI_BUS_TYPE    Type;           // PCI Bus Error Type 
    ERROR_PCI_BUS_ID      Id;             // PCI Bus Identifier      
    UCHAR                 Reserved[4];    // Reserved
    ULONGLONG             Address;        // Memory or IO Address on the PCI bus at
                                          // the time of the event
    ULONGLONG             Data;           // Data on the PCI bus at time of the event
    ULONGLONG             CmdType;        // Bus Command or Operation at time of the event
    ULONGLONG             RequestorId;    // Bus Requestor Identifier at time of the event
    ULONGLONG             ResponderId;    // Bus Responder Identifier at time of the event
    ULONGLONG             TargetId;       // Intended Bus Target Identifier at time of the event
    UCHAR                 OemId[16];      // OEM defined identification for pci bus
    ERROR_OEM_DATA        OemData;        // OEM specific data. 
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

//
// IA64 ERRORS: Platform ERROR_PCI_COMPONENT device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_COMPONENT_GUID \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_COMPONENT_VALID   {
    ULONGLONG Valid;
    struct {                                       // Bits:
        ULONGLONG ErrorStatus:1;                   //    0: Error Status valid bit
        ULONGLONG Info:1;                          //    1: Information  valid bit
        ULONGLONG MemoryMappedRegistersPairs:1;    //    2: Number of Memory Mapped Registers Pairs valid bit
        ULONGLONG ProgrammedIORegistersPairs:1;    //    3: Number of Programmed IO Registers Pairs valid bit
        ULONGLONG RegistersDataPairs:1;            //    4: Memory Mapped Registers Pairs valid bit
        ULONGLONG OemData:1;                       //    5: OEM Data valid bit.
        ULONGLONG Reserved:58;                     // 63-6: Reserved
    };
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {  // Bytes:
   USHORT VendorId;                         //   0-1: Vendor Identifier
   USHORT DeviceId;                         //   2-3: Device Identifier
   UCHAR  ClassCodeInterface;               //     4: Class Code.Interface field
   UCHAR  ClassCodeSubClass;                //     5: Class Code.SubClass  field
   UCHAR  ClassCodeBaseClass;               //     6: Class Code.BaseClass field
   UCHAR  FunctionNumber;                   //     7: Function Number
   UCHAR  DeviceNumber;                     //     8: Device Number
   UCHAR  BusNumber;                        //     9: Bus Number
   UCHAR  SegmentNumber;                    //    10: Segment Number
   UCHAR  Reserved0;    
   ULONG  Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT  {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;                 // Component Error Status
     ERROR_PCI_COMPONENT_INFO    Info;                        // Component Information
     ULONG                       MemoryMappedRegistersPairs;  // Number of Memory Mapped Registers Pairs
     ULONG                       ProgrammedIORegistersPairs;  // Number of Programmed IO Registers Pairs
#if 0
     ULONGLONG                   RegistersPairs[/* 2 * (MemoryMappedRegistersPairs + ProgrammedIORegistersPairs) */];
     ERROR_OEM_DATA              OemData;
#endif // 0
 } ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

//
// IA64 ERRORS: Platform ERROR_SYSTEM_EVENT_LOG device definitions
//
// With reference to the IPMI System Event Log.
//

#define ERROR_SYSTEM_EVENT_LOG_GUID \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG RecordId:1;               //       0: Record Identifier     valid bit
        ULONGLONG RecordType:1;             //       1: Record Type           valid bit
        ULONGLONG GeneratorId:1;            //       2: Generator Identifier  valid bit
        ULONGLONG EVMRev:1;                 //       3: Event Format Revision valid bit
        ULONGLONG SensorType:1;             //       4: Sensor Type           valid bit
        ULONGLONG SensorNum:1;              //       5: Sensor Number         valid bit
        ULONGLONG EventDirType:1;           //       6: Event Dir             valid bit
        ULONGLONG EventData1:1;             //       7: Event Data1           valid bit
        ULONGLONG EventData2:1;             //       8: Event Data2           valid bit
        ULONGLONG EventData3:1;             //       9: Event Data3           valid bit
        ULONGLONG Reserved:54;              //   10-63:
    };
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG    {
    ERROR_SECTION_HEADER         Header;
    ERROR_SYSTEM_EVENT_LOG_VALID Valid;
    USHORT                       RecordId;     // Record Identifier used for SEL record access
    UCHAR                        RecordType;   // Record Type:
                                               //   0x02 - System Event Record
                                               //   0xC0 - 0xDF OEM     time stamped, bytes 8-16 OEM defined
                                               //   0xE0 - 0xFF OEM non-time stamped, bytes 4-16 OEM defined
    ULONG                        TimeStamp;    // Time stamp of the event log
    USHORT                       GeneratorId;  // Software ID if event was generated by software
                                               //   Byte 1:
                                               //       Bit 0   - set to 1 when using system software
                                               //       Bit 7:1 - 7-bit system ID
                                               //   Byte 2:
                                               //       Bit 1:0 - IPMB device LUN if byte 1 holds slave
                                               //                 address, 0x0 otherwise
                                               //       Bit 7:2 - Reserved.
    UCHAR                        EVMRevision;  // Error message format version
    UCHAR                        SensorType;   // Sensor Type code of the sensor that generated event
    UCHAR                        SensorNumber; // Number of the sensor that generated event
    UCHAR                        EventDir;     // Event Dir
                                               //   Bit 7 - 0: asserted, 1: desasserted
                                               // Event Type
                                               //   Bit 6:0 - Event Type code
    UCHAR                        Data1;        // Event data field
    UCHAR                        Data2;        // Event data field
    UCHAR                        Data3;        // Event data field
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

//
// IA64 ERRORS: Platform ERROR_SMBIOS device definitions
//
// With reference to the SMBIOS Specifications.
//

#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SMBIOS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG EventType:1;              //       0: Event Type valid bit
        ULONGLONG Length:1;                 //       1: Length     valid bit
        ULONGLONG TimeStamp:1;              //       2: Time Stamp valid bit
        ULONGLONG OemData:1;                //       3: Data       valid bit
        ULONGLONG Reserved:60;              //    4-63:
    };
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

//
// ERROR_SMBIOS.Type definitions
//

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;
// enum values defined in SMBIOS 2.3 - 3.3.16.6.1

typedef struct _ERROR_SMBIOS    {
    ERROR_SECTION_HEADER     Header;
    ERROR_SMBIOS_VALID       Valid;
    ERROR_SMBIOS_EVENT_TYPE  EventType;   // Event Type
    UCHAR                    Length;      // Length of the error information in bytes
    ERROR_TIMESTAMP          TimeStamp;   // Event Time Stamp
    ERROR_OEM_DATA           OemData;     // Optional data validated by SMBIOS.Valid.Data.
} ERROR_SMBIOS, *PERROR_SMBIOS;

//
// IA64 ERRORS: Platform Specific error device definitions
//

#define ERROR_PLATFORM_SPECIFIC_GUID \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC  {
     ERROR_SECTION_HEADER           Header;
     ERROR_PLATFORM_SPECIFIC_VALID  Valid;
     ERROR_STATUS                   ErrorStatus; // Platform Generic Error Status
     ULONGLONG                      RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                      ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                      TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA        BusSpecificData; // OEM specific Bus dependent data
     UCHAR                          OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA                 OemData;         // OEM specific data 
#if 0
     UCHAR                          OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

//
// IA64 ERRORS: Platform Bus error device definitions
//

#define ERROR_PLATFORM_BUS_GUID \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_BUS_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
     ERROR_SECTION_HEADER        Header;
     ERROR_PLATFORM_BUS_VALID    Valid;
     ERROR_STATUS                ErrorStatus;       // Bus Error Status
     ULONGLONG                   RequestorId;       // Bus Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Bus Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

//
// IA64 ERRORS: Platform Host Controller error device definitions
//

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}
    

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;       // Host Controller Error Status
     ULONGLONG                   RequestorId;       // Host controller Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Host controller Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Host controller intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

//
// IA64 ERROR_LOGRECORDS definitions
//
//  MCA_EXCEPTION,
//  CMC_EXCEPTION,
//  CPE_EXCEPTION.
//

// For compatibility with previous versions of the definitions:
typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;

typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;    // Machine Check Abort
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#endif // _IA64_

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#endif // _MCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mf.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mf.h

Abstract:

    This header describes the structures and interfaces required to interact
    with the multifunction enumerator.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_MF_)
#define _MF_

//
// MfFlags value
//

#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

typedef struct _MF_RESOURCE_MAP {

    ULONG Count;
    UCHAR Resources[ANYSIZE_ARRAY];

} MF_RESOURCE_MAP, *PMF_RESOURCE_MAP;


typedef struct _MF_VARYING_RESOURCE_ENTRY {

    UCHAR ResourceIndex;
    UCHAR Reserved[3];      // Packing
    ULONG Offset;
    ULONG Size;
    ULONG MaxCount;

} MF_VARYING_RESOURCE_ENTRY, *PMF_VARYING_RESOURCE_ENTRY;


typedef struct _MF_VARYING_RESOURCE_MAP {

    ULONG Count;
    MF_VARYING_RESOURCE_ENTRY Resources[ANYSIZE_ARRAY];

} MF_VARYING_RESOURCE_MAP, *PMF_VARYING_RESOURCE_MAP;


typedef struct _MF_DEVICE_INFO *PMF_DEVICE_INFO;

typedef struct _MF_DEVICE_INFO {

    //
    // Name for this child, unique with respect to the other children
    //
    UNICODE_STRING Name;

    //
    // A REG_MULTI_SZ style list of hardware IDs
    //
    UNICODE_STRING HardwareID;

    //
    // A REG_MULTI_SZ style list of compatible IDs
    //
    UNICODE_STRING CompatibleID;

    //
    // Map of resource that we totally consume
    //
    PMF_RESOURCE_MAP ResourceMap;

    //
    // Map of resource that we partially consume
    //
    PMF_VARYING_RESOURCE_MAP VaryingResourceMap;

    //
    // Flags -
    //      MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE - if the parent resource doesn't
    //          contain a descriptor referenced in the ResourceMap use a
    //          null (CmResourceTypeNull) descriptor instead.
    //
    ULONG MfFlags;

} MF_DEVICE_INFO;

typedef
NTSTATUS
(*PMF_ENUMERATE_CHILD)(
    IN PVOID Context,
    IN ULONG Index,
    OUT PMF_DEVICE_INFO ChildInfo
    );

/*++


Routine Description:

    This returns information about children to be enumerated by a multifunction
    driver.

Arguments:

    Context - Context from the MF_ENUMERATION_INTERFACE

    Index - Zero based index of the children

    ChildInfo - Pointer to a caller allocated buffer that should be filled in
        by the callee.  This will involve allocation of extra buffers for each
        piece of information.  These will be freed by calling ExFreePool when
        they are no longer required.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NO_MORE_ENTRIES indicates that the are no more children to enumerate

--*/

typedef struct _MF_ENUMERATION_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Multi-function enumeration data
    //
    PMF_ENUMERATE_CHILD EnumerateChild;

} MF_ENUMERATION_INTERFACE, *PMF_ENUMERATION_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mcd.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    mcd.h

Abstract:

    These are the structures and defines that are used in the
    changer class drivers. The changer class driver is separated
    into two modules. Mcd.c contains code common to all medium
    changer drivers including the driver's major entry points.

Author:

    chuckp (Chuck Park)

Environment:

    Kernel mode

Revision History :

--*/


#include "scsi.h"
#include "ntddchgr.h"
#include <classpnp.h>

#include <wmidata.h>
#include <wmistr.h>

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) ChangerClassDebugPrint x
#else
#define DebugPrint(x)
#endif

#define MAXIMUM_CHANGER_INQUIRY_DATA 252

typedef
NTSTATUS
(*CHANGER_COMMAND_ROUTINE)(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );

typedef 
ULONG
(*CHANGER_EXTENSION_SIZE)(
    IN VOID
    );

typedef 
NTSTATUS
(*CHANGER_INITIALIZE)(
    IN PDEVICE_OBJECT DeviceObject
    );

typedef 
NTSTATUS
(*CHANGER_PERFORM_DIAGNOSTICS)(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );

typedef
VOID
(*CHANGER_ERROR_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN NTSTATUS *Status,
    IN BOOLEAN *Retry
    );

typedef struct _MCD_INIT_DATA {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // To return the size of the minidriver extension
    //

    CHANGER_EXTENSION_SIZE ChangerAdditionalExtensionSize;

    //
    // To perform minidriver specific initialization
    //

    CHANGER_INITIALIZE     ChangerInitialize;

    //
    // To perform minidriver specific error processing
    //

    CHANGER_ERROR_ROUTINE  ChangerError;

    //
    // To perform diagnostic tests on the device
    //

    CHANGER_PERFORM_DIAGNOSTICS ChangerPerformDiagnostics;

    //
    // Minidriver dispatch routines
    //

    CHANGER_COMMAND_ROUTINE   ChangerGetParameters;

    CHANGER_COMMAND_ROUTINE   ChangerGetStatus;

    CHANGER_COMMAND_ROUTINE   ChangerGetProductData;

    CHANGER_COMMAND_ROUTINE   ChangerSetAccess;

    CHANGER_COMMAND_ROUTINE   ChangerGetElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerInitializeElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerSetPosition;

    CHANGER_COMMAND_ROUTINE   ChangerExchangeMedium;

    CHANGER_COMMAND_ROUTINE   ChangerMoveMedium;

    CHANGER_COMMAND_ROUTINE   ChangerReinitializeUnit;

    CHANGER_COMMAND_ROUTINE   ChangerQueryVolumeTags;

} MCD_INIT_DATA, *PMCD_INIT_DATA;

typedef struct _MODE_ELEMENT_ADDRESS_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransportElementAddress[2];
    UCHAR NumberTransportElements[2];
    UCHAR FirstStorageElementAddress[2];
    UCHAR NumberStorageElements[2];
    UCHAR FirstIEPortElementAddress[2];
    UCHAR NumberIEPortElements[2];
    UCHAR FirstDataXFerElementAddress[2];
    UCHAR NumberDataXFerElements[2];
    UCHAR Reserved2[2];

} MODE_ELEMENT_ADDRESS_PAGE, *PMODE_ELEMENT_ADDRESS_PAGE;

typedef struct _MODE_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber;

} MODE_TRANSPORT_GEOMETRY_PAGE, *PMODE_TRANSPORT_GEOMETRY_PAGE;

//
// Capabilities page decribes the various functions that the device
// supports. Used in GetParameters.
//

typedef struct _MODE_DEVICE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransport : 1;
    UCHAR StorageLocation : 1;
    UCHAR IEPort : 1;
    UCHAR DataXFer : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR MTtoMT : 1;
    UCHAR MTtoST : 1;
    UCHAR MTtoIE : 1;
    UCHAR MTtoDT : 1;
    UCHAR Reserved4 : 4;
    UCHAR STtoMT : 1;
    UCHAR STtoST : 1;
    UCHAR STtoIE : 1;
    UCHAR STtoDT : 1;
    UCHAR Reserved5 : 4;
    UCHAR IEtoMT : 1;
    UCHAR IEtoST : 1;
    UCHAR IEtoIE : 1;
    UCHAR IEtoDT : 1;
    UCHAR Reserved6 : 4;
    UCHAR DTtoMT : 1;
    UCHAR DTtoST : 1;
    UCHAR DTtoIE : 1;
    UCHAR DTtoDT : 1;
    UCHAR Reserved7 : 4;
    UCHAR Reserved8[4];
    UCHAR XMTtoMT : 1;
    UCHAR XMTtoST : 1;
    UCHAR XMTtoIE : 1;
    UCHAR XMTtoDT : 1;
    UCHAR Reserved9 : 4;
    UCHAR XSTtoMT : 1;
    UCHAR XSTtoST : 1;
    UCHAR XSTtoIE : 1;
    UCHAR XSTtoDT : 1;
    UCHAR Reserved10 : 4;
    UCHAR XIEtoMT : 1;
    UCHAR XIEtoST : 1;
    UCHAR XIEtoIE : 1;
    UCHAR XIEtoDT : 1;
    UCHAR Reserved11 : 4;
    UCHAR XDTtoMT : 1;
    UCHAR XDTtoST : 1;
    UCHAR XDTtoIE : 1;
    UCHAR XDTtoDT : 1;
    UCHAR Reserved12 : 4;

} MODE_DEVICE_CAPABILITIES_PAGE, *PMODE_DEVICE_CAPABILITIES_PAGE;

#define MODE_PAGE_DISPLAY 0x22

//
// Structures describing return data from READ_ELEMENT_STATUS
//

typedef struct _ELEMENT_STATUS_HEADER {
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} ELEMENT_STATUS_HEADER, *PELEMENT_STATUS_HEADER;

typedef struct _ELEMENT_STATUS_PAGE {
    UCHAR ElementType;
    UCHAR Reserved1 : 6;
    UCHAR AVolTag : 1;
    UCHAR PVolTag : 1;
    UCHAR ElementDescriptorLength[2];
    UCHAR Reserved2;
    UCHAR DescriptorByteCount[3];
} ELEMENT_STATUS_PAGE, *PELEMENT_STATUS_PAGE;


typedef struct _ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} ELEMENT_DESCRIPTOR, *PELEMENT_DESCRIPTOR;


//
// The following routines are the exported entry points for
// all changer class drivers.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ChangerClassInitialize(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  PMCD_INIT_DATA ChangerInitData
    );

PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    );

NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    );

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// The following routines are provided by the changer
// device-specific module. Each routine name is
// prefixed with 'Changer.'


ULONG
ChangerAdditionalExtensionSize(
    VOID
    );

NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\miniport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef DECLSPEC_NOINLINE
#if (_MSC_VER >= 1300)
#define DECLSPEC_NOINLINE  __declspec(noinline)
#else
#define DECLSPEC_NOINLINE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
#define RTL_CONSTANT_STRING(s) { sizeof( s ) - sizeof( (s)[0] ), sizeof( s ), s }
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX


#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#if !defined(MIDL_PASS) || defined(_M_IX86)

#if (_MSC_FULL_VER >= 13012035)

//
// Define bit scan intrinsics.
//

//#define BitScanForward _BitScanForward
//#define BitScanReverse _BitScanReverse

//BOOLEAN
//_BitScanForward (
//    OUT ULONG *Index,
//    IN ULONG Mask
//    );

//BOOLEAN
//_BitScanReverse (
//    OUT ULONG *Index,
//    IN ULONG Mask
//    );


//#pragma intrinsic(_BitScanForward)
//#pragma intrinsic(_BitScanReverse)

//
// Define FS referencing intrinsics
//
#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__readfsbyte (
    IN ULONG Offset
    );
 
USHORT
__readfsword (
    IN ULONG Offset
    );
 
ULONG
__readfsdword (
    IN ULONG Offset
    );
 
VOID
__writefsbyte (
    IN ULONG Offset,
    IN UCHAR Data
    );
 
VOID
__writefsword (
    IN ULONG Offset,
    IN USHORT Data
    );
 
VOID
__writefsdword (
    IN ULONG Offset,
    IN ULONG Data
    );

#ifdef __cplusplus
}
#endif
 
#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#endif

#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//
typedef struct _PCI_AGP_CAPABILITY {
    
    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;


#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );

//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b


// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ksi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksi.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core internal definitions.

--*/

#if !defined(_KSI_)
#define _KSI_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined(_NTDDK_)

typedef struct {
    LONGLONG Frequency;
    LONGLONG LastDueTime;
    LONGLONG RunningTimeDelta;
    LONGLONG LastRunningTime;
    KSPIN_LOCK TimeAccessLock;
    LIST_ENTRY EventQueue;
    KSPIN_LOCK EventQueueLock;
    KTIMER QueueTimer;
    KDPC QueueDpc;
    LONG ReferenceCount;
    KSSTATE State;
    LONGLONG SuspendDelta;
    LONGLONG SuspendTime;
    PFNKSSETTIMER SetTimer;
    PFNKSCANCELTIMER CancelTimer;
    PFNKSCLOCK_CORRELATEDTIME CorrelatedTime;
    PVOID Context;
    KSRESOLUTION Resolution;
    KEVENT FreeEvent;
    LONG ExternalTimeReferenceCount;
    BOOLEAN ExternalTimeValid;
    LONGLONG LastStreamTime;
} KSIDEFAULTCLOCK, *PKSIDEFAULTCLOCK;

typedef struct {
    KSOBJECT_HEADER Header;
    PKSIDEFAULTCLOCK DefaultClock;
    ULONG Reserved;
} KSCLOCKINSTANCE, *PKSCLOCKINSTANCE;

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiDefaultClockAddMarkEvent(
    IN PIRP Irp,
    IN PKSEVENT_TIME_INTERVAL EventTime,
    IN PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
BOOLEAN
NTAPI
KsiQueryObjectCreateItemsPresent(
    IN KSDEVICE_HEADER Header
    );

#endif // !defined(_NTDDK_)

#define STATIC_KSNAME_Server\
    0x3C0D501AL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501A-140B-11D1-B40F-00A0C9223196", KSNAME_Server);
#define KSNAME_Server DEFINE_GUIDNAMED(KSNAME_Server)

#define KSSTRING_Server L"{3C0D501A-140B-11D1-B40F-00A0C9223196}"

#define STATIC_KSPROPSETID_Service \
    0x3C0D501BL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501B-140B-11D1-B40F-00A0C9223196", KSPROPSETID_Service);
#define KSPROPSETID_Service DEFINE_GUIDNAMED(KSPROPSETID_Service)

typedef enum {
    KSPROPERTY_SERVICE_BUILDCACHE,
    KSPROPERTY_SERVICE_MERIT
} KSPROPERTY_SERVICE;

#define DEFINE_KSPROPERTY_ITEM_SERVICE_BUILDCACHE(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_BUILDCACHE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_SERVICE_MERIT(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_MERIT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(ULONG) + sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !_KSI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif


/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#ifndef DRVM_MAPPER
#define DRVM_MAPPER             (0x2000)
#endif
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_CONSOLEVOICECOM_GET           (DRVM_MAPPER+23)
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#define DRV_QUERYSTRINGID            (DRV_RESERVED + 14)
#define DRV_QUERYSTRINGIDSIZE        (DRV_RESERVED + 15)
#define DRV_QUERYIDFROMSTRINGID      (DRV_RESERVED + 16)

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
typedef VOID (TASKCALLBACK) (DWORD_PTR dwInst);

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mountdev.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mountdev.h

Abstract:

    This file defines the private interfaces between the mount point manager
    and the mounted devices.

Author:

    norbertk

Revision History:

--*/

#ifndef _MOUNTDEV_
#define _MOUNTDEV_

#include <mountmgr.h>

#define IOCTL_MOUNTDEV_QUERY_UNIQUE_ID              CTL_CODE(MOUNTDEVCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY      CTL_CODE(MOUNTDEVCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME    CTL_CODE(MOUNTDEVCONTROLTYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_CREATED                 CTL_CODE(MOUNTDEVCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTDEV_LINK_DELETED                 CTL_CODE(MOUNTDEVCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_STABLE_GUID            CTL_CODE(MOUNTDEVCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_MOUNTDEV_QUERY_UNIQUE_ID.
// Input structure for IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY.
//

typedef struct _MOUNTDEV_UNIQUE_ID {
    USHORT  UniqueIdLength;
    UCHAR   UniqueId[1];
} MOUNTDEV_UNIQUE_ID, *PMOUNTDEV_UNIQUE_ID;

//
// Output structure for IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY.
//

typedef struct _MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT {
    ULONG   Size;
    USHORT  OldUniqueIdOffset;
    USHORT  OldUniqueIdLength;
    USHORT  NewUniqueIdOffset;
    USHORT  NewUniqueIdLength;
} MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT, *PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT;

//
// MOUNTDEV_NAME
//
// Input structure for IOCTL_MOUNTDEV_LINK_CREATED.
// Input structure for IOCTL_MOUNTDEV_LINK_DELETED.
//

//
// Output structure for IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME
//

typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME {
    BOOLEAN UseOnlyIfThereAreNoOtherLinks;
    USHORT  NameLength;
    WCHAR   Name[1];
} MOUNTDEV_SUGGESTED_LINK_NAME, *PMOUNTDEV_SUGGESTED_LINK_NAME;

//
// Output structure for IOCTL_MOUNTDEV_QUERY_STABLE_GUID.
//

typedef struct _MOUNTDEV_STABLE_GUID {
    GUID    StableGuid;
} MOUNTDEV_STABLE_GUID, *PMOUNTDEV_STABLE_GUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\minitape.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    minitape.h

Abstract:

    Type definitions for minitape drivers.

Revision History:

--*/

#ifndef _MINITAPE_
#define _MINITAPE_

#include "stddef.h"

#define ASSERT( exp )

#if DBG

#define DebugPrint(x) ScsiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef DECLSPEC_NOINLINE
#if (_MSC_VER >= 1300)
#define DECLSPEC_NOINLINE  __declspec(noinline)
#else
#define DECLSPEC_NOINLINE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX



//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    ULONG Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    ULONG Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    ULONG Type;
    ULONG Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    ULONG Type;
    ULONG Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    ULONG Method;
    ULONG Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_EJECT_MEDIA      0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS   0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG DefaultBlockSize;
    ULONG MaximumBlockSize;
    ULONG MinimumBlockSize;
    ULONG MaximumPartitionCount;
    ULONG FeaturesLow;
    ULONG FeaturesHigh;
    ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    ULONG BlockSize;
    ULONG PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    ULONG Method;
    ULONG Count;
    ULONG Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//
#define TAPE_QUERY_DRIVE_PARAMETERS       0L
#define TAPE_QUERY_MEDIA_CAPACITY         1L
#define TAPE_CHECK_FOR_DRIVE_PROBLEM      2L
#define TAPE_QUERY_IO_ERROR_DATA          3L
#define TAPE_QUERY_DEVICE_ERROR_DATA      4L

typedef struct _TAPE_WMI_OPERATIONS {
   ULONG Method;
   ULONG DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;



typedef struct _TAPE_STATISTICS {
    ULONG Version;
    ULONG Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    UCHAR         CompressionRatioReads;
    UCHAR         CompressionRatioWrites;
} TAPE_STATISTICS, *PTAPE_STATISTICS;

#define RECOVERED_WRITES_VALID   0x00000001
#define UNRECOVERED_WRITES_VALID 0x00000002
#define RECOVERED_READS_VALID    0x00000004
#define UNRECOVERED_READS_VALID  0x00000008
#define WRITE_COMPRESSION_INFO_VALID  0x00000010
#define READ_COMPRESSION_INFO_VALID   0x00000020

typedef struct _TAPE_GET_STATISTICS {
    ULONG Operation;
} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO   1L
#define TAPE_RESET_STATISTICS  2L

//
// IOCTL_STORAGE_GET_MEDIA_TYPES_EX will return an array of DEVICE_MEDIA_INFO
// structures, one per supported type, embedded in the GET_MEDIA_TYPES struct.
//

typedef enum _STORAGE_MEDIA_TYPE {
    //
    // Following are defined in ntdddisk.h in the MEDIA_TYPE enum
    //
    // Unknown,                // Format is unknown
    // F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    // F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    // F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    // F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    // F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    // F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    // F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    // F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    // F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    // F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    // RemovableMedia,         // Removable media other than floppy
    // FixedMedia,             // Fixed hard disk media
    // F3_120M_512,            // 3.5", 120M Floppy
    // F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    // F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    // F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    // F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    // F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    // F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    // F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    // F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    // F8_256_128,             // 8",     256KB,  128 bytes/sector
    // F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
    //

    DDS_4mm = 0x20,            // Tape - DAT DDS1,2,... (all vendors)
    MiniQic,                   // Tape - miniQIC Tape
    Travan,                    // Tape - Travan TR-1,2,3,...
    QIC,                       // Tape - QIC
    MP_8mm,                    // Tape - 8mm Exabyte Metal Particle
    AME_8mm,                   // Tape - 8mm Exabyte Advanced Metal Evap
    AIT1_8mm,                  // Tape - 8mm Sony AIT
    DLT,                       // Tape - DLT Compact IIIxt, IV
    NCTP,                      // Tape - Philips NCTP
    IBM_3480,                  // Tape - IBM 3480
    IBM_3490E,                 // Tape - IBM 3490E
    IBM_Magstar_3590,          // Tape - IBM Magstar 3590
    IBM_Magstar_MP,            // Tape - IBM Magstar MP
    STK_DATA_D3,               // Tape - STK Data D3
    SONY_DTF,                  // Tape - Sony DTF
    DV_6mm,                    // Tape - 6mm Digital Video
    DMI,                       // Tape - Exabyte DMI and compatibles
    SONY_D2,                   // Tape - Sony D2S and D2L
    CLEANER_CARTRIDGE,         // Cleaner - All Drive types that support Drive Cleaners
    CD_ROM,                    // Opt_Disk - CD
    CD_R,                      // Opt_Disk - CD-Recordable (Write Once)
    CD_RW,                     // Opt_Disk - CD-Rewriteable
    DVD_ROM,                   // Opt_Disk - DVD-ROM
    DVD_R,                     // Opt_Disk - DVD-Recordable (Write Once)
    DVD_RW,                    // Opt_Disk - DVD-Rewriteable
    MO_3_RW,                   // Opt_Disk - 3.5" Rewriteable MO Disk
    MO_5_WO,                   // Opt_Disk - MO 5.25" Write Once
    MO_5_RW,                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    MO_5_LIMDOW,               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    PC_5_WO,                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    PC_5_RW,                   // Opt_Disk - Phase Change 5.25" Rewriteable
    PD_5_RW,                   // Opt_Disk - PhaseChange Dual Rewriteable
    ABL_5_WO,                  // Opt_Disk - Ablative 5.25" Write Once Optical
    PINNACLE_APEX_5_RW,        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    SONY_12_WO,                // Opt_Disk - Sony 12" Write Once
    PHILIPS_12_WO,             // Opt_Disk - Philips/LMS 12" Write Once
    HITACHI_12_WO,             // Opt_Disk - Hitachi 12" Write Once
    CYGNET_12_WO,              // Opt_Disk - Cygnet/ATG 12" Write Once
    KODAK_14_WO,               // Opt_Disk - Kodak 14" Write Once
    MO_NFR_525,                // Opt_Disk - Near Field Recording (Terastor)
    NIKON_12_RW,               // Opt_Disk - Nikon 12" Rewriteable
    IOMEGA_ZIP,                // Mag_Disk - Iomega Zip
    IOMEGA_JAZ,                // Mag_Disk - Iomega Jaz
    SYQUEST_EZ135,             // Mag_Disk - Syquest EZ135
    SYQUEST_EZFLYER,           // Mag_Disk - Syquest EzFlyer
    SYQUEST_SYJET,             // Mag_Disk - Syquest SyJet
    AVATAR_F2,                 // Mag_Disk - 2.5" Floppy
    MP2_8mm,                   // Tape - 8mm Hitachi
    DST_S,                     // Ampex DST Small Tapes
    DST_M,                     // Ampex DST Medium Tapes
    DST_L,                     // Ampex DST Large Tapes
    VXATape_1,                 // Ecrix 8mm Tape
    VXATape_2,                 // Ecrix 8mm Tape
    STK_9840,                  // STK 9840
    LTO_Ultrium,               // IBM, HP, Seagate LTO Ultrium
    LTO_Accelis,               // IBM, HP, Seagate LTO Accelis
    DVD_RAM,                   // Opt_Disk - DVD-RAM
    AIT_8mm,                   // AIT2 or higher
    ADR_1,                     // OnStream ADR Mediatypes
    ADR_2,                     
    STK_9940                   // STK 9940
} STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;

#define MEDIA_ERASEABLE         0x00000001
#define MEDIA_WRITE_ONCE        0x00000002
#define MEDIA_READ_ONLY         0x00000004
#define MEDIA_READ_WRITE        0x00000008

#define MEDIA_WRITE_PROTECTED   0x00000100
#define MEDIA_CURRENTLY_MOUNTED 0x80000000

//
// Define the different storage bus types
// Bus types below 128 (0x80) are reserved for Microsoft use
//

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;

typedef struct _DEVICE_MEDIA_INFO {
    union {
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } DiskInfo;

        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } RemovableDiskInfo;

        struct {
            STORAGE_MEDIA_TYPE MediaType;
            ULONG   MediaCharacteristics; // Bitmask of MEDIA_XXX values.
            ULONG   CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;

            //
            // Bus specific information describing the medium supported.
            //

            union {
                struct {
                    UCHAR MediumType;
                    UCHAR DensityCode;
                } ScsiInformation;
            } BusSpecificData;

        } TapeInfo;
    } DeviceSpecific;
} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

typedef struct _GET_MEDIA_TYPES {
    ULONG DeviceType;              // FILE_DEVICE_XXX values
    ULONG MediaInfoCount;
    DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;


//
// IOCTL_STORAGE_PREDICT_FAILURE
//
// input - none
//
// output - STORAGE_PREDICT_FAILURE structure
//          PredictFailure returns zero if no failure predicted and non zero
//                         if a failure is predicted.
//
//          VendorSpecific returns 512 bytes of vendor specific information
//                         if a failure is predicted
//
typedef struct _STORAGE_PREDICT_FAILURE
{
    ULONG PredictFailure;
    UCHAR VendorSpecific[512];
} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;


#define MAXIMUM_CDB_SIZE 12

//
// SCSI I/O Request Block
//

typedef struct _SCSI_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR ScsiStatus;               // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    UCHAR QueueTag;                 // offset 8
    UCHAR QueueAction;              // offset 9
    UCHAR CdbLength;                // offset a
    UCHAR SenseInfoBufferLength;    // offset b
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    union {
        ULONG InternalStatus;       // offset 2c
        ULONG QueueSortKey;         // offset 2c
    };

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Cdb[16];                  // offset 30
} SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;

#define SCSI_REQUEST_BLOCK_SIZE sizeof(SCSI_REQUEST_BLOCK)

//
// SCSI I/O Request Block for WMI Requests
//

typedef struct _SCSI_WMI_REQUEST_BLOCK {
    USHORT Length;
    UCHAR Function;        // SRB_FUNCTION_WMI
    UCHAR SrbStatus;
    UCHAR WMISubFunction;
    UCHAR PathId;          // If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in
    UCHAR TargetId;        // WMIFlags then PathId, TargetId and Lun are
    UCHAR Lun;             // reserved fields.
    UCHAR Reserved1;
    UCHAR WMIFlags;
    UCHAR Reserved2[2];
    ULONG SrbFlags;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    PVOID DataPath;
    PVOID Reserved3;
    PVOID OriginalRequest;
    PVOID SrbExtension;
    ULONG Reserved4;
    UCHAR Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19
#define SRB_FUNCTION_RESET_LOGICAL_UNIT     0x20

//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23
#define SRB_STATUS_NOT_POWERED              0x24

//
// This value is used by the port driver to indicate that a non-scsi-related
// error occured.  Miniports must never return this status.
//

#define SRB_STATUS_INTERNAL_ERROR           0x30

//
// Srb status values 0x38 through 0x3f are reserved for internal port driver 
// use.
// 



//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008

#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_FREE_SENSE_BUFFER         0x00000400

#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000
#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE    0x00200000
#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT  0x00400000
#define SRB_FLAGS_DONT_START_NEXT_PACKET    0x00800000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

#if DBG==1
//
// A signature used to validate the scsi port number
// at the end of a sense buffer.
//
#define SCSI_PORT_SIGNATURE                 0x54524f50
#endif

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01


#ifndef _NTDDK_
#define SCSIPORT_API DECLSPEC_IMPORT
#else
#define SCSIPORT_API
#endif


SCSIPORT_API
VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#pragma pack(push, cdb, 1)
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;    // 0x08, 0x0A - SCSIOP_READ, SCSIOP_WRITE
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;

    //
    // SCSI-1 Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    //
    // SCSI-3 Inquiry CDB
    //

    struct _CDB6INQUIRY3 {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR EnableVitalProductData : 1;
        UCHAR CommandSupportData : 1;
        UCHAR Reserved1 : 6;
        UCHAR PageCode;
        UCHAR Reserved2;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY3, *PCDB6INQUIRY3;

    struct _CDB6VERIFY {
        UCHAR OperationCode;    // 0x13 - SCSIOP_VERIFY
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY, *PCDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;    // 0x04 - SCSIOP_FORMAT_UNIT
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12, *PCDB12;



    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;    // 0x4B - SCSIOP_PAUSE_RESUME
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;    // 0x43 - SCSIOP_READ_TOC
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51 - SCSIOP_READ_DISC_INFORMATION
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, *PREAD_DISK_INFORMATION,
      READ_DISC_INFORMATION, *PREAD_DISC_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52 - SCSIOP_READ_TRACK_INFORMATION
        UCHAR Track : 2;
        UCHAR Reserved4 : 3;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION, *PREAD_TRACK_INFORMATION;

    struct _RESERVE_TRACK_RZONE {
        UCHAR OperationCode;    // 0x53 - SCSIOP_RESERVE_TRACK_RZONE
        UCHAR Reserved1[4];
        UCHAR ReservationSize[4];
        UCHAR Control;
    } RESERVE_TRACK_RZONE, *PRESERVE_TRACK_RZONE;

    struct _SEND_OPC_INFORMATION {
        UCHAR OperationCode;    // 0x54 - SCSIOP_SEND_OPC_INFORMATION
        UCHAR DoOpc    : 1;     // perform OPC
        UCHAR Reserved : 7;
        UCHAR Reserved1[5];
        UCHAR ParameterListLength[2];
        UCHAR Reserved2;
    } SEND_OPC_INFORMATION, *PSEND_OPC_INFORMATION;

    struct _CLOSE_TRACK {
        UCHAR OperationCode;    // 0x5B - SCSIOP_CLOSE_TRACK_SESSION
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Track     : 1;
        UCHAR Session   : 1;
        UCHAR Reserved2 : 6;
        UCHAR Reserved3;
        UCHAR TrackNumber[2];
        UCHAR Reserved4[3];
        UCHAR Control;
    } CLOSE_TRACK, *PCLOSE_TRACK;

    struct _SEND_CUE_SHEET {
        UCHAR OperationCode;    // 0x5D - SCSIOP_SEND_CUE_SHEET
        UCHAR Reserved[5];
        UCHAR CueSheetSize[3];
        UCHAR Control;
    } SEND_CUE_SHEET, *PSEND_CUE_SHEET;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44 - SCSIOP_READ_HEADER
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER, *PREAD_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;    // 0x45 - SCSIOP_PLAY_AUDIO
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO, *PPLAY_AUDIO;

    struct _PLAY_AUDIO_MSF { 
        UCHAR OperationCode;    // 0x47 - SCSIOP_PLAY_AUDIO_MSF
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    struct _BLANK_MEDIA {
        UCHAR OperationCode;    // 0xA1 - SCSIOP_BLANK
        UCHAR BlankType : 3;
        UCHAR Reserved1 : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved2 : 3;
        UCHAR AddressOrTrack[4];
        UCHAR Reserved3[5];
        UCHAR Control;
    } BLANK_MEDIA, *PBLANK_MEDIA;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC - SCSIOP_PLAY_CD
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD, *PPLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA - SCSIOP_SCAN_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD, *PSCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E - SCSIOP_STOP_PLAY_SCAN
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN, *PSTOP_PLAY_SCAN;


    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;    // 0x42 - SCSIOP_READ_SUB_CHANNEL
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD { 
        UCHAR OperationCode;    // 0xBE - SCSIOP_READ_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD, *PREAD_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;    // 0xB9 - SCSIOP_READ_CD_MSF
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF, *PREAD_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA, *PPLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA, *PNEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;    // 0x1A - SCSIOP_MODE_SENSE
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;    // 0x5A - SCSIOP_MODE_SENSE10
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10, *PMODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;    // 0x15 - SCSIOP_MODE_SELECT
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;    // 0x55 - SCSIOP_MODE_SELECT10
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10, *PMODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;    // 0x2B - SCSIOP_LOCATE
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;    // 0x4D - SCSIOP_LOG_SENSE
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;    // 0x4C - SCSIOP_LOG_SELECT
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } LOGSELECT, *PLOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;    // 0x0A - SCSIOP_PRINT
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;    // 0x2B - SCSIOP_SEEK
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;    // 0x19 - SCSIOP_ERASE
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;    // 0x1B - SCSIOP_START_STOP_UNIT
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;    // 0x1E - SCSIOP_MEDIUM_REMOVAL
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;    // 0x0C - SCSIOP_SEEK_BLOCK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;    // 0x02 - SCSIOP_REQUEST_BLOCK_ADDR
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;    // 0x0D - SCSIOP_PARTITION
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;        // 0x43 - SCSIOP_READ_POSITION
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0x07 - SCSIOP_INIT_ELEMENT_STATUS
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS, *PINIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;    // 0xE7 - SCSIOP_INIT_ELEMENT_RANGE
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE, *PINITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;    // 0x2B - SCSIOP_POSITION_TO_ELEMENT
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT, *PPOSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;    // 0xA5 - SCSIOP_MOVE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM, *PMOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_EXCHANGE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM, *PEXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0xB8 - SCSIOP_READ_ELEMENT_STATUS
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS, *PREAD_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SEND_VOLUME_TAG
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG, *PSEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS, *PREQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_LOAD_UNLOAD_SLOT
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD, *PLOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;    // 0xBD - SCSIOP_MECHANISM_STATUS
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS, *PMECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35 - SCSIOP_SYNCHRONIZE_CACHE

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10, *PSYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4A - SCSIOP_GET_EVENT_STATUS_NOTIFICATION

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION, *PGET_EVENT_STATUS_NOTIFICATION;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD - SCSIOP_READ_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE, *PREAD_DVD_STRUCTURE;

    struct _SEND_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xBF - SCSIOP_SEND_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR Format;
        UCHAR ParameterListLength[2];
        UCHAR Reserved3;
        UCHAR Control;
    } SEND_DVD_STRUCTURE, *PSEND_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3 - SCSIOP_SEND_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY, *PSEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4 - SCSIOP_REPORT_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY, *PREPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7 - SCSIOP_SET_READ_AHEAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD, *PSET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0x23 - SCSIOP_READ_FORMATTED_CAPACITY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES, *PREAD_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0 - SCSIOP_REPORT_LUNS
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS, *PREPORT_LUNS;

    struct _PERSISTENT_RESERVE_IN {
        UCHAR OperationCode;    // 0x5E - SCSIOP_PERSISTENT_RESERVE_IN
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } PERSISTENT_RESERVE_IN, *PPERSISTENT_RESERVE_IN;

    struct _PERSISTENT_RESERVE_OUT {
        UCHAR OperationCode;    // 0x5F - SCSIOP_PERSISTENT_RESERVE_OUT
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Type : 4;
        UCHAR Scope : 4;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2]; // 0x18
        UCHAR Control;
    } PERSISTENT_RESERVE_OUT, *PPERSISTENT_RESERVE_OUT;

    //
    // MMC / SFF-8090 commands
    //

    struct _GET_CONFIGURATION {
        UCHAR OperationCode;       // 0x46 - SCSIOP_GET_CONFIGURATION
        UCHAR RequestType : 2;     // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
        UCHAR Reserved1   : 6;     // includes obsolete LUN field
        UCHAR StartingFeature[2];
        UCHAR Reserved2[3];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } GET_CONFIGURATION, *PGET_CONFIGURATION;

    struct _SET_CD_SPEED {
        UCHAR OperationCode;       // 0xB8 - SCSIOP_SET_CD_SPEED
        UCHAR Reserved1;
        UCHAR ReadSpeed[2];        // 1x == (75 * 2352)
        UCHAR WriteSpeed[2];       // 1x == (75 * 2352)
        UCHAR Reserved2[5];
        UCHAR Control;
    } SET_CD_SPEED, *PSET_CD_SPEED;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#pragma pack(pop, cdb)

////////////////////////////////////////////////////////////////////////////////
//
// GET_EVENT_STATUS_NOTIFICATION
//


#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_MASK  0x02
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_MASK    0x04
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK    0x08
#define NOTIFICATION_MEDIA_STATUS_CLASS_MASK        0x10
#define NOTIFICATION_MULTI_HOST_CLASS_MASK          0x20
#define NOTIFICATION_DEVICE_BUSY_CLASS_MASK         0x40


#define NOTIFICATION_NO_CLASS_EVENTS                  0x0
#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_EVENTS  0x1
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS    0x2
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS    0x3
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS        0x4
#define NOTIFICATION_MULTI_HOST_CLASS_EVENTS          0x5
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS         0x6

#pragma pack(push, not_header, 1)
typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
    UCHAR EventDataLength[2];

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
    UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;
#pragma pack(pop, not_header)

#define NOTIFICATION_OPERATIONAL_EVENT_NO_CHANGE         0x0
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_REQUESTED  0x1
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_OCCURRED   0x2

#define NOTIFICATION_OPERATIONAL_STATUS_AVAILABLE        0x0
#define NOTIFICATION_OPERATIONAL_STATUS_TEMPORARY_BUSY   0x1
#define NOTIFICATION_OPERATIONAL_STATUS_EXTENDED_BUSY    0x2

#define NOTIFICATION_OPERATIONAL_OPCODE_NONE             0x0
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_CHANGE   0x1
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_ADDED    0x2
#define NOTIFICATION_OPERATIONAL_OPCODE_UNIT_RESET       0x3
#define NOTIFICATION_OPERATIONAL_OPCODE_FIRMWARE_CHANGED 0x4
#define NOTIFICATION_OPERATIONAL_OPCODE_INQUIRY_CHANGED  0x5

//
// Class event data may be one (or none) of the following:
//

#pragma pack(push, not_op, 1)
typedef struct _NOTIFICATION_OPERATIONAL_STATUS { // event class == 0x1
    UCHAR OperationalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR OperationalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Operation[2];
} NOTIFICATION_OPERATIONAL_STATUS, *PNOTIFICATION_OPERATIONAL_STATUS;
#pragma pack(pop, not_op)


#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3
#define NOTIFICATION_POWER_STATUS_SLEEP             0x4

#pragma pack(push, not_power, 1)
typedef struct _NOTIFICATION_POWER_STATUS { // event class == 0x2
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;
#pragma pack(pop, not_power)

#define NOTIFICATION_EXTERNAL_EVENT_NO_CHANGE       0x0
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN     0x1
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_UP       0x2
#define NOTIFICATION_EXTERNAL_EVENT_EXTERNAL        0x3 // respond with GET_CONFIGURATION?

#define NOTIFICATION_EXTERNAL_STATUS_READY          0x0
#define NOTIFICATION_EXTERNAL_STATUS_PREVENT        0x1

#define NOTIFICATION_EXTERNAL_REQUEST_NONE          0x0000
#define NOTIFICATION_EXTERNAL_REQUEST_QUEUE_OVERRUN 0x0001
#define NOTIFICATION_EXTERNAL_REQUEST_PLAY          0x0101
#define NOTIFICATION_EXTERNAL_REQUEST_REWIND_BACK   0x0102
#define NOTIFICATION_EXTERNAL_REQUEST_FAST_FORWARD  0x0103
#define NOTIFICATION_EXTERNAL_REQUEST_PAUSE         0x0104
#define NOTIFICATION_EXTERNAL_REQUEST_STOP          0x0106
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_LOW     0x0200
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_HIGH    0x02ff

#pragma pack(push, not_extern, 1)
typedef struct _NOTIFICATION_EXTERNAL_STATUS { // event class == 0x3
    UCHAR ExternalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR ExternalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Request[2];
} NOTIFICATION_EXTERNAL_STATUS, *PNOTIFICATION_EXTERNAL_STATUS;
#pragma pack(pop, not_extern)

#define NOTIFICATION_MEDIA_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3
#define NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE       0x4

#pragma pack(push, not_media, 1)
typedef struct _NOTIFICATION_MEDIA_STATUS { // event class == 0x4
    UCHAR MediaEvent : 4;
    UCHAR Reserved : 4;

    union {
        UCHAR PowerStatus; // OBSOLETE -- was improperly named in NT5 headers
        UCHAR MediaStatus; // Use this for currently reserved fields
        struct {
            UCHAR DoorTrayOpen : 1;
            UCHAR MediaPresent : 1;
            UCHAR ReservedX    : 6; // do not reference this directly!
        };
    };
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;
#pragma pack(pop, not_media)


#define NOTIFICATION_MULTI_HOST_EVENT_NO_CHANGE        0x0
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_REQUEST  0x1
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_GRANT    0x2
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_RELEASE  0x3

#define NOTIFICATION_MULTI_HOST_STATUS_READY           0x0
#define NOTIFICATION_MULTI_HOST_STATUS_PREVENT         0x1

#define NOTIFICATION_MULTI_HOST_PRIORITY_NO_REQUESTS   0x0
#define NOTIFICATION_MULTI_HOST_PRIORITY_LOW           0x1
#define NOTIFICATION_MULTI_HOST_PRIORITY_MEDIUM        0x2
#define NOTIFICATION_MULTI_HOST_PRIORITY_HIGH          0x3

#pragma pack(push, not_multi, 1)
typedef struct _NOTIFICATION_MULTI_HOST_STATUS { // event class == 0x5
    UCHAR MultiHostEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR MultiHostStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Priority[2];
} NOTIFICATION_MULTI_HOST_STATUS, *PNOTIFICATION_MULTI_HOST_STATUS;
#pragma pack(pop, not_multi)

#define NOTIFICATION_BUSY_EVENT_NO_CHANGE           0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

#pragma pack(push, not_busy, 1)
typedef struct _NOTIFICATION_BUSY_STATUS { // event class == 0x6
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;
#pragma pack(pop, not_busy)

////////////////////////////////////////////////////////////////////////////////

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

#pragma pack(push, dvd_struct_header, 1)
typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

    UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;
#pragma pack(pop, dvd_struct_header)

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

#pragma pack(push, dvdstuff, 1)
typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;
#pragma pack(pop, dvdstuff)

//
// Read Formatted Capacity Data - returned in Big Endian Format
//


#pragma pack(push, formatted_capacity, 1)
typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;
#pragma pack(pop, formatted_capacity)

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY      0x00
#define LAST_SESSION_INCOMPLETE 0x01
#define LAST_SESSION_COMPLETE   0x03

#define DISK_TYPE_CDDA          0x01
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF


#pragma pack(push, discinfo, 1)
typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISC_INFORMATION {
    
    UCHAR Length[2];
    UCHAR DiscStatus        : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable          : 1;
    UCHAR Reserved1         : 3;
    UCHAR FirstTrackNumber;
    
    UCHAR NumberOfSessionsLsb;
    UCHAR LastSessionFirstTrackLsb;
    UCHAR LastSessionLastTrackLsb;
    UCHAR MrwStatus   : 2;
    UCHAR MrwDirtyBit : 1;
    UCHAR Reserved2   : 2;
    UCHAR URU         : 1;
    UCHAR DBC_V       : 1;
    UCHAR DID_V       : 1;
    
    UCHAR DiscType;
    UCHAR NumberOfSessionsMsb;
    UCHAR LastSessionFirstTrackMsb;
    UCHAR LastSessionLastTrackMsb;

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // HMSF
    UCHAR LastPossibleLeadOutStartTime[4]; // HMSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[ 1 ]; // can be many of these here....

} DISC_INFORMATION, *PDISC_INFORMATION;

// TODO: Deprecate DISK_INFORMATION
//#if PRAGMA_DEPRECATED_DDK
//#pragma deprecated(_DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated( DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated(PDISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#endif

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;
#pragma pack(pop, discinfo)


//
// Read Header definitions and structures
//
#pragma pack(push, cdheader, 1)
typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;
#pragma pack(pop, cdheader)


#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

// TODO: Deprecate TRACK_INFORMATION structure, use TRACK_INFORMATION2 instead
#pragma pack(push, track_info, 1)
typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR Damage : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP : 1;
    UCHAR Packet : 1;
    UCHAR Blank : 1;
    UCHAR RT : 1;
    UCHAR NWA_V : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;

typedef struct _TRACK_INFORMATION2 {
    
    UCHAR Length[2];
    UCHAR TrackNumberLsb;
    UCHAR SessionNumberLsb;
    
    UCHAR Reserved4;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved5 : 2;
    UCHAR DataMode      : 4;
    UCHAR FixedPacket   : 1;
    UCHAR Packet        : 1;
    UCHAR Blank         : 1;
    UCHAR ReservedTrack : 1;
    UCHAR NWA_V     : 1;
    UCHAR LRA_V     : 1;
    UCHAR Reserved6 : 6;
    
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4]; // blocking factor
    UCHAR TrackSize[4];
    UCHAR LastRecordedAddress[4];
    
    UCHAR TrackNumberMsb;
    UCHAR SessionNumberMsb;
    UCHAR Reserved7[2];

} TRACK_INFORMATION2, *PTRACK_INFORMATION2;
#pragma pack(pop, track_info)



//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03 // disk
#define MODE_PAGE_MRW                   0x03 // cdrom
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05 // disk
#define MODE_PAGE_WRITE_PARAMETERS      0x05 // cdrom
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D // cdrom
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A // cdrom

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

// 6-byte commands:
#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_INIT_ELEMENT_STATUS 0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E

// 10-byte commands
#define SCSIOP_READ_FORMATTED_CAPACITY 0x23
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_POSITION_TO_ELEMENT 0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_GET_CONFIGURATION   0x46
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_GET_EVENT_STATUS    0x4A
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
#define SCSIOP_STOP_PLAY_SCAN      0x4E
#define SCSIOP_READ_DISK_INFORMATION    0x51
#define SCSIOP_READ_DISC_INFORMATION    0x51  // proper use of disc over disk
#define SCSIOP_READ_TRACK_INFORMATION   0x52
#define SCSIOP_RESERVE_TRACK_RZONE      0x53
#define SCSIOP_SEND_OPC_INFORMATION     0x54  // optimum power calibration
#define SCSIOP_MODE_SELECT10            0x55
#define SCSIOP_RESERVE_UNIT10           0x56
#define SCSIOP_RELEASE_UNIT10           0x57
#define SCSIOP_MODE_SENSE10             0x5A
#define SCSIOP_CLOSE_TRACK_SESSION      0x5B
#define SCSIOP_READ_BUFFER_CAPACITY     0x5C
#define SCSIOP_SEND_CUE_SHEET           0x5D
#define SCSIOP_PERSISTENT_RESERVE_IN    0x5E
#define SCSIOP_PERSISTENT_RESERVE_OUT   0x5F

// 12-byte commands
#define SCSIOP_REPORT_LUNS              0xA0
#define SCSIOP_BLANK                    0xA1
#define SCSIOP_SEND_EVENT               0xA2
#define SCSIOP_SEND_KEY                 0xA3
#define SCSIOP_REPORT_KEY               0xA4
#define SCSIOP_MOVE_MEDIUM              0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT         0xA6
#define SCSIOP_EXCHANGE_MEDIUM          0xA6
#define SCSIOP_SET_READ_AHEAD           0xA7
#define SCSIOP_READ_DVD_STRUCTURE       0xAD
#define SCSIOP_REQUEST_VOL_ELEMENT      0xB5
#define SCSIOP_SEND_VOLUME_TAG          0xB6
#define SCSIOP_READ_ELEMENT_STATUS      0xB8
#define SCSIOP_READ_CD_MSF              0xB9
#define SCSIOP_SCAN_CD                  0xBA
#define SCSIOP_SET_CD_SPEED             0xBB
#define SCSIOP_PLAY_CD                  0xBC
#define SCSIOP_MECHANISM_STATUS         0xBD
#define SCSIOP_READ_CD                  0xBE
#define SCSIOP_SEND_DVD_STRUCTURE       0xBF
#define SCSIOP_INIT_ELEMENT_RANGE       0xE7

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1


//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

#pragma pack(push, inquiry, 1)
typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    union {
        UCHAR Versions;
        struct {
            UCHAR ANSIVersion : 3;
            UCHAR ECMAVersion : 3;
            UCHAR ISOVersion : 2;
        };
    };
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR TerminateTask : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved;
    UCHAR Addr16 : 1;               // defined only for SIP devices.
    UCHAR Addr32 : 1;               // defined only for SIP devices.
    UCHAR AckReqQ: 1;               // defined only for SIP devices.
    UCHAR MediumChanger : 1;
    UCHAR MultiPort : 1;
    UCHAR ReservedBit2 : 1;
    UCHAR EnclosureServices : 1;
    UCHAR ReservedBit3 : 1;
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR TransferDisable : 1;      // defined only for SIP devices.
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;          // defined only for SIP devices.
    UCHAR Wide16Bit : 1;            // defined only for SIP devices.
    UCHAR Wide32Bit : 1;            // defined only for SIP devices.
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#pragma pack(pop, inquiry)

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Vital Product Data Pages
//

//
// Unit Serial Number Page (page code 0x80)
//
// Provides a product serial number for the target or the logical unit.
//
#pragma pack(push, vpd_media_sn, 1)
typedef struct _VPD_MEDIA_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[0];
} VPD_MEDIA_SERIAL_NUMBER_PAGE, *PVPD_MEDIA_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_media_sn)

#pragma pack(push, vpd_sn, 1)
typedef struct _VPD_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[0];
} VPD_SERIAL_NUMBER_PAGE, *PVPD_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_sn)

//
// Device Identification Page (page code 0x83)
// Provides the means to retrieve zero or more identification descriptors
// applying to the logical unit.
//

#pragma pack(push, vpd_stuff, 1)
typedef enum _VPD_CODE_SET {
    VpdCodeSetReserved = 0,
    VpdCodeSetBinary = 1,
    VpdCodeSetAscii = 2
} VPD_CODE_SET, *PVPD_CODE_SET;

typedef enum _VPD_ASSOCIATION {
    VpdAssocDevice = 0,
    VpdAssocPort = 1,
    VpdAssocReserved1 = 3,
    VpdAssocReserved2 = 4
} VPD_ASSOCIATION, *PVPD_ASSOCIATION;

typedef enum _VPD_IDENTIFIER_TYPE {
    VpdIdentifierTypeVendorSpecific = 0,
    VpdIdentifierTypeVendorId = 1,
    VpdIdentifierTypeEUI64 = 2,
    VpdIdentifierTypeFCPHName = 3,
    VpdIdentifierTypePortRelative = 4
} VPD_IDENTIFIER_TYPE, *PVPD_IDENTIFIER_TYPE;

typedef struct _VPD_IDENTIFICATION_DESCRIPTOR {
    UCHAR CodeSet : 4;          // VPD_CODE_SET
    UCHAR Reserved : 4;
    UCHAR IdentifierType : 4;   // VPD_IDENTIFIER_TYPE
    UCHAR Association : 2;
    UCHAR Reserved2 : 2;
    UCHAR Reserved3;
    UCHAR IdentifierLength;
    UCHAR Identifier[0];
} VPD_IDENTIFICATION_DESCRIPTOR, *PVPD_IDENTIFICATION_DESCRIPTOR;

typedef struct _VPD_IDENTIFICATION_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;


    //
    // The following field is actually a variable length array of identification
    // descriptors.  Unfortunately there's no C notation for an array of
    // variable length structures so we're forced to just pretend.
    //

    // VPD_IDENTIFICATION_DESCRIPTOR Descriptors[0];
    UCHAR Descriptors[0];
} VPD_IDENTIFICATION_PAGE, *PVPD_IDENTIFICATION_PAGE;

//
// Supported Vital Product Data Pages Page (page code 0x00)
// Contains a list of the vital product data page cods supported by the target
// or logical unit.
//

typedef struct _VPD_SUPPORTED_PAGES_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SupportedPageList[0];
} VPD_SUPPORTED_PAGES_PAGE, *PVPD_SUPPORTED_PAGES_PAGE;
#pragma pack(pop, vpd_stuff)


#define VPD_MAX_BUFFER_SIZE         0xff

#define VPD_SUPPORTED_PAGES         0x00
#define VPD_SERIAL_NUMBER           0x80
#define VPD_DEVICE_IDENTIFIERS      0x83
#define VPD_MEDIA_SERIAL_NUMBER     0x84

//
// Persistent Reservation Definitions.
//

//
// PERSISTENT_RESERVE_* definitions
//

#define RESERVATION_ACTION_READ_KEYS                    0x00
#define RESERVATION_ACTION_READ_RESERVATIONS            0x01

#define RESERVATION_ACTION_REGISTER                     0x00
#define RESERVATION_ACTION_RESERVE                      0x01
#define RESERVATION_ACTION_RELEASE                      0x02
#define RESERVATION_ACTION_CLEAR                        0x03
#define RESERVATION_ACTION_PREEMPT                      0x04
#define RESERVATION_ACTION_PREEMPT_ABORT                0x05
#define RESERVATION_ACTION_REGISTER_IGNORE_EXISTING     0x06

#define RESERVATION_SCOPE_LU                            0x00
#define RESERVATION_SCOPE_ELEMENT                       0x02

#define RESERVATION_TYPE_WRITE_EXCLUSIVE                0x01
#define RESERVATION_TYPE_EXCLUSIVE                      0x03
#define RESERVATION_TYPE_WRITE_EXCLUSIVE_REGISTRANTS    0x05
#define RESERVATION_TYPE_EXCLUSIVE_REGISTRANTS          0x06

//
// Structures for reserve in command.
//

#pragma pack(push, reserve_in_stuff, 1)
typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
    UCHAR ReservationKeyList[0][8];
} PRI_REGISTRATION_LIST, *PPRI_REGISTRATION_LIST;

typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR Reserved;
    UCHAR Type : 4;
    UCHAR Scope : 4;
    UCHAR Obsolete[2];
} PRI_RESERVATION_DESCRIPTOR, *PPRI_RESERVATION_DESCRIPTOR;

typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
    PRI_RESERVATION_DESCRIPTOR Reservations[0];
} PRI_RESERVATION_LIST, *PPRI_RESERVATION_LIST;
#pragma pack(pop, reserve_in_stuff)

//
// Structures for reserve out command.
//

#pragma pack(push, reserve_out_stuff, 1)
typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR Obsolete[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;
#pragma pack(pop, reserve_out_stuff)


//
// Sense Data Format
//

#pragma pack(push, sensedata, 1)
typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;
#pragma pack(pop, sensedata)

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Maximum request sense buffer size
//

#define MAX_SENSE_BUFFER_SIZE 255

//
// Maximum number of additional sense bytes.
//

#define MAX_ADDITIONAL_SENSE_BYTES (MAX_SENSE_BUFFER_SIZE - SENSE_BUFFER_SIZE)

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE                              0x00
#define SCSI_ADSENSE_NO_SEEK_COMPLETE                      0x02
#define SCSI_ADSENSE_LUN_NOT_READY                         0x04
#define SCSI_ADSENSE_WRITE_ERROR                           0x0C
#define SCSI_ADSENSE_TRACK_ERROR                           0x14
#define SCSI_ADSENSE_SEEK_ERROR                            0x15
#define SCSI_ADSENSE_REC_DATA_NOECC                        0x17
#define SCSI_ADSENSE_REC_DATA_ECC                          0x18
#define SCSI_ADSENSE_PARAMETER_LIST_LENGTH                 0x1A
#define SCSI_ADSENSE_ILLEGAL_COMMAND                       0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK                         0x21
#define SCSI_ADSENSE_INVALID_CDB                           0x24
#define SCSI_ADSENSE_INVALID_LUN                           0x25
#define SCSI_ADSENSE_INVALID_FIELD_PARAMETER_LIST          0x26
#define SCSI_ADSENSE_WRITE_PROTECT                         0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED                        0x28
#define SCSI_ADSENSE_BUS_RESET                             0x29
#define SCSI_ADSENSE_PARAMETERS_CHANGED                    0x2A
#define SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION       0x2E
#define SCSI_ADSENSE_INVALID_MEDIA                         0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE                    0x3a
#define SCSI_ADSENSE_POSITION_ERROR                        0x3b
#define SCSI_ADSENSE_OPERATOR_REQUEST                      0x5a // see below
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK           0x64
#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE               0x6f
#define SCSI_ADSENSE_POWER_CALIBRATION_ERROR               0x73
#define SCSI_ADSENSE_VENDOR_UNIQUE                         0x80 // and higher
#define SCSI_ADSENSE_MUSIC_AREA                            0xA0
#define SCSI_ADSENSE_DATA_AREA                             0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW                       0xA7

// for legacy apps:
#define SCSI_ADWRITE_PROTECT                        SCSI_ADSENSE_WRITE_PROTECT
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED  SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED


//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_REBUILD_IN_PROGRESS          0x05
#define SCSI_SENSEQ_RECALCULATION_IN_PROGRESS    0x06
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07
#define SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS       0x08

//
// SCSI_ADSENSE_WRITE_ERROR (0x0C) qualifiers
//
#define SCSI_SENSEQ_LOSS_OF_STREAMING            0x09
#define SCSI_SENSEQ_PADDING_BLOCKS_ADDED         0x0A


//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02
#define SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED 0x03

//
// SCSI_ADSENSE_OPERATOR_REQUEST (0x5a) qualifiers
//

#define SCSI_SENSEQ_STATE_CHANGE_INPUT     0x00 // generic request
#define SCSI_SENSEQ_MEDIUM_REMOVAL         0x01
#define SCSI_SENSEQ_WRITE_PROTECT_ENABLE   0x02
#define SCSI_SENSEQ_WRITE_PROTECT_DISABLE  0x03

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05

//
// SCSI_ADSENSE_POWER_CALIBRATION_ERROR (0x73) qualifiers
//

#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ALMOST_FULL 0x01
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_FULL        0x02
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ERROR       0x03
#define SCSI_SENSEQ_PMA_RMA_UPDATE_FAILURE             0x04
#define SCSI_SENSEQ_PMA_RMA_IS_FULL                    0x05
#define SCSI_SENSEQ_PMA_RMA_ALMOST_FULL                0x06



//
// Read Capacity Data - returned in Big Endian format
//

#pragma pack(push, read_capacity, 1)
typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;
#pragma pack(pop, read_capacity)

//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

#pragma pack(push, read_block_limits, 1)
typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;
#pragma pack(pop, read_block_limits)


//
// Mode data structures.
//

//
// Define Mode parameter header.
//

#pragma pack(push, mode_params, 1)
typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;
#pragma pack(pop, mode_params)

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

#pragma pack(push, mode_params_block, 1)
typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;
#pragma pack(pop, mode_params_block)

//
// Define Disconnect-Reconnect page.
//


#pragma pack(push, mode_page_disconnect, 1)
typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;
#pragma pack(pop, mode_page_disconnect)

//
// Define mode caching page.
//

#pragma pack(push, mode_page_caching, 1)
typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;
#pragma pack(pop, mode_page_caching)

//
// Define write parameters cdrom page
//
#pragma pack(push, mode_page_wp2, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE2 {
    UCHAR PageCode : 6;             // 0x05
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;    
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;    
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR MediaCatalogNumber[16];
    UCHAR ISRC[16];
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE2, *PMODE_CDROM_WRITE_PARAMETERS_PAGE2;
#pragma pack(pop, mode_page_wp2)

#ifndef DEPRECATE_DDK_FUNCTIONS
// this structure is being retired due to missing fields and overly
// complex data definitions for the MCN and ISRC.
#pragma pack(push, mode_page_wp, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE {
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;    
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;    
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7                 : 7;
    UCHAR MediaCatalogNumberValid   : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8                 : 7;
    UCHAR ISRCValid                 : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE, *PMODE_CDROM_WRITE_PARAMETERS_PAGE;
#pragma pack(pop, mode_page_wp)
#endif //ifndef DEPRECATE_DDK_FUNCTIONS

//
// Define the MRW mode page for CDROM device types
//
#pragma pack(push, mode_page_mrw, 1)
typedef struct _MODE_MRW_PAGE {
    UCHAR PageCode : 6; // 0x03
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;   //0x06
    UCHAR Reserved1;
    UCHAR LbaSpace  : 1;
    UCHAR Reserved2 : 7;
    UCHAR Reserved3[4];
} MODE_MRW_PAGE, *PMODE_MRW_PAGE;
#pragma pack(pop, mode_page_mrw)

//
// Define mode flexible disk page.
//

#pragma pack(push, mode_page_flex, 1)
typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
} MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;
#pragma pack(pop, mode_page_flex)

//
// Define mode format page.
//

#pragma pack(push, mode_page_format, 1)
typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
} MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;
#pragma pack(pop, mode_page_format)

//
// Define rigid disk driver geometry page.
//

#pragma pack(push, mode_page_geometry, 1)
typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;
#pragma pack(pop, mode_page_geometry)

//
// Define read write recovery page
//

#pragma pack(push, mode_page_rw_recovery, 1)
typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;
#pragma pack(pop, mode_page_rw_recovery)

//
// Define read recovery page - cdrom
//

#pragma pack(push, mode_page_r_recovery, 1)
typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;
#pragma pack(pop, mode_page_r_recovery)


//
// Define Informational Exception Control Page. Used for failure prediction
//

#pragma pack(push, mode_page_xcpt, 1)
typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR LogErr : 1;
            UCHAR Reserved2 : 1;
            UCHAR Test : 1;
            UCHAR Dexcpt : 1;
            UCHAR Reserved3 : 3;
            UCHAR Perf : 1;
        };
    };
        
    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];
    UCHAR ReportCount[4];

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;
#pragma pack(pop, mode_page_xcpt)

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

#pragma pack(push, mode_page_power, 1)
typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];
    UCHAR StandbyTimer[4];
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;
#pragma pack(pop, mode_page_power)

//
// CD-Audio Control Mode Page Format
//

#pragma pack(push, mode_page_cdaudio, 1)
typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;

typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;
#pragma pack(pop, mode_page_cdaudio)

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

#pragma pack(push, mode_page_features, 1)
typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;
#pragma pack(pop, mode_page_features)

//
// CDVD Inactivity Time-out Page Format
//

#pragma pack(push, mode_page_timeout, 1)
typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;
#pragma pack(pop, mode_page_timeout)

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


#pragma pack(push, mode_page_capabilities, 1)
typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // >= 0x18      // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR BufferUnderrunFree : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    union {
        UCHAR ReadSpeedMaximum[2];
        UCHAR ObsoleteReserved[2];          // offset 8
    };
    
    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12

    union {
        UCHAR ReadSpeedCurrent[2];
        UCHAR ObsoleteReserved2[2];         // offset 14
    };
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    union {
        UCHAR WriteSpeedMaximum[2];
        UCHAR ObsoleteReserved4[2];         // offset 18
    };
    union {
        UCHAR WriteSpeedCurrent[2];
        UCHAR ObsoleteReserved11[2];        // offset 20
    };

    //
    // NOTE: This mode page is two bytes too small in the release
    //       version of the Windows2000 DDK.  it also incorrectly
    //       put the CopyManagementRevision at offset 20 instead
    //       of offset 22, so fix that with a nameless union (for
    //       backwards-compatibility with those who "fixed" it on
    //       their own by looking at Reserved10[]).
    //

    union {
        UCHAR CopyManagementRevision[2];    // offset 22
        UCHAR Reserved10[2];
    };
    //UCHAR Reserved12[2];                    // offset 24

} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;
#pragma pack(pop, mode_page_capabilities)

#pragma pack(push, lun_list, 1)
typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
} LUN_LIST, *PLUN_LIST;
#pragma pack(pop, lun_list)


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

#pragma pack(push, mode_parm_rw, 1)
typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;
#pragma pack(pop, mode_parm_rw)


//
// Tape definitions
//

#pragma pack(push, tape_position, 1)
typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;
#pragma pack(pop, tape_position)

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB big endians values.
//

#pragma pack(push, byte_stuff, 1)
typedef union _EIGHT_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    };

    ULONGLONG AsULongLong;
} EIGHT_BYTE, *PEIGHT_BYTE;

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;
#pragma pack(pop, byte_stuff)

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES_QUAD(Destination, Source) {           \
    PEIGHT_BYTE d = (PEIGHT_BYTE)(Destination);             \
    PEIGHT_BYTE s = (PEIGHT_BYTE)(Source);                  \
    d->Byte7 = s->Byte0;                                    \
    d->Byte6 = s->Byte1;                                    \
    d->Byte5 = s->Byte2;                                    \
    d->Byte4 = s->Byte3;                                    \
    d->Byte3 = s->Byte4;                                    \
    d->Byte2 = s->Byte5;                                    \
    d->Byte1 = s->Byte6;                                    \
    d->Byte0 = s->Byte7;                                    \
}

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

#define REVERSE_BYTES_SHORT(Destination, Source) {          \
    PTWO_BYTE d = (PTWO_BYTE)(Destination);                 \
    PTWO_BYTE s = (PTWO_BYTE)(Source);                      \
    d->Byte1 = s->Byte0;                                    \
    d->Byte0 = s->Byte1;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}


#if defined DebugPrint
   #undef DebugPrint
#endif

#if DBG

#define DebugPrint(x) TapeDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Define capabilites and mechanical status page.
//

typedef struct _MODE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2[2];
    UCHAR RO : 1;
    UCHAR Reserved3 : 4;
    UCHAR SPREV : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5 : 3;
    UCHAR EFMT : 1;
    UCHAR Reserved6 : 1;
    UCHAR QFA : 1;
    UCHAR Reserved7 : 2;
    UCHAR LOCK : 1;
    UCHAR LOCKED : 1;
    UCHAR PREVENT : 1;
    UCHAR UNLOAD : 1;
    UCHAR Reserved8 : 2;
    UCHAR ECC : 1;
    UCHAR CMPRS : 1;
    UCHAR Reserved9 : 1;
    UCHAR BLK512 : 1;
    UCHAR BLK1024 : 1;
    UCHAR Reserved10 : 4;
    UCHAR SLOWB : 1;
    UCHAR MaximumSpeedSupported[2];
    UCHAR MaximumStoredDefectedListEntries[2];
    UCHAR ContinuousTransferLimit[2];
    UCHAR CurrentSpeedSelected[2];
    UCHAR BufferSize[2];
    UCHAR Reserved11[2];

} MODE_CAPABILITIES_PAGE, *PMODE_CAPABILITIES_PAGE;

typedef struct _MODE_CAP_PAGE {

    MODE_PARAMETER_HEADER   ParameterListHeader;
    MODE_PARAMETER_BLOCK    ParameterListBlock;
    MODE_CAPABILITIES_PAGE  CapabilitiesPage;

} MODE_CAP_PAGE, *PMODE_CAP_PAGE;



//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;

typedef struct _MODE_MEDIUM_PART_PAGE_PLUS {

    MODE_PARAMETER_HEADER       ParameterListHeader;
    MODE_PARAMETER_BLOCK        ParameterListBlock;
    MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE_PLUS, *PMODE_MEDIUM_PART_PAGE_PLUS;



//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;

typedef struct _MODE_DEVICE_CONFIG_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE_PLUS, *PMODE_DEVICE_CONFIG_PAGE_PLUS ;

//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;

typedef struct _MODE_DATA_COMPRESS_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE_PLUS, *PMODE_DATA_COMPRESS_PAGE_PLUS;



//
// Tape/Minitape definition.
//

typedef
BOOLEAN
(*TAPE_VERIFY_INQUIRY_ROUTINE)(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef
VOID
(*TAPE_EXTENSION_INIT_ROUTINE)(
    IN  PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef enum _TAPE_STATUS {
    TAPE_STATUS_SEND_SRB_AND_CALLBACK,
    TAPE_STATUS_CALLBACK,
    TAPE_STATUS_CHECK_TEST_UNIT_READY,

    TAPE_STATUS_SUCCESS,
    TAPE_STATUS_INSUFFICIENT_RESOURCES,
    TAPE_STATUS_NOT_IMPLEMENTED,
    TAPE_STATUS_INVALID_DEVICE_REQUEST,
    TAPE_STATUS_INVALID_PARAMETER,

    TAPE_STATUS_MEDIA_CHANGED,
    TAPE_STATUS_BUS_RESET,
    TAPE_STATUS_SETMARK_DETECTED,
    TAPE_STATUS_FILEMARK_DETECTED,
    TAPE_STATUS_BEGINNING_OF_MEDIA,
    TAPE_STATUS_END_OF_MEDIA,
    TAPE_STATUS_BUFFER_OVERFLOW,
    TAPE_STATUS_NO_DATA_DETECTED,
    TAPE_STATUS_EOM_OVERFLOW,
    TAPE_STATUS_NO_MEDIA,
    TAPE_STATUS_IO_DEVICE_ERROR,
    TAPE_STATUS_UNRECOGNIZED_MEDIA,

    TAPE_STATUS_DEVICE_NOT_READY,
    TAPE_STATUS_MEDIA_WRITE_PROTECTED,
    TAPE_STATUS_DEVICE_DATA_ERROR,
    TAPE_STATUS_NO_SUCH_DEVICE,
    TAPE_STATUS_INVALID_BLOCK_LENGTH,
    TAPE_STATUS_IO_TIMEOUT,
    TAPE_STATUS_DEVICE_NOT_CONNECTED,
    TAPE_STATUS_DATA_OVERRUN,
    TAPE_STATUS_DEVICE_BUSY,
    TAPE_STATUS_REQUIRES_CLEANING,
    TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED

} TAPE_STATUS, *PTAPE_STATUS;

typedef
VOID
(*TAPE_ERROR_ROUTINE)(
    IN      PVOID               MinitapeExtension,
    IN      PSCSI_REQUEST_BLOCK Srb,
    IN OUT  PTAPE_STATUS        TapeStatus
    );

#define TAPE_RETRY_MASK 0x0000FFFF
#define IGNORE_ERRORS   0x00010000
#define RETURN_ERRORS   0x00020000

typedef
TAPE_STATUS
(*TAPE_PROCESS_COMMAND_ROUTINE)(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         StatusOfLastCommand,
    IN OUT  PULONG              RetryFlags
    );

//
// NT 4.0 miniclass drivers will be using this.
//

typedef struct _TAPE_INIT_DATA {
    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;
} TAPE_INIT_DATA, *PTAPE_INIT_DATA;

typedef struct _TAPE_INIT_DATA_EX {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // Keep the 4.0 init data as is, so support of these
    // drivers can be as seamless as possible.
    //

    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;

    //
    // New entry points / information for 5.0
    //
    // Returns supported media types for the device.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeGetMediaTypes;

    //
    // Indicates the number of different types the drive supports.
    //

    ULONG                           MediaTypesSupported;

    //
    // Entry point for all WMI operations that the driver/device supports.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeWMIOperations;
    ULONG                           Reserved[2];
} TAPE_INIT_DATA_EX, *PTAPE_INIT_DATA_EX;

SCSIPORT_API
ULONG
TapeClassInitialize(
    IN  PVOID           Argument1,
    IN  PVOID           Argument2,
    IN  PTAPE_INIT_DATA_EX TapeInitData
    );

SCSIPORT_API
BOOLEAN
TapeClassAllocateSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               SrbBufferSize
    );

SCSIPORT_API
VOID
TapeClassZeroMemory(
    IN OUT  PVOID   Buffer,
    IN      ULONG   BufferSize
    );

SCSIPORT_API
ULONG
TapeClassCompareMemory(
    IN OUT  PVOID   Source1,
    IN OUT  PVOID   Source2,
    IN      ULONG   Length
    );

SCSIPORT_API
LARGE_INTEGER
TapeClassLiDiv(
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor
    );

SCSIPORT_API
VOID
TapeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// defines for QIC tape density codes
//

#define QIC_XX     0   // ????
#define QIC_24     5   // 0x05
#define QIC_120    15  // 0x0F
#define QIC_150    16  // 0x10
#define QIC_525    17  // 0x11
#define QIC_1350   18  // 0x12
#define QIC_1000   21  // 0x15
#define QIC_1000C  30  // 0x1E
#define QIC_2100   31  // 0x1F
#define QIC_2GB    34  // 0x22
#define QIC_5GB    40  // 0x28

//
// defines for QIC tape media codes
//

#define DCXXXX   0
#define DC300    1
#define DC300XLP 2
#define DC615    3
#define DC600    4
#define DC6037   5
#define DC6150   6
#define DC6250   7
#define DC6320   8
#define DC6525   9
#define DC9135SL 33  //0x21
#define DC9210   34  //0x22
#define DC9135   35  //0x23
#define DC9100   36  //0x24
#define DC9120   37  //0x25
#define DC9120SL 38  //0x26
#define DC9164   39  //0x27
#define DCXXXXFW 48  //0x30
#define DC9200SL 49  //0x31
#define DC9210XL 50  //0x32
#define DC10GB   51  //0x33
#define DC9200   52  //0x34
#define DC9120XL 53  //0x35
#define DC9210SL 54  //0x36
#define DC9164XL 55  //0x37
#define DC9200XL 64  //0x40
#define DC9400   65  //0x41
#define DC9500   66  //0x42
#define DC9500SL 70  //0x46

//
// defines for translation reference point
//

#define NOT_FROM_BOT 0
#define FROM_BOT 1

//
// info/structure returned by/from
// TapeLogicalBlockToPhysicalBlock( )
//

typedef struct _TAPE_PHYS_POSITION {
    ULONG SeekBlockAddress;
    ULONG SpaceBlockCount;
} TAPE_PHYS_POSITION, PTAPE_PHYS_POSITION;

//
// function prototypes
//

TAPE_PHYS_POSITION
TapeClassLogicalBlockToPhysicalBlock(
    IN UCHAR DensityCode,
    IN ULONG LogicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );

ULONG
TapeClassPhysicalBlockToLogicalBlock(
    IN UCHAR DensityCode,
    IN ULONG PhysicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );


//
// LOG SENSE Page codes
//
#define TapeAlertLogPage  0x2E

//
// Type of tape drive alert information
// supported by the drive.
// For example, if the type is TapeAlertInfoNone, the drive doesn't
// support any alert info. Need to use read\write error counters
// to predict drive problems. If the type is TapeAlertInfoRequestSense,
// request sense command can be used to determine drive problems.
//
typedef enum _TAPE_ALERT_INFO_TYPE { 
   TapeAlertInfoNone,        
   TapeAlertInfoRequestSense,
   TapeAlertInfoLogPage   
} TAPE_ALERT_INFO_TYPE;

//
// Tape alert information
//
#define READ_WARNING            1
#define WRITE_WARNING           2
#define HARD_ERROR              3 
#define MEDIA_ERROR             4
#define READ_FAILURE            5
#define WRITE_FAILURE           6
#define MEDIA_LIFE              7
#define NOT_DATA_GRADE          8
#define WRITE_PROTECT           9
#define NO_REMOVAL              10
#define CLEANING_MEDIA          11
#define UNSUPPORTED_FORMAT      12
#define SNAPPED_TAPE            13
#define CLEAN_NOW               20
#define CLEAN_PERIODIC          21
#define EXPIRED_CLEANING_MEDIA  22
#define HARDWARE_A              30
#define HARDWARE_B              31
#define INTERFACE_ERROR         32
#define EJECT_MEDIA             33
#define DOWNLOAD_FAIL           34

//
// The following structs are duplicated from wmidata.h
// wmidata.h is generated from wmicore.mof file. Should
// the MOF file change for these structs, the corresponding
// change should be made in these structs also. 
// Since minidrivers do not have access wmidata.h, we need
// to duplicate it here.
//
// ISSUE : 02/28/2000 - nramas : Should find a better way to
// handle the above. Duplication will cause problems in keeping
// these definitions in sync.
//
typedef struct _WMI_TAPE_DRIVE_PARAMETERS
{
    // Maximum block size supported
    ULONG MaximumBlockSize;

    // Minimum block size supported
    ULONG MinimumBlockSize;
    
    // Default block size supported
    ULONG DefaultBlockSize;

    // Maximum number of partitions allowed.
    ULONG MaximumPartitionCount;

    // TRUE if drive supports compression.
    BOOLEAN CompressionCapable;

    // TRUE if compression is enabled.
    BOOLEAN CompressionEnabled;

    // TRUE if drive reports setmarks
    BOOLEAN ReportSetmarks;

    // TRUE if drive supports hardware error correction
    BOOLEAN HardwareErrorCorrection;
} WMI_TAPE_DRIVE_PARAMETERS, *PWMI_TAPE_DRIVE_PARAMETERS;

typedef struct _WMI_TAPE_MEDIA_PARAMETERS
{
    // Maximum capacity of the media
    ULONGLONG MaximumCapacity;

    // Available capacity of the media
    ULONGLONG AvailableCapacity;

    // Current blocksize
    ULONG BlockSize;

    // Current number of partitions
    ULONG PartitionCount;

    // TRUEif media is write protected
    BOOLEAN MediaWriteProtected;
} WMI_TAPE_MEDIA_PARAMETERS, *PWMI_TAPE_MEDIA_PARAMETERS;


typedef struct _WMI_TAPE_PROBLEM_WARNING
{
    // Tape drive problem warning event
    ULONG DriveProblemType;

    // Tape drive problem data
    UCHAR TapeData[512];
} WMI_TAPE_PROBLEM_WARNING, *PWMI_TAPE_PROBLEM_WARNING;

typedef struct _WMI_TAPE_PROBLEM_IO_ERROR
{
    // Read errors corrected without much delay
    ULONG ReadCorrectedWithoutDelay;

    // Read errors corrected with substantial delay
    ULONG ReadCorrectedWithDelay;

    // Total number of Read errors
    ULONG ReadTotalErrors;

    // Total number of read errors that were corrected
    ULONG ReadTotalCorrectedErrors;

    // Total number of uncorrected read errors
    ULONG ReadTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for read
    ULONG ReadCorrectionAlgorithmProcessed;

    // Write errors corrected without much delay
    ULONG WriteCorrectedWithoutDelay;

    // Write errors corrected with substantial delay
    ULONG WriteCorrectedWithDelay;

    // Total number of Read errors
    ULONG WriteTotalErrors;

    // Total number of write errors that were corrected
    ULONG WriteTotalCorrectedErrors;

    // Total number of uncorrected write errors
    ULONG WriteTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for write
    ULONG WriteCorrectionAlgorithmProcessed;

    // Errors not related to medium
    ULONG NonMediumErrors;
} WMI_TAPE_PROBLEM_IO_ERROR, *PWMI_TAPE_PROBLEM_IO_ERROR;

typedef struct _WMI_TAPE_PROBLEM_DEVICE_ERROR
{

   // WARNING : Drive is experiencing read problem.
   BOOLEAN ReadWarning;
   
   // WARNING : Drive is experiencing write problem.
   BOOLEAN WriteWarning;

   // Drive hardware problem
   BOOLEAN HardError;

   // Critical Error : Too many read errors.
   BOOLEAN ReadFailure;

   // Critical Error : Too many write errors.
   BOOLEAN WriteFailure;

   // Tape format not supported
   BOOLEAN UnsupportedFormat;

   // Tape is snapped. Replace media
   BOOLEAN TapeSnapped;

   // Drive Requires Cleaning
   BOOLEAN DriveRequiresCleaning;

   // It's time to clean the drive
   BOOLEAN TimetoCleanDrive;

   // Hardware error. Check drive
   BOOLEAN DriveHardwareError;

   // Some error in cabling, or connection.
   BOOLEAN ScsiInterfaceError;

   // Critical Error : Media life expired. 
   BOOLEAN MediaLife;
} WMI_TAPE_PROBLEM_DEVICE_ERROR, *PWMI_TAPE_PROBLEM_DEVICE_ERROR;


#endif /* _MINITAPE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\msports.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:        msports.h
//
//  Contents:    public header file for COM name arbitration database
//               and Advanced dialog override and invocation
//
//--------------------------------------------------------------------

#ifndef _MSPORTS_H
#define _MSPORTS_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SERIAL_ADVANCED_SETTINGS

/*++

Routine Description:

    Displays the advanced properties dialog for the COM port specified by
    DeviceInfoSet and DeviceInfoData.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

Return Value:

    ERROR_SUCCESS if the dialog was shown

  --*/
LONG
SerialDisplayAdvancedSettings(IN HWND             ParentHwnd,
                              IN HDEVINFO         DeviceInfoSet,
                              IN PSP_DEVINFO_DATA DeviceInfoData
                              );

/*++

Routine Description:

    Prototype to allow serial port vendors to override the advanced dialog
    represented by the COM port specified by DeviceInfoSet and DeviceInfoData.

    To override the advanced page, place a value named EnumAdvancedDialog under
    the same key in which you would put your EnumPropPages32 value.  The format
    of the value is exactly the same as Enum...32 as well.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    HidePollingUI - If TRUE, hide all UI that deals with polling.

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

    Reserved - Unused

Return Value:

    TRUE if the user pressed OK, FALSE if Cancel was pressed
--*/

typedef
BOOL
(*PPORT_ADVANCED_DIALOG) (
    IN HWND             ParentHwnd,
    IN BOOL             HidePollingUI,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PVOID            Reserved
    );

#endif

DECLARE_HANDLE(HCOMDB);
typedef HCOMDB *PHCOMDB;
#define HCOMDB_INVALID_HANDLE_VALUE ((HCOMDB) INVALID_HANDLE_VALUE)

//
// Minimum through maximum number of COM names arbitered
//
#define COMDB_MIN_PORTS_ARBITRATED 256
#define COMDB_MAX_PORTS_ARBITRATED 4096

LONG
WINAPI
ComDBOpen (
    PHCOMDB PHComDB
    );
/*++

Routine Description:

    Opens name data base, and returns a handle to be used in future calls.

Arguments:

    None.

Return Value:

    INVALID_HANDLE_VALUE if the call fails, otherwise a valid handle

    If INVALID_HANDLE_VALUE, call GetLastError() to get details (??)

--*/

LONG
WINAPI
ComDBClose (
    HCOMDB HComDB
    );
/*++

Routine Description:

    frees a handle to the database returned from OpenComPortDataBase

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:

    None

--*/

#define CDB_REPORT_BITS      0x0
#define CDB_REPORT_BYTES     0x1

LONG
WINAPI
ComDBGetCurrentPortUsage (
    HCOMDB   HComDB,
    PBYTE    Buffer,
    DWORD    BufferSize,
    ULONG    ReportType, // CDB_REPORT value
    LPDWORD  MaxPortsReported
    );
/*++

Routine Description:

    if Buffer is NULL, than MaxPortsReported will contain the max number of ports
        the DB will report (this value is NOT the number of bytes need for Buffer).
        ReportType is ignored in this case.

    if ReportType == CDB_REPORT_BITS
        returns a bit array indicating if a comX name is claimed.
        ie, Bit 0 of Byte 0 is com1, bit 1 of byte 0 is com2 and so on.

        BufferSize >= MaxPortsReported / 8


    if ReportType == CDB_REPORT_BYTES
        returns a byte array indicating if a comX name is claimed.  Zero unused, non zero
        used, ie, byte 0 is com1, byte 1 is com2, etc

        BufferSize >= MaxPortsReported

Arguments:

    Handle returned from OpenComPortDataBase.

    Buffer pointes to memory to place bit array

    BufferSize   Size of buffer in bytes

    MaxPortsReported    Pointer to DWORD that holds the number of bytes in buffer filled in

Return Value:

    returns ERROR_SUCCESS if successful.
            ERROR_NOT_CONNECTED cannot connect to DB
            ERROR_MORE_DATA if buffer not large enough

--*/


LONG
WINAPI
ComDBClaimNextFreePort (
    HCOMDB   HComDB,
    LPDWORD  ComNumber
    );
/*++

Routine Description:

    returns the first free COMx value

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:


    returns ERROR_SUCCESS if successful. or other ERROR_ if not

    if successful, then ComNumber will be that next free com value and claims it in the database


--*/



LONG
WINAPI
ComDBClaimPort (
    HCOMDB   HComDB,
    DWORD    ComNumber,
    BOOL     ForceClaim,
    PBOOL    Forced /* optional */
    );
/*++

Routine Description:

    Attempts to claim a com name in the database

Arguments:

    DataBaseHandle - returned from OpenComPortDataBase.

    ComNumber      - The port value to be claimed

    Force          - If TRUE, will force the port to be claimed even if in use already

    Forced         - will reflect the event that the claim was forced

Return Value:


    returns ERROR_SUCCESS if port name was not already claimed, or if it was claimed
                          and Force was TRUE.

            ERROR_SHARING_VIOLATION if port name is use and Force is false


--*/

LONG
WINAPI
ComDBReleasePort (
    HCOMDB   HComDB,
    DWORD    ComNumber
    );
/*++

Routine Description:

    Releases the port in the database

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    ComNumber      - port to be unclaimed in database

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_INVALID_PARAMETER if ComNumber is greater than the number of
                                    ports arbitrated


--*/

LONG
WINAPI
ComDBResizeDatabase (
    HCOMDB   HComDB,
    DWORD    NewSize
    );
/*++

Routine Description:

    Resizes the database to the new size.  To get the current size, call
    ComDBGetCurrentPortUsage with a Buffer == NULL.

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    NewSize        - must be a multiple of 1024, with a max of 4096

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_BAD_LENGTH if NewSize is not greater than the current size or
                             NewSize is greater than COMDB_MAX_PORTS_ARBITRATED

--*/


#ifdef __cplusplus
}
#endif


#endif // _MSPORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\mountmgr.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    mountmgr.h

Abstract:

    This file defines the external mount point interface for administering
    mount points.

Author:

    norbertk

Revision History:

--*/

#ifndef _MOUNTMGR_
#define _MOUNTMGR_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef FAR
#define FAR
#endif


#define MOUNTMGR_DEVICE_NAME        L"\\Device\\MountPointManager"
#define MOUNTMGR_DOS_DEVICE_NAME    L"\\\\.\\MountPointManager"

#define MOUNTMGRCONTROLTYPE  ((ULONG) 'm')
#define MOUNTDEVCONTROLTYPE  ((ULONG) 'M')

//
// These are the IOCTLs supported by the mount point manager.
//

#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                 CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY         CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER            CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS          CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED   CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED   CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY                CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE      CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES    CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH        CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS       CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_SCRUB_REGISTRY               CTL_CODE(MOUNTMGRCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT             CTL_CODE(MOUNTMGRCONTROLTYPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_SET_AUTO_MOUNT               CTL_CODE(MOUNTMGRCONTROLTYPE, 16, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Input structure for IOCTL_MOUNTMGR_CREATE_POINT.
//

typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
    USHORT  SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    USHORT  DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

//
// Input structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINT {
    ULONG   SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    ULONG   UniqueIdOffset;
    USHORT  UniqueIdLength;
    ULONG   DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

//
// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINTS {
    ULONG                   Size;
    ULONG                   NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT    MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

//
// Input structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

//
// Output structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
    BOOLEAN DriveLetterWasAssigned;
    UCHAR   CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

//
// Input structure for IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED and
// IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED.
//

typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT {
    USHORT  SourceVolumeNameOffset;
    USHORT  SourceVolumeNameLength;
    USHORT  TargetVolumeNameOffset;
    USHORT  TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

//
// Input structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
// Output structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
//

typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
    ULONG   EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

//
// Input structure for IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE,
// IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH, and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_TARGET_NAME {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_TARGET_NAME, *PMOUNTMGR_TARGET_NAME;

//
// Output structure for IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_VOLUME_PATHS {
    ULONG   MultiSzLength;
    WCHAR   MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

//
// Macro that defines what a "drive letter" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are find "drive letter" mount points.
//

#define MOUNTMGR_IS_DRIVE_LETTER(s) (   \
    (s)->Length == 28 &&                \
    (s)->Buffer[0] == '\\' &&           \
    (s)->Buffer[1] == 'D' &&            \
    (s)->Buffer[2] == 'o' &&            \
    (s)->Buffer[3] == 's' &&            \
    (s)->Buffer[4] == 'D' &&            \
    (s)->Buffer[5] == 'e' &&            \
    (s)->Buffer[6] == 'v' &&            \
    (s)->Buffer[7] == 'i' &&            \
    (s)->Buffer[8] == 'c' &&            \
    (s)->Buffer[9] == 'e' &&            \
    (s)->Buffer[10] == 's' &&           \
    (s)->Buffer[11] == '\\' &&          \
    (s)->Buffer[12] >= 'A' &&           \
    (s)->Buffer[12] <= 'Z' &&           \
    (s)->Buffer[13] == ':')

//
// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
//

#define MOUNTMGR_IS_VOLUME_NAME(s) (                                          \
     ((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
     (s)->Buffer[0] == '\\' &&                                                \
     ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') &&                     \
     (s)->Buffer[2] == '?' &&                                                 \
     (s)->Buffer[3] == '\\' &&                                                \
     (s)->Buffer[4] == 'V' &&                                                 \
     (s)->Buffer[5] == 'o' &&                                                 \
     (s)->Buffer[6] == 'l' &&                                                 \
     (s)->Buffer[7] == 'u' &&                                                 \
     (s)->Buffer[8] == 'm' &&                                                 \
     (s)->Buffer[9] == 'e' &&                                                 \
     (s)->Buffer[10] == '{' &&                                                \
     (s)->Buffer[19] == '-' &&                                                \
     (s)->Buffer[24] == '-' &&                                                \
     (s)->Buffer[29] == '-' &&                                                \
     (s)->Buffer[34] == '-' &&                                                \
     (s)->Buffer[47] == '}'                                                   \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) (    \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME(s) (     \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) (  \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

//
// The following IOCTL is supported by mounted devices.
//

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME    CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
//

typedef struct _MOUNTDEV_NAME {
    USHORT  NameLength;
    WCHAR   Name[1];
} MOUNTDEV_NAME, *PMOUNTDEV_NAME;

//
// Devices that wish to be mounted should report this GUID in
// IoRegisterDeviceInterface.
//

DEFINE_GUID(MOUNTDEV_MOUNTED_DEVICE_GUID, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);




//
// Input / Output structure for querying / setting the auto-mount setting
//

typedef enum _MOUNTMGR_AUTO_MOUNT_STATE {
        Disabled = 0,
        Enabled
        } MOUNTMGR_AUTO_MOUNT_STATE;

typedef struct _MOUNTMGR_QUERY_AUTO_MOUNT {
    MOUNTMGR_AUTO_MOUNT_STATE   CurrentState;
    } MOUNTMGR_QUERY_AUTO_MOUNT, *PMOUNTMGR_QUERY_AUTO_MOUNT;

typedef struct _MOUNTMGR_SET_AUTO_MOUNT {
    MOUNTMGR_AUTO_MOUNT_STATE   NewState;
    } MOUNTMGR_SET_AUTO_MOUNT, *PMOUNTMGR_SET_AUTO_MOUNT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\msacmdrv.h ===
//==========================================================================;
//
//  msacmdrv.h
//
//  Copyright (c) 1992-1999 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File for Drivers
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACMDRV
#define _INC_ACMDRV         /* #defined if msacmdrv.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_ACM)
#ifndef RC_INVOKED
#error MSACM.H to be included first
#endif
#endif

#include "pshpack1.h"   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAKE_ACM_VERSION(mjr, mnr, bld) (((long)(mjr)<<24)| \
                                         ((long)(mnr)<<16)| \
                                         ((long)bld))


#ifdef WIN32
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  under WIN32 all drivers use unicode structures.  these have already
//  been #defined in MSACM.H.  however, regardless of whether UNICODE is
//  defined, we will define these structures as unicode structures for use
//  in 32-bit drivers.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#undef ACMDRIVERDETAILS
#undef PACMDRIVERDETAILS
#undef LPACMDRIVERDETAILS

#undef ACMFORMATTAGDETAILS
#undef PACMFORMATTAGDETAILS
#undef LPACMFORMATTAGDETAILS

#undef ACMFORMATDETAILS
#undef PACMFORMATDETAILS
#undef LPACMFORMATDETAILS

#undef ACMFORMATCHOOSE
#undef PACMFORMATCHOOSE
#undef LPACMFORMATCHOOSE

#undef ACMFILTERTAGDETAILS
#undef PACMFILTERTAGDETAILS
#undef LPACMFILTERTAGDETAILS

#undef ACMFILTERDETAILS
#undef PACMFILTERDETAILS
#undef LPACMFILTERDETAILS

#undef ACMFILTERCHOOSE
#undef PACMFILTERCHOOSE
#undef LPACMFILTERCHOOSE

#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW

#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW

#define ACMFORMATDETAILS	ACMFORMATDETAILSW
#define PACMFORMATDETAILS	PACMFORMATDETAILSW
#define LPACMFORMATDETAILS	LPACMFORMATDETAILSW

#define ACMFORMATCHOOSE		ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE	PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE	LPACMFORMATCHOOSEW

#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW

#define ACMFILTERDETAILS	ACMFILTERDETAILSW
#define PACMFILTERDETAILS	PACMFILTERDETAILSW
#define LPACMFILTERDETAILS	LPACMFILTERDETAILSW

#define ACMFILTERCHOOSE		ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE	PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE	LPACMFILTERCHOOSEW

#endif

//
//
//
//
//
#define ACMDRVOPENDESC_SECTIONNAME_CHARS

#ifdef _WIN32
typedef struct tACMDRVOPENDESCA
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCA, *PACMDRVOPENDESCA, FAR *LPACMDRVOPENDESCA;

typedef struct tACMDRVOPENDESCW
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCWSTR         pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCWSTR         pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCW, *PACMDRVOPENDESCW, FAR *LPACMDRVOPENDESCW;

#define ACMDRVOPENDESC      ACMDRVOPENDESCW
#define PACMDRVOPENDESC     PACMDRVOPENDESCW
#define LPACMDRVOPENDESC    LPACMDRVOPENDESCW
#else
typedef struct tACMDRVOPENDESC
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESC, *PACMDRVOPENDESC, FAR *LPACMDRVOPENDESC;
#endif


//
//
//
//
//
typedef struct tACMDRVSTREAMINSTANCE
{
    DWORD               cbStruct;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD_PTR           dwCallback;
    DWORD_PTR           dwInstance;
    DWORD               fdwOpen;
    DWORD               fdwDriver;
    DWORD_PTR           dwDriver;
    HACMSTREAM          has;

} ACMDRVSTREAMINSTANCE, *PACMDRVSTREAMINSTANCE, FAR *LPACMDRVSTREAMINSTANCE;


//
//  NOTE! this structure must match the ACMSTREAMHEADER in msacm.h but
//  defines more information for the driver writing convenience
//
typedef struct tACMDRVSTREAMHEADER FAR *LPACMDRVSTREAMHEADER;
typedef struct tACMDRVSTREAMHEADER
{
    DWORD                   cbStruct;
    DWORD                   fdwStatus;
    DWORD_PTR               dwUser;
    LPBYTE                  pbSrc;
    DWORD                   cbSrcLength;
    DWORD                   cbSrcLengthUsed;
    DWORD_PTR               dwSrcUser;
    LPBYTE                  pbDst;
    DWORD                   cbDstLength;
    DWORD                   cbDstLengthUsed;
    DWORD_PTR               dwDstUser;

    DWORD                   fdwConvert;     // flags passed from convert func
    LPACMDRVSTREAMHEADER    padshNext;      // for async driver queueing
    DWORD                   fdwDriver;      // driver instance flags
    DWORD_PTR               dwDriver;       // driver instance data

    //
    //  all remaining fields are used by the ACM for bookkeeping purposes.
    //  an ACM driver should never use these fields (though than can be
    //  helpful for debugging)--note that the meaning of these fields
    //  may change, so do NOT rely on them in shipping code.
    //
    DWORD                   fdwPrepared;
    DWORD_PTR               dwPrepared;
    LPBYTE                  pbPreparedSrc;
    DWORD                   cbPreparedSrcLength;
    LPBYTE                  pbPreparedDst;
    DWORD                   cbPreparedDstLength;

} ACMDRVSTREAMHEADER, *PACMDRVSTREAMHEADER;


//
//  structure for ACMDM_STREAM_SIZE message
//
//
typedef struct tACMDRVSTREAMSIZE
{
    DWORD               cbStruct;
    DWORD               fdwSize;
    DWORD               cbSrcLength;
    DWORD               cbDstLength;

} ACMDRVSTREAMSIZE, *PACMDRVSTREAMSIZE, FAR *LPACMDRVSTREAMSIZE;



//
//  structure containing the information for the ACMDM_FORMAT_SUGGEST message
//
//
typedef struct tACMDRVFORMATSUGGEST
{
    DWORD               cbStruct;           // sizeof(ACMDRVFORMATSUGGEST)
    DWORD               fdwSuggest;         // Suggest flags
    LPWAVEFORMATEX      pwfxSrc;            // Source Format
    DWORD               cbwfxSrc;           // Source Size
    LPWAVEFORMATEX      pwfxDst;            // Dest format
    DWORD               cbwfxDst;           // Dest Size

} ACMDRVFORMATSUGGEST, *PACMDRVFORMATSUGGEST, FAR *LPACMDRVFORMATSUGGEST;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Messages
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMDM_DRIVER_NOTIFY             (ACMDM_BASE + 1)
#define ACMDM_DRIVER_DETAILS            (ACMDM_BASE + 10)

#define ACMDM_HARDWARE_WAVE_CAPS_INPUT  (ACMDM_BASE + 20)
#define ACMDM_HARDWARE_WAVE_CAPS_OUTPUT (ACMDM_BASE + 21)

#define ACMDM_FORMATTAG_DETAILS         (ACMDM_BASE + 25)
#define ACMDM_FORMAT_DETAILS            (ACMDM_BASE + 26)
#define ACMDM_FORMAT_SUGGEST            (ACMDM_BASE + 27)

#define ACMDM_FILTERTAG_DETAILS         (ACMDM_BASE + 50)
#define ACMDM_FILTER_DETAILS            (ACMDM_BASE + 51)

#define ACMDM_STREAM_OPEN               (ACMDM_BASE + 76)
#define ACMDM_STREAM_CLOSE              (ACMDM_BASE + 77)
#define ACMDM_STREAM_SIZE               (ACMDM_BASE + 78)
#define ACMDM_STREAM_CONVERT            (ACMDM_BASE + 79)
#define ACMDM_STREAM_RESET              (ACMDM_BASE + 80)
#define ACMDM_STREAM_PREPARE            (ACMDM_BASE + 81)
#define ACMDM_STREAM_UNPREPARE          (ACMDM_BASE + 82)
#define ACMDM_STREAM_UPDATE	        (ACMDM_BASE + 83)


#include "poppack.h"    /* Revert to default packing */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ndistapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndiswan.h

Abstract:

    Main header file for the TAPI wrapper

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Revision History:

--*/

#ifndef _NDIS_TAPI_
#define _NDIS_TAPI_

//
//
//
//
// Begin definitions for TAPI
//
//
//
//

#ifndef NDIS_TAPI_CURRENT_VERSION
#define NDIS_TAPI_CURRENT_VERSION 0x00010003
#endif
//
// Symbolic constants
//


#define NDIS_STATUS_TAPI_ADDRESSBLOCKED           ((NDIS_STATUS)0xC0012000L)
#define NDIS_STATUS_TAPI_BEARERMODEUNAVAIL        ((NDIS_STATUS)0xC0012001L)
#define NDIS_STATUS_TAPI_CALLUNAVAIL              ((NDIS_STATUS)0xC0012002L)
#define NDIS_STATUS_TAPI_DIALBILLING              ((NDIS_STATUS)0xC0012003L)
#define NDIS_STATUS_TAPI_DIALDIALTONE             ((NDIS_STATUS)0xC0012004L)
#define NDIS_STATUS_TAPI_DIALPROMPT               ((NDIS_STATUS)0xC0012005L)
#define NDIS_STATUS_TAPI_DIALQUIET                ((NDIS_STATUS)0xC0012006L)
#define NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION   ((NDIS_STATUS)0xC0012007L)
#define NDIS_STATUS_TAPI_INUSE                    ((NDIS_STATUS)0xC0012008L)
#define NDIS_STATUS_TAPI_INVALADDRESS             ((NDIS_STATUS)0xC0012009L)
#define NDIS_STATUS_TAPI_INVALADDRESSID           ((NDIS_STATUS)0xC001200AL)
#define NDIS_STATUS_TAPI_INVALADDRESSMODE         ((NDIS_STATUS)0xC001200BL)
#define NDIS_STATUS_TAPI_INVALBEARERMODE          ((NDIS_STATUS)0xC001200CL)
#define NDIS_STATUS_TAPI_INVALCALLHANDLE          ((NDIS_STATUS)0xC001200DL)
#define NDIS_STATUS_TAPI_INVALCALLPARAMS          ((NDIS_STATUS)0xC001200EL)
#define NDIS_STATUS_TAPI_INVALCALLSTATE           ((NDIS_STATUS)0xC001200FL)
#define NDIS_STATUS_TAPI_INVALDEVICECLASS         ((NDIS_STATUS)0xC0012010L)
#define NDIS_STATUS_TAPI_INVALLINEHANDLE          ((NDIS_STATUS)0xC0012011L)
#define NDIS_STATUS_TAPI_INVALLINESTATE           ((NDIS_STATUS)0xC0012012L)
#define NDIS_STATUS_TAPI_INVALMEDIAMODE           ((NDIS_STATUS)0xC0012013L)
#define NDIS_STATUS_TAPI_INVALRATE                ((NDIS_STATUS)0xC0012014L)
#define NDIS_STATUS_TAPI_NODRIVER                 ((NDIS_STATUS)0xC0012015L)
#define NDIS_STATUS_TAPI_OPERATIONUNAVAIL         ((NDIS_STATUS)0xC0012016L)
#define NDIS_STATUS_TAPI_RATEUNAVAIL              ((NDIS_STATUS)0xC0012017L)
#define NDIS_STATUS_TAPI_RESOURCEUNAVAIL          ((NDIS_STATUS)0xC0012018L)
#define NDIS_STATUS_TAPI_STRUCTURETOOSMALL        ((NDIS_STATUS)0xC0012019L)
#define NDIS_STATUS_TAPI_USERUSERINFOTOOBIG       ((NDIS_STATUS)0xC001201AL)
#define NDIS_STATUS_TAPI_ALLOCATED                ((NDIS_STATUS)0xC001201BL)
#define NDIS_STATUS_TAPI_INVALADDRESSSTATE        ((NDIS_STATUS)0xC001201CL)
#define NDIS_STATUS_TAPI_INVALPARAM               ((NDIS_STATUS)0xC001201DL)
#define NDIS_STATUS_TAPI_NODEVICE                 ((NDIS_STATUS)0xC001201EL)

//
//  The following DISCONNECTMODE status codes are used by CO_ADDRESS_FAMILY_TAPI
//  NDIS Call Managers as the NDIS status passed to:
//
//  - Ndis[M]CmMakeCallComplete
//  - Ndis[M]CmDispatchIncomingCloseCall
//
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL    ((NDIS_STATUS)0xC0012020L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN   ((NDIS_STATUS)0xC0012021L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT    ((NDIS_STATUS)0xC0012022L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_PICKUP    ((NDIS_STATUS)0xC0012023L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_FORWARDED ((NDIS_STATUS)0xC0012024L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY      ((NDIS_STATUS)0xC0012025L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER  ((NDIS_STATUS)0xC0012026L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS   ((NDIS_STATUS)0xC0012027L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE  ((NDIS_STATUS)0xC0012028L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION   ((NDIS_STATUS)0xC0012029L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE ((NDIS_STATUS)0xC001202AL)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL    ((NDIS_STATUS)0xC001202BL)


#define NDIS_STATUS_TAPI_RECV_DIGIT					((NDIS_STATUS)0x40010020L) // FIXME: Should this be in ndis.h?

#define LINE_ADDRESSSTATE                           0L
#define LINE_CALLINFO                               1L
#define LINE_CALLSTATE                              2L
#define LINE_CLOSE                                  3L
#define LINE_DEVSPECIFIC                            4L
#define LINE_DEVSPECIFICFEATURE                     5L  // not used
#define LINE_GATHERDIGITS                           6L  // not used
#define LINE_GENERATE                               7L  // not used
#define LINE_LINEDEVSTATE                           8L
#define LINE_MONITORDIGITS                          9L  // not used
#define LINE_MONITORMEDIA                           10L // not used
#define LINE_MONITORTONE                            11L // not used
#define LINE_REPLY                                  12L // not used
#define LINE_REQUEST                                13L // not used
#define LINE_CREATE                             	19L // TAPI v1.4

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#endif


#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
#define LINE_AGENTSESSIONSTATUS                 27L             // TAPI v2.2
#define LINE_QUEUESTATUS                        28L             // TAPI v2.2
#define LINE_AGENTSTATUSEX                      29L             // TAPI v2.2
#define LINE_GROUPSTATUS                        30L             // TAPI v2.2
#define LINE_PROXYSTATUS                        31L             // TAPI v2.2
#endif


#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINE_APPNEWCALLHUB                      32L             // TAPI v3.0
#define LINE_CALLHUBCLOSE                       33L             // TAPI v3.0
#define LINE_DEVSPECIFICEX                      34L             // TAPI v3.0
#endif


#define TSPI_MESSAGE_BASE                           500L

#define LINE_NEWCALL                                TSPI_MESSAGE_BASE
#define LINE_CALLDEVSPECIFIC                        (TSPI_MESSAGE_BASE + 1L)

#ifndef __NDISTAPI_STRINGFORMATS_DEFINED
#define __NDISTAPI_STRINGFORMATS_DEFINED

#define STRINGFORMAT_ASCII                          0x00000001
#define STRINGFORMAT_DBCS                           0x00000002
#define STRINGFORMAT_UNICODE                        0x00000003
#define STRINGFORMAT_BINARY                         0x00000004

#endif	// __NDISTAPI_STRINGFORMATS_DEFINED

#define LINEADDRCAPFLAGS_FWDNUMRINGS                0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID              0x00000002
#define LINEADDRCAPFLAGS_SECURE                     0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT             0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE            0x00000010
#define LINEADDRCAPFLAGS_DIALED                     0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK                0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK                0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT                 0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL              0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT              0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID               0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD               0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE               0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD             0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE             0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL                0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID             0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR              0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR              0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT              0x00100000
#define LINEADDRCAPFLAGS_CONFDROP                   0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT             0x00400000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER      		0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  	0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             	0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           	0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        	0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        	0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           	0x20000000      // TAPI v2.0
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRCAPFLAGS_ACDGROUP               	0x40000000      // TAPI v3.0
#define LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION 	0x80000000    // TAPI v3.0
#endif


#define LINEADDRESSMODE_ADDRESSID                   0x00000001
#define LINEADDRESSMODE_DIALABLEADDR                0x00000002

#define LINEADDRESSSHARING_PRIVATE                  0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL              0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW               0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED            0x00000008
#define LINEADDRESSSHARING_MONITORED                0x00000010

#define LINEADDRESSSTATE_OTHER                      0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC                0x00000002
#define LINEADDRESSSTATE_INUSEZERO                  0x00000004
#define LINEADDRESSSTATE_INUSEONE                   0x00000008
#define LINEADDRESSSTATE_INUSEMANY                  0x00000010
#define LINEADDRESSSTATE_NUMCALLS                   0x00000020
#define LINEADDRESSSTATE_FORWARD                    0x00000040
#define LINEADDRESSSTATE_TERMINALS                  0x00000080

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRESSTYPE_PHONENUMBER             0x00000001
#define LINEADDRESSTYPE_SDP                     0x00000002
#define LINEADDRESSTYPE_EMAILNAME               0x00000004
#define LINEADDRESSTYPE_DOMAINNAME              0x00000008
#define LINEADDRESSTYPE_IPADDRESS               0x00000010
#endif

#define LINEADDRFEATURE_FORWARD                     0x00000001
#define LINEADDRFEATURE_MAKECALL                    0x00000002
#define LINEADDRFEATURE_PICKUP                      0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL             0x00000008
#define LINEADDRFEATURE_SETTERMINAL                 0x00000010
#define LINEADDRFEATURE_SETUPCONF                   0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL              0x00000040
#define LINEADDRFEATURE_UNPARK                      0x00000080
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                         0x00000001
#define LINEANSWERMODE_DROP                         0x00000002
#define LINEANSWERMODE_HOLD                         0x00000004

#define LINEBEARERMODE_VOICE                        0x00000001
#define LINEBEARERMODE_SPEECH                       0x00000002
#define LINEBEARERMODE_MULTIUSE                     0x00000004
#define LINEBEARERMODE_DATA                         0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA                0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING             0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                        0x00000001
#define LINEBUSYMODE_TRUNK                          0x00000002
#define LINEBUSYMODE_UNKNOWN                        0x00000004
#define LINEBUSYMODE_UNAVAIL                        0x00000008

#define LINECALLCOMPLCOND_BUSY                      0x00000001
#define LINECALLCOMPLCOND_NOANSWER                  0x00000002

#define LINECALLCOMPLMODE_CAMPON                    0x00000001
#define LINECALLCOMPLMODE_CALLBACK                  0x00000002
#define LINECALLCOMPLMODE_INTRUDE                   0x00000004
#define LINECALLCOMPLMODE_MESSAGE                   0x00000008

#define LINECALLFEATURE_ACCEPT                      0x00000001
#define LINECALLFEATURE_ADDTOCONF                   0x00000002
#define LINECALLFEATURE_ANSWER                      0x00000004
#define LINECALLFEATURE_BLINDTRANSFER               0x00000008
#define LINECALLFEATURE_COMPLETECALL                0x00000010
#define LINECALLFEATURE_COMPLETETRANSF              0x00000020
#define LINECALLFEATURE_DIAL                        0x00000040
#define LINECALLFEATURE_DROP                        0x00000080
#define LINECALLFEATURE_GATHERDIGITS                0x00000100
#define LINECALLFEATURE_GENERATEDIGITS              0x00000200
#define LINECALLFEATURE_GENERATETONE                0x00000400
#define LINECALLFEATURE_HOLD                        0x00000800
#define LINECALLFEATURE_MONITORDIGITS               0x00001000
#define LINECALLFEATURE_MONITORMEDIA                0x00002000
#define LINECALLFEATURE_MONITORTONES                0x00004000
#define LINECALLFEATURE_PARK                        0x00008000
#define LINECALLFEATURE_PREPAREADDCONF              0x00010000
#define LINECALLFEATURE_REDIRECT                    0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF              0x00040000
#define LINECALLFEATURE_SECURECALL                  0x00080000
#define LINECALLFEATURE_SENDUSERUSER                0x00100000
#define LINECALLFEATURE_SETCALLPARAMS               0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL             0x00400000
#define LINECALLFEATURE_SETTERMINAL                 0x00800000
#define LINECALLFEATURE_SETUPCONF                   0x01000000
#define LINECALLFEATURE_SETUPTRANSFER               0x02000000
#define LINECALLFEATURE_SWAPHOLD                    0x04000000
#define LINECALLFEATURE_UNHOLD                      0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif


#define LINECALLINFOSTATE_OTHER                     0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC               0x00000002
#define LINECALLINFOSTATE_BEARERMODE                0x00000004
#define LINECALLINFOSTATE_RATE                      0x00000008
#define LINECALLINFOSTATE_MEDIAMODE                 0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC               0x00000020
#define LINECALLINFOSTATE_CALLID                    0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID             0x00000080
#define LINECALLINFOSTATE_ORIGIN                    0x00000100
#define LINECALLINFOSTATE_REASON                    0x00000200
#define LINECALLINFOSTATE_COMPLETIONID              0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR              0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR              0x00001000
#define LINECALLINFOSTATE_NUMMONITORS               0x00002000
#define LINECALLINFOSTATE_TRUNK                     0x00004000
#define LINECALLINFOSTATE_CALLERID                  0x00008000
#define LINECALLINFOSTATE_CALLEDID                  0x00010000
#define LINECALLINFOSTATE_CONNECTEDID               0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID             0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID             0x00080000
#define LINECALLINFOSTATE_DISPLAY                   0x00100000
#define LINECALLINFOSTATE_USERUSERINFO              0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP             0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP              0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO              0x01000000
#define LINECALLINFOSTATE_TERMINAL                  0x02000000
#define LINECALLINFOSTATE_DIALPARAMS                0x04000000
#define LINECALLINFOSTATE_MONITORMODES              0x08000000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif


#define LINECALLORIGIN_OUTBOUND                     0x00000001
#define LINECALLORIGIN_INTERNAL                     0x00000002
#define LINECALLORIGIN_EXTERNAL                     0x00000004
#define LINECALLORIGIN_UNKNOWN                      0x00000010
#define LINECALLORIGIN_UNAVAIL                      0x00000020
#define LINECALLORIGIN_CONFERENCE                   0x00000040
#define LINECALLORIGIN_INBOUND                      0x00000080

#define LINECALLPARAMFLAGS_SECURE                   0x00000001
#define LINECALLPARAMFLAGS_IDLE                     0x00000002
#define LINECALLPARAMFLAGS_BLOCKID                  0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK              0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK              0x00000010
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif


#define LINECALLPARTYID_BLOCKED                     0x00000001
#define LINECALLPARTYID_OUTOFAREA                   0x00000002
#define LINECALLPARTYID_NAME                        0x00000004
#define LINECALLPARTYID_ADDRESS                     0x00000008
#define LINECALLPARTYID_PARTIAL                     0x00000010
#define LINECALLPARTYID_UNKNOWN                     0x00000020
#define LINECALLPARTYID_UNAVAIL                     0x00000040

#define LINECALLPRIVILEGE_NONE                      0x00000001
#define LINECALLPRIVILEGE_MONITOR                   0x00000002
#define LINECALLPRIVILEGE_OWNER                     0x00000004

#define LINECALLREASON_DIRECT                       0x00000001
#define LINECALLREASON_FWDBUSY                      0x00000002
#define LINECALLREASON_FWDNOANSWER                  0x00000004
#define LINECALLREASON_FWDUNCOND                    0x00000008
#define LINECALLREASON_PICKUP                       0x00000010
#define LINECALLREASON_UNPARK                       0x00000020
#define LINECALLREASON_REDIRECT                     0x00000040
#define LINECALLREASON_CALLCOMPLETION               0x00000080
#define LINECALLREASON_TRANSFER                     0x00000100
#define LINECALLREASON_REMINDER                     0x00000200
#define LINECALLREASON_UNKNOWN                      0x00000400
#define LINECALLREASON_UNAVAIL                      0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif


#define LINECALLSELECT_LINE                         0x00000001
#define LINECALLSELECT_ADDRESS                      0x00000002
#define LINECALLSELECT_CALL                         0x00000004
#if (NDIS_TAPI_CURRENT_VERSION > 0x00020000)
#define LINECALLSELECT_DEVICEID                 0x00000008
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINECALLSELECT_CALLID                   0x00000010
#endif


#define LINECALLSTATE_IDLE                          0x00000001
#define LINECALLSTATE_OFFERING                      0x00000002
#define LINECALLSTATE_ACCEPTED                      0x00000004
#define LINECALLSTATE_DIALTONE                      0x00000008
#define LINECALLSTATE_DIALING                       0x00000010
#define LINECALLSTATE_RINGBACK                      0x00000020
#define LINECALLSTATE_BUSY                          0x00000040
#define LINECALLSTATE_SPECIALINFO                   0x00000080
#define LINECALLSTATE_CONNECTED                     0x00000100
#define LINECALLSTATE_PROCEEDING                    0x00000200
#define LINECALLSTATE_ONHOLD                        0x00000400
#define LINECALLSTATE_CONFERENCED                   0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF                0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER            0x00002000
#define LINECALLSTATE_DISCONNECTED                  0x00004000
#define LINECALLSTATE_UNKNOWN                       0x00008000

#define LINEDEVCAPFLAGS_CROSSADDRCONF               0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP                 0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP                  0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL                0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR                0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP                   0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING                 0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET                   0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE                0x00000100
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEDEVCAPFLAGS_MSP                     0x00000200      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUB                 0x00000400      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUBTRACKING         0x00000800      // TAPI v3.0
#define LINEDEVCAPFLAGS_PRIVATEOBJECTS          0x00001000      // TAPI v3.0
#endif


#define LINEDEVSTATE_OTHER                          0x00000001
#define LINEDEVSTATE_RINGING                        0x00000002
#define LINEDEVSTATE_CONNECTED                      0x00000004
#define LINEDEVSTATE_DISCONNECTED                   0x00000008
#define LINEDEVSTATE_MSGWAITON                      0x00000010
#define LINEDEVSTATE_MSGWAITOFF                     0x00000020
#define LINEDEVSTATE_INSERVICE                      0x00000040
#define LINEDEVSTATE_OUTOFSERVICE                   0x00000080
#define LINEDEVSTATE_MAINTENANCE                    0x00000100
#define LINEDEVSTATE_OPEN                           0x00000200
#define LINEDEVSTATE_CLOSE                          0x00000400
#define LINEDEVSTATE_NUMCALLS                       0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS                 0x00001000
#define LINEDEVSTATE_TERMINALS                      0x00002000
#define LINEDEVSTATE_ROAMMODE                       0x00004000
#define LINEDEVSTATE_BATTERY                        0x00008000
#define LINEDEVSTATE_SIGNAL                         0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                    0x00020000
#define LINEDEVSTATE_REINIT                         0x00040000
#define LINEDEVSTATE_LOCK                           0x00080000

#define LINEDEVSTATUSFLAGS_CONNECTED                0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT                  0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE                0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED                   0x00000008

#define LINEDIALTONEMODE_NORMAL                     0x00000001
#define LINEDIALTONEMODE_SPECIAL                    0x00000002
#define LINEDIALTONEMODE_INTERNAL                   0x00000004
#define LINEDIALTONEMODE_EXTERNAL                   0x00000008
#define LINEDIALTONEMODE_UNKNOWN                    0x00000010
#define LINEDIALTONEMODE_UNAVAIL                    0x00000020

#define LINEDIGITMODE_PULSE                         0x00000001
#define LINEDIGITMODE_DTMF                          0x00000002
#define LINEDIGITMODE_DTMFEND                       0x00000004

#define LINEDISCONNECTMODE_NORMAL                   0x00000001
#define LINEDISCONNECTMODE_UNKNOWN                  0x00000002
#define LINEDISCONNECTMODE_REJECT                   0x00000004
#define LINEDISCONNECTMODE_PICKUP                   0x00000008
#define LINEDISCONNECTMODE_FORWARDED                0x00000010
#define LINEDISCONNECTMODE_BUSY                     0x00000020
#define LINEDISCONNECTMODE_NOANSWER                 0x00000040
#define LINEDISCONNECTMODE_BADADDRESS               0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE              0x00000100
#define LINEDISCONNECTMODE_CONGESTION               0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE             0x00000400
#define LINEDISCONNECTMODE_UNAVAIL                  0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#define LINEDISCONNECTMODE_CANCELLED            0x00080000      // TAPI v2.0
#endif


#define LINEFEATURE_DEVSPECIFIC                     0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT                 0x00000002
#define LINEFEATURE_FORWARD                         0x00000004
#define LINEFEATURE_MAKECALL                        0x00000008
#define LINEFEATURE_SETMEDIACONTROL                 0x00000010
#define LINEFEATURE_SETTERMINAL                     0x00000020
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif


#define LINEFORWARDMODE_UNCOND                      0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL              0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL              0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC              0x00000008
#define LINEFORWARDMODE_BUSY                        0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL                0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL                0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC                0x00000080
#define LINEFORWARDMODE_NOANSW                      0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL              0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL              0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC              0x00000800
#define LINEFORWARDMODE_BUSYNA                      0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL              0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL              0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC              0x00008000

#define LINEGATHERTERM_BUFFERFULL                   0x00000001
#define LINEGATHERTERM_TERMDIGIT                    0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT                 0x00000004
#define LINEGATHERTERM_INTERTIMEOUT                 0x00000008
#define LINEGATHERTERM_CANCEL                       0x00000010

#define LINEGENERATETERM_DONE                       0x00000001
#define LINEGENERATETERM_CANCEL                     0x00000002

#define LINEMEDIACONTROL_NONE                       0x00000001
#define LINEMEDIACONTROL_START                      0x00000002
#define LINEMEDIACONTROL_RESET                      0x00000004
#define LINEMEDIACONTROL_PAUSE                      0x00000008
#define LINEMEDIACONTROL_RESUME                     0x00000010
#define LINEMEDIACONTROL_RATEUP                     0x00000020
#define LINEMEDIACONTROL_RATEDOWN                   0x00000040
#define LINEMEDIACONTROL_RATENORMAL                 0x00000080
#define LINEMEDIACONTROL_VOLUMEUP                   0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN                 0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL               0x00000400

#define LINEMEDIAMODE_UNKNOWN                       0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE              0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE                0x00000008
#define LINEMEDIAMODE_DATAMODEM                     0x00000010
#define LINEMEDIAMODE_G3FAX                         0x00000020
#define LINEMEDIAMODE_TDD                           0x00000040
#define LINEMEDIAMODE_G4FAX                         0x00000080
#define LINEMEDIAMODE_DIGITALDATA                   0x00000100
#define LINEMEDIAMODE_TELETEX                       0x00000200
#define LINEMEDIAMODE_VIDEOTEX                      0x00000400
#define LINEMEDIAMODE_TELEX                         0x00000800
#define LINEMEDIAMODE_MIXED                         0x00001000
#define LINEMEDIAMODE_ADSI                          0x00002000

#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                          0x00004000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020001)
#define LINEMEDIAMODE_VIDEO                     0x00008000      // TAPI v2.1
#undef LAST_LINEMEDIAMODE
#define LAST_LINEMEDIAMODE                      0x00008000		// Should override last definition.
#endif




#define LINEPARKMODE_DIRECTED                       0x00000001
#define LINEPARKMODE_NONDIRECTED                    0x00000002

#define LINEREMOVEFROMCONF_NONE                     0x00000001
#define LINEREMOVEFROMCONF_LAST                     0x00000002
#define LINEREMOVEFROMCONF_ANY                      0x00000003

#define LINEREQUESTMODE_MAKECALL                    0x00000001
#define LINEREQUESTMODE_MEDIACALL                   0x00000002
#define LINEREQUESTMODE_DROP                        0x00000004

#define LAST_LINEREQUESTMODE                        LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                        0x00000001
#define LINEROAMMODE_UNAVAIL                        0x00000002
#define LINEROAMMODE_HOME                           0x00000004
#define LINEROAMMODE_ROAMA                          0x00000008
#define LINEROAMMODE_ROAMB                          0x00000010

#define LINESPECIALINFO_NOCIRCUIT                   0x00000001
#define LINESPECIALINFO_CUSTIRREG                   0x00000002
#define LINESPECIALINFO_REORDER                     0x00000004
#define LINESPECIALINFO_UNKNOWN                     0x00000008
#define LINESPECIALINFO_UNAVAIL                     0x00000010

#define LINETERMDEV_PHONE                           0x00000001
#define LINETERMDEV_HEADSET                         0x00000002
#define LINETERMDEV_SPEAKER                         0x00000004

#define LINETERMMODE_BUTTONS                        0x00000001
#define LINETERMMODE_LAMPS                          0x00000002
#define LINETERMMODE_DISPLAY                        0x00000004
#define LINETERMMODE_RINGER                         0x00000008
#define LINETERMMODE_HOOKSWITCH                     0x00000010
#define LINETERMMODE_MEDIATOLINE                    0x00000020
#define LINETERMMODE_MEDIAFROMLINE                  0x00000040
#define LINETERMMODE_MEDIABIDIRECT                  0x00000080

#define LINETERMSHARING_PRIVATE                     0x00000001
#define LINETERMSHARING_SHAREDEXCL                  0x00000002
#define LINETERMSHARING_SHAREDCONF                  0x00000004

#define LINETONEMODE_CUSTOM                         0x00000001
#define LINETONEMODE_RINGBACK                       0x00000002
#define LINETONEMODE_BUSY                           0x00000004
#define LINETONEMODE_BEEP                           0x00000008
#define LINETONEMODE_BILLING                        0x00000010

#define LINETRANSFERMODE_TRANSFER                   0x00000001
#define LINETRANSFERMODE_CONFERENCE                 0x00000002

#define LINETOLLLISTOPTION_ADD                      0x00000001
#define LINETOLLLISTOPTION_REMOVE                   0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE            0x00000001

#define LINETRANSLATERESULT_CANONICAL               0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL           0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE            0x00000004
#define LINETRANSLATERESULT_LOCAL                   0x00000008
#define LINETRANSLATERESULT_INTOLLLIST              0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST           0x00000020
#define LINETRANSLATERESULT_DIALBILLING             0x00000040
#define LINETRANSLATERESULT_DIALQUIET               0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE            0x00000100
#define LINETRANSLATERESULT_DIALPROMPT              0x00000200
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT      		0x00000400      // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)                                           
#define LINETRANSLATERESULT_NOTRANSLATION       	0x00000800      // TAPI v3.0       
#endif              

//
// Type definitions
//

typedef ULONG_PTR HTAPI_LINE;
typedef ULONG_PTR HDRV_LINE;
typedef ULONG_PTR HTAPI_CALL;
typedef ULONG_PTR HDRV_CALL;

typedef struct _LINE_ADDRESS_CAPS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulLineDeviceID;

    ULONG   ulAddressSize;
    ULONG   ulAddressOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

    ULONG   ulAddressSharing;
    ULONG   ulAddressStates;
    ULONG   ulCallInfoStates;
    ULONG   ulCallerIDFlags;
    ULONG   ulCalledIDFlags;
    ULONG   ulConnectedIDFlags;
    ULONG   ulRedirectionIDFlags;
    ULONG   ulRedirectingIDFlags;
    ULONG   ulCallStates;
    ULONG   ulDialToneModes;
    ULONG   ulBusyModes;
    ULONG   ulSpecialInfo;
    ULONG   ulDisconnectModes;

    ULONG   ulMaxNumActiveCalls;
    ULONG   ulMaxNumOnHoldCalls;
    ULONG   ulMaxNumOnHoldPendingCalls;
    ULONG   ulMaxNumConference;
    ULONG   ulMaxNumTransConf;

    ULONG   ulAddrCapFlags;
    ULONG   ulCallFeatures;
    ULONG   ulRemoveFromConfCaps;
    ULONG   ulRemoveFromConfState;
    ULONG   ulTransferModes;
    ULONG   ulParkModes;

    ULONG   ulForwardModes;
    ULONG   ulMaxForwardEntries;
    ULONG   ulMaxSpecificEntries;
    ULONG   ulMinFwdNumRings;
    ULONG   ulMaxFwdNumRings;

    ULONG   ulMaxCallCompletions;
    ULONG   ulCallCompletionConds;
    ULONG   ulCallCompletionModes;
    ULONG   ulNumCompletionMessages;
    ULONG   ulCompletionMsgTextEntrySize;
    ULONG   ulCompletionMsgTextSize;
    ULONG   ulCompletionMsgTextOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
    ULONG   ulAddressFeatures;                              // TAPI v1.4

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG   ulPredictiveAutoTransferStates;                 // TAPI v2.0
    ULONG   ulNumCallTreatments;                            // TAPI v2.0
    ULONG   ulCallTreatmentListSize;                        // TAPI v2.0
    ULONG   ulCallTreatmentListOffset;                      // TAPI v2.0
    ULONG   ulDeviceClassesSize;                            // TAPI v2.0
    ULONG   ulDeviceClassesOffset;                          // TAPI v2.0
    ULONG   ulMaxCallDataSize;                              // TAPI v2.0
    ULONG   ulCallFeatures2;                                // TAPI v2.0
    ULONG   ulMaxNoAnswerTimeout;                           // TAPI v2.0
    ULONG   ulConnectedModes;                               // TAPI v2.0
    ULONG   ulOfferingModes;                                // TAPI v2.0
    ULONG   ulAvailableMediaModes;                          // TAPI v2.0
#endif
#endif

} LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;


typedef struct _LINE_ADDRESS_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulNumInUse;
    ULONG   ulNumActiveCalls;
    ULONG   ulNumOnHoldCalls;
    ULONG   ulNumOnHoldPendCalls;
    ULONG   ulAddressFeatures;

    ULONG   ulNumRingsNoAnswer;
    ULONG   ulForwardNumEntries;
    ULONG   ulForwardSize;
    ULONG   ulForwardOffset;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;


typedef struct _LINE_DIAL_PARAMS
{
    ULONG   ulDialPause;
    ULONG   ulDialSpeed;
    ULONG   ulDigitDuration;
    ULONG   ulWaitForDialtone;

} LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;


typedef struct _LINE_CALL_INFO
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   hLine;
    ULONG   ulLineDeviceID;
    ULONG   ulAddressID;

    ULONG   ulBearerMode;
    ULONG   ulRate;
    ULONG   ulMediaMode;

    ULONG   ulAppSpecific;
    ULONG   ulCallID;
    ULONG   ulRelatedCallID;
    ULONG   ulCallParamFlags;
    ULONG   ulCallStates;

    ULONG   ulMonitorDigitModes;
    ULONG   ulMonitorMediaModes;
    LINE_DIAL_PARAMS    DialParams;

    ULONG   ulOrigin;
    ULONG   ulReason;
    ULONG   ulCompletionID;
    ULONG   ulNumOwners;
    ULONG   ulNumMonitors;

    ULONG   ulCountryCode;
    ULONG   ulTrunk;

    ULONG   ulCallerIDFlags;
    ULONG   ulCallerIDSize;
    ULONG   ulCallerIDOffset;
    ULONG   ulCallerIDNameSize;
    ULONG   ulCallerIDNameOffset;

    ULONG   ulCalledIDFlags;
    ULONG   ulCalledIDSize;
    ULONG   ulCalledIDOffset;
    ULONG   ulCalledIDNameSize;
    ULONG   ulCalledIDNameOffset;

    ULONG   ulConnectedIDFlags;
    ULONG   ulConnectedIDSize;
    ULONG   ulConnectedIDOffset;
    ULONG   ulConnectedIDNameSize;
    ULONG   ulConnectedIDNameOffset;

    ULONG   ulRedirectionIDFlags;
    ULONG   ulRedirectionIDSize;
    ULONG   ulRedirectionIDOffset;
    ULONG   ulRedirectionIDNameSize;
    ULONG   ulRedirectionIDNameOffset;

    ULONG   ulRedirectingIDFlags;
    ULONG   ulRedirectingIDSize;
    ULONG   ulRedirectingIDOffset;
    ULONG   ulRedirectingIDNameSize;
    ULONG   ulRedirectingIDNameOffset;

    ULONG   ulAppNameSize;
    ULONG   ulAppNameOffset;

    ULONG   ulDisplayableAddressSize;
    ULONG   ulDisplayableAddressOffset;

    ULONG   ulCalledPartySize;
    ULONG   ulCalledPartyOffset;

    ULONG   ulCommentSize;
    ULONG   ulCommentOffset;

    ULONG   ulDisplaySize;
    ULONG   ulDisplayOffset;

    ULONG   ulUserUserInfoSize;
    ULONG   ulUserUserInfoOffset;

    ULONG   ulHighLevelCompSize;
    ULONG   ulHighLevelCompOffset;

    ULONG   ulLowLevelCompSize;
    ULONG   ulLowLevelCompOffset;

    ULONG   ulChargingInfoSize;
    ULONG   ulChargingInfoOffset;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulCallTreatment;                                // TAPI v2.0
    ULONG       ulCallDataSize;                                 // TAPI v2.0
    ULONG       ulCallDataOffset;                               // TAPI v2.0
    ULONG       ulSendingFlowspecSize;                          // TAPI v2.0
    ULONG       ulSendingFlowspecOffset;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecSize;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecOffset;                      // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulCallerIDAddressType;                          // TAPI v3.0
    ULONG       ulCalledIDAddressType;                          // TAPI v3.0
    ULONG       ulConnectedIDAddressType;                       // TAPI v3.0
    ULONG       ulRedirectionIDAddressType;                     // TAPI v3.0
    ULONG       ulRedirectingIDAddressType;                     // TAPI v3.0
#endif

} LINE_CALL_INFO, *PLINE_CALL_INFO;


typedef struct _LINE_CALL_PARAMS        // Defaults:
{
    ULONG   ulTotalSize;                // ---------

    ULONG   ulBearerMode;               // voice
    ULONG   ulMinRate;                  // (3.1kHz)
    ULONG   ulMaxRate;                  // (3.1kHz)
    ULONG   ulMediaMode;                // interactiveVoice

    ULONG   ulCallParamFlags;           // 0
    ULONG   ulAddressMode;              // addressID
    ULONG   ulAddressID;                // (any available)

    LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

    ULONG   ulOrigAddressSize;          // 0
    ULONG   ulOrigAddressOffset;
    ULONG   ulDisplayableAddressSize;
    ULONG   ulDisplayableAddressOffset;

    ULONG   ulCalledPartySize;          // 0
    ULONG   ulCalledPartyOffset;

    ULONG   ulCommentSize;              // 0
    ULONG   ulCommentOffset;

    ULONG   ulUserUserInfoSize;         // 0
    ULONG   ulUserUserInfoOffset;

    ULONG   ulHighLevelCompSize;        // 0
    ULONG   ulHighLevelCompOffset;

    ULONG   ulLowLevelCompSize;         // 0
    ULONG   ulLowLevelCompOffset;

    ULONG   ulDevSpecificSize;          // 0
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulPredictiveAutoTransferStates;                 // TAPI v2.0
    ULONG       ulTargetAddressSize;                            // TAPI v2.0
    ULONG       ulTargetAddressOffset;                          // TAPI v2.0
    ULONG       ulSendingFlowspecSize;                          // TAPI v2.0
    ULONG       ulSendingFlowspecOffset;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecSize;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecOffset;                      // TAPI v2.0
    ULONG       ulDeviceClassSize;                              // TAPI v2.0
    ULONG       ulDeviceClassOffset;                            // TAPI v2.0
    ULONG       ulDeviceConfigSize;                             // TAPI v2.0
    ULONG       ulDeviceConfigOffset;                           // TAPI v2.0
    ULONG       ulCallDataSize;                                 // TAPI v2.0
    ULONG       ulCallDataOffset;                               // TAPI v2.0
    ULONG       ulNoAnswerTimeout;                              // TAPI v2.0
    ULONG       ulCallingPartyIDSize;                           // TAPI v2.0
    ULONG       ulCallingPartyIDOffset;                         // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulAddressType;                                  // TAPI v3.0
#endif

} LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;


typedef struct _LINE_CALL_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulCallState;
    ULONG   ulCallStateMode;
    ULONG   ulCallPrivilege;
    ULONG   ulCallFeatures;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_CALL_STATUS, *PLINE_CALL_STATUS;


typedef struct _LINE_EXTENSION_ID
{
    ULONG   ulExtensionID0;
    ULONG   ulExtensionID1;
    ULONG   ulExtensionID2;
    ULONG   ulExtensionID3;

} LINE_EXTENSION_ID, *PLINE_EXTENSION_ID;


typedef struct _LINE_DEV_CAPS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulProviderInfoSize;
    ULONG   ulProviderInfoOffset;

    ULONG   ulSwitchInfoSize;
    ULONG   ulSwitchInfoOffset;

    ULONG   ulPermanentLineID;
    ULONG   ulLineNameSize;
    ULONG   ulLineNameOffset;
    ULONG   ulStringFormat;

    ULONG   ulAddressModes;
    ULONG   ulNumAddresses;
    ULONG   ulBearerModes;
    ULONG   ulMaxRate;
    ULONG   ulMediaModes;

    ULONG   ulGenerateToneModes;
    ULONG   ulGenerateToneMaxNumFreq;
    ULONG   ulGenerateDigitModes;
    ULONG   ulMonitorToneMaxNumFreq;
    ULONG   ulMonitorToneMaxNumEntries;
    ULONG   ulMonitorDigitModes;
    ULONG   ulGatherDigitsMinTimeout;
    ULONG   ulGatherDigitsMaxTimeout;

    ULONG   ulMedCtlDigitMaxListSize;
    ULONG   ulMedCtlMediaMaxListSize;
    ULONG   ulMedCtlToneMaxListSize;
    ULONG   ulMedCtlCallStateMaxListSize;

    ULONG   ulDevCapFlags;
    ULONG   ulMaxNumActiveCalls;
    ULONG   ulAnswerMode;
    ULONG   ulRingModes;
    ULONG   ulLineStates;

    ULONG   ulUUIAcceptSize;
    ULONG   ulUUIAnswerSize;
    ULONG   ulUUIMakeCallSize;
    ULONG   ulUUIDropSize;
    ULONG   ulUUISendUserUserInfoSize;
    ULONG   ulUUICallInfoSize;

    LINE_DIAL_PARAMS    MinDialParams;
    LINE_DIAL_PARAMS    MaxDialParams;
    LINE_DIAL_PARAMS    DefaultDialParams;

    ULONG   ulNumTerminals;
    ULONG   ulTerminalCapsSize;
    ULONG   ulTerminalCapsOffset;
    ULONG   ulTerminalTextEntrySize;
    ULONG   ulTerminalTextSize;
    ULONG   ulTerminalTextOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
    ULONG   ulLineFeatures;                                 // TAPI v1.4
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulSettableDevStatus;                            // TAPI v2.0
    ULONG       ulDeviceClassesSize;                            // TAPI v2.0
    ULONG       ulDeviceClassesOffset;                          // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
	GUID        PermanentLineGuid;                              // TAPI v3.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulAddressTypes;                                 // TAPI v3.0
    GUID        ProtocolGuid;                                   // TAPI v3.0
    ULONG       ulAvailableTracking;                            // TAPI v3.0    
#endif

} LINE_DEV_CAPS, *PLINE_DEV_CAPS;


typedef struct _LINE_DEV_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulNumOpens;
    ULONG   ulOpenMediaModes;
    ULONG   ulNumActiveCalls;
    ULONG   ulNumOnHoldCalls;
    ULONG   ulNumOnHoldPendCalls;
    ULONG   ulLineFeatures;
    ULONG   ulNumCallCompletions;
    ULONG   ulRingMode;
    ULONG   ulSignalLevel;
    ULONG   ulBatteryLevel;
    ULONG   ulRoamMode;

    ULONG   ulDevStatusFlags;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_DEV_STATUS, *PLINE_DEV_STATUS;


#ifndef __NDISTAPI_VAR_STRING_DECLARED
#define __NDISTAPI_VAR_STRING_DECLARED

typedef struct _VAR_STRING
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulStringFormat;
    ULONG   ulStringSize;
    ULONG   ulStringOffset;

} VAR_STRING, *PVAR_STRING;

#endif // __NDISTAPI_VAR_STRING_DECLARED

typedef struct _NDIS_TAPI_ACCEPT
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_ACCEPT, *PNDIS_TAPI_ACCEPT;


typedef struct _NDIS_TAPI_ANSWER
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;


typedef struct _NDIS_TAPI_CLOSE
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;

} NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;


typedef struct _NDIS_TAPI_CLOSE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;

} NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;


typedef struct _NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulMediaModes;
    IN  LINE_CALL_PARAMS    LineCallParams;

} NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION,
*PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION;


typedef struct _NDIS_TAPI_CONFIG_DIALOG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    IN  ULONG       ulLibraryNameTotalSize;
    OUT ULONG       ulLibraryNameNeededSize;
    OUT CHAR        szLibraryName[1];

} NDIS_TAPI_CONFIG_DIALOG, *PNDIS_TAPI_CONFIG_DIALOG;


typedef struct _NDIS_TAPI_DEV_SPECIFIC
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    IN  HDRV_CALL   hdCall;
    IN OUT  ULONG   ulParamsSize;
    IN OUT  UCHAR   Params[1];

} NDIS_TAPI_DEV_SPECIFIC, *PNDIS_TAPI_DEV_SPECIFIC;


typedef struct _NDIS_TAPI_DIAL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulDestAddressSize;
    IN  CHAR        szDestAddress[1];

} NDIS_TAPI_DIAL, *PNDIS_TAPI_DIAL;


typedef struct _NDIS_TAPI_DROP
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_DROP, *PNDIS_TAPI_DROP;


typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulAddressID;
    IN  ULONG       ulExtVersion;
    OUT LINE_ADDRESS_CAPS   LineAddressCaps;

} NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;


typedef struct _NDIS_TAPI_GET_ADDRESS_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    OUT ULONG       ulAddressID;
    IN  ULONG       ulAddressMode;
    IN  ULONG       ulAddressSize;
    IN  CHAR        szAddress[1];

} NDIS_TAPI_GET_ADDRESS_ID, *PNDIS_TAPI_GET_ADDRESS_ID;


typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    OUT LINE_ADDRESS_STATUS LineAddressStatus;

} NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;


typedef struct _NDIS_TAPI_GET_CALL_ADDRESS_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT ULONG       ulAddressID;

} NDIS_TAPI_GET_CALL_ADDRESS_ID, *PNDIS_TAPI_GET_CALL_ADDRESS_ID;


typedef struct _NDIS_TAPI_GET_CALL_INFO
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT LINE_CALL_INFO  LineCallInfo;

} NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;


typedef struct _NDIS_TAPI_GET_CALL_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT LINE_CALL_STATUS    LineCallStatus;

} NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;


typedef struct _NDIS_TAPI_GET_DEV_CAPS
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulExtVersion;
    OUT LINE_DEV_CAPS   LineDevCaps;

} NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;


typedef struct _NDIS_TAPI_GET_DEV_CONFIG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    OUT VAR_STRING  DeviceConfig;

} NDIS_TAPI_GET_DEV_CONFIG, *PNDIS_TAPI_GET_DEV_CONFIG;


typedef struct _NDIS_TAPI_GET_EXTENSION_ID
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    OUT LINE_EXTENSION_ID   LineExtensionID;

} NDIS_TAPI_GET_EXTENSION_ID, *PNDIS_TAPI_GET_EXTENSION_ID;


typedef struct _NDIS_TAPI_GET_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulSelect;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    OUT VAR_STRING  DeviceID;

} NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;


typedef struct _NDIS_TAPI_GET_LINE_DEV_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    OUT LINE_DEV_STATUS LineDevStatus;

} NDIS_TAPI_GET_LINE_DEV_STATUS, *PNDIS_TAPI_GET_LINE_DEV_STATUS;


typedef struct _NDIS_TAPI_MAKE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  HTAPI_CALL  htCall;
    OUT HDRV_CALL   hdCall;
    IN  ULONG       ulDestAddressSize;
    IN  ULONG       ulDestAddressOffset;
    IN  BOOLEAN     bUseDefaultLineCallParams;
    IN  LINE_CALL_PARAMS    LineCallParams;

} NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;


typedef struct _NDIS_TAPI_NEGOTIATE_EXT_VERSION
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulLowVersion;
    IN  ULONG       ulHighVersion;
    OUT ULONG       ulExtVersion;

} NDIS_TAPI_NEGOTIATE_EXT_VERSION, *PNDIS_TAPI_NEGOTIATE_EXT_VERSION;


typedef struct _NDIS_TAPI_OPEN
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  HTAPI_LINE  htLine;
    OUT HDRV_LINE   hdLine;

} NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;


typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceIDBase;
    OUT ULONG       ulNumLineDevs;
    OUT ULONG_PTR   ulProviderID;

} NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;


typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
{
    IN  ULONG       ulRequestID;

} NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;


typedef struct _NDIS_TAPI_SECURE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;

} NDIS_TAPI_SECURE_CALL, *PNDIS_TAPI_SECURE_CALL;


typedef struct _NDIS_TAPI_SELECT_EXT_VERSION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulExtVersion;

} NDIS_TAPI_SELECT_EXT_VERSION, *PNDIS_TAPI_SELECT_EXT_VERSION;


typedef struct _NDIS_TAPI_SEND_USER_USER_INFO
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_SEND_USER_USER_INFO, *PNDIS_TAPI_SEND_USER_USER_INFO;


typedef struct _NDIS_TAPI_SET_APP_SPECIFIC
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulAppSpecific;

} NDIS_TAPI_SET_APP_SPECIFIC, *PNDIS_TAPI_SET_APP_SPECIFIC;


typedef struct _NDIS_TAPI_SET_CALL_PARAMS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulBearerMode;
    IN  ULONG       ulMinRate;
    IN  ULONG       ulMaxRate;
    IN  BOOLEAN     bSetLineDialParams;
    IN  LINE_DIAL_PARAMS    LineDialParams;

} NDIS_TAPI_SET_CALL_PARAMS, *PNDIS_TAPI_SET_CALL_PARAMS;


typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulMediaModes;

} NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION,
*PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;


typedef struct _NDIS_TAPI_SET_DEV_CONFIG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    IN  ULONG       ulDeviceConfigSize;
    IN  UCHAR       DeviceConfig[1];

} NDIS_TAPI_SET_DEV_CONFIG, *PNDIS_TAPI_SET_DEV_CONFIG;


typedef struct _NDIS_TAPI_SET_MEDIA_MODE
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulMediaMode;

} NDIS_TAPI_SET_MEDIA_MODE, *PNDIS_TAPI_SET_MEDIA_MODE;


typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulLineStates;
    IN  ULONG       ulAddressStates;

} NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;


typedef struct _NDIS_TAPI_EVENT
{
    IN  HTAPI_LINE  htLine;
    IN  HTAPI_CALL  htCall;
    IN  ULONG       ulMsg;
    IN  ULONG_PTR   ulParam1;
    IN  ULONG_PTR   ulParam2;
    IN  ULONG_PTR   ulParam3;

} NDIS_TAPI_EVENT, *PNDIS_TAPI_EVENT;

typedef struct _NDISTAPI_CHARACTERISTICS {
	PVOID	RequestProc;
	GUID	Guid;
	NDIS_WAN_MEDIUM_SUBTYPE	MediaType;
} NDISTAPI_CHARACTERISTICS, *PNDISTAPI_CHARACTERISTICS;


typedef struct _NDIS_TAPI_GATHER_DIGITS
{
    IN  ULONG       ulRequestID;
	IN 	HDRV_CALL   hdCall;
	IN	ULONG		ulEndToEndID;
	IN	ULONG		ulDigitModes;
	IN	LPWSTR		lpsOrigDigitsBuffer;
	IN	ULONG		ulDigitsBufferOffset;
	IN	ULONG		ulNumDigitsNeeded;
	OUT	ULONG		ulNumDigitsRead;
	OUT	ULONG		ulTickCount;
	OUT	ULONG		ulTerminationReason;
	IN 	ULONG		ulTerminationDigitsMask;
	IN 	ULONG		ulFirstDigitTimeout;
	IN	ULONG		ulInterDigitTimeout;
} NDIS_TAPI_GATHER_DIGITS, *PNDIS_TAPI_GATHER_DIGITS;

typedef struct _NDIS_TAPI_MONITOR_DIGITS
{
	IN	HDRV_CALL	hdCall;
	IN	ULONG		ulDigitModes;
} NDIS_TAPI_MONITOR_DIGITS, *PNDIS_TAPI_MONITOR_DIGITS;

#define CO_TAPI_VERSION                         NDIS_TAPI_CURRENT_VERSION

//
//  The CO_TAPI structures below are meant for TAPI support
//  over CONDIS Call Managers and Miniport Call Managers.
//

//  Structure associated with OID_CO_TAPI_CM_CAPS
//
typedef struct _CO_TAPI_CM_CAPS
{
    OUT ULONG                 ulCoTapiVersion;
    OUT ULONG                 ulNumLines;
    OUT ULONG                 ulFlags;

} CO_TAPI_CM_CAPS, *PCO_TAPI_CM_CAPS;

//
//  Bit definitions for Flags in CO_TAPI_CM_CAPS
//
#define CO_TAPI_FLAG_PER_LINE_CAPS              0x00000001

//
//  Structure associated with OID_CO_TAPI_LINE_CAPS.
//
typedef struct _CO_TAPI_LINE_CAPS
{
    IN  ULONG                 ulLineID;
    OUT ULONG                 ulFlags;
    OUT LINE_DEV_CAPS         LineDevCaps;

} CO_TAPI_LINE_CAPS, *PCO_TAPI_LINE_CAPS;

//
//  Bit definitions for Flags in CO_TAPI_LINE_CAPS
//
#define CO_TAPI_FLAG_PER_ADDRESS_CAPS           0x00000001

//
//  Structure associated with OID_CO_TAPI_ADDRESS_CAPS.
//
typedef struct _CO_TAPI_ADDRESS_CAPS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    OUT ULONG                 ulFlags;
    OUT LINE_ADDRESS_CAPS     LineAddressCaps;

} CO_TAPI_ADDRESS_CAPS, *PCO_TAPI_ADDRESS_CAPS;


//
//  Special values for Line and Address ID fields:
//
#define CO_TAPI_LINE_ID_UNSPECIFIED             0xFFFFFFFF
#define CO_TAPI_ADDRESS_ID_UNSPECIFIED          0xFFFFFFFF

//
//  Structure associated with OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS.
//
typedef struct _CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see below
    IN  NDIS_VAR_DATA_DESC    DestAddress;
    IN  NDIS_VAR_DATA_DESC    LineCallParams;  // LINE_CALL_PARAMS
    OUT NDIS_VAR_DATA_DESC    NdisCallParams;  // CO_CALL_PARAMETERS

} CO_TAPI_TRANSLATE_TAPI_CALLPARAMS, *PCO_TAPI_TRANSLATE_TAPI_CALLPARAMS;

//
//  Bit definitions for Flags in CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
//  and CO_TAPI_TRANSLATE_NDIS_CALLPARAMS.
//
#define CO_TAPI_FLAG_OUTGOING_CALL              0x00000001
#define CO_TAPI_FLAG_INCOMING_CALL              0x00000002
#define CO_TAPI_FLAG_USE_DEFAULT_CALLPARAMS		0x00000004


//
//  Structure associated with OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS.
//
typedef struct _CO_TAPI_TRANSLATE_NDIS_CALLPARAMS
{
    IN  ULONG                 ulFlags;         // see above
    IN  NDIS_VAR_DATA_DESC    NdisCallParams;  // CO_CALL_PARAMETERS
    OUT NDIS_VAR_DATA_DESC    LineCallInfo;    // LINE_CALL_INFO

} CO_TAPI_TRANSLATE_NDIS_CALLPARAMS, *PCO_TAPI_TRANSLATE_NDIS_CALLPARAMS;


//
//  Structure associated with OID_CO_TAPI_TRANSLATE_SAP.
//
typedef struct _CO_TAPI_TRANSLATE_SAP
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulMediaModes;
    IN  ULONG                 Reserved;
    OUT ULONG                 NumberOfSaps;
    OUT NDIS_VAR_DATA_DESC    NdisSapParams[1];   // CO_SAP

} CO_TAPI_TRANSLATE_SAP, *PCO_TAPI_TRANSLATE_SAP;


//
//  Structure associated with OID_CO_TAPI_GET_CALL_DIAGNOSTICS.
//
typedef struct _CO_TAPI_CALL_DIAGNOSTICS
{
    OUT ULONG                 ulOrigin;
    OUT ULONG                 ulReason;
    OUT NDIS_VAR_DATA_DESC    DiagInfo;

} CO_TAPI_CALL_DIAGNOSTICS, *PCO_TAPI_CALL_DIAGNOSTICS;


//
//  Structure used in the Media-specific part of CO_CALL_PARAMETERS
//  for an outgoing call for the CO_ADDRESS_FAMILY_TAPI address family.
//  This is used in NdisClMakeCall/Ndis[M]CmActivateVc, and
//  completion routines.
//
//  This overlays:
//     CO_CALL_PARAMETERS.MediaParameters->MediaSpecific.Parameters[]
//
typedef struct _CO_AF_TAPI_MAKE_CALL_PARAMETERS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
    IN  NDIS_VAR_DATA_DESC    DestAddress;
    IN  NDIS_VAR_DATA_DESC    LineCallParams;  // LINE_CALL_PARAMS

} CO_AF_TAPI_MAKE_CALL_PARAMETERS, *PCO_AF_TAPI_MAKE_CALL_PARAMETERS;



//
//  Structure used in the Media-specific part of CO_CALL_PARAMETERS
//  for an incoming call for the CO_ADDRESS_FAMILY_TAPI address family.
//  This is used in Ndis[M]CmDispatchIncomingCall/Ndis[M]CmActivateVc
//  and completion routines.
//
//  This overlays:
//     CO_CALL_PARAMETERS.MediaParameters->MediaSpecific.Parameters[]
//
typedef struct _CO_AF_TAPI_INCOMING_CALL_PARAMETERS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
    IN  NDIS_VAR_DATA_DESC    LineCallInfo;    // LINE_CALL_INFO

} CO_AF_TAPI_INCOMING_CALL_PARAMETERS, *PCO_AF_TAPI_INCOMING_CALL_PARAMETERS;



//
//  Value of SapType in CO_SAP for a Service Access Point on the
//  CO_ADDRESS_FAMILY_TAPI address family.
//
#define AF_TAPI_SAP_TYPE      0x00008000

//
//  Structure used to convey TAPI-style SAP information in the NDIS CO_SAP
//  structure.
//
//  This overlays:
//     CO_SAP.Sap[]
//
typedef struct _CO_AF_TAPI_SAP
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulMediaModes;

} CO_AF_TAPI_SAP, *PCO_AF_TAPI_SAP;



#endif // _NDIS_TAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)
// The 2 messages above will be removed once the ALLOCBUFFER code is ready

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       HANDLE hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ndiswan.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndiswan.h

Abstract:

    Main header file for the wan wrapper

Author:

    Thomas J. Dimitri (TommyD)  20-Feb-1994

Revision History:

--*/


#ifndef _NDIS_WAN_
#define _NDIS_WAN_

//
// Begin definitions for WANs
//

//
// Bit field set int he Reserved field for
// NdisRegisterMiniport or passed in NdisRegisterSpecial
//

#define NDIS_USE_WAN_WRAPPER            0x00000001

#define NDIS_STATUS_TAPI_INDICATION ((NDIS_STATUS)0x40010080L)


//
// NDIS WAN Framing bits
//
#define RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                 0x00000002

#define ARAP_V1_FRAMING                 0x00000004
#define ARAP_V2_FRAMING                 0x00000008
#define ARAP_FRAMING                    (ARAP_V1_FRAMING | ARAP_V2_FRAMING)

#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040

#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

#define SLIP_FRAMING                    0x00001000
#define SLIP_VJ_COMPRESSION             0x00002000
#define SLIP_VJ_AUTODETECT              0x00004000

#define MEDIA_NRZ_ENCODING              0x00010000
#define MEDIA_NRZI_ENCODING             0x00020000
#define MEDIA_NLPID                     0x00040000

#define RFC_1356_FRAMING                0x00100000
#define RFC_1483_FRAMING                0x00200000
#define RFC_1490_FRAMING                0x00400000
#define LLC_ENCAPSULATION               0x00800000

#define SHIVA_FRAMING                   0x01000000
#define NBF_PRESERVE_MAC_ADDRESS        0x01000000

#ifndef _WAN50_
#define PASS_THROUGH_MODE               0x10000000
#define RAW_PASS_THROUGH_MODE           0x20000000
#endif

#define TAPI_PROVIDER                   0x80000000

//
// NDIS WAN Information structures used
// by NDIS 3.1 Wan Miniport drivers
//
typedef struct _NDIS_WAN_INFO
{
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxTransmit;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           Endpoints;
    OUT UINT            MemoryFlags;
    OUT NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_INFO, *PNDIS_WAN_INFO;

typedef struct _NDIS_WAN_SET_LINK_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
        ULONG           HeaderPadding;
        ULONG           TailPadding;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO;

typedef struct _NDIS_WAN_GET_LINK_INFO {
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO;

//
// NDIS WAN Bridging Options
//
#define BRIDGING_FLAG_LANFCS            0x00000001
#define BRIDGING_FLAG_LANID             0x00000002
#define BRIDGING_FLAG_PADDING           0x00000004

//
// NDIS WAN Bridging Capabilities
//
#define BRIDGING_TINYGRAM               0x00000001
#define BRIDGING_LANID                  0x00000002
#define BRIDGING_NO_SPANNING_TREE       0x00000004
#define BRIDGING_8021D_SPANNING_TREE    0x00000008
#define BRIDGING_8021G_SPANNING_TREE    0x00000010
#define BRIDGING_SOURCE_ROUTING         0x00000020
#define BRIDGING_DEC_LANBRIDGE          0x00000040

//
// NDIS WAN Bridging Type
//
#define BRIDGING_TYPE_RESERVED          0x00000001
#define BRIDGING_TYPE_8023_CANON        0x00000002
#define BRIDGING_TYPE_8024_NO_CANON     0x00000004
#define BRIDGING_TYPE_8025_NO_CANON     0x00000008
#define BRIDGING_TYPE_FDDI_NO_CANON     0x00000010
#define BRIDGING_TYPE_8024_CANON        0x00000400
#define BRIDGING_TYPE_8025_CANON        0x00000800
#define BRIDGING_TYPE_FDDI_CANON        0x00001000

typedef struct _NDIS_WAN_GET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT USHORT          LanSegmentNumber;
    OUT UCHAR           BridgeNumber;
    OUT UCHAR           BridgingOptions;
    OUT ULONG           BridgingCapabilities;
    OUT UCHAR           BridgingType;
    OUT UCHAR           MacBytes[6];
} NDIS_WAN_GET_BRIDGE_INFO, *PNDIS_WAN_GET_BRIDGE_INFO;

typedef struct _NDIS_WAN_SET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  USHORT          LanSegmentNumber;
    IN  UCHAR           BridgeNumber;
    IN  UCHAR           BridgingOptions;
    IN  ULONG           BridgingCapabilities;
    IN  UCHAR           BridgingType;
    IN  UCHAR           MacBytes[6];
} NDIS_WAN_SET_BRIDGE_INFO, *PNDIS_WAN_SET_BRIDGE_INFO;

//
// NDIS WAN Compression Information
//

//
// Define MSCompType bit field, 0 disables all
//
#define NDISWAN_COMPRESSION             0x00000001
#define NDISWAN_ENCRYPTION              0x00000010
#define NDISWAN_40_ENCRYPTION           0x00000020
#define NDISWAN_128_ENCRYPTION          0x00000040
#define NDISWAN_56_ENCRYPTION           0x00000080
#define NDISWAN_HISTORY_LESS            0x01000000

//
// Define CompType codes
//
#define COMPTYPE_OUI                    0
#define COMPTYPE_NT31RAS                254
#define COMPTYPE_NONE                   255


typedef struct _NDIS_WAN_COMPRESS_INFO
{
    UCHAR   SessionKey[8];
    ULONG   MSCompType;

    // Fields above indicate NDISWAN capabilities.
    // Fields below indicate MAC-specific capabilities.

    UCHAR   CompType;
    USHORT  CompLength;

    union
    {
        struct
        {
            UCHAR   CompOUI[3];
            UCHAR   CompSubType;
            UCHAR   CompValues[32];
        } Proprietary;

        struct
        {
            UCHAR   CompValues[32];
        } Public;
    };
} NDIS_WAN_COMPRESS_INFO;

typedef NDIS_WAN_COMPRESS_INFO UNALIGNED *PNDIS_WAN_COMPRESS_INFO;

typedef struct _NDIS_WAN_GET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_GET_COMP_INFO, *PNDIS_WAN_GET_COMP_INFO;

typedef struct _NDIS_WAN_SET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_SET_COMP_INFO, *PNDIS_WAN_SET_COMP_INFO;

//
// NDIS WAN Statistics Information
//

typedef struct _NDIS_WAN_GET_STATS_INFO
{
    IN  NDIS_HANDLE NdisLinkHandle;
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_GET_STATS_INFO, *PNDIS_WAN_GET_STATS_INFO;

#define NdisMWanInitializeWrapper(NdisWrapperHandle,                                \
                                  SystemSpecific1,                                  \
                                  SystemSpecific2,                                  \
                                  SystemSpecific3)                                  \
{                                                                                   \
    NdisMInitializeWrapper(NdisWrapperHandle,                                       \
                            SystemSpecific1,                                        \
                            SystemSpecific2,                                        \
                            SystemSpecific3);                                       \
}

typedef struct _NDIS_MAC_LINE_UP
{
    IN  ULONG               LinkSpeed;
    IN  NDIS_WAN_QUALITY    Quality;
    IN  USHORT              SendWindow;
    IN  NDIS_HANDLE      ConnectionWrapperID;
    IN  NDIS_HANDLE      NdisLinkHandle;
    OUT NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_UP, *PNDIS_MAC_LINE_UP;


typedef struct _NDIS_MAC_LINE_DOWN
{
    IN  NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_DOWN, *PNDIS_MAC_LINE_DOWN;


//
// These are the error values that can be indicated by the driver.
// This bit field is set when calling NdisIndicateStatus.
//
#define WAN_ERROR_CRC               ((ULONG)0x00000001)
#define WAN_ERROR_FRAMING           ((ULONG)0x00000002)
#define WAN_ERROR_HARDWAREOVERRUN   ((ULONG)0x00000004)
#define WAN_ERROR_BUFFEROVERRUN     ((ULONG)0x00000008)
#define WAN_ERROR_TIMEOUT           ((ULONG)0x00000010)
#define WAN_ERROR_ALIGNMENT         ((ULONG)0x00000020)

typedef struct _NDIS_MAC_FRAGMENT
{
    IN  NDIS_HANDLE     NdisLinkContext;
    IN  ULONG           Errors;
} NDIS_MAC_FRAGMENT, *PNDIS_MAC_FRAGMENT;

//
// NDIS WAN Information structures used
// by NDIS 5.0 Miniport drivers
//

//
// Defines for the individual fields are the
// same as for NDIS 3.x/4.x Wan miniports.
//
// See the DDK.
//

//
// Information that applies to all VC's on
// this adapter.
//
// OID: OID_WAN_CO_GET_INFO
//
typedef struct _NDIS_WAN_CO_INFO {
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxSendWindow;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

//
// Set VC specific PPP framing information.
//
// OID: OID_WAN_CO_SET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

//
// Get VC specific PPP framing information.
//
// OID: OID_WAN_CO_GET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

//
// Get VC specific PPP compression information
//
// OID: OID_WAN_CO_GET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;


//
// Set VC specific PPP compression information
//
// OID: OID_WAN_CO_SET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;


//
// Get VC specific statistics
//
// OID: OID_WAN_CO_GET_STATS_INFO
//
typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

//
// Used to notify NdisWan of Errors.  See error
// bit mask in ndiswan.h
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_FRAGMENT
//
typedef struct _NDIS_WAN_CO_FRAGMENT {
    IN  ULONG           Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

//
// Used to notify NdisWan of changes in link speed and
// send window.  Can be given at any time.  NdisWan will honor
// any send window (even zero).  NdisWan will default zero
// TransmitSpeed/ReceiveSpeed settings to 28.8Kbs.
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_LINKPARAMS
//
typedef struct _WAN_CO_LINKPARAMS {
    ULONG   TransmitSpeed;              // Transmit speed of the VC in Bytes/sec
    ULONG   ReceiveSpeed;               // Receive speed of the VC in Bytes/sec
    ULONG   SendWindow;                 // Current send window for the VC
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;

#endif  // _NDIS_WAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\ddk\inc\ndis.h ===
/*++ BUILD Version: 0096    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndis.h

Abstract:

    This module defines the structures, macros, and functions available
    to NDIS drivers.

Revision History:

--*/

#if !defined(_NDIS_)
#define _NDIS_

#if !defined(NDIS_WDM)
#define NDIS_WDM        0
#endif

//
// If we're building a miniport on x86, set BINARY_COMPATIBLE so that
// we don't use functions that aren't available on Windows 9x.
//

#if !defined(BINARY_COMPATIBLE)
#if defined(NDIS_MINIPORT_DRIVER) && defined(_M_IX86)
#define BINARY_COMPATIBLE 1
#else
#define BINARY_COMPATIBLE 0
#endif
#endif

#if !defined(_M_IX86)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

//
// BEGIN INTERNAL DEFINITIONS
//

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//

#if (BINARY_COMPATIBLE && !NDIS_WDM)

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
//
// The following internal definitions are included here in order to allow
// the exported NDIS structures, macros, and functions to compile.  They
// must not be used directly by miniport drivers.
//

#define _NTDDK_

#include <ctype.h>  

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef DECLSPEC_NOINLINE
#if (_MSC_VER >= 1300)
#define DECLSPEC_NOINLINE  __declspec(noinline)
#else
#define DECLSPEC_NOINLINE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


#if ((_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)) && !defined(_M_AMD64)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

//
// Define API decoration for direct importing system DLL references.
//

#if !defined(_NTSYSTEM_)
#define NTSYSAPI     DECLSPEC_IMPORT
#define NTSYSCALLAPI DECLSPEC_IMPORT
#else
#define NTSYSAPI
#if defined(_NTDLLBUILD_)
#define NTSYSCALLAPI
#else
#define NTSYSCALLAPI DECLSPEC_ADDRSAFE
#endif

#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// NTSTATUS
//

typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

// end_windbgkd
// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

#ifndef __SECSTATUS_DEFINED__
typedef long SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif



//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Counted String
//

typedef USHORT RTL_STRING_LENGTH_TYPE;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

//
// CONSTCounted String
//

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)     // winnt

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#if _WIN32_WINNT >= 0x0501

#define UNICODE_STRING_MAX_BYTES ((USHORT) 65534) // winnt
#define UNICODE_STRING_MAX_CHARS (32767) // winnt

#define DECLARE_CONST_UNICODE_STRING(_variablename, _string) \
const WCHAR _variablename ## _buffer[] = _string; \
const UNICODE_STRING _variablename = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWSTR) _variablename ## _buffer };

#endif // _WIN32_WINNT >= 0x0501

// begin_ntminiport begin_ntminitape

//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt

// end_ntminiport end_ntminitape

// begin_winnt
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL


#include <guiddef.h>

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED

typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    ULONG Uniquifier;
} OBJECTID;
#endif // !_OBJECTID_DEFINED

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )

// begin_winnt begin_ntminiport
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
#define RTL_CONSTANT_STRING(s) { sizeof( s ) - sizeof( (s)[0] ), sizeof( s ), s }
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is of medium or high importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of high importance, then a DPC interrupt is requested on the
// target processor and the DPC will be processed when the interrupt occurs.
// Otherwise, the DPC execution will be delayed on the target processor until
// the DPC queue depth on the target processor is greater that the maximum
// target depth or the minimum DPC rate on the target processor is less than
// the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed whne the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Define DPC type indicies.
//

#define DPC_NORMAL 0
#define DPC_THREADED 1

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PVOID DpcData;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;


//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.
//
// One simply calculates the base of the array by adding one to the base
// MDL pointer:
//
//      Pages = (PPFN_NUMBER) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//


typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_DESCRIBES_AWE           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

#define NTKERNELAPI DECLSPEC_IMPORT     
#define NTHALAPI DECLSPEC_IMPORT            
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    union {
        struct {
            UCHAR Type;
            UCHAR Absolute;
            UCHAR Size;
            union {
                UCHAR Inserted;
                BOOLEAN DebugActive;
            };
        };

        volatile LONG Lock;
    };

    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;


typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)   // structure padded due to align()
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct DECLSPEC_ALIGN(16) _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

#else

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#endif

#if defined(_WIN64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//
// The ASSERT macro has been updated to be an expression instead of a statement.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#if DBG

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, msg ),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)),FALSE) : \
        TRUE)

#define RTL_VERIFY         ASSERT
#define RTL_VERIFYMSG      ASSERTMSG

#define RTL_SOFT_VERIFY    RTL_SOFT_ASSERT
#define RTL_SOFT_VERIFYMSG RTL_SOFT_ASSERTMSG

#else
#define ASSERT( exp )         ((void) 0)
#define ASSERTMSG( msg, exp ) ((void) 0)

#define RTL_SOFT_ASSERT(_exp)          ((void) 0)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) ((void) 0)

#define RTL_VERIFY( exp )         ((exp) ? TRUE : FALSE)
#define RTL_VERIFYMSG( msg, exp ) ((exp) ? TRUE : FALSE)

#define RTL_SOFT_VERIFY(_exp)         ((_exp) ? TRUE : FALSE)
#define RTL_SOFT_VERIFYMSG(msg, _exp) ((_exp) ? TRUE : FALSE)

#endif // DBG

//
//  Doubly-linked list manipulation routines.
//


//
//  VOID
//  InitializeListHead32(
//      PLIST_ENTRY32 ListHead
//      );
//

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)


VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))



BOOLEAN
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}


//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // !MIDL_PASS


#if defined (_MSC_VER) && ( _MSC_VER >= 900 )

PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#endif

#if (defined(_M_AMD64) || defined(_M_IA64)) && !defined(_REALLY_GET_CALLERS_CALLER_)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;

#else

NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );


NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))

#if defined(_M_AMD64)

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
    );

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
    );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
    VOID UNALIGNED *Destination,
    SIZE_T Length,
    IN UCHAR Fill
    );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
    VOID UNALIGNED *Destination,
    SIZE_T Length
    );

#else

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

#endif

#if !defined(MIDL_PASS)
FORCEINLINE
PVOID
RtlSecureZeroMemory(
    IN PVOID ptr,
    IN SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}
#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

// end_wdm

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

// begin_wdm

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6
#define DBG_STATUS_WORKER           7

#if DBG

#define KdPrint(_x_) DbgPrint _x_
// end_wdm
#define KdPrintEx(_x_) DbgPrintEx _x_
#define vKdPrintEx(_x_) vDbgPrintEx _x_
#define vKdPrintExWithPrefix(_x_) vDbgPrintExWithPrefix _x_
// begin_wdm
#define KdBreakPoint() DbgBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

// begin_wdm

#else

#define KdPrint(_x_)
// end_wdm
#define KdPrintEx(_x_)
#define vKdPrintEx(_x_)
#define vKdPrintExWithPrefix(_x_)
// begin_wdm
#define KdBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s)

// begin_wdm

#endif

#ifndef _DBGNT_

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

// end_wdm

ULONG
__cdecl
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    ...
    );

#ifdef _VA_LIST_DEFINED

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

#endif

ULONG
__cdecl
DbgPrintReturnControlC(
    PCH Format,
    ...
    );

NTSYSAPI
NTSTATUS
DbgQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    );

NTSYSAPI
NTSTATUS
DbgSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );

// begin_wdm

#endif // _DBGNT_

//
// Component name filter id enumeration and levels.
//

#define DPFLTR_ERROR_LEVEL 0
#define DPFLTR_WARNING_LEVEL 1
#define DPFLTR_TRACE_LEVEL 2
#define DPFLTR_INFO_LEVEL 3
#define DPFLTR_MASK 0x80000000

typedef enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_RPCPROXY_ID = 42,
    DPFLTR_AUTOCHK_ID = 43,
    DPFLTR_DCOMSS_ID = 44,
    DPFLTR_UNIMODEM_ID = 45,
    DPFLTR_SIS_ID = 46,
    DPFLTR_FLTMGR_ID = 47,
    DPFLTR_WMICORE_ID = 48,
    DPFLTR_BURNENG_ID = 49,
    DPFLTR_IMAPI_ID = 50,
    DPFLTR_SXS_ID = 51,
    DPFLTR_FUSION_ID = 52,
    DPFLTR_IDLETASK_ID = 53,
    DPFLTR_SOFTPCI_ID = 54,
    DPFLTR_TAPE_ID = 55,
    DPFLTR_MCHGR_ID = 56,
    DPFLTR_IDEP_ID = 57,
    DPFLTR_PCIIDE_ID = 58,
    DPFLTR_FLOPPY_ID = 59,
    DPFLTR_FDC_ID = 60,
    DPFLTR_TERMSRV_ID = 61,
    DPFLTR_W32TIME_ID = 62,
    DPFLTR_PREFETCHER_ID = 63,
    DPFLTR_RSFILTER_ID = 64,
    DPFLTR_FCPORT_ID = 65,
    DPFLTR_PCI_ID = 66,
    DPFLTR_DMIO_ID = 67,
    DPFLTR_DMCONFIG_ID = 68,
    DPFLTR_DMADMIN_ID = 69,
    DPFLTR_WSOCKTRANSPORT_ID = 70,
    DPFLTR_VSS_ID = 71,
    DPFLTR_PNPMEM_ID = 72,
    DPFLTR_PROCESSOR_ID = 73,
    DPFLTR_DMSERVER_ID = 74,
    DPFLTR_SR_ID = 75,
    DPFLTR_INFINIBAND_ID = 76,
    DPFLTR_IHVDRIVER_ID = 77,
    DPFLTR_IHVVIDEO_ID = 78,
    DPFLTR_IHVAUDIO_ID = 79,
    DPFLTR_IHVNETWORK_ID = 80,
    DPFLTR_IHVSTREAMING_ID = 81,
    DPFLTR_IHVBUS_ID = 82,
    DPFLTR_HPS_ID = 83,
    DPFLTR_RTLTHREADPOOL_ID = 84,
    DPFLTR_LDR_ID = 85,
    DPFLTR_TCPIP6_ID = 86,
    DPFLTR_ISAPNP_ID = 87,
    DPFLTR_SHPC_ID = 88,
    DPFLTR_STORPORT_ID = 89,
    DPFLTR_STORMINIPORT_ID = 90,
    DPFLTR_PRINTSPOOLER_ID = 91,
    DPFLTR_VSSDYNDISK_ID = 92,
    DPFLTR_VERIFIER_ID = 93,
    DPFLTR_VDS_ID = 94,
    DPFLTR_VDSBAS_ID = 95,
    DPFLTR_VDSDYNDR_ID = 96,
    DPFLTR_VDSUTIL_ID = 97,
    DPFLTR_DFRGIFC_ID = 98,
    DPFLTR_ENDOFTABLE_ID
} DPFLTR_TYPE;

//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

//
// Define the maximum message size that will be sent over the LPC to the
// application reading the error log entries.
//

//
// Regardless of LPC size restrictions, ERROR_LOG_MAXIMUM_SIZE must remain
// a value that can fit in a UCHAR.
//

#define ERROR_LOG_LIMIT_SIZE (256-16)

//
// This limit, exclusive of IO_ERROR_LOG_MESSAGE_HEADER_LENGTH, also applies
// to IO_ERROR_LOG_MESSAGE_LENGTH
//

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) -    \
                                            sizeof(IO_ERROR_LOG_PACKET) +     \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                          \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

//
// IO_ERROR_LOG_MESSAGE_LENGTH is
// min(PORT_MAXIMUM_MESSAGE_LENGTH, ERROR_LOG_MESSAGE_LIMIT_SIZE)
//

#define IO_ERROR_LOG_MESSAGE_LENGTH                                           \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?           \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                        \
        PORT_MAXIMUM_MESSAGE_LENGTH)

//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -                 \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)


#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1


//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


//++
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    These functions order memory accesses as seen by other processors.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier(
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic (_ReadWriteBarrier)


FORCEINLINE
VOID
KeMemoryBarrier (
    VOID
    )
{
    LONG Barrier;
    __asm {
        xchg Barrier, eax
    }
}

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()


#endif // defined(_X86_)


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

//
// Interlocked intrinsic functions.
//

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG64
InterlockedAnd64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedOr64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedXor64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONG64
InterlockedIncrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    IN OUT LONG64 volatile *Target,
    IN LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 ExChange,
    IN LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if defined(_AMD64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 32

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1


//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    __movsb(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    __movsw(Buffer, Register, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    __movsd(Buffer, Register, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    PUCHAR Register,
    UCHAR Value
    )
{

    *Register = Value;
    StoreFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    PUSHORT Register,
    USHORT Value
    )
{

    *Register = Value;
    StoreFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    PULONG Register,
    ULONG Value
    )
{

    *Register = Value;
    StoreFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{

    __movsb(Register, Buffer, Count);
    StoreFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{

    __movsw(Register, Buffer, Count);
    StoreFence();
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{

    __movsd(Register, Buffer, Count);
    StoreFence();
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __inbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __inwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __indwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __outbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __outwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __outdwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

//
// AMD64 Specific portions of mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    These functions order memory accesses as seen by other processors.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

#if !defined(_CROSS_PLATFORM_)

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier (
    VOID
    );

#pragma intrinsic(_ReadWriteBarrier)

#ifdef __cplusplus
}
#endif

#define KeMemoryBarrier() _ReadWriteBarrier()
#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

#else

#define KeMemoryBarrier()
#define KeMemoryBarrierWithoutFence()

#endif


#endif // defined(_AMD64_)


#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"


#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __fci (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);
void __yield();
void __lfetch(int, void const *);
void __lfetchfault(int, void const *);

#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__fci)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)
#pragma intrinsic (__yield)
#pragma intrinsic (__lfetch)
#pragma intrinsic (__lfetchfault)
#endif // _M_IA64

#ifdef __cplusplus
}
#endif




//
//
// VOID
// KeMemoryBarrierWithoutFence (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses generated by the compiler.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#ifdef __cplusplus
extern "C" {
#endif

VOID
_ReadWriteBarrier (
    VOID
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(_ReadWriteBarrier)

#define KeMemoryBarrierWithoutFence() _ReadWriteBarrier()

//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as generated by the compiler and 
//    as seen by other processors.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KE_MEMORY_BARRIER_REQUIRED

#define KeMemoryBarrier() {_ReadWriteBarrier();__mf ();_ReadWriteBarrier();}

//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#endif // defined(_IA64_)

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040


#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; 

//
// On X86 the following routines are defined in the HAL and imported by
// all other modules.
//

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  __declspec(dllimport)

#else

#define _DECL_HAL_KE_IMPORT

#endif

//
// spin lock functions
//

#if defined(_X86_) && (defined(_WDMDDK_) || defined(WIN9X_COMPAT_SPINLOCK))

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#else

__inline
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    ) 
{
    *SpinLock = 0;
}

#endif

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

// end_wdm end_ntddk

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm begin_ntddk

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#else

//
// These functions are imported for IA64, ntddk, ntifs, nthal, ntosp, and wdm.
// They can be inlined for the system on AMD64.
//

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

#if defined(_IA64_) || defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_) || defined(_WDMDDK_)

// end_wdm end_ntddk

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm begin_ntddk

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#else

#if defined(_AMD64_)

//
// The system version of these functions are defined in amd64.h for AMD64.
//

#endif

#endif

#endif

// end_wdm end_ntddk end_nthal end_ntifs

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KeReleaseSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OldIrql
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//
typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );
//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; 
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; 
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; 
typedef struct _FILE_OBJECT *PFILE_OBJECT; 

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

#if defined(_IA64_)                             
                                                
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );

#endif                                          
                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
#endif                                          
                                                
NTHALAPI                                        
VOID                                            
KeFlushWriteBuffer (                            
    VOID                                        
    );                                          
                                                
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

typedef struct _MAP_REGISTER_ENTRY {
    PVOID   MapRegister;
    BOOLEAN WriteToDevice;
} MAP_REGISTER_ENTRY, *PMAP_REGISTER_ENTRY;

typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#endif

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.

//

#if defined(_WIN64)

#define ExInterlockedAddLargeStatistic(Addend, Increment)                   \
    (VOID) InterlockedAdd64(&(Addend)->QuadPart, Increment)

#else

#ifdef __cplusplus
extern "C" {
#endif

LONG
_InterlockedAddLargeStatistic (
    IN PLONGLONG Addend,
    IN ULONG Increment
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic (_InterlockedAddLargeStatistic)

#define ExInterlockedAddLargeStatistic(Addend,Increment)                     \
    (VOID) _InterlockedAddLargeStatistic ((PLONGLONG)&(Addend)->QuadPart, Increment)

#endif

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, IA64, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

#if !defined(_WINBASE_)

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

{

#ifdef _WIN64

    //
    // Slist headers must be 16 byte aligned.
    //

    if ((ULONG_PTR) SListHead & 0x0f) {

        DbgPrint( "InitializeSListHead unaligned Slist header.  Address = %p, Caller = %p\n", SListHead, _ReturnAddress());
        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    SListHead->Alignment = 0;

    //
    // For IA-64 we save the region number of the elements of the list in a
    // separate field.  This imposes the requirement that all elements stored
    // in the list are from the same region.

#if defined(_IA64_)

    SListHead->Region = (ULONG_PTR)SListHead & VRN_MASK;

#elif defined(_AMD64_)

    SListHead->Region = 0;

#endif

    return;
}

#endif

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

PSLIST_ENTRY
FirstEntrySList (
    IN const SLIST_HEADER *SListHead
    );

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#if defined(_WIN64)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

{

    return (USHORT)(SListHead->Alignment & 0xffff);
}

#endif

#else

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif

#if defined(_WIN64)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#else

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

#else

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

#endif // defined(_WIN64)

// end_ntddk end_wdm end_ntosp


PSLIST_ENTRY
FASTCALL
InterlockedPushListSList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY List,
    IN PSLIST_ENTRY ListEnd,
    IN ULONG Count
    );


//
// Define interlocked lookaside list structure and allocation functions.
//

VOID
ExAdjustLookasideDepth (
    VOID
    );

// begin_ntddk begin_wdm begin_ntosp

typedef
PVOID
(*PALLOCATE_FUNCTION) (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    IN PVOID Buffer
    );

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _GENERAL_LOOKASIDE {

#else

typedef struct DECLSPEC_CACHEALIGN _GENERAL_LOOKASIDE {

#endif

    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    union {
        ULONG AllocateMisses;
        ULONG AllocateHits;
    };

    ULONG TotalFrees;
    union {
        ULONG FreeMisses;
        ULONG FreeHits;
    };

    POOL_TYPE Type;
    ULONG Tag;
    ULONG Size;
    PALLOCATE_FUNCTION Allocate;
    PFREE_FUNCTION Free;
    LIST_ENTRY ListEntry;
    ULONG LastTotalAllocates;
    union {
        ULONG LastAllocateMisses;
        ULONG LastAllocateHits;
    };

    ULONG Future[2];
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _NPAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _NPAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    );

__inline
PVOID
ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);


#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);

#endif

    }
    return;
}


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05
#define PCI_CAPABILITY_ID_AGP_TARGET        0x0E

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//
typedef struct _PCI_AGP_CAPABILITY {
    
    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Agp3Mode:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   HostTransDisable:1;
        ULONG   Gart64:1;
        ULONG   ITA_Coherent:1;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   CalibrationCycle:3;
        ULONG   AsyncRequestSize:3;
        ULONG   Rsvd1:1;
        ULONG   Isoch:1;
        ULONG   Rsvd2:6;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:1;
        ULONG   Gart64:1;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   CalibrationCycle:3;
        ULONG   AsyncReqSize:3;
        ULONG   Rsvd3:8;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

//
// An AGPv3 Target must have an extended capability,
// but it's only present for a Master when the Isoch
// bit is set in its status register
//
typedef enum _EXTENDED_AGP_REGISTER {
    IsochStatus,
    AgpControl,
    ApertureSize,
    AperturePageSize,
    GartLow,
    GartHigh,
    IsochCommand
} EXTENDED_AGP_REGISTER, *PEXTENDED_AGP_REGISTER;

typedef struct _PCI_AGP_ISOCH_STATUS {
    ULONG ErrorCode: 2;
    ULONG Rsvd1: 1;
    ULONG Isoch_L: 3;
    ULONG Isoch_Y: 2;
    ULONG Isoch_N: 8;
    ULONG Rsvd2: 16;
} PCI_AGP_ISOCH_STATUS, *PPCI_AGP_ISOCH_STATUS;

typedef struct _PCI_AGP_CONTROL {
    ULONG Rsvd1: 7;
    ULONG GTLB_Enable: 1;
    ULONG AP_Enable: 1;
    ULONG CAL_Disable: 1;
    ULONG Rsvd2: 22;
} PCI_AGP_CONTROL, *PPCI_AGP_CONTROL;

typedef struct _PCI_AGP_APERTURE_PAGE_SIZE {
    USHORT PageSizeMask: 11;
    USHORT Rsvd1: 1;
    USHORT PageSizeSelect: 4;
} PCI_AGP_APERTURE_PAGE_SIZE, *PPCI_AGP_APERTURE_PAGE_SIZE;

typedef struct _PCI_AGP_ISOCH_COMMAND {
    USHORT Rsvd1: 6;
    USHORT Isoch_Y: 2;
    USHORT Isoch_N: 8;
} PCI_AGP_ISOCH_COMMAND, *PPCI_AGP_ISOCH_COMMAND;

typedef struct PCI_AGP_EXTENDED_CAPABILITY {

    PCI_AGP_ISOCH_STATUS IsochStatus;

//
// Target only ----------------<<-begin->>
//
    PCI_AGP_CONTROL AgpControl;
    USHORT ApertureSize;
    PCI_AGP_APERTURE_PAGE_SIZE AperturePageSize;
    ULONG GartLow;
    ULONG GartHigh;
//
// ------------------------------<<-end->>
//

    PCI_AGP_ISOCH_COMMAND IsochCommand;

} PCI_AGP_EXTENDED_CAPABILITY, *PPCI_AGP_EXTENDED_CAPABILITY;


#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80




typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;


#else // BINARY_COMPATIBLE && !NDIS_WDM

#if (!BINARY_COMPATIBLE)

//
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//
//
// The definitions available in ntddk.h must not be used directly by non-WDM miniport drivers.
//

#include <ntddk.h>

#else // !BINARY_COMPATIBLE

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
//

#include <wdm.h>

#endif  // else !BINARY_COMPATIBLE

#endif //  else BINARY_COMPATIBLE && !NDIS_WDM
//
// END INTERNAL DEFINITIONS
//
// The following definitions may be used by NDIS drivers, except as noted.
//

#ifndef __NET_PNP__
#define __NET_PNP__

//
//  PnP and PM event codes that can be indicated up to transports
//  and clients.
//
typedef enum _NET_PNP_EVENT_CODE
{
    NetEventSetPower,
    NetEventQueryPower,
    NetEventQueryRemoveDevice,
    NetEventCancelRemoveDevice,
    NetEventReconfigure,
    NetEventBindList,
    NetEventBindsComplete,
    NetEventPnPCapabilities,
    NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

//
//  Networking PnP event indication structure.
//
typedef struct _NET_PNP_EVENT
{
    //
    //  Event code describing action to take.
    //
    NET_PNP_EVENT_CODE  NetEvent;

    //
    //  Event specific data.
    //
    PVOID               Buffer;

    //
    //  Length of event specific data.
    //
    ULONG               BufferLength;

    //
    //  Reserved values are for use by respective components only.
    //
    //  Note: these reserved areas must be pointer aligned.
    //  

    ULONG_PTR           NdisReserved[4];
    ULONG_PTR           TransportReserved[4];
    ULONG_PTR           TdiReserved[4];
    ULONG_PTR           TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

//
//  The following structure defines the device power states.
//
typedef enum _NET_DEVICE_POWER_STATE
{
    NetDeviceStateUnspecified = 0,
    NetDeviceStateD0,
    NetDeviceStateD1,
    NetDeviceStateD2,
    NetDeviceStateD3,
    NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

#endif // __NET_PNP__

//
// Indicate that we're building for NT. NDIS_NT is always used for
// miniport builds.
//

#define NDIS_NT 1

#if defined(NDIS_DOS)
#undef NDIS_DOS
#endif


//
// Define status codes and event log codes.
//

#include <ntstatus.h>
#include <netevent.h>

//
// Define a couple of extra types.
//

#if !defined(_WINDEF_)      // these are defined in windows.h too
typedef signed int INT, *PINT;
typedef unsigned int UINT, *PUINT;
#endif

typedef UNICODE_STRING NDIS_STRING, *PNDIS_STRING;


//
// Portability extentions
//

#define NDIS_INIT_FUNCTION(_F)      alloc_text(INIT,_F)
#define NDIS_PAGABLE_FUNCTION(_F)   alloc_text(PAGE,_F)
#define NDIS_PAGEABLE_FUNCTION(_F)  alloc_text(PAGE,_F)

//
// This file contains the definition of an NDIS_OID as
// well as #defines for all the current OID values.
//

//
// Define NDIS_STATUS and NDIS_HANDLE here
//
typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef int NDIS_STATUS, *PNDIS_STATUS; // note default size


//
// for Miniports versions 5.0 and up, provide a consistent way to match
// Ndis version in their characteristics with their makefile defines
//
#if (!defined(NDIS_MINIPORT_MAJOR_VERSION) && !defined(NDIS_MINIPORT_MINOR_VERSION))
#if (defined(NDIS51_MINIPORT))
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 1
#elif (defined(NDIS50_MINIPORT))
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 0
#endif
#endif

//
// for protocol versions 5.0 and up, provide a consistent way to match
// Ndis version in their characteristics with their makefile defines
//
#if (!defined(NDIS_PROTOCOL_MAJOR_VERSION) && !defined(NDIS_PROTOCOL_MINOR_VERSION))
#if (defined(NDIS51))
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 1
#elif (defined(NDIS50))
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 0
#endif
#endif


#include <ntddndis.h>



//
// Ndis defines for configuration manager data structures
//
typedef CM_MCA_POS_DATA NDIS_MCA_POS_DATA, *PNDIS_MCA_POS_DATA;
typedef CM_EISA_SLOT_INFORMATION NDIS_EISA_SLOT_INFORMATION, *PNDIS_EISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION NDIS_EISA_FUNCTION_INFORMATION, *PNDIS_EISA_FUNCTION_INFORMATION;

//
// Define an exported function.
//
#if defined(NDIS_WRAPPER)
#define EXPORT
#else
#define EXPORT DECLSPEC_IMPORT
#endif

//
// Memory manipulation functions.
//
#define NdisMoveMemory(Destination, Source, Length) RtlCopyMemory(Destination, Source, Length)
#define NdisZeroMemory(Destination, Length)         RtlZeroMemory(Destination, Length)
#define NdisEqualMemory(Source1, Source2, Length)   RtlEqualMemory(Source1, Source2, Length)
#define NdisFillMemory(Destination, Length, Fill)   RtlFillMemory(Destination, Length, Fill)
#define NdisRetrieveUlong(Destination, Source)      RtlRetrieveUlong(Destination, Source)
#define NdisStoreUlong(Destination, Value)          RtlStoreUlong(Destination, Value)

#define NDIS_STRING_CONST(x)    {sizeof(L##x)-2, sizeof(L##x), L##x}

//
// On a RISC machine, I/O mapped memory can't be accessed with
// the Rtl routines.
//
#if defined(_M_IX86) || defined(_M_AMD64)

#define NdisMoveMappedMemory(Destination,Source,Length) RtlCopyMemory(Destination,Source,Length)
#define NdisZeroMappedMemory(Destination,Length)        RtlZeroMemory(Destination,Length)

#elif defined(_M_IA64)

#define NdisMoveMappedMemory(Destination,Source,Length)                     \
{                                                                           \
    PUCHAR _Src = (Source);                                                 \
    PUCHAR _Dest = (Destination);                                           \
    PUCHAR _End = _Dest + (Length);                                         \
    while (_Dest < _End)                                                    \
    {                                                                       \
        *_Dest++ = *_Src++;                                                 \
    }                                                                       \
}

#define NdisZeroMappedMemory(Destination,Length)                            \
{                                                                           \
    PUCHAR _Dest = (Destination);                                           \
    PUCHAR _End = _Dest + (Length);                                         \
    while (_Dest < _End)                                                    \
    {                                                                       \
        *_Dest++ = 0;                                                       \
    }                                                                       \
}
#endif


#define NdisMoveToMappedMemory(Destination,Source,Length)                   \
                            NdisMoveMappedMemory(Destination,Source,Length)
#define NdisMoveFromMappedMemory(Destination,Source,Length)                 \
                            NdisMoveMappedMemory(Destination,Source,Length)


//
// definition of the basic spin lock structure
//

typedef struct _NDIS_SPIN_LOCK
{
    KSPIN_LOCK  SpinLock;
    KIRQL       OldIrql;
} NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;


//
// definition of the ndis event structure
//
typedef struct _NDIS_EVENT
{
    KEVENT      Event;
} NDIS_EVENT, *PNDIS_EVENT;

#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parenthesis
typedef VOID    (*NDIS_PROC)(struct _NDIS_WORK_ITEM *, PVOID);
#pragma warning(pop)

//
// Definition of an ndis work-item
//
typedef struct _NDIS_WORK_ITEM
{
    PVOID           Context;
    NDIS_PROC       Routine;
    UCHAR           WrapperReserved[8*sizeof(PVOID)];
} NDIS_WORK_ITEM, *PNDIS_WORK_ITEM;

#define NdisInterruptLatched            Latched
#define NdisInterruptLevelSensitive     LevelSensitive
typedef KINTERRUPT_MODE NDIS_INTERRUPT_MODE, *PNDIS_INTERRUPT_MODE;

//
// Configuration definitions
//

//
// Possible data types
//

typedef enum _NDIS_PARAMETER_TYPE
{
    NdisParameterInteger,
    NdisParameterHexInteger,
    NdisParameterString,
    NdisParameterMultiString,
    NdisParameterBinary
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef struct
{
    USHORT          Length;
    PVOID           Buffer;
} BINARY_DATA;

//
// To store configuration information
//
typedef struct _NDIS_CONFIGURATION_PARAMETER
{
    NDIS_PARAMETER_TYPE ParameterType;
    union
    {
        ULONG           IntegerData;
        NDIS_STRING     StringData;
        BINARY_DATA     BinaryData;
    } ParameterData;
} NDIS_CONFIGURATION_PARAMETER, *PNDIS_CONFIGURATION_PARAMETER;


//
// Definitions for the "ProcessorType" keyword
//
typedef enum _NDIS_PROCESSOR_TYPE
{
    NdisProcessorX86,
    NdisProcessorMips,
    NdisProcessorAlpha,
    NdisProcessorPpc,
    NdisProcessorAmd64
} NDIS_PROCESSOR_TYPE, *PNDIS_PROCESSOR_TYPE;

//
// Definitions for the "Environment" keyword
//
typedef enum _NDIS_ENVIRONMENT_TYPE
{
    NdisEnvironmentWindows,
    NdisEnvironmentWindowsNt
} NDIS_ENVIRONMENT_TYPE, *PNDIS_ENVIRONMENT_TYPE;


//
// Possible Hardware Architecture. Define these to
// match the HAL INTERFACE_TYPE enum.
//
typedef enum _NDIS_INTERFACE_TYPE
{
    NdisInterfaceInternal = Internal,
    NdisInterfaceIsa = Isa,
    NdisInterfaceEisa = Eisa,
    NdisInterfaceMca = MicroChannel,
    NdisInterfaceTurboChannel = TurboChannel,
    NdisInterfacePci = PCIBus,
    NdisInterfacePcMcia = PCMCIABus,
    NdisInterfaceCBus = CBus,
    NdisInterfaceMPIBus = MPIBus,
    NdisInterfaceMPSABus = MPSABus,
    NdisInterfaceProcessorInternal = ProcessorInternal,
    NdisInterfaceInternalPowerBus = InternalPowerBus,
    NdisInterfacePNPISABus = PNPISABus,
    NdisInterfacePNPBus = PNPBus,
    NdisMaximumInterfaceType
} NDIS_INTERFACE_TYPE, *PNDIS_INTERFACE_TYPE;

//
// Definition for shutdown handler
//

typedef
VOID
(*ADAPTER_SHUTDOWN_HANDLER) (
    IN  PVOID ShutdownContext
    );

//
// Stuff for PCI configuring
//

typedef CM_PARTIAL_RESOURCE_LIST NDIS_RESOURCE_LIST, *PNDIS_RESOURCE_LIST;


//
// The structure passed up on a WAN_LINE_UP indication
//

typedef struct _NDIS_WAN_LINE_UP
{
    IN ULONG                LinkSpeed;          // 100 bps units
    IN ULONG                MaximumTotalSize;   // suggested max for send packets
    IN NDIS_WAN_QUALITY     Quality;
    IN USHORT               SendWindow;         // suggested by the MAC
    IN UCHAR                RemoteAddress[6];
    IN OUT UCHAR            LocalAddress[6];
    IN ULONG                ProtocolBufferLength;   // Length of protocol info buffer
    IN PUCHAR               ProtocolBuffer;     // Information used by protocol
    IN USHORT               ProtocolType;       // Protocol ID
    IN OUT NDIS_STRING      DeviceName;
} NDIS_WAN_LINE_UP, *PNDIS_WAN_LINE_UP;

//
// The structure passed up on a WAN_LINE_DOWN indication
//

typedef struct _NDIS_WAN_LINE_DOWN
{
    IN UCHAR    RemoteAddress[6];
    IN UCHAR    LocalAddress[6];
} NDIS_WAN_LINE_DOWN, *PNDIS_WAN_LINE_DOWN;

//
// The structure passed up on a WAN_FRAGMENT indication
//

typedef struct _NDIS_WAN_FRAGMENT
{
    IN UCHAR    RemoteAddress[6];
    IN UCHAR    LocalAddress[6];
} NDIS_WAN_FRAGMENT, *PNDIS_WAN_FRAGMENT;

//
// The structure passed up on a WAN_GET_STATS indication
//

typedef struct _NDIS_WAN_GET_STATS
{
    IN  UCHAR   LocalAddress[6];
    OUT ULONG   BytesSent;
    OUT ULONG   BytesRcvd;
    OUT ULONG   FramesSent;
    OUT ULONG   FramesRcvd;
    OUT ULONG   CRCErrors;                      // Serial-like info only
    OUT ULONG   TimeoutErrors;                  // Serial-like info only
    OUT ULONG   AlignmentErrors;                // Serial-like info only
    OUT ULONG   SerialOverrunErrors;            // Serial-like info only
    OUT ULONG   FramingErrors;                  // Serial-like info only
    OUT ULONG   BufferOverrunErrors;            // Serial-like info only
    OUT ULONG   BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG   BytesReceivedUncompressed;      // Compression info only
    OUT ULONG   BytesTransmittedCompressed;     // Compression info only
    OUT ULONG   BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_GET_STATS, *PNDIS_WAN_GET_STATS;


//
// DMA Channel information
//
typedef struct _NDIS_DMA_DESCRIPTION
{
    BOOLEAN     DemandMode;
    BOOLEAN     AutoInitialize;
    BOOLEAN     DmaChannelSpecified;
    DMA_WIDTH   DmaWidth;
    DMA_SPEED   DmaSpeed;
    ULONG       DmaPort;
    ULONG       DmaChannel;
} NDIS_DMA_DESCRIPTION, *PNDIS_DMA_DESCRIPTION;

//
// Internal structure representing an NDIS DMA channel
//
typedef struct _NDIS_DMA_BLOCK
{
    PVOID                   MapRegisterBase;
    KEVENT                  AllocationEvent;
    PVOID                   SystemAdapterObject;
    PVOID                   Miniport;
    BOOLEAN                 InProgress;
} NDIS_DMA_BLOCK, *PNDIS_DMA_BLOCK;



#if defined(NDIS_WRAPPER)
//
// definitions for PnP state
//

typedef enum _NDIS_PNP_DEVICE_STATE
{
    NdisPnPDeviceAdded,
    NdisPnPDeviceStarted,
    NdisPnPDeviceQueryStopped,
    NdisPnPDeviceStopped,
    NdisPnPDeviceQueryRemoved,
    NdisPnPDeviceRemoved,
    NdisPnPDeviceSurpriseRemoved
} NDIS_PNP_DEVICE_STATE;

//
// flags to use in PnPCapabilities Flag
//
#define NDIS_DEVICE_NOT_STOPPABLE                   0x00000001      // the debvice is not stoppable i.e. ISA
#define NDIS_DEVICE_NOT_REMOVEABLE                  0x00000002      // the device can not be safely removed
#define NDIS_DEVICE_NOT_SUSPENDABLE                 0x00000004      // the device can not be safely suspended
#define NDIS_DEVICE_DISABLE_PM                      0x00000008      // disable all PM features
#define NDIS_DEVICE_DISABLE_WAKE_UP                 0x00000010      // disable device waking up the system
#define NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT       0x00000020      // disable device waking up the -system- due to a cable re-connect
#define NDIS_DEVICE_RESERVED                        0x00000040      // should not be used
#define NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET    0x00000080      // disable device waking up the -system- due to a magic packet
#define NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH   0x00000100      // disable device waking up the -system- due to a pattern match



#endif // NDIS_WRAPPER defined

//
// Ndis Buffer is actually an Mdl
//
typedef MDL NDIS_BUFFER, *PNDIS_BUFFER;

struct _NDIS_PACKET;
typedef NDIS_HANDLE PNDIS_PACKET_POOL;

//
//
// wrapper-specific part of a packet
//
typedef struct _NDIS_PACKET_PRIVATE
{
    UINT                PhysicalCount;  // number of physical pages in packet.
    UINT                TotalLength;    // Total amount of data in the packet.
    PNDIS_BUFFER        Head;           // first buffer in the chain
    PNDIS_BUFFER        Tail;           // last buffer in the chain

    // if Head is NULL the chain is empty; Tail doesn't have to be NULL also

    PNDIS_PACKET_POOL   Pool;           // so we know where to free it back to
    UINT                Count;
    ULONG               Flags;
    BOOLEAN             ValidCounts;
    UCHAR               NdisPacketFlags;    // See fPACKET_xxx bits below
    USHORT              NdisPacketOobOffset;
} NDIS_PACKET_PRIVATE, * PNDIS_PACKET_PRIVATE;

//
// The bits define the bits in the Flags
//
#define NDIS_FLAGS_PROTOCOL_ID_MASK             0x0000000F  // The low 4 bits are defined for protocol-id
                                                            // The values are defined in ntddndis.h
#define NDIS_FLAGS_MULTICAST_PACKET             0x00000010  // don't use
#define NDIS_FLAGS_RESERVED2                    0x00000020  // don't use
#define NDIS_FLAGS_RESERVED3                    0x00000040  // don't use
#define NDIS_FLAGS_DONT_LOOPBACK                0x00000080  // Write only
#define NDIS_FLAGS_IS_LOOPBACK_PACKET           0x00000100  // Read only
#define NDIS_FLAGS_LOOPBACK_ONLY                0x00000200  // Write only
#define NDIS_FLAGS_RESERVED4                    0x00000400  // don't use
#define NDIS_FLAGS_DOUBLE_BUFFERED              0x00000800  // used by ndis
#define NDIS_FLAGS_SENT_AT_DPC                  0x00001000  // the protocol sent this packet at DPC
#define NDIS_FLAGS_USES_SG_BUFFER_LIST          0x00002000  // used by Ndis
#define NDIS_FLAGS_CONTAINS_ARCNET_HEADER       0x00004000  // used by Ndis

//
// Low-bits in the NdisPacketFlags are reserved by NDIS Wrapper for internal use
//
#define fPACKET_WRAPPER_RESERVED                0x3F
#define fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO    0x40
#define fPACKET_ALLOCATED_BY_NDIS               0x80

//
// Definition for layout of the media-specific data. More than one class of media-specific
// information can be tagged onto a packet.
//
typedef enum _NDIS_CLASS_ID
{
    NdisClass802_3Priority,
    NdisClassWirelessWanMbxMailbox,
    NdisClassIrdaPacketInfo,
    NdisClassAtmAALInfo

} NDIS_CLASS_ID;

typedef struct _MEDIA_SPECIFIC_INFORMATION
{
    UINT            NextEntryOffset;
    NDIS_CLASS_ID   ClassId;
    UINT            Size;
    UCHAR           ClassInformation[1];

} MEDIA_SPECIFIC_INFORMATION, *PMEDIA_SPECIFIC_INFORMATION;

typedef struct _NDIS_PACKET_OOB_DATA
{
    union
    {
        ULONGLONG   TimeToSend;
        ULONGLONG   TimeSent;
    };
    ULONGLONG       TimeReceived;
    UINT            HeaderSize;
    UINT            SizeMediaSpecificInfo;
    PVOID           MediaSpecificInformation;

    NDIS_STATUS     Status;
} NDIS_PACKET_OOB_DATA, *PNDIS_PACKET_OOB_DATA;

#define NDIS_GET_PACKET_PROTOCOL_TYPE(_Packet_) ((_Packet_)->Private.Flags & NDIS_PROTOCOL_ID_MASK)

#define NDIS_OOB_DATA_FROM_PACKET(_p)                                   \
                        (PNDIS_PACKET_OOB_DATA)((PUCHAR)(_p) +          \
                        (_p)->Private.NdisPacketOobOffset)
#define NDIS_GET_PACKET_HEADER_SIZE(_Packet)                            \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->HeaderSize
#define NDIS_GET_PACKET_STATUS(_Packet)                                 \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->Status
#define NDIS_GET_PACKET_TIME_TO_SEND(_Packet)                           \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeToSend
#define NDIS_GET_PACKET_TIME_SENT(_Packet)                              \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeSent
#define NDIS_GET_PACKET_TIME_RECEIVED(_Packet)                          \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeReceived
#define NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                    \
                                            _pMediaSpecificInfo,        \
                                            _pSizeMediaSpecificInfo)    \
{                                                                       \
    if (!((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) ||\
        !((_Packet)->Private.NdisPacketFlags & fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO))\
    {                                                                   \
        *(_pMediaSpecificInfo) = NULL;                                  \
        *(_pSizeMediaSpecificInfo) = 0;                                 \
    }                                                                   \
    else                                                                \
    {                                                                   \
        *(_pMediaSpecificInfo) =((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +\
                    (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation;\
        *(_pSizeMediaSpecificInfo) = ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +\
                    (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo;\
    }                                                                   \
}

#define NDIS_SET_PACKET_HEADER_SIZE(_Packet, _HdrSize)                  \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->HeaderSize = (_HdrSize)
#define NDIS_SET_PACKET_STATUS(_Packet, _Status)                        \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->Status = (_Status)
#define NDIS_SET_PACKET_TIME_TO_SEND(_Packet, _TimeToSend)              \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeToSend = (_TimeToSend)
#define NDIS_SET_PACKET_TIME_SENT(_Packet, _TimeSent)                   \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeSent = (_TimeSent)
#define NDIS_SET_PACKET_TIME_RECEIVED(_Packet, _TimeReceived)           \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeReceived = (_TimeReceived)
#define NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                    \
                                            _MediaSpecificInfo,         \
                                            _SizeMediaSpecificInfo)     \
{                                                                       \
    if ((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) \
    {                                                                   \
        (_Packet)->Private.NdisPacketFlags |= fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO;\
        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                    \
                                          (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation = (_MediaSpecificInfo);\
        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                    \
                                          (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo = (_SizeMediaSpecificInfo);\
    }                                                                   \
}

//
// packet definition
//
typedef struct _NDIS_PACKET
{
    NDIS_PACKET_PRIVATE Private;

    union
    {
        struct                  // For Connection-less miniports
        {
            UCHAR   MiniportReserved[2*sizeof(PVOID)];
            UCHAR   WrapperReserved[2*sizeof(PVOID)];
        };

        struct
        {
            //
            // For de-serialized miniports. And by implication conn-oriented miniports.
            //
            UCHAR   MiniportReservedEx[3*sizeof(PVOID)];
            UCHAR   WrapperReservedEx[sizeof(PVOID)];
        };

        struct
        {
            UCHAR   MacReserved[4*sizeof(PVOID)];
        };
    };

    ULONG_PTR       Reserved[2];            // For compatibility with Win95
    UCHAR           ProtocolReserved[1];

} NDIS_PACKET, *PNDIS_PACKET, **PPNDIS_PACKET;

//
//  NDIS per-packet information.
//
typedef enum _NDIS_PER_PACKET_INFO
{
    TcpIpChecksumPacketInfo,
    IpSecPacketInfo,
    TcpLargeSendPacketInfo,
    ClassificationHandlePacketInfo,
    NdisReserved,
    ScatterGatherListPacketInfo,
    Ieee8021QInfo,
    OriginalPacketInfo,
    PacketCancelId,
    MaxPerPacketInfo
} NDIS_PER_PACKET_INFO, *PNDIS_PER_PACKET_INFO;

typedef struct _NDIS_PACKET_EXTENSION
{
    PVOID       NdisPacketInfo[MaxPerPacketInfo];
} NDIS_PACKET_EXTENSION, *PNDIS_PACKET_EXTENSION;

#define NDIS_PACKET_EXTENSION_FROM_PACKET(_P)       ((PNDIS_PACKET_EXTENSION)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset + sizeof(NDIS_PACKET_OOB_DATA)))
#define NDIS_PER_PACKET_INFO_FROM_PACKET(_P, _Id)   ((PNDIS_PACKET_EXTENSION)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset + sizeof(NDIS_PACKET_OOB_DATA)))->NdisPacketInfo[(_Id)]
#define NDIS_GET_ORIGINAL_PACKET(_P)                NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalPacketInfo)
#define NDIS_SET_ORIGINAL_PACKET(_P, _OP)           NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalPacketInfo) = _OP
#define NDIS_GET_PACKET_CANCEL_ID(_P)               NDIS_PER_PACKET_INFO_FROM_PACKET(_P, PacketCancelId)
#define NDIS_SET_PACKET_CANCEL_ID(_P, _cId)         NDIS_PER_PACKET_INFO_FROM_PACKET(_P, PacketCancelId) = _cId


typedef struct _NDIS_PACKET_STACK
{
    ULONG_PTR   IMReserved[2];
    ULONG_PTR   NdisReserved[4];
} NDIS_PACKET_STACK, *PNDIS_PACKET_STACK;

//
//  Per-packet information for TcpIpChecksumPacketInfo.
//
typedef struct _NDIS_TCP_IP_CHECKSUM_PACKET_INFO
{
    union
    {
        struct
        {
            ULONG   NdisPacketChecksumV4:1;
            ULONG   NdisPacketChecksumV6:1;
            ULONG   NdisPacketTcpChecksum:1;
            ULONG   NdisPacketUdpChecksum:1;
            ULONG   NdisPacketIpChecksum:1;
        } Transmit;

        struct
        {
            ULONG   NdisPacketTcpChecksumFailed:1;
            ULONG   NdisPacketUdpChecksumFailed:1;
            ULONG   NdisPacketIpChecksumFailed:1;
            ULONG   NdisPacketTcpChecksumSucceeded:1;
            ULONG   NdisPacketUdpChecksumSucceeded:1;
            ULONG   NdisPacketIpChecksumSucceeded:1;
            ULONG   NdisPacketLoopback:1;
        } Receive;

        ULONG   Value;
    };
} NDIS_TCP_IP_CHECKSUM_PACKET_INFO, *PNDIS_TCP_IP_CHECKSUM_PACKET_INFO;


//
//  Per-packet information for Ieee8021QInfo.
//
typedef struct _NDIS_PACKET_8021Q_INFO
{
    union
    {
        struct
        {
            UINT32      UserPriority:3;         // 802.1p priority
            UINT32      CanonicalFormatId:1;    // always 0
            UINT32      VlanId:12;              // VLAN Identification
            UINT32      Reserved:16;            // set to 0
        }   TagHeader;

        PVOID  Value;
    };
} NDIS_PACKET_8021Q_INFO, *PNDIS_PACKET_8021Q_INFO;

//
//  Old definitions, to be obsoleted.
//
#define Ieee8021pPriority   Ieee8021QInfo
typedef UINT                IEEE8021PPRIORITY;


#define MAX_HASHES          4
#define TRUNCATED_HASH_LEN  12

#define CRYPTO_SUCCESS                      0
#define CRYPTO_GENERIC_ERROR                1
#define CRYPTO_TRANSPORT_AH_AUTH_FAILED     2
#define CRYPTO_TRANSPORT_ESP_AUTH_FAILED    3
#define CRYPTO_TUNNEL_AH_AUTH_FAILED        4
#define CRYPTO_TUNNEL_ESP_AUTH_FAILED       5
#define CRYPTO_INVALID_PACKET_SYNTAX        6
#define CRYPTO_INVALID_PROTOCOL             7

typedef struct _NDIS_IPSEC_PACKET_INFO
{
    union
    {
        struct
        {
            NDIS_HANDLE OffloadHandle;
            NDIS_HANDLE NextOffloadHandle;

        } Transmit;

        struct
        {
            ULONG   SA_DELETE_REQ:1;
            ULONG   CRYPTO_DONE:1;
            ULONG   NEXT_CRYPTO_DONE:1;
            ULONG   CryptoStatus;
        } Receive;
    };
} NDIS_IPSEC_PACKET_INFO, *PNDIS_IPSEC_PACKET_INFO;


///
//  NDIS Task Off-Load data structures.
///

#define NDIS_TASK_OFFLOAD_VERSION 1

//
//  The following defines are used in the Task field above to define
//  the type of task offloading necessary.
//
typedef enum _NDIS_TASK
{
    TcpIpChecksumNdisTask,
    IpSecNdisTask,
    TcpLargeSendNdisTask,
    MaxNdisTask
} NDIS_TASK, *PNDIS_TASK;

typedef enum _NDIS_ENCAPSULATION
{
    UNSPECIFIED_Encapsulation,
    NULL_Encapsulation,
    IEEE_802_3_Encapsulation,
    IEEE_802_5_Encapsulation,
    LLC_SNAP_ROUTED_Encapsulation,
    LLC_SNAP_BRIDGED_Encapsulation

} NDIS_ENCAPSULATION;

//
// Encapsulation header format
//
typedef struct _NDIS_ENCAPSULATION_FORMAT
{
    NDIS_ENCAPSULATION  Encapsulation;              // Encapsulation type
    struct
    {
        ULONG   FixedHeaderSize:1;
        ULONG   Reserved:31;
    } Flags;

    ULONG    EncapsulationHeaderSize;               // Encapsulation header size

} NDIS_ENCAPSULATION_FORMAT,*PNDIS_ENCAPSULATION_FORMAT;


//
// OFFLOAD header structure for OID_TCP_TASK_OFFLOAD
//
typedef struct _NDIS_TASK_OFFLOAD_HEADER
{
    ULONG       Version;                            // set to NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               // Size of this structure
    ULONG       Reserved;                           // Reserved for future use
    ULONG       OffsetFirstTask;                    // Offset to the first
    NDIS_ENCAPSULATION_FORMAT  EncapsulationFormat; // Encapsulation information.
                                                    // NDIS_TASK_OFFLOAD structure(s)

} NDIS_TASK_OFFLOAD_HEADER, *PNDIS_TASK_OFFLOAD_HEADER;


//
//  Task offload Structure, which follows the above header in ndis query
//
typedef struct _NDIS_TASK_OFFLOAD
{
    ULONG       Version;                            // NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               //  Size of this structure. Used for version checking.
    NDIS_TASK   Task;                               //  Task.
    ULONG       OffsetNextTask;                     //  Offset to the next NDIS_TASK_OFFLOAD
    ULONG       TaskBufferLength;                   //  Length of the task offload information.
    UCHAR       TaskBuffer[1];                      //  The task offload information.
} NDIS_TASK_OFFLOAD, *PNDIS_TASK_OFFLOAD;

//
//  Offload structure for NDIS_TASK_TCP_IP_CHECKSUM
//
typedef struct _NDIS_TASK_TCP_IP_CHECKSUM
{
    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Receive;


    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Receive;


} NDIS_TASK_TCP_IP_CHECKSUM, *PNDIS_TASK_TCP_IP_CHECKSUM;

//
//  Off-load structure for NDIS_TASK_TCP_LARGE_SEND
//
typedef struct _NDIS_TASK_TCP_LARGE_SEND
{
    ULONG     Version;
    ULONG     MaxOffLoadSize;
    ULONG        MinSegmentCount;
    BOOLEAN   TcpOptions;
    BOOLEAN   IpOptions;

} NDIS_TASK_TCP_LARGE_SEND, *PNDIS_TASK_TCP_LARGE_SEND;


typedef struct _NDIS_TASK_IPSEC
{
    struct
    {
        ULONG   AH_ESP_COMBINED;
        ULONG   TRANSPORT_TUNNEL_COMBINED;
        ULONG   V4_OPTIONS;
        ULONG   RESERVED;
    } Supported;

    struct
    {
        ULONG   MD5:1;
        ULONG   SHA_1:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4AH;

    struct
    {
        ULONG   DES:1;
        ULONG   RESERVED:1;
        ULONG   TRIPLE_DES:1;
        ULONG   NULL_ESP:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4ESP;

} NDIS_TASK_IPSEC, *PNDIS_TASK_IPSEC;


#define IPSEC_TPT_UDPESP_ENCAPTYPE_IKE                 0x00000001
#define IPSEC_TUN_UDPESP_ENCAPTYPE_IKE                 0x00000002
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_IKE          0x00000004
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_IKE   0x00000008
#define IPSEC_TPT_UDPESP_ENCAPTYPE_OTHER               0x00000010
#define IPSEC_TUN_UDPESP_ENCAPTYPE_OTHER               0x00000020
#define IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_OTHER        0x00000040
#define IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_OTHER 0x00000080


typedef UINT    IEEE8021PPRIORITY;

//
// WAN Packet. This is used by WAN miniports only. This is the legacy model.
// Co-Ndis is the preferred model for WAN miniports
//
typedef struct _NDIS_WAN_PACKET
{
    LIST_ENTRY          WanPacketQueue;
    PUCHAR              CurrentBuffer;
    ULONG               CurrentLength;
    PUCHAR              StartBuffer;
    PUCHAR              EndBuffer;
    PVOID               ProtocolReserved1;
    PVOID               ProtocolReserved2;
    PVOID               ProtocolReserved3;
    PVOID               ProtocolReserved4;
    PVOID               MacReserved1;
    PVOID               MacReserved2;
    PVOID               MacReserved3;
    PVOID               MacReserved4;
} NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

//
// Routines to get/set packet flags
//

/*++

UINT
NdisGetPacketFlags(
    IN  PNDIS_PACKET    Packet
    );

--*/

#define NdisGetPacketFlags(_Packet)         (_Packet)->Private.Flags

/*++

VOID
NdisSetPacketFlags(
    IN  PNDIS_PACKET Packet,
    IN  UINT Flags
    );

--*/

#define NdisSetPacketFlags(_Packet, _Flags)     (_Packet)->Private.Flags |= (_Flags)
#define NdisClearPacketFlags(_Packet, _Flags)   (_Packet)->Private.Flags &= ~(_Flags)

//
// Request types used by NdisRequest; constants are added for
// all entry points in the MAC, for those that want to create
// their own internal requests.
//

typedef enum _NDIS_REQUEST_TYPE
{
    NdisRequestQueryInformation,
    NdisRequestSetInformation,
    NdisRequestQueryStatistics,
    NdisRequestOpen,
    NdisRequestClose,
    NdisRequestSend,
    NdisRequestTransferData,
    NdisRequestReset,
    NdisRequestGeneric1,
    NdisRequestGeneric2,
    NdisRequestGeneric3,
    NdisRequestGeneric4
} NDIS_REQUEST_TYPE, *PNDIS_REQUEST_TYPE;


//
// Structure of requests sent via NdisRequest
//

typedef struct _NDIS_REQUEST
{
    UCHAR               MacReserved[4*sizeof(PVOID)];
    NDIS_REQUEST_TYPE   RequestType;
    union _DATA
    {
        struct _QUERY_INFORMATION
        {
            NDIS_OID    Oid;
            PVOID       InformationBuffer;
            UINT        InformationBufferLength;
            UINT        BytesWritten;
            UINT        BytesNeeded;
        } QUERY_INFORMATION;

        struct _SET_INFORMATION
        {
            NDIS_OID    Oid;
            PVOID       InformationBuffer;
            UINT        InformationBufferLength;
            UINT        BytesRead;
            UINT        BytesNeeded;
        } SET_INFORMATION;

    } DATA;
#if (defined(NDIS50) || defined(NDIS51) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT))
    UCHAR               NdisReserved[9*sizeof(PVOID)];
    union
    {
        UCHAR           CallMgrReserved[2*sizeof(PVOID)];
        UCHAR           ProtocolReserved[2*sizeof(PVOID)];
    };
    UCHAR               MiniportReserved[2*sizeof(PVOID)];
#endif
} NDIS_REQUEST, *PNDIS_REQUEST;


//
// NDIS Address Family definitions.
//
typedef ULONG           NDIS_AF, *PNDIS_AF;
#define CO_ADDRESS_FAMILY_Q2931             ((NDIS_AF)0x1)  // ATM
#define CO_ADDRESS_FAMILY_PSCHED            ((NDIS_AF)0x2)  // Packet scheduler
#define CO_ADDRESS_FAMILY_L2TP              ((NDIS_AF)0x3)
#define CO_ADDRESS_FAMILY_IRDA              ((NDIS_AF)0x4)
#define CO_ADDRESS_FAMILY_1394              ((NDIS_AF)0x5)
#define CO_ADDRESS_FAMILY_PPP               ((NDIS_AF)0x6)
#define CO_ADDRESS_FAMILY_INFINIBAND        ((NDIS_AF)0x7)
#define CO_ADDRESS_FAMILY_TAPI              ((NDIS_AF)0x800)
#define CO_ADDRESS_FAMILY_TAPI_PROXY        ((NDIS_AF)0x801)

//
// The following is OR'ed with the base AF to denote proxy support
//
#define CO_ADDRESS_FAMILY_PROXY             0x80000000


//
//  Address family structure registered/opened via
//      NdisCmRegisterAddressFamily
//      NdisClOpenAddressFamily
//
typedef struct
{
    NDIS_AF                     AddressFamily;  // one of the CO_ADDRESS_FAMILY_xxx values above
    ULONG                       MajorVersion;   // the major version of call manager
    ULONG                       MinorVersion;   // the minor version of call manager
} CO_ADDRESS_FAMILY, *PCO_ADDRESS_FAMILY;

//
// Definition for a SAP
//
typedef struct
{
    ULONG                       SapType;
    ULONG                       SapLength;
    UCHAR                       Sap[1];
} CO_SAP, *PCO_SAP;

//
// Definitions for physical address.
//

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;
typedef struct _NDIS_PHYSICAL_ADDRESS_UNIT
{
    NDIS_PHYSICAL_ADDRESS       PhysicalAddress;
    UINT                        Length;
} NDIS_PHYSICAL_ADDRESS_UNIT, *PNDIS_PHYSICAL_ADDRESS_UNIT;


/*++

ULONG
NdisGetPhysicalAddressHigh(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    );

--*/

#define NdisGetPhysicalAddressHigh(_PhysicalAddress)            \
        ((_PhysicalAddress).HighPart)

/*++

VOID
NdisSetPhysicalAddressHigh(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  ULONG                   Value
    );

--*/

#define NdisSetPhysicalAddressHigh(_PhysicalAddress, _Value)    \
     ((_PhysicalAddress).HighPart) = (_Value)


/*++

ULONG
NdisGetPhysicalAddressLow(
    IN  NDIS_PHYSICAL_ADDRESS PhysicalAddress
    );

--*/

#define NdisGetPhysicalAddressLow(_PhysicalAddress)             \
    ((_PhysicalAddress).LowPart)


/*++

VOID
NdisSetPhysicalAddressLow(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  ULONG                   Value
    );

--*/

#define NdisSetPhysicalAddressLow(_PhysicalAddress, _Value)     \
    ((_PhysicalAddress).LowPart) = (_Value)

//
// Macro to initialize an NDIS_PHYSICAL_ADDRESS constant
//

#define NDIS_PHYSICAL_ADDRESS_CONST(_Low, _High)                \
    { (ULONG)(_Low), (LONG)(_High) }


//
// block used for references...
//
typedef struct _REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    USHORT                      ReferenceCount;
    BOOLEAN                     Closing;
} REFERENCE, * PREFERENCE;

//
// block used for references using a ULONG
//
typedef struct _ULONG_REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    ULONG                       ReferenceCount;
    BOOLEAN                     Closing;
} ULONG_REFERENCE, *PULONG_REFERENCE;


//
// Types of Memory (not mutually exclusive)
//

#define NDIS_MEMORY_CONTIGUOUS      0x00000001
#define NDIS_MEMORY_NONCACHED       0x00000002

//
// Open options
//
#define NDIS_OPEN_RECEIVE_NOT_REENTRANT 0x00000001

//
// NDIS_STATUS values
//

#define NDIS_STATUS_SUCCESS                     ((NDIS_STATUS)STATUS_SUCCESS)
#define NDIS_STATUS_PENDING                     ((NDIS_STATUS) STATUS_PENDING)
#define NDIS_STATUS_NOT_RECOGNIZED              ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_COPIED                  ((NDIS_STATUS)0x00010002L)
#define NDIS_STATUS_NOT_ACCEPTED                ((NDIS_STATUS)0x00010003L)
#define NDIS_STATUS_CALL_ACTIVE                 ((NDIS_STATUS)0x00010007L)

#define NDIS_STATUS_ONLINE                      ((NDIS_STATUS)0x40010003L)
#define NDIS_STATUS_RESET_START                 ((NDIS_STATUS)0x40010004L)
#define NDIS_STATUS_RESET_END                   ((NDIS_STATUS)0x40010005L)
#define NDIS_STATUS_RING_STATUS                 ((NDIS_STATUS)0x40010006L)
#define NDIS_STATUS_CLOSED                      ((NDIS_STATUS)0x40010007L)
#define NDIS_STATUS_WAN_LINE_UP                 ((NDIS_STATUS)0x40010008L)
#define NDIS_STATUS_WAN_LINE_DOWN               ((NDIS_STATUS)0x40010009L)
#define NDIS_STATUS_WAN_FRAGMENT                ((NDIS_STATUS)0x4001000AL)
#define NDIS_STATUS_MEDIA_CONNECT               ((NDIS_STATUS)0x4001000BL)
#define NDIS_STATUS_MEDIA_DISCONNECT            ((NDIS_STATUS)0x4001000CL)
#define NDIS_STATUS_HARDWARE_LINE_UP            ((NDIS_STATUS)0x4001000DL)
#define NDIS_STATUS_HARDWARE_LINE_DOWN          ((NDIS_STATUS)0x4001000EL)
#define NDIS_STATUS_INTERFACE_UP                ((NDIS_STATUS)0x4001000FL)
#define NDIS_STATUS_INTERFACE_DOWN              ((NDIS_STATUS)0x40010010L)
#define NDIS_STATUS_MEDIA_BUSY                  ((NDIS_STATUS)0x40010011L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION   ((NDIS_STATUS)0x40010012L)
#define NDIS_STATUS_WW_INDICATION               NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define NDIS_STATUS_LINK_SPEED_CHANGE           ((NDIS_STATUS)0x40010013L)
#define NDIS_STATUS_WAN_GET_STATS               ((NDIS_STATUS)0x40010014L)
#define NDIS_STATUS_WAN_CO_FRAGMENT             ((NDIS_STATUS)0x40010015L)
#define NDIS_STATUS_WAN_CO_LINKPARAMS           ((NDIS_STATUS)0x40010016L)

#define NDIS_STATUS_NOT_RESETTABLE              ((NDIS_STATUS)0x80010001L)
#define NDIS_STATUS_SOFT_ERRORS                 ((NDIS_STATUS)0x80010003L)
#define NDIS_STATUS_HARD_ERRORS                 ((NDIS_STATUS)0x80010004L)
#define NDIS_STATUS_BUFFER_OVERFLOW             ((NDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define NDIS_STATUS_FAILURE                     ((NDIS_STATUS) STATUS_UNSUCCESSFUL)
#define NDIS_STATUS_RESOURCES                   ((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define NDIS_STATUS_CLOSING                     ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_BAD_VERSION                 ((NDIS_STATUS)0xC0010004L)
#define NDIS_STATUS_BAD_CHARACTERISTICS         ((NDIS_STATUS)0xC0010005L)
#define NDIS_STATUS_ADAPTER_NOT_FOUND           ((NDIS_STATUS)0xC0010006L)
#define NDIS_STATUS_OPEN_FAILED                 ((NDIS_STATUS)0xC0010007L)
#define NDIS_STATUS_DEVICE_FAILED               ((NDIS_STATUS)0xC0010008L)
#define NDIS_STATUS_MULTICAST_FULL              ((NDIS_STATUS)0xC0010009L)
#define NDIS_STATUS_MULTICAST_EXISTS            ((NDIS_STATUS)0xC001000AL)
#define NDIS_STATUS_MULTICAST_NOT_FOUND         ((NDIS_STATUS)0xC001000BL)
#define NDIS_STATUS_REQUEST_ABORTED             ((NDIS_STATUS)0xC001000CL)
#define NDIS_STATUS_RESET_IN_PROGRESS           ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING          ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_NOT_SUPPORTED               ((NDIS_STATUS)STATUS_NOT_SUPPORTED)
#define NDIS_STATUS_INVALID_PACKET              ((NDIS_STATUS)0xC001000FL)
#define NDIS_STATUS_OPEN_LIST_FULL              ((NDIS_STATUS)0xC0010010L)
#define NDIS_STATUS_ADAPTER_NOT_READY           ((NDIS_STATUS)0xC0010011L)
#define NDIS_STATUS_ADAPTER_NOT_OPEN            ((NDIS_STATUS)0xC0010012L)
#define NDIS_STATUS_NOT_INDICATING              ((NDIS_STATUS)0xC0010013L)
#define NDIS_STATUS_INVALID_LENGTH              ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA                ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT            ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID                 ((NDIS_STATUS)0xC0010017L)
#define NDIS_STATUS_ADAPTER_REMOVED             ((NDIS_STATUS)0xC0010018L)
#define NDIS_STATUS_UNSUPPORTED_MEDIA           ((NDIS_STATUS)0xC0010019L)
#define NDIS_STATUS_GROUP_ADDRESS_IN_USE        ((NDIS_STATUS)0xC001001AL)
#define NDIS_STATUS_FILE_NOT_FOUND              ((NDIS_STATUS)0xC001001BL)
#define NDIS_STATUS_ERROR_READING_FILE          ((NDIS_STATUS)0xC001001CL)
#define NDIS_STATUS_ALREADY_MAPPED              ((NDIS_STATUS)0xC001001DL)
#define NDIS_STATUS_RESOURCE_CONFLICT           ((NDIS_STATUS)0xC001001EL)
#define NDIS_STATUS_NO_CABLE                    ((NDIS_STATUS)0xC001001FL)

#define NDIS_STATUS_INVALID_SAP                 ((NDIS_STATUS)0xC0010020L)
#define NDIS_STATUS_SAP_IN_USE                  ((NDIS_STATUS)0xC0010021L)
#define NDIS_STATUS_INVALID_ADDRESS             ((NDIS_STATUS)0xC0010022L)
#define NDIS_STATUS_VC_NOT_ACTIVATED            ((NDIS_STATUS)0xC0010023L)
#define NDIS_STATUS_DEST_OUT_OF_ORDER           ((NDIS_STATUS)0xC0010024L)  // cause 27
#define NDIS_STATUS_VC_NOT_AVAILABLE            ((NDIS_STATUS)0xC0010025L)  // cause 35,45
#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE      ((NDIS_STATUS)0xC0010026L)  // cause 37
#define NDIS_STATUS_INCOMPATABLE_QOS            ((NDIS_STATUS)0xC0010027L)  // cause 49
#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED      ((NDIS_STATUS)0xC0010028L)  // cause 93
#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION     ((NDIS_STATUS)0xC0010029L)  // cause 3

#define NDIS_STATUS_TOKEN_RING_OPEN_ERROR       ((NDIS_STATUS)0xC0011000L)
#define NDIS_STATUS_INVALID_DEVICE_REQUEST      ((NDIS_STATUS)STATUS_INVALID_DEVICE_REQUEST)
#define NDIS_STATUS_NETWORK_UNREACHABLE         ((NDIS_STATUS)STATUS_NETWORK_UNREACHABLE)


//
// used in error logging
//

#define NDIS_ERROR_CODE ULONG

#define NDIS_ERROR_CODE_RESOURCE_CONFLICT           EVENT_NDIS_RESOURCE_CONFLICT
#define NDIS_ERROR_CODE_OUT_OF_RESOURCES            EVENT_NDIS_OUT_OF_RESOURCE
#define NDIS_ERROR_CODE_HARDWARE_FAILURE            EVENT_NDIS_HARDWARE_FAILURE
#define NDIS_ERROR_CODE_ADAPTER_NOT_FOUND           EVENT_NDIS_ADAPTER_NOT_FOUND
#define NDIS_ERROR_CODE_INTERRUPT_CONNECT           EVENT_NDIS_INTERRUPT_CONNECT
#define NDIS_ERROR_CODE_DRIVER_FAILURE              EVENT_NDIS_DRIVER_FAILURE
#define NDIS_ERROR_CODE_BAD_VERSION                 EVENT_NDIS_BAD_VERSION
#define NDIS_ERROR_CODE_TIMEOUT                     EVENT_NDIS_TIMEOUT
#define NDIS_ERROR_CODE_NETWORK_ADDRESS             EVENT_NDIS_NETWORK_ADDRESS
#define NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION   EVENT_NDIS_UNSUPPORTED_CONFIGURATION
#define NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER  EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
#define NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
#define NDIS_ERROR_CODE_BAD_IO_BASE_ADDRESS         EVENT_NDIS_BAD_IO_BASE_ADDRESS
#define NDIS_ERROR_CODE_RECEIVE_SPACE_SMALL         EVENT_NDIS_RECEIVE_SPACE_SMALL
#define NDIS_ERROR_CODE_ADAPTER_DISABLED            EVENT_NDIS_ADAPTER_DISABLED

#if BINARY_COMPATIBLE

#if USE_KLOCKS

#define DISPATCH_LEVEL      2

#define NdisAllocateSpinLock(_SpinLock) KeInitializeSpinLock(&(_SpinLock)->SpinLock)

#define NdisFreeSpinLock(_SpinLock)

#define NdisAcquireSpinLock(_SpinLock)  KeAcquireSpinLock(&(_SpinLock)->SpinLock, &(_SpinLock)->OldIrql)

#define NdisReleaseSpinLock(_SpinLock)  KeReleaseSpinLock(&(_SpinLock)->SpinLock,(_SpinLock)->OldIrql)

#define NdisDprAcquireSpinLock(_SpinLock)                       \
{                                                               \
    KeAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);        \
    (_SpinLock)->OldIrql = DISPATCH_LEVEL;                      \
}

#define NdisDprReleaseSpinLock(_SpinLock) KeReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock)

#else

//
// Ndis Spin Locks
//
EXPORT
VOID
NdisAllocateSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisFreeSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisDprAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisDprReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

#endif


EXPORT
VOID
NdisGetCurrentSystemTime(
    PLARGE_INTEGER              pSystemTime
    );

//
// Interlocked support functions
//

EXPORT
LONG
NdisInterlockedIncrement(
    IN  PLONG                   Addend
    );

EXPORT
LONG
NdisInterlockedDecrement(
    IN  PLONG                   Addend
    );

EXPORT
VOID
NdisInterlockedAddUlong(
    IN  PULONG                  Addend,
    IN  ULONG                   Increment,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
PLIST_ENTRY
NdisInterlockedInsertHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );


EXPORT
PLIST_ENTRY
NdisInterlockedInsertTailList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );


EXPORT
PLIST_ENTRY
NdisInterlockedRemoveHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
LARGE_INTEGER
NdisInterlockedAddLargeInteger(
    IN  PLARGE_INTEGER          Addend,
    IN  ULONG                   Increment,
    IN  PKSPIN_LOCK             Lock
    );

#else // BINARY_COMPATIBLE

#define NdisAllocateSpinLock(_SpinLock) KeInitializeSpinLock(&(_SpinLock)->SpinLock)

#define NdisFreeSpinLock(_SpinLock)

#define NdisAcquireSpinLock(_SpinLock)  KeAcquireSpinLock(&(_SpinLock)->SpinLock, &(_SpinLock)->OldIrql)

#define NdisReleaseSpinLock(_SpinLock)  KeReleaseSpinLock(&(_SpinLock)->SpinLock,(_SpinLock)->OldIrql)

#define NdisDprAcquireSpinLock(_SpinLock)                                   \
{                                                                           \
    KeAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);                    \
    (_SpinLock)->OldIrql = DISPATCH_LEVEL;                                  \
}

#define NdisDprReleaseSpinLock(_SpinLock) KeReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock)

#define NdisGetCurrentSystemTime(_pSystemTime)                              \
    {                                                                       \
        KeQuerySystemTime(_pSystemTime);                                    \
    }

//
// Interlocked support functions
//

#define NdisInterlockedIncrement(Addend)    InterlockedIncrement(Addend)

#define NdisInterlockedDecrement(Addend)    InterlockedDecrement(Addend)

#define NdisInterlockedAddUlong(_Addend, _Increment, _SpinLock) \
    ExInterlockedAddUlong(_Addend, _Increment, &(_SpinLock)->SpinLock)

#define NdisInterlockedInsertHeadList(_ListHead, _ListEntry, _SpinLock) \
    ExInterlockedInsertHeadList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

#define NdisInterlockedInsertTailList(_ListHead, _ListEntry, _SpinLock) \
    ExInterlockedInsertTailList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

#define NdisInterlockedRemoveHeadList(_ListHead, _SpinLock) \
    ExInterlockedRemoveHeadList(_ListHead, &(_SpinLock)->SpinLock)

#define NdisInterlockedPushEntryList(ListHead, ListEntry, Lock) \
    ExInterlockedPushEntryList(ListHead, ListEntry, &(Lock)->SpinLock)

#define NdisInterlockedPopEntryList(ListHead, Lock) \
    ExInterlockedPopEntryList(ListHead, &(Lock)->SpinLock)

#endif // BINARY_COMPATIBLE

#ifndef MAXIMUM_PROCESSORS
#ifdef _WIN64
#define MAXIMUM_PROCESSORS 64
#else
#define MAXIMUM_PROCESSORS 32
#endif
#endif

typedef union _NDIS_RW_LOCK_REFCOUNT
{
    UINT                        RefCount;
    UCHAR                       cacheLine[16];  // One refCount per cache line
} NDIS_RW_LOCK_REFCOUNT;

typedef struct _NDIS_RW_LOCK
{
    union
    {
        struct
        {
            KSPIN_LOCK          SpinLock;
            PVOID               Context;
        };
        UCHAR                   Reserved[16];
    };

    NDIS_RW_LOCK_REFCOUNT       RefCount[MAXIMUM_PROCESSORS];
} NDIS_RW_LOCK, *PNDIS_RW_LOCK;

typedef struct _LOCK_STATE
{
    USHORT                      LockState;
    KIRQL                       OldIrql;
} LOCK_STATE, *PLOCK_STATE;


EXPORT
VOID
NdisInitializeReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock
    );


EXPORT
VOID
NdisAcquireReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  BOOLEAN                 fWrite,         // TRUE -> Write, FALSE -> Read
    IN  PLOCK_STATE             LockState
    );


EXPORT
VOID
NdisReleaseReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  PLOCK_STATE             LockState
    );


#define NdisInterlockedAddLargeStatistic(_Addend, _Increment)   \
    ExInterlockedAddLargeStatistic((PLARGE_INTEGER)_Addend, _Increment)

//
// S-List support
//

#define NdisInterlockedPushEntrySList(SListHead, SListEntry, Lock) \
    ExInterlockedPushEntrySList(SListHead, SListEntry, &(Lock)->SpinLock)

#define NdisInterlockedPopEntrySList(SListHead, Lock) \
    ExInterlockedPopEntrySList(SListHead, &(Lock)->SpinLock)

#define NdisInterlockedFlushSList(SListHead) ExInterlockedFlushSList(SListHead)

#define NdisInitializeSListHead(SListHead)  ExInitializeSListHead(SListHead)

#define NdisQueryDepthSList(SListHead)  ExQueryDepthSList(SListHead)

EXPORT
VOID
NdisGetCurrentProcessorCpuUsage(
    OUT PULONG                  pCpuUsage
    );

EXPORT
VOID
NdisGetCurrentProcessorCounts(
    OUT PULONG                  pIdleCount,
    OUT PULONG                  pKernelAndUser,
    OUT PULONG                  pIndex
    );

EXPORT
VOID
NdisGetSystemUpTime(
    OUT PULONG                  pSystemUpTime
    );

//
// List manipulation
//

/*++

VOID
NdisInitializeListHead(
    IN  PLIST_ENTRY ListHead
    );

--*/
#define NdisInitializeListHead(_ListHead) InitializeListHead(_ListHead)


//
// Configuration Requests
//

EXPORT
VOID
NdisOpenConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

EXPORT
VOID
NdisOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle
    );

EXPORT
VOID
NdisOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle
    );

EXPORT
VOID
NdisReadConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_CONFIGURATION_PARAMETER *ParameterValue,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            Keyword,
    IN  NDIS_PARAMETER_TYPE     ParameterType
    );

EXPORT
VOID
NdisWriteConfiguration(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            Keyword,
    IN  PNDIS_CONFIGURATION_PARAMETER ParameterValue
    );

EXPORT
VOID
NdisCloseConfiguration(
    IN  NDIS_HANDLE             ConfigurationHandle
    );

EXPORT
VOID
NdisReadNetworkAddress(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 NetworkAddress,
    OUT PUINT                   NetworkAddressLength,
    IN  NDIS_HANDLE             ConfigurationHandle
    );

EXPORT
VOID
NdisReadEisaSlotInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION EisaData
    );

EXPORT
VOID
NdisReadEisaSlotInformationEx(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION *EisaData,
    OUT PUINT                   NumberOfFunctions
    );

EXPORT
ULONG
NdisReadPciSlotInformation(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisWritePciSlotInformation(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisReadPcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    );

EXPORT
ULONG
NdisWritePcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    );

//
// Buffer Pool
//

EXPORT
VOID
NdisAllocateBufferPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors
    );

EXPORT
VOID
NdisFreeBufferPool(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    );

EXPORT
VOID
NdisCopyBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   MemoryDescriptor,
    IN  UINT                    Offset,
    IN  UINT                    Length
    );


//
//  VOID
//  NdisCopyLookaheadData(
//      IN  PVOID               Destination,
//      IN  PVOID               Source,
//      IN  ULONG               Length,
//      IN  ULONG               ReceiveFlags
//      );
//

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisCopyLookaheadData(_Destination, _Source, _Length, _MacOptions)  \
        RtlCopyMemory(_Destination, _Source, _Length)
#else
#define NdisCopyLookaheadData(_Destination, _Source, _Length, _MacOptions)  \
    {                                                                       \
        if ((_MacOptions) & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA)            \
        {                                                                   \
            RtlCopyMemory(_Destination, _Source, _Length);                  \
        }                                                                   \
        else                                                                \
        {                                                                   \
            PUCHAR _Src = (PUCHAR)(_Source);                                \
            PUCHAR _Dest = (PUCHAR)(_Destination);                          \
            PUCHAR _End = _Dest + (_Length);                                \
            while (_Dest < _End)                                            \
            {                                                               \
                *_Dest++ = *_Src++;                                         \
            }                                                               \
        }                                                                   \
    }
#endif

//
// Packet Pool
//
EXPORT
VOID
NdisAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

EXPORT
VOID
NdisAllocatePacketPoolEx(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

EXPORT
VOID
NdisSetPacketPoolProtocolId(
    IN  NDIS_HANDLE             PacketPoolHandle,
    IN  UINT                    ProtocolId
    );

EXPORT
UINT
NdisPacketPoolUsage(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
UINT
NdisPacketSize(
    IN  UINT                    ProtocolReservedSize
    );

EXPORT
NDIS_HANDLE
NdisGetPoolFromPacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
PNDIS_PACKET_STACK
NdisIMGetCurrentPacketStack(
    IN  PNDIS_PACKET            Packet,
    OUT BOOLEAN *               StacksRemaining
    );

EXPORT
VOID
NdisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisFreePacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
VOID
NdisDprFreePacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
VOID
NdisDprFreePacketNonInterlocked(
    IN  PNDIS_PACKET            Packet
    );


EXPORT
VOID
NdisAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisDprAllocatePacketNonInterlocked(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

// VOID
// NdisReinitializePacket(
//  IN OUT PNDIS_PACKET         Packet
//  );
#define NdisReinitializePacket(Packet)                                      \
{                                                                           \
    (Packet)->Private.Head = (PNDIS_BUFFER)NULL;                            \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}


//
// Block Pool APIs
//
typedef
VOID
(__stdcall *NDIS_BLOCK_INITIALIZER) (
    IN  PUCHAR                  Block,
    IN  SIZE_T                  NumberOfBytes
    );

NDIS_HANDLE
NdisCreateBlockPool(
    IN  USHORT                  BlockSize,
    IN  USHORT                  FreeBlockLinkOffset,
    IN  ULONG                   Tag,
    IN  NDIS_BLOCK_INITIALIZER  InitFunction OPTIONAL
    );

VOID
NdisDestroyBlockPool(
    IN  NDIS_HANDLE             BlockPoolHandle
    );

PUCHAR
NdisAllocateFromBlockPool(
    IN  NDIS_HANDLE             BlockPoolHandle
    );

VOID
NdisFreeToBlockPool(
    IN  PUCHAR                  Block
    );

#if BINARY_COMPATIBLE

EXPORT
VOID
NdisFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    );

EXPORT
VOID
NdisQueryBuffer(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length
    );

EXPORT
VOID
NdisQueryBufferSafe(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length,
    IN  MM_PAGE_PRIORITY        Priority
    );

EXPORT
VOID
NdisQueryBufferOffset(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   Offset,
    OUT PUINT                   Length
    );

//
// This is a combination of NdisQueryPacket and NdisQueryBuffer and
// optimized for protocols to get the first Buffer, its VA and its size.
//
VOID
NdisGetFirstBufferFromPacket(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength
    );

VOID
NdisGetFirstBufferFromPacketSafe(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength,
    IN  MM_PAGE_PRIORITY        Priority
    );


//
// This is used to determine how many physical pieces
// an NDIS_BUFFER will take up when mapped.
//

EXPORT
ULONG
NDIS_BUFFER_TO_SPAN_PAGES(
    IN  PNDIS_BUFFER                Buffer
    );

EXPORT
VOID
NdisGetBufferPhysicalArraySize(
    IN  PNDIS_BUFFER                Buffer,
    OUT PUINT                       ArraySize
    );

#else // BINARY_COMPATIBLE

#define NdisFreeBuffer(Buffer)  IoFreeMdl(Buffer)

#define NdisQueryBuffer(_Buffer, _VirtualAddress, _Length)                  \
{                                                                           \
    if (ARGUMENT_PRESENT(_VirtualAddress))                                  \
    {                                                                       \
        *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdl(_Buffer);    \
    }                                                                       \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}

#define NdisQueryBufferSafe(_Buffer, _VirtualAddress, _Length, _Priority)   \
{                                                                           \
    if (ARGUMENT_PRESENT(_VirtualAddress))                                  \
    {                                                                       \
        *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdlSafe(_Buffer, _Priority); \
    }                                                                       \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}

#define NdisQueryBufferOffset(_Buffer, _Offset, _Length)                    \
{                                                                           \
    *(_Offset) = MmGetMdlByteOffset(_Buffer);                               \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}


#define NdisGetFirstBufferFromPacket(_Packet,                               \
                                     _FirstBuffer,                          \
                                     _FirstBufferVA,                        \
                                     _FirstBufferLength,                    \
                                     _TotalBufferLength)                    \
    {                                                                       \
        PNDIS_BUFFER    _pBuf;                                              \
                                                                            \
        _pBuf = (_Packet)->Private.Head;                                    \
        *(_FirstBuffer) = _pBuf;                                            \
        if (_pBuf)                                                          \
        {                                                                   \
            *(_FirstBufferVA) = MmGetSystemAddressForMdl(_pBuf);            \
            *(_FirstBufferLength) =                                         \
            *(_TotalBufferLength) = MmGetMdlByteCount(_pBuf);               \
            for (_pBuf = _pBuf->Next;                                       \
                 _pBuf != NULL;                                             \
                 _pBuf = _pBuf->Next)                                       \
            {                                                               \
                *(_TotalBufferLength) += MmGetMdlByteCount(_pBuf);          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            *(_FirstBufferVA) = 0;                                          \
            *(_FirstBufferLength) = 0;                                      \
            *(_TotalBufferLength) = 0;                                      \
        }                                                                   \
    }

#define NdisGetFirstBufferFromPacketSafe(_Packet,                           \
                                         _FirstBuffer,                      \
                                         _FirstBufferVA,                    \
                                         _FirstBufferLength,                \
                                         _TotalBufferLength,                \
                                         _Priority)                         \
    {                                                                       \
        PNDIS_BUFFER    _pBuf;                                              \
                                                                            \
        _pBuf = (_Packet)->Private.Head;                                    \
        *(_FirstBuffer) = _pBuf;                                            \
        if (_pBuf)                                                          \
        {                                                                   \
            *(_FirstBufferVA) = MmGetSystemAddressForMdlSafe(_pBuf, _Priority); \
            *(_FirstBufferLength) = *(_TotalBufferLength) = MmGetMdlByteCount(_pBuf); \
            for (_pBuf = _pBuf->Next;                                       \
                 _pBuf != NULL;                                             \
                 _pBuf = _pBuf->Next)                                       \
            {                                                               \
                *(_TotalBufferLength) += MmGetMdlByteCount(_pBuf);          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            *(_FirstBufferVA) = 0;                                          \
            *(_FirstBufferLength) = 0;                                      \
            *(_TotalBufferLength) = 0;                                      \
        }                                                                   \
    }


#define NDIS_BUFFER_TO_SPAN_PAGES(_Buffer)                                  \
    (MmGetMdlByteCount(_Buffer)==0 ?                                        \
                1 :                                                         \
                (ADDRESS_AND_SIZE_TO_SPAN_PAGES(                            \
                        MmGetMdlVirtualAddress(_Buffer),                    \
                        MmGetMdlByteCount(_Buffer))))

#define NdisGetBufferPhysicalArraySize(Buffer, ArraySize)                   \
    (*(ArraySize) = NDIS_BUFFER_TO_SPAN_PAGES(Buffer))

#endif // BINARY_COMPATIBLE


/*++

NDIS_BUFFER_LINKAGE(
    IN  PNDIS_BUFFER            Buffer
    );

--*/

#define NDIS_BUFFER_LINKAGE(Buffer) ((Buffer)->Next)


/*++

VOID
NdisRecalculatePacketCounts(
    IN OUT PNDIS_PACKET         Packet
    );

--*/

#define NdisRecalculatePacketCounts(Packet)                                 \
{                                                                           \
    {                                                                       \
        PNDIS_BUFFER TmpBuffer = (Packet)->Private.Head;                    \
        if (TmpBuffer)                                                      \
        {                                                                   \
            while (TmpBuffer->Next)                                         \
            {                                                               \
                TmpBuffer = TmpBuffer->Next;                                \
            }                                                               \
            (Packet)->Private.Tail = TmpBuffer;                             \
        }                                                                   \
        (Packet)->Private.ValidCounts = FALSE;                              \
    }                                                                       \
}


/*++

VOID
NdisChainBufferAtFront(
    IN OUT PNDIS_PACKET         Packet,
    IN OUT PNDIS_BUFFER         Buffer
    );

--*/

#define NdisChainBufferAtFront(Packet, Buffer)                              \
{                                                                           \
    PNDIS_BUFFER TmpBuffer = (Buffer);                                      \
                                                                            \
    for (;;)                                                                \
    {                                                                       \
        if (TmpBuffer->Next == (PNDIS_BUFFER)NULL)                          \
            break;                                                          \
        TmpBuffer = TmpBuffer->Next;                                        \
    }                                                                       \
    if ((Packet)->Private.Head == NULL)                                     \
    {                                                                       \
        (Packet)->Private.Tail = TmpBuffer;                                 \
    }                                                                       \
    TmpBuffer->Next = (Packet)->Private.Head;                               \
    (Packet)->Private.Head = (Buffer);                                      \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}

/*++

VOID
NdisChainBufferAtBack(
    IN OUT PNDIS_PACKET         Packet,
    IN OUT PNDIS_BUFFER         Buffer
    );

--*/

#define NdisChainBufferAtBack(Packet, Buffer)                               \
{                                                                           \
    PNDIS_BUFFER TmpBuffer = (Buffer);                                      \
                                                                            \
    for (;;)                                                                \
    {                                                                       \
        if (TmpBuffer->Next == NULL)                                        \
            break;                                                          \
        TmpBuffer = TmpBuffer->Next;                                        \
    }                                                                       \
    if ((Packet)->Private.Head != NULL)                                     \
    {                                                                       \
        (Packet)->Private.Tail->Next = (Buffer);                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        (Packet)->Private.Head = (Buffer);                                  \
    }                                                                       \
    (Packet)->Private.Tail = TmpBuffer;                                     \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}

EXPORT
VOID
NdisUnchainBufferAtFront(
    IN OUT PNDIS_PACKET         Packet,
    OUT PNDIS_BUFFER *          Buffer
    );

EXPORT
VOID
NdisUnchainBufferAtBack(
    IN OUT PNDIS_PACKET         Packet,
    OUT PNDIS_BUFFER *          Buffer
    );


/*++

VOID
NdisQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );

--*/

#pragma warning(push)
#pragma warning(disable:4127)
__inline
VOID
NdisQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    )
{                                                                           
    if ((_FirstBuffer) != NULL)                                             
    {                                                                       
        PNDIS_BUFFER * __FirstBuffer = (_FirstBuffer);                      
        *(__FirstBuffer) = (_Packet)->Private.Head;                         
    }                                                                       
    if ((_TotalPacketLength) || (_BufferCount) || (_PhysicalBufferCount))   
    {                                                                       
        if (!(_Packet)->Private.ValidCounts)                                
        {                                                                   
            PNDIS_BUFFER TmpBuffer = (_Packet)->Private.Head;               
            UINT PTotalLength = 0, PPhysicalCount = 0, PAddedCount = 0;     
            UINT PacketLength, Offset;                                      
                                                                            
            while (TmpBuffer != (PNDIS_BUFFER)NULL)                         
            {                                                               
                NdisQueryBufferOffset(TmpBuffer, &Offset, &PacketLength);   
                PTotalLength += PacketLength;                               
                PPhysicalCount += (UINT)NDIS_BUFFER_TO_SPAN_PAGES(TmpBuffer);
                ++PAddedCount;                                              
                TmpBuffer = TmpBuffer->Next;                                
            }                                                               
            (_Packet)->Private.Count = PAddedCount;                         
            (_Packet)->Private.TotalLength = PTotalLength;                  
            (_Packet)->Private.PhysicalCount = PPhysicalCount;              
            (_Packet)->Private.ValidCounts = TRUE;                          
        }                                                                   
                                                                            
        if (_PhysicalBufferCount)                                           
        {                                                                   
            PUINT __PhysicalBufferCount = (_PhysicalBufferCount);           
            *(__PhysicalBufferCount) = (_Packet)->Private.PhysicalCount;    
        }                                                                   
        if (_BufferCount)                                                   
        {                                                                   
            PUINT __BufferCount = (_BufferCount);                           
            *(__BufferCount) = (_Packet)->Private.Count;                    
        }                                                                   
        if (_TotalPacketLength)                                             
        {                                                                   
            PUINT __TotalPacketLength = (_TotalPacketLength);               
            *(__TotalPacketLength) = (_Packet)->Private.TotalLength;        
        }                                                                   
    }                                                                       
}
#pragma warning(pop)

/*++

VOID
NdisQueryPacketLength(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );

--*/

#define NdisQueryPacketLength(_Packet,                                      \
                              _TotalPacketLength)                           \
{                                                                           \
    if (!(_Packet)->Private.ValidCounts)                                    \
    {                                                                       \
        NdisQueryPacket(_Packet, NULL, NULL, NULL, _TotalPacketLength);     \
    }                                                                       \
    else *(_TotalPacketLength) = (_Packet)->Private.TotalLength;            \
}


/*++

VOID
NdisGetNextBuffer(
    IN  PNDIS_BUFFER            CurrentBuffer,
    OUT PNDIS_BUFFER *          NextBuffer
    );

--*/

#define NdisGetNextBuffer(CurrentBuffer, NextBuffer)                        \
{                                                                           \
    *(NextBuffer) = (CurrentBuffer)->Next;                                  \
}

#if BINARY_COMPATIBLE

VOID
NdisAdjustBufferLength(
    IN  PNDIS_BUFFER            Buffer,
    IN  UINT                    Length
    );

#else // BINARY_COMPATIBLE

#define NdisAdjustBufferLength(Buffer, Length)  (((Buffer)->ByteCount) = (Length))

#endif // BINARY_COMPATIBLE

EXPORT
VOID
NdisCopyFromPacketToPacket(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied
    );

EXPORT
VOID
NdisCopyFromPacketToPacketSafe(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied,
    IN  MM_PAGE_PRIORITY        Priority
    );

EXPORT
NDIS_STATUS
NdisAllocateMemory(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    );

EXPORT
NDIS_STATUS
NdisAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    );

EXPORT
VOID
NdisFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    );


/*++
VOID
NdisStallExecution(
    IN  UINT                    MicrosecondsToStall
    )
--*/

#define NdisStallExecution(MicroSecondsToStall)     KeStallExecutionProcessor(MicroSecondsToStall)


EXPORT
VOID
NdisInitializeEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
VOID
NdisSetEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
VOID
NdisResetEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
BOOLEAN
NdisWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
);

/*++
VOID
NdisInitializeWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context
    );
--*/

#define NdisInitializeWorkItem(_WI_, _R_, _C_)  \
    {                                           \
        (_WI_)->Context = _C_;                  \
        (_WI_)->Routine = _R_;                  \
    }

EXPORT
NDIS_STATUS
NdisScheduleWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem
    );

//
// Simple I/O support
//

EXPORT
VOID
NdisOpenFile(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            FileHandle,
    OUT PUINT                   FileLength,
    IN  PNDIS_STRING            FileName,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    );

EXPORT
VOID
NdisCloseFile(
    IN  NDIS_HANDLE             FileHandle
    );

EXPORT
VOID
NdisMapFile(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 MappedBuffer,
    IN  NDIS_HANDLE             FileHandle
    );

EXPORT
VOID
NdisUnmapFile(
    IN  NDIS_HANDLE             FileHandle
    );


//
// Portability extensions
//

/*++
VOID
NdisFlushBuffer(
    IN  PNDIS_BUFFER            Buffer,
    IN  BOOLEAN                 WriteToDevice
    )
--*/

#define NdisFlushBuffer(Buffer,WriteToDevice)                               \
        KeFlushIoBuffers((Buffer),!(WriteToDevice), TRUE)

EXPORT
ULONG
NdisGetSharedDataAlignment(
    VOID
    );


//
// Write Port
//

/*++
VOID
NdisWritePortUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    )
--*/
#define NdisWritePortUchar(Handle,Port,Data)                                \
        WRITE_PORT_UCHAR((PUCHAR)(NDIS_PORT_TO_PORT(Handle,Port)),(UCHAR)(Data))

/*++
VOID
NdisWritePortUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    )
--*/
#define NdisWritePortUshort(Handle,Port,Data)                               \
        WRITE_PORT_USHORT((PUSHORT)(NDIS_PORT_TO_PORT(Handle,Port)),(USHORT)(Data))


/*++
VOID
NdisWritePortUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    )
--*/
#define NdisWritePortUlong(Handle,Port,Data)                                \
        WRITE_PORT_ULONG((PULONG)(NDIS_PORT_TO_PORT(Handle,Port)),(ULONG)(Data))


//
// Write Port Buffers
//

/*++
VOID
NdisWritePortBufferUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUchar(Handle,Port,Buffer,Length)                 \
        NdisRawWritePortBufferUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisWritePortBufferUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUshort(Handle,Port,Buffer,Length)                \
        NdisRawWritePortBufferUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))


/*++
VOID
NdisWritePortBufferUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUlong(Handle,Port,Buffer,Length)                 \
        NdisRawWritePortBufferUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))


//
// Read Ports
//

/*++
VOID
NdisReadPortUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    )
--*/
#define NdisReadPortUchar(Handle,Port, Data)                                \
        NdisRawReadPortUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))

/*++
VOID
NdisReadPortUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUSHORT                 Data
    )
--*/
#define NdisReadPortUshort(Handle,Port,Data)                                \
        NdisRawReadPortUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))


/*++
VOID
NdisReadPortUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PULONG                  Data
    )
--*/
#define NdisReadPortUlong(Handle,Port,Data)                                 \
        NdisRawReadPortUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))

//
// Read Buffer Ports
//

/*++
VOID
NdisReadPortBufferUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUchar(Handle,Port,Buffer,Length)                  \
        NdisRawReadPortBufferUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisReadPortBufferUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUshort(Handle,Port,Buffer,Length)                 \
        NdisRawReadPortBufferUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisReadPortBufferUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUlong(Handle,Port,Buffer)                         \
        NdisRawReadPortBufferUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

//
// Raw Routines
//

//
// Write Port Raw
//

/*++
VOID
NdisRawWritePortUchar(
    IN  ULONG_PTR               Port,
    IN  UCHAR                   Data
    )
--*/
#define NdisRawWritePortUchar(Port,Data)                                    \
        WRITE_PORT_UCHAR((PUCHAR)(Port),(UCHAR)(Data))

/*++
VOID
NdisRawWritePortUshort(
    IN  ULONG_PTR               Port,
    IN  USHORT                  Data
    )
--*/
#define NdisRawWritePortUshort(Port,Data)                                   \
        WRITE_PORT_USHORT((PUSHORT)(Port),(USHORT)(Data))

/*++
VOID
NdisRawWritePortUlong(
    IN  ULONG_PTR               Port,
    IN  ULONG                   Data
    )
--*/
#define NdisRawWritePortUlong(Port,Data)                                    \
        WRITE_PORT_ULONG((PULONG)(Port),(ULONG)(Data))


//
// Raw Write Port Buffers
//

/*++
VOID
NdisRawWritePortBufferUchar(
    IN  ULONG_PTR               Port,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisRawWritePortBufferUchar(Port,Buffer,Length) \
        WRITE_PORT_BUFFER_UCHAR((PUCHAR)(Port),(PUCHAR)(Buffer),(Length))

/*++
VOID
NdisRawWritePortBufferUshort(
    IN  ULONG_PTR               Port,
    IN  PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawWritePortBufferUshort(Port,Buffer,Length)                    \
        WRITE_PORT_BUFFER_USHORT((PUSHORT)(Port),(PUSHORT)(Buffer),(Length))
#else
#define NdisRawWritePortBufferUshort(Port,Buffer,Length)                    \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PUSHORT _Current = (Buffer);                                        \
        PUSHORT _End = _Current + (Length);                                 \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            WRITE_PORT_USHORT((PUSHORT)_Port,*(UNALIGNED USHORT *)_Current);\
        }                                                                   \
}
#endif


/*++
VOID
NdisRawWritePortBufferUlong(
    IN  ULONG_PTR               Port,
    IN  PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawWritePortBufferUlong(Port,Buffer,Length)                     \
        WRITE_PORT_BUFFER_ULONG((PULONG)(Port),(PULONG)(Buffer),(Length))
#else
#define NdisRawWritePortBufferUlong(Port,Buffer,Length)                     \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PULONG _Current = (Buffer);                                         \
        PULONG _End = _Current + (Length);                                  \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            WRITE_PORT_ULONG((PULONG)_Port,*(UNALIGNED ULONG *)_Current);   \
        }                                                                   \
}
#endif


//
// Raw Read Ports
//

/*++
VOID
NdisRawReadPortUchar(
    IN  ULONG_PTR               Port,
    OUT PUCHAR                  Data
    )
--*/
#define NdisRawReadPortUchar(Port, Data) \
        *(Data) = READ_PORT_UCHAR((PUCHAR)(Port))

/*++
VOID
NdisRawReadPortUshort(
    IN  ULONG_PTR               Port,
    OUT PUSHORT                 Data
    )
--*/
#define NdisRawReadPortUshort(Port,Data) \
        *(Data) = READ_PORT_USHORT((PUSHORT)(Port))

/*++
VOID
NdisRawReadPortUlong(
    IN  ULONG_PTR               Port,
    OUT PULONG                  Data
    )
--*/
#define NdisRawReadPortUlong(Port,Data) \
        *(Data) = READ_PORT_ULONG((PULONG)(Port))


//
// Raw Read Buffer Ports
//

/*++
VOID
NdisRawReadPortBufferUchar(
    IN  ULONG_PTR               Port,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisRawReadPortBufferUchar(Port,Buffer,Length)                      \
        READ_PORT_BUFFER_UCHAR((PUCHAR)(Port),(PUCHAR)(Buffer),(Length))


/*++
VOID
NdisRawReadPortBufferUshort(
    IN  ULONG_PTR               Port,
    OUT PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawReadPortBufferUshort(Port,Buffer,Length)                     \
        READ_PORT_BUFFER_USHORT((PUSHORT)(Port),(PUSHORT)(Buffer),(Length))
#else
#define NdisRawReadPortBufferUshort(Port,Buffer,Length)                     \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PUSHORT _Current = (Buffer);                                        \
        PUSHORT _End = _Current + (Length);                                 \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            *(UNALIGNED USHORT *)_Current = READ_PORT_USHORT((PUSHORT)_Port); \
        }                                                                   \
}
#endif


/*++
VOID
NdisRawReadPortBufferUlong(
    IN  ULONG_PTR               Port,
    OUT PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawReadPortBufferUlong(Port,Buffer,Length)                      \
        READ_PORT_BUFFER_ULONG((PULONG)(Port),(PULONG)(Buffer),(Length))
#else
#define NdisRawReadPortBufferUlong(Port,Buffer,Length)                      \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PULONG _Current = (Buffer);                                         \
        PULONG _End = _Current + (Length);                                  \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            *(UNALIGNED ULONG *)_Current = READ_PORT_ULONG((PULONG)_Port);  \
        }                                                                   \
}
#endif


//
// Write Registers
//

/*++
VOID
NdisWriteRegisterUchar(
    IN  PUCHAR                  Register,
    IN  UCHAR                   Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUchar(Register,Data)                               \
        WRITE_REGISTER_UCHAR((Register),(Data))
#else
#define NdisWriteRegisterUchar(Register,Data)                               \
    {                                                                       \
        WRITE_REGISTER_UCHAR((Register),(Data));                            \
        READ_REGISTER_UCHAR(Register);                                      \
    }
#endif

/*++
VOID
NdisWriteRegisterUshort(
    IN  PUCHAR                  Register,
    IN  USHORT                  Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUshort(Register,Data)                              \
        WRITE_REGISTER_USHORT((Register),(Data))
#else
#define NdisWriteRegisterUshort(Register,Data)                              \
    {                                                                       \
        WRITE_REGISTER_USHORT((Register),(Data));                           \
        READ_REGISTER_USHORT(Register);                                     \
    }
#endif

/*++
VOID
NdisWriteRegisterUlong(
    IN  PUCHAR                  Register,
    IN  ULONG                   Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUlong(Register,Data)   WRITE_REGISTER_ULONG((Register),(Data))
#else
#define NdisWriteRegisterUlong(Register,Data)                               \
    {                                                                       \
        WRITE_REGISTER_ULONG((Register),(Data));                            \
        READ_REGISTER_ULONG(Register);                                      \
    }
#endif

/*++
VOID
NdisReadRegisterUchar(
    IN  PUCHAR                  Register,
    OUT PUCHAR                  Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUchar(Register,Data)    *(Data) = *((volatile UCHAR * const)(Register))
#else
#define NdisReadRegisterUchar(Register,Data)    *(Data) = READ_REGISTER_UCHAR((PUCHAR)(Register))
#endif

/*++
VOID
NdisReadRegisterUshort(
    IN  PUSHORT                 Register,
    OUT PUSHORT                 Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUshort(Register,Data)   *(Data) = *((volatile USHORT * const)(Register))
#else
#define NdisReadRegisterUshort(Register,Data)   *(Data) = READ_REGISTER_USHORT((PUSHORT)(Register))
#endif

/*++
VOID
NdisReadRegisterUlong(
    IN  PULONG                  Register,
    OUT PULONG                  Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUlong(Register,Data)    *(Data) = *((volatile ULONG * const)(Register))
#else
#define NdisReadRegisterUlong(Register,Data)    *(Data) = READ_REGISTER_ULONG((PULONG)(Register))
#endif

#define NdisEqualAnsiString(_String1,_String2, _CaseInsensitive)            \
            RtlEqualAnsiString(_String1, _String2, _CaseInsensitive)

#define NdisEqualString(_String1, _String2, _CaseInsensitive)               \
            RtlEqualUnicodeString(_String1, _String2, _CaseInsensitive)

#define NdisEqualUnicodeString(_String1, _String2, _CaseInsensitive)        \
            RtlEqualUnicodeString(_String1, _String2, _CaseInsensitive)

EXPORT
VOID __cdecl
NdisWriteErrorLogEntry(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  NDIS_ERROR_CODE         ErrorCode,
    IN  ULONG                   NumberOfErrorValues,
    ...
    );

EXPORT
VOID
NdisInitializeString(
    OUT PNDIS_STRING    Destination,
    IN  PUCHAR          Source
    );

#define NdisFreeString(String) NdisFreeMemory((String).Buffer, (String).MaximumLength, 0)

#define NdisPrintString(String) DbgPrint("%ls",(String).Buffer)


/*++

VOID
NdisCreateLookaheadBufferFromSharedMemory(
    IN  PVOID                   pSharedMemory,
    IN  UINT                    LookaheadLength,
    OUT PVOID *                 pLookaheadBuffer
    );

--*/

#define NdisCreateLookaheadBufferFromSharedMemory(_S, _L, _B)   ((*(_B)) = (_S))

/*++

VOID
NdisDestroyLookaheadBufferFromSharedMemory(
    IN  PVOID                   pLookaheadBuffer
    );

--*/

#define NdisDestroyLookaheadBufferFromSharedMemory(_B)


//
// The following declarations are shared between ndismac.h and ndismini.h. They
// are meant to be for internal use only. They should not be used directly by
// miniport drivers.
//

//
// declare these first since they point to each other
//

typedef struct _NDIS_WRAPPER_HANDLE     NDIS_WRAPPER_HANDLE, *PNDIS_WRAPPER_HANDLE;
typedef struct _NDIS_PROTOCOL_BLOCK     NDIS_PROTOCOL_BLOCK, *PNDIS_PROTOCOL_BLOCK;
typedef struct _NDIS_OPEN_BLOCK         NDIS_OPEN_BLOCK, *PNDIS_OPEN_BLOCK;
typedef struct _NDIS_M_DRIVER_BLOCK     NDIS_M_DRIVER_BLOCK, *PNDIS_M_DRIVER_BLOCK;
typedef struct _NDIS_MINIPORT_BLOCK     NDIS_MINIPORT_BLOCK,*PNDIS_MINIPORT_BLOCK;
typedef struct _CO_CALL_PARAMETERS      CO_CALL_PARAMETERS, *PCO_CALL_PARAMETERS;
typedef struct _CO_MEDIA_PARAMETERS     CO_MEDIA_PARAMETERS, *PCO_MEDIA_PARAMETERS;
typedef struct _NDIS_CALL_MANAGER_CHARACTERISTICS *PNDIS_CALL_MANAGER_CHARACTERISTICS;
typedef struct _NDIS_AF_LIST            NDIS_AF_LIST, *PNDIS_AF_LIST;
typedef struct _X_FILTER                ETH_FILTER, *PETH_FILTER;
typedef struct _X_FILTER                FDDI_FILTER, *PFDDI_FILTER;
typedef struct _X_FILTER                TR_FILTER, *PTR_FILTER;
typedef struct _X_FILTER                NULL_FILTER, *PNULL_FILTER;



//
// Timers.
//

typedef
VOID
(*PNDIS_TIMER_FUNCTION) (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

typedef struct _NDIS_TIMER
{
    KTIMER      Timer;
    KDPC        Dpc;
} NDIS_TIMER, *PNDIS_TIMER;

EXPORT
VOID
NdisInitializeTimer(
    IN OUT PNDIS_TIMER          Timer,
    IN  PNDIS_TIMER_FUNCTION    TimerFunction,
    IN  PVOID                   FunctionContext
    );

VOID
NdisCancelTimer(
    IN  PNDIS_TIMER             Timer,
    OUT PBOOLEAN                TimerCancelled
    );

EXPORT
VOID
NdisSetTimer(
    IN  PNDIS_TIMER             Timer,
    IN  UINT                    MillisecondsToDelay
    );

EXPORT
VOID
NdisSetTimerEx(
    IN  PNDIS_TIMER             Timer,
    IN  UINT                    MillisecondsToDelay,
    IN  PVOID                   FunctionContext
    );

//
// DMA operations.
//

EXPORT
VOID
NdisAllocateDmaChannel(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            NdisDmaHandle,
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  PNDIS_DMA_DESCRIPTION   DmaDescription,
    IN  ULONG                   MaximumLength
    );

EXPORT
VOID
NdisSetupDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    );

EXPORT
VOID
NdisCompleteDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    );

//
// Wrapper initialization and termination.
//

EXPORT
VOID
NdisInitializeWrapper(
    OUT PNDIS_HANDLE            NdisWrapperHandle,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

EXPORT
VOID
NdisTerminateWrapper(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PVOID                   SystemSpecific
    );

//
// Shared memory
//

#define NdisUpdateSharedMemory(_H, _L, _V, _P)

//
// System processor count
//

EXPORT
CCHAR
NdisSystemProcessorCount(
    VOID
    );

EXPORT
PVOID
NdisGetRoutineAddress(
    IN PNDIS_STRING     NdisRoutineName
    );


EXPORT
UINT
NdisGetVersion(
    VOID
    );

//
// Ansi/Unicode support routines
//

#if BINARY_COMPATIBLE

EXPORT
VOID
NdisInitAnsiString(
    IN OUT  PANSI_STRING        DestinationString,
    IN      PCSTR               SourceString
    );

EXPORT
VOID
NdisInitUnicodeString(
    IN OUT  PUNICODE_STRING     DestinationString,
    IN      PCWSTR              SourceString
    );

EXPORT
NDIS_STATUS
NdisAnsiStringToUnicodeString(
    IN OUT  PUNICODE_STRING     DestinationString,
    IN      PANSI_STRING        SourceString
    );

EXPORT
NDIS_STATUS
NdisUnicodeStringToAnsiString(
    IN OUT  PANSI_STRING        DestinationString,
    IN      PUNICODE_STRING     SourceString
    );

EXPORT
NDIS_STATUS
NdisUpcaseUnicodeString(
    OUT PUNICODE_STRING         DestinationString,
    IN  PUNICODE_STRING         SourceString
    );

#else // BINARY_COMPATIBLE

#define NdisInitAnsiString(_as, s)              RtlInitString(_as, s)
#define NdisInitUnicodeString(_us, s)           RtlInitUnicodeString(_us, s)
#define NdisAnsiStringToUnicodeString(_us, _as) RtlAnsiStringToUnicodeString(_us, _as, FALSE)
#define NdisUnicodeStringToAnsiString(_as, _us) RtlUnicodeStringToAnsiString(_as, _us, FALSE)
#define NdisUpcaseUnicodeString(_d, _s)         RtlUpcaseUnicodeString(_d, _s, FALSE)

#endif // BINARY_COMPATIBLE

//
// Non-paged lookaside list support routines
//

#define NdisInitializeNPagedLookasideList(_L, _AR, _FR, _Fl, _S, _T, _D) \
                ExInitializeNPagedLookasideList(_L, _AR, _FR, _Fl, _S, _T, _D)

#define NdisDeleteNPagedLookasideList(_L)           ExDeleteNPagedLookasideList(_L)
#define NdisAllocateFromNPagedLookasideList(_L)     ExAllocateFromNPagedLookasideList(_L)
#define NdisFreeToNPagedLookasideList(_L, _E)       ExFreeToNPagedLookasideList(_L, _E)


EXPORT
VOID
NdisSetPacketStatus(
    IN          PNDIS_PACKET    Packet,
    IN          NDIS_STATUS     Status,
    IN          NDIS_HANDLE     Handle,
    IN          ULONG           Code
    );

#define NDIS_MAX_EVENT_LOG_DATA_SIZE ((ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG)) & ~3)

#if NDIS_RECV_SCALE

#define NDIS_MAX_PROCESSOR_COUNT   32

typedef struct _NDIS_RECEIVE_SCALE_HASH_MAP
{
    CCHAR   TargetCpu[NDIS_MAX_PROCESSOR_COUNT];
} NDIS_RECEIVE_SCALE_HASH_MAP, *PNDIS_RECEIVE_SCALE_HASH_MAP;

//
// used in OID_GEN_RECEIVE_SCALE_PARAMETERS
//
typedef struct _NDIS_RECEIVE_SCALE_PARAMETERS
{
    USHORT                          EthType;
    USHORT                          CurrentHashFunction;
    NDIS_RECEIVE_SCALE_HASH_MAP     HashMap;
} NDIS_RECEIVE_SCALE_PARAMETERS, *PNDIS_RECEIVE_SCALE_PARAMETERS;


#endif

#define NDIS_CURRENT_PROCESSOR                       KeGetCurrentProcessorNumber()

#if defined(NDIS_WRAPPER)
typedef struct _OID_LIST    OID_LIST, *POID_LIST;
#endif // NDIS_WRAPPER defined


//
// Function types for NDIS_PROTOCOL_CHARACTERISTICS
//

typedef
VOID
(*OPEN_ADAPTER_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    );

typedef
VOID
(*CLOSE_ADAPTER_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*RESET_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*STATUS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

typedef
VOID
(*STATUS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

typedef
VOID
(*SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*WAN_SEND_COMPLETE_HANDLER) (
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET        Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*TRANSFER_DATA_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

typedef
VOID
(*WAN_TRANSFER_DATA_COMPLETE_HANDLER)(
    VOID
    );

typedef
NDIS_STATUS
(*RECEIVE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookAheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
NDIS_STATUS
(*WAN_RECEIVE_HANDLER)(
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PUCHAR                  Packet,
    IN  ULONG                   PacketSize
    );

typedef
VOID
(*RECEIVE_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext
    );

//
// Protocol characteristics for down-level NDIS 3.0 protocols
//
typedef struct _NDIS30_PROTOCOL_CHARACTERISTICS
{
    UCHAR                           MajorNdisVersion;
    UCHAR                           MinorNdisVersion;
    USHORT                          Filler;
    union
    {
        UINT                        Reserved;
        UINT                        Flags;
    };
    OPEN_ADAPTER_COMPLETE_HANDLER   OpenAdapterCompleteHandler;
    CLOSE_ADAPTER_COMPLETE_HANDLER  CloseAdapterCompleteHandler;
    union
    {
        SEND_COMPLETE_HANDLER       SendCompleteHandler;
        WAN_SEND_COMPLETE_HANDLER   WanSendCompleteHandler;
    };
    union
    {
     TRANSFER_DATA_COMPLETE_HANDLER TransferDataCompleteHandler;
     WAN_TRANSFER_DATA_COMPLETE_HANDLER WanTransferDataCompleteHandler;
    };

    RESET_COMPLETE_HANDLER          ResetCompleteHandler;
    REQUEST_COMPLETE_HANDLER        RequestCompleteHandler;
    union
    {
        RECEIVE_HANDLER             ReceiveHandler;
        WAN_RECEIVE_HANDLER         WanReceiveHandler;
    };
    RECEIVE_COMPLETE_HANDLER        ReceiveCompleteHandler;
    STATUS_HANDLER                  StatusHandler;
    STATUS_COMPLETE_HANDLER         StatusCompleteHandler;
    NDIS_STRING                     Name;
} NDIS30_PROTOCOL_CHARACTERISTICS;

//
// Function types extensions for NDIS 4.0 Protocols
//
typedef
INT
(*RECEIVE_PACKET_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
VOID
(*BIND_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    );

typedef
VOID
(*UNBIND_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    );

typedef
NDIS_STATUS
(*PNP_EVENT_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          NetPnPEvent
    );

typedef
VOID
(*UNLOAD_PROTOCOL_HANDLER)(
    VOID
    );

//
// Protocol characteristics for NDIS 4.0 protocols
//
typedef struct _NDIS40_PROTOCOL_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS30_PROTOCOL_CHARACTERISTICS Ndis30Chars;
#else
    NDIS30_PROTOCOL_CHARACTERISTICS;
#endif

    //
    // Start of NDIS 4.0 extensions.
    //
    RECEIVE_PACKET_HANDLER          ReceivePacketHandler;

    //
    // PnP protocol entry-points
    //
    BIND_HANDLER                    BindAdapterHandler;
    UNBIND_HANDLER                  UnbindAdapterHandler;
    PNP_EVENT_HANDLER               PnPEventHandler;
    UNLOAD_PROTOCOL_HANDLER         UnloadHandler;

} NDIS40_PROTOCOL_CHARACTERISTICS;


//
// Protocol (5.0) handler proto-types - used by clients as well as call manager modules
//
typedef
VOID
(*CO_SEND_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
VOID
(*CO_STATUS_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

typedef
UINT
(*CO_RECEIVE_PACKET_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PNDIS_PACKET            Packet
    );

typedef
NDIS_STATUS
(*CO_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

typedef
VOID
(*CO_REQUEST_COMPLETE_HANDLER)(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
//
typedef
NDIS_STATUS
(*CO_CREATE_VC_HANDLER)(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

typedef
NDIS_STATUS
(*CO_DELETE_VC_HANDLER)(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

typedef
VOID
(*CO_AF_REGISTER_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

typedef struct _NDIS50_PROTOCOL_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS40_PROTOCOL_CHARACTERISTICS Ndis40Chars;
#else
    NDIS40_PROTOCOL_CHARACTERISTICS;
#endif
    
    //
    // Placeholders for protocol extensions for PnP/PM etc.
    //
    PVOID                           ReservedHandlers[4];

    //
    // Start of NDIS 5.0 extensions.
    //

    CO_SEND_COMPLETE_HANDLER        CoSendCompleteHandler;
    CO_STATUS_HANDLER               CoStatusHandler;
    CO_RECEIVE_PACKET_HANDLER       CoReceivePacketHandler;
    CO_AF_REGISTER_NOTIFY_HANDLER   CoAfRegisterNotifyHandler;

} NDIS50_PROTOCOL_CHARACTERISTICS;

#if (defined(NDIS50) || defined(NDIS51))
typedef NDIS50_PROTOCOL_CHARACTERISTICS  NDIS_PROTOCOL_CHARACTERISTICS;
#else
#if NDIS40
typedef NDIS40_PROTOCOL_CHARACTERISTICS  NDIS_PROTOCOL_CHARACTERISTICS;
#else
typedef NDIS30_PROTOCOL_CHARACTERISTICS  NDIS_PROTOCOL_CHARACTERISTICS;
#endif
#endif
typedef NDIS_PROTOCOL_CHARACTERISTICS *PNDIS_PROTOCOL_CHARACTERISTICS;

//
// Requests used by Protocol Modules
//

EXPORT
VOID
NdisRegisterProtocol(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            NdisProtocolHandle,
    IN  PNDIS_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics,
    IN  UINT                    CharacteristicsLength
    );

EXPORT
VOID
NdisDeregisterProtocol(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisProtocolHandle
    );


EXPORT
VOID
NdisOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL
    );


EXPORT
VOID
NdisCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    );


EXPORT
VOID
NdisCompleteBindAdapter(
    IN   NDIS_HANDLE            BindAdapterContext,
    IN   NDIS_STATUS            Status,
    IN   NDIS_STATUS            OpenStatus
    );

EXPORT
VOID
NdisCompleteUnbindAdapter(
    IN   NDIS_HANDLE            UnbindAdapterContext,
    IN   NDIS_STATUS            Status
    );

EXPORT
VOID
NdisSetProtocolFilter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  RECEIVE_HANDLER         ReceiveHandler,
    IN  RECEIVE_PACKET_HANDLER  ReceivePacketHandler,
    IN  NDIS_MEDIUM             Medium,
    IN  UINT                    Offset,
    IN  UINT                    Size,
    IN  PUCHAR                  Pattern
    );

EXPORT
VOID
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  PNDIS_STRING            ProtocolSection
);

EXPORT
VOID
NdisGetDriverHandle(
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisDriverHandle
    );

EXPORT
VOID
NdisReEnumerateProtocolBindings(
    IN  NDIS_HANDLE             NdisProtocolHandle
    );

EXPORT
NDIS_STATUS
NdisWriteEventLogEntry(
    IN  PVOID                   LogHandle,
    IN  NDIS_STATUS             EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PVOID                   StringsList     OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data            OPTIONAL
    );

//
//  The following routine is used by transports to complete pending
//  network PnP events.
//
EXPORT
VOID
NdisCompletePnPEvent(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    );

//
//  The following routine is used by a transport to query the localized
//  friendly instance name of the adapter that they are bound to. There
//  are two variations of this, one uses the binding handle and the other
//  the binding context. Some transports need this before they bind - like
//  TCP/IP for instance.
//
EXPORT
NDIS_STATUS
NdisQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisBindingHandle
    );

EXPORT
NDIS_STATUS
NdisQueryBindInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     BindingContext
    );

//
// The following is used by TDI/NDIS interface as part of Network PnP.
// For use by TDI alone.
//
typedef
NTSTATUS
(*TDI_REGISTER_CALLBACK)(
    IN  PUNICODE_STRING         DeviceName,
    OUT HANDLE  *               TdiHandle
    );

typedef
NTSTATUS
(*TDI_PNP_HANDLER)(
    IN  PUNICODE_STRING         UpperComponent,
    IN  PUNICODE_STRING         LowerComponent,
    IN  PUNICODE_STRING         BindList,
    IN  PVOID                   ReconfigBuffer,
    IN  UINT                    ReconfigBufferSize,
    IN  UINT                    Operation
    );

EXPORT
VOID
NdisRegisterTdiCallBack(
    IN  TDI_REGISTER_CALLBACK   RegisterCallback,
    IN  TDI_PNP_HANDLER         PnPHandler
    );

EXPORT
VOID
NdisRegisterTdiPnpHandler(
    IN  TDI_PNP_HANDLER         PnPHandler
    );


EXPORT
VOID
NdisDeregisterTdiCallBack(
    VOID
    );

VOID
NdisReset(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    );

VOID
NdisRequest(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );


#if BINARY_COMPATIBLE

VOID
NdisSend(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    );

VOID
NdisSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

VOID
NdisTransferData(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN OUT  PNDIS_PACKET        Packet,
    OUT PUINT                   BytesTransferred
    );


#else // BINARY_COMPATIBLE


#ifdef __cplusplus

#define NdisSend(Status, NdisBindingHandle, Packet)                                     \
{                                                                                       \
    *(Status) =                                                                         \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.SendHandler)(     \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
        (Packet));                                                                      \
}

#define NdisSendPackets(NdisBindingHandle, PacketArray, NumberOfPackets)                \
{                                                                                       \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.SendPacketsHandler)(  \
        (PNDIS_OPEN_BLOCK)(NdisBindingHandle),                                          \
        (PacketArray),                                                                  \
        (NumberOfPackets));                                                             \
}

#define WanMiniportSend(Status,                                                         \
                        NdisBindingHandle,                                              \
                        NdisLinkHandle,                                                 \
                        WanPacket)                                                      \
{                                                                                       \
    *(Status) =                                                                         \
        ((((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.WanSendHandler))( \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
            (NdisLinkHandle),                                                           \
            (PNDIS_PACKET)(WanPacket));                                                 \
}

#define NdisTransferData(Status,                                                        \
                         NdisBindingHandle,                                             \
                         MacReceiveContext,                                             \
                         ByteOffset,                                                    \
                         BytesToTransfer,                                               \
                         Packet,                                                        \
                         BytesTransferred)                                              \
{                                                                                       \
    *(Status) =                                                                         \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.TransferDataHandler)( \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->NdisCommonOpenBlock.BindingHandle, \
            (MacReceiveContext),                                                        \
            (ByteOffset),                                                               \
            (BytesToTransfer),                                                          \
            (Packet),                                                                   \
            (BytesTransferred));                                                        \
}

#else

#define NdisSend(Status, NdisBindingHandle, Packet)                         \
{                                                                           \
    *(Status) =                                                             \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->SendHandler)(             \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
        (Packet));                                                          \
}


#define NdisSendPackets(NdisBindingHandle, PacketArray, NumberOfPackets)    \
{                                                                           \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->SendPacketsHandler)(          \
        (PNDIS_OPEN_BLOCK)(NdisBindingHandle),                              \
        (PacketArray),                                                      \
        (NumberOfPackets));                                                 \
}

#define WanMiniportSend(Status,                                             \
                        NdisBindingHandle,                                  \
                        NdisLinkHandle,                                     \
                        WanPacket)                                          \
{                                                                           \
    *(Status) =                                                             \
        ((((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->WanSendHandler))(        \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
            (NdisLinkHandle),                                               \
            (PNDIS_PACKET)(WanPacket));                                     \
}

#define NdisTransferData(Status,                                            \
                         NdisBindingHandle,                                 \
                         MacReceiveContext,                                 \
                         ByteOffset,                                        \
                         BytesToTransfer,                                   \
                         Packet,                                            \
                         BytesTransferred)                                  \
{                                                                           \
    *(Status) =                                                             \
        (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->TransferDataHandler)(     \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->BindingHandle,         \
            (MacReceiveContext),                                            \
            (ByteOffset),                                                   \
            (BytesToTransfer),                                              \
            (Packet),                                                       \
            (BytesTransferred));                                            \
}

#endif // ifdef __cplusplus

#endif // BINARY_COMPATIBLE

//
// Routines to access packet flags
//

/*++

VOID
NdisSetSendFlags(
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Flags
    );

--*/

#define NdisSetSendFlags(_Packet,_Flags)    (_Packet)->Private.Flags = (_Flags)

/*++

VOID
NdisQuerySendFlags(
    IN  PNDIS_PACKET            Packet,
    OUT PUINT                   Flags
    );

--*/

#define NdisQuerySendFlags(_Packet,_Flags)  *(_Flags) = (_Packet)->Private.Flags

//
// The following is the minimum size of packets a miniport must allocate
// when it indicates packets via NdisMIndicatePacket or NdisMCoIndicatePacket
//
#define PROTOCOL_RESERVED_SIZE_IN_PACKET    (4 * sizeof(PVOID))

EXPORT
VOID
NdisReturnPackets(
    IN  PNDIS_PACKET    *       PacketsToReturn,
    IN  UINT                    NumberOfPackets
    );

EXPORT
PNDIS_PACKET
NdisGetReceivedPacket(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacContext
    );

//
// Macros to portably manipulate NDIS buffers.
//
#if BINARY_COMPATIBLE

EXPORT
ULONG
NdisBufferLength(
    IN  PNDIS_BUFFER            Buffer
    );

EXPORT
PVOID
NdisBufferVirtualAddress(
    IN  PNDIS_BUFFER            Buffer
    );

#else // BINARY_COMPATIBLE

#define NdisBufferLength(Buffer)                            MmGetMdlByteCount(Buffer)
#define NdisBufferVirtualAddress(_Buffer)                   MmGetSystemAddressForMdl(_Buffer)
#define NdisBufferVirtualAddressSafe(_Buffer, _Priority)    MmGetSystemAddressForMdlSafe(_Buffer, _Priority)

#endif  // BINARY_COMPATIBLE

//
// Ndis 5.1 entry points for setting/gettign packet's CancelId and cancelling send packets
//

// #if (defined(NDIS50) || defined(NDIS51) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT))
/*
EXPORT
VOID
NdisSetPacketCancelId(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           CancelId
    );
*/
#define  NdisSetPacketCancelId(_Packet, _CancelId) NDIS_SET_PACKET_CANCEL_ID(_Packet, _CancelId);

/*
EXPORT
PVOID
NdisGetPacketCancelId(
    IN  PNDIS_PACKET    Packet
    );
*/
#define  NdisGetPacketCancelId(_Packet) NDIS_GET_PACKET_CANCEL_ID(_Packet);

EXPORT
VOID
NdisCancelSendPackets(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PVOID           CancelId
    );

EXPORT
NDIS_STATUS
NdisQueryPendingIOCount(
    IN      PVOID       NdisBindingHandle,
    IN OUT  PULONG      IoCount
    );
    
EXPORT
UCHAR
NdisGeneratePartialCancelId(
    VOID
    );

#if 0
#if NDIS_RECV_SCALE
EXPORT
NDIS_STATUS
NdisSetReceiveScaleParameters(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_RECEIVE_SCALE_PARAMETERS  ReceiveScaleParameters
    );
#endif
#endif

// #endif // NDIS51


//
// The following definitions are available only to full MAC drivers.  They
// must not be used by miniport drivers.
//

#if defined(NDIS_WRAPPER)

typedef
BOOLEAN
(*PNDIS_INTERRUPT_SERVICE)(
    IN  PVOID                   InterruptContext
    );

typedef
VOID
(*PNDIS_DEFERRED_PROCESSING)(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   InterruptContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );

#endif // defined(NDIS_WRAPPER)

//
// The following handlers are used in the OPEN_BLOCK
//
typedef
NDIS_STATUS
(*WAN_SEND_HANDLER)(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             LinkHandle,
    IN  PVOID                   Packet
    );

typedef
NDIS_STATUS
(*SEND_HANDLER)(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    );

typedef
NDIS_STATUS
(*TRANSFER_DATA_HANDLER)(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred
    );

typedef
NDIS_STATUS
(*RESET_HANDLER)(
    IN  NDIS_HANDLE             NdisBindingHandle
    );

typedef
NDIS_STATUS
(*REQUEST_HANDLER)(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );

typedef
VOID
(*SEND_PACKETS_HANDLER)(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    );


typedef struct _NDIS_COMMON_OPEN_BLOCK
{
    PVOID                       MacHandle;          // needed for backward compatibility
    NDIS_HANDLE                 BindingHandle;      // Miniport's open context
    PNDIS_MINIPORT_BLOCK        MiniportHandle;     // pointer to the miniport
    PNDIS_PROTOCOL_BLOCK        ProtocolHandle;     // pointer to our protocol
    NDIS_HANDLE                 ProtocolBindingContext;// context when calling ProtXX funcs
    PNDIS_OPEN_BLOCK            MiniportNextOpen;   // used by adapter's OpenQueue
    PNDIS_OPEN_BLOCK            ProtocolNextOpen;   // used by protocol's OpenQueue
    NDIS_HANDLE                 MiniportAdapterContext; // context for miniport
    BOOLEAN                     Reserved1;
    BOOLEAN                     Reserved2;
    BOOLEAN                     Reserved3;
    BOOLEAN                     Reserved4;
    PNDIS_STRING                BindDeviceName;
    KSPIN_LOCK                  Reserved5;
    PNDIS_STRING                RootDeviceName;

    //
    // These are referenced by the macros used by protocols to call.
    // All of the ones referenced by the macros are internal NDIS handlers for the miniports
    //
    union
    {
        SEND_HANDLER            SendHandler;
        WAN_SEND_HANDLER        WanSendHandler;
    };
    TRANSFER_DATA_HANDLER       TransferDataHandler;

    //
    // These are referenced internally by NDIS
    //
    SEND_COMPLETE_HANDLER       SendCompleteHandler;
    TRANSFER_DATA_COMPLETE_HANDLER TransferDataCompleteHandler;
    RECEIVE_HANDLER             ReceiveHandler;
    RECEIVE_COMPLETE_HANDLER    ReceiveCompleteHandler;
    WAN_RECEIVE_HANDLER         WanReceiveHandler;
    REQUEST_COMPLETE_HANDLER    RequestCompleteHandler;

    //
    // NDIS 4.0 extensions
    //
    RECEIVE_PACKET_HANDLER      ReceivePacketHandler;
    SEND_PACKETS_HANDLER        SendPacketsHandler;

    //
    // More Cached Handlers
    //
    RESET_HANDLER               ResetHandler;
    REQUEST_HANDLER             RequestHandler;
    RESET_COMPLETE_HANDLER      ResetCompleteHandler;
    STATUS_HANDLER              StatusHandler;
    STATUS_COMPLETE_HANDLER     StatusCompleteHandler;
    
#if defined(NDIS_WRAPPER)
    ULONG                       Flags;
    LONG                        References;
    KSPIN_LOCK                  SpinLock;           // guards Closing
    NDIS_HANDLE                 FilterHandle;
    ULONG                       ProtocolOptions;
    USHORT                      CurrentLookahead;
    USHORT                      ConnectDampTicks;
    USHORT                      DisconnectDampTicks;

    //
    // These are optimizations for getting to driver routines. They are not
    // necessary, but are here to save a dereference through the Driver block.
    //
    W_SEND_HANDLER              WSendHandler;
    W_TRANSFER_DATA_HANDLER     WTransferDataHandler;

    //
    //  NDIS 4.0 miniport entry-points
    //
    W_SEND_PACKETS_HANDLER      WSendPacketsHandler;

    W_CANCEL_SEND_PACKETS_HANDLER   CancelSendPacketsHandler;
        
    //
    //  Contains the wake-up events that are enabled for the open.
    //
    ULONG                       WakeUpEnable;
    //
    // event to be signalled when close complets
    //
    PKEVENT                     CloseCompleteEvent;

    QUEUED_CLOSE                QC;

    LONG                        AfReferences;

    PNDIS_OPEN_BLOCK            NextGlobalOpen;

#endif

} NDIS_COMMON_OPEN_BLOCK;

//
// one of these per open on an adapter/protocol
//
struct _NDIS_OPEN_BLOCK
{
#ifdef __cplusplus
    NDIS_COMMON_OPEN_BLOCK NdisCommonOpenBlock;
#else
    NDIS_COMMON_OPEN_BLOCK;
#endif

#if defined(NDIS_WRAPPER)
    
    //
    // The stuff below is for CO drivers/protocols. This part is not allocated for CL drivers.
    //
    struct _NDIS_OPEN_CO
    {
        //
        // this is the list of the call manager opens done on this adapter
        //
        struct _NDIS_CO_AF_BLOCK *          NextAf;
    
        //
        //  NDIS 5.0 miniport entry-points, filled in at open time.
        //
        W_CO_CREATE_VC_HANDLER              MiniportCoCreateVcHandler;
        W_CO_REQUEST_HANDLER                MiniportCoRequestHandler;
    
        //
        // NDIS 5.0 protocol completion routines, filled in at RegisterAf/OpenAf time
        //
        CO_CREATE_VC_HANDLER                CoCreateVcHandler;
        CO_DELETE_VC_HANDLER                CoDeleteVcHandler;
        CM_ACTIVATE_VC_COMPLETE_HANDLER     CmActivateVcCompleteHandler;
        CM_DEACTIVATE_VC_COMPLETE_HANDLER   CmDeactivateVcCompleteHandler;
        CO_REQUEST_COMPLETE_HANDLER         CoRequestCompleteHandler;
    
        //
        // lists for queuing connections. There is both a queue for currently
        // active connections and a queue for connections that are not active.
        //
        LIST_ENTRY                          ActiveVcHead;
        LIST_ENTRY                          InactiveVcHead;
        LONG                                PendingAfNotifications;
        PKEVENT                             AfNotifyCompleteEvent;
    };
#endif
};

//
// The following definitions are available only to miniport drivers.  They
// must not be used by full MAC drivers.
//

#if defined(NDIS_MINIPORT_DRIVER) || defined(NDIS_WRAPPER)

#if ARCNET
#include <afilter.h>
#endif
#include <xfilter.h>

#define NDIS_M_MAX_LOOKAHEAD 526


//
// Function types for NDIS_MINIPORT_CHARACTERISTICS
//


typedef
BOOLEAN
(*W_CHECK_FOR_HANG_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_DISABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_ENABLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_HALT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
VOID
(*W_HANDLE_INTERRUPT_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_INITIALIZE_HANDLER)(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

typedef
VOID
(*W_ISR_HANDLER)(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_QUERY_INFORMATION_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

typedef
NDIS_STATUS
(*W_RECONFIGURE_HANDLER)(
    OUT PNDIS_STATUS            OpenErrorStatus,
    IN  NDIS_HANDLE             MiniportAdapterContext  OPTIONAL,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

typedef
NDIS_STATUS
(*W_RESET_HANDLER)(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    );

typedef
NDIS_STATUS
(*W_SEND_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Flags
    );

typedef
NDIS_STATUS
(*WM_SEND_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PNDIS_WAN_PACKET        Packet
    );

typedef
NDIS_STATUS
(*W_SET_INFORMATION_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

typedef
NDIS_STATUS
(*W_TRANSFER_DATA_HANDLER)(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    );

typedef
NDIS_STATUS
(*WM_TRANSFER_DATA_HANDLER)(
    VOID
    );

typedef struct _NDIS30_MINIPORT_CHARACTERISTICS
{
    UCHAR                       MajorNdisVersion;
    UCHAR                       MinorNdisVersion;
    USHORT                      Filler;
    UINT                        Reserved;
    W_CHECK_FOR_HANG_HANDLER    CheckForHangHandler;
    W_DISABLE_INTERRUPT_HANDLER DisableInterruptHandler;
    W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler;
    W_HALT_HANDLER              HaltHandler;
    W_HANDLE_INTERRUPT_HANDLER  HandleInterruptHandler;
    W_INITIALIZE_HANDLER        InitializeHandler;
    W_ISR_HANDLER               ISRHandler;
    W_QUERY_INFORMATION_HANDLER QueryInformationHandler;
    W_RECONFIGURE_HANDLER       ReconfigureHandler;
    W_RESET_HANDLER             ResetHandler;
    union
    {
        W_SEND_HANDLER          SendHandler;
        WM_SEND_HANDLER         WanSendHandler;
    };
    W_SET_INFORMATION_HANDLER   SetInformationHandler;
    union
    {
        W_TRANSFER_DATA_HANDLER TransferDataHandler;
        WM_TRANSFER_DATA_HANDLER WanTransferDataHandler;
    };
} NDIS30_MINIPORT_CHARACTERISTICS;

//
// Miniport extensions for NDIS 4.0
//
typedef
VOID
(*W_RETURN_PACKET_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    );

//
// NDIS 4.0 extension
//
typedef
VOID
(*W_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

typedef
VOID
(*W_ALLOCATE_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   VirtualAddress,
    IN  PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,
    IN  ULONG                   Length,
    IN  PVOID                   Context
    );

typedef struct _NDIS40_MINIPORT_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS30_MINIPORT_CHARACTERISTICS Ndis30Chars;
#else
    NDIS30_MINIPORT_CHARACTERISTICS;
#endif
    //
    // Extensions for NDIS 4.0
    //
    W_RETURN_PACKET_HANDLER     ReturnPacketHandler;
    W_SEND_PACKETS_HANDLER      SendPacketsHandler;
    W_ALLOCATE_COMPLETE_HANDLER AllocateCompleteHandler;

} NDIS40_MINIPORT_CHARACTERISTICS;


//
// Miniport extensions for NDIS 5.0
//
//
// NDIS 5.0 extension - however available for miniports only
//

//
// W_CO_CREATE_VC_HANDLER is a synchronous call
//
typedef
NDIS_STATUS
(*W_CO_CREATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            MiniportVcContext
    );

typedef
NDIS_STATUS
(*W_CO_DELETE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext
    );

typedef
NDIS_STATUS
(*W_CO_ACTIVATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

typedef
NDIS_STATUS
(*W_CO_DEACTIVATE_VC_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext
    );

typedef
VOID
(*W_CO_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

typedef
NDIS_STATUS
(*W_CO_REQUEST_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

typedef struct _NDIS50_MINIPORT_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS40_MINIPORT_CHARACTERISTICS Ndis40Chars;
#else
    NDIS40_MINIPORT_CHARACTERISTICS;
#endif
    //
    // Extensions for NDIS 5.0
    //
    W_CO_CREATE_VC_HANDLER      CoCreateVcHandler;
    W_CO_DELETE_VC_HANDLER      CoDeleteVcHandler;
    W_CO_ACTIVATE_VC_HANDLER    CoActivateVcHandler;
    W_CO_DEACTIVATE_VC_HANDLER  CoDeactivateVcHandler;
    W_CO_SEND_PACKETS_HANDLER   CoSendPacketsHandler;
    W_CO_REQUEST_HANDLER        CoRequestHandler;
} NDIS50_MINIPORT_CHARACTERISTICS;

//
// Miniport extensions for NDIS 5.1
//
typedef VOID
(*W_CANCEL_SEND_PACKETS_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   CancelId
    );

//
// power profiles
//
typedef enum _NDIS_POWER_PROFILE
{
    NdisPowerProfileBattery,
    NdisPowerProfileAcOnLine
} NDIS_POWER_PROFILE, *PNDIS_POWER_PROFILE;

typedef enum _NDIS_DEVICE_PNP_EVENT
{
    NdisDevicePnPEventQueryRemoved,
    NdisDevicePnPEventRemoved,
    NdisDevicePnPEventSurpriseRemoved,
    NdisDevicePnPEventQueryStopped,
    NdisDevicePnPEventStopped,
    NdisDevicePnPEventPowerProfileChanged,
    NdisDevicePnPEventMaximum
} NDIS_DEVICE_PNP_EVENT, *PNDIS_DEVICE_PNP_EVENT;

typedef VOID
(*W_PNP_EVENT_NOTIFY_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    );

typedef VOID
(*W_MINIPORT_SHUTDOWN_HANDLER) (
    IN  NDIS_HANDLE                     MiniportAdapterContext
    );

#if NDIS_RECV_SCALE

typedef
BOOLEAN
(*MINIPORT_ISR_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    OUT PBOOLEAN                QueueDefaultInterruptDpc,
    OUT PULONG                  TargetProcessors
    );

typedef    
VOID
(*MINIPORT_INTERRUPT_DPC_HANDLER)(
    IN  NDIS_HANDLE             MiniportInterruptContext,
    OUT PULONG                  TargetProcessors
    );


typedef struct _NDIS_MINIPORT_INTERRUPT_EX
{
    PKINTERRUPT                 InterruptObject;
    KSPIN_LOCK                  DpcCountLock;
    union
    {
        PVOID                   Reserved;
        PVOID                   InterruptContext;
    };
    MINIPORT_ISR_HANDLER            MiniportIsr;
    MINIPORT_INTERRUPT_DPC_HANDLER  MiniportDpc;
    KDPC                        InterruptDpc;
    PNDIS_MINIPORT_BLOCK        Miniport;

    UCHAR                       DpcCount;
    BOOLEAN                     Filler1;

    //
    // This is used to tell when all the Dpcs for the adapter are completed.
    //

    KEVENT                      DpcsCompletedEvent;

    BOOLEAN                     SharedInterrupt;
    BOOLEAN                     IsrRequested;
    struct _NDIS_MINIPORT_INTERRUPT_EX *NextInterrupt;
    ULONG                       DpcQueued;          // bitmap of processors for which a Dpc is already queud
    KDPC                        Dpc[NDIS_MAX_PROCESSOR_COUNT];
} NDIS_MINIPORT_INTERRUPT_EX, *PNDIS_MINIPORT_INTERRUPT_EX;

EXPORT
NDIS_STATUS
NdisMRegisterInterruptEx(
    OUT PNDIS_MINIPORT_INTERRUPT_EX Interrupt,
    IN NDIS_HANDLE                  MiniportAdapterHandle,
    IN UINT                         InterruptVector,
    IN UINT                         InterruptLevel,
    IN BOOLEAN                      RequestIsr,
    IN BOOLEAN                      SharedInterrupt,
    IN NDIS_INTERRUPT_MODE          InterruptMode
    );

EXPORT    
VOID
NdisMDeregisterInterruptEx(
    IN  PNDIS_MINIPORT_INTERRUPT_EX     MiniportInterrupt
    );

//
// for interrupts registered with NdisMRegisterInterruptEx 
// BOOLEAN
// NdisMSynchronizeWithInterruptEx(
//     IN  PNDIS_MINIPORT_INTERRUPT_EX  Interrupt,
//     IN  PVOID                        SynchronizeFunction,
//     IN  PVOID                        SynchronizeContext
//     );

#define NdisMSynchronizeWithInterruptEx(_Interrupt, _SynchronizeFunction, _SynchronizeContext) \
        NdisMSynchronizeWithInterrupt((PNDIS_MINIPORT_INTERRUPT)(_Interrupt),  _SynchronizeFunction, _SynchronizeContext)


#endif

typedef struct _NDIS51_MINIPORT_CHARACTERISTICS
{
#ifdef __cplusplus
    NDIS50_MINIPORT_CHARACTERISTICS Ndis50Chars;
#else
    NDIS50_MINIPORT_CHARACTERISTICS;
#endif
    //
    // Extensions for NDIS 5.1
    //
    W_CANCEL_SEND_PACKETS_HANDLER   CancelSendPacketsHandler;
    W_PNP_EVENT_NOTIFY_HANDLER      PnPEventNotifyHandler;
    W_MINIPORT_SHUTDOWN_HANDLER     AdapterShutdownHandler;
#if NDIS_RECV_SCALE
    MINIPORT_ISR_HANDLER                        MiniportISRHandler;
    MINIPORT_INTERRUPT_DPC_HANDLER              InterruptDpcHandler;
#else    
    PVOID                           Reserved1;
    PVOID                           Reserved2;
#endif
    PVOID                           Reserved3;
    PVOID                           Reserved4;
} NDIS51_MINIPORT_CHARACTERISTICS;

#ifdef NDIS51_MINIPORT
typedef struct _NDIS51_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
#ifdef NDIS50_MINIPORT
typedef struct _NDIS50_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
#ifdef NDIS40_MINIPORT
typedef struct _NDIS40_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#else
typedef struct _NDIS30_MINIPORT_CHARACTERISTICS NDIS_MINIPORT_CHARACTERISTICS;
#endif
#endif
#endif

typedef NDIS_MINIPORT_CHARACTERISTICS * PNDIS_MINIPORT_CHARACTERISTICS;
typedef NDIS_MINIPORT_CHARACTERISTICS   NDIS_WAN_MINIPORT_CHARACTERISTICS;
typedef NDIS_WAN_MINIPORT_CHARACTERISTICS * PNDIS_MINIPORT_CHARACTERISTICS;

typedef struct _NDIS_MINIPORT_INTERRUPT
{
    PKINTERRUPT                 InterruptObject;
    KSPIN_LOCK                  DpcCountLock;
    PVOID                       Reserved;
    W_ISR_HANDLER               MiniportIsr;
    W_HANDLE_INTERRUPT_HANDLER  MiniportDpc;
    KDPC                        InterruptDpc;
    PNDIS_MINIPORT_BLOCK        Miniport;

    UCHAR                       DpcCount;
    BOOLEAN                     Filler1;

    //
    // This is used to tell when all the Dpcs for the adapter are completed.
    //

    KEVENT                      DpcsCompletedEvent;

    BOOLEAN                     SharedInterrupt;
    BOOLEAN                     IsrRequested;

} NDIS_MINIPORT_INTERRUPT, *PNDIS_MINIPORT_INTERRUPT;

typedef struct _NDIS_MINIPORT_TIMER
{
    KTIMER                      Timer;
    KDPC                        Dpc;
    PNDIS_TIMER_FUNCTION        MiniportTimerFunction;
    PVOID                       MiniportTimerContext;
    PNDIS_MINIPORT_BLOCK        Miniport;
    struct _NDIS_MINIPORT_TIMER *NextTimer;
} NDIS_MINIPORT_TIMER, *PNDIS_MINIPORT_TIMER;

typedef
VOID
(*FILTER_PACKET_INDICATION_HANDLER)(
    IN  NDIS_HANDLE             Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );

typedef
VOID
(*ETH_RCV_INDICATE_HANDLER)(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
VOID
(*ETH_RCV_COMPLETE_HANDLER)(
    IN  PETH_FILTER             Filter
    );

typedef
VOID
(*FDDI_RCV_INDICATE_HANDLER)(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  UINT                    AddressLength,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
VOID
(*FDDI_RCV_COMPLETE_HANDLER)(
    IN  PFDDI_FILTER            Filter
    );

typedef
VOID
(*TR_RCV_INDICATE_HANDLER)(
    IN  PTR_FILTER              Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    );

typedef
VOID
(*TR_RCV_COMPLETE_HANDLER)(
    IN  PTR_FILTER              Filter
    );

typedef
VOID
(*WAN_RCV_HANDLER)(
    OUT PNDIS_STATUS            Status,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext,
    IN PUCHAR                   Packet,
    IN ULONG                    PacketSize
    );

typedef
VOID
(*WAN_RCV_COMPLETE_HANDLER)(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              NdisLinkContext
    );

typedef
VOID
(*NDIS_M_SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_WM_SEND_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   Packet,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_M_TD_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    );

typedef
VOID
(*NDIS_M_SEND_RESOURCES_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

typedef
VOID
(*NDIS_M_STATUS_HANDLER)(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    );

typedef
VOID
(*NDIS_M_STS_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    );

typedef
VOID
(*NDIS_M_REQ_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    );

typedef
VOID
(*NDIS_M_RESET_COMPLETE_HANDLER)(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    );

typedef
BOOLEAN
(FASTCALL *NDIS_M_START_SENDS)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    );

//
//  Defines the type of work item.
//
typedef enum _NDIS_WORK_ITEM_TYPE
{
    NdisWorkItemRequest,
    NdisWorkItemSend,
    NdisWorkItemReturnPackets,
    NdisWorkItemResetRequested,
    NdisWorkItemResetInProgress,
    NdisWorkItemReserved,
    NdisWorkItemMiniportCallback,
    NdisMaxWorkItems
} NDIS_WORK_ITEM_TYPE, *PNDIS_WORK_ITEM_TYPE;


#define NUMBER_OF_WORK_ITEM_TYPES   NdisMaxWorkItems
#define NUMBER_OF_SINGLE_WORK_ITEMS 6

//
//  Work item structure
//
typedef struct _NDIS_MINIPORT_WORK_ITEM
{
    //
    //  Link for the list of work items of this type.
    //
    SINGLE_LIST_ENTRY   Link;

    //
    //  type of work item and context information.
    //
    NDIS_WORK_ITEM_TYPE WorkItemType;
    PVOID               WorkItemContext;
} NDIS_MINIPORT_WORK_ITEM, *PNDIS_MINIPORT_WORK_ITEM;

typedef
NDIS_STATUS
(FASTCALL *NDIS_M_QUEUE_WORK_ITEM)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext
    );

typedef
NDIS_STATUS
(FASTCALL *NDIS_M_QUEUE_NEW_WORK_ITEM)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext
    );

typedef
VOID
(FASTCALL *NDIS_M_DEQUEUE_WORK_ITEM)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    OUT PVOID   *               WorkItemContext
    );

#if defined(NDIS_WRAPPER)

//
// Structure used by the logging apis
//
typedef struct _NDIS_LOG
{
    PNDIS_MINIPORT_BLOCK        Miniport;   // The owning miniport block
    KSPIN_LOCK                  LogLock;    // For serialization
    PIRP                        Irp;        // Pending Irp to consume this log
    UINT                        TotalSize;  // Size of the log buffer
    UINT                        CurrentSize;// Size of the log buffer
    UINT                        InPtr;      // IN part of the circular buffer
    UINT                        OutPtr;     // OUT part of the circular buffer
    UCHAR                       LogBuf[1];  // The circular buffer
} NDIS_LOG, *PNDIS_LOG;

#if ARCNET

//
// Arcnet specific stuff
//
#define ARC_SEND_BUFFERS            8
#define ARC_HEADER_SIZE             4

typedef struct _NDIS_ARC_BUF
{
    NDIS_HANDLE                 ArcnetBufferPool;
    PUCHAR                      ArcnetLookaheadBuffer;
    UINT                        NumFree;
    ARC_BUFFER_LIST             ArcnetBuffers[ARC_SEND_BUFFERS];
} NDIS_ARC_BUF, *PNDIS_ARC_BUF;

#endif

#endif

typedef struct _NDIS_BIND_PATHS
{
    UINT                        Number;
    NDIS_STRING                 Paths[1];
} NDIS_BIND_PATHS, *PNDIS_BIND_PATHS;

//
// Do not change the structure below !!!
//
typedef struct
{
    union
    {
        PETH_FILTER             EthDB;
        PNULL_FILTER            NullDB;             // Default Filter
    };
    PTR_FILTER                  TrDB;
    PFDDI_FILTER                FddiDB;
#if ARCNET
    PARC_FILTER                 ArcDB;
#else
    PVOID                       XXXDB;
#endif
} FILTERDBS, *PFILTERDBS;

//
// one of these per mini-port registered on a Driver
//
struct _NDIS_MINIPORT_BLOCK
{
    PVOID                       Signature;          // MINIPORT_DEVICE_MAGIC_VALUE
    PNDIS_MINIPORT_BLOCK        NextMiniport;       // used by driver's MiniportQueue
    PNDIS_M_DRIVER_BLOCK        DriverHandle;       // pointer to our Driver block
    NDIS_HANDLE                 MiniportAdapterContext; // context when calling mini-port functions
    UNICODE_STRING              MiniportName;       // how mini-port refers to us
    PNDIS_BIND_PATHS            BindPaths;
    NDIS_HANDLE                 OpenQueue;          // queue of opens for this mini-port
    REFERENCE                   ShortRef;           // contains spinlock for OpenQueue

    NDIS_HANDLE                 DeviceContext;      // Context associated with the intermediate driver

    UCHAR                       Padding1;           // DO NOT REMOVE OR NDIS WILL BREAK!!!

    //
    // Synchronization stuff.
    //
    // The boolean is used to lock out several DPCs from running at the same time.
    //
    UCHAR                       LockAcquired;       // EXPOSED via macros. Do not move

    UCHAR                       PmodeOpens;         // Count of opens which turned on pmode/all_local

    //
    //  This is the processor number that the miniport's
    //  interrupt DPC and timers are running on.
    //
    UCHAR                       AssignedProcessor;

    KSPIN_LOCK                  Lock;

    PNDIS_REQUEST               MediaRequest;

    PNDIS_MINIPORT_INTERRUPT    Interrupt;

    ULONG                       Flags;              // Flags to keep track of the
                                                    // miniport's state.
    ULONG                       PnPFlags;

    //
    // Send information
    //
    LIST_ENTRY                  PacketList;
    PNDIS_PACKET                FirstPendingPacket; // This is head of the queue of packets
                                                    // waiting to be sent to miniport.
    PNDIS_PACKET                ReturnPacketsQueue;

    //
    // Space used for temp. use during request processing
    //
    ULONG                       RequestBuffer;
    PVOID                       SetMCastBuffer;

    PNDIS_MINIPORT_BLOCK        PrimaryMiniport;
    PVOID                       WrapperContext;

    //
    // context to pass to bus driver when reading or writing config space
    //
    PVOID                       BusDataContext;
    //
    // flag to specify PnP capabilities of the device. we need this to fail query_stop
    // query_remove or suspend request if the device can not handle it
    //
    ULONG                       PnPCapabilities;
    
    //
    // Resource information
    //
    PCM_RESOURCE_LIST           Resources;

    //
    // Watch-dog timer
    //
    NDIS_TIMER                  WakeUpDpcTimer;

    //
    // Needed for PnP. Upcased version. The buffer is allocated as part of the
    // NDIS_MINIPORT_BLOCK itself.
    //
    // Note:
    // the following two fields should be explicitly UNICODE_STRING because
    // under Win9x the NDIS_STRING is an ANSI_STRING
    //
    UNICODE_STRING              BaseName;
    UNICODE_STRING              SymbolicLinkName;

    //
    // Check for hang stuff
    //
    ULONG                       CheckForHangSeconds;
    USHORT                      CFHangTicks;
    USHORT                      CFHangCurrentTick;

    //
    // Reset information
    //
    NDIS_STATUS                 ResetStatus;
    NDIS_HANDLE                 ResetOpen;

    //
    // Holds media specific information.
    //
#ifdef __cplusplus
    FILTERDBS                   FilterDbs;          // EXPOSED via macros. Do not move
#else
    FILTERDBS;                                      // EXPOSED via macros. Do not move
#endif

    FILTER_PACKET_INDICATION_HANDLER PacketIndicateHandler;
    NDIS_M_SEND_COMPLETE_HANDLER    SendCompleteHandler;
    NDIS_M_SEND_RESOURCES_HANDLER   SendResourcesHandler;
    NDIS_M_RESET_COMPLETE_HANDLER   ResetCompleteHandler;

    NDIS_MEDIUM                 MediaType;

    //
    // contains mini-port information
    //
    ULONG                       BusNumber;
    NDIS_INTERFACE_TYPE         BusType;
    NDIS_INTERFACE_TYPE         AdapterType;

    PDEVICE_OBJECT              DeviceObject;
    PDEVICE_OBJECT              PhysicalDeviceObject;
    PDEVICE_OBJECT              NextDeviceObject;

    //
    // Holds the map registers for this mini-port.
    //
    struct _MAP_REGISTER_ENTRY *MapRegisters;   // EXPOSED via macros. Do not move

    //
    // List of registered address families. Valid for the call-manager, Null for the client
    //
    PNDIS_AF_LIST               CallMgrAfList;

    PVOID                       MiniportThread;
    PVOID                       SetInfoBuf;
    USHORT                      SetInfoBufLen;
    USHORT                      MaxSendPackets;

    //
    //  Status code that is returned from the fake handlers.
    //
    NDIS_STATUS                 FakeStatus;

    PVOID                       LockHandler;        // For the filter lock

    //
    // the following field should be explicitly UNICODE_STRING because
    // under Win9x the NDIS_STRING is an ANSI_STRING
    //
    PUNICODE_STRING             pAdapterInstanceName;   //  Instance specific name for the adapter.

    PNDIS_MINIPORT_TIMER        TimerQueue;

    UINT                        MacOptions;

    //
    // RequestInformation
    //
    PNDIS_REQUEST               PendingRequest;
    UINT                        MaximumLongAddresses;
    UINT                        MaximumShortAddresses;
    UINT                        CurrentLookahead;
    UINT                        MaximumLookahead;

    //
    //  For efficiency
    //
    W_HANDLE_INTERRUPT_HANDLER  HandleInterruptHandler;
    W_DISABLE_INTERRUPT_HANDLER DisableInterruptHandler;
    W_ENABLE_INTERRUPT_HANDLER  EnableInterruptHandler;
    W_SEND_PACKETS_HANDLER      SendPacketsHandler;
    NDIS_M_START_SENDS          DeferredSendHandler;

    //
    // The following cannot be unionized.
    //
    ETH_RCV_INDICATE_HANDLER    EthRxIndicateHandler;   // EXPOSED via macros. Do not move
    TR_RCV_INDICATE_HANDLER     TrRxIndicateHandler;    // EXPOSED via macros. Do not move
    FDDI_RCV_INDICATE_HANDLER   FddiRxIndicateHandler;  // EXPOSED via macros. Do not move

    ETH_RCV_COMPLETE_HANDLER    EthRxCompleteHandler;   // EXPOSED via macros. Do not move
    TR_RCV_COMPLETE_HANDLER     TrRxCompleteHandler;    // EXPOSED via macros. Do not move
    FDDI_RCV_COMPLETE_HANDLER   FddiRxCompleteHandler;  // EXPOSED via macros. Do not move

    NDIS_M_STATUS_HANDLER       StatusHandler;          // EXPOSED via macros. Do not move
    NDIS_M_STS_COMPLETE_HANDLER StatusCompleteHandler;  // EXPOSED via macros. Do not move
    NDIS_M_TD_COMPLETE_HANDLER  TDCompleteHandler;      // EXPOSED via macros. Do not move
    NDIS_M_REQ_COMPLETE_HANDLER QueryCompleteHandler;   // EXPOSED via macros. Do not move
    NDIS_M_REQ_COMPLETE_HANDLER SetCompleteHandler;     // EXPOSED via macros. Do not move

    NDIS_WM_SEND_COMPLETE_HANDLER WanSendCompleteHandler;// EXPOSED via macros. Do not move
    WAN_RCV_HANDLER             WanRcvHandler;          // EXPOSED via macros. Do not move
    WAN_RCV_COMPLETE_HANDLER    WanRcvCompleteHandler;  // EXPOSED via macros. Do not move

    /********************************************************************************************/
    /****************                                                                  **********/
    /**************** STUFF ABOVE IS POTENTIALLY ACCESSED BY MACROS. ADD STUFF BELOW   **********/
    /**************** SEVERE POSSIBILITY OF BREAKING SOMETHING IF STUFF ABOVE IS MOVED **********/
    /****************                                                                  **********/
    /********************************************************************************************/
#if defined(NDIS_WRAPPER)
    PNDIS_MINIPORT_BLOCK        NextGlobalMiniport;     // used to queue miniport on global miniport queue

    //
    // Work that the miniport needs to do.
    //
    SINGLE_LIST_ENTRY           WorkQueue[NUMBER_OF_WORK_ITEM_TYPES];
    SINGLE_LIST_ENTRY           SingleWorkItems[NUMBER_OF_SINGLE_WORK_ITEMS];

    UCHAR                       SendFlags;
    UCHAR                       TrResetRing;
    UCHAR                       ArcnetAddress;
    UCHAR                       XState;     // flag to indicate why we have set the fake handlers
    
    union
    {
#if ARCNET
        PNDIS_ARC_BUF           ArcBuf;
#endif
        //
        // the following field has a different use under NT and Memphis
        //
        PVOID                   BusInterface;
    };

    PNDIS_LOG                   Log;

    //
    // Store information here to track adapters
    //
    ULONG                       SlotNumber;

    PCM_RESOURCE_LIST           AllocatedResources;
    PCM_RESOURCE_LIST           AllocatedResourcesTranslated;

    //
    //  Contains a list of the packet patterns that have been added to the
    //  adapter.
    //
    SINGLE_LIST_ENTRY           PatternList;

    //
    //  The driver's power management capabilities.
    //
    NDIS_PNP_CAPABILITIES       PMCapabilities;

    //
    // DeviceCapabilites as received from bus driver
    //
    DEVICE_CAPABILITIES         DeviceCaps;

    //
    //  Contains the wake-up events that are enabled for the miniport.
    //
    ULONG                       WakeUpEnable;

    //
    //  The current device state that the adapter is in.
    //
    DEVICE_POWER_STATE          CurrentDevicePowerState;

    //
    //  The following IRP is created in response to a cable disconnect
    //  from the device.  We keep a pointer around in case we need to cancel
    //  it.
    //
    PIRP                        pIrpWaitWake;

    SYSTEM_POWER_STATE          WaitWakeSystemState;

    //
    //  The following is a pointer to a dynamically allocated array
    //  of GUID structs. This is used to map GUIDs to OIDs
    //  for custom GUIDs provided by the miniport.
    //

    LARGE_INTEGER               VcIndex;                //  Index used to identify a VC.
    KSPIN_LOCK                  VcCountLock;            //  Lock used to protect VC instance count.
    LIST_ENTRY                  WmiEnabledVcs;          //  List of WMI enabled VCs
    PNDIS_GUID                  pNdisGuidMap;           // This is a list of all the GUIDs
                                                        //  and OIDs supported including any
                                                        //  customg GUIDs.
    PNDIS_GUID                  pCustomGuidMap;         // This is a pointer into
                                                        //  the pGuidToOidMap to the
                                                        //  first custom GUID.
    USHORT                      VcCount;                //  Number of VC's that have instance names.

    USHORT                      cNdisGuidMap;           // This is the number of std. GUIDs
    USHORT                      cCustomGuidMap;         // This is the number of custom GUIDs

    //
    // These two are used temporarily while allocating the map registers.
    //
    USHORT                      CurrentMapRegister;
    PKEVENT                     AllocationEvent;

    USHORT                      BaseMapRegistersNeeded;
    USHORT                      SGMapRegistersNeeded;
    ULONG                       MaximumPhysicalMapping;

    //
    // This timer is used for media disconnect timouts.
    //
    NDIS_TIMER                  MediaDisconnectTimer;

    //
    // The timeout value for media disconnect timer to fire
    // default is 20 seconds
    //
    USHORT                      MediaDisconnectTimeOut;

    //
    // Used for WMI support
    //
    USHORT                      InstanceNumber;

    //
    // this event will be set at the end of adapter initialization
    //
    NDIS_EVENT                  OpenReadyEvent;

    //
    // current PnP state of the device, ex. started, stopped, query_removed, etc.
    //
    NDIS_PNP_DEVICE_STATE       PnPDeviceState;
    
    //
    // previous device state. to be used when we get a cancel_remove or a cancel_stop
    //
    NDIS_PNP_DEVICE_STATE       OldPnPDeviceState;
    
    //
    // Handlers to Write/Read Bus data
    //
    PGET_SET_DEVICE_DATA        SetBusData;
    PGET_SET_DEVICE_DATA        GetBusData;

    KDPC                        DeferredDpc;

    //
    // Some NDIS gathered stats
    //
    NDIS_STATS                  NdisStats;

    //
    // Valid during Packet Indication
    //
    PNDIS_PACKET                IndicatedPacket[MAXIMUM_PROCESSORS];

    //
    // this event is for protecting against returning from REMOVE IRP
    // too early and while we still have pending workitems
    //
    PKEVENT                     RemoveReadyEvent;

    //
    // this event gets signaled when all opens on the miniport are closed
    //
    PKEVENT                     AllOpensClosedEvent;

    //
    // this event gets signaled when all requests on the miniport are gone
    //
    PKEVENT                     AllRequestsCompletedEvent;

    //
    // Init time for the miniport in milliseconds
    //
    ULONG                       InitTimeMs;

    NDIS_MINIPORT_WORK_ITEM     WorkItemBuffer[NUMBER_OF_SINGLE_WORK_ITEMS];

    PDMA_ADAPTER                SystemAdapterObject;
    
    //
    // flags to fail certain NDIS APIs to make sure the driver does the right things
    //
    ULONG                       DriverVerifyFlags;
    
    POID_LIST                   OidList;
    //
    // InternalResetCount:  The # of times NDIS decided a miniport was hung
    // MiniportResetCount   The # of times miniport decided it was hung
    //
    USHORT                      InternalResetCount;
    USHORT                      MiniportResetCount;

    USHORT                      MediaSenseConnectCount;
    USHORT                      MediaSenseDisconnectCount;

    PNDIS_PACKET    *           xPackets;

    //
    // track the user mode requests
    //
    ULONG                       UserModeOpenReferences;

    //
    // Saved handlers. The handlers in the NDIS_OPEN_BLOCK are saved here
    // by ndisMSwapOpenHandlers and restored by ndisMRestoreOpenHandlers.
    //
    union
    {
        PVOID                   SavedSendHandler;
        PVOID                   SavedWanSendHandler;
    };
    W_SEND_PACKETS_HANDLER      SavedSendPacketsHandler;
    W_CANCEL_SEND_PACKETS_HANDLER SavedCancelSendPacketsHandler;

    //
    // real Send