tr[iCurrentPos], 1);
			++iCurrentPos;
		}

		BOOL bFoundSep = FALSE;
		if((iCurrentPos < iStringLength) &&
		   (m_bstrMoniker.m_str[iCurrentPos] == NAME_SEP)) {
			bFoundSep = TRUE;
			++iCurrentPos;
		}

		// Read in the value
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] != ENTRY_SEP)) {
			if((iCurrentPos < iStringLength - 1) &&
			   (m_bstrMoniker.m_str[iCurrentPos] == QUOTE_CHAR)) {
				++iCurrentPos;
			}

			bstrValue.Append(&m_bstrMoniker.m_str[iCurrentPos], 1);
			++iCurrentPos;
		}

		if(bFoundSep) { // If it's a real entry
			CComVariant varValue = bstrValue; // Convert BSTR to Variant
			pBag->Write(bstrName, &varValue);
			// Even if error occurs in Write(), continue processing
		}

		// Eat up multiple spaces for entry separators
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] == ENTRY_SEP)) {
			++iCurrentPos;
		}
	}
}

HRESULT CSEOGenericMoniker::CreateBoundObject(IPropertyBag *pBag, ISEOInitObject **ppResult) {
	_ASSERT(ppResult);
	*ppResult = NULL;
	if(!pBag) return E_POINTER;

	CComVariant varPROGID;
	CLSID clsid;

	varPROGID.vt = VT_BSTR; // Request type from Read()
	varPROGID.bstrVal = NULL;
	HRESULT hRes = pBag->Read(szObjectType, &varPROGID, NULL);

	if(SUCCEEDED(hRes))	{
		_ASSERT(varPROGID.vt == VT_BSTR);
		hRes = CLSIDFromProgID(varPROGID.bstrVal, &clsid);
	}

	if(SUCCEEDED(hRes))	{
		hRes = CoCreateInstance(clsid, NULL, CLSCTX_ALL,
		                        IID_ISEOInitObject, (LPVOID *) ppResult);
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\events.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	events.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Objects Server Events classes.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	04/04/97	created

--*/


// events.cpp : Implementation of Server Events classes
#include "stdafx.h"
#include <new.h>
#include "seodefs.h"
#include "events.h"
#include "comcat.h"
#include "urlmon.h"
#include "seolib.h"


#include <initguid.h>
// {1EF08720-1E76-11d1-AA29-00AA006BC80B}
DEFINE_GUID(IID_ICreateSinkInfo, 0x1ef08720, 0x1e76, 0x11d1, 0xaa, 0x29, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
class CCreateSinkInfo : public IUnknown {
	public:
		BOOL m_bInit;
		BOOL m_bEnabled;
		CComBSTR m_strSinkClass;
		CComPtr<IUnknown> m_pSink;
		CComPtr<IEventPropertyBag> m_pSinkProperties;
};


#define BD_DISPLAYNAME				L"DisplayName"
#define BD_BINDINGMANAGERMONIKER	L"BindingManagerMoniker"
#define BD_SOURCETYPES				L"SourceTypes"
#define BD_SOURCES					L"Sources"
#define BD_EVENTTYPES				L"EventTypes"
//#define BD_BINDINGS					L"Bindings"
#define BD_SINKCLASS				L"SinkClass"
#define BD_SINKPROPERTIES			L"SinkProperties"
#define BD_SOURCEPROPERTIES			L"SourceProperties"
#define BD_ENABLED					L"Enabled"
#define BD_EXPIRATION				L"Expiration"
#define BD_MAXFIRINGS				L"MaxFirings"


#define LOCK_TIMEOUT		15000
#define LOCK_TIMEOUT_SHORT	1000


class CLocker {
	public:
		CLocker(int iTimeout=LOCK_TIMEOUT) {
			m_hrRes = S_OK;
			m_iTimeout = iTimeout;
		};
		~CLocker() {
			Unlock();
		};
		HRESULT Lock(BOOL bWrite, IEventLock *pLock) {
			Unlock();
			m_bWrite = bWrite;
			m_pLock = pLock;
			if (m_pLock) {
				m_hrRes = m_bWrite ? m_pLock->LockWrite(m_iTimeout) : m_pLock->LockRead(m_iTimeout);
				if (!SUCCEEDED(m_hrRes)) {
					m_pLock.Release();
				}
			}
			return (m_hrRes);
		};
		HRESULT Lock(BOOL bWrite, IUnknown *pUnk) {
			CComQIPtr<IEventLock,&IID_IEventLock> pLock;

			if (pUnk) {
				pLock = pUnk;
			}
			return (Lock(bWrite,pLock));
		};
		HRESULT Unlock() {
			m_hrRes = S_OK;
			if (m_pLock) {
				m_hrRes = m_bWrite ? m_pLock->UnlockWrite() : m_pLock->UnlockRead();
				_ASSERTE(SUCCEEDED(m_hrRes));
			}
			m_pLock.Release();
			return (m_hrRes);
		}
		HRESULT LockWrite(IUnknown *pUnk) {
			return (Lock(TRUE,pUnk));
		};
		HRESULT LockRead(IUnknown *pUnk) {
			return (Lock(FALSE,pUnk));
		};
		HRESULT LockWrite(IEventLock *pLock) {
			return (Lock(TRUE,pLock));
		};
		HRESULT LockRead(IEventLock *pLock) {
			return (Lock(FALSE,pLock));
		};
		operator HRESULT() {
			return (m_hrRes);
		};

	private:
		CComPtr<IEventLock> m_pLock;
		BOOL m_bWrite;
		HRESULT m_hrRes;
		int m_iTimeout;
};


typedef HRESULT (*CreatorFunc)(LPVOID,REFIID,LPVOID *);


static HRESULT AddImpl1(BSTR pszName, CStringGUID& objGuid, CComVariant *pvarName) {

	if (!pvarName) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (pszName && *pszName) {
		objGuid = pszName;
		if (!objGuid) {
			return (E_INVALIDARG);
		}
	}
	if (!pszName || !*pszName || ((GUID&) objGuid == GUID_NULL)) {
		objGuid.CalcNew();
		if (!objGuid) {
			return (E_FAIL);
		}
	}
	*pvarName = (LPCOLESTR) objGuid;
	return (S_OK);
}


static HRESULT AddImpl2(IEventPropertyBag *pDatabase,
						CreatorFunc pfnCreator,
						REFIID iidDesired,
						CComVariant *pvarName,
						IUnknown **ppResult) {
	HRESULT hrRes;
	CComPtr<IEventDatabasePlugin> pPlugIn;
	CComPtr<IEventPropertyBag> pNewDatabase;

	if (ppResult) {
		*ppResult = NULL;
	}
	if (!pDatabase || !pfnCreator || !pvarName || (pvarName->vt != VT_BSTR)) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppResult) {
		return (E_POINTER);
	}
	hrRes = pfnCreator(NULL,IID_IEventDatabasePlugin,(LPVOID *) &pPlugIn);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pPlugIn);
	hrRes = pPlugIn->put_Name(pvarName->bstrVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPlugIn->put_Parent(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pNewDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewDatabase);
	hrRes = pPlugIn->put_Database(pNewDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPlugIn->QueryInterface(iidDesired,(LPVOID *) ppResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppResult);
	return (hrRes);
}


static HRESULT CreateSubPropertyBag(IEventPropertyBag *pBase,
									VARIANT *pvarName,
									IEventPropertyBag **ppResult,
									BOOL bCreate) {
	HRESULT hrRes;
	CComVariant varValue;
	BOOL bTmpCreate = bCreate;

	if (ppResult) {
		*ppResult = NULL;
	}
	if (!ppResult || !pBase || !pvarName) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if ((pvarName->vt == VT_EMPTY) || ((pvarName->vt == VT_BSTR) && (SysStringLen(pvarName->bstrVal) == 0))) {
		*ppResult = pBase;
		(*ppResult)->AddRef();
		return (S_OK);
	}
again:
	hrRes = pBase->Item(pvarName,&varValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if ((hrRes == S_FALSE) && !bTmpCreate) {
		if (bCreate) {
			_ASSERTE(FALSE);
			return (E_FAIL);
		}
		return (S_FALSE);
	}
	hrRes = varValue.ChangeType(VT_UNKNOWN);
	if (!SUCCEEDED(hrRes)) {
		if (!bTmpCreate || (pvarName->vt != VT_BSTR)) {
			return (hrRes);
		}
		bTmpCreate = FALSE;
		varValue.Clear();
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varValue.punkVal);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(varValue.punkVal);
		varValue.vt = VT_UNKNOWN;
		hrRes = pBase->Add(pvarName->bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		goto again;
	}
	hrRes = varValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) ppResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppResult);
	return (hrRes);
}


static HRESULT SetName(IEventPropertyBag *pBase, VARIANT *pvarSubKey, IEventDatabasePlugin *pObject) {
	HRESULT hrRes;
	VARIANT varTmp;
	long lIndex;

	if (!pBase || !pvarSubKey || !pObject) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (pvarSubKey->vt == VT_BSTR) {
		if (!pvarSubKey->bstrVal || !*pvarSubKey->bstrVal) {
			return (E_INVALIDARG);
		}
		return (pObject->put_Name(pvarSubKey->bstrVal));
	}
	VariantInit(&varTmp);
	hrRes = VariantChangeType(&varTmp,pvarSubKey,0,VT_I4);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	lIndex = varTmp.lVal;
	VariantClear(&varTmp);
	hrRes = pBase->Name(lIndex,&varTmp.bstrVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	varTmp.vt = VT_BSTR;
	hrRes = pObject->put_Name(varTmp.bstrVal);
	VariantClear(&varTmp);
	return (hrRes);
}


static HRESULT CreatePluggedInObject(CreatorFunc pfnCreator,
									 IEventPropertyBag *pBase,
									 VARIANT *pvarSubKey,
									 REFIID iidDesired,
									 IUnknown **ppUnkResult,
									 BOOL bCreate) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pDatabase;
	CComPtr<IEventDatabasePlugin> pinitResult;

	if (ppUnkResult) {
		*ppUnkResult = NULL;
	}
	if (!ppUnkResult) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!pfnCreator || !pBase || !pvarSubKey) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CreateSubPropertyBag(pBase,pvarSubKey,&pDatabase,bCreate);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if ((hrRes == S_FALSE) && !bCreate) {
		return (S_FALSE);
	}
	hrRes = pfnCreator(NULL,IID_IEventDatabasePlugin,(LPVOID *) &pinitResult);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pinitResult);
	hrRes = pinitResult->put_Database(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SetName(pBase,pvarSubKey,pinitResult);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pinitResult->QueryInterface(iidDesired,(LPVOID *) ppUnkResult);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkResult);
	return (hrRes);
}


static HRESULT CopyPropertyBagShallow(IEventPropertyBag *pIn, IEventPropertyBag **ppOut, BOOL bLock=TRUE) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;
	CComPtr<IEventPropertyBag> pTmp;
	CLocker lckRead;
	CLocker lckWrite;

	if (!pIn || !ppOut) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!*ppOut) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &pTmp);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(pTmp);
	} else {
		pTmp = *ppOut;
	}
	if (bLock) {
		if (!SUCCEEDED(lckRead.LockRead(pIn))) {
			if ((HRESULT) lckRead == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				if (!*ppOut) {
					*ppOut = pTmp;
					(*ppOut)->AddRef();
				}
				return (S_OK);
			}
			return ((HRESULT) lckRead);
		}
		if (*ppOut && !SUCCEEDED(lckWrite.LockWrite(pTmp))) {
			return ((HRESULT) lckWrite);
		}
	}
	hrRes = pIn->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkEnum);
	pEnum = pUnkEnum;
	if (!pEnum) {
		_ASSERTE(FALSE);
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varName;
		CComVariant varValue;

		varName.Clear();
		hrRes = pEnum->Next(1,&varName,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varName.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(varName.bstrVal);
		varValue.Clear();
		hrRes = pIn->Item(&varName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERT(hrRes!=S_FALSE);
		hrRes = pTmp->Add(varName.bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!*ppOut) {
		*ppOut = pTmp;
		(*ppOut)->AddRef();
	}
	return (S_OK);
}


static HRESULT CopyPropertyBag(IEventPropertyBag *pIn, IEventPropertyBag **ppOut, BOOL bLock=TRUE, int iTimeout=LOCK_TIMEOUT) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;
	CComPtr<IEventPropertyBag> pTmp;
	CLocker lckRead(iTimeout);
	CLocker lckWrite(iTimeout);

	if (!pIn || !ppOut) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!*ppOut) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &pTmp);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (hrRes);
		}
		_ASSERTE(pTmp);
	} else {
		pTmp = *ppOut;
	}
	if (bLock) {
		if (!SUCCEEDED(lckRead.LockRead(pIn))) {
			if ((HRESULT) lckRead == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				if (!*ppOut) {
					*ppOut = pTmp;
					(*ppOut)->AddRef();
				}
				return (S_OK);
			}
			return ((HRESULT) lckRead);
		}
		if (*ppOut && !SUCCEEDED(lckWrite.LockWrite(pTmp))) {
			return ((HRESULT) lckWrite);
		}
	}
	hrRes = pIn->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkEnum);
	pEnum = pUnkEnum;
	if (!pEnum) {
		_ASSERTE(FALSE);
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varName;
		CComVariant varValue;

		varName.Clear();
		hrRes = pEnum->Next(1,&varName,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varName.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(varName.bstrVal);
		varValue.Clear();
		hrRes = pIn->Item(&varName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERT(hrRes!=S_FALSE);
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (SUCCEEDED(hrRes)) {
			CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pValue;

			pValue = varValue.punkVal;
			if (pValue) {
				varValue.Clear();
				varValue.punkVal = NULL;
				hrRes = CopyPropertyBag(pValue,(IEventPropertyBag **) &varValue.punkVal,FALSE);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				varValue.vt = VT_UNKNOWN;
			}
		}
		hrRes = pTmp->Add(varName.bstrVal,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!*ppOut) {
		*ppOut = pTmp;
		(*ppOut)->AddRef();
	}
	return (S_OK);
}


static HRESULT SaveImpl(BSTR strName, CComPtr<IEventPropertyBag>& pDatabase, CComPtr<IEventPropertyBag>& pTmpDatabase, CComPtr<IEventPropertyBag>& pParent) {
	HRESULT hrRes;

	if (!strName) {
		return (E_POINTER);
	}
	if (!pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (pParent) {
		CComVariant varValue;

		if (!pTmpDatabase) {
			return (EVENTS_E_BADDATA);
		}
		varValue = pTmpDatabase;
		hrRes = pParent->Add(strName,&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		pTmpDatabase.Release();
		pDatabase.Release();
		varValue.Clear();
		hrRes = pParent->Item(&CComVariant(strName),&varValue);
		pParent.Release();
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			return (E_FAIL);
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = varValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) &pDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		return (S_OK);
	}
	if (!pTmpDatabase) {
		return (S_OK);
	}
	hrRes = CopyPropertyBagShallow(pTmpDatabase,&pDatabase.p);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pTmpDatabase.Release();
	return (S_OK);
}


static HRESULT NextOfUnknown(IUnknown *pUnkEnum,
							 IEventPropertyBag *pCollection,
							 IUnknown **apunkElt,
							 BSTR *astrNames,
							 ULONG celt,
							 ULONG *pceltFetched,
							 REFIID riidDesired) {
	CComQIPtr<IEnumString,&IID_IEnumString> pEnumString;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;
	DWORD dwIdx;
	VARIANT *pvarTmp;
	DWORD dwTmpStored;
	HRESULT hrRes;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (apunkElt) {
		memset(apunkElt,0,sizeof(IUnknown *)*celt);
	}
	if (astrNames) {
		memset(astrNames,0,sizeof(BSTR)*celt);
	}
	if (!apunkElt || !astrNames) {
		_ASSERTE(FALSE);
		return (E_OUTOFMEMORY);
	}
	if (!pUnkEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	dwTmpStored = 0;
	pEnumString = pUnkEnum;
	if (!pEnumString) {
		pEnumVARIANT = pUnkEnum;
		if (!pEnumVARIANT) {
			return (E_NOINTERFACE);
		}
		pvarTmp = (VARIANT *) _alloca(sizeof(VARIANT)*celt);
		if (!pvarTmp) {
			return (E_OUTOFMEMORY);
		}
		memset(pvarTmp,0,sizeof(pvarTmp[0])*celt);
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantInit(&pvarTmp[dwIdx]);
		}
	}
	while (dwTmpStored < celt) {
		DWORD dwTmpFetched;
		DWORD dwInnerTmpStored;
		HRESULT hrInnerRes;

		if (pEnumString) {
			hrRes = pEnumString->Next(celt-dwTmpStored,(LPWSTR *) &astrNames[dwTmpStored],&dwTmpFetched);
			if (SUCCEEDED(hrRes)) {
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					BSTR strTmp;

					strTmp = SysAllocString(astrNames[dwIdx]);
					if (astrNames[dwIdx] && !strTmp) {
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(astrNames[dwIdx]);
					astrNames[dwIdx] = strTmp;
				}
			}
		} else {
			hrRes = pEnumVARIANT->Next(celt-dwTmpStored,&pvarTmp[dwTmpStored],&dwTmpFetched);
			if (SUCCEEDED(hrRes)) {
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					hrInnerRes = VariantChangeType(&pvarTmp[dwTmpStored+dwIdx],
												   &pvarTmp[dwTmpStored+dwIdx],
												   0,
												   VT_BSTR);
					if (!SUCCEEDED(hrInnerRes)) {
						hrRes = hrInnerRes;
						break;
					}
					_ASSERTE(pvarTmp[dwTmpStored+dwIdx].bstrVal);
					astrNames[dwTmpStored+dwIdx] = pvarTmp[dwTmpStored+dwIdx].bstrVal;
					VariantInit(&pvarTmp[dwTmpStored+dwIdx]);
				}
				for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
					VariantClear(&pvarTmp[dwIdx]);
				}
			}
		}
		if (!SUCCEEDED(hrRes) || !dwTmpFetched) {
			break;
		}
		dwInnerTmpStored = 0;
		for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
			CComVariant varTmp;

			varTmp.Clear();
			hrRes = pCollection->Item(&CComVariant(astrNames[dwTmpStored+dwIdx]),&varTmp);
			if (!SUCCEEDED(hrRes)) {
				break;
			}
			hrInnerRes = varTmp.ChangeType(VT_UNKNOWN);
			if (SUCCEEDED(hrInnerRes)) {
				_ASSERTE(varTmp.punkVal);
				hrInnerRes = varTmp.punkVal->QueryInterface(riidDesired,
															(LPVOID *) &apunkElt[dwTmpStored+dwInnerTmpStored]);
			}
			_ASSERTE(!SUCCEEDED(hrInnerRes)||apunkElt[dwTmpStored+dwInnerTmpStored]);
			if (!SUCCEEDED(hrInnerRes)) {
				SysFreeString(astrNames[dwTmpStored+dwIdx]);
				memcpy(&astrNames[dwTmpStored+dwIdx],
					   &astrNames[dwTmpStored+dwIdx+1],
					   (dwTmpFetched-dwIdx-1)*sizeof(BSTR));
				memset(astrNames[dwTmpStored+dwTmpFetched-1],0,sizeof(BSTR));
				dwTmpFetched--;
				dwIdx--;
				dwInnerTmpStored--;
			}
			dwInnerTmpStored++;
		}
		dwTmpStored += dwInnerTmpStored;
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			SysFreeString(astrNames[dwIdx]);
			if (apunkElt[dwIdx]) {
				apunkElt[dwIdx]->Release();
				apunkElt[dwIdx] = NULL;
			}
		}
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpStored;
	}
	return ((dwTmpStored==celt)?S_OK:S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// IEventEnumBase
class ATL_NO_VTABLE IEventEnumBase
{
	public:
		virtual HRESULT SetEnum(IUnknown *punkEnum, IEventPropertyBag *pCollection) = 0;
		virtual IUnknown *GetEnum() = 0;
		virtual IEventPropertyBag *GetCollection() = 0;
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) = 0;
		HRESULT BaseSkip(ULONG celt);
		HRESULT BaseReset();
};


HRESULT IEventEnumBase::BaseSkip(ULONG celt) {
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;

	pEnumUnknown = GetEnum();
	if (pEnumUnknown) {
		return (pEnumUnknown->Skip(celt));
	}
	pEnumVARIANT = GetEnum();
	if (!pEnumVARIANT) {
		return (pEnumVARIANT->Skip(celt));
	}
	_ASSERTE(FALSE);
	return (E_NOINTERFACE);
}


HRESULT IEventEnumBase::BaseReset() {
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnumVARIANT;

	pEnumUnknown = GetEnum();
	if (pEnumUnknown) {
		return (pEnumUnknown->Reset());
	}
	pEnumVARIANT = GetEnum();
	if (!pEnumVARIANT) {
		return (pEnumVARIANT->Reset());
	}
	_ASSERTE(FALSE);
	return (E_NOINTERFACE);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBase
class ATL_NO_VTABLE CEventEnumUnknownBase :
	public IEventEnumBase,
	public IEnumUnknown
{
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, IUnknown **apunkElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();
		HRESULT STDMETHODCALLTYPE Clone(IEnumUnknown **ppEnum);
	protected:
		virtual HRESULT MakeNewEnumUnknown(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumUnknown **ppNewEnum) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBase


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Next(ULONG celt, IUnknown **apunkElt, ULONG *pceltFetched) {
	HRESULT hrRes;
	IEventPropertyBag **ppTmp;
	BSTR *pstrTmp;
	DWORD dwTmpFetched;
	DWORD dwIdx;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (apunkElt) {
		memset(apunkElt,0,sizeof(IUnknown *)*celt);
	}
	if (!apunkElt) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	ppTmp = (IEventPropertyBag **) _alloca(sizeof(IEventPropertyBag *)*celt);
	pstrTmp = (BSTR *) _alloca(sizeof(BSTR)*celt);
	hrRes = NextOfUnknown(GetEnum(),
						  GetCollection(),
						  (IUnknown **) ppTmp,
						  pstrTmp,
						  celt,
						  &dwTmpFetched,
						  IID_IEventPropertyBag);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
		hrRes = MakeNewObject(IID_IEventDatabasePlugin,(LPVOID *) &apunkElt[dwIdx]);
		if (SUCCEEDED(hrRes)) {
			_ASSERTE(apunkElt[dwIdx]);
			hrRes = ((IEventDatabasePlugin *) apunkElt[dwIdx])->put_Database(ppTmp[dwIdx]);
			if (SUCCEEDED(hrRes)) {
				hrRes = ((IEventDatabasePlugin *) apunkElt[dwIdx])->put_Name(pstrTmp[dwIdx]);
			}
		}
		if (!SUCCEEDED(hrRes)) {
			for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
				if (apunkElt[dwIdx]) {
					apunkElt[dwIdx]->Release();
					apunkElt[dwIdx] = NULL;
				}
			}
			break;
		}
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		SysFreeString(pstrTmp[dwIdx]);
		if (ppTmp[dwIdx]) {
			ppTmp[dwIdx]->Release();
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpFetched;
	}
	return ((dwTmpFetched<celt)?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Skip(ULONG celt) {

	return (BaseSkip(celt));
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Reset() {

	return (BaseReset());
}


HRESULT STDMETHODCALLTYPE CEventEnumUnknownBase::Clone(IEnumUnknown **ppEnum) {
	HRESULT hrRes;
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pThisEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pThisEnumVARIANT;
	CComPtr<IUnknown> pClone;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	pThisEnumUnknown = GetEnum();
	if (pThisEnumUnknown) {
		hrRes = pThisEnumUnknown->Clone((IEnumUnknown **) &pClone);
	} else {
		pThisEnumVARIANT = GetEnum();
		if (pThisEnumVARIANT) {
			hrRes = pThisEnumVARIANT->Clone((IEnumVARIANT **) &pClone);
		} else {
			_ASSERTE(FALSE);
			hrRes = E_NOINTERFACE;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pClone);
	hrRes = MakeNewEnumUnknown(pClone,GetCollection(),ppEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumUnknownBaseImpl
template <class ObjectClass, class EnumClass>
class ATL_NO_VTABLE CEventEnumUnknownBaseImpl :
	public CEventEnumUnknownBase
{
	protected:
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) {

			return (CComObject<ObjectClass>::_CreatorClass::CreateInstance(NULL,iidDesired,ppvObject));
		}
		virtual HRESULT MakeNewEnumUnknown(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumUnknown **ppNewEnum) {
			HRESULT hrRes;
			CComObject<EnumClass> *pTmp;

			if (ppNewEnum) {
				*ppNewEnum = NULL;
			}
			if (!ppNewEnum || !pContained || !pCollection) {
				_ASSERTE(FALSE);
				return (E_POINTER);
			}
			hrRes = CComObject<EnumClass>::CreateInstance(&pTmp);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(pTmp);
			pTmp->AddRef();
			hrRes = pTmp->SetEnum(pContained,pCollection);
			if (SUCCEEDED(hrRes)) {
				hrRes = pTmp->QueryInterface(IID_IEnumUnknown,(LPVOID *) ppNewEnum);
				_ASSERTE(!SUCCEEDED(hrRes)||*ppNewEnum);
			}
			pTmp->Release();
			return (hrRes);
		};
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBase
class ATL_NO_VTABLE CEventEnumVARIANTBase :
	public IEventEnumBase,
	public IEnumVARIANT
{
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);
	protected:
		virtual HRESULT MakeNewEnumVARIANT(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumVARIANT **ppNewEnum) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBase


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched) {
	HRESULT hrRes;
	IEventPropertyBag **ppTmp;
	BSTR *pstrTmp;
	DWORD dwTmpFetched;
	DWORD dwIdx;

	if (pceltFetched) {
		*pceltFetched = 0;
	}
	if (avarElt) {
		memset(avarElt,0,sizeof(avarElt[0])*celt);
	}
	if (!avarElt) {
		return (E_POINTER);
	}
#if 0
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		VariantInit(&avarElt[dwIdx]);
	}
#endif
	if (!celt) {
		return (S_OK);
	}
	ppTmp = (IEventPropertyBag **) _alloca(sizeof(IEventPropertyBag *)*celt);
	pstrTmp = (BSTR *) _alloca(sizeof(BSTR)*celt);
	hrRes = NextOfUnknown(GetEnum(),
						  GetCollection(),
						  (IUnknown **) ppTmp,
						  pstrTmp,
						  celt,
						  &dwTmpFetched,
						  IID_IEventPropertyBag);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
		hrRes = MakeNewObject(IID_IEventDatabasePlugin,(LPVOID *) &avarElt[dwIdx].punkVal);
		if (SUCCEEDED(hrRes)) {
			_ASSERTE(avarElt[dwIdx].punkVal);
			avarElt[dwIdx].vt = VT_UNKNOWN;
			hrRes = ((IEventDatabasePlugin *) avarElt[dwIdx].punkVal)->put_Database(ppTmp[dwIdx]);
			if (SUCCEEDED(hrRes)) {
				hrRes = ((IEventDatabasePlugin *) avarElt[dwIdx].punkVal)->put_Name(pstrTmp[dwIdx]);
			}
		}
		if (!SUCCEEDED(hrRes)) {
			for (dwIdx=0;dwIdx<dwTmpFetched;dwIdx++) {
				VariantClear(&avarElt[dwIdx]);
			}
			break;
		}
		if (SUCCEEDED(hrRes)) {
			hrRes = VariantChangeType(&avarElt[dwIdx],&avarElt[dwIdx],0,VT_DISPATCH);
			_ASSERTE(SUCCEEDED(hrRes));
		}
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		SysFreeString(pstrTmp[dwIdx]);
		if (ppTmp[dwIdx]) {
			ppTmp[dwIdx]->Release();
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pceltFetched) {
		*pceltFetched = dwTmpFetched;
	}
	return ((dwTmpFetched<celt)?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Skip(ULONG celt) {

	return (BaseSkip(celt));
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Reset() {

	return (BaseReset());
}


HRESULT STDMETHODCALLTYPE CEventEnumVARIANTBase::Clone(IEnumVARIANT **ppEnum) {
	HRESULT hrRes;
	CComQIPtr<IEnumUnknown,&IID_IEnumUnknown> pThisEnumUnknown;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pThisEnumVARIANT;
	CComPtr<IUnknown> pClone;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		return (E_POINTER);
	}
	pThisEnumUnknown = GetEnum();
	if (pThisEnumUnknown) {
		hrRes = pThisEnumUnknown->Clone((IEnumUnknown **) &pClone);
	} else {
		pThisEnumVARIANT = GetEnum();
		if (pThisEnumVARIANT) {
			hrRes = pThisEnumVARIANT->Clone((IEnumVARIANT **) &pClone);
		} else {
			_ASSERTE(FALSE);
			hrRes = E_NOINTERFACE;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pClone);
	hrRes = MakeNewEnumVARIANT(pClone,GetCollection(),ppEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventEnumVARIANTBaseImpl
template <class ObjectClass, class EnumClass>
class ATL_NO_VTABLE CEventEnumVARIANTBaseImpl :
	public CEventEnumVARIANTBase
{
	protected:
		virtual HRESULT MakeNewObject(REFIID iidDesired, LPVOID *ppvObject) {

			return (CComObject<ObjectClass>::_CreatorClass::CreateInstance(NULL,iidDesired,ppvObject));
		}
		virtual HRESULT MakeNewEnumVARIANT(IUnknown *pContained,
										   IEventPropertyBag *pCollection,
										   IEnumVARIANT **ppNewEnum) {
			HRESULT hrRes;
			CComObject<EnumClass> *pTmp;

			if (ppNewEnum) {
				*ppNewEnum = NULL;
			}
			if (!ppNewEnum || !pContained || !pCollection) {
				_ASSERTE(FALSE);
				return (E_POINTER);
			}
			hrRes = CComObject<EnumClass>::CreateInstance(&pTmp);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(pTmp);
			pTmp->AddRef();
			hrRes = pTmp->SetEnum(pContained,pCollection);
			if (SUCCEEDED(hrRes)) {
				hrRes = pTmp->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppNewEnum);
				_ASSERTE(!SUCCEEDED(hrRes)||*ppNewEnum);
			}
			pTmp->Release();
			return (hrRes);
		};
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinksEnum
class ATL_NO_VTABLE CEventTypeSinksEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public IEnumVARIANT,
	public IEnumString
{
	DEBUG_OBJECT_DEF(CEventTypeSinksEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Load(IEventTypeSinks *pSinks, DWORD dwIdx);
		static HRESULT Create(IEventTypeSinks *pSinks,
							  DWORD dwIdx,
							  REFIID iidDesired,
							  LPVOID *ppvResult);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypeSinksEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypeSinksEnum Class",
//								   L"Event.TypeSinksEnum.1",
//								   L"Event.TypeSinksEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypeSinksEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumString)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEnumXXXX
	public:
		HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
		HRESULT STDMETHODCALLTYPE Reset();

	// IEnumVARIANT
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **ppEnum);

	// IEnumString
	public:
		HRESULT STDMETHODCALLTYPE Next(ULONG celt, LPWSTR *apszElt, ULONG *pceltFetched);
		HRESULT STDMETHODCALLTYPE Clone(IEnumString **ppEnum);

	private:
		DWORD m_dwIdx;
		CComPtr<IEventTypeSinks> m_pSinks;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinksEnum


HRESULT CEventTypeSinksEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinksEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypeSinksEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypeSinksEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinksEnum::FinalRelease");

	m_pSinks.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypeSinksEnum::Load(IEventTypeSinks *pSinks, DWORD dwIdx) {
	DEBUG_OBJECT_CHECK

	if (!pSinks) {
		return (E_POINTER);
	}
	m_pSinks = pSinks;
	m_dwIdx = dwIdx;
	return (S_OK);
}


HRESULT CEventTypeSinksEnum::Create(IEventTypeSinks *pSinks,
									DWORD dwIdx,
									REFIID iidDesired,
									LPVOID *ppvResult) {
	HRESULT hrRes;
	CComObject<CEventTypeSinksEnum> *pEnum;

	if (ppvResult) {
		*ppvResult = NULL;
	}
	if (!pSinks) {
		return (E_FAIL);
	}
	if (!ppvResult) {
		return (E_POINTER);
	}
	hrRes = CComObject<CEventTypeSinksEnum>::CreateInstance(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pEnum->AddRef();
	hrRes = pEnum->Load(pSinks,dwIdx);
	if (SUCCEEDED(hrRes)) {
		hrRes = pEnum->QueryInterface(IID_IEnumVARIANT,ppvResult);
	}
	pEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Skip(ULONG celt) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	long lCount;

	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	hrRes = m_pSinks->get_Count(&lCount);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(lCount>=0);
	if (lCount < 0) {
		return (E_FAIL);
	}
	m_dwIdx += celt;
	if (m_dwIdx > (DWORD) lCount) {
		m_dwIdx = lCount;
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Reset() {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	m_dwIdx = 0;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Next(ULONG celt, VARIANT *avarElt, ULONG *pceltFetched) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	DWORD dwIdx;

	if (avarElt) {
		memset(avarElt,0,sizeof(avarElt[0])*celt);
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantInit(&avarElt[dwIdx]);
		}
	}
	if (pceltFetched) {
		*pceltFetched = 0;
	}
	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	if (!avarElt) {
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		hrRes = m_pSinks->Item(m_dwIdx+dwIdx+1,&avarElt[dwIdx].bstrVal);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		avarElt[dwIdx].vt = VT_BSTR;
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			VariantClear(&avarElt[dwIdx]);
		}
		return (hrRes);
	}
	m_dwIdx += dwIdx;
	if (pceltFetched) {
		*pceltFetched = dwIdx;
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Clone(IEnumVARIANT **ppEnum) {
	DEBUG_OBJECT_CHECK

	return (Create(m_pSinks,m_dwIdx,IID_IEnumVARIANT,(LPVOID *) ppEnum));
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Next(ULONG celt, LPWSTR *apszElt, ULONG *pceltFetched) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	DWORD dwIdx;

	if (apszElt) {
		memset(apszElt,0,sizeof(*apszElt)*celt);
	}
	if (pceltFetched) {
		*pceltFetched = 0;
	}
	_ASSERTE(m_pSinks);
	if (!m_pSinks) {
		return (E_FAIL);
	}
	if (!apszElt) {
		return (E_POINTER);
	}
	if (!celt) {
		return (S_OK);
	}
	for (dwIdx=0;dwIdx<celt;dwIdx++) {
		CComBSTR bstrVal;

		bstrVal.Empty();
		hrRes = m_pSinks->Item(m_dwIdx+dwIdx+1,&bstrVal);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		apszElt[dwIdx] = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(bstrVal)+1));
		if (!apszElt[dwIdx]) {
			hrRes = E_OUTOFMEMORY;
			break;
		}
		wcscpy(apszElt[dwIdx],bstrVal);
	}
	if (!SUCCEEDED(hrRes)) {
		for (dwIdx=0;dwIdx<celt;dwIdx++) {
			CoTaskMemFree(apszElt[dwIdx]);
			apszElt[dwIdx] = NULL;
		}
		return (hrRes);
	}
	m_dwIdx += dwIdx;
	if (pceltFetched) {
		*pceltFetched = dwIdx;
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinksEnum::Clone(IEnumString **ppEnum) {
	DEBUG_OBJECT_CHECK

	return (Create(m_pSinks,m_dwIdx,IID_IEnumString,(LPVOID *) ppEnum));
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinks
class ATL_NO_VTABLE CEventTypeSinks :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventTypeSinks, &CLSID_CEventTypeSinks>,
	public IDispatchImpl<IEventTypeSinks, &IID_IEventTypeSinks, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventTypeSinks)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Load(CATID catid);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypeSinks);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypeSinks Class",
//								   L"Event.TypeSinks.1",
//								   L"Event.TypeSinks");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypeSinks)
		COM_INTERFACE_ENTRY(IEventTypeSinks)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventTypeSinks)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventTypeSinks
	public:
		HRESULT STDMETHODCALLTYPE Item(long lIndex, BSTR *pstrTypeSink);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszTypeSink);
		HRESULT STDMETHODCALLTYPE Remove(BSTR pszTypeSink);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CATID m_catid;
		DWORD m_dwProgID;
		CComBSTR *m_astrProgID;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypeSinks


HRESULT CEventTypeSinks::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinks::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_dwProgID = 0;
	m_astrProgID = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypeSinks")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypeSinks::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypeSinks::FinalRelease");

	_ASSERTE((!m_dwProgID&&!m_astrProgID)||(m_dwProgID&&m_astrProgID));
	delete[] m_astrProgID;
	m_dwProgID = 0;
	m_astrProgID = NULL;
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypeSinks::Load(CATID catid) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CComPtr<IEnumCLSID> pEnum;
	DWORD dwAlloc = 0;
	CLSID *pclsid = NULL;
	DWORD dwTmp;

	m_catid = GUID_NULL;
	delete[] m_astrProgID;
	m_dwProgID = 0;
	m_astrProgID = NULL;
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatInfo->EnumClassesOfCategories(1,(GUID *) &catid,-1,NULL,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = S_FALSE;
	while (1) {

		dwTmp = (hrRes==S_FALSE) ? 1 : dwAlloc;
		if (!MyReallocInPlace(&pclsid,sizeof(*pclsid)*(dwAlloc+dwTmp))) {
		    if (pclsid) MyFree(pclsid);
			return (E_OUTOFMEMORY);
		}
		hrRes = pEnum->Next(dwTmp,&pclsid[dwAlloc],&dwTmp);
		// Do not alter hrRes between here and the bottom of the loop!  The first statement
		// in the loop relies on hrRes having the result from this call to IEnumCLSID::Next.
		if (!SUCCEEDED(hrRes)) {
			MyFree(pclsid);
			return (hrRes);
		}
		if (!dwTmp) {
			break;
		}
		dwAlloc += dwTmp;
	}
	m_astrProgID = new CComBSTR[dwAlloc];
	if (!m_astrProgID) {
		MyFree(pclsid);
		return (E_OUTOFMEMORY);
	}
	for (dwTmp=0,m_dwProgID=0;dwTmp<dwAlloc;dwTmp++) {
		LPOLESTR pszTmp;

		hrRes = ProgIDFromCLSID(pclsid[dwTmp],&pszTmp);
		if (SUCCEEDED(hrRes)) {
			m_astrProgID[m_dwProgID] = pszTmp;
			CoTaskMemFree(pszTmp);
			m_dwProgID++;
		}
	}
	MyFree(pclsid);
	m_catid = catid;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Item(long lIndex, BSTR *pstrTypeSink) {
	DEBUG_OBJECT_CHECK

	if (pstrTypeSink) {
		*pstrTypeSink = NULL;
	}
	if (!pstrTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	if (lIndex < 1) {
		return (E_INVALIDARG);
	}
	if ((DWORD) lIndex > m_dwProgID) {
		return (S_FALSE);
	}
	*pstrTypeSink = SysAllocString(m_astrProgID[lIndex]);
	if (!pstrTypeSink) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Add(BSTR pszTypeSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	CComPtr<ICatRegister> pCatReg;

	if (!pszTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	objGuid.CalcFromProgID(pszTypeSink);
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassImplCategories(objGuid,1,&m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = Load(m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::Remove(BSTR pszTypeSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	CComPtr<ICatRegister> pCatReg;

	if (!pszTypeSink) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	objGuid.CalcFromProgID(pszTypeSink);
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassImplCategories(objGuid,1,&m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = Load(m_catid);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	*plCount = m_dwProgID;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypeSinks::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	_ASSERTE(m_catid!=GUID_NULL);
	if (m_catid == GUID_NULL) {
		return (E_FAIL);
	}
	return (CEventTypeSinksEnum::Create(this,0,IID_IEnumVARIANT,(LPVOID *) ppUnkEnum));
}


/////////////////////////////////////////////////////////////////////////////
// CEventType
class ATL_NO_VTABLE CEventType :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventType, &CLSID_CEventType>,
	public IDispatchImpl<IEventType, &IID_IEventType, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventType)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventType);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventType Class",
//								   L"Event.Type.1",
//								   L"Event.Type");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventType)
		COM_INTERFACE_ENTRY(IEventType)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventType)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventType
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE get_Sinks(IEventTypeSinks **ppTypeSinks);

	private:
		CComPtr<ICatInformation> m_pCatInfo;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventType


HRESULT CEventType::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventType::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &m_pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pCatInfo);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventType")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventType::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventType::FinalRelease");

	m_pCatInfo.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventType::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventType::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	LPOLESTR pszDesc;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	hrRes = m_pCatInfo->GetCategoryDesc(CStringGUID(m_strName),LOCALE_USER_DEFAULT,&pszDesc);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pstrDisplayName = SysAllocString(pszDesc);
	CoTaskMemFree(pszDesc);
	if (!pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventType::get_Sinks(IEventTypeSinks **ppTypeSinks) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComObject<CEventTypeSinks> *pSinks;

	if (ppTypeSinks) {
		*ppTypeSinks = NULL;
	}
	if (!ppTypeSinks) {
		return (E_POINTER);
	}
	hrRes = CComObject<CEventTypeSinks>::CreateInstance(&pSinks);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pSinks->AddRef();
	hrRes = pSinks->Load(CStringGUID(m_strName));
	if (SUCCEEDED(hrRes)) {
		hrRes = pSinks->QueryInterface(IID_IEventTypeSinks,(LPVOID *) ppTypeSinks);
	}
	pSinks->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypesEnum
class ATL_NO_VTABLE CEventTypesEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventTypesEnum, &CLSID_CEventTypesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventType,CEventTypesEnum>,
	public CEventEnumUnknownBaseImpl<CEventType,CEventTypesEnum>
{
	DEBUG_OBJECT_DEF(CEventTypesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypesEnum Class",
//								   L"Event.EventTypesEnum.1",
//								   L"Event.EventTypesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypesEnum


HRESULT CEventTypesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventTypesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventTypesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventTypes
class ATL_NO_VTABLE CEventTypes :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventTypes, &CLSID_CEventTypes>,
	public IDispatchImpl<IEventTypes, &IID_IEventTypes, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventTypes)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventTypes);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventTypes Class",
//								   L"Event.EventTypes.1",
//								   L"Event.EventTypes");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventTypes)
		COM_INTERFACE_ENTRY(IEventTypes)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventTypes)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventTypes
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventType **ppEventType);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszEventType);
		HRESULT STDMETHODCALLTYPE Remove(BSTR pszEventType);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<ICatInformation> m_pCatInfo;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventTypes


HRESULT CEventTypes::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypes::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &m_pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pCatInfo);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventTypes")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventTypes::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventTypes::FinalRelease");

	m_pCatInfo.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventTypes::Item(VARIANT *pvarDesired, IEventType **ppEventType) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventType>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventType,
								  (IUnknown **) ppEventType,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventTypes::Add(BSTR pszEventType) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CStringGUID objGuid;
	LPOLESTR pszDesc;
	CComPtr<IEventPropertyBag> pdictTmp;

	if (!m_pCatInfo) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!pszEventType) {
		return (E_POINTER);
	}
	objGuid = pszEventType;
	if (!objGuid) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = m_pCatInfo->GetCategoryDesc(objGuid,LOCALE_USER_DEFAULT,&pszDesc);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	CoTaskMemFree(pszDesc);
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pDatabase->Add((LPOLESTR) ((LPCOLESTR) objGuid),&CComVariant(pdictTmp));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventTypes::Remove(BSTR pszEventType) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(&CComVariant(pszEventType)));
}


HRESULT STDMETHODCALLTYPE CEventTypes::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventTypes::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventTypesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkTmp);
	hrRes = CComObject<CEventTypesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSource
class ATL_NO_VTABLE CEventSource :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSource, &CLSID_CEventSource>,
	public IDispatchImpl<IEventSource, &IID_IEventSource, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSource)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSource);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSource Class",
//								   L"Event.Source.1",
//								   L"Event.Source");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSource)
		COM_INTERFACE_ENTRY(IEventSource)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSource)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSource
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_BindingManagerMoniker(IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE put_BindingManagerMoniker(IUnknown *pUnkMoniker);
		HRESULT STDMETHODCALLTYPE putref_BindingManagerMoniker(IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE GetBindingManager(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE get_Properties(IEventPropertyBag **ppProperties);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSource


HRESULT CEventSource::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSource::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSource")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSource::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSource::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSource::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventSource::get_BindingManagerMoniker(IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;

	if (ppUnkMoniker) {
		*ppUnkMoniker = NULL;
	}
	if (!ppUnkMoniker) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_BINDINGMANAGERMONIKER),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (EVENTS_E_BADDATA);
	}
	hrRes = varPropValue.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,varPropValue.bstrVal,&dwEaten,(IMoniker **) ppUnkMoniker);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::put_BindingManagerMoniker(IUnknown *pUnkMoniker) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropName;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (pUnkMoniker) {
		CComBSTR strString;
		CComPtr<IBindCtx> pBindCtx;
		CComQIPtr<IMoniker,&IID_IMoniker> pMoniker = pUnkMoniker;
		LPOLESTR pszDisplayName;

		if (!pMoniker) {
			return (E_NOINTERFACE);
		}
		hrRes = CreateBindCtx(0,&pBindCtx);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pMoniker->GetDisplayName(pBindCtx,NULL,&pszDisplayName);
		if (!SUCCEEDED(hrRes)) {
			CoTaskMemFree(pszDisplayName);
			return (hrRes);
		}
		varPropValue = pszDisplayName;
		CoTaskMemFree(pszDisplayName);
	} else {
		varPropValue = L"";
	}
	varPropName = BD_BINDINGMANAGERMONIKER;
	hrRes = m_pTmpDatabase->Add(BD_BINDINGMANAGERMONIKER,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::putref_BindingManagerMoniker(IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK

	if (!ppUnkMoniker) {
		return (E_POINTER);
	}
	return (put_BindingManagerMoniker(*ppUnkMoniker));
}


HRESULT STDMETHODCALLTYPE CEventSource::GetBindingManager(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkMon;
	CComQIPtr<IMoniker,&IID_IMoniker> pMon;
	CComPtr<IBindCtx> pBindCtx;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!ppBindingManager) {
		return (E_POINTER);
	}
	hrRes = get_BindingManagerMoniker(&pUnkMon);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pMon = pUnkMon;
	if (!pMon) {
		return (E_NOINTERFACE);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMon->BindToObject(pBindCtx,NULL,IID_IEventBindingManager,(LPVOID *) ppBindingManager);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSource::get_Properties(IEventPropertyBag **ppProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (ppProperties) {
		*ppProperties = NULL;
	}
	if (!ppProperties) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	*ppProperties = m_pTmpDatabase;
	(*ppProperties)->AddRef();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSource::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourcesEnum
class ATL_NO_VTABLE CEventSourcesEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSourcesEnum, &CLSID_CEventSourcesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventSource,CEventSourcesEnum>,
	public CEventEnumUnknownBaseImpl<CEventSource,CEventSourcesEnum>
{
	DEBUG_OBJECT_DEF(CEventSourcesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourcesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourcesEnum Class",
//								   L"Event.SourcesEnum.1",
//								   L"Event.SourcesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourcesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourcesEnum


HRESULT CEventSourcesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourcesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourcesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourcesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourcesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventSourcesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSources
class ATL_NO_VTABLE CEventSources :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSources, &CLSID_CEventSources>,
	public IDispatchImpl<IEventSources, &IID_IEventSources, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSources)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSources);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSources Class",
//								   L"Event.Sources.1",
//								   L"Event.Sources");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSources)
		COM_INTERFACE_ENTRY(IEventSources)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSources)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSources
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventSource **ppSource);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszSource, IEventSource **ppSource);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSources


HRESULT CEventSources::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSources::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSources")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSources::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSources::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSources::Item(VARIANT *pvarDesired, IEventSource **ppSource) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSource>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventSource,
								  (IUnknown **) ppSource,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventSources::Add(BSTR pszSource, IEventSource **ppSource) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppSource) {
		*ppSource = NULL;
	}
	hrRes = AddImpl1(pszSource,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppSource);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventSource>::_CreatorClass::CreateInstance,
					 IID_IEventSource,
					 &varName,
					 (IUnknown **) ppSource);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppSource);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSources::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventSources::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventSources::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventSourcesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pUnkTmp);
	hrRes = CComObject<CEventSourcesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceType
class ATL_NO_VTABLE CEventSourceType :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSourceType, &CLSID_CEventSourceType>,
	public IDispatchImpl<IEventSourceType, &IID_IEventSourceType, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSourceType)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceType);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceType Class",
//								   L"Event.Source.1",
//								   L"Event.Source");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceType)
		COM_INTERFACE_ENTRY(IEventSourceType)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSourceType)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSourceType
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_EventTypes(IEventTypes **ppEventTypes);
		HRESULT STDMETHODCALLTYPE get_Sources(IEventSources **ppSources);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceType


HRESULT CEventSourceType::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceType::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceType")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceType::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceType::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	_ASSERTE(m_strName);
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		_ASSERTE(m_pTmpDatabase);
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	} else {
		varPropValue = L"";
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSourceType::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_EventTypes(IEventTypes **ppEventTypes) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (CreatePluggedInObject(CComObject<CEventTypes>::_CreatorClass::CreateInstance,
								  m_pTmpDatabase?m_pTmpDatabase:m_pDatabase,
								  &CComVariant(BD_EVENTTYPES),
								  IID_IEventTypes,
								  (IUnknown **) ppEventTypes,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::get_Sources(IEventSources **ppSources) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (CreatePluggedInObject(CComObject<CEventSources>::_CreatorClass::CreateInstance,
								  m_pTmpDatabase?m_pTmpDatabase:m_pDatabase,
								  &CComVariant(BD_SOURCES),
								  IID_IEventSources,
								  (IUnknown **) ppSources,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventSourceType::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypesEnum
class ATL_NO_VTABLE CEventSourceTypesEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSourceTypesEnum, &CLSID_CEventSourceTypesEnum>,
	public CEventEnumVARIANTBaseImpl<CEventSourceType,CEventSourceTypesEnum>,
	public CEventEnumUnknownBaseImpl<CEventSourceType,CEventSourceTypesEnum>
{
	DEBUG_OBJECT_DEF(CEventSourceTypesEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceTypesEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceTypesEnum Class",
//								   L"Event.SourcesEnum.1",
//								   L"Event.SourcesEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceTypesEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypesEnum


HRESULT CEventSourceTypesEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypesEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceTypesEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceTypesEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypesEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventSourceTypesEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypes
class ATL_NO_VTABLE CEventSourceTypes :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventSourceTypes, &CLSID_CEventSourceTypes>,
	public IDispatchImpl<IEventSourceTypes, &IID_IEventSourceTypes, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventSourceTypes)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventSourceTypes);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventSourceTypes Class",
//								   L"Event.SourceTypes.1",
//								   L"Event.SourceTypes");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventSourceTypes)
		COM_INTERFACE_ENTRY(IEventSourceTypes)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventSourceTypes)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventSourceTypes
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventSourceType **ppSourceType);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszSourceType, IEventSourceType **ppSourceType);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventSourceTypes


HRESULT CEventSourceTypes::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypes::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventSourceTypes")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventSourceTypes::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventSourceTypes::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Item(VARIANT *pvarDesired, IEventSourceType **ppSourceType) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSourceType>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventSourceType,
								  (IUnknown **) ppSourceType,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Add(BSTR pszSourceType, IEventSourceType **ppSourceType) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppSourceType) {
		*ppSourceType = NULL;
	}
	hrRes = AddImpl1(pszSourceType,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppSourceType);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventSourceType>::_CreatorClass::CreateInstance,
					 IID_IEventSourceType,
					 &varName,
					 (IUnknown **) ppSourceType);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppSourceType);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventSourceTypes::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventSourceTypesEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CEventSourceTypesEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventManager


HRESULT CEventManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventManager::FinalConstruct");
	HRESULT hrRes = S_OK;
	CComPtr<IEventPropertyBag> pDatabaseRoot;
	CComPtr<IEventPropertyBag> pDatabase;

	ADD_DEBUG_OBJECT("CEventManager")
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(m_pUnkMarshaler);
	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabaseRoot);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(pDatabaseRoot);
	hrRes = CreateSubPropertyBag(pDatabaseRoot,&CComVariant(L"LM/EventManager"),&pDatabase,TRUE);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	_ASSERTE(pDatabase);
	hrRes = put_Database(pDatabase);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventManager::get_SourceTypes(IEventSourceTypes **ppSourceTypes) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventSourceTypes>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  &CComVariant(BD_SOURCETYPES),
								  IID_IEventSourceTypes,
								  (IUnknown **) ppSourceTypes,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventManager::CreateSink(IEventBinding *pEventBinding,
								   	 				IEventDeliveryOptions *pDeliveryOptions,
													IUnknown **ppUnkSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strSinkClass;
	CComPtr<IEventPropertyBag> pSinkProperties;
	CComQIPtr<CCreateSinkInfo,&IID_ICreateSinkInfo> pInfo;
	CLocker lck(LOCK_TIMEOUT);
	CComPtr<IUnknown> pSink;
	CComQIPtr<IEventIsCacheable,&IID_IEventIsCacheable> pCache;
	VARIANT varSinkClass;
	VARIANT_BOOL bEnabled;

	if (ppUnkSink) {
		*ppUnkSink = NULL;
	}
	_ASSERTE(m_pLock);
	if (!ppUnkSink || !pEventBinding) {
		return (E_POINTER);
	}
	hrRes = lck.LockRead(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pInfo = pEventBinding;
	if (pInfo && pInfo->m_bInit) {
again:
		lck.Unlock();
		if (!pInfo->m_bEnabled) {
			return (EVENTS_E_DISABLED);
		}
		if (pInfo->m_pSink) {
			*ppUnkSink = pInfo->m_pSink;
			(*ppUnkSink)->AddRef();
			return (S_OK);
		}
		if (pSink) {
			*ppUnkSink = pSink;
			(*ppUnkSink)->AddRef();
			return (S_OK);
		}
		varSinkClass.vt = VT_BYREF|VT_BSTR;
		varSinkClass.pbstrVal = &pInfo->m_strSinkClass;
		hrRes = SEOCreateObjectEx(&varSinkClass,
								  pEventBinding,
								  pInfo->m_pSinkProperties,
								  IID_IUnknown,
								  pDeliveryOptions,
								  ppUnkSink);
		return (hrRes);
	}
	lck.Unlock();
	hrRes = pEventBinding->get_SinkProperties(&pSinkProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_SinkClass(&strSinkClass);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_Enabled(&bEnabled);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (bEnabled) {
		varSinkClass.vt = VT_BYREF|VT_BSTR;
		varSinkClass.pbstrVal = &strSinkClass;
		hrRes = SEOCreateObjectEx(&varSinkClass,
								  pEventBinding,
								  pSinkProperties,
								  IID_IUnknown,
								  pDeliveryOptions,
								  &pSink);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	if (!pInfo) {
		if (!bEnabled) {
			return (EVENTS_E_DISABLED);
		}
		*ppUnkSink = pSink;
		(*ppUnkSink)->AddRef();
		return (hrRes);
	}
	hrRes = lck.LockWrite(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pInfo->m_bInit) {
		pSink.Release();
		goto again;
	}
	pInfo->m_bInit = TRUE;
	pInfo->m_strSinkClass.Attach(strSinkClass.Detach());
	pInfo->m_bEnabled = bEnabled ? TRUE : FALSE;
	if (pInfo->m_bEnabled) {
		pCache = pSink;
		if (pCache && (pCache->IsCacheable() == S_OK)) {
			pInfo->m_pSink = pSink;
		}
	}
	pInfo->m_pSinkProperties = pSinkProperties;
	goto again;
}


#if 0

HRESULT STDMETHODCALLTYPE CEventManager::CreateSink(IEventBinding *pEventBinding,
								   	 				IEventDeliveryOptions *pDeliveryOptions,
													IUnknown **ppUnkSink) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strProgID;
	CComPtr<IEventPropertyBag> pProperties;

	if (ppUnkSink) {
		*ppUnkSink = NULL;
	}
	if (!ppUnkSink || !pEventBinding) {
		return (E_POINTER);
	}
	hrRes = pEventBinding->get_SinkProperties(&pProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventBinding->get_SinkClass(&strProgID);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOCreateObject(&CComVariant(strProgID),pEventBinding,pProperties,IID_IUnknown,ppUnkSink);
	return (hrRes);
}

#endif


/////////////////////////////////////////////////////////////////////////////
// CEventBinding
class ATL_NO_VTABLE CEventBinding :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventBinding, &CLSID_CEventBinding>,
	public IDispatchImpl<IEventBinding, &IID_IEventBinding, &LIBID_SEOLib>,
	public CEventDatabasePlugin,
	public CCreateSinkInfo
{
	DEBUG_OBJECT_DEF(CEventBinding)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT GetProperties(LPCOLESTR pszPropName, IEventPropertyBag **ppProperties);
		HRESULT CopyForWrite();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBinding);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBinding Class",
//								   L"Event.Binding.1",
//								   L"Event.Binding");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBinding)
		COM_INTERFACE_ENTRY(IEventBinding)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBinding)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_IID(IID_ICreateSinkInfo, CCreateSinkInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventBinding
	public:
		HRESULT STDMETHODCALLTYPE get_ID(BSTR *pstrID);
		HRESULT STDMETHODCALLTYPE get_DisplayName(BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE put_DisplayName(BSTR pszDisplayName);
		HRESULT STDMETHODCALLTYPE putref_DisplayName(BSTR *ppszDisplayName);
		HRESULT STDMETHODCALLTYPE get_SinkClass(BSTR *pstrSinkClass);
		HRESULT STDMETHODCALLTYPE put_SinkClass(BSTR pszSinkClass);
		HRESULT STDMETHODCALLTYPE putref_SinkClass(BSTR *ppszSinkClass);
		HRESULT STDMETHODCALLTYPE get_SinkProperties(IEventPropertyBag **ppSinkProperties);
		HRESULT STDMETHODCALLTYPE get_SourceProperties(IEventPropertyBag **ppSourceProperties);
		HRESULT STDMETHODCALLTYPE get_EventBindingProperties(IEventPropertyBag **ppBindingProperties);
		HRESULT STDMETHODCALLTYPE get_Enabled(VARIANT_BOOL *pbEnabled);
		HRESULT STDMETHODCALLTYPE put_Enabled(VARIANT_BOOL bEnabled);
		HRESULT STDMETHODCALLTYPE putref_Enabled(VARIANT_BOOL *pbEnabled);
		HRESULT STDMETHODCALLTYPE get_Expiration(DATE *pdateExpiration);
		HRESULT STDMETHODCALLTYPE put_Expiration(DATE dateExpiration);
		HRESULT STDMETHODCALLTYPE putref_Expiration(DATE *pdateExpiration);
		HRESULT STDMETHODCALLTYPE get_MaxFirings(long *plMaxFirings);
		HRESULT STDMETHODCALLTYPE put_MaxFirings(long lMaxFirings);
		HRESULT STDMETHODCALLTYPE putref_MaxFirings(long *plMaxFirings);
		HRESULT STDMETHODCALLTYPE Save();

	private:
		CComPtr<IEventPropertyBag> m_pTmpDatabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBinding


HRESULT CEventBinding::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBinding::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	m_bInit = FALSE;
	ADD_DEBUG_OBJECT("CEventBinding")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBinding::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBinding::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_ID(BSTR *pstrID) {
	DEBUG_OBJECT_CHECK

	if (pstrID) {
		*pstrID = NULL;
	}
	if (!pstrID) {
		return (E_POINTER);
	}
	*pstrID = SysAllocString(m_strName);
	if (!*pstrID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_DisplayName(BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pstrDisplayName) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_DISPLAYNAME),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrDisplayName = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrDisplayName = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT CEventBinding::CopyForWrite() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBag(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_DisplayName(BSTR pszDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pszDisplayName) {
		varPropValue = pszDisplayName;
	}
	hrRes = m_pTmpDatabase->Add(BD_DISPLAYNAME,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_DisplayName(BSTR *ppszDisplayName) {
	DEBUG_OBJECT_CHECK

	if (!ppszDisplayName) {
		return (E_POINTER);
	}
	return (put_DisplayName(*ppszDisplayName));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SinkClass(BSTR *pstrSinkClass) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pstrSinkClass) {
		*pstrSinkClass = NULL;
	}
	if (!pstrSinkClass) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_SINKCLASS),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		*pstrSinkClass = SysAllocString(L"");
	} else {
		hrRes = varPropValue.ChangeType(VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pstrSinkClass = SysAllocString(varPropValue.bstrVal);
	}
	if (!*pstrSinkClass) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_SinkClass(BSTR pszSinkClass) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pszSinkClass) {
		varPropValue = pszSinkClass;
	}
	hrRes = m_pTmpDatabase->Add(BD_SINKCLASS,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_SinkClass(BSTR *ppszSinkClass) {
	DEBUG_OBJECT_CHECK

	if (!ppszSinkClass) {
		return (E_POINTER);
	}
	return (put_SinkClass(*ppszSinkClass));
}


HRESULT CEventBinding::GetProperties(LPCOLESTR pszPropName, IEventPropertyBag **ppProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (ppProperties) {
		*ppProperties = NULL;
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppProperties) {
		return (E_POINTER);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pTmpDatabase->Item(&CComVariant(pszPropName),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		hrRes = varPropValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			varPropValue.Clear();
			hrRes = S_FALSE;
		} else {
			CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pBag;
			CComPtr<IEventPropertyBag> pTmp;

			pBag = varPropValue.punkVal;
			if (!pBag) {
				varPropValue.Clear();
				hrRes = S_FALSE;
			}
		}
	}
	if (hrRes == S_FALSE) {
		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varPropValue.punkVal);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		varPropValue.vt = VT_UNKNOWN;
		hrRes = m_pTmpDatabase->Add((LPOLESTR) pszPropName,&varPropValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	hrRes = varPropValue.punkVal->QueryInterface(IID_IEventPropertyBag,(LPVOID *) ppProperties);
	_ASSERTE(SUCCEEDED(hrRes));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SinkProperties(IEventPropertyBag **ppSinkProperties) {
	DEBUG_OBJECT_CHECK

	return (GetProperties(BD_SINKPROPERTIES,ppSinkProperties));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_SourceProperties(IEventPropertyBag **ppSourceProperties) {
	DEBUG_OBJECT_CHECK

	return (GetProperties(BD_SOURCEPROPERTIES,ppSourceProperties));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_EventBindingProperties(IEventPropertyBag **ppBindingProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!ppBindingProperties) {
		return (E_POINTER);
	}
	if (!m_pTmpDatabase) {
		hrRes = CopyPropertyBagShallow(m_pDatabase,&m_pTmpDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	*ppBindingProperties = m_pTmpDatabase;
	(*ppBindingProperties)->AddRef();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_Enabled(VARIANT_BOOL *pbEnabled) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pbEnabled) {
		*pbEnabled = VARIANT_TRUE;
	}
	if (!pbEnabled) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_ENABLED),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		hrRes = varPropValue.ChangeType(VT_BOOL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		*pbEnabled = varPropValue.boolVal;
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_Enabled(VARIANT_BOOL bEnabled) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	varPropValue = bEnabled;
	hrRes = m_pTmpDatabase->Add(BD_ENABLED,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_Enabled(VARIANT_BOOL *pbEnabled) {
	DEBUG_OBJECT_CHECK

	if (!pbEnabled) {
		return (E_POINTER);
	}
	return (put_Enabled(*pbEnabled));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_Expiration(DATE *pdateExpiration) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (pdateExpiration) {
		*pdateExpiration = 0.0;
	}
	if (!pdateExpiration) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_EXPIRATION),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	hrRes = varPropValue.ChangeType(VT_DATE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pdateExpiration = varPropValue.date;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_Expiration(DATE dateExpiration) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (dateExpiration != 0.0) {
		varPropValue = dateExpiration;
	}
	hrRes = m_pTmpDatabase->Add(BD_EXPIRATION,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_Expiration(DATE *pdateExpiration) {
	DEBUG_OBJECT_CHECK

	if (!pdateExpiration) {
		return (E_POINTER);
	}
	return (put_Expiration(*pdateExpiration));
}


HRESULT STDMETHODCALLTYPE CEventBinding::get_MaxFirings(long *plMaxFirings) {
	DEBUG_OBJECT_CHECK
	CComPtr<IEventPropertyBag> pTmp = m_pTmpDatabase ? m_pTmpDatabase : m_pDatabase;
	HRESULT hrRes;
	CComVariant varPropValue;

	if (plMaxFirings) {
		*plMaxFirings = 0;
	}
	if (!plMaxFirings) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = pTmp->Item(&CComVariant(BD_MAXFIRINGS),&varPropValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (S_FALSE);
	}
	hrRes = varPropValue.ChangeType(VT_I4);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*plMaxFirings = varPropValue.lVal;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBinding::put_MaxFirings(long lMaxFirings) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varPropValue;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyForWrite();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (lMaxFirings != -1) {
		varPropValue = lMaxFirings;
	}
	hrRes = m_pTmpDatabase->Add(BD_MAXFIRINGS,&varPropValue);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBinding::putref_MaxFirings(long *plMaxFirings) {
	DEBUG_OBJECT_CHECK

	if (!plMaxFirings) {
		return (E_POINTER);
	}
	return (put_MaxFirings(*plMaxFirings));
}


HRESULT STDMETHODCALLTYPE CEventBinding::Save() {
	DEBUG_OBJECT_CHECK

	return (SaveImpl(m_strName,m_pDatabase,m_pTmpDatabase,m_pParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindingsEnum
class ATL_NO_VTABLE CEventBindingsEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventBindingsEnum, &CLSID_CEventBindingsEnum>,
	public CEventEnumVARIANTBaseImpl<CEventBinding,CEventBindingsEnum>,
	public CEventEnumUnknownBaseImpl<CEventBinding,CEventBindingsEnum>
{
	DEBUG_OBJECT_DEF(CEventBindingsEnum)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBindingsEnum);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBindingsEnum Class",
//								   L"Event.BindingsEnum.1",
//								   L"Event.BindingsEnum");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindingsEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
		COM_INTERFACE_ENTRY(IEnumUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventEnumBase
	public:
		virtual HRESULT SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection);
		virtual IUnknown *GetEnum() { _ASSERTE(m_pEnum); return (m_pEnum); };
		virtual IEventPropertyBag *GetCollection() { _ASSERTE(m_pCollection); return (m_pCollection); };

	private:
		CComPtr<IUnknown> m_pEnum;
		CComPtr<IEventPropertyBag> m_pCollection;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindingsEnum


HRESULT CEventBindingsEnum::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingsEnum::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindingsEnum")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindingsEnum::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingsEnum::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT CEventBindingsEnum::SetEnum(IUnknown *pEnum, IEventPropertyBag *pCollection) {
	DEBUG_OBJECT_CHECK

	if (!pEnum || !pCollection) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	m_pEnum = pEnum;
	m_pCollection = pCollection;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindings
class ATL_NO_VTABLE CEventBindings :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventBindings, &CLSID_CEventBindings>,
	public IDispatchImpl<IEventBindings, &IID_IEventBindings, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventBindings)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventBindings);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventBindings Class",
//								   L"Event.Bindings.1",
//								   L"Event.Bindings");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindings)
		COM_INTERFACE_ENTRY(IEventBindings)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBindings)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventBindings
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarDesired, IEventBinding **ppBinding);
		HRESULT STDMETHODCALLTYPE Add(BSTR strBinding, IEventBinding **ppBinding);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindings


HRESULT CEventBindings::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindings::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindings")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindings::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindings::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBindings::Item(VARIANT *pvarDesired, IEventBinding **ppBinding) {
	DEBUG_OBJECT_CHECK

	return (CreatePluggedInObject(CComObject<CEventBinding>::_CreatorClass::CreateInstance,
								  m_pDatabase,
								  pvarDesired,
								  IID_IEventBinding,
								  (IUnknown **) ppBinding,
								  FALSE));
}


HRESULT STDMETHODCALLTYPE CEventBindings::Add(BSTR strBinding, IEventBinding **ppBinding) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varName;
	CStringGUID objGuid;

	if (ppBinding) {
		*ppBinding = NULL;
	}
	hrRes = AddImpl1(strBinding,objGuid,&varName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(varName.vt==VT_BSTR);
	hrRes = Item(&varName,ppBinding);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes != S_FALSE) {
		return (S_FALSE);
	}
	hrRes = AddImpl2(m_pDatabase,
					 CComObject<CEventBinding>::_CreatorClass::CreateInstance,
					 IID_IEventBinding,
					 &varName,
					 (IUnknown **) ppBinding);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppBinding);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventBindings::Remove(VARIANT *pvarDesired) {
	DEBUG_OBJECT_CHECK

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->Remove(pvarDesired));
}


HRESULT STDMETHODCALLTYPE CEventBindings::get_Count(long *plCount) {
	DEBUG_OBJECT_CHECK

	if (plCount) {
		*plCount = 0;
	}
	if (!plCount) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	return (m_pDatabase->get_Count(plCount));
}


HRESULT STDMETHODCALLTYPE CEventBindings::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkTmp;
	CComObject<CEventBindingsEnum> *pNewEnum;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = m_pDatabase->get__NewEnum(&pUnkTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CEventBindingsEnum>::CreateInstance(&pNewEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(pNewEnum);
	pNewEnum->AddRef();
	hrRes = pNewEnum->SetEnum(pUnkTmp,m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		pNewEnum->Release();
		return (hrRes);
	}
	hrRes = pNewEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppUnkEnum);
	pNewEnum->Release();
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(*ppUnkEnum);
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventBindingManager


HRESULT CEventBindingManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingManager::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventBindingManager")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventBindingManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventBindingManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::get_Bindings(BSTR pszEventType, IEventBindings **ppBindings) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strTmp;
	CComPtr<IEventPropertyBag> pEventTypes;
	CComPtr<IEventPropertyBag> pEventType;

	if (ppBindings) {
		*ppBindings = NULL;
	}
	if (!pszEventType || !ppBindings) {
		return (E_POINTER);
	}
	// tbd - verify that pszEventType is a valid event type
	hrRes = CreateSubPropertyBag(m_pDatabase,&CComVariant(BD_EVENTTYPES),&pEventTypes,TRUE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateSubPropertyBag(pEventTypes,&CComVariant(pszEventType),&pEventType,TRUE);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindings>::_CreatorClass::CreateInstance,
								  pEventType,
								  &CComVariant(BD_BINDINGS),
								  IID_IEventBindings,
								  (IUnknown **) ppBindings,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pSubKey;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		return (E_FAIL);
	}
	hrRes = CreateSubPropertyBag(m_pDatabase,&CComVariant(BD_EVENTTYPES),&pSubKey,TRUE);
	_ASSERTE(!SUCCEEDED(hrRes)||pSubKey);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (pSubKey->get__NewEnum(ppUnkEnum));
}


#if 0
HRESULT STDMETHODCALLTYPE CEventBindingManager::get__NewEnum(IUnknown **ppUnkEnum) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varValue;
	CLocker lck;
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pSubKey;

	if (ppUnkEnum) {
		*ppUnkEnum = NULL;
	}
	if (!ppUnkEnum) {
		return (E_POINTER);
	}
	if (!m_pDatabase) {
		return (E_FAIL);
	}
	hrRes = lck.LockRead(m_pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		lck.Unlock();
		hrRes = lck.LockWrite(m_pDatabase);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
									 NULL,
									 CLSCTX_ALL,
									 IID_IUnknown,
									 (LPVOID *) &varValue.punkVal);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			varValue.vt = VT_UNKNOWN;
			hrRes = m_pDatabase->Add(BD_EVENTTYPES,&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			varValue.Clear();
			hrRes = m_pDatabase->Item(&CComVariant(BD_EVENTTYPES),&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			_ASSERTE(hrRes!=S_FALSE);
			if (hrRes == S_FALSE) {
				return (E_FAIL);
			}
		}
	}
	lck.Unlock();
	pSubKey = varValue.punkVal;
	if (!pSubKey) {
		return (E_NOINTERFACE);
	}
	return (pSubKey->get__NewEnum(ppUnkEnum));
}
#endif


HRESULT STDMETHODCALLTYPE CEventBindingManager::GetClassID(CLSID *pClassID) {
	DEBUG_OBJECT_CHECK

	if (!pClassID) {
		return (E_POINTER);
	}
	*pClassID = CLSID_CEventBindingManager;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::InitNew(void) {
	DEBUG_OBJECT_CHECK

	m_strDatabaseManager.Empty();
	m_pDatabase.Release();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComVariant varDictionary;
	CStringGUID objGuid;
	CComPtr<ISEOInitObject> pInit;
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pTmp;
	EXCEPINFO ei = {0,0,L"Event.BindingManager",NULL,NULL,0,NULL,NULL,0};

	if (!pPropBag) {
		return (E_POINTER);
	}
	hrRes = pPropBag->Read(L"DatabaseManager",&varDictionary,pErrorLog);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = varDictionary.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	objGuid.CalcFromProgID(varDictionary.bstrVal);
	if (!objGuid) {
		objGuid = varDictionary.bstrVal;
	}
	if (!objGuid) {
		if (pErrorLog) {
			ei.scode = CO_E_CLASSSTRING;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(objGuid,NULL,CLSCTX_ALL,IID_ISEOInitObject,(LPVOID *) &pInit);
	_ASSERTE(!SUCCEEDED(hrRes)||pInit);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	pTmp = pInit;
	if (!pTmp) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (E_NOINTERFACE);
	}
	hrRes = pInit->Load(pPropBag,pErrorLog);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = put_Database(pTmp);
	if (!SUCCEEDED(hrRes)) {
		if (pErrorLog) {
			ei.scode = hrRes;
			pErrorLog->AddError(L"DatabaseManager",&ei);
		}
		return (hrRes);
	}
	m_strDatabaseManager = varDictionary.bstrVal;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Save(IPropertyBag *pPropBag,
													 BOOL fClearDirty,
													 BOOL fSaveAllProperties) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComQIPtr<ISEOInitObject,&IID_ISEOInitObject> pInit;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	if (!pPropBag) {
		return (E_POINTER);
	}
	pInit = m_pDatabase;
	if (!pInit) {
		return (E_NOINTERFACE);
	}
	hrRes = pInit->Save(pPropBag,fClearDirty,fSaveAllProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pPropBag->Write(L"DatabaseManager",&CComVariant(m_strDatabaseManager));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::OnChange() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IConnectionPoint> pCP;
	CComPtr<IEnumConnections> pEnum;

	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		CONNECTDATA cdNotify;

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		_ASSERTE(cdNotify.pUnk);
		hrRes = ((IEventNotifyBindingChange *) cdNotify.pUnk)->OnChange();
		_ASSERTE(SUCCEEDED(hrRes));
		cdNotify.pUnk->Release();
	}
	pCP.Release();
	pEnum.Release();
	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChangeDisp,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		CONNECTDATA cdNotify;
		static DISPPARAMS dpArgs = {NULL,NULL,0,0};

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		_ASSERTE(cdNotify.pUnk);
		hrRes = ((IEventNotifyBindingChangeDisp *) cdNotify.pUnk)->Invoke(1,
																		  IID_NULL,
																		  GetUserDefaultLCID(),
																		  DISPATCH_METHOD,
																		  &dpArgs,
																		  NULL,
																		  NULL,
																		  NULL);
		_ASSERTE(SUCCEEDED(hrRes));
		cdNotify.pUnk->Release();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::Copy(long lTimeout, IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pCopy;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CopyPropertyBag(m_pDatabase,&pCopy,TRUE,lTimeout);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindingManager>::_CreatorClass::CreateInstance,
								  pCopy,
								  &CComVariant(),
								  IID_IEventBindingManager,
								  (IUnknown **) ppBindingManager,
								  TRUE));
}


HRESULT STDMETHODCALLTYPE CEventBindingManager::EmptyCopy(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pCopy;

	if (!m_pDatabase) {
		_ASSERTE(FALSE);
		return (E_FAIL);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pCopy);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CreatePluggedInObject(CComObject<CEventBindingManager>::_CreatorClass::CreateInstance,
								  pCopy,
								  &CComVariant(),
								  IID_IEventBindingManager,
								  (IUnknown **) ppBindingManager,
								  TRUE));
}


void CEventBindingManager::AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IConnectionPointContainer> pCPC;

	if (dwCount == 1) {
		if (!m_pDatabase) {
			_ASSERTE(FALSE);
			return;
		}
		if (((CP_ENBC *) this)->GetCount() + ((CP_ENBCD *) this)->GetCount() != 1) {
			return;
		}
		hrRes = m_pDatabase->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
		if (!SUCCEEDED(hrRes)) {
			return;
		}
		hrRes = pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&m_pCP);
		if (!SUCCEEDED(hrRes)) {
			return;
		}
		hrRes = m_pCP->Advise(GetControllingUnknown(),&m_dwCPCookie);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			m_pCP.Release();
			return;
		}
	}
}


void CEventBindingManager::UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (dwCount == 0) {
		if (!m_pDatabase) {
			_ASSERTE(FALSE);
			return;
		}
		if (!m_pCP) {
			return;
		}
		if (((CP_ENBC *) this)->GetCount() + ((CP_ENBCD *) this)->GetCount() != 0) {
			return;
		}
		hrRes = m_pCP->Unadvise(m_dwCPCookie);
		_ASSERTE(SUCCEEDED(hrRes));
		m_pCP.Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CEventDatabasePlugin


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Database(IEventPropertyBag **ppDatabase) {

	if (!ppDatabase) {
		return (E_POINTER);
	}
	*ppDatabase = m_pDatabase;
	if (*ppDatabase) {
		(*ppDatabase)->AddRef();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Database(IEventPropertyBag *pDatabase) {

	m_pDatabase = pDatabase;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Database(IEventPropertyBag **ppDatabase) {

	if (!ppDatabase) {
		return (E_POINTER);
	}
	return (put_Database(*ppDatabase));
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Name(BSTR *pstrName) {

	if (!pstrName) {
		return (E_POINTER);
	}
	*pstrName = SysAllocString(m_strName);
	if (!*pstrName && m_strName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Name(BSTR strName) {

	m_strName = strName;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Name(BSTR *pstrName) {

	if (!pstrName) {
		return (E_POINTER);
	}
	return (put_Name(*pstrName));
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::get_Parent(IEventPropertyBag **ppParent) {

	if (!ppParent) {
		return (E_POINTER);
	}
	*ppParent = m_pParent;
	if (*ppParent) {
		(*ppParent)->AddRef();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::put_Parent(IEventPropertyBag *pParent) {

	m_pParent = pParent;
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventDatabasePlugin::putref_Parent(IEventPropertyBag **ppParent) {

	if (!ppParent) {
		return (E_POINTER);
	}
	return (put_Parent(*ppParent));
}


/////////////////////////////////////////////////////////////////////////////
// CEventMetabaseDatabaseManager


HRESULT CEventMetabaseDatabaseManager::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventMetabaseDatabaseManager::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventMetabaseDatabaseManager")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventMetabaseDatabaseManager::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventMetabaseDatabaseManager::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::CreateDatabase(BSTR strPath, IUnknown **ppMonDatabase) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComBSTR strTmp;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;
	CComPtr<IEventPropertyBag> pDatabase;
	CComVariant varDatabase;
	BOOL bExisted = FALSE;

	if (ppMonDatabase) {
		*ppMonDatabase = NULL;
	}
	if (!ppMonDatabase) {
		return (E_POINTER);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pDatabase->Item(&CComVariant(strPath),&varDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		CComVariant varTmp;

		hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventPropertyBag,
								 (LPVOID *) &varTmp.punkVal);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		varTmp.vt = VT_UNKNOWN;
		hrRes = pDatabase->Add(strPath,&varTmp);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	} else {
		bExisted = TRUE;
	}
	strTmp = L"@SEO.SEOGenericMoniker: MonikerType=Event.BindingManager DatabaseManager=SEO.SEOMetaDictionary MetabasePath=";
	strTmp.Append(strPath);
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,strTmp,&dwEaten,(IMoniker **) ppMonDatabase);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppMonDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (bExisted?S_FALSE:S_OK);
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::EraseDatabase(BSTR strPath) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pDatabase;

	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventPropertyBag,
							 (LPVOID *) &pDatabase);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pDatabase->Remove(&CComVariant(strPath));
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


#define DW2W(x) _itow(x,(LPWSTR) _alloca(11*sizeof(WCHAR)),10)


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::MakeVServerPath(BSTR strService, long lInstance, BSTR *pstrPath) {
	DEBUG_OBJECT_CHECK
	CComBSTR strTmp;

	if (pstrPath) {
		*pstrPath = NULL;
	}
	if (!pstrPath) {
		return (E_POINTER);
	}
	if (!strService || !*strService || (lInstance < 0)) {
		return (E_INVALIDARG);
	}
	strTmp = L"LM/";
	strTmp.Append(strService);
	strTmp.Append(L"/");
	strTmp.Append(DW2W(lInstance));
	strTmp.Append(L"/EventManager");
	*pstrPath = strTmp.Detach();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventMetabaseDatabaseManager::MakeVRootPath(BSTR strService, long lInstance, BSTR strRoot, BSTR *pstrPath) {
	DEBUG_OBJECT_CHECK
	CComBSTR strTmp;

	if (pstrPath) {
		*pstrPath = NULL;
	}
	if (!pstrPath) {
		return (E_POINTER);
	}
	if (!strService || !*strService || (lInstance < 0) || !strRoot || !*strRoot) {
		return (E_INVALIDARG);
	}
	strTmp = L"LM/";
	strTmp.Append(strService);
	strTmp.Append(L"/");
	strTmp.Append(DW2W(lInstance));
	strTmp.Append(L"/root/");
	strTmp.Append(strRoot);
	strTmp.Append(L"/EventManager");
	*pstrPath = strTmp.Detach();
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventUtil


HRESULT CEventUtil::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventUtil::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventUtil")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventUtil::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventUtil::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventUtil::DisplayNameFromMoniker(IUnknown *pUnkMoniker,
															 BSTR *pstrDisplayName) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IMoniker> pMoniker;
	CComPtr<IBindCtx> pBindCtx;
	LPWSTR pszDisplayName;

	if (pstrDisplayName) {
		*pstrDisplayName = NULL;
	}
	if (!pUnkMoniker || !pstrDisplayName) {
		return (E_POINTER);
	}
	hrRes = pUnkMoniker->QueryInterface(IID_IMoniker,(LPVOID *) &pMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMoniker->GetDisplayName(pBindCtx,NULL,&pszDisplayName);
	_ASSERTE(!SUCCEEDED(hrRes)||pszDisplayName);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*pstrDisplayName = SysAllocString(pszDisplayName);
	CoTaskMemFree(pszDisplayName);
	if (!pstrDisplayName) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::MonikerFromDisplayName(BSTR strDisplayName,
															 IUnknown **ppUnkMoniker) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IBindCtx> pBindCtx;
	DWORD dwEaten;

	if (ppUnkMoniker) {
		*ppUnkMoniker = NULL;
	}
	if (!strDisplayName || !ppUnkMoniker) {
		return (E_POINTER);
	}
#if 0
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayNameEx(pBindCtx,strDisplayName,&dwEaten,(IMoniker **) ppUnkMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkMoniker);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkMoniker);
		return (S_OK);
	}
	pBindCtx.Release();
#endif
	hrRes = CreateBindCtx(0,&pBindCtx);
	_ASSERTE(!SUCCEEDED(hrRes)||pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = MkParseDisplayName(pBindCtx,strDisplayName,&dwEaten,(IMoniker **) ppUnkMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkMoniker);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkMoniker);
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::ObjectFromMoniker(IUnknown *pUnkMoniker, IUnknown **ppUnkObject) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<IMoniker> pMoniker;
	CComPtr<IBindCtx> pBindCtx;

	if (ppUnkObject) {
		*ppUnkObject = NULL;
	}
	if (!pUnkMoniker || !ppUnkObject) {
		return (E_POINTER);
	}
	hrRes = pUnkMoniker->QueryInterface(IID_IMoniker,(LPVOID *) &pMoniker);
	_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CreateBindCtx(0,&pBindCtx);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pMoniker->BindToObject(pBindCtx,NULL,IID_IUnknown,(LPVOID *) ppUnkObject);
	_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkObject);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!*ppUnkObject);
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::GetNewGUID(BSTR *pstrGUID) {
	DEBUG_OBJECT_CHECK
	CStringGUID objGuid;

	if (pstrGUID) {
		*pstrGUID = NULL;
	}
	if (!pstrGUID) {
		return (E_POINTER);
	}
	objGuid.CalcNew();
	if (!objGuid) {
		return (E_OUTOFMEMORY);
	}
	*pstrGUID = SysAllocString(objGuid);
	if (!*pstrGUID) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::CopyPropertyBag(IUnknown *pUnkInput, IUnknown **ppUnkOutput) {
	DEBUG_OBJECT_CHECK
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pInput;

	if (ppUnkOutput) {
		*ppUnkOutput = NULL;
	}
	if (!pUnkInput || !ppUnkOutput) {
		return (E_POINTER);
	}
	pInput = pUnkInput;
	if (!pInput) {
		return (E_NOINTERFACE);
	}
	return (::CopyPropertyBag(pInput,(IEventPropertyBag **) ppUnkOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::CopyPropertyBagShallow(IUnknown *pUnkInput, IUnknown **ppUnkOutput) {
	DEBUG_OBJECT_CHECK
	CComQIPtr<IEventPropertyBag,&IID_IEventPropertyBag> pInput;

	if (ppUnkOutput) {
		*ppUnkOutput = NULL;
	}
	if (!pUnkInput || !ppUnkOutput) {
		return (E_POINTER);
	}
	pInput = pUnkInput;
	if (!pInput) {
		return (E_NOINTERFACE);
	}
	return (::CopyPropertyBagShallow(pInput,(IEventPropertyBag **) ppUnkOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::DispatchFromObject(IUnknown *pUnkObject, IDispatch **ppDispOutput) {
	DEBUG_OBJECT_CHECK

	if (ppDispOutput) {
		*ppDispOutput = NULL;
	}
	if (!pUnkObject || !ppDispOutput) {
		return (E_POINTER);
	}
	return (pUnkObject->QueryInterface(IID_IDispatch,(LPVOID *) ppDispOutput));
}


HRESULT STDMETHODCALLTYPE CEventUtil::GetIndexedGUID(BSTR strGUID, long lIndex, BSTR *pstrResult) {
	DEBUG_OBJECT_CHECK
	CStringGUID guidGUID;
	CStringGUID guidNew;

	if (pstrResult) {
		*pstrResult = NULL;
	}
	if (!strGUID || !pstrResult) {
		return (E_POINTER);
	}
	guidGUID.Assign(strGUID);
	if (!guidGUID) {
		return (E_INVALIDARG);
	}
	guidNew.Assign(guidGUID,(DWORD) lIndex);
	if (!guidNew) {
		return (E_FAIL);
	}
	*pstrResult = SysAllocString(guidNew);
	if (!*pstrResult) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventUtil::RegisterSource(BSTR strSourceType,
													 BSTR strSource,
													 long lInstance,
													 BSTR strService,
													 BSTR strVRoot,
													 BSTR strDatabaseManager,
													 BSTR strDisplayName,
													 IEventBindingManager **ppBindingManager) {
	HRESULT hrRes;
	CStringGUID guidSource;
	CComPtr<IEventManager> pEventManager;
	CComPtr<IEventSourceTypes> pSourceTypes;
	CComPtr<IEventSourceType> pSourceType;
	CComPtr<IEventSources> pSources;
	CComPtr<IEventSource> pSource;
	CComPtr<IEventDatabaseManager> pDatabaseManager;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!strSourceType || !strSource || !strService || !strDatabaseManager || !ppBindingManager) {
		return (E_POINTER);
	}
	if (lInstance == -1) {
		guidSource = strSource;
	} else {
		CStringGUID guidTmp;

		guidTmp = strSource;
		if (!guidTmp) {
			return (E_INVALIDARG);
		}
		guidSource.Assign(guidTmp,lInstance);
	}
	if (!guidSource) {
		return (E_INVALIDARG);
	}
	hrRes = CoCreateInstance(CLSID_CEventManager,
							 NULL,
							 CLSCTX_ALL,
							 IID_IEventManager,
							 (LPVOID *) &pEventManager);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pEventManager->get_SourceTypes(&pSourceTypes);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pSourceTypes->Item(&CComVariant(strSourceType),&pSourceType);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (SEO_E_NOTPRESENT);
	}
	hrRes = pSourceType->get_Sources(&pSources);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pSources->Add(CComBSTR((LPCWSTR) guidSource),&pSource);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_OK) {
		VARIANT varDatabaseManager;
		CComBSTR strPath;
		CComPtr<IUnknown> pPath;

		varDatabaseManager.vt = VT_BSTR | VT_BYREF;
		varDatabaseManager.pbstrVal = &strDatabaseManager;
		hrRes = SEOCreateObject(&varDatabaseManager,
								NULL,
								NULL,
								IID_IEventDatabaseManager,
								(IUnknown **) &pDatabaseManager);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (strVRoot && strVRoot[0]) {
			hrRes = pDatabaseManager->MakeVRootPath(strService,lInstance,strVRoot,&strPath);
		} else {
			hrRes = pDatabaseManager->MakeVServerPath(strService,lInstance,&strPath);
		}
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pDatabaseManager->CreateDatabase(strPath,&pPath);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pSource->put_BindingManagerMoniker(pPath);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (strDisplayName) {
			hrRes = pSource->put_DisplayName(strDisplayName);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		hrRes = pSource->Save();
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	hrRes = pSource->GetBindingManager(ppBindingManager);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventComCat


HRESULT CEventComCat::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventComCat::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventComCat")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventComCat::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventComCat::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterCategory(BSTR pszCategory, BSTR pszDescription, long lcidLanguage) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CATEGORYINFO ci;
	CStringGUID objCat;

	if (!pszCategory || !pszDescription) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	if (wcslen(pszDescription) > sizeof(ci.szDescription)/sizeof(ci.szDescription[0])-1) {
		return (E_INVALIDARG);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	memset(&ci,0,sizeof(ci));
	ci.catid = objCat;
	ci.lcid = lcidLanguage;
	wcscpy(ci.szDescription,pszDescription);
	hrRes = pCatReg->RegisterCategories(1,&ci);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterCategory(BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objCat;

	if (!pszCategory) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterCategories(1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassImplCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassImplCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::RegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->RegisterClassReqCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::UnRegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatRegister> pCatReg;
	CStringGUID objClass;
	CStringGUID objCat;

	if (!pszClass || !pszCategory) {
		return (E_POINTER);
	}
	objClass = pszClass;
	if (!objClass) {
		return (CO_E_CLASSSTRING);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatRegister,
							 (LPVOID *) &pCatReg);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatReg);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatReg->UnRegisterClassReqCategories(objClass,1,(GUID *) &((REFGUID) objCat));
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CEventComCat::GetCategories(SAFEARRAY **ppsaCategories) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CComPtr<IEnumCATEGORYINFO> pEnum;
	DWORD dwTmp;
	DWORD dwAlloc = 0;
	CATEGORYINFO *pci = NULL;

	if (ppsaCategories) {
		*ppsaCategories = NULL;
	}
	if (!ppsaCategories) {
		return (E_POINTER);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pCatInfo->EnumCategories(LOCALE_NEUTRAL,&pEnum);
	_ASSERTE(!SUCCEEDED(hrRes)||pEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = S_FALSE;
	while (1) {
		dwTmp = (hrRes==S_FALSE) ? 1 : dwAlloc;
		if (!MyReallocInPlace(&pci,sizeof(*pci)*(dwAlloc+dwTmp))) {
			MyFree(pci);
			return (E_OUTOFMEMORY);
		}
		hrRes = pEnum->Next(dwTmp,&pci[dwAlloc],&dwTmp);
		// Do not alter hrRes between here and the bottom of the loop!  The first statement
		// in the loop relies on hrRes having the result from this call to IEnumCLSID::Next.
		if (!SUCCEEDED(hrRes)) {
			MyFree(pci);
			return (hrRes);
		}
		if (!dwTmp) {
			break;
		}
		dwAlloc += dwTmp;
	}
	*ppsaCategories = SafeArrayCreateVector(VT_VARIANT,1,dwAlloc);
	if (!*ppsaCategories) {
		MyFree(pci);
		return (E_OUTOFMEMORY);
	}
	_ASSERTE(SafeArrayGetDim(*ppsaCategories)==1);
	_ASSERTE(SafeArrayGetElemsize(*ppsaCategories)==sizeof(VARIANT));
	hrRes = SafeArrayLock(*ppsaCategories);
	_ASSERTE(SUCCEEDED(hrRes));
	if (SUCCEEDED(hrRes)) {
		HRESULT hrResTmp;

		for (dwTmp=1;dwTmp<=dwAlloc;dwTmp++) {
			CStringGUID objGuid;
			VARIANT *pvarElt;

			objGuid = pci[dwTmp-1].catid;
			if (!objGuid) {
				hrRes = E_OUTOFMEMORY;
				break;
			}
			pvarElt = NULL;
			hrRes = SafeArrayPtrOfIndex(*ppsaCategories,(long *) &dwTmp,(LPVOID *) &pvarElt);
			_ASSERTE(!SUCCEEDED(hrRes)||pvarElt);
			if (!SUCCEEDED(hrRes)) {
				break;
			}
			pvarElt->bstrVal = SysAllocString(objGuid);
			if (!pvarElt->bstrVal) {
				hrRes = E_OUTOFMEMORY;
				break;
			}
			pvarElt->vt = VT_BSTR;
		}
		hrResTmp = SafeArrayUnlock(*ppsaCategories);
		_ASSERTE(SUCCEEDED(hrResTmp));
		if (!SUCCEEDED(hrResTmp) && SUCCEEDED(hrRes)) {
			hrRes = hrResTmp;
		}
	}
	MyFree(pci);
	if (!SUCCEEDED(hrRes)) {
		SafeArrayDestroy(*ppsaCategories);
		*ppsaCategories = NULL;
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventComCat::GetCategoryDescription(BSTR pszCategory,
															   long lcidLanguage,
															   BSTR *pstrDescription) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CComPtr<ICatInformation> pCatInfo;
	CStringGUID objCat;
	LPWSTR pszDesc;

	if (pstrDescription) {
		*pstrDescription = NULL;
	}
	if (!pszCategory || !pstrDescription) {
		return (E_POINTER);
	}
	objCat = pszCategory;
	if (!objCat) {
		return (CO_E_CLASSSTRING);
	}
	hrRes = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
							 NULL,
							 CLSCTX_ALL,
							 IID_ICatInformation,
							 (LPVOID *) &pCatInfo);
	_ASSERTE(!SUCCEEDED(hrRes)||pCatInfo);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pszDesc = NULL;
	hrRes = pCatInfo->GetCategoryDesc(objCat,lcidLanguage,&pszDesc);
	_ASSERTE(!SUCCEEDED(hrRes)||pszDesc);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(!pszDesc);
		return (hrRes);
	}
	*pstrDescription = SysAllocString(pszDesc);
	CoTaskMemFree(pszDesc);
	if (!*pstrDescription) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventRouterInternal
class ATL_NO_VTABLE CEventRouterInternal :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventRouterInternal, &CLSID_CEventRouterInternal>,
	public IEventRouter,
	public IEventNotifyBindingChange
{
	DEBUG_OBJECT_DEF(CEventRouterInternal)
	private:
		class CDispatcher {
			DEBUG_OBJECT_DEF2(CDispatcher,"CEventRouterInternal::CDispatcher",CEventRouterInternal__CDispatcher)
			public:
				CDispatcher();
				virtual ~CDispatcher();
				HRESULT Init(REFCLSID clsidDispatcher, IClassFactory *pClassFactory);
				BOOL HasEventType(REFIID iidEventType);
				HRESULT AddEventType(REFIID iidEventType, IEventRouter *piRouter, IEventBindingManager *piManager);
				HRESULT GetDispatcher(REFIID iidDesired, LPVOID *ppvDispatcher);
				REFCLSID GetCLSID() { return (m_clsidDispatcher); };
				void SetPreload(IEnumGUID *pEnumPreload) {
					m_pEnumPreload = pEnumPreload;
				};
			private:
				CLSID m_clsidDispatcher;
				DWORD m_dwEventTypes;
				IID *m_aiidEventTypes;
				CComQIPtr<IEventDispatcher,&IID_IEventDispatcher> m_pDispatcher;
				CComPtr<IUnknown> m_pUnkDispatcher;
				CComPtr<IEnumGUID> m_pEnumPreload;
		};

	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		BOOL FindDispatcher(REFCLSID clsidDispatcher, REFIID iidEventType, CDispatcher **ppDispatcher);
		HRESULT AddDispatcher(REFCLSID clsidDispatcher, IClassFactory *pClassFactory, REFIID iidEventType, CDispatcher **ppDispatcher);
		void PutDatabaseImpl(IEventBindingManager *pBindingManager, int iTimeout);
		void MakeBindingManagerCopy(int iTimeout, BOOL bRequired);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventRouterInternal);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventRouterInternal Class",
//								   L"Event.RouterInternal.1",
//								   L"Event.RouterInternal");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventRouterInternal)
		COM_INTERFACE_ENTRY(IEventRouter)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IEventLock, m_pLock.p)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventRouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE put_Database(IEventBindingManager *pBindingManager);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent,
												REFIID iidDesired,
												IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher,
													   REFIID iidEvent,
													   REFIID iidDesired,
													   IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
															  IClassFactory *piClassFactory,
															  REFIID iidEvent,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult);

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		class CDispatchers : public CSEOGrowableList<CDispatcher> {
			// tbd - override various members
		};
		CDispatchers m_Dispatchers;
		CComPtr<IEventBindingManager> m_pBindingManager;
		CComPtr<IEventBindingManager> m_pBindingManagerCopy;
		BOOL m_bMakeNewCopy;
		CComPtr<IEventLock> m_pLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
		CComPtr<IConnectionPoint> m_pCP;
		DWORD m_dwCookie;
};


HRESULT CEventRouterInternal::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouterInternal::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_bMakeNewCopy = TRUE;
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventRouterInternal")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventRouterInternal::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouterInternal::FinalRelease");

	put_Database(NULL);
	m_pBindingManager.Release();
	m_pBindingManagerCopy.Release();
	m_pLock.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


BOOL CEventRouterInternal::FindDispatcher(REFCLSID clsidDispatcher, REFIID iidEventType, CDispatcher **ppDispatcher) {
	DEBUG_OBJECT_CHECK

	if (ppDispatcher) {
		*ppDispatcher = NULL;
	}
	if (!ppDispatcher) {
		return (E_POINTER);
	}
	for (DWORD dwIdx=0;dwIdx<m_Dispatchers.Count();dwIdx++) {
		if (m_Dispatchers[dwIdx].GetCLSID() == clsidDispatcher) {
			if (m_Dispatchers[dwIdx].HasEventType(iidEventType)) {
				*ppDispatcher = m_Dispatchers.Index(dwIdx);
				return (TRUE);
			}
			return (FALSE);
		}
	}
	return (FALSE);
}


HRESULT CEventRouterInternal::AddDispatcher(REFCLSID clsidDispatcher, IClassFactory *pClassFactory, REFIID iidEventType, CDispatcher **ppDispatcher) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CDispatcher *pTmp;

	if (ppDispatcher) {
		*ppDispatcher = NULL;
	}
	if (!ppDispatcher) {
		return (E_POINTER);
	}
	MakeBindingManagerCopy(LOCK_TIMEOUT,TRUE);
	for (DWORD dwIdx=0;dwIdx<m_Dispatchers.Count();dwIdx++) {
		if (m_Dispatchers[dwIdx].GetCLSID() == clsidDispatcher) {
			hrRes = m_Dispatchers[dwIdx].AddEventType(iidEventType,this,m_pBindingManagerCopy);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			*ppDispatcher = m_Dispatchers.Index(dwIdx);
			return (S_OK);
		}
	}
	pTmp = new CDispatcher;
	if (!pTmp) {
		return (E_OUTOFMEMORY);
	}
	hrRes = pTmp->Init(clsidDispatcher,pClassFactory);
	if (!SUCCEEDED(hrRes)) {
		delete pTmp;
		return (hrRes);
	}
	hrRes = m_Dispatchers.Add(pTmp);
	if (!SUCCEEDED(hrRes)) {
		delete pTmp;
		return (hrRes);
	}
	hrRes = pTmp->AddEventType(iidEventType,this,m_pBindingManagerCopy);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppDispatcher = pTmp;
	return (S_OK);
}


void CEventRouterInternal::PutDatabaseImpl(IEventBindingManager *pBindingManager, int iTimeout) {
	DEBUG_OBJECT_CHECK
	BOOL bDoAdvise = FALSE;
	HRESULT hrRes;

	m_bMakeNewCopy = TRUE;
	if (m_pBindingManager != pBindingManager) {
		bDoAdvise = TRUE;
	}
	if (pBindingManager) {
		pBindingManager->AddRef();
	}
	if (m_pBindingManager) {
		m_Dispatchers.RemoveAll();
		if (bDoAdvise) {
			if (m_pCP) {
				hrRes = m_pCP->Unadvise(m_dwCookie);
				_ASSERTE(SUCCEEDED(hrRes));
				m_pCP.Release();
			}
		}
	}
	if (bDoAdvise) {
		m_pBindingManagerCopy.Release();
	}
	m_pBindingManager = pBindingManager;
	if (m_pBindingManager) {
		if (bDoAdvise) {
			CComQIPtr<IConnectionPointContainer,&IID_IConnectionPointContainer> pCPC;

			pCPC = m_pBindingManager;
			if (pCPC) {
				hrRes = pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&m_pCP);
				if (SUCCEEDED(hrRes)) {
					hrRes = m_pCP->Advise(GetControllingUnknown(),&m_dwCookie);
					_ASSERTE(SUCCEEDED(hrRes));
					if (!SUCCEEDED(hrRes)) {
						m_pCP.Release();
					}
				}
			}
		}
		MakeBindingManagerCopy(iTimeout,FALSE);
	}
	if (pBindingManager) {
		pBindingManager->Release();
	}
}


void CEventRouterInternal::MakeBindingManagerCopy(int iTimeout, BOOL bRequired) {
	HRESULT hrRes;
	CComQIPtr<IEventBindingManagerCopier, &IID_IEventBindingManagerCopier> pCopier;
	CComPtr<IEventBindingManager> pNewCopy;

	_ASSERTE(m_pBindingManager);
	if (!m_bMakeNewCopy) {
		return;
	}
	pCopier = m_pBindingManager;
	_ASSERTE(pCopier);
	if (!pCopier) {
		// We couldn't QI' for IEventBindingManagerCopier, so just use the
		// current event binding manager without attempting to make a copy.
		m_pBindingManagerCopy = m_pBindingManager;
		goto done;
	}
	hrRes = pCopier->Copy(iTimeout,&pNewCopy);
	_ASSERTE(SUCCEEDED(hrRes)||(hrRes==SEO_E_TIMEOUT));
	if (SUCCEEDED(hrRes)) {
		// We successfully made a copy of the binding event manager.
		m_pBindingManagerCopy = pNewCopy;
		goto done;
	}
	if (!bRequired) {
		// We don't actually an event binding manager yet, so just exit while
		// leaving m_bMakeNewCopy==TRUE.
		return;
	}
	if (m_pBindingManagerCopy) {
		// Since we must have an event binding manager, and since we already have
		// an old copy, just continue using the old copy and forget about making
		// a new copy.
		goto done;
	}
	// Ok - we must have an event binding manager.  And we don't have an old copy
	// we can use.  So, just create a completely empty copy.
	m_pBindingManagerCopy.Release();
	hrRes = pCopier->EmptyCopy(&m_pBindingManagerCopy);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		// Arrgg!  We even failed to make the empty copy.  We are really in trouble.
		// So just use the event binding manager directly, without making a copy.
		m_pBindingManagerCopy = m_pBindingManager;
	}
done:
	// The only case where we don't want to reset this flag is where we failed
	// to make a copy, but we weren't required to make a copy either - in that
	// case, we took an early return from the method.  In all other case, we
	// want to reset this flag to prevent any further attempts at making a
	// copy.
	m_bMakeNewCopy = FALSE;
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::get_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	if (ppBindingManager) {
		*ppBindingManager = NULL;
	}
	if (!ppBindingManager) {
		return (E_POINTER);
	}
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppBindingManager = m_pBindingManager;
	if (!ppBindingManager) {
		(*ppBindingManager)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::put_Database(IEventBindingManager *pBindingManager) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	PutDatabaseImpl(pBindingManager,LOCK_TIMEOUT);
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::putref_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!ppBindingManager) {
		return (E_POINTER);
	}
	return (put_Database(*ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcher(REFIID iidEventType,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	return (GetDispatcherByCLSID(iidEventType,iidEventType,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcherByCLSID(REFCLSID clsidDispatcher,
																	 REFIID iidEventType,
																	 REFIID iidDesired,
																	 IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	return (GetDispatcherByClassFactory(clsidDispatcher,
										NULL,
										iidEventType,
										iidDesired,
										ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouterInternal::GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
																			IClassFactory *pClassFactory,
																			REFIID iidEventType,
																			REFIID iidDesired,
																			IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;
	CDispatcher *pDispatcher;
	CLocker cLock;

	if (ppUnkResult) {
		*ppUnkResult = NULL;
	}
	if (!ppUnkResult) {
		return (E_POINTER);
	}
	hrRes = cLock.LockRead(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (FindDispatcher(clsidDispatcher,iidEventType,&pDispatcher)) {
		hrRes = pDispatcher->GetDispatcher(iidDesired,(LPVOID *) ppUnkResult);
		return (hrRes);
	}
	cLock.Unlock();
	hrRes = cLock.LockWrite(m_pLock);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = AddDispatcher(clsidDispatcher,pClassFactory,iidEventType,&pDispatcher);
	if (SUCCEEDED(hrRes)) {
		hrRes = pDispatcher->GetDispatcher(iidDesired,(LPVOID *) ppUnkResult);
	}
	return (hrRes);
}


class CDispSave {
	private:
		CDispSave(IClassFactory *pCF, REFCLSID rclsid) {

			if (pCF) {
				m_pCF = pCF;
				m_clsid = rclsid;
			} else {
				m_clsid = GUID_NULL;
			}
		};
		~CDispSave() {
			// nothing
		};
	public:
		static void Init(CDispSave *pNew, IClassFactory *pCF, REFCLSID rclsid) {
			new(pNew) CDispSave(pCF,rclsid);
		};
		static void Term(CDispSave *pDisp) {
			pDisp->~CDispSave();
		};
	public:
		CComPtr<IClassFactory> m_pCF;
		GUID m_clsid;
};


HRESULT STDMETHODCALLTYPE CEventRouterInternal::OnChange() {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes = S_OK;
	CDispSave *pSave = NULL;
	DWORD dwSaveCount;
	DWORD dwIdx;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT_SHORT);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		return (S_OK);
	}
	// First, let's go through and make a copy of (some of) the dispatcher info that's
	// in this router.  We do this by allocating an array of objects on the stack...
	dwSaveCount = m_Dispatchers.Count();
	pSave = (CDispSave *) _alloca(sizeof(CDispSave)*dwSaveCount);
	if (pSave) {
		// Now we initialize each of the objects.
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			CComPtr<IClassFactory> pCF;

			// The Init() routine wants either an IClassFactory or a NULL value.
			hrRes = m_Dispatchers[dwIdx].GetDispatcher(IID_IClassFactory,(LPVOID *) &pCF);
			CDispSave::Init(&pSave[dwIdx],pCF,m_Dispatchers[dwIdx].GetCLSID());
			pCF.Release();
		}
	}
	PutDatabaseImpl(m_pBindingManager,LOCK_TIMEOUT_SHORT);
	if (pSave) {
		// Now we do the pre-loading...
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			// If the previous dispatcher implements IClassFactory...
			if (pSave[dwIdx].m_pCF) {
				CDispatcher *pDisp;
				CComPtr<IEventDispatcherChain> pChain;
				CComPtr<IUnknown> pUnkEnum;
				CComQIPtr<IEnumGUID,&IID_IEnumGUID> pEnum;
				IID iidEventType;

				// ...then use the previous dispatcher to create a new dispatcher.
				hrRes = AddDispatcher(pSave[dwIdx].m_clsid,pSave[dwIdx].m_pCF,GUID_NULL,&pDisp);
				_ASSERTE(SUCCEEDED(hrRes));
				if (SUCCEEDED(hrRes)) {
					// Now, if the new dispatcher implements IEventDispatcherChain...
					hrRes = pDisp->GetDispatcher(IID_IEventDispatcherChain,(LPVOID *) &pChain);
				}
				if (pChain) {
					// ... then call the new dispatcher's IEventDispatcherChain::SetPrevious method.
					hrRes = pChain->SetPrevious(pSave[dwIdx].m_pCF,&pUnkEnum);
				}
				if (pUnkEnum) {
					// If the IEventDispatcherChain::SetPrevious method returned an object...
					pEnum = pUnkEnum;
				}
				if (pEnum) {
					// ... and if that object implements IEnumGUID...
					if (!m_bMakeNewCopy) {
						// ... and if we have a binding manager copy now...
						while (pEnum->Next(1,&iidEventType,NULL) == S_OK) {
							// ... then we loop through the GUID's and add each of them as an
							// event type (which causes the new dispatcher's IEventDispatcher::SetContext
							// method to be called).
							hrRes = pDisp->AddEventType(iidEventType,this,m_pBindingManagerCopy);
							_ASSERTE(SUCCEEDED(hrRes));
						}
					} else {
						// If we don't have a binding manager copy, then set it up so
						// that we'll do the event type pre-loading on the first
						// event fired to the new dispatcher.
						pDisp->SetPreload(pEnum);
					}
				}
				pChain.Release();
				pUnkEnum.Release();
				pEnum.Release();
			}
		}
	}
	if (pSave) {
		for (dwIdx=0;dwIdx<dwSaveCount;dwIdx++) {
			// Be sure to clean-up the array of objects on the stack - if we
			// don't do this explicitly, then we would leak ref-counts on the
			// old dispatcher(s).
			CDispSave::Term(&pSave[dwIdx]);
		}
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


CEventRouterInternal::CDispatcher::CDispatcher() {
	DEBUG_OBJECT_CHECK

	m_dwEventTypes = 0;
	m_aiidEventTypes = NULL;
}


CEventRouterInternal::CDispatcher::~CDispatcher() {
	DEBUG_OBJECT_CHECK

	if (m_aiidEventTypes) {
		delete[] m_aiidEventTypes;
		m_aiidEventTypes = NULL;
	}
}


HRESULT CEventRouterInternal::CDispatcher::Init(REFCLSID clsidDispatcher, IClassFactory *pClassFactory) {
	DEBUG_OBJECT_CHECK
	HRESULT hrRes;

	m_clsidDispatcher = clsidDispatcher;
	if (pClassFactory) {
		hrRes = pClassFactory->CreateInstance(NULL,IID_IUnknown,(LPVOID *) &m_pUnkDispatcher);
	} else {
		hrRes = CoCreateInstance(clsidDispatcher,
								 NULL,
								 CLSCTX_ALL,
								 IID_IUnknown,
								 (LPVOID *) &m_pUnkDispatcher);
	}
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkDispatcher);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pDispatcher = m_pUnkDispatcher;
	return (S_OK);
}


BOOL CEventRouterInternal::CDispatcher::HasEventType(REFIID iidEventType) {
	DEBUG_OBJECT_CHECK

	for (DWORD dwIdx=0;dwIdx<m_dwEventTypes;dwIdx++) {
		if (m_aiidEventTypes[dwIdx] == iidEventType) {
			return (TRUE);
		}
	}
	return (FALSE);
}


HRESULT CEventRouterInternal::CDispatcher::AddEventType(REFIID iidEventType, IEventRouter *piRouter, IEventBindingManager *piManager) {
	DEBUG_OBJECT_CHECK
	IID *aiidTmp;
	HRESULT hrRes;

	if (iidEventType == GUID_NULL) {
		return (S_FALSE);
	}
	if (HasEventType(iidEventType)) {
		return (S_FALSE);
	}
	if (m_pEnumPreload) {
		// If we were set-up to pre-load some event types...
		CComPtr<IEnumGUID> pEnum;
		IID iidPreload;

		pEnum = m_pEnumPreload;
		m_pEnumPreload.Release();  // Prevent infinite recusion
		while (pEnum->Next(1,&iidPreload,NULL) == S_OK) {
			// Add each event type returned by the enumerator.
			hrRes = AddEventType(iidPreload,piRouter,piManager);
			_ASSERTE(SUCCEEDED(hrRes));
		}
	}
	if (m_pDispatcher) {
		CComPtr<IEventBindings> pBindings;

		hrRes = piManager->get_Bindings((LPOLESTR) ((LPCOLESTR) CStringGUID(iidEventType)),&pBindings);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = m_pDispatcher->SetContext(iidEventType,piRouter,pBindings);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	}
	aiidTmp = new IID[m_dwEventTypes+1];
	if (!aiidTmp) {
		return (E_OUTOFMEMORY);
	}
	memcpy(aiidTmp,m_aiidEventTypes,sizeof(m_aiidEventTypes[0])*m_dwEventTypes);
	delete[] m_aiidEventTypes;
	m_aiidEventTypes = aiidTmp;
	aiidTmp[m_dwEventTypes++] = iidEventType;
	return (S_OK);
}


HRESULT CEventRouterInternal::CDispatcher::GetDispatcher(REFIID iidDesired, LPVOID *ppvDispatcher) {
	DEBUG_OBJECT_CHECK

	if (ppvDispatcher) {
		*ppvDispatcher = NULL;
	}
	if (!ppvDispatcher) {
		return (E_POINTER);
	}
	if (!m_pUnkDispatcher) {
		return (E_FAIL);
	}
	return (m_pUnkDispatcher->QueryInterface(iidDesired,ppvDispatcher));
}


/////////////////////////////////////////////////////////////////////////////
// CEventRouter


HRESULT CEventRouter::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouter::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CComObject<CEventRouterInternal>::_CreatorClass::CreateInstance(NULL,
																			IID_IEventRouter,
																			(LPVOID *) &m_pRouter);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	ADD_DEBUG_OBJECT("CEventRouter")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventRouter::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventRouter::FinalRelease");

	if (m_pRouter) {
		m_pRouter->put_Database(NULL);
	}
	m_pRouter.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventRouter::get_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->get_Database(ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::put_Database(IEventBindingManager *pBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->put_Database(pBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::putref_Database(IEventBindingManager **ppBindingManager) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->putref_Database(ppBindingManager));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcher(REFIID iidEventType,
													  REFIID iidDesired,
													  IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcher(iidEventType,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcherByCLSID(REFCLSID clsidDispatcher,
															 REFIID iidEventType,
															 REFIID iidDesired,
															 IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcherByCLSID(clsidDispatcher,
											iidEventType,
											iidDesired,
											ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CEventRouter::GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
																	IClassFactory *pClassFactory,
																	REFIID iidEventType,
																	REFIID iidDesired,
																	IUnknown **ppUnkResult) {
	DEBUG_OBJECT_CHECK

	if (!m_pRouter) {
		return (E_FAIL);
	}
	return (m_pRouter->GetDispatcherByClassFactory(clsidDispatcher,
												   pClassFactory,
												   iidEventType,
												   iidDesired,
												   ppUnkResult));
}


/////////////////////////////////////////////////////////////////////////////
// CEventServiceSubObject
class ATL_NO_VTABLE CEventServiceSubObject :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CEventRouterInternal, &CLSID_CEventRouterInternal>,
	public IEventNotifyBindingChange
{
	DEBUG_OBJECT_DEF(CEventServiceSubObject)

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CEventServiceSubObject);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"EventServiceSubObject Class",
//								   L"Event.ServiceSubObject.1",
//								   L"Event.ServiceSubObject");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventServiceSubObject)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


HRESULT CEventServiceSubObject::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceSubObject::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	ADD_DEBUG_OBJECT("CEventServiceObject")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventServiceSubObject::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceSubObject::FinalRelease");

	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CEventServiceSubObject::OnChange() {

	// nothing
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CEventServiceObject


HRESULT CEventServiceObject::FinalConstruct() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceObject::FinalConstruct");
	HRESULT hrRes = S_OK;
	CComPtr<IConnectionPoint> pCP;

	hrRes = CoCreateInstance(CLSID_CSEOMetaDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) &m_pUnkMetabase);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	if (SUCCEEDED(hrRes)) {
		m_pCPC = m_pUnkMetabase;
		_ASSERTE(m_pCPC);
		if (!m_pCPC) {
			hrRes = E_NOINTERFACE;
		}
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = m_pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
		_ASSERTE(SUCCEEDED(hrRes));
		if (!SUCCEEDED(hrRes)) {
			m_pCPC.Release();
		}
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = CComObject<CEventServiceSubObject>::_CreatorClass::CreateInstance(NULL,
																				  IID_IUnknown,
																				  (LPVOID *) &m_pSubObject);
		_ASSERTE(SUCCEEDED(hrRes));
		if (SUCCEEDED(hrRes)) {
			hrRes = pCP->Advise(m_pSubObject,&m_dwCookie);
			_ASSERTE(SUCCEEDED(hrRes));
		}
		if (!SUCCEEDED(hrRes)) {
			m_pCPC.Release();
		}
	}
	ADD_DEBUG_OBJECT("CEventServiceObject")
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventServiceObject::FinalRelease() {
	DEBUG_OBJECT_CHECK
	TraceFunctEnter("CEventServiceObject::FinalRelease");

	if (m_pCPC) {
		CComPtr<IConnectionPoint> pCP;
		HRESULT hrRes;

		hrRes = m_pCPC->FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
		_ASSERTE(SUCCEEDED(hrRes));
		if (SUCCEEDED(hrRes)) {
			hrRes = pCP->Unadvise(m_dwCookie);
			_ASSERTE(SUCCEEDED(hrRes));
		}
		m_pCPC.Release();
	}
	m_pSubObject.Release();
	m_pUnkMetabase.Release();
	m_pUnkMarshaler.Release();
	REMOVE_DEBUG_OBJECT
	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\gmoniker.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	gmoniker.h

Abstract:

	This module contains the definition for the
	CSEOGenericMoniker object.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   04/11/97        created

--*/

// GMONIKER.H : Declaration of the CSEOGenericMoniker

#define GENERIC_MONIKER_PROGID L"SEO.SEOGenericMoniker"
#define GENERIC_MONIKER_VERPROGID GENERIC_MONIKER_PROGID L".1"


/////////////////////////////////////////////////////////////////////////////
// CSEOGenericMoniker

class ATL_NO_VTABLE CSEOGenericMoniker : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEOGenericMoniker, &CLSID_CSEOGenericMoniker>,
	public IParseDisplayName,
	public IDispatchImpl<IMoniker, &IID_IMoniker, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOGenericMoniker Class",
								   GENERIC_MONIKER_VERPROGID,
								   GENERIC_MONIKER_PROGID);

	BEGIN_COM_MAP(CSEOGenericMoniker)
		COM_INTERFACE_ENTRY(IMoniker)
		COM_INTERFACE_ENTRY(IParseDisplayName)
		COM_INTERFACE_ENTRY(IPersistStream) // Needed for OleLoadFromStream support
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IPersist
	public:
		HRESULT STDMETHODCALLTYPE GetClassID( 
			/* [out] */ CLSID __RPC_FAR *pClassID);
        

	// IPersistStream
	public:
		HRESULT STDMETHODCALLTYPE IsDirty(void);
        
		HRESULT STDMETHODCALLTYPE Load( 
			/* [unique][in] */ IStream __RPC_FAR *pStm);
        
		HRESULT STDMETHODCALLTYPE Save( 
			/* [unique][in] */ IStream __RPC_FAR *pStm,
			/* [in] */ BOOL fClearDirty);
        
		HRESULT STDMETHODCALLTYPE GetSizeMax( 
			/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
        

	// IMoniker
	public:
		/* [local] */ HRESULT STDMETHODCALLTYPE BindToObject( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ REFIID riidResult,
			/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult);
        
		/* [local] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObj);
        
		HRESULT STDMETHODCALLTYPE Reduce( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [in] */ DWORD dwReduceHowFar,
			/* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced);
        
		HRESULT STDMETHODCALLTYPE ComposeWith( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
			/* [in] */ BOOL fOnlyIfNotGeneric,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite);
        
		HRESULT STDMETHODCALLTYPE Enum( 
			/* [in] */ BOOL fForward,
			/* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker);
        
		HRESULT STDMETHODCALLTYPE IsEqual( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker);
        
		HRESULT STDMETHODCALLTYPE Hash( 
			/* [out] */ DWORD __RPC_FAR *pdwHash);
        
		HRESULT STDMETHODCALLTYPE IsRunning( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning);
        
		HRESULT STDMETHODCALLTYPE GetTimeOfLastChange( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [out] */ FILETIME __RPC_FAR *pFileTime);
        
		HRESULT STDMETHODCALLTYPE Inverse( 
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk);
        
		HRESULT STDMETHODCALLTYPE CommonPrefixWith( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix);
        
		HRESULT STDMETHODCALLTYPE RelativePathTo( 
			/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath);
        
		HRESULT STDMETHODCALLTYPE GetDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName);
        
		HRESULT STDMETHODCALLTYPE ParseDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
			/* [in] */ LPOLESTR pszDisplayName,
			/* [out] */ ULONG __RPC_FAR *pchEaten,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);
        
		HRESULT STDMETHODCALLTYPE IsSystemMoniker( 
			/* [out] */ DWORD __RPC_FAR *pdwMksys);
        

	// IParseDisplayName
	public:
		HRESULT STDMETHODCALLTYPE ParseDisplayName( 
			/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
			/* [in] */ LPOLESTR pszDisplayName,
			/* [out] */ ULONG __RPC_FAR *pchEaten,
			/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut);

	DECLARE_GET_CONTROLLING_UNKNOWN();

	protected:
		HRESULT CreateBoundObject(IPropertyBag *pBag, ISEOInitObject **ppResult);
		void SetPropertyBag(IPropertyBag *pBag);
		void SetMonikerString(LPCOLESTR psString) {
			m_bstrMoniker = psString;
		}

	private: // Private data
		CComBSTR m_bstrMoniker;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\events.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	events.h

Abstract:

	This module contains the definition for the Server
	Extension Objects Server Events classes.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	04/04/97	created

--*/


// events.h : Declaration of the Server Events classes

/////////////////////////////////////////////////////////////////////////////
// CEventDatabasePlugin
class ATL_NO_VTABLE CEventDatabasePlugin :
	public IEventDatabasePlugin
{
	// IEventDatabasePlugin
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventPropertyBag **ppDatabase);
		HRESULT STDMETHODCALLTYPE put_Database(IEventPropertyBag *pDatabase);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventPropertyBag **ppDatabase);
		HRESULT STDMETHODCALLTYPE get_Name(BSTR *pstrName);
		HRESULT STDMETHODCALLTYPE put_Name(BSTR strName);
		HRESULT STDMETHODCALLTYPE putref_Name(BSTR *pstrName);
		HRESULT STDMETHODCALLTYPE get_Parent(IEventPropertyBag **ppParent);
		HRESULT STDMETHODCALLTYPE put_Parent(IEventPropertyBag *pParent);
		HRESULT STDMETHODCALLTYPE putref_Parent(IEventPropertyBag **ppParent);

	protected:
		CComPtr<IEventPropertyBag> m_pDatabase;
		CComBSTR m_strName;
		CComPtr<IEventPropertyBag> m_pParent;
};


/////////////////////////////////////////////////////////////////////////////
// CEventManager
class ATL_NO_VTABLE CEventManager :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventManager, &CLSID_CEventManager>,
	public IDispatchImpl<IEventManager, &IID_IEventManager, &LIBID_SEOLib>,
	public CEventDatabasePlugin
{
	DEBUG_OBJECT_DEF(CEventManager)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventManager Class",
								   L"Event.Manager.1",
								   L"Event.Manager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventManager)
		COM_INTERFACE_ENTRY(IEventManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventManager)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventManager
	public:
		HRESULT STDMETHODCALLTYPE get_SourceTypes(IEventSourceTypes **ppSourceTypes);
		HRESULT STDMETHODCALLTYPE CreateSink(IEventBinding *pBinding,
											 IEventDeliveryOptions *pDeliveryOptions,
											 IUnknown **ppUnkSink);

	private:
		CComPtr<IEventLock> m_pLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventBindingManager
class ATL_NO_VTABLE CEventBindingManager :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventBindingManager, &CLSID_CEventBindingManager>,
	public IDispatchImpl<IEventBindingManager, &IID_IEventBindingManager, &LIBID_SEOLib>,
	public CEventDatabasePlugin,
	public ISEOInitObject,
	public IConnectionPointContainerImpl<CEventBindingManager>,
	public CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChange>,
	public CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChangeDisp>,
	public IEventNotifyBindingChange,
	public IProvideClassInfo2Impl<&CLSID_CEventBindingManager,&IID_IEventNotifyBindingChangeDisp,&LIBID_SEOLib>,
	public IDispatchImpl<IEventBindingManagerCopier, &IID_IEventBindingManagerCopier, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventBindingManager)

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventBindingManager Class",
								   L"Event.BindingManager.1",
								   L"Event.BindingManager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventBindingManager)
		COM_INTERFACE_ENTRY(IEventBindingManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventBindingManager)
		COM_INTERFACE_ENTRY(IEventDatabasePlugin)
		COM_INTERFACE_ENTRY(ISEOInitObject)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
		COM_INTERFACE_ENTRY(IEventNotifyBindingChange)
		COM_INTERFACE_ENTRY(IProvideClassInfo2)
		COM_INTERFACE_ENTRY(IEventBindingManagerCopier)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	BEGIN_CONNECTION_POINT_MAP(CEventBindingManager)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChange)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChangeDisp)
	END_CONNECTION_POINT_MAP()

	// IEventBindingManager
	public:
		HRESULT STDMETHODCALLTYPE get_Bindings(BSTR pszEventType, IEventBindings **ppBindings);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);

	// ISEOInitObject (IPersistPropertyBag)
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);
		HRESULT STDMETHODCALLTYPE InitNew(void);
		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	// IEventBindingManagerCopier
	public:
		HRESULT STDMETHODCALLTYPE Copy(long lTimeout, IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE EmptyCopy(IEventBindingManager **ppBindingManager);

	// CSEOConnectionPointImpl<>
	public:
		void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount);
		void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount);

	private:
		typedef CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChange> CP_ENBC;
		typedef CSEOConnectionPointImpl<CEventBindingManager, &IID_IEventNotifyBindingChangeDisp> CP_ENBCD;
		DWORD m_dwCPCookie;
		CComPtr<IConnectionPoint> m_pCP;
		CComBSTR m_strDatabaseManager;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventMetabaseDatabaseManager
class ATL_NO_VTABLE CEventMetabaseDatabaseManager :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventMetabaseDatabaseManager, &CLSID_CEventMetabaseDatabaseManager>,
	public IDispatchImpl<IEventDatabaseManager, &IID_IEventDatabaseManager, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventMetabaseDatabaseManager)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventMetabaseDatabaseManager Class",
								   L"Event.MetabaseDatabaseManager.1",
								   L"Event.MetabaseDatabaseManager");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventMetabaseDatabaseManager)
		COM_INTERFACE_ENTRY(IEventDatabaseManager)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventDatabaseManager)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventDatabaseManager
	public:
		HRESULT STDMETHODCALLTYPE CreateDatabase(BSTR strPath, IUnknown **ppMonDatabase);
		HRESULT STDMETHODCALLTYPE EraseDatabase(BSTR strPath);
		HRESULT STDMETHODCALLTYPE MakeVServerPath(BSTR strService, long lInstance, BSTR *pstrPath);
		HRESULT STDMETHODCALLTYPE MakeVRootPath(BSTR strService, long lInstance, BSTR strRoot, BSTR *pstrPath);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventUtil
class ATL_NO_VTABLE CEventUtil :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventUtil, &CLSID_CEventUtil>,
	public IDispatchImpl<IEventUtil, &IID_IEventUtil, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventUtil)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventUtil Class",
								   L"Event.Util.1",
								   L"Event.Util");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventUtil)
		COM_INTERFACE_ENTRY(IEventUtil)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventUtil)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventUtil
	public:
		HRESULT STDMETHODCALLTYPE DisplayNameFromMoniker(IUnknown *pUnkMoniker, BSTR *pstrDisplayName);
		HRESULT STDMETHODCALLTYPE MonikerFromDisplayName(BSTR strDisplayName, IUnknown **ppUnkMoniker);
		HRESULT STDMETHODCALLTYPE ObjectFromMoniker(IUnknown *pUnkMoniker, IUnknown **ppUnkObject);
		HRESULT STDMETHODCALLTYPE GetNewGUID(BSTR *pstrGUID);
		HRESULT STDMETHODCALLTYPE CopyPropertyBag(IUnknown *pUnkInput, IUnknown **ppUnkOutput);
		HRESULT STDMETHODCALLTYPE CopyPropertyBagShallow(IUnknown *pUnkInput, IUnknown **ppUnkOutput);
		HRESULT STDMETHODCALLTYPE DispatchFromObject(IUnknown *pUnkObject, IDispatch **ppDispOutput);
		HRESULT STDMETHODCALLTYPE GetIndexedGUID(BSTR strGUID, long lIndex, BSTR *pstrResult);
		HRESULT STDMETHODCALLTYPE RegisterSource(BSTR strSourceType,
												 BSTR strSource,
												 long lInstance,
												 BSTR strService,
												 BSTR strVRoot,
												 BSTR strDatabaseManager,
												 BSTR strDisplayName,
												 IEventBindingManager **ppBindingManager);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventComCat
class ATL_NO_VTABLE CEventComCat :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventComCat, &CLSID_CEventComCat>,
	public IDispatchImpl<IEventComCat, &IID_IEventComCat, &LIBID_SEOLib>
{
	DEBUG_OBJECT_DEF(CEventComCat)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventComCat Class",
								   L"Event.ComCat.1",
								   L"Event.ComCat");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventComCat)
		COM_INTERFACE_ENTRY(IEventComCat)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventComCat)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventComCat
	public:
		HRESULT STDMETHODCALLTYPE RegisterCategory(BSTR pszCategory, BSTR pszDescription, long lcidLanguage);
		HRESULT STDMETHODCALLTYPE UnRegisterCategory(BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE RegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE UnRegisterClassImplementsCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE RegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE UnRegisterClassRequiresCategory(BSTR pszClass, BSTR pszCategory);
		HRESULT STDMETHODCALLTYPE GetCategories(SAFEARRAY **ppsaCategories);
		HRESULT STDMETHODCALLTYPE GetCategoryDescription(BSTR strCategory, long lcidLanguage, BSTR *pstrDescription);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CEventRouter
class ATL_NO_VTABLE CEventRouter :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventRouter, &CLSID_CEventRouter>,
	public IEventRouter
{
	DEBUG_OBJECT_DEF(CEventRouter)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventRouter Class",
								   L"Event.Router.1",
								   L"Event.Router");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventRouter)
		COM_INTERFACE_ENTRY(IEventRouter)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventRouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE put_Database(IEventBindingManager *pBindingManager);
		HRESULT STDMETHODCALLTYPE putref_Database(IEventBindingManager **ppBindingManager);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent,
												REFIID iidDesired,
												IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher,
													   REFIID iidEvent,
													   REFIID iidDesired,
													   IUnknown **ppUnkResult);

		HRESULT STDMETHODCALLTYPE GetDispatcherByClassFactory(REFCLSID clsidDispatcher,
															  IClassFactory *piClassFactory,
															  REFIID iidEvent,
															  REFIID iidDesired,
															  IUnknown **ppUnkResult);

	private:
		CComPtr<IEventRouter> m_pRouter;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


EXTERN_C const CLSID CLSID_CEventServiceObject;


/////////////////////////////////////////////////////////////////////////////
// CEventServiceObject
class ATL_NO_VTABLE CEventServiceObject :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventServiceObject, &CLSID_CEventServiceObject>,
	public IUnknown
{
	DEBUG_OBJECT_DEF(CEventServiceObject)
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventServiceObject Class",
								   L"Event.ServiceObject.1",
								   L"Event.ServiceObject");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventServiceObject)
		COM_INTERFACE_ENTRY(IUnknown)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventNotifyBindingChange
	public:
		HRESULT STDMETHODCALLTYPE OnChange();

	private:
		CComQIPtr<IConnectionPointContainer,&IID_IConnectionPointContainer> m_pCPC;
		DWORD m_dwCookie;
		CComPtr<IUnknown> m_pSubObject;
		CComPtr<IUnknown> m_pUnkMetabase;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\item.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	item.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Item class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	02/18/97	created

--*/


// item.cpp : Implementation of CSEODictionaryItem
#include "stdafx.h"
#include "seodefs.h"
#include "item.h"


static HRESULT VarToIndex(DWORD *pdwIndex, VARIANT *pvarFrom, DWORD dwCount, BOOL bBoundsError=TRUE) {
	TraceFunctEnter("VarToIndex");
	VARIANT varIndex;
	HRESULT hr;

	if (!pvarFrom || (pvarFrom->vt == VT_ERROR)) {
		if (bBoundsError && !dwCount) {
			TraceFunctLeave();
			return (SEO_E_NOTPRESENT);
		}
		*pdwIndex = 0;
		TraceFunctLeave();
		return (S_OK);
	}
	if (!dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	VariantInit(&varIndex);
	if (pvarFrom->vt != VT_I4) {
		hr = VariantChangeTypeEx(&varIndex,pvarFrom,LOCALE_NEUTRAL,0,VT_I4);
		if (!SUCCEEDED(hr)) {
			VariantClear(&varIndex);
			TraceFunctLeave();
			return (hr);
		}
	} else {
		varIndex.vt = VT_I4;
		varIndex.lVal = pvarFrom->lVal;
	}
	if ((varIndex.iVal < 0) || (bBoundsError && ((DWORD) varIndex.iVal >= dwCount))) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	*pdwIndex = min(dwCount,(DWORD) varIndex.iVal);
	TraceFunctLeave();
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSEODictionaryItem


HRESULT CSEODictionaryItem::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEODictionaryItem::FinalConstruct");

	m_dwCount = 0;
	m_pvcValues = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEODictionaryItem::FinalRelease() {
	TraceFunctEnter("CSEODictionaryItem::FinalRelease");

	if (m_pvcValues) {
		DWORD dwIdx;

		for (dwIdx=0;dwIdx<m_dwCount;dwIdx++) {
			m_pvcValues[dwIdx].~ValueClass();
		}
		CoTaskMemFree(m_pvcValues);
		m_pvcValues = NULL;
	}
	m_dwCount = 0;
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::get_Value(VARIANT *pvarIndex, VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::get_Value");
	DWORD dwIndex;
	HRESULT hr;

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsVariant(pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddValue(VARIANT *pvarIndex, VARIANT *pvarValue) {
	TraceFunctEnter("CSEODictionaryItem::AddValue");
	DWORD dwIndex;
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pvarValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount,FALSE);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pvarValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::DeleteValue(VARIANT *pvarIndex) {
	TraceFunctEnter("CSEODictionaryItem::DeleteValue");
	DWORD dwIndex;
	HRESULT hr;

	if (!pvarIndex) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = VarToIndex(&dwIndex,pvarIndex,m_dwCount);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	m_pvcValues[dwIndex].~ValueClass();
	m_dwCount--;
	memcpy(&m_pvcValues[dwIndex-1],&m_pvcValues[dwIndex],sizeof(m_pvcValues[0])*(m_dwCount-dwIndex));
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::get_Count(VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::get_Count");

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	pvarResult->vt = VT_I4;
	pvarResult->lVal = (LONG) m_dwCount;
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::GetStringA(DWORD dwIndex, DWORD *pchCount, LPSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::GetStringA");

	if (dwIndex >= m_dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsStringA(pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::GetStringW(DWORD dwIndex, DWORD *pchCount, LPWSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::GetStringW");

	if (dwIndex >= m_dwCount) {
		TraceFunctLeave();
		return (SEO_E_NOTPRESENT);
	}
	TraceFunctLeave();
	return (m_pvcValues[dwIndex].AsStringW(pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddStringA(DWORD dwIndex, LPCSTR pszValue) {
	TraceFunctEnter("CSEODictionaryItem::AddStringA");
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pszValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pszValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEODictionaryItem::AddStringW(DWORD dwIndex, LPCWSTR pszValue) {
	TraceFunctEnter("CSEODictionaryItem::AddStringW");
	HRESULT hr;
	ValueClass *pvcValue;

	if (!pszValue) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	hr = AddSlot(&dwIndex,&pvcValue);
	if (!SUCCEEDED(hr)) {
		TraceFunctLeave();
		return (hr);
	}
	hr = m_pvcValues[dwIndex].Assign(pszValue);
	if (!SUCCEEDED(hr)) {
		VARIANT varIndex;

		VariantInit(&varIndex);
		varIndex.vt = VT_I4;
		varIndex.lVal = dwIndex;
		DeleteValue(&varIndex);
		TraceFunctLeave();
		return (hr);
	}
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::AddSlot(DWORD *pdwIndex, ValueClass **ppvcResult) {
	TraceFunctEnter("CSEODictionaryItem::AddSlot");
	LPVOID pvRes;

	if (*pdwIndex > m_dwCount) {
		*pdwIndex = m_dwCount;
	}
	pvRes = CoTaskMemRealloc(m_pvcValues,sizeof(m_pvcValues[0])*(m_dwCount+1));
	if (!pvRes) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_pvcValues = (ValueClass *) pvRes;
	memcpy(&m_pvcValues[*pdwIndex+1],&m_pvcValues[*pdwIndex],sizeof(m_pvcValues[0])*(m_dwCount-*pdwIndex));
	new(&m_pvcValues[*pdwIndex]) ValueClass();
	m_dwCount++;
	*ppvcResult = &m_pvcValues[*pdwIndex];
	TraceFunctLeave();
	return (S_OK);
}


CSEODictionaryItem::ValueClass::ValueClass() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::ValueClass");

	Init();
	TraceFunctLeave();
}


CSEODictionaryItem::ValueClass::ValueClass(ValueClass& vcFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::ValueClass");

	Init();
	Assign(vcFrom);
	TraceFunctLeave();
}


CSEODictionaryItem::ValueClass::~ValueClass() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::~ValueClass");

	Clear();
	TraceFunctLeave();
}


void CSEODictionaryItem::ValueClass::Init() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Init");

	m_vtValue.veType = veNone;
	m_vtValue.pszStringA = NULL;
	VariantInit(&m_vtValue.varVARIANT);
	TraceFunctLeave();
}


void CSEODictionaryItem::ValueClass::Clear() {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Clear");

	m_vtValue.veType = veNone;
	if (m_vtValue.pszStringA) {
		CoTaskMemFree(m_vtValue.pszStringA);
		m_vtValue.pszStringA = NULL;
	}
	VariantClear(&m_vtValue.varVARIANT);
	TraceFunctLeave();
}


HRESULT CSEODictionaryItem::ValueClass::Assign(ValueClass& vcFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (&vcFrom != this) {
		switch (m_vtValue.veType) {

			case veStringA:
				TraceFunctLeave();
				return (Assign(vcFrom.m_vtValue.pszStringA));

			case veVARIANT:
				TraceFunctLeave();
				return (Assign(&vcFrom.m_vtValue.varVARIANT));
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(LPCSTR pszFromA) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (!pszFromA) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	m_vtValue.pszStringA = (LPSTR) CoTaskMemAlloc(strlen(pszFromA)+1);
	if (!m_vtValue.pszStringA) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_vtValue.veType = veStringA;
	strcpy(m_vtValue.pszStringA,pszFromA);
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(VARIANT *pvarFrom) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");
	HRESULT hr;

	if (!pvarFrom) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	hr = VariantCopy(&m_vtValue.varVARIANT,pvarFrom);
	if (SUCCEEDED(hr)) {
		m_vtValue.veType = veVARIANT;
	}
	TraceFunctLeave();
	return (hr);
}


HRESULT CSEODictionaryItem::ValueClass::Assign(LPCWSTR pszFromW) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::Assign");

	if (!pszFromW) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	Clear();
	m_vtValue.varVARIANT.bstrVal = SysAllocString(pszFromW);
	if (!m_vtValue.varVARIANT.bstrVal) {
		TraceFunctLeave();
		return (E_OUTOFMEMORY);
	}
	m_vtValue.varVARIANT.vt = VT_BSTR;
	m_vtValue.veType = veVARIANT;
	TraceFunctLeave();
	return (S_OK);
}


HRESULT CSEODictionaryItem::ValueClass::AsVariant(VARIANT *pvarResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsVariant");

	if (!pvarResult) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	VariantInit(pvarResult);
	switch (m_vtValue.veType) {

		case veStringA: {
			DWORD dwLen = strlen(m_vtValue.pszStringA);

			pvarResult->bstrVal = SysAllocStringLen(NULL,dwLen);
			if (!pvarResult->bstrVal) {
				TraceFunctLeave();
				return (E_OUTOFMEMORY);
			}
			ATLA2WHELPER(pvarResult->bstrVal,m_vtValue.pszStringA,dwLen);
			pvarResult->vt = VT_BSTR;
			TraceFunctLeave();
			return (S_OK);
		}

		case veVARIANT:
			TraceFunctLeave();
			return (VariantCopy(pvarResult,&m_vtValue.varVARIANT));
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::AsStringA(DWORD *pchCount, LPSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsStringA");

	if (!pchCount) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	switch (m_vtValue.veType) {

		case veStringA:
			if (pszResult) {
				DWORD dwLen = strlen(m_vtValue.pszStringA);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				memcpy(pszResult,m_vtValue.pszStringA,dwCopy);
				if (dwCopy == *pchCount) {
					pszResult[dwCopy-1] = 0;
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = strlen(m_vtValue.pszStringA) + 1;
				TraceFunctLeave();
				return (S_OK);
			}

		case veVARIANT: {
			VARIANT varValue;
			LPCWSTR pszValue;
			HRESULT hr;

			VariantInit(&varValue);
			if (m_vtValue.varVARIANT.vt != VT_BSTR) {
				hr = VariantChangeTypeEx(&varValue,&m_vtValue.varVARIANT,LOCALE_NEUTRAL,0,VT_BSTR);
				if (!SUCCEEDED(hr)) {
					VariantClear(&varValue);
					TraceFunctLeave();
					return (hr);
				}
				pszValue = varValue.bstrVal;
			} else {
				pszValue = m_vtValue.varVARIANT.bstrVal;
			}
			if (pszResult) {
				DWORD dwLen = wcslen(pszValue);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				ATLW2AHELPER(pszResult,pszValue,dwCopy);
				VariantClear(&varValue);
				if (dwCopy == *pchCount) {
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = wcslen(pszValue) + 1;
				VariantClear(&varValue);
				TraceFunctLeave();
				return (S_OK);
			}
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


HRESULT CSEODictionaryItem::ValueClass::AsStringW(DWORD *pchCount, LPWSTR pszResult) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::AsStringW");

	if (!pchCount) {
		TraceFunctLeave();
		return (E_POINTER);
	}
	switch (m_vtValue.veType) {

		case veStringA:
			if (pszResult) {
				DWORD dwLen = strlen(m_vtValue.pszStringA);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				ATLA2WHELPER(pszResult,m_vtValue.pszStringA,dwCopy);
				if (dwCopy == *pchCount) {
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = strlen(m_vtValue.pszStringA) + 1;
				TraceFunctLeave();
				return (S_OK);
			}

		case veVARIANT: {
			VARIANT varValue;
			LPCWSTR pszValue;
			HRESULT hr;

			VariantInit(&varValue);
			if (m_vtValue.varVARIANT.vt != VT_BSTR) {
				hr = VariantChangeTypeEx(&varValue,&m_vtValue.varVARIANT,LOCALE_NEUTRAL,0,VT_BSTR);
				if (!SUCCEEDED(hr)) {
					VariantClear(&varValue);
					TraceFunctLeave();
					return (hr);
				}
				pszValue = varValue.bstrVal;
			} else {
				pszValue = m_vtValue.varVARIANT.bstrVal;
			}
			if (pszResult) {
				DWORD dwLen = wcslen(pszValue);
				DWORD dwCopy = min(*pchCount,dwLen+1);
				BOOL bMoreData = FALSE;

				memcpy(pszResult,pszValue,dwCopy);
				VariantClear(&varValue);
				if (dwCopy == *pchCount) {
					pszResult[dwCopy-1] = 0;
					bMoreData = TRUE;
				}
				*pchCount = dwCopy;
				TraceFunctLeave();
				return (bMoreData?SEO_S_MOREDATA:S_OK);
			} else {
				*pchCount = wcslen(pszValue) + 1;
				VariantClear(&varValue);
				TraceFunctLeave();
				return (S_OK);
			}
		}
	}
	TraceFunctLeave();
	return (E_UNEXPECTED);
}


void *CSEODictionaryItem::ValueClass::operator new(size_t cbSize, CSEODictionaryItem::ValueClass *pvcInPlace) {
	TraceFunctEnter("CSEODictionaryItem::ValueClass::operator new");

	TraceFunctLeave();
	return (pvcInPlace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\item.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	item.h

Abstract:

	This module contains the definition for the Server
	Extension Object Item class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	02/18/97	created

--*/


// item.h : Declaration of the CSEODictionaryItem

/////////////////////////////////////////////////////////////////////////////
// CSEODictionaryItem
class ATL_NO_VTABLE CSEODictionaryItem :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEODictionaryItem, &CLSID_CSEODictionaryItem>,
	public IDispatchImpl<ISEODictionaryItem, &IID_ISEODictionaryItem, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEODictionaryItem Class",
								   L"SEO.SEODictionaryItem.1",
								   L"SEO.SEODictionaryItem");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEODictionaryItem)
		COM_INTERFACE_ENTRY(ISEODictionaryItem)
		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionaryItem
	public:
		HRESULT STDMETHODCALLTYPE get_Value(VARIANT *pvarIndex, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE AddValue(VARIANT *pvarIndex, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE DeleteValue(VARIANT *pvarIndex);
		HRESULT STDMETHODCALLTYPE get_Count(VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE GetStringA(DWORD dwIndex, DWORD *pchCount, LPSTR pszResult);
		HRESULT STDMETHODCALLTYPE GetStringW(DWORD dwIndex, DWORD *pchCount, LPWSTR pszResult);
		HRESULT STDMETHODCALLTYPE AddStringA(DWORD dwIndex, LPCSTR pszValue);
		HRESULT STDMETHODCALLTYPE AddStringW(DWORD dwIndex, LPCWSTR pszValue);

	private:
		class ValueClass {
			public:
				ValueClass();
				ValueClass(ValueClass& vcFrom);
				~ValueClass();
				void Init();
				void Clear();
				HRESULT Assign(ValueClass& vcFrom);
				HRESULT Assign(LPCSTR pszFromA);
				HRESULT Assign(VARIANT *pvarFrom);
				HRESULT Assign(LPCWSTR pszFromW);
				HRESULT AsVariant(VARIANT *pvarResult);
				HRESULT AsStringA(DWORD *pchCount, LPSTR pszResult);
				HRESULT AsStringW(DWORD *pchCount, LPWSTR pszResult);
				void *operator new(size_t cbSize, ValueClass *pvcInPlace);
                void operator delete(void * p) {}

#if _MSC_VER >= 1200
                void operator delete(void * p, ValueClass *pvcInPlace) {}
#endif

			private:
				typedef enum tagValueEnum {
					veNone,
					veStringA,
					veVARIANT
				} ValueEnum;
				typedef struct tagValueType {
					ValueEnum veType;
					union {
						LPSTR pszStringA;
						VARIANT varVARIANT;
					};
				} ValueType;
				ValueType m_vtValue;
		};
		HRESULT AddSlot(DWORD *pdwIndex,ValueClass **ppvcResult);
		DWORD m_dwCount;
		ValueClass *m_pvcValues;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\membag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	membag.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Memory Property Bag.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   02/10/97        created
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/

// MEMBAG.cpp : Implementation of CSEOMemDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "String"
#include "MEMBAG.h"


HRESULT ResolveVariant(IEventPropertyBag *pBag, VARIANT *pvarPropDesired, CComVariant &varResult) {
	if (!pvarPropDesired) {
		return (E_POINTER);
	}

	varResult.Clear();
	HRESULT hrRes = S_OK;
	CComVariant varIndex; // Hold the I4 type


	switch (pvarPropDesired->vt & VT_TYPEMASK) {
		case VT_I1:  case VT_I2:  case VT_I4:  case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
		case VT_R4:  case VT_R8:
		case VT_INT: case VT_UINT: // Any type of number
			hrRes = VariantChangeType(&varIndex, pvarPropDesired, 0, VT_I4);
			varResult.vt = VT_BSTR;
			varResult.bstrVal = NULL;
			if (SUCCEEDED(hrRes)) {
				hrRes = pBag->Name(varIndex.lVal, &varResult.bstrVal);
			}
			break;

		default: // Otherwise, convert to a string
			hrRes = VariantChangeType(&varResult, pvarPropDesired, 0, VT_BSTR);
			break;
	}

	return (hrRes);
}



HRESULT DataItem::AsVARIANT(VARIANT *pvarResult) const {
	if(!pvarResult) return E_POINTER;
	CComVariant varResult;

	if(IsDWORD()) varResult = (long) dword;
	else if(IsString()) varResult = pStr;
	else if(IsInterface()) varResult = pUnk;
	else varResult.Clear();

	return varResult.Detach(pvarResult);
}

DataItem::DataItem(VARIANT *pVar) {
	eType = Empty;
	if(!pVar) return;

	switch (pVar->vt) {
		case VT_EMPTY:
			// Already set to Empty
			break;

		case VT_I4:
			eType = DWord;
			dword = pVar->lVal;
			break;

		case VT_UNKNOWN:
		case VT_DISPATCH:
			eType = Interface;
			pUnk = pVar->punkVal;
			if(pUnk) pUnk->AddRef();
			break;

		default:
			eType = String;
			CComVariant vNew;
			vNew.ChangeType(VT_BSTR, pVar);
			iStringSize = SysStringLen(vNew.bstrVal) + 1;
			pStr = (LPSTR) MyMalloc(iStringSize * sizeof(WCHAR));
			if (pStr) {
				ATLW2AHELPER(pStr, vNew.bstrVal, iStringSize * sizeof(WCHAR));
			}
			break;
	}

    m_pszKey = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionaryEnum

class CSEOMemDictionaryEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
        CSEOMemDictionaryEnum() : m_iIterator(&m_dummylist) {}
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEOMemDictionary *, OurMap::iterator * = NULL);

	BEGIN_COM_MAP(CSEOMemDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		OurMap::iterator m_iIterator;
        OurList m_dummylist;
		CSEOMemDictionary *m_dictionary;
        CShareLockNH *m_pLock;
};

HRESULT CSEOMemDictionaryEnum::FinalConstruct() {
	m_dictionary = NULL;
	return S_OK;
}

void CSEOMemDictionaryEnum::FinalRelease() {
	if(m_dictionary) {
        m_dictionary->m_lock.ShareUnlock();
        m_dictionary->GetControllingUnknown()->Release();
    }
	m_dictionary = NULL;
}

STDMETHODIMP CSEOMemDictionaryEnum::Init(CSEOMemDictionary *pDict, OurMap::iterator *omi) {
	if(m_dictionary) {
        m_dictionary->m_lock.ShareUnlock();
        m_dictionary->GetControllingUnknown()->Release();
    }

	m_dictionary = pDict;

	if(m_dictionary) {
		m_dictionary->GetControllingUnknown()->AddRef();
        m_dictionary->m_lock.ShareLock();
        if (omi) {
            m_iIterator = *omi;
        } else {
		    m_iIterator.SetList(&(m_dictionary->m_mData));
        }
	}

	return S_OK;
}

STDMETHODIMP CSEOMemDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResultParam) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	if(!varDest) return E_POINTER;
	DWORD dwDummy = 0;
	LPDWORD pdwResult = (pdwResultParam ? pdwResultParam : &dwDummy);
	*pdwResult = 0; // Nothing done so far
	HRESULT hrRes = S_OK; // So far, so good

    _ASSERT(m_iIterator.GetHead() != &m_dummylist);

	while(SUCCEEDED(hrRes) && (*pdwResult < dwCount) &&
	      (!(m_iIterator.AtEnd()))) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		CComVariant varResult(m_iIterator.GetKey());
		if (varResult.vt == VT_ERROR) {
			if (hrRes == S_OK) hrRes = varResult.scode;
			while (*pdwResult) {
				--(*pdwResult);
				VariantClear(&varDest[*pdwResult]);
			}
			break;
		}
		VariantInit(&varDest[*pdwResult]);
		hrRes = varResult.Detach(&varDest[*pdwResult]);
		++(*pdwResult); // Increment successful count for caller
		++m_iIterator; // Point to the next one
	}

	return (FAILED(hrRes) ? hrRes : ((*pdwResult < dwCount) ? S_FALSE : S_OK));
}

STDMETHODIMP CSEOMemDictionaryEnum::Skip(DWORD dwCount) {
    _ASSERT(m_iIterator.GetHead() != &m_dummylist);
	for(DWORD i = 0; i < dwCount; ++i) ++m_iIterator;
	return ((!(m_iIterator.AtEnd())) ? S_OK : S_FALSE);
}

STDMETHODIMP CSEOMemDictionaryEnum::Reset(void) {
    _ASSERT(m_iIterator.GetHead() != &m_dummylist);
	m_iIterator.Front();
	return S_OK;
}

STDMETHODIMP CSEOMemDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComObject<CSEOMemDictionaryEnum> *p;
	HRESULT hrRes = CComObject<CSEOMemDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	hrRes = p->Init(m_dictionary, &m_iIterator);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
        if (FAILED(hrRes)) delete p;
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionary


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarName || !pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;
	HRESULT hrRes = E_INVALIDARG;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		hrRes = GetVariantA(W2A(vNew.bstrVal), pvarResult);

		// Convert SEO_E_NOTPRESENT to VT_EMPTY
		if(hrRes == SEO_E_NOTPRESENT) {
			VariantClear(pvarResult);
			hrRes = S_OK;
		}
	}

	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::put_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarName || !pvarValue) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		return SetVariantA(W2A(vNew.bstrVal), pvarValue);
	} else {
		return E_INVALIDARG;
	}
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get__NewEnum(
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComObject<CSEOMemDictionaryEnum> *p;
	HRESULT hrRes = CComObject<CSEOMemDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
        if (FAILED(hrRes)) delete p;
	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	VariantInit(pvarResult);
	if(theIterator.Found()) { // Found
		return (*theIterator)->AsVARIANT(pvarResult);
	} else {
		return SEO_E_NOTPRESENT; // Didn't find it
	}
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantA(W2A(pszName), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	DataItem diItem(pvarValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(pvarValue);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetStringA(
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsString()) {
			strncpy(pszResult, *(theIterator.GetData()), *pchCount);
			return (*pchCount >= (DWORD) (*theIterator)->StringSize()) ?
			       S_OK : SEO_S_MOREDATA;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	USES_CONVERSION;
	OurMap::iterator theIterator = m_mData.find(W2A(pszName));

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsString()) {
			int iSize = min((int) *pchCount, (*theIterator)->StringSize());
			ATLA2WHELPER(pszResult, *(theIterator.GetData()), iSize);
			return (*pchCount >= (DWORD) (*theIterator)->StringSize()) ?
			       S_OK : SEO_S_MOREDATA;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetStringA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	DataItem diItem(pszValue, chCount);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	USES_CONVERSION;
	DataItem diItem(pszValue, chCount);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	if(!pdwResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsDWORD()) {
			*pdwResult = *(*theIterator);
			return S_OK;
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordA(W2A(pszName), pdwResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	DataItem diItem(dwValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(dwValue);
	return Insert(W2A(pszName), diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	if(!ppunkResult) return E_POINTER;
	OurMap::iterator theIterator = m_mData.find(pszName);

	if(theIterator.Found()) { // Found
		if((*theIterator)->IsInterface()) {
			LPUNKNOWN pObj = *(*theIterator);
			return pObj->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
		}
	}

	return SEO_E_NOTPRESENT; // Didn't find it
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::GetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceA(W2A(pszName), iidDesired, ppunkResult);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	DataItem diItem(punkValue);
	return Insert(pszName, diItem);
}

HRESULT STDMETHODCALLTYPE CSEOMemDictionary::SetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	DataItem diItem(punkValue);
	return Insert(W2A(pszName), diItem);
}


HRESULT CSEOMemDictionary::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOMemDictionary::FinalRelease() {
	m_pUnkMarshaler.Release();
}

// Four cases: (exists/not) x (Good/Empty item)
HRESULT CSEOMemDictionary::Insert(LPCSTR pszName, const DataItem &diItem) {
	HRESULT hrRes = S_OK;

    m_lock.ExclusiveLock();

    OurMap::iterator iThisItem = m_mData.find(pszName);
    // If the item was found, remove it
    if(iThisItem.Found()) m_mData.erase(iThisItem);

	// If not an empty item, try to insert it
	if(!diItem.IsEmpty() &&
	   !m_mData.insert(pszName, diItem)) {
		hrRes = E_FAIL;
	}

    m_lock.ExclusiveUnlock();

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	HRESULT hrRes;
	VARTYPE vtType;

	if (!pszPropName || !pVar) {
		return (E_POINTER);
	}

    m_lock.ShareLock();

	vtType = pVar->vt;
//	VariantClear(pVar);
	hrRes = GetVariantW(pszPropName,pVar);
	if (SUCCEEDED(hrRes) && (vtType != VT_EMPTY)) {
		hrRes = VariantChangeType(pVar,pVar,0,vtType);
	}
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pVar);
	}

    m_lock.ShareUnlock();

	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
	return (SetVariantW(pszPropName,pVar));
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue) {
	if (!pvarPropValue) {
		return (E_POINTER);
	}
	VariantInit(pvarPropValue);
	if (!pvarPropDesired) {
		return (E_POINTER);
	}

	CComVariant varResolved;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResolved);

	if (S_OK != hrRes) { // Don't continue if S_FALSE, of FAILED(), etc.
		return (hrRes);
	}

    m_lock.ShareLock();

	hrRes = GetVariantW(varResolved.bstrVal, pvarPropValue);
	if (hrRes == SEO_E_NOTPRESENT) {
	    m_lock.ShareUnlock();
		return (S_FALSE);
	}
	if (SUCCEEDED(hrRes)) {
		VariantChangeType(pvarPropValue,pvarPropValue,0,VT_DISPATCH);
		_ASSERTE(pvarPropValue->vt!=VT_UNKNOWN);
	}

    m_lock.ShareUnlock();

	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Name(long lPropIndex, BSTR *pbstrPropName) {
    m_lock.ShareLock();

	OurMap::iterator iIterator = m_mData.begin();
	CComBSTR bstrName;

	if (!pbstrPropName) {
        m_lock.ShareUnlock();
		return (E_POINTER);
	}

	*pbstrPropName = NULL;
	if (lPropIndex < 1) {
        m_lock.ShareUnlock();
		return (S_FALSE);
	}
	while ((--lPropIndex > 0) && (!iIterator.AtEnd())) {
        ++iIterator;
	}
	if (iIterator.AtEnd()) {
        m_lock.ShareUnlock();
		return (S_FALSE);
	}
	bstrName = iIterator.GetKey();
	*pbstrPropName = bstrName.Detach();

    m_lock.ShareUnlock();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Add(BSTR pszPropName, VARIANT *pvarPropValue) {
	return (SetVariantW(pszPropName,pvarPropValue));
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::Remove(VARIANT *pvarPropDesired) {
	CComVariant varResolved;

	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResolved);

	if (S_OK != hrRes) { // Don't continue if S_FALSE, of FAILED(), etc.
		return (hrRes);
	}

    m_lock.ExclusiveLock();

	USES_CONVERSION;
	OurMap::iterator iThisItem = m_mData.find(W2A(varResolved.bstrVal));

	// If the item was found, remove it
	if(iThisItem.Found()) {
		m_mData.erase(iThisItem);
	} else {
//		_ASSERT(FALSE); // ResolveVariant should have returned something for find() to find
		hrRes = S_FALSE; // Not found
	}

    m_lock.ExclusiveUnlock();

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get_Count(long *plCount) {

	if (!plCount) {
		return (E_POINTER);
	}
    m_lock.ShareLock();
	*plCount = m_mData.size();
    m_lock.ShareUnlock();
	return (S_OK);
}


/*	Just use get__NewEnum from ISEODictionary
HRESULT STDMETHODCALLTYPE CSEOMemDictionary::get__NewEnum(IUnknown **ppUnkEnum) {

	return (E_NOTIMPL);
}	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\membag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	membag.h

Abstract:

	This module contains the definition for the
	ISEODictionary object in memory.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   02/10/97        created
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/

// MEMBAG.h : Declaration of the CSEOMemDictionary

#include "tfdlist.h"
#include "rwnew.h"


enum DataType {Empty, DWord, String, Interface};
class DataItem {
	public:

    typedef     DLIST_ENTRY*    (*PFNDLIST)( class  DataItem*);

		DataItem() {
            m_pszKey = NULL;
            eType = Empty;
        };
		DataItem(DWORD d) {
            eType = DWord;
            dword = d;
        };
		DataItem(LPCSTR s, int iSize = -1) {
			eType = String;
			iStringSize = ((iSize >= 0) ? iSize : (lstrlen(s) + 1));
			pStr = (LPSTR) MyMalloc(iStringSize);
			if (pStr) {
				strncpy(pStr, s, iStringSize);
			}
            m_pszKey = NULL;
		};
		DataItem(LPCWSTR s, int iSize = -1) {
			eType = String;
			iStringSize = sizeof(WCHAR) * ((iSize >= 0) ? iSize : (wcslen(s) + 1));
			pStr = (LPSTR) MyMalloc(iStringSize);
			if (pStr) {
				ATLW2AHELPER(pStr, s, iStringSize);
			}
            m_pszKey = NULL;
		};
		DataItem(IUnknown *p) {
            eType = Interface;
            pUnk = p;
            if(pUnk) pUnk->AddRef();
            m_pszKey = NULL;
        }
		DataItem(const DataItem &diItem) {
			eType = diItem.eType;
			if(eType == DWord) dword = diItem.dword;
			else if(eType == String) {
				iStringSize = diItem.iStringSize;
				pStr = (LPSTR) MyMalloc(iStringSize);
				if (pStr) {
					strncpy(pStr, diItem.pStr, iStringSize);
				}
			} else if(eType == Interface) {
				pUnk = diItem.pUnk;
				if(pUnk) pUnk->AddRef();
			}
            if (diItem.m_pszKey) {
                m_pszKey = (LPSTR) MyMalloc(lstrlen(diItem.m_pszKey) + 1);
                if (m_pszKey) {
                    strcpy(m_pszKey, diItem.m_pszKey);
                }
            } else {
                m_pszKey = NULL;
            }
		};
		DataItem &operator=(const DataItem &diItem) {
			eType = diItem.eType;
			if(eType == DWord) dword = diItem.dword;
			else if(eType == String) {iStringSize = diItem.iStringSize;
						  pStr = (LPSTR) MyMalloc(iStringSize);
						  if (pStr) {
							  strncpy(pStr, diItem.pStr, iStringSize);}
						  }
			else if(eType == Interface) {pUnk = diItem.pUnk;
						     if(pUnk) pUnk->AddRef();}
            if (diItem.m_pszKey) {
                m_pszKey = (LPSTR) MyMalloc(lstrlen(diItem.m_pszKey) + 1);
                if (m_pszKey) {
                    strcpy(m_pszKey, diItem.m_pszKey);
                }
            } else {
                m_pszKey = NULL;
            }
			return *this;
		};
		DataItem(VARIANT *pVar);
		~DataItem() {
			if(eType == String) MyFree(pStr);
			else if((eType == Interface) && pUnk) pUnk->Release();
			eType = Empty;
            if (m_pszKey) {
                MyFree(m_pszKey);
                m_pszKey = NULL;
            }
		};

        BOOL SetKey(LPCSTR pszKey) {
            if (m_pszKey) {
                MyFree(m_pszKey);
                m_pszKey = NULL;
            }
            m_pszKey = (LPSTR) MyMalloc(lstrlen(pszKey) + 1);
            if (!m_pszKey) return FALSE;

            strcpy(m_pszKey, pszKey);
            return TRUE;
        }

		BOOL IsEmpty() const {return (eType == Empty);};
		BOOL IsDWORD() const {return (eType == DWord);};
		BOOL IsString() const {return (eType == String);};
		BOOL IsInterface() const {return (eType == Interface);};

		operator DWORD() const {return (const) (IsDWORD() ? dword : 0);};
		operator LPCSTR() const {return (IsString() ? pStr : NULL);};
		LPCSTR GetString() const {return (IsString() ? pStr : NULL);};
		operator LPUNKNOWN() const {return (IsInterface() ? pUnk : NULL);};
		HRESULT AsVARIANT(VARIANT *pVar) const;
		int StringSize() const {return iStringSize;};

         static DLIST_ENTRY *GetListEntry(DataItem *p) {
            return &p->m_listentry;
        }

        LPCSTR GetKey() {
            return m_pszKey;
        }

	private:
		DataType eType;
		int iStringSize;
		union {
			DWORD dword;
			LPSTR pStr;
			LPUNKNOWN pUnk;
		};
        DLIST_ENTRY m_listentry;
        LPSTR m_pszKey;
};

class ComparableString {
	public:
		ComparableString(LPCSTR p = NULL) : m_ptr(0), m_bAlloc(TRUE) {
			if(!p) return;
			m_ptr = (LPSTR) MyMalloc(lstrlen(p) + 1);
			if (m_ptr) {
				lstrcpy(m_ptr, p);
			}
		};
		ComparableString(const ComparableString &csOther) : m_ptr(0) {
			LPCSTR p = csOther.m_ptr;
			m_ptr = (LPSTR) MyMalloc(lstrlen(p) + 1);
			if (m_ptr) {
				lstrcpy(m_ptr, p);
			}
		};
		~ComparableString() {if(m_bAlloc&&m_ptr) MyFree(m_ptr);};
		LPCSTR Data() const {return m_ptr;};
		bool operator<(const ComparableString &csOther) const {
			if (!m_ptr || !csOther.m_ptr) {
				if (csOther.m_ptr) {
					return (true);
				}
				return (false);
			}
			return (lstrcmpi(m_ptr, csOther.m_ptr) < 0);};

	protected:
		LPSTR m_ptr;
		BOOL m_bAlloc;
};

class ComparableStringRef : public ComparableString {
	public:
		ComparableStringRef(LPCSTR p) {
			m_ptr = (LPSTR) p;
			m_bAlloc = FALSE;
		};
};

typedef TDListHead<DataItem, &DataItem::GetListEntry> OurList;

class OurMap {
    public:
        class iterator : public TDListIterator<OurList> {
            public:
                iterator(OurList *pHead)
                    : TDListIterator<OurList>(pHead)
                {
                    m_fFound = FALSE;
                }

                // get the key for the current item
                LPCSTR GetKey() {
                    return Current()->GetKey();
                }

                // get the data for the current item
                DataItem *GetData() {
                    return Current();
                }

		        void operator++() {
                    Next();
                }

		        DataItem *operator*() {
                    return Current();
                }

                void SetList(OurMap *pMap) {
                    ReBind(&(pMap->m_list));
                }

                // point the iterator to a specific item in the list
                // arguments:
                //   pszKey - key to find
                //   iMatchType - -1 == point at first item with smaller key
                //                0 == point at item with key
                //                1 == point at first item with larger key
                // returns:
                //   TRUE if a match was found, FALSE otherwise
                BOOL find(LPCSTR pszKey, DWORD iMatchType = 0) {
                    if (strncmp(pszKey, "-1", 2) == 0) DebugBreak();
                    // reset the iterator
                    Front();

                    // walk until we match the key
                    while (!AtEnd()) {
                        const char *pszCurrentKey = Current()->GetKey();
                        if (lstrcmpi(pszCurrentKey, pszKey) == iMatchType) {
                            m_fFound = TRUE;
                            return TRUE;
                        }
                        Next();
                    }
                    m_fFound = FALSE;
                    return FALSE;
                };

                // did the last search succeed?
                BOOL Found() {
                    return m_fFound;
                }
            private:
                BOOL m_fFound;
        };

        friend iterator;

        OurMap() {
            m_cList = 0;
        }

        ~OurMap() {
            // remove all items from the list
            while (m_cList) {
                delete m_list.PopFront();
                m_cList--;
            }
            _ASSERT(m_list.IsEmpty());
        }

        void erase(iterator i) {
            m_cList--;
            delete i.RemoveItem();
        }

        BOOL insert(LPCSTR pszKey, DataItem di) {
            char buf[255];

            OurMap::iterator it(&m_list);

            DataItem *pDI = new DataItem();
            if (pDI == NULL) return FALSE;

            // copy the data item to the one that we will insert into
            // our list
            *pDI = di;
            if (!pDI->SetKey(pszKey)) {
                delete pDI;
                return FALSE;
            }

            // find the first item with a larger key.  if no such item was
            // found then insert at head of list
            if (it.find(pszKey, 1)) {
                it.InsertBefore(pDI);
            } else {
                m_list.PushFront(pDI);
            }
            m_cList++;

            return TRUE;
        }


        iterator find(LPCSTR pszKey) {
            OurMap::iterator it(&m_list);

            it.find(pszKey);

            return it;
        }

        iterator begin() {
            OurMap::iterator it(&m_list);

            return it;
        }

        long size() {
            return m_cList;
        }

    private:
        OurList m_list;
        long m_cList;
};

/////////////////////////////////////////////////////////////////////////////
// CSEOMemDictionary

class ATL_NO_VTABLE CSEOMemDictionary :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEOMemDictionary, &CLSID_CSEOMemDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>,
	public IPropertyBag,
	public IDispatchImpl<IEventPropertyBag, &IID_IEventPropertyBag, &LIBID_SEOLib>
{
	friend class CSEOMemDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMemDictionary Class",
								   L"SEO.SEOMemDictionary.1",
								   L"SEO.SEOMemDictionary");

	BEGIN_COM_MAP(CSEOMemDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(IPropertyBag)
		COM_INTERFACE_ENTRY(IEventPropertyBag)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventPropertyBag)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
	virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
	    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPWSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCWSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	// IPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Write(LPCOLESTR pszPropName, VARIANT *pVar);

	// IEventPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Name(long lPropIndex, BSTR *pbstrPropName);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszPropName, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarPropDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		/*	Just use the get__NewEnum from ISEODictionary
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);	*/

	protected:
		HRESULT Insert(LPCSTR pszName, const DataItem &diItem);

	private: // Private data
		OurMap m_mData;
        CShareLockNH m_lock;

		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\mimebag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	mimebag.h

Abstract:

	This module contains the definition for the
	object that wraps MimeOle with a Property Bag.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	01/28/97	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// MIMEBAG.h : Declaration of the CSEOMimeDictionary

/////////////////////////////////////////////////////////////////////////////
// CSEOMimeDictionary
class ATL_NO_VTABLE CSEOMimeDictionary : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEOMimeDictionary, &CLSID_CSEOMimeDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMimeDictionary Class",
								   L"SEO.SEOMimeDictionary.1",
								   L"SEO.SEOMimeDictionary");

	BEGIN_COM_MAP(CSEOMimeDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
//		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMimeMessageTree, m_pMessageTree)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMimeOleMalloc, m_pMalloc)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
        virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPWSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCWSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	private: // Implementation member functions
		void ReadHeader();

	private: // Private data
		IMimeMessageTree *m_pMessageTree; // Our copy of aggregated object
		IMimeOleMalloc *m_pMalloc;
		LONG m_dwValueCnt;
		struct ValueEntry {
			BSTR strName;
			//DWORD dwType;
			BSTR strData;
			//BOOL bDirty;
		} *m_paValue;
		CComObjectThreadModel::CriticalSection m_csCritSec;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\metabag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	metabag.cpp

Abstract:

	This module contains the implementation for an ISEODicitonary
	Object on the Metabase.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   03/11/97        created

--*/

// METABAG.cpp : Implementation of CSEOMetaDictionary

#include "stdafx.h"
#include "seodefs.h"
#include "IADMW.H"
#include "METABAG.h"
#include <stdarg.h>
#include <stdio.h>


#ifdef DEBUG
	#define MY_OUTPUT_DEBUG_STRING(x)	OutputDebugString("SEO.DLL: " x);
	#define MY_OUTPUT_DEBUG_STRING_HR(hr,x)	if (FAILED(hr)) { MY_OUTPUT_DEBUG_STRING(x) }
#else
	#define MY_OUTPUT_DEBUG_STRING(x)
	#define MY_OUTPUT_DEBUG_STRING_HR(hr,x)
#endif

#if 1
	#define MY_ASSERTE(x)				_ASSERTE(x)
	#define MY_ASSERTE_CHK_HR(hr,chk)	MY_ASSERTE(chk(hr))
#else
	#ifdef DEBUG
		inline BOOL __assert_output(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFmt, ...) {
			CHAR szOutput[512];
			LPSTR pszOutput;
			DWORD dwLen;

			_snprintf(szOutput,510,"ASSERT: %s(%u): \r\n",pszFile,dwLine);
			dwLen = lstrlen(szOutput);
			if (dwLen < 508) {
				va_list valArgs;

				va_start(valArgs,pszFmt);
				pszOutput = szOutput + dwLen - 2;
				_vsnprintf(pszOutput,508-dwLen,pszFmt,valArgs);
				lstrcat(szOutput,"\r\n");
				va_end(valArgs);
			}
			OutputDebugString(szOutput);
			DebugBreak();
			return (FALSE);
		}
		#define MY_ASSERTE(x)				((x)?1:__assert_output(__FILE__,__LINE__,#x))
		#define MY_ASSERTE_CHK_HR(hr,chk)	(chk(hr)?1:__assert_output(__FILE__,__LINE__,"hr=0x%x",(hr)))
	#else
		#define MY_ASSERTE(X)
		#define MY_ASSERTE_CHK_HR(hr,chk)
	#endif
#endif
#define MY_ASSERTE_HR(hr)		MY_ASSERTE_CHK_HR(hr,SUCCEEDED)
#define MY_CHK_RPC_HR(hr)		(SUCCEEDED(hr) || \
								 (HRESULT_FACILITY(hr)==FACILITY_RPC) || \
								 ((hr)==HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)) || \
								 ((hr)==HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE)))
#define MY_ASSERTE_RPC_HR(hr)	MY_ASSERTE_CHK_HR(hr,MY_CHK_RPC_HR)


/////////////////////////////////////////////////////////////////////////////
// CChangeNotify
class ATL_NO_VTABLE CChangeNotify :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CChangeNotify, &CLSID_CChangeNotify>,
	public IMSAdminBaseSinkW
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT Advise(CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> *pMetabaseHandle);
		HRESULT Unadvise();
		HRESULT AddNotify(CSEOMetaDictionary *pNotify);
		HRESULT RemoveNotify(CSEOMetaDictionary *pNotify);

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CChangeNotify);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"ChangeNotify Class",
//								   L"Metabag.ChangeNotify.1",
//								   L"Metabag.ChangeNotify");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CChangeNotify)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_W, IMSAdminBaseSinkW)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IMSAdminBaseSinkW
	public:
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);
		HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

	private:
		CComPtr<IEventLock> m_pLock;
		DWORD m_dwNotifyCount;
		CSEOMetaDictionary **m_apNotify;
		DWORD m_dwCookie;
        CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> *m_pMetabaseHandle;
		BOOL m_bConnected;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


/////////////////////////////////////////////////////////////////////////////
// CChangeNotify


HRESULT CChangeNotify::FinalConstruct() {
	TraceFunctEnter("CChangeNotify::FinalConstruct");
	HRESULT hrRes = S_OK;

	m_dwNotifyCount = 0;
	m_apNotify = NULL;
    m_pMetabaseHandle = NULL;
	m_bConnected = FALSE;
	hrRes = CoCreateInstance(CLSID_CEventLock,NULL,CLSCTX_ALL,IID_IEventLock,(LPVOID *) &m_pLock);
	MY_OUTPUT_DEBUG_STRING_HR(hrRes,"CChangeNotify::FinalConstruct - CoCreateInstance failed.\n")
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
		MY_OUTPUT_DEBUG_STRING_HR(hrRes,"CChangeNotify::FinalConstruct - CoCreateFreeThreadedMarshaler failed.\n")
		_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	}
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CChangeNotify::FinalRelease() {
	TraceFunctEnter("CChangeNotify::FinalRelease");

	_ASSERTE(!m_apNotify);
	_ASSERTE(!m_pMetabaseHandle);
	_ASSERTE(!m_bConnected);
	m_pLock.Release();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CChangeNotify::Advise(CGlobalInterface<IMSAdminBase,&IID_IMSAdminBase_W> *pMetabaseHandle) {
	HRESULT hrRes;
    CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	CComQIPtr<IMSAdminBaseSinkW,&IID_IMSAdminBaseSink_W> pThis = this;

	_ASSERTE(pThis);
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	_ASSERTE(!m_apNotify);
	_ASSERTE(!m_pMetabaseHandle);
	if (!pMetabaseHandle) {
		m_pLock->UnlockWrite();
		return (E_POINTER);
	}
	m_pMetabaseHandle = pMetabaseHandle;
    hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
    if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to implement IConnectionPointContainer
		return (S_OK);
    }
	hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
	_ASSERTE(!SUCCEEDED(hrRes)||pCP);
	if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to source IMSAdminBaseSink_W
		return (S_OK);
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CChangeNotify::Unadvise() {
	HRESULT hrRes;
    CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;

    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (m_apNotify) {
		CoTaskMemFree(m_apNotify);
		m_apNotify = NULL;
	}
    hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
    if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to implement IConnectionPointContainer
		return (hrRes);
    }
	hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
	_ASSERTE(!SUCCEEDED(hrRes)||pCP);
	if (!SUCCEEDED(hrRes)) {
        m_pMetabaseHandle = NULL;
		m_pLock->UnlockWrite();
		MY_ASSERTE_RPC_HR(hrRes);	// expected metabase to source IMSAdminBaseSink_W
		return (hrRes);
	}
	if (m_dwNotifyCount) {
		_ASSERTE(FALSE);	// Object leak detected!
		hrRes = pCP->Unadvise(m_dwCookie);
		MY_ASSERTE_RPC_HR(hrRes);
	}
    m_pMetabaseHandle = NULL;
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CChangeNotify::AddNotify(CSEOMetaDictionary *pNotify) {
	HRESULT hrRes;
	CSEOMetaDictionary **apNotify;

	if (!pNotify) {
		return (E_POINTER);
	}
    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	apNotify = (CSEOMetaDictionary **) CoTaskMemRealloc(m_apNotify,sizeof(CSEOMetaDictionary *)*(m_dwNotifyCount+1));
	if (!apNotify) {
		m_pLock->UnlockWrite();
		return (E_OUTOFMEMORY);
	}
	m_apNotify = apNotify;
	m_apNotify[m_dwNotifyCount] = pNotify;
	m_dwNotifyCount++;
	if (!m_bConnected) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		CComQIPtr<IMSAdminBaseSinkW,&IID_IMSAdminBaseSink_W> pThis = this;

		_ASSERTE(m_dwNotifyCount==1);
		m_bConnected = TRUE;
		m_pLock->UnlockWrite();
		_ASSERTE(pThis);
        hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        if (SUCCEEDED(hrRes)) {
    		hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
			MY_ASSERTE_RPC_HR(hrRes);
    		if (SUCCEEDED(hrRes)) {
    			hrRes = pCP->Advise(pThis,&m_dwCookie);
    			_ASSERTE(SUCCEEDED(hrRes));
    		}
        }
	} else {
		m_pLock->UnlockWrite();
	}
	return (S_OK);
}


HRESULT CChangeNotify::RemoveNotify(CSEOMetaDictionary *pNotify) {
	HRESULT hrRes;
	DWORD dwIdx;

	if (!pNotify) {
		return (E_POINTER);
	}
    if (!m_pMetabaseHandle) {
        return (S_OK);
    }
	hrRes = m_pLock->LockWrite(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (!m_apNotify) {
		m_pLock->UnlockWrite();
		return (S_FALSE);
	}
	for (dwIdx=0;dwIdx<m_dwNotifyCount;dwIdx++) {
		if (m_apNotify[dwIdx] == pNotify) {
			break;
		}
	}
	if (dwIdx == m_dwNotifyCount) {
		m_pLock->UnlockWrite();
		return (S_FALSE);
	}
	m_apNotify[dwIdx] = m_apNotify[m_dwNotifyCount-1];
	m_apNotify[m_dwNotifyCount-1] = NULL;
	m_dwNotifyCount--;
	if (!m_dwNotifyCount) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		DWORD dwCookie = m_dwCookie;

		_ASSERTE(m_bConnected);
		m_bConnected = FALSE;
		m_pLock->UnlockWrite();
        hrRes = m_pMetabaseHandle->GetInterfaceQI(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
		MY_ASSERTE_RPC_HR(hrRes);
        if (SUCCEEDED(hrRes)) {
    		hrRes = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
			MY_ASSERTE_RPC_HR(hrRes);
    		if (SUCCEEDED(hrRes)) {
    			hrRes = pCP->Unadvise(dwCookie);
				MY_ASSERTE_RPC_HR(hrRes);
    		}
        }
	} else {
		m_pLock->UnlockWrite();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]) {
	HRESULT hrRes;
	CComPtr<IEventLock> pLock = m_pLock;
	CSEOMetaDictionary **apNotify;
	DWORD dwIdx;
	LPCWSTR *apszChange;

	_ASSERTE(dwMDNumElements&&pcoChangeList);
	if (!pcoChangeList) {
		return (E_POINTER);
	}
	if (!dwMDNumElements) {
		return (S_OK);
	}
	hrRes = pLock->LockRead(5000);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (!m_apNotify || !m_dwNotifyCount) {
		pLock->UnlockRead();
		return (S_OK);
	}
	apNotify = (CSEOMetaDictionary **) _alloca(sizeof(CSEOMetaDictionary *)*(m_dwNotifyCount+1));
	if (!apNotify) {
		_ASSERTE(FALSE);
		pLock->UnlockRead();
		return (E_OUTOFMEMORY);
	}
	apszChange = (LPCWSTR *) _alloca(sizeof(LPWSTR)*(dwMDNumElements+1));
	if (!apszChange) {
		_ASSERTE(FALSE);
		pLock->UnlockRead();
		return (E_OUTOFMEMORY);
	}
	memcpy(apNotify,m_apNotify,sizeof(CSEOMetaDictionary *)*m_dwNotifyCount);
	apNotify[m_dwNotifyCount] = NULL;
	for (dwIdx=0;apNotify[dwIdx];dwIdx++) {
		apNotify[dwIdx]->GetControllingUnknown()->AddRef();
	}
	pLock->UnlockRead();
	pLock.Release();
	for (dwIdx=0;dwIdx<dwMDNumElements;dwIdx++) {
		apszChange[dwIdx] = pcoChangeList[dwIdx].pszMDPath;
	}
	apszChange[dwMDNumElements] = NULL;
	for (dwIdx=0;apNotify[dwIdx];dwIdx++) {
		hrRes = apNotify[dwIdx]->OnChange(apszChange);
		_ASSERTE(SUCCEEDED(hrRes));
		apNotify[dwIdx]->GetControllingUnknown()->Release();
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::ShutdownNotify(void) {

	// tbd
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////


LPCWSTR szSeparator = L"/";
LPCOLESTR szSaveKey = OLESTR("MetabasePath");

static CComObject<CChangeNotify> *g_pChangeNotify;

HRESULT ResolveVariant(IEventPropertyBag *pBag, VARIANT *pvarPropDesired, CComVariant &varResult);


// Static member variables
CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> CSEOMetabase::m_MetabaseHandle;
CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> CSEOMetabase::m_MetabaseChangeHandle;
int CSEOMetabase::m_iCount = 0;

HRESULT CSEOMetabase::InitializeMetabase() {
	EnterCriticalSection(&_Module.m_csWindowCreate);
	if (m_iCount++) {
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return S_OK;    // Already initialized
	}
    m_MetabaseHandle.Init();
	m_MetabaseChangeHandle.Init();
    HRESULT hRes = m_MetabaseHandle.Load(CLSID_MSAdminBase_W);
    if (FAILED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - m_MetabaseHandle.Load failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return hRes;
    }
	hRes = m_MetabaseChangeHandle.Load(CLSID_MSAdminBase_W);
    if (FAILED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - m_MetabaseChangeHandle.Load failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return hRes;
    }
	hRes = CComObject<CChangeNotify>::CreateInstance(&g_pChangeNotify);
	if (!SUCCEEDED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - CComObject<CChangeNotify>::CreateInstance failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return (hRes);
	}
	g_pChangeNotify->GetControllingUnknown()->AddRef();
	hRes = g_pChangeNotify->Advise(&m_MetabaseChangeHandle);
	if (!SUCCEEDED(hRes)) {
		MY_OUTPUT_DEBUG_STRING("CSEOMetabase::InitializeMetabase - g_pChangeNotify->Advise failed.\n")
		TerminateMetabase();
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return (hRes);
	}

	LeaveCriticalSection(&_Module.m_csWindowCreate);
	return hRes;
}

HRESULT CSEOMetabase::TerminateMetabase()
{
	EnterCriticalSection(&_Module.m_csWindowCreate);
	--m_iCount;
	if(m_iCount > 0) {
		LeaveCriticalSection(&_Module.m_csWindowCreate);
		return S_OK; // More copies still using it
	}

	if (g_pChangeNotify) {
		g_pChangeNotify->Unadvise();
		g_pChangeNotify->GetControllingUnknown()->Release();
		g_pChangeNotify = NULL;
	}
	if(m_MetabaseHandle) {
        m_MetabaseHandle.Term();
	}
	if(m_MetabaseChangeHandle) {
        m_MetabaseChangeHandle.Term();
	}

	LeaveCriticalSection(&_Module.m_csWindowCreate);
	return S_OK;
}

HRESULT CSEOMetabase::SetStatus(LockStatus ls, long lTimeout) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(m_pmbDefer) {
		return m_pmbDefer->SetStatus(ls, lTimeout);
	}

	if(!m_MetabaseHandle) return E_FAIL;
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	// tbd: Do we need to count open requests, and wait for same number of close requests?
	if(m_eStatus == Error) return E_FAIL;
	if(m_eStatus == ls) return S_OK; // Already in desired state

	hRes = E_FAIL;
	if(m_eStatus == Closed) {
		if((ls == Read) || (ls == Write)) {
			DWORD dwAccess = ((ls == Write) ? METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ :
							  METADATA_PERMISSION_READ);
			hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					      m_pszPath, dwAccess, lTimeout, &m_mhHandle);

			// If it failed, and we're trying to write, try to create it
			if(FAILED(hRes) && (ls == Write)) {
				METADATA_HANDLE mhTemp;
				hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
									  NULL, dwAccess, lTimeout, &mhTemp);
				if(SUCCEEDED(hRes)) {
					piMetabase->AddKey(mhTemp, m_pszPath); // Create Path
					piMetabase->CloseKey(mhTemp); // Close the temp handle
					// And try one more time
					hRes = piMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
										  m_pszPath, dwAccess, lTimeout, &m_mhHandle);
				}
			}

			if(SUCCEEDED(hRes)) {
				m_eStatus = ls;
			}
		} // Else unknown request
	} else if(ls == Closed) {
//		if(m_eStatus == Write) piMetabase->SaveData(); // I'm not sure if CloseKey() does this
		hRes = piMetabase->CloseKey(m_mhHandle);
		m_eStatus = Closed;
		m_mhHandle = METADATA_MASTER_ROOT_HANDLE;
	} else if ((ls == Read) && (m_eStatus == Write)) {
		hRes = S_FALSE;
	} // Else trying to change state while already opened

	return hRes;
}

// Opens the specified path and returns a new string to use as the path
HRESULT CSEOMetabase::OpenPath(CSEOMetabaseLock &mbLocker, LPCWSTR pszPath,
			    LPWSTR pszPathBuf, DWORD &dwId, LockStatus lsOpen) {
	HRESULT hRes = S_OK;

	if (InitError == m_hrInitRes) {
		return (m_hrInitRes);
	}
	if(m_pmbDefer) { // If we're defering
		hRes = mbLocker.SetStatus(lsOpen); // Open the master
		LPWSTR pszPathTmp = (LPWSTR) GetRelPath((LPWSTR) alloca(sizeof(*pszPath)*(GetPathLength() + 1)));
		ConcatinatePaths(pszPathBuf,pszPathTmp,pszPath);
	} else {
		hRes = mbLocker.SetStatus(lsOpen);
		if(pszPath) { // If there's something to copy
			wcscpy(pszPathBuf,pszPath);
		} else {
			pszPathBuf[0] = 0; // Treat null string like an empty string
		}
	}

	// Future: parse path for //# to indicate a specific entry for dwId
	dwId = 0;

	return hRes;
}

HRESULT CSEOMetabase::EnumKeys(LPCWSTR pszPath, DWORD dwNum, LPWSTR pszName) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(Error == Status()) {
		return MD_ERROR_NOT_INITIALIZED; // or E_FAIL;
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not used in Enum
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId);
	if(FAILED(hRes)) return hRes;

	return piMetabase->EnumKeys(GetHandle(), pszPathBuf, pszName, dwNum);
}

HRESULT CSEOMetabase::GetData(LPCWSTR pszPath, DWORD &dwType, DWORD &dwLen, PBYTE pbData) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
	if(Error == Status()) {
		return MD_ERROR_NOT_INITIALIZED; // or E_FAIL;
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	METADATA_RECORD mdrData;
	DWORD dwRequiredDataLen = 0;
	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, mdrData.dwMDIdentifier);
	if(FAILED(hRes)) return hRes;

	// Initialize data
	mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrData.dwMDUserType = 0;
	mdrData.dwMDDataType = 0;
	mdrData.dwMDDataLen = dwLen;
	mdrData.pbMDData = (PBYTE) alloca(dwLen);
	mdrData.dwMDDataTag = 0;

	hRes = piMetabase->GetData(GetHandle(), pszPathBuf,
					             &mdrData, &dwRequiredDataLen);

	// Set values for return
	dwType = mdrData.dwMDDataType;

	if(dwType == EXPANDSZ_METADATA) { // It needs environment string substitutions
		// Save the new size in mdrData.dwMDDataLen
		mdrData.dwMDDataLen = ExpandEnvironmentStringsW((LPCWSTR) mdrData.pbMDData, (LPWSTR) pbData, dwLen);
		dwType = STRING_METADATA; // Don't need to expand anymore
		if(!mdrData.dwMDDataLen && *pbData) hRes = E_FAIL;
	} else {
		memcpy(pbData, mdrData.pbMDData, min(dwLen, mdrData.dwMDDataLen));
	}

//      if(mdrData.dwMDDataTag) m_piMetabase->ReleaseReferenceData(mdrData.dwMDDataTag); - No longer needed
	dwLen = ((HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hRes) ? dwRequiredDataLen : mdrData.dwMDDataLen);

	switch (hRes) { // Translate return code
		case ERROR_PATH_NOT_FOUND:
		case MD_ERROR_DATA_NOT_FOUND:
			hRes = SEO_E_NOTPRESENT;
			break;

		case HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
			hRes = SEO_S_MOREDATA;
			break;

		case ERROR_SUCCESS:
			hRes = S_OK;
			break;
	}

	return hRes;
}

// Add path if it doesn't exist already
HRESULT CSEOMetabase::AddKey(LPCWSTR pszPath) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not needed for AddKey()
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	hRes = piMetabase->AddKey(GetHandle(), pszPathBuf); // Make sure path exists
	if (hRes == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) {
		hRes = S_OK;
	}
	return (hRes);
}

HRESULT CSEOMetabase::DeleteKey(LPCWSTR pszPath) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	CSEOMetabaseLock mbLocker(this);
	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	DWORD dwDummyId = 0; // Not needed for DeleyeKey()
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, dwDummyId, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	hRes = piMetabase->DeleteKey(GetHandle(), pszPathBuf); // Make sure path does not exist
	if (hRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
		hRes = S_OK;
	}
	return (hRes);
}


HRESULT CSEOMetabase::SetData(LPCWSTR pszPath, DWORD dwType, DWORD dwLen, PBYTE pbData) {
	if (InitError == m_eStatus) {
		return (m_hrInitRes);
	}
    CComPtr<IMSAdminBaseW> piMetabase;
    HRESULT hRes = m_MetabaseHandle.GetInterface(&piMetabase);
    if (!SUCCEEDED(hRes)) {
        return (hRes);
    }

	METADATA_RECORD mdrData;
	DWORD dwRequiredDataLen = 0;
	CSEOMetabaseLock mbLocker(this);

	LPWSTR pszPathBuf = (LPWSTR) alloca(sizeof(*pszPathBuf)*(4 + GetPathLength() + SafeStrlen(pszPath)));
	hRes = OpenPath(mbLocker, pszPath, pszPathBuf, mdrData.dwMDIdentifier, Write);
	if(FAILED(hRes)) return hRes;
	if(Status() != Write) return E_FAIL; // Couldn't open for Writing

	// Initialize data
	mdrData.dwMDAttributes = 0;
	mdrData.dwMDUserType = 0;
	mdrData.dwMDDataType = dwType;
	mdrData.dwMDDataLen = dwLen;
	mdrData.pbMDData = pbData;
	mdrData.dwMDDataTag = 0;

	if(pbData) { // If it's a non-NULL pointer
		PBYTE pbTemp = (PBYTE) alloca(dwLen + 1); // Make sure string is null-terminated

		if((dwType == STRING_METADATA) && // If it's a string
		   ((dwLen < 1) || pbData[dwLen - 1])) { // And it's not null-terminated
			memcpy(pbTemp, pbData, dwLen);
			pbTemp[dwLen] = 0; // Terminate new string
			++dwLen; // Include null terminator in length
			mdrData.dwMDDataLen = dwLen; // New Length
			mdrData.pbMDData = pbTemp; // Point to new string
		}

		piMetabase->AddKey(GetHandle(), pszPathBuf); // Make sure path exists
		return piMetabase->SetData(GetHandle(), pszPathBuf, &mdrData);
	} else { // NULL pointer, so delete it
		// m_piMetabase->DeleteData(GetHandle(), pbPathBuf, 0, ALL_METADATA);
		return piMetabase->DeleteKey(GetHandle(), pszPathBuf);
	}
}

void CSEOMetabase::ConcatinatePaths(LPWSTR pszResult, LPCWSTR pszP1, LPCWSTR pszP2) {
	pszResult[0] = 0;
	if(pszP1 && *pszP1) {
		//if(szSeparator[0] != pszP1[0]) lstrcat(pszResult, szSeparator);
		wcscat(pszResult, pszP1);
	}

	if(pszP2) { // && *pszP2) {
		if(szSeparator[0] != pszResult[wcslen(pszResult) - 1]) wcscat(pszResult, szSeparator);
		if(!*pszP2) {
			wcscat(pszResult, szSeparator);
		} else {
			//lstrcat(pszResult, pszP2 + ((szSeparator[0] != pszP2[0]) ? 0 : lstrlen(szSeparator)));
			wcscat(pszResult, pszP2);
		}
	}

	//int iLast = lstrlen(pszResult) - 1;
	//if((iLast >= 0) && (szSeparator[0] == pszResult[iLast])) pszResult[iLast] = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionaryEnum

class CSEOMetaDictionaryEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEOMetaDictionary *, DWORD dwIndex = 0);

	BEGIN_COM_MAP(CSEOMetaDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		CSEOMetaDictionary *m_dictionary;
		DWORD m_dwIndex;
};

HRESULT CSEOMetaDictionaryEnum::FinalConstruct() {
	m_dictionary = NULL;
	m_dwIndex = 0;
	return S_OK;
}

void CSEOMetaDictionaryEnum::FinalRelease() {
	if(m_dictionary) m_dictionary->GetControllingUnknown()->Release();
	m_dictionary = NULL;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Init(CSEOMetaDictionary *pDict, DWORD dwIndex) {
	if(m_dictionary) m_dictionary->GetControllingUnknown()->Release();
	m_dictionary = pDict;
	m_dwIndex = dwIndex;

	if(m_dictionary) {
		m_dictionary->GetControllingUnknown()->AddRef();
	}

	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResultParam) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	if(!varDest) return E_POINTER;
	WCHAR szName[METADATA_MAX_NAME_LEN];
	DWORD dwDummy = 0;
	LPDWORD pdwResult = (pdwResultParam ? pdwResultParam : &dwDummy);
	*pdwResult = 0; // Nothing done so far
	HRESULT hrRes = S_OK; // So far, so good

	while((S_OK == hrRes) && (*pdwResult < dwCount)) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		hrRes = m_dictionary->m_mbHelper.EnumKeys(NULL, m_dwIndex, szName);

		if(SUCCEEDED(hrRes)) {
			CComVariant varResult(szName);
			VariantInit(&varDest[*pdwResult]);
			hrRes = varResult.Detach(&varDest[*pdwResult]);
			++(*pdwResult); // Increment successful count for caller
			++m_dwIndex; // Point to the next one
		}
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_FALSE;
	if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hrRes) hrRes = S_FALSE;
	return (FAILED(hrRes) ? hrRes : ((*pdwResult < dwCount) ? S_FALSE : hrRes));
}

STDMETHODIMP CSEOMetaDictionaryEnum::Skip(DWORD dwCount) {
	m_dwIndex += dwCount;
	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Reset(void) {
	m_dwIndex = 0;
	return S_OK;
}

STDMETHODIMP CSEOMetaDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComObject<CSEOMetaDictionaryEnum> *p;
	HRESULT hrRes = CComObject<CSEOMetaDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	hrRes = p->Init(m_dictionary, m_dwIndex);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
    if (FAILED(hrRes)) delete p;
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionary


// The following macro may be inserted in a method to support
// reading/writing from just that method if handle not already opened.
// The object will take care of close the handle if needed, etc.
#define METABASE_READ  METABASE_HELPER(m_mbHelper, Read)
#define METABASE_WRITE METABASE_HELPER(m_mbHelper, Write)


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarName || !pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;
	HRESULT hrRes = E_INVALIDARG;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		hrRes = GetVariantA(W2A(vNew.bstrVal), pvarResult);

		// Convert SEO_E_NOTPRESENT to VT_EMPTY
		if(SEO_E_NOTPRESENT == hrRes) {
			VariantClear(pvarResult);
			hrRes = S_OK;
		}
	}

	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::put_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarName || !pvarValue) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	CComVariant vNew;

	if(SUCCEEDED(vNew.ChangeType(VT_BSTR, pvarName))) {
		return SetVariantA(W2A(vNew.bstrVal), pvarValue);
	} else {
		return E_INVALIDARG;
	}
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get__NewEnum(
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComObject<CSEOMetaDictionaryEnum> *p;
	HRESULT hrRes = CComObject<CSEOMetaDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
    if (FAILED(hrRes)) delete p;
	return hrRes;
}


HRESULT CSEOMetaDictionary::GetVariantW(LPCWSTR pszName, VARIANT __RPC_FAR *pvarResult, BOOL bCreate) {

	if(!pvarResult) return E_POINTER;
	if(!pszName) return E_POINTER;
	CComVariant varResult;
	HRESULT hRes = E_FAIL;
	VariantInit(pvarResult);
	if(*pszName && (szSeparator[0] != pszName[wcslen(pszName) - 1])) {
		DWORD dwType = 0;
		DWORD dwCount = METADATA_MAX_NAME_LEN; // Initial buffer size
		PBYTE pbBuf = NULL;
		hRes = SEO_S_MOREDATA;
		while(SEO_S_MOREDATA == hRes) {
			pbBuf = (PBYTE) alloca(dwCount);
			hRes = m_mbHelper.GetData(pszName, dwType, dwCount, pbBuf);
		}
		if(SUCCEEDED(hRes)) {
			if(DWORD_METADATA == dwType) varResult = *((long *) pbBuf);
			else varResult = (LPCWSTR) pbBuf;
		}
	}

	if(varResult.vt == VT_EMPTY) { // nothing found so far, so read as subkey
		if (!bCreate) {
			WCHAR szName[METADATA_MAX_NAME_LEN];

			hRes = m_mbHelper.EnumKeys(pszName,0,szName);
			if (hRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				return (SEO_E_NOTPRESENT);
			}
		}
		CComPtr<IUnknown> pRef;
		hRes = GetInterfaceW(pszName, IID_ISEODictionary, &pRef);
		varResult = pRef;
	}

	if(SUCCEEDED(hRes)) hRes = varResult.Detach(pvarResult);
	return hRes;
}


HRESULT CSEOMetaDictionary::GetVariantA(LPCSTR pszName, VARIANT __RPC_FAR *pvarResult, BOOL bCreate) {

	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantW(A2W(pszName),pvarResult,bCreate);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	return (GetVariantW(pszName,pvarResult,TRUE));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	if(!pvarResult) return E_INVALIDARG;
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantW(A2W(pszName),pvarResult,TRUE);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	HRESULT hRes = S_OK;

	if(pvarValue->vt == VT_I4) {
		hRes = m_mbHelper.SetDWord(pszName, pvarValue->lVal);
	} else if((pvarValue->vt == VT_UNKNOWN) || (pvarValue->vt == VT_DISPATCH)) {
		CComQIPtr<ISEODictionary, &IID_ISEODictionary> piDict = pvarValue->punkVal;
		if(piDict) hRes = CopyDictionary(pszName, piDict);
	} else if(pvarValue->vt == VT_EMPTY) { // Delete it
		hRes = m_mbHelper.SetData(pszName, 0, 0, NULL);
	} else if(pvarValue->vt == VT_BSTR) { // It's a string
		hRes = m_mbHelper.SetString(pszName, pvarValue->bstrVal);
	} else { // Try to convert it to a string
		CComVariant pvarTemp = *pvarValue;
		hRes = pvarTemp.ChangeType(VT_BSTR);
		if(SUCCEEDED(hRes)) {
			hRes = m_mbHelper.SetString(pszName, pvarTemp.bstrVal);
		} // Else, return the ChangeType error
	}
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	if(!pvarValue) return E_POINTER;
	USES_CONVERSION; // Needed for W2A(), etc.
	return SetVariantW(A2W(pszName), pvarValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	if(!pszResult) return E_POINTER;

	DWORD dwType = 0;
	DWORD dwCountTmp = sizeof(*pszResult) * (*pchCount);
	HRESULT hRes = m_mbHelper.GetData(pszName, dwType, dwCountTmp, (PBYTE) pszResult);
	*pchCount = dwCountTmp / sizeof(*pszResult);
	if(SUCCEEDED(hRes) && (DWORD_METADATA == dwType)) hRes = SEO_E_NOTPRESENT;
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetStringA(
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	if(!pszResult) return E_POINTER;
	USES_CONVERSION;
	DWORD dwType = 0;
	DWORD dwByteCount = *pchCount * sizeof(*pszResult);
	PBYTE pbBuf = (PBYTE) alloca(dwByteCount);
	HRESULT hRes = m_mbHelper.GetData(A2W(pszName), dwType, dwByteCount, pbBuf);
	if(SUCCEEDED(hRes) && (DWORD_METADATA == dwType)) hRes = SEO_E_NOTPRESENT;

	// Now, convert back to ANSI chars
	if(SUCCEEDED(hRes) && (BINARY_METADATA == dwType)) {
		memcpy(pszResult, pbBuf, dwByteCount);
		*pchCount = dwByteCount / sizeof(*pszResult);
	} else {
		ATLW2AHELPER(pszResult, (LPCWSTR) pbBuf, sizeof(*pszResult) * min(*pchCount, dwByteCount));
		*pchCount = dwByteCount; // Same number of characters
	}

	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	return m_mbHelper.SetData(pszName, STRING_METADATA,
				  chCount*sizeof(*pszValue), (PBYTE) pszValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetStringA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	if(!pszValue) return E_POINTER;
	USES_CONVERSION;
	return m_mbHelper.SetData(A2W(pszName), STRING_METADATA,
				  chCount, (PBYTE) A2W(pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	if(!pdwResult) return E_POINTER;

	DWORD dwType = 0;
	DWORD dwCount = sizeof(DWORD);
	HRESULT hRes = m_mbHelper.GetData(pszName, dwType, dwCount, (PBYTE) pdwResult);
	if(SUCCEEDED(hRes) && (DWORD_METADATA != dwType)) hRes = SEO_E_NOTPRESENT;
	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordW(A2W(pszName), pdwResult);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	return m_mbHelper.SetDWord(pszName, dwValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return m_mbHelper.SetDWord(A2W(pszName), dwValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	if(!ppunkResult) return E_POINTER;
	CComObject<CSEOMetaDictionary> *pKey;
	HRESULT hrRes = CComObject<CSEOMetaDictionary>::CreateInstance(&pKey);
	if (FAILED(hrRes)) return (hrRes);
	CComPtr<ISEODictionary> pAutomaticCleanup = pKey;
	hrRes = pKey->Init(m_mbHelper, pszName);

	if (SUCCEEDED(hrRes)) {
		hrRes = pKey->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
	}

	return (hrRes);
//      tbd: return SEO_E_NOTPRESENT; // Didn't find it
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceW(A2W(pszName), iidDesired, ppunkResult);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	CComQIPtr<ISEODictionary, &IID_ISEODictionary> piDict = punkValue;
	return (piDict ? CopyDictionary(pszName, piDict) : E_INVALIDARG);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::SetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return SetInterfaceW(A2W(pszName), punkValue);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID) {
	memcpy(pClassID, &CLSID_CSEOMetaDictionary, sizeof(CLSID));
	_ASSERT(IsEqualCLSID(*pClassID, CLSID_CSEOMetaDictionary));
	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::InitNew(void) {
	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Load(
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ IErrorLog __RPC_FAR * /*pErrorLog*/) {
	if(!pPropBag) return E_POINTER;
	CComVariant varPath;

	varPath.vt = VT_BSTR; // Request type from Read()
	varPath.bstrVal = NULL;
	HRESULT hRes = pPropBag->Read(szSaveKey, &varPath, NULL);
	if(SUCCEEDED(hRes)) m_mbHelper.SetPath(varPath.bstrVal);

	return hRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Save(
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ BOOL /*fClearDirty*/,
			/* [in] */ BOOL /*fSaveAllProperties*/) {
	if(!pPropBag) return E_POINTER;
	LPWSTR pszBuf = (LPWSTR) alloca(sizeof(*pszBuf)*(m_mbHelper.GetPathLength() + 1)); // Temporary buffer to hold path
	CComVariant varPath = m_mbHelper.GetPath(pszBuf);
	return pPropBag->Write(szSaveKey, &varPath);
}


HRESULT CSEOMetaDictionary::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOMetaDictionary::FinalRelease() {
	m_pUnkMarshaler.Release();
}


HRESULT CSEOMetaDictionary::OnChange(LPCWSTR *apszPath) {
	HRESULT hrRes;
	CComPtr<IConnectionPoint> pCP;
	CComPtr<IEnumConnections> pEnum;
	CONNECTDATA cd;
	BOOL bDoNotify = FALSE;
	CSEOConnectionPointImpl<CSEOMetaDictionary,&IID_IEventNotifyBindingChange> *pCPImpl;
	LPWSTR pszThisPath = NULL;
	DWORD dwThisPathLen;

	if (!apszPath) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	if (!apszPath[0]) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	Lock();
	pCPImpl = (CSEOConnectionPointImpl<CSEOMetaDictionary,&IID_IEventNotifyBindingChange> *) this;
	if (!pCPImpl->GetCount()) {
		Unlock();
		return (S_OK);
	}
	Unlock();
	hrRes = FindConnectionPoint(IID_IEventNotifyBindingChange,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		return (S_OK);
	}
	while (1) {
		hrRes = pEnum->Next(1,&cd,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			return (S_OK);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		if (!bDoNotify) {
			if (!pszThisPath) {
				pszThisPath = (LPWSTR) _alloca(sizeof(*pszThisPath)*(m_mbHelper.GetPathLength()+1));
				if (!pszThisPath) {
					_ASSERTE(FALSE);
					return (S_OK);
				}
				m_mbHelper.GetPath(pszThisPath);
				dwThisPathLen = wcslen(pszThisPath);
				if (dwThisPathLen && (pszThisPath[dwThisPathLen-1] == szSeparator[0])) {
					dwThisPathLen--;
				}
				if (dwThisPathLen && (pszThisPath[0] == szSeparator[0])) {
					pszThisPath++;
					dwThisPathLen--;
				}
			}
			for (DWORD dwIdx=0;apszPath[dwIdx];dwIdx++) {
				DWORD dwPathLen;
				LPCWSTR pszPath;

				pszPath = apszPath[dwIdx];
				dwPathLen = wcslen(pszPath);
				if (dwPathLen && (pszPath[dwPathLen-1] == szSeparator[0])) {
					dwPathLen--;
				}
				if (dwPathLen && (pszPath[0] == szSeparator[0])) {
					pszPath++;
					dwPathLen--;
				}
				if ((dwThisPathLen > dwPathLen) ||
					(memicmp(pszThisPath,pszPath,dwThisPathLen*sizeof(pszPath[0])) != 0)) {
					continue;
				}
				if (!dwThisPathLen ||
					(dwThisPathLen == dwPathLen) ||
					(pszPath[dwThisPathLen] == szSeparator[0])) {
					bDoNotify = TRUE;
					break;
				}
			}
		}
		if (bDoNotify) {
			hrRes = ((IEventNotifyBindingChange *) cd.pUnk)->OnChange();
			_ASSERTE(SUCCEEDED(hrRes));
		}
		cd.pUnk->Release();
		if (!bDoNotify) {
			break;
		}
	}
	return (S_OK);
}


void CSEOMetaDictionary::AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
	HRESULT hrRes;

	if (dwCount == 1) {
		if (!g_pChangeNotify) {
			return;
		}
		hrRes = g_pChangeNotify->AddNotify(this);
		_ASSERTE(SUCCEEDED(hrRes));
	}
}


void CSEOMetaDictionary::UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
	HRESULT hrRes;

	if (dwCount == 0) {
		if (!g_pChangeNotify) {
			return;
		}
		hrRes = g_pChangeNotify->RemoveNotify(this);
		_ASSERTE(SUCCEEDED(hrRes));
	}
}


HRESULT CSEOMetaDictionary::CopyDictionary(LPCWSTR pszName, ISEODictionary *pBag) {
	if(!pBag) return S_OK; // Nothing to copy

	// If not already open for writing, make it so
	CSEOMetabaseLock mbLocker(&m_mbHelper);
	if(::Write != m_mbHelper.Status()) {
		mbLocker.SetStatus(::Write);
	}
	CComObject<CSEOMetaDictionary> *pKey; // New Subkey
	HRESULT hrRes = CComObject<CSEOMetaDictionary>::CreateInstance(&pKey);
	if (FAILED(hrRes)) return (hrRes);
	CComPtr<ISEODictionary> pAutomaticCleanup = pKey;
	hrRes = m_mbHelper.DeleteKey(pszName); // Empty Metabase path
	if (FAILED(hrRes)) return (hrRes);
	hrRes = m_mbHelper.AddKey(pszName); // Create Metabase path
	if (FAILED(hrRes)) return (hrRes);
	hrRes = pKey->InitShare(m_mbHelper, pszName);
	if (FAILED(hrRes)) return (hrRes);

	CComPtr<IUnknown> piUnk;
	HRESULT hr = pBag->get__NewEnum(&piUnk);
	if(FAILED(hr) || !piUnk) return hr;
	CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> pieEnum = piUnk;
	piUnk.Release(); // Done with piUnk - use pieEnum now
	if(!pieEnum) return E_INVALIDARG;

	CComVariant varName; // Hold the current property name

	// Read in and copy all of the properties
	while(S_OK == pieEnum->Next(1, &varName, NULL)) {
		CComVariant varDest; // Hold the current result
		if(SUCCEEDED(pBag->get_Item(&varName, &varDest))) {
			varName.ChangeType(VT_BSTR); // Try to get a string
			pKey->SetVariantW(varName.bstrVal, &varDest);
		}
	}

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	HRESULT hrRes;
	VARTYPE vtType;

	if (!pszPropName || !pVar) {
		return (E_POINTER);
	}
	vtType = pVar->vt;
//	VariantClear(pVar);
	hrRes = GetVariantW(pszPropName,pVar);
	if (SUCCEEDED(hrRes) && (vtType != VT_EMPTY)) {
		hrRes = VariantChangeType(pVar,pVar,0,vtType);
	}
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pVar);
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Write(LPCOLESTR pszPropName, VARIANT *pVar) {

	return (SetVariantW(pszPropName,pVar));
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue) {
	if (!pvarPropValue) {
		return (E_POINTER);
	}
//	VariantClear(pvarPropValue); // Might have been initialized by caller (?)

	CComVariant varResult;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varResult);
	if (S_OK != hrRes) { // Don't just check for SUCCEEDED in case it's S_FALSE
		return (hrRes);
	}

	hrRes = GetVariantW(varResult.bstrVal,pvarPropValue,FALSE);
	if (hrRes == SEO_E_NOTPRESENT) {
		return (S_FALSE);
	}
#if 0
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	{
		CComVariant varTmp(*pvarPropValue);
		HRESULT hrRes;  // hide outer hrRes
		CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictTmp;
		CComPtr<IUnknown> punkEnum;
		CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;

		hrRes = varTmp.ChangeType(VT_UNKNOWN); // Make it an Unknown (if possible)
		if (SUCCEEDED(hrRes)) {
			pdictTmp = varTmp.punkVal;
			if (!pdictTmp) {
				VariantClear(pvarPropValue);
				return (E_NOINTERFACE);
			}
			hrRes = pdictTmp->get__NewEnum(&punkEnum); // Get it's Enum object
			if (!SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				return (hrRes);
			}
			pEnum = punkEnum;
			if (!pEnum) {
				VariantClear(pvarPropValue);
				return (E_NOINTERFACE);
			}
			varTmp.Clear();
			hrRes = pEnum->Next(1,&varTmp,NULL); // Ask Enum for first object
			if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
				VariantClear(pvarPropValue);
				return (S_FALSE);
			}
			if (!SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				return (hrRes);
			}
		}
	}
#endif
	if (SUCCEEDED(hrRes)) {
		VariantChangeType(pvarPropValue,pvarPropValue,0,VT_DISPATCH);
		_ASSERTE(pvarPropValue->vt!=VT_UNKNOWN);
	}
#if 0
	{
		HRESULT hrRes;
		CComVariant varTmp(*pvarPropValue);

		hrRes = varTmp.ChangeType(VT_UNKNOWN);
		if (SUCCEEDED(hrRes)) {
			hrRes = varTmp.ChangeType(VT_DISPATCH);
			_ASSERTE(SUCCEEDED(hrRes));
			if (SUCCEEDED(hrRes)) {
				VariantClear(pvarPropValue);
				pvarPropValue->vt = VT_DISPATCH;
				pvarPropValue->pdispVal = varTmp.pdispVal;
				pvarPropValue->pdispVal->AddRef();
			}
			hrRes = varTmp.ChangeType(VT_UNKNOWN);
			_ASSERTE(SUCCEEDED(hrRes));
		}

	}
#endif
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Name(long lPropIndex, BSTR *pbstrPropName) {
	if(!pbstrPropName) {
		return E_POINTER;
	}
	if (lPropIndex < 1) {
		return (S_FALSE);
	}
	*pbstrPropName = NULL;
	WCHAR szName[METADATA_MAX_NAME_LEN];

	HRESULT hrRes = m_mbHelper.EnumKeys(NULL, lPropIndex - 1, szName);

	if(SUCCEEDED(hrRes)) {
		*pbstrPropName = SysAllocString(szName);
		if(!*pbstrPropName) hrRes = E_OUTOFMEMORY;
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_FALSE;
	return hrRes;
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Add(BSTR pszPropName, VARIANT *pvarPropValue) {

	return (SetVariantW(pszPropName,pvarPropValue));
}

HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::Remove(VARIANT *pvarPropDesired) {
	CComVariant varCopy;
	HRESULT hrRes = ResolveVariant(this, pvarPropDesired, varCopy);
	if (S_OK != hrRes) { // Don't just check for SUCCEEDED in case it's S_FALSE
		return (hrRes);
	}

	hrRes = m_mbHelper.SetData(varCopy.bstrVal, 0, 0, NULL);
	if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
		return (S_FALSE);
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get_Count(long *plCount) {
	if(!plCount) return E_POINTER;
	*plCount = 0; // Nothing done so far

	WCHAR szName[METADATA_MAX_NAME_LEN];
	HRESULT hrRes = S_OK; // So far, so good

	while(S_OK == hrRes) {
		// Must have succeeded to get here, so OK to overwrite hrRes
		hrRes = m_mbHelper.EnumKeys(NULL, *plCount, szName);

		if(SUCCEEDED(hrRes)) {
			++(*plCount); // Increment successful count for caller
		}
	}

	if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrRes) hrRes = S_OK;
	return hrRes;
}


/*      Just use get__NewEnum from ISEODictionary
HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::get__NewEnum(IUnknown **ppUnkEnum) {

	return (E_NOTIMPL);
}       */


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::LockRead(int iTimeoutMS) {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Read,iTimeoutMS);
	if (!SUCCEEDED(hrRes)) {
		if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_BUSY)) {
			return (EVENTS_E_TIMEOUT);
		}
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::UnlockRead() {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Closed);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::LockWrite(int iTimeoutMS) {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Write,iTimeoutMS);
	if (!SUCCEEDED(hrRes)) {
		if (hrRes == HRESULT_FROM_WIN32(ERROR_PATH_BUSY)) {
			return (EVENTS_E_TIMEOUT);
		}
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOMetaDictionary::UnlockWrite() {
	HRESULT hrRes;

	hrRes = m_mbHelper.SetStatus(::Closed);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\regprop.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	regprop.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Registry Property Bag.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   11/26/96        created
	andyj   01/14/97        made usable for reading
	andyj   02/12/97        Converted PropertyBag's to Dictonary's

--*/


// REGPROP.cpp : Implementation of CSEORegDictionary
#include "stdafx.h"
#include "seodefs.h"
//#include "String"
#include "REGPROP.h"


// Registry Path Separator
#define PATH_SEP        "\\"


void Data2Variant(DWORD dwType, LPCSTR pData, CComVariant &varResult) {
	varResult.Clear();

	switch (dwType) { // Depending on the Registry type
		case REG_DWORD:
			varResult = *((long *) pData);
			break;

		case REG_DWORD_BIG_ENDIAN:
			varResult = MAKELONG(HIWORD(*((ULONG *) pData)),
					     LOWORD(*((ULONG *) pData)));
			break;

		case REG_EXPAND_SZ:
			{
				int iSize = ExpandEnvironmentStringsA(pData, NULL, 0);
				LPSTR szTemp = (LPSTR) _alloca(iSize);

				if(ExpandEnvironmentStringsA(pData, szTemp, iSize)) {
					varResult = szTemp;
				}
			}
			break;

		case REG_LINK:
		case REG_RESOURCE_LIST:
		case REG_MULTI_SZ:
		case REG_SZ:
		case REG_BINARY:
		case REG_NONE:
		default:
			varResult = pData;
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionaryEnum

class CSEORegDictionaryEnum :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//      public CComCoClass<CSEORegDictionaryEnum, &CLSID_CSEORegDictionary>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

		HRESULT STDMETHODCALLTYPE Next(DWORD, LPVARIANT, LPDWORD);
		HRESULT STDMETHODCALLTYPE Skip(DWORD);
		HRESULT STDMETHODCALLTYPE Reset(void);
		HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT **);

		// Not Exported
		HRESULT STDMETHODCALLTYPE Init(CSEORegDictionary *);

	BEGIN_COM_MAP(CSEORegDictionaryEnum)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	private: // Data members
		DWORD m_index;
		CSEORegDictionary *m_dictionary;
};

HRESULT CSEORegDictionaryEnum::FinalConstruct() {
	m_index = 0;
	m_dictionary = NULL;
	return S_OK;
}

void CSEORegDictionaryEnum::FinalRelease() {
	if(m_dictionary) m_dictionary->Release();
	m_dictionary = NULL;
}

STDMETHODIMP CSEORegDictionaryEnum::Init(CSEORegDictionary *pDict) {
	if(m_dictionary) m_dictionary->Release();
	m_dictionary = pDict;
	if(m_dictionary) m_dictionary->AddRef();
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Next(DWORD dwCount, LPVARIANT varDest,
					 LPDWORD pdwResult) {
	if(!m_dictionary) return E_FAIL; // Hasn't been properly initialized
	*pdwResult = 0; // Nothing done so far
	int iSize = max(m_dictionary->m_dwcMaxNameLen + 1,
			        m_dictionary->m_dwcMaxValueData);
	LPSTR pData = (LPSTR) _alloca(iSize); // Temp Buffer
	while(*pdwResult < dwCount) {
		DWORD retCode = ERROR_SUCCESS;  // Initialize
		CComVariant varResult;

		if(m_index < m_dictionary->m_dwValueCount) { // Still doing Values
			DWORD dwcNameSize = m_dictionary->m_dwcMaxNameLen + 1;
			DWORD dwcValueSize = m_dictionary->m_dwcMaxValueData;
			DWORD dwType = 0;
			LPSTR psName = (LPSTR) _alloca(dwcNameSize); // Temporary buffer for the name
			retCode = RegEnumValueA (m_dictionary->m_hkThisKey, m_index, psName, &dwcNameSize, NULL,
						 &dwType, (LPBYTE) pData, &dwcValueSize);
			if (retCode != ERROR_SUCCESS) return E_FAIL;
			// tbd: perhaps race condition that longer entry was added after RegQueryInfoKey call
			Data2Variant(dwType, pData, varResult);
		} else if(m_index < (m_dictionary->m_dwValueCount + m_dictionary->m_dwKeyCount)) { // Now do Keys
			CComPtr<CComObject<CSEORegDictionary> > pKey;
			retCode = RegEnumKeyA(m_dictionary->m_hkThisKey,
			          m_index - m_dictionary->m_dwValueCount, pData, iSize);
			if (retCode != ERROR_SUCCESS) return E_FAIL;
			CAndyString strTemp = m_dictionary->m_strSubKey;
			if(strTemp.length() > 0) strTemp += PATH_SEP; // Add separator if needed
			strTemp += pData;
			HRESULT hrRes = CComObject<CSEORegDictionary>::CreateInstance(&pKey);
			if(FAILED(hrRes)) return hrRes;
			if(!pKey) return E_FAIL;
			pKey.p->AddRef(); // Do this for CComPtr counting
			hrRes = pKey->Load(m_dictionary->m_strMachine.data(), (SEO_HKEY) (DWORD_PTR) m_dictionary->m_hkBaseKey, strTemp.data());
			if (FAILED(hrRes)) return hrRes;
			LPUNKNOWN punkResult = NULL;
			hrRes = pKey->QueryInterface(IID_ISEODictionary, (LPVOID *) &punkResult);
			if (FAILED(hrRes)) return hrRes;
			varResult = punkResult;
		} else {
			return S_OK; // No more data
		}

		varResult.Detach(&varDest[*pdwResult]);
		++m_index; // Point to the next one
		++(*pdwResult); // Increment successful count for caller
	}
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Skip(DWORD dwCount) {
	m_index += dwCount;
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Reset(void) {
	m_index = 0;
	return S_OK;
}

STDMETHODIMP CSEORegDictionaryEnum::Clone(IEnumVARIANT **ppunkResult) {
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComPtr<CComObject<CSEORegDictionaryEnum> > p;
	HRESULT hrRes = CComObject<CSEORegDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	p.p->AddRef(); // Do this for CComPtr counting
	hrRes = p->Init(m_dictionary);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
	return hrRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionary


HRESULT STDMETHODCALLTYPE CSEORegDictionary::get_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return (pvarName->vt != VT_BSTR) ? E_INVALIDARG :
	       GetVariantA(W2A(pvarName->bstrVal), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::put_Item(
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::put_Item"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::get__NewEnum(
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	// Based on Samples\ATL\circcoll\objects.cpp (see also ATL\beeper\beeper.*
	if (ppunkResult == NULL) return E_POINTER;
	*ppunkResult = NULL;
	CComObject<CSEORegDictionaryEnum> *p;
	HRESULT hrRes = CComObject<CSEORegDictionaryEnum>::CreateInstance(&p);
	if (!SUCCEEDED(hrRes)) return (hrRes);
	hrRes = p->Init(this);
	if (SUCCEEDED(hrRes)) hrRes = p->QueryInterface(IID_IEnumVARIANT, (void**)ppunkResult);
    if (FAILED(hrRes)) delete p;
	return hrRes;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	CComVariant varResult;
	DWORD dwType = 0;
	LPSTR pData = (LPSTR) _alloca(m_dwcMaxValueData);
	HRESULT hr = LoadItemA(pszName, dwType, (LPBYTE) pData);

	if(FAILED(hr)) { // Not a value, perhaps a key
		CComPtr<IUnknown> pRef;
		hr = GetInterfaceA(pszName, IID_ISEORegDictionary, &pRef);
		varResult = pRef;
		if(SUCCEEDED(hr)) hr = varResult.Detach(pvarResult);
		return hr;
	}

	Data2Variant(dwType, pData, varResult);
	if(SUCCEEDED(hr)) hr = varResult.Detach(pvarResult);
	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetVariantA(W2A(pszName), pvarResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetVariantA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetVariantW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetStringA(
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	DWORD dwType = 0;
	LPSTR pData = (LPSTR) _alloca(*pchCount);
	HRESULT hr = LoadItemA(pszName, dwType, (LPBYTE) pData, pchCount);
	if(FAILED(hr)) return hr;

	if(dwType == REG_EXPAND_SZ) { // It needs environment string substitutions
		DWORD dwSize = ExpandEnvironmentStringsA(pData, pszResult, *pchCount);
		if(!dwSize && *pData) hr = E_FAIL;
	} else {
		memcpy(pszResult, pData, *pchCount);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	USES_CONVERSION; // Needed for A2W(), etc.
	DWORD dwType = 0;
	DWORD dwBytes = *pchCount * sizeof(WCHAR);
	LPWSTR pData = (LPWSTR) _alloca(dwBytes);
	HRESULT hr = LoadItemW(pszName, dwType, (LPBYTE) pData, &dwBytes);
	if(FAILED(hr)) return hr;

	if(dwType == REG_EXPAND_SZ) { // It needs environment string substitutions
		*pchCount = ExpandEnvironmentStringsW(pData, pszResult, *pchCount);
	} else {
		memcpy(pszResult, pData, dwBytes);
		*pchCount = dwBytes / sizeof(WCHAR);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetStringA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetStringW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	DWORD dwType = 0;
	LPBYTE pData = (LPBYTE) _alloca(m_dwcMaxValueData);
	HRESULT hr = LoadItemA(pszName, dwType, pData);
	if(FAILED(hr)) return hr;
	*pdwResult = *((DWORD *) pData);
	return hr;
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetDWordA(W2A(pszName), pdwResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetDWordA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetDWordW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	CComObject<CSEORegDictionary> *pKey;
	HRESULT hrRes = CComObject<CSEORegDictionary>::CreateInstance(&pKey);
	if (!SUCCEEDED(hrRes)) return (hrRes);

	CAndyString strTemp = m_strSubKey;
	if(strTemp.length() > 0) strTemp += PATH_SEP; // Add separator if needed
	strTemp += pszName;
	hrRes = pKey->Load(m_strMachine.data(), (SEO_HKEY) (DWORD_PTR) m_hkBaseKey, strTemp.data());

	if (SUCCEEDED(hrRes)) {
		hrRes = pKey->QueryInterface(iidDesired, (LPVOID *) ppunkResult);
	}

    if (FAILED(hrRes)) delete pKey;

	return (hrRes);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::GetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	USES_CONVERSION; // Needed for W2A(), etc.
	return GetInterfaceA(W2A(pszName), iidDesired, ppunkResult);
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetInterfaceA(
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEORegDictionary::SetInterfaceW(
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEORegDictionary::SetInterfaceW"));
}

/*

STDMETHODIMP CSEORegPropertyBagEx::Write(LPCOLESTR pszPropName, VARIANT *pVar) {
	DWORD dwIdx;

	if (!pszPropName) {
		return (E_POINTER);
	}
	if (pVar && ((pVar->vt & VT_TYPEMASK) == VT_UNKNOWN)) {
		IUnknown *pTmp;
		ISEORegPropertyBagEx *pKey;
		HRESULT hrRes;
		BSTR strTmp;

		pTmp = (pVar->vt & VT_BYREF) ? (pVar->ppunkVal ? *pVar->ppunkVal : NULL) : pVar->punkVal;
		if (!pTmp) {
			return (E_INVALIDARG);
		}
		hrRes = pTmp->QueryInterface(IID_ISEORegPropertyBagEx,(LPVOID *) &pKey);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		strTmp = SysAllocStringLen(m_strSubKey,wcslen(m_strSubKey)+wcslen(pszPropName)+1);
		wcscat(strTmp, PATH_SEP);
		wcscat(strTmp,pszPropName);
		hrRes = pKey->Load(m_strMachine.data(),(SEO_HKEY) (DWORD) m_hkBaseKey,strTmp,NULL);
		SysFreeString(strTmp);
		pKey->Release();
		// tbd
		return (hrRes);
	} else {
		for (dwIdx=0;dwIdx<m_dwValueCnt;dwIdx++) {
			if (_wcsicmp(pszPropName,m_paValue[dwIdx].strName) == 0) {
				break;
			}
		}
		if ((dwIdx==m_dwValueCnt) && (!pVar || (pVar->vt==VT_EMPTY))) {
			return (S_OK);
		}
		if (dwIdx < m_dwValueCnt) {
			MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
		} else if (!MyReallocInPlace(&m_paValue,sizeof(m_paValue[0])*(m_dwValueCnt+1))) {
			return (E_OUTOFMEMORY);
		} else {
			m_dwValueCnt++;
		}
		// tbd
	}
	return (S_OK);
}


STDMETHODIMP CSEORegPropertyBagEx::CreateSubKey(LPCOLESTR pszPropName, ISEOPropertyBagEx **ppSubKey) {
	CComObject<CSEORegPropertyBagEx> *pKey;
	VARIANT varTmp;
	HRESULT hrRes;

	hrRes = CComObject<CSEORegPropertyBagEx>::CreateInstance(&pKey);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	VariantInit(&varTmp);
	varTmp.vt = VT_UNKNOWN | VT_BYREF;
	hrRes = pKey->QueryInterface(IID_IUnknown,(LPVOID *) varTmp.ppunkVal);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	hrRes = pKey->QueryInterface(IID_ISEOPropertyBagEx,(LPVOID *) ppSubKey);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	hrRes = Write(pszPropName,&varTmp);
	if (!SUCCEEDED(hrRes)) {
		pKey->Release();
		return (hrRes);
	}
	return (hrRes);
}

// The following is based on the MONKEY sample app in MSDN
STDMETHODIMP CSEORegDictionary::ReLoad() {
	USES_CONVERSION; // Needed for A2W(), etc.
	HKEY     hKey;
	DWORD retCode = ERROR_SUCCESS; // Initialize

	DWORD dwcMaxValueName = 0;      // Longest Value name.
	DWORD dwcMaxValueData = 0;      // Longest Value data size.
	retCode = RegQueryInfoKey(hKey, NULL, NULL, NULL, &m_dwKeyCnt, NULL, NULL,
				  &m_dwValueCnt, &dwcMaxValueName, &dwcMaxValueData, 0, 0);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Unable to get data for key

	// Allocate memory
	if(m_dwKeyCnt) {
		m_paKey   = (KeyEntry *)   MyMalloc(sizeof(KeyEntry)   * m_dwKeyCnt);
		if (!m_paKey) return E_FAIL; // Unable to allocate memory
	}
	if(m_dwValueCnt) {
		m_paValue = (ValueEntry *) MyMalloc(sizeof(ValueEntry) * m_dwValueCnt);
		if (!m_paValue) return E_FAIL; // Unable to allocate memory
	}

	retCode = ERROR_SUCCESS; // Initialize for the loop
	for (DWORD i = 0; (i < m_dwKeyCnt) && (retCode == ERROR_SUCCESS); i++) {
		m_paKey[i].pKey = NULL; // No object for it, yet
		m_paKey[i].strName = SysAllocStringLen(NULL, MAX_PATH + 1);
		if (!m_paKey[i].strName) return E_FAIL;

		retCode = RegEnumKeyW(hKey, i, m_paKey[i].strName, MAX_PATH + 1);
		if (retCode != ERROR_SUCCESS) return E_FAIL;
	}

	retCode = ERROR_SUCCESS; // Initialize for the loop
	for (i = 0; (i < m_dwValueCnt) && (retCode == ERROR_SUCCESS); i++) {
		m_paValue[i].bDirty = FALSE; // Not dirty
		m_paValue[i].strName = SysAllocStringLen(NULL, dwcMaxValueName);
		m_paValue[i].strData = SysAllocStringLen(NULL, dwcMaxValueData);
		if (!m_paValue[i].strName || !m_paValue[i].strData) return E_FAIL;

		DWORD dwcNameLen = dwcMaxValueName + 1;
		DWORD dwcValueSize = dwcMaxValueData;
		retCode = RegEnumValueW (hKey, i, m_paValue[i].strName, &dwcNameLen,
					 NULL, &m_paValue[i].dwType, (LPBYTE) m_paValue[i].strData,
					 &dwcValueSize);
		if (retCode != ERROR_SUCCESS) return E_FAIL;
		// tbd: perhaps race condition that longer entry was added after RegQueryInfoKey call
	}

	RegCloseKey (hKey);   // Close the key handle.
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::FreeBase() {
	m_hkBaseKey = NULL;
	return (S_OK);
}


STDMETHODIMP CSEORegDictionary::FreeData() {
	DWORD dwIdx;

	for (dwIdx=0;dwIdx<m_dwValueCnt;dwIdx++) {
		MySysFreeStringInPlace(&m_paValue[dwIdx].strName);
		MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
	}
	m_dwValueCnt = 0;
	MyFreeInPlace(&m_paValue);
	for (dwIdx=0;dwIdx<m_dwKeyCnt;dwIdx++) {
		MySysFreeStringInPlace(&m_paKey[dwIdx].strName);
		if (m_paKey[dwIdx].pKey) {
			RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
		}
	}
	MyFreeInPlace(&m_paKey);
	return (S_OK);
}

DATA (Member variables):
		DWORD m_dwValueCnt;
		struct ValueEntry {
			BSTR strName;
			DWORD dwType;
			BSTR strData;
			BOOL bDirty;
		} *m_paValue;
		DWORD m_dwKeyCnt;
		struct KeyEntry {
			BSTR strName;
			CComObject<CSEORegDictionary> *pKey;
		} *m_paKey;
*/

STDMETHODIMP CSEORegDictionary::Load(LPCOLESTR pszMachine,
									 SEO_HKEY skBaseKey,
									 LPCOLESTR pszSubKey,
									 IErrorLog *) {
	USES_CONVERSION; // Needed for OLE2A(), etc.
	if (!pszMachine || !pszSubKey)
	    return (E_INVALIDARG);
	else
	    return Load(OLE2A(pszMachine), skBaseKey, OLE2A(pszSubKey));
}

STDMETHODIMP CSEORegDictionary::Load(LPCSTR pszMachine,
				     SEO_HKEY skBaseKey,
				     LPCSTR pszSubKey) {
	HRESULT hrRes;

	if (!skBaseKey) return (E_INVALIDARG);

	if (!m_strMachine.empty() || m_hkBaseKey || !m_strSubKey.empty()) {
		CloseKey();
	}

	m_strMachine = pszMachine;
	m_strSubKey = pszSubKey;
	DWORD dwLastPos = m_strSubKey.length() - 1;
	if(m_strSubKey[dwLastPos] == *PATH_SEP) m_strSubKey.erase(dwLastPos, 1);
	m_hkBaseKey = (HKEY) skBaseKey;
	if (!m_strMachine.data() || !m_strSubKey.data()) return (E_OUTOFMEMORY);
	hrRes = OpenKey();
	return (hrRes);
}

HRESULT CSEORegDictionary::FinalConstruct() {
	HRESULT hrRes;

	m_hkBaseKey = NULL;
	m_hkThisKey = NULL;
	m_dwValueCount = 0;
	m_dwKeyCount = 0;
	m_dwcMaxValueData = 0; // Longest Value data size
	m_dwcMaxNameLen = 0; // Longest Key name size
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}

void CSEORegDictionary::FinalRelease() {
	CloseKey();
	m_pUnkMarshaler.Release();
}

STDMETHODIMP CSEORegDictionary::OpenKey() {
	// tbd: Verify that the A version of RegOpenKeyEx is compatible with the
	//      W version of RegQueryValueEx, etc.
	DWORD retCode = RegOpenKeyExA (m_hkBaseKey, m_strSubKey.data(),
				       0, KEY_READ, &m_hkThisKey);

	if (retCode != ERROR_SUCCESS) {
		m_hkThisKey = NULL; // Ensure this wasn't set
		return E_FAIL; // Unable to open key
	}

	DWORD dwKeyNameLen = 0;
	DWORD dwValueNameLen = 0;
	retCode = RegQueryInfoKey(m_hkThisKey, NULL, NULL, NULL, &m_dwKeyCount,
				  &dwKeyNameLen, NULL, &m_dwValueCount,
				  &dwValueNameLen, &m_dwcMaxValueData, NULL, NULL);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Unable to get data for key
	m_dwcMaxNameLen = max(dwKeyNameLen, dwValueNameLen);
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::CloseKey() {
	if(m_hkThisKey) RegCloseKey (m_hkThisKey); // Close the key handle.
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::LoadItemA(LPCSTR lpValueName,
					  DWORD  &dType,
					  LPBYTE lpData,
					  LPDWORD lpcbDataParam) {
	if (!m_hkThisKey) return E_FAIL; // Wasn't opened
	DWORD dwDummy = m_dwcMaxValueData;
	if(!lpcbDataParam) lpcbDataParam = &dwDummy;
	DWORD retCode = RegQueryValueExA(m_hkThisKey, lpValueName, NULL, &dType,
					 lpData, lpcbDataParam);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Error reading data
	return S_OK;
}

STDMETHODIMP CSEORegDictionary::LoadItemW(LPCWSTR lpValueName,
					  DWORD  &dType,
					  LPBYTE lpData,
					  LPDWORD lpcbDataParam) {
	if (!m_hkThisKey) return E_FAIL; // Wasn't opened
	DWORD dwDummy = m_dwcMaxValueData;
	if(!lpcbDataParam) lpcbDataParam = &dwDummy;
	DWORD retCode = RegQueryValueExW(m_hkThisKey, lpValueName, NULL, &dType,
					 lpData, lpcbDataParam);
	if (retCode != ERROR_SUCCESS) return E_FAIL; // Error reading data
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\metabag.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	metabag.h

Abstract:

	This module contains the definition for the
	ISEODictionary object on the Metabase.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   03/11/97        created

--*/

// METABAG.h : Declaration of the CSEOMetaDictionary


//#define TIMEOUT		15000
#define ALWAYS_LOCK	0


#define SafeStrlen(x)	((x)?wcslen(x):0)


class CGlobalInterfaceImpl {
	public:
		void Init() {
			m_pUnkObject = NULL;
			m_piGIT = NULL;
		};
		void Term() {
			if (m_pUnkObject) {
				m_pUnkObject->Release();
				m_pUnkObject = NULL;
			}
			if (m_piGIT) {
				HRESULT hrRes = m_piGIT->RevokeInterfaceFromGlobal(m_dwCookie);
				_ASSERTE(SUCCEEDED(hrRes));
				m_piGIT->Release();
				m_piGIT = NULL;
			}
		};
		bool operator!() {
			return (!m_pUnkObject&&!m_piGIT);
		};
		operator bool() {
			return (m_pUnkObject||m_piGIT);
		};
	protected:
		HRESULT Load(REFCLSID rclsid, REFIID riid) {
			return (LoadImpl(rclsid,riid,NULL));
		};
		HRESULT Load(REFIID riid, IUnknown *pUnkObject) {
			if (!pUnkObject) {
				return (E_POINTER);
			}
			return (LoadImpl(GUID_NULL,riid,pUnkObject));
		};
		HRESULT GetInterface(REFIID riid, IUnknown **ppUnkObject) {

			if (ppUnkObject) {
				*ppUnkObject = NULL;
			}
			if (!ppUnkObject) {
				return (E_POINTER);
			}
			_ASSERTE(m_pUnkObject||m_piGIT);	// Not loaded.
			_ASSERTE(!m_pUnkObject||!m_piGIT);	// Internal error.
			if (m_pUnkObject) {
				*ppUnkObject = m_pUnkObject;
				(*ppUnkObject)->AddRef();
				return (S_OK);
			}
			if (m_piGIT) {
				return (m_piGIT->GetInterfaceFromGlobal(m_dwCookie,riid,(LPVOID *) ppUnkObject));
			}
			return (E_FAIL);
		};
		HRESULT GetInterfaceQI(REFIID riid, REFIID riidDesired, LPVOID *ppvObject) {
			CComPtr<IUnknown> pUnkObject;
			HRESULT hrRes;

			if (ppvObject) {
				*ppvObject = NULL;
			}
			if (!ppvObject) {
				return (E_POINTER);
			}
			hrRes = GetInterface(riid,&pUnkObject);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			return (pUnkObject->QueryInterface(riidDesired,ppvObject));
		};
	private:
		HRESULT LoadImpl(REFCLSID rclsid, REFIID riid, IUnknown *pUnkObject) {
			HRESULT hrRes;

			hrRes = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
									 NULL,
									 CLSCTX_ALL,
									 IID_IGlobalInterfaceTable,
									 (LPVOID *) &m_piGIT);
			_ASSERTE(SUCCEEDED(hrRes));	// Should always succeed on NT4 SP3 and later.
			if (!SUCCEEDED(hrRes) && (hrRes != REGDB_E_CLASSNOTREG)) {
				return (hrRes);
			}
			if (!pUnkObject) {
				hrRes = CoCreateInstance(rclsid,NULL,CLSCTX_ALL,riid,(LPVOID *) &m_pUnkObject);
				if (!SUCCEEDED(hrRes)) {
					if (m_piGIT) {
						m_piGIT->Release();
						m_piGIT = NULL;
					}
					return (hrRes);
				}
			} else {
				m_pUnkObject = pUnkObject;
				m_pUnkObject->AddRef();
			}
			if (m_piGIT) {
				hrRes = m_piGIT->RegisterInterfaceInGlobal(m_pUnkObject,riid,&m_dwCookie);
				m_pUnkObject->Release();
				m_pUnkObject = NULL;
				if (!SUCCEEDED(hrRes)) {
					m_piGIT->Release();
					m_piGIT = NULL;
					return (hrRes);
				}
			}
			return (S_OK);
		};
		IUnknown *m_pUnkObject;
		DWORD m_dwCookie;
		IGlobalInterfaceTable *m_piGIT;
};


template<class T, const IID *pIID>
class CGlobalInterface : public CGlobalInterfaceImpl {
	public:
		HRESULT Load(REFCLSID rclsid) {
			return (CGlobalInterfaceImpl::Load(rclsid,*pIID));
		};
		HRESULT Load(T *pT) {
			if (!pT) {
				return (E_POINTER);
			}
			return (CGlobalInterfaceImpl::Load(*pIID,(IUnknown *) pT));
		};
		HRESULT GetInterface(T **ppT) {
			return (CGlobalInterfaceImpl::GetInterface(*pIID,(IUnknown **) ppT));
		};
		HRESULT GetInterfaceQI(REFIID riidDesired,LPVOID *ppv) {
			return (CGlobalInterfaceImpl::GetInterfaceQI(*pIID,riidDesired,ppv));
		};
};


struct IMSAdminBaseW;
class CSEOMetabaseLock;

enum LockStatus {Closed, Read, Write, Error, DontCare, InitError};


class CSEOMetabase { // Wrapper for Metabase funcitons
	public:
		CSEOMetabase() {
			m_mhHandle = METADATA_MASTER_ROOT_HANDLE;
			m_eStatus = Closed; // Closed until we delegate
			m_pszPath = (LPWSTR) MyMalloc(sizeof(*m_pszPath));
			m_pmbDefer = NULL;

            if(!m_pszPath) {
                m_hrInitRes = E_OUTOFMEMORY;
                goto Exit;
            }

            *m_pszPath = 0;
			m_hrInitRes = InitializeMetabase();

Exit:
			if(!SUCCEEDED(m_hrInitRes)) {
				m_eStatus = InitError;
			}
		};
		~CSEOMetabase() {
			if(!m_pmbDefer) SetStatus(Closed); // Close self on cleanup
			if (SUCCEEDED(m_hrInitRes)) {
				TerminateMetabase();
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = NULL;
			m_pmbDefer = NULL;
		};

		void operator=(const CSEOMetabase &mbMetabase) {
			SetPath(mbMetabase.m_pszPath);
		};
		HRESULT InitShare(CSEOMetabase *pmbOther, LPCWSTR pszPath, LPUNKNOWN punkOwner = NULL) {
			LPWSTR pszTmp = NULL;

			m_punkDeferOwner = punkOwner;
			m_pmbDefer = pmbOther;
			if (pszPath) {
				pszTmp = (LPWSTR) MyMalloc(sizeof(*pszPath)*(SafeStrlen(pszPath) + 1));
				if(!pszTmp) return E_OUTOFMEMORY;
				wcscpy(pszTmp, pszPath);
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = pszTmp;
			return S_OK;
		};

		LockStatus Status() const {
			return (m_pmbDefer ? m_pmbDefer->Status() : m_eStatus);
		};
		HRESULT SetStatus(LockStatus ls, long lTimeout=15000);
		HRESULT EnumKeys(LPCWSTR pszPath, DWORD dwNum, LPWSTR pszName);
		HRESULT AddKey(LPCWSTR pszPathBuf);
		HRESULT DeleteKey(LPCWSTR pszPathBuf);
		HRESULT GetData(LPCWSTR path, DWORD &dwType, DWORD &dwLen, PBYTE pbData);
		HRESULT SetData(LPCWSTR path, DWORD dwType, DWORD dwLen, PBYTE pbData);
		HRESULT SetDWord(LPCWSTR path, DWORD dwData) {
			return SetData(path, DWORD_METADATA, sizeof(DWORD), (PBYTE) &dwData);
		};
		HRESULT SetString(LPCWSTR path, LPCWSTR psData, int iLen = -1) {
			if(iLen < 0) iLen = sizeof(*psData) * (SafeStrlen(psData) + 1);
			return SetData(path, STRING_METADATA, iLen, (PBYTE) psData);
		};
		METADATA_HANDLE GetHandle() {
			if(m_pmbDefer) {
				return m_pmbDefer->GetHandle();
			} else {
				return m_mhHandle; // Not defering, so use our handle
			}
		};

		int GetPathLength() {
			int iRet = SafeStrlen(m_pszPath);
			if(m_pmbDefer) {
				iRet += (3 + m_pmbDefer->GetPathLength());
			}
			return iRet;
		};
		LPCWSTR GetRelPath(LPWSTR psRet) { // Get the Relative Path from the original deferer
			if(!psRet) return psRet;
			if(m_pmbDefer) {
				LPWSTR psBuf = (LPWSTR) alloca(sizeof(*psBuf)*(m_pmbDefer->GetPathLength() + 1));
				m_pmbDefer->GetRelPath(psBuf);
				ConcatinatePaths(psRet,psBuf,m_pszPath);
			} else {
				*psRet = 0; // Empty string
			}
			return psRet;
		};
		LPCWSTR GetPath(LPWSTR psRet) {
			if(!psRet) return psRet;
			if(m_pmbDefer) {
				LPWSTR psBuf = (LPWSTR) alloca(sizeof(*psBuf)*(m_pmbDefer->GetPathLength() + 1));
				m_pmbDefer->GetPath(psBuf);
				ConcatinatePaths(psRet, psBuf,m_pszPath);
			} else {
				wcscpy(psRet,m_pszPath);
			}
			return psRet;
		};
		void AppendPath(LPCWSTR pszPathParam) {
			LPWSTR pszPath = (LPWSTR) alloca(sizeof(*pszPath)*(SafeStrlen(m_pszPath)+SafeStrlen(pszPathParam)+3));
			ConcatinatePaths(pszPath,m_pszPath,pszPathParam);
			SetPath(pszPath);
		};
		void SetPath(LPCWSTR pszPath) {
			LPWSTR pszTmp = NULL;
			SetStatus(Closed); // Make sure we're closed
			if (pszPath) {
				pszTmp = (LPWSTR) MyMalloc((sizeof(*pszTmp))*(SafeStrlen(pszPath)+3));
                if(!pszTmp)
                    return;
				ConcatinatePaths(pszTmp,pszPath,NULL);
			}
			if(m_pszPath) MyFree(m_pszPath);
			m_pszPath = pszTmp;
		};

		static HRESULT InitializeMetabase();
		static HRESULT TerminateMetabase();

	protected:
		void ConcatinatePaths(LPWSTR pszResult, LPCWSTR pszP1, LPCWSTR pszP2);
		HRESULT OpenPath(CSEOMetabaseLock &mbLocker, LPCWSTR pszPath,
		                 LPWSTR pszPathBuf, DWORD &dwId, LockStatus lsOpen = Read);

	private:
		LPWSTR m_pszPath;
		METADATA_HANDLE m_mhHandle;
		LockStatus m_eStatus;
		CSEOMetabase *m_pmbDefer; // Defer to this object if set
		CComPtr<IUnknown> m_punkDeferOwner; // Keep reference count
		HRESULT m_hrInitRes;

		static CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> m_MetabaseHandle;
		static CGlobalInterface<IMSAdminBaseW,&IID_IMSAdminBase_W> m_MetabaseChangeHandle;
		static int m_iCount; // Number of calls to InitializeMetabase()
};

class CSEOMetabaseLock {
	public:
		CSEOMetabaseLock(CSEOMetabase *piObject, LockStatus ls = DontCare) {
			m_bChanged = FALSE;
			m_piObject = piObject;
			if(DontCare != ls) SetStatus(ls);
		};
		~CSEOMetabaseLock() {
			if(m_bChanged) SetStatus(m_lsPrevious);
		};

		HRESULT SetStatus(LockStatus ls) {
			if(!m_piObject) return E_FAIL; // Not initialized
			m_lsPrevious = m_piObject->Status();
			HRESULT hRes = m_piObject->SetStatus(ls);
			LockStatus lsNewStatus = m_piObject->Status();
			if((lsNewStatus != m_lsPrevious) && (hRes != S_FALSE)) m_bChanged = TRUE;
			if(lsNewStatus == Closed) m_bChanged = FALSE;
			return hRes;
		};

	private:
		CSEOMetabase *m_piObject;
		BOOL m_bChanged; // True if we are responsible for restoring in our destructor
		LockStatus m_lsPrevious;
};

// The following macro may be inserted in a method to support
// reading/writing from just that method if handle not already opened.
// The object will take care of closing the handle if needed, etc.
#define METABASE_HELPER(x,y) CSEOMetabaseLock mbHelper(x, y)



/////////////////////////////////////////////////////////////////////////////
// CSEOMetaDictionary

class ATL_NO_VTABLE CSEOMetaDictionary :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEOMetaDictionary, &CLSID_CSEOMetaDictionary>,
	public ISEOInitObject,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>,
	public IPropertyBag,
	public IDispatchImpl<IEventPropertyBag, &IID_IEventPropertyBag, &LIBID_SEOLib>,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>,
	public IConnectionPointContainerImpl<CSEOMetaDictionary>,
//	public IConnectionPointImpl<CSEOMetaDictionary, &IID_IEventNotifyBindingChange>
	public CSEOConnectionPointImpl<CSEOMetaDictionary, &IID_IEventNotifyBindingChange>
{
	friend class CSEOMetaDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT OnChange(LPCWSTR *apszPath);
		HRESULT GetVariantA(LPCSTR pszName, VARIANT *pvarResult, BOOL bCreate);
		HRESULT GetVariantW(LPCWSTR pszName, VARIANT *pvarResult, BOOL bCreate);

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOMetaDictionary Class",
								   L"SEO.SEOMetaDictionary.1",
								   L"SEO.SEOMetaDictionary");

	BEGIN_COM_MAP(CSEOMetaDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(ISEOInitObject)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		COM_INTERFACE_ENTRY(IPropertyBag)
		COM_INTERFACE_ENTRY(IEventPropertyBag)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, IEventPropertyBag)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	END_COM_MAP()

	BEGIN_CONNECTION_POINT_MAP(CSEOMetaDictionary)
		CONNECTION_POINT_ENTRY(IID_IEventNotifyBindingChange)
	END_CONNECTION_POINT_MAP()

	// CSEOConnectionPointImp<>
	public:
		void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount);
		void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount);

	// ISEODictionary
	public:
	virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item(
	    /* [in] */ VARIANT __RPC_FAR *pvarName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
	    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ VARIANT __RPC_FAR *pvarValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [out][in] */ DWORD __RPC_FAR *pchCount,
	    /* [retval][size_is][out] */ LPWSTR pszResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD chCount,
	    /* [size_is][in] */ LPCWSTR pszValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ DWORD dwValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ REFIID iidDesired,
	    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA(
	    /* [in] */ LPCSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);

	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW(
	    /* [in] */ LPCWSTR pszName,
	    /* [in] */ IUnknown __RPC_FAR *punkValue);


	// ISEOInitObject (IPersistPropertyBag)
	public:
		virtual HRESULT STDMETHODCALLTYPE GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID);

		virtual HRESULT STDMETHODCALLTYPE InitNew(void);

		virtual HRESULT STDMETHODCALLTYPE Load(
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ IErrorLog __RPC_FAR *pErrorLog);

		virtual HRESULT STDMETHODCALLTYPE Save(
			/* [in] */ IPropertyBag __RPC_FAR *pPropBag,
			/* [in] */ BOOL fClearDirty,
			/* [in] */ BOOL fSaveAllProperties);

	// IPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Write(LPCOLESTR pszPropName, VARIANT *pVar);

	// IEventPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE Item(VARIANT *pvarPropDesired, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Name(long lPropIndex, BSTR *pbstrPropName);
		HRESULT STDMETHODCALLTYPE Add(BSTR pszPropName, VARIANT *pvarPropValue);
		HRESULT STDMETHODCALLTYPE Remove(VARIANT *pvarPropDesired);
		HRESULT STDMETHODCALLTYPE get_Count(long *plCount);
		/*	Just use the get__NewEnum from ISEODictionary
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppUnkEnum);	*/

		DECLARE_GET_CONTROLLING_UNKNOWN();

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockRead();
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockWrite();

	protected:
		HRESULT CopyDictionary(LPCWSTR pszName, ISEODictionary *pBag);
		HRESULT Init(const CSEOMetabase &pmbOther, LPCWSTR pszPath) {
			m_mbHelper = pmbOther;
			m_mbHelper.AppendPath(pszPath);
			return S_OK;
		};
		HRESULT InitShare(CSEOMetabase &pmbOther, LPCWSTR pszPath) {
			return m_mbHelper.InitShare(&pmbOther, pszPath,
				this->GetControllingUnknown());
		};

	private: // Private data
		CSEOMetabase m_mbHelper; // The master helper
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\mimebag.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	mimebag.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Registry Property Bag.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   01/28/97	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// MIMEBAG.cpp : Implementation of CSEOMimeDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "mimeole.h"
#include "MIMEBAG.h"


inline void AnsiToBstr(BSTR &bstr, LPCSTR lpcstr) {
	if(bstr) SysFreeString(bstr);
	bstr = A2BSTR(lpcstr);
/*
	int iSize = lstrlen(lpcstr); // Number of characters to copy
	bstr = SysAllocStringLen(NULL, iSize);
	MultiByteToWideChar(CP_ACP, 0, lpcstr, -1, bstr, iSize);
*/
}

/////////////////////////////////////////////////////////////////////////////
// CSEOMimeDictionary


HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::get_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::get_Item"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::put_Item( 
    /* [in] */ VARIANT __RPC_FAR *pvarName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::put_Item"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::get__NewEnum( 
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::get__NewEnum"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetVariantA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetVariantA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetVariantW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ VARIANT __RPC_FAR *pvarValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetVariantW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPSTR pszResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pchCount,
    /* [retval][size_is][out] */ LPWSTR pszResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetStringA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetStringA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetStringW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD chCount,
    /* [size_is][in] */ LPCWSTR pszValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetStringW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetDWordA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetDWordA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetDWordW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetDWordW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::GetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ REFIID iidDesired,
    /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::GetInterfaceW"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetInterfaceA( 
    /* [in] */ LPCSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetInterfaceA"));
}

HRESULT STDMETHODCALLTYPE CSEOMimeDictionary::SetInterfaceW( 
    /* [in] */ LPCWSTR pszName,
    /* [in] */ IUnknown __RPC_FAR *punkValue)
{
	ATLTRACENOTIMPL(_T("CSEOMimeDictionary::SetInterfaceW"));
}

/*
STDMETHODIMP CSEOMimePropertyBagEx::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) {
	if (!pszPropName || !pVar) return (E_POINTER);

	LONG dwIdx;
	VARTYPE vtVar = pVar->vt; // Requested type
	VariantClear(pVar);
	ReadHeader();

/*
	if(vtVar == VT_UNKNOWN) || (vtVar == VT_EMPTY)) {
		// Look for a matching key
		for (dwIdx=0;dwIdx<m_dwKeyCnt;dwIdx++) {
			if (_wcsicmp(pszPropName, m_paKey[dwIdx].strName) == 0) {
				if(!m_paKey[dwIdx].pKey) { // If object doesn't already exists
					HRESULT hrRes = CComObject<CSEORegPropertyBagEx>::CreateInstance(&(m_paKey[dwIdx].pKey));
					if (!SUCCEEDED(hrRes)) return (hrRes);

					BSTR strTemp = SysAllocStringLen(m_strSubKey, wcslen(m_strSubKey) +
						       wcslen(m_paKey[dwIdx].strName) + wcslen(PATH_SEP));
					if (!strTemp) {
						RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
						return (E_OUTOFMEMORY);
					}

					if(wcslen(strTemp) > 0) wcscat(strTemp, PATH_SEP); // Add separator if needed
					wcscat(strTemp,m_paKey[dwIdx].strName);
					hrRes = m_paKey[dwIdx].pKey->Load(m_strMachine,(SEO_HKEY) (DWORD) m_hkBaseKey,strTemp,pErrorLog);
					SysFreeString(strTemp);

					if (!SUCCEEDED(hrRes)) {
						RELEASE_AND_SHREAD_POINTER(m_paKey[dwIdx].pKey);
						return (hrRes);
					}
				}

				pVar->vt = VT_UNKNOWN;
				pVar->punkVal = m_paKey[dwIdx].pKey;
				pVar->punkVal->AddRef(); // Increment for the copy we are about to return

				return (S_OK);
			}
		}

		if (vtVar != VT_EMPTY) return (E_INVALIDARG); // Didn't find right type to return
	}
* /
	// Look for a matching value
	for (dwIdx = 0; dwIdx < m_dwValueCnt; ++dwIdx) {
		if (_wcsicmp(pszPropName, m_paValue[dwIdx].strName) == 0) {
			HRESULT hrRes;
			VARIANT varResult;

			VariantInit(&varResult);
			varResult.vt = VT_BSTR; // | VT_BYREF;
			varResult.bstrVal = SysAllocString(m_paValue[dwIdx].strData);
			if (vtVar == VT_EMPTY) vtVar = varResult.vt;
			hrRes = VariantChangeType(pVar, &varResult, 0, vtVar);
			VariantClear(&varResult); // Not needed anymore

			if (FAILED(hrRes)) {
				VariantClear(pVar);
				if (pErrorLog) {
					// tbd
				}
				return (hrRes);
			}
			return (S_OK);
		}
	}
	return (E_INVALIDARG);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Count(LONG *plResult) {
	if(!plResult) return (E_POINTER);
	ReadHeader();
	*plResult = m_dwValueCnt;
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Name(LONG lIndex, BSTR *pstrResult) {
	if(!pstrResult) return (E_POINTER);
	ReadHeader();
	if(lIndex >= m_dwValueCnt) return (E_POINTER);
	SysFreeString(*pstrResult); // Free any existing string
	*pstrResult = SysAllocString(m_paValue[lIndex].strName);
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::get_Type(LONG lIndex, VARTYPE *pvtResult) {
	if(!pvtResult) return (E_POINTER);
	*pvtResult = VT_BSTR;
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::Lock() {
	m_csCritSec.Lock();
	return (S_OK);
}


STDMETHODIMP CSEOMimePropertyBagEx::Unlock() {
	m_csCritSec.Unlock();
	return (S_OK);
}
*/

HRESULT CSEOMimeDictionary::FinalConstruct() {
	m_dwValueCnt = 0;
	m_paValue = NULL;
	m_csCritSec.Init();
	m_pMessageTree = NULL; // Our copy of aggregated object
	m_pMalloc = NULL;
	HRESULT hr = E_FAIL;

	m_pMessageTree = NULL;
	// tbd: Combine these using CoCreateInstanceEx()
	hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_ALL,
	     IID_IMimeOleMalloc, (LPVOID *) &m_pMalloc);

	IUnknown *pUnkOuter = this;
	hr = CoCreateInstance(CLSID_MIMEOLE, pUnkOuter, CLSCTX_INPROC_SERVER, IID_IMimeMessageTree, (LPVOID *)&m_pMessageTree);
//	hr = CoCreateInstance(CLSID_MIMEOLE, this, CLSCTX_ALL,
//	     IID_IMimeMessageTree, (LPVOID *) &m_pMessageTree);

	if (SUCCEEDED(hr)) {
		hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	}
	return (hr);
}


void CSEOMimeDictionary::FinalRelease() {
//	Flush(NULL);

	for (LONG dwIdx = 0; dwIdx < m_dwValueCnt; ++dwIdx) {
		MySysFreeStringInPlace(&m_paValue[dwIdx].strName);
		MySysFreeStringInPlace(&m_paValue[dwIdx].strData);
	}

	m_dwValueCnt = 0;
	MyFreeInPlace(&m_paValue);

	RELEASE_AND_SHREAD_POINTER(m_pMessageTree);
	RELEASE_AND_SHREAD_POINTER(m_pMalloc);

	m_csCritSec.Term();
	m_pUnkMarshaler.Release();
}

void CSEOMimeDictionary::ReadHeader() {
	if(m_paValue) return; // Already read it

	IMimeHeader *pHeader = NULL;
	IMimeEnumHeaderLines *pEnum = NULL;
	HBODY hBody = 0;
	HEADERLINE rgLine[1];
	ULONG cLines = 0;
	LONG iEntries = 0; // Number of Header lines
	HRESULT hr = E_FAIL;

	// tbd: Error checking
	hr = m_pMessageTree->GetBody(IBL_ROOT, NULL, &hBody);
	hr = m_pMessageTree->BindToObject(hBody, IID_IMimeHeader, (LPVOID *) &pHeader);
	hr = pHeader->EnumHeaderLines(NULL, &pEnum);

	while(SUCCEEDED(hr = pEnum->Next(1, rgLine, &cLines))) {
		if(hr == S_FALSE) break;
		++iEntries;
		// Use rgLine->pszHeader and rgLine->pszLine
		m_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
	}

	RELEASE_AND_SHREAD_POINTER(pEnum);
	m_dwValueCnt = iEntries;
	m_paValue = (ValueEntry *) MyMalloc(sizeof(ValueEntry) * m_dwValueCnt);
	//if (!m_paValue) return E_FAIL; // Unable to allocate memory
	hr = pHeader->EnumHeaderLines(NULL, &pEnum);
	iEntries = 0; // Start again

	while(SUCCEEDED(hr = pEnum->Next(1, rgLine, &cLines))) {
		if(hr == S_FALSE) break;
		AnsiToBstr(m_paValue[iEntries].strName, rgLine->pszHeader);
		AnsiToBstr(m_paValue[iEntries].strData, rgLine->pszLine);
		++iEntries;
		m_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
	}

	RELEASE_AND_SHREAD_POINTER(pEnum);
	RELEASE_AND_SHREAD_POINTER(pHeader);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\regprop.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	regprop.h

Abstract:

	This module contains the definition for the Server
	Extension Object Registry Property Bag.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


// REGPROP.h : Declaration of the CSEORegDictionary
class CAndyString { // Temporary until we get std::string to work
	public:
		CAndyString() {m_string[0] = 0;}
		CAndyString(CAndyString &as) {lstrcpyn(m_string, as.m_string, sizeof(m_string));};

		LPCSTR data() {return m_string;};
		BOOL empty() {return (length() < 1);};
		int length() {return strlen(m_string);};
		void erase(int pos, int len = 1) {m_string[pos] = 0;};

		CAndyString &operator=(LPCSTR s) {lstrcpyn(m_string, s, sizeof(m_string)); return *this;};
		CAndyString &operator+=(LPCSTR s) 
		{
			strncat(m_string, s, (sizeof(m_string)-strlen(m_string))-1); 
			m_string[sizeof(m_string)-1]='\0';
			return *this;
		};
		char operator[](int i) {return m_string[i];};

	private:
		char m_string[MAX_PATH + 1];
};

/////////////////////////////////////////////////////////////////////////////
// CSEORegDictionary
class ATL_NO_VTABLE CSEORegDictionary : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEORegDictionary, &CLSID_CSEORegDictionary>,
	public IDispatchImpl<ISEORegDictionary, &IID_ISEORegDictionary, &LIBID_SEOLib>
{
	friend class CSEORegDictionaryEnum; // Helper class

	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEORegDictionary Class",
								   L"SEO.SEORegDictionary.1",
								   L"SEO.SEORegDictionary");

	BEGIN_COM_MAP(CSEORegDictionary)
		COM_INTERFACE_ENTRY(ISEORegDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
//		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEORegDictionary
	public:
        virtual /* [id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [propput][helpstring] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT __RPC_FAR *pvarName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [hidden][id][propget][helpstring] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVariantW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ VARIANT __RPC_FAR *pvarValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pchCount,
            /* [retval][size_is][out] */ LPWSTR pszResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStringW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD chCount,
            /* [size_is][in] */ LPCWSTR pszValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDWordW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID iidDesired,
            /* [retval][iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterfaceW( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown __RPC_FAR *punkValue);

		HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pszMachine, SEO_HKEY skBaseKey, LPCOLESTR pszSubKey, IErrorLog *pErrorLog);
		HRESULT STDMETHODCALLTYPE Load(LPCSTR pszMachine, SEO_HKEY skBaseKey, LPCSTR pszSubKey);

		DECLARE_GET_CONTROLLING_UNKNOWN();

	private: // Methods
		STDMETHODIMP OpenKey();
		STDMETHODIMP CloseKey();
		STDMETHODIMP LoadItemA(LPCSTR lpValueName,
                              DWORD  &lpType,
                              LPBYTE lpData,
                              LPDWORD lpcbDataParam = NULL);
		STDMETHODIMP LoadItemW(LPCWSTR lpValueName,
                              DWORD  &lpType,
                              LPBYTE lpData,
                              LPDWORD lpcbDataParam = NULL);

	private: // Data
		CAndyString m_strMachine; //std::string m_strMachine;
		CAndyString m_strSubKey; //std::string m_strSubKey;
		HKEY m_hkBaseKey;
		HKEY m_hkThisKey;
		DWORD m_dwValueCount;
		DWORD m_dwKeyCount;
		DWORD m_dwcMaxValueData; // Longest Value data size.
		DWORD m_dwcMaxNameLen; // Longest Name length
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the Server
	Extension Object resources.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	11/26/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\router.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	router.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Router class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/04/97	created

--*/


// router.cpp : Implementation of CSEORouter
#include "stdafx.h"

#define SEODLLDEF	// identifiers get exported through the .DEF file
#include "seodefs.h"
#include "fhash.h"
#include "router.h"


#define LOCK_TIMEOUT	INFINITE


static DWORD HashGuidToDword(const GUID& guid) {
	DWORD dwRes = 0;
	DWORD *pdwTmp = (DWORD *) &guid;
	DWORD dwRemain = sizeof(guid);

	while (dwRemain > sizeof(*pdwTmp)) {
		dwRes += *pdwTmp;
		*pdwTmp++;
		dwRemain -= sizeof(*pdwTmp);
	}
	return (dwRes);
}


static HRESULT VariantQI(VARIANT *pvar, REFIID iid, IUnknown **ppunkResult) {
	HRESULT hrRes;

	if (!pvar || !ppunkResult) {
		return (E_POINTER);
	}
	hrRes = VariantChangeType(pvar,pvar,0,VT_UNKNOWN);
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pvar);
		return (hrRes);
	}
	hrRes = pvar->punkVal->QueryInterface(iid,(void **) ppunkResult);
	VariantClear(pvar);
	return (hrRes);
}


static HRESULT GetNextSubDict(ISEODictionary *pdictBase, IEnumVARIANT *pevEnum, VARIANT *pvarName, ISEODictionary **ppdictSub) {
	HRESULT hrRes;
	VARIANT varSub;

	if (!pdictBase || !pevEnum || !pvarName || !ppdictSub) {
		return (E_POINTER);
	}
	VariantInit(pvarName);
	*ppdictSub = NULL;
	hrRes = pevEnum->Next(1,pvarName,NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (hrRes == S_FALSE) {
		return (SEO_E_NOTPRESENT);
	}
	VariantInit(&varSub);
	hrRes = pdictBase->get_Item(pvarName,&varSub);
	if (!SUCCEEDED(hrRes) || (varSub.vt == VT_EMPTY)) {
		VariantClear(pvarName);
		return (hrRes);
	}
	hrRes = VariantQI(&varSub,IID_ISEODictionary,(IUnknown **) ppdictSub);
	VariantClear(&varSub);
	if (!SUCCEEDED(hrRes)) {
		VariantClear(pvarName);
	}
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CBP
class CBP {
	public:
		CBP();
		CBP(CBP& bpFrom);
		~CBP();
		const CBP& operator =(const CBP& cbpFrom);
		CLSID& GetKey();
		int MatchKey(CLSID& clsid);
		HRESULT Init(REFCLSID clsidBP, ISEODictionary *pdictIn);
		CLSID m_clsidBP;
		CLSID m_clsidDispatcher;
		CComPtr<ISEODictionary> m_pdictBP;
		CComPtr<IUnknown> m_punkDispatcher;
};


inline const CBP& CBP::operator =(const CBP& cbpFrom) {

	m_clsidBP = cbpFrom.m_clsidBP;
	m_clsidDispatcher = cbpFrom.m_clsidDispatcher;
	m_pdictBP = cbpFrom.m_pdictBP;
	m_punkDispatcher = cbpFrom.m_punkDispatcher;
	return (*this);
}


/////////////////////////////////////////////////////////////////////////////
// CSEORouterInternal
class ATL_NO_VTABLE CSEORouterInternal :
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CSEORouter, &CLSID_CSEORouter>,
	public ISEORouter
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_AGGREGATABLE(CSEORouterInternal);

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SEORouter Class",
//								   L"SEO.SEORouter.1",
//								   L"SEO.SEORouter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEORouterInternal)
		COM_INTERFACE_ENTRY(ISEORouter)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IEventLock, m_pUnkLock.p)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEORouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE put_Database(ISEODictionary *pdictDatabase);
		HRESULT STDMETHODCALLTYPE get_Server(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE put_Server(ISEODictionary *pdictServer);
		HRESULT STDMETHODCALLTYPE get_Applications(ISEODictionary **ppdictResult);
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult);
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult);

	private:
		typedef TFHash<CBP,CLSID> CBPHash;
		CBPHash m_hashBP;
		CComPtr<ISEODictionary> m_pdictDatabase;
		CComPtr<ISEODictionary> m_pdictServer;
		CComPtr<ISEODictionary> m_pdictApplications;
		CComPtr<IUnknown> m_pUnkLock;
		CComPtr<IUnknown> m_pUnkMarshaler;
		IEventLock *m_pLock;
};


CBP::CBP() {

	m_clsidBP = GUID_NULL;
	m_clsidDispatcher = GUID_NULL;
}


CBP::CBP(CBP& cbpFrom) {

	m_clsidBP = cbpFrom.m_clsidBP;
	m_clsidDispatcher = cbpFrom.m_clsidDispatcher;
	m_pdictBP = cbpFrom.m_pdictBP;
	m_punkDispatcher = cbpFrom.m_punkDispatcher;
}


CBP::~CBP() {

	m_clsidBP = GUID_NULL;
	m_clsidDispatcher = GUID_NULL;
	m_pdictBP.Release();
	m_punkDispatcher.Release();
}


CLSID& CBP::GetKey() {

	return (m_clsidBP);
}


int CBP::MatchKey(CLSID& clsid) {

	return (memcmp(&m_clsidBP,&clsid,sizeof(clsid))==0);
}


HRESULT CBP::Init(REFCLSID clsidBP, ISEODictionary *pdictIn) {
	HRESULT hrRes;
	VARIANT varTmp;
	CComPtr<ISEODictionary> pdictTmp;

	if (!pdictIn) {
		return (E_POINTER);
	}
	m_clsidBP = clsidBP;
	VariantInit(&varTmp);
	hrRes = pdictIn->GetVariantA(BD_DISPATCHER,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = VariantChangeType(&varTmp,&varTmp,0,VT_BSTR);
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = CLSIDFromString(varTmp.bstrVal,&m_clsidDispatcher);
	}
	if (!SUCCEEDED(hrRes)) {
		m_clsidDispatcher = GUID_NULL;
	}
	VariantClear(&varTmp);
	hrRes = SEOCopyDictionary(pdictIn,&m_pdictBP);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT CSEORouterInternal::FinalConstruct() {
	TraceFunctEnter("CSEORouterInternal::FinalConstruct");
	HRESULT hrRes;

	if (!m_hashBP.Init(4,4,HashGuidToDword)) {
		return (E_OUTOFMEMORY);
	}
	hrRes = CoCreateInstance(CLSID_CSEOMemDictionary,
							 NULL,
							 CLSCTX_ALL,
							 IID_ISEODictionary,
							 (LPVOID *) &m_pdictApplications);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CoCreateInstance(CLSID_CEventLock,
							 GetControllingUnknown(),
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) &m_pUnkLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = m_pUnkLock->QueryInterface(IID_IEventLock,(LPVOID *) &m_pLock);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	GetControllingUnknown()->Release();	// decrement reference count to prevent circular reference
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEORouterInternal::FinalRelease() {
	TraceFunctEnter("CSEORouterInternal::FinalRelease");

	GetControllingUnknown()->AddRef();
	m_pdictDatabase.Release();
	m_pdictServer.Release();
	m_pdictApplications.Release();
	m_pLock->Release();
	m_pUnkLock.Release();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CSEORouterInternal::get_Database(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictDatabase;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT CSEORouterInternal::put_Database(ISEODictionary *pdictDatabase) {
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pdictDatabase = pdictDatabase;
	m_hashBP.Clear();
	if (!m_hashBP.Init(4,4,HashGuidToDword)) {
		return (E_OUTOFMEMORY);
	}
	if (m_pdictDatabase) {
		CComPtr<ISEODictionary> pdictBindingPoints;

		hrRes = m_pdictDatabase->GetInterfaceA(BD_BINDINGPOINTS,
											   IID_ISEODictionary,
											   (IUnknown **) &pdictBindingPoints);
		if (SUCCEEDED(hrRes)) {
			CComPtr<IUnknown> pUnkEnum;

			hrRes = pdictBindingPoints->get__NewEnum(&pUnkEnum);
			if (SUCCEEDED(hrRes)) {
				CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(pUnkEnum);

				if (pevEnum) {
					while (1) {
						VARIANT varBP;
						CComPtr<ISEODictionary> pdictBP;
						CLSID clsidBP;
						CBP cbpBP;

						VariantInit(&varBP);
						pdictBP = NULL;
						hrRes = GetNextSubDict(pdictBindingPoints,pevEnum,&varBP,&pdictBP);
						if (!SUCCEEDED(hrRes)) {
							break;
						}
						if (hrRes == S_FALSE) {
							continue;
						}
						hrRes = CLSIDFromString(varBP.bstrVal,&clsidBP);
						VariantClear(&varBP);
						if (!SUCCEEDED(hrRes)) {
							continue;
						}
						hrRes = cbpBP.Init(clsidBP,pdictBP);
						if (!SUCCEEDED(hrRes)) {
							continue;
						}
						m_hashBP.Insert(cbpBP);
					}
				}
			}
		}
	}
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CSEORouterInternal::get_Server(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictServer;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT CSEORouterInternal::put_Server(ISEODictionary *pdictServer) {
	HRESULT hrRes;

	hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pdictServer = pdictServer;
	m_pLock->UnlockWrite();
	return (S_OK);
}


HRESULT CSEORouterInternal::get_Applications(ISEODictionary **ppdictResult) {
	HRESULT hrRes;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	*ppdictResult = m_pdictApplications;
	if (*ppdictResult) {
		(*ppdictResult)->AddRef();
	}
	m_pLock->UnlockRead();
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEORouterInternal::GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {

	return (GetDispatcherByCLSID(iidEvent,iidEvent,iidDesired,ppUnkResult));
}


HRESULT STDMETHODCALLTYPE CSEORouterInternal::GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
	HRESULT hrRes;
	CBP *pcbpBP;
	CComPtr<IUnknown> punkDispatcher;

	if (!ppUnkResult) {
		return (E_POINTER);
	}
	*ppUnkResult = NULL;
	// First, get a read-lock across the entire set of binding points.
	hrRes = m_pLock->LockRead(LOCK_TIMEOUT);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	// Next, look for this particular binding point in the hash table.
	if (!(pcbpBP=m_hashBP.SearchKey((GUID&) iidEvent))) {
		// If it's not there - that's fine.  It means we don't have to dispatch to anyone.
		m_pLock->UnlockRead();
		return (S_FALSE);
	}
	// Next, look to see if we have already loaded the dispatcher for this binding point.
	if (!pcbpBP->m_punkDispatcher) {
		// Make copies of the data we'll need from the hash table entry.
		CLSID clsidTmpDispatcher = pcbpBP->m_clsidDispatcher;
		CComQIPtr<ISEODispatcher,&IID_ISEODispatcher> pdispDispatcher;
		CComQIPtr<ISEORouter,&IID_ISEORouter> prouterThis(GetControllingUnknown());
		CComPtr<ISEODictionary> pdictBP = pcbpBP->m_pdictBP;

		// If the CLSID for the dispatcher specified in the binding point is GUID_NULL, then use the
		// CLSID from the clsidDispatcher parameter.
		if (clsidTmpDispatcher == GUID_NULL) {
			clsidTmpDispatcher = clsidDispatcher;
		}
		// If we haven't already loaded the dispatcher, we need to release the read-lock, and create
		// the dispatcher object.
		m_pLock->UnlockRead();
		hrRes = CoCreateInstance(clsidTmpDispatcher,
								 NULL,
								 CLSCTX_ALL,
								 IID_IUnknown,
								 (LPVOID *) &punkDispatcher);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		// If the dispatcher supports ISEODispatcher, we want to initialize it through that interface.
		pdispDispatcher = punkDispatcher;
		if (pdispDispatcher) {
			hrRes = pdispDispatcher->SetContext(prouterThis,pdictBP);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		// Now get a write-lock across the entire set of binding points.
		hrRes = m_pLock->LockWrite(LOCK_TIMEOUT);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		// While we were creating the dispatcher, someone else may have updated the binding database
		// and removed this binding point entirely - so search for it again.
		if (!(pcbpBP=m_hashBP.SearchKey((GUID&) iidEvent))) {
			// The binding point went away while we were unlocked - which is not a problem, since it
			// means that someone changed the binding database during that window.  So just assume
			// everything is cool.
			m_pLock->UnlockWrite();
			return (S_FALSE);
		}
		// Also while we were creating the dispatcher, someone else may have been doing the exact same
		// thing - so check to make sure that there still isn't a dispatcher in the hash table.
		if (!pcbpBP->m_punkDispatcher) {
			// There isn't, so store the one we created there.
			pcbpBP->m_punkDispatcher = punkDispatcher;
		} else {
			// Make copy of the interface we need from the hash table entry.
			punkDispatcher = pcbpBP->m_punkDispatcher;
		}
		m_pLock->UnlockWrite();
	} else {
		// Make copies of the interface we need from the hash table entry.
		punkDispatcher = pcbpBP->m_punkDispatcher;
		m_pLock->UnlockRead();
	}
	// Get the interface which the client actually wants.
	hrRes = punkDispatcher->QueryInterface(iidDesired,(LPVOID *) ppUnkResult);
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CSEORouter


HRESULT CSEORouter::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CComObject<CSEORouterInternal>::_CreatorClass::CreateInstance(NULL,
																		  IID_ISEORouter,
																		  (LPVOID *) &m_pRouter);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_pLock = m_pRouter;
	m_pMarshal = m_pRouter;
	if (!m_pLock || !m_pMarshal) {
		return (E_NOINTERFACE);
	}
	return (S_OK);
}


void CSEORouter::FinalRelease() {

	if (m_pRouter) {
		m_pRouter->put_Database(NULL);
	}
	m_pRouter.Release();
	m_pLock.Release();
	m_pMarshal.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\seo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seo.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object service.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	10/11/96	created
	dondu	11/26/96	major rewrite
	andyj	02/03/97	Added CSEOMimeDictionary support
	andyj	02/12/97	Converted PropertyBag's to Dictonary's
	andyj	04/11/97	Added CSEOGenericMoniker

--*/


// SEO.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		<<TBD>>.

#include "stdafx.h"

//#define IID_DEFINED
#include "initguid.h"

#define SEODLLDEF	// identifiers get exported through the .DEF file
#include "seodefs.h"

#include "mimeole.h"

#include "String"
#include "MEMBAG.h"

#include "IADMW.H" // Needed by METABAG.H
#include "METABAG.H"

#include "SEO_i.c"
#include "regprop.h"
//#include "mimebag.h"
#include "item.h"
#include "fhash.h"
#include "router.h"
#include "rwnew.h"
#include "seolock.h"
#include "subdict.h"
#include "stream.h"
#include "events.h"
#include "gmoniker.h"
#include "seolib.h"


CSEOComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSEORegDictionary, CSEORegDictionary)
//	OBJECT_ENTRY(CLSID_CSEOMimeDictionary, CSEOMimeDictionary)
	OBJECT_ENTRY(CLSID_CSEOMemDictionary, CSEOMemDictionary)
	OBJECT_ENTRY(CLSID_CSEOMetaDictionary, CSEOMetaDictionary)
	OBJECT_ENTRY(CLSID_CSEODictionaryItem, CSEODictionaryItem)
	OBJECT_ENTRY(CLSID_CSEORouter, CSEORouter)
	OBJECT_ENTRY(CLSID_CEventLock, CEventLock)
	OBJECT_ENTRY(CLSID_CSEOStream, CSEOStream)
	OBJECT_ENTRY(CLSID_CEventManager, CEventManager)
	OBJECT_ENTRY(CLSID_CSEOGenericMoniker, CSEOGenericMoniker)
	OBJECT_ENTRY(CLSID_CEventMetabaseDatabaseManager, CEventMetabaseDatabaseManager)
	OBJECT_ENTRY(CLSID_CEventBindingManager, CEventBindingManager)
	OBJECT_ENTRY(CLSID_CEventUtil, CEventUtil)
	OBJECT_ENTRY(CLSID_CEventComCat, CEventComCat)
	OBJECT_ENTRY(CLSID_CEventRouter, CEventRouter)
	OBJECT_ENTRY(CLSID_CEventServiceObject, CEventServiceObject)
END_OBJECT_MAP()

ALLOC_DEBUG_MODULE


/////////////////////////////////////////////////////////////////////////////
// CSEOComModule

static GUID g_appidSEO = { /* 064b2506-630b-11d2-a028-00c04fa37348 */
    0x064b2506,
    0x630b,
    0x11d2,
    {0xa0, 0x28, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48}
};

const GUID *CSEOComModule::GetAPPID() {

	return (&g_appidSEO);
}


HRESULT CSEOComModule::WriteAPPID() {
	CStringGUID guid;
	LPSTR pszKey;
	CRegKey rk;
	LONG lRes;
	HRESULT hrRes = S_OK;

	guid = *GetAPPID();
	if (!guid) {
		return (CO_E_CLASSSTRING);
	}
	pszKey = (LPSTR) alloca(strlen("AppID\\")+strlen(guid)+1);
	if (!pszKey) {
		return (E_OUTOFMEMORY);
	}
	strcpy(pszKey,"AppID\\");
	strcat(pszKey,guid);
	lRes = rk.Create(HKEY_CLASSES_ROOT,pszKey);
	if (lRes != ERROR_SUCCESS) {
		return (HRESULT_FROM_WIN32(lRes));
	}
	lRes = rk.SetValue("Server Extension Objects");
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
	lRes = rk.SetValue("","DllSurrogate");
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
exit:
	rk.Close();
	if (!SUCCEEDED(hrRes)) {
		EraseAPPID();
	}
	return (hrRes);
}


HRESULT CSEOComModule::EraseAPPID() {
	CStringGUID guid;
	LPSTR pszKey;
	CRegKey rk;
	LONG lRes;
	HRESULT hrRes = S_OK;

	guid = *GetAPPID();
	if (!guid) {
		return (CO_E_CLASSSTRING);
	}
	pszKey = (LPSTR) alloca(strlen(guid)+strlen("AppID\\")+1);
	if (!pszKey) {
		return (E_OUTOFMEMORY);
	}
	strcpy(pszKey,"AppID\\");
	strcat(pszKey,guid);
	lRes = rk.Open(HKEY_CLASSES_ROOT,"");
	if (lRes != ERROR_SUCCESS) {
		return (HRESULT_FROM_WIN32(lRes));
	}
	lRes = rk.RecurseDeleteKey(pszKey);
	if (lRes != ERROR_SUCCESS) {
		hrRes = HRESULT_FROM_WIN32(lRes);
		goto exit;
	}
exit:
	rk.Close();
	return (hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		INIT_DEBUG_MODULE
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		TERM_DEBUG_MODULE
		_Module.Term();
		if (!lpvReserved) {
			// lpvReserved is NULL when called because of FreeLibrary, and
			// non-NULL when called during normal process termination.  We
			// only want to perform this operation during FreeLibrary,
			// because we are calling into another .DLL and we only want to
			// do that if we are sure that the other .DLL hasn't already
			// terminated.
			MyMallocTerm();
		}
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {

	TraceFunctEnter("DllCanUnloadNow");
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	DebugTrace(0,"Returns %s.",(hRes==S_OK)?"S_OK":"S_FALSE");
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {

	TraceFunctEnter("DllGetClassObject");
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {

	TraceFunctEnter("DllRegisterServer");
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.WriteAPPID();
	if (SUCCEEDED(hRes)) {
		hRes = _Module.RegisterServer(TRUE);
		if (!SUCCEEDED(hRes)) {
			_Module.UnregisterServer();
			_Module.EraseAPPID();
		}
	}
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {

	TraceFunctEnter("DllUnregisterServer");
	_Module.UnregisterServer();
	_Module.EraseAPPID();
	DebugTrace(0,"Returns S_OK");
	TraceFunctLeave();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE MCISInitSEOA(LPCSTR pszService, DWORD dwVirtualServer, ISEORouter **ppshHandle) {
	TraceFunctEnter("MCISInitSEOA");
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;
	CComPtr<ISEORouter> prouterResult;

	if (!ppshHandle) {
		return (E_POINTER);
	}
	*ppshHandle = NULL;
	hrRes = MCISGetBindingInMetabaseA(pszService,dwVirtualServer,GUID_NULL,NULL,TRUE,FALSE,&pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CComObject<CSEORouter>::_CreatorClass::CreateInstance(NULL,
																  IID_ISEORouter,
																  (LPVOID *) &prouterResult);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = prouterResult->put_Database(pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	*ppshHandle = prouterResult;
	(*ppshHandle)->AddRef();
	TraceFunctLeave();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE MCISInitSEOW(LPCWSTR pszService, DWORD dwVirtualServer, ISEORouter **ppshHandle) {
	TraceFunctEnter("MCISInitSEOW");
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;
	CComPtr<ISEORouter> prouterResult;

	if (!ppshHandle) {
		return (E_POINTER);
	}
	*ppshHandle = NULL;
	hrRes = MCISGetBindingInMetabaseW(pszService,dwVirtualServer,GUID_NULL,NULL,TRUE,FALSE,&pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = CComObject<CSEORouter>::_CreatorClass::CreateInstance(NULL,
																  IID_ISEORouter,
																  (LPVOID *) &prouterResult);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	hrRes = prouterResult->put_Database(pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		TraceFunctLeave();
		return (hrRes);
	}
	*ppshHandle = prouterResult;
	(*ppshHandle)->AddRef();
	TraceFunctLeave();
	return (S_OK);
}


static HRESULT GetSubDictA(ISEODictionary *pdictBase,
						   LPCSTR pszName,
						   LPCSTR *ppszSubName,
						   ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	LPSTR pszNameCopy = (LPSTR) _alloca((strlen(pszName)+1)*sizeof(CHAR));
	LPSTR pszNameCurr;
	CComPtr<ISEODictionary> pdictCurr = pdictBase;
	LPSTR pszSlash;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pdictBase || !pszName || !ppszSubName) {
		return (E_POINTER);
	}
	strcpy(pszNameCopy,pszName);
	pszNameCurr = pszNameCopy;
	while ((pszSlash=strchr(pszNameCurr,'\\'))!=NULL) {
		CComPtr<ISEODictionary> pdictSub;

		*pszSlash = 0;
		pdictSub.Release();
		hrRes = pdictCurr->GetInterfaceA(pszNameCurr,IID_ISEODictionary,(IUnknown **) &pdictSub);
		if (!SUCCEEDED(hrRes) && (hrRes != SEO_E_NOTPRESENT)) {
			return (hrRes);
		}
		if (!SUCCEEDED(hrRes)) {
			hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																				 IID_ISEODictionary,
																				 (LPVOID *) &pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			hrRes = pdictCurr->SetInterfaceA(pszNameCurr,pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		pdictCurr = pdictSub;
		pszNameCurr = pszSlash + 1;
	}
	*ppszSubName = pszName + (pszNameCurr - pszNameCopy);
	*ppdictResult = pdictCurr;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


static HRESULT GetSubDictW(ISEODictionary *pdictBase,
						   LPCWSTR pszName,
						   LPCWSTR *ppszSubName,
						   ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	LPWSTR pszNameCopy = (LPWSTR) _alloca((wcslen(pszName)+1)*sizeof(WCHAR));
	LPWSTR pszNameCurr;
	CComPtr<ISEODictionary> pdictCurr = pdictBase;
	LPWSTR pszSlash;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pdictBase || !pszName || !ppszSubName) {
		return (E_POINTER);
	}
	wcscpy(pszNameCopy,pszName);
	pszNameCurr = pszNameCopy;
	while ((pszSlash=wcschr(pszNameCurr,'\\'))!=NULL) {
		CComPtr<ISEODictionary> pdictSub;

		*pszSlash = 0;
		pdictSub.Release();
		hrRes = pdictCurr->GetInterfaceW(pszNameCurr,IID_ISEODictionary,(IUnknown **) &pdictSub);
		if (!SUCCEEDED(hrRes) && (hrRes != SEO_E_NOTPRESENT)) {
			return (hrRes);
		}
		if (!SUCCEEDED(hrRes)) {
			hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																				 IID_ISEODictionary,
																				 (LPVOID *) &pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			hrRes = pdictCurr->SetInterfaceW(pszNameCurr,pdictSub);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		pdictCurr = pdictSub;
		pszNameCurr = pszSlash + 1;
	}
	*ppszSubName = pszName + (pszNameCurr - pszNameCopy);
	*ppdictResult = pdictCurr;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromMultiSzA(	DWORD dwCount,
														LPCSTR *ppszNames,
														LPCSTR *ppszValues,
														BOOL bCopy,
														BOOL bReadOnly,
														ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	DWORD dwIdx;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!ppszNames || !ppszValues) {
		return (E_POINTER);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwCount;dwIdx++) {
		if (!ppszNames[dwIdx] || !ppszNames[dwIdx][0]) {
			return (E_POINTER);
		}
		LPCSTR pszSubString;
		CComPtr<ISEODictionary> pdictSub;
		LPCSTR pszSubName;

		pdictSub.Release();
		hrRes = GetSubDictA(pdictTmp,ppszNames[dwIdx],&pszSubName,&pdictSub);
		pszSubString = ppszValues[dwIdx];
		if (pszSubString[strlen(pszSubString)+1]) {
			CComPtr<ISEODictionaryItem> pitemValue;

			hrRes = CComObject<CSEODictionaryItem>::_CreatorClass::CreateInstance(NULL,
																				  IID_ISEODictionaryItem,
																				  (LPVOID *) &pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			while (*pszSubString) {
				hrRes = pitemValue->AddStringA((DWORD) -1,pszSubString);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				pszSubString += strlen(pszSubString) + 1;
			}
			hrRes = pdictSub->SetInterfaceA(pszSubName,pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		} else {
			hrRes = pdictSub->SetStringA(pszSubName,(strlen(pszSubString)+1)*sizeof(CHAR),pszSubString);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromMultiSzW(	DWORD dwCount,
														LPCWSTR *ppszNames,
														LPCWSTR *ppszValues,
														BOOL bCopy,
														BOOL bReadOnly,
														ISEODictionary **ppdictResult) {

	HRESULT hrRes;
	DWORD dwIdx;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!ppszNames || !ppszValues) {
		return (E_POINTER);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwCount;dwIdx++) {
		if (!ppszNames[dwIdx] || !ppszNames[dwIdx][0]) {
			return (E_POINTER);
		}
		LPCWSTR pszSubString;
		CComPtr<ISEODictionary> pdictSub;
		LPCWSTR pszSubName;

		pdictSub.Release();
		hrRes = GetSubDictW(pdictTmp,ppszNames[dwIdx],&pszSubName,&pdictSub);
		pszSubString = ppszValues[dwIdx];
		if (pszSubString[wcslen(pszSubString)+1]) {
			CComPtr<ISEODictionaryItem> pitemValue;

			hrRes = CComObject<CSEODictionaryItem>::_CreatorClass::CreateInstance(NULL,
																				  IID_ISEODictionaryItem,
																				  (LPVOID *) &pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			while (*pszSubString) {
				hrRes = pitemValue->AddStringW((DWORD) -1,pszSubString);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				pszSubString += wcslen(pszSubString) + 1;
			}
			hrRes = pdictSub->SetInterfaceW(pszSubName,pitemValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		} else {
			hrRes = pdictSub->SetStringW(pszSubName,(wcslen(pszSubString)+1)*sizeof(CHAR),pszSubString);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (S_OK);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateMultiSzFromDictionaryA(	ISEODictionary *pdictDictionary,
														DWORD *pdwCount,
														LPSTR **pppszNames,
														LPSTR **pppszValues) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateMultiSzFromDictionaryW(	ISEODictionary *pdictDictionary,
														DWORD *pdwCount,
														LPWSTR **pppszNames,
														LPWSTR **pppszValues) {

	return (E_NOTIMPL);
}


#define DW2W(x) _itow(x,(LPWSTR) _alloca(11*sizeof(WCHAR)),10)


SEODLLDEF HRESULT STDAPICALLTYPE MCISGetBindingInMetabaseA(	LPCSTR pszService,
												DWORD dwVirtualServer,
												REFGUID guidEventSource,
												LPCSTR pszBinding,
												BOOL bCreate,
												BOOL fLock,
												ISEODictionary **ppdictResult) {
	USES_CONVERSION;

	return (MCISGetBindingInMetabaseW(pszService?A2W(pszService):NULL,
									  dwVirtualServer,
									  guidEventSource,
									  pszBinding?A2W(pszBinding):NULL,
									  bCreate,
									  fLock,
									  ppdictResult));
}

SEODLLDEF HRESULT STDAPICALLTYPE MCISGetBindingInMetabaseW(	LPCWSTR pszService,
												DWORD dwVirtualServer,
												REFGUID guidEventSource,
												LPCWSTR pszBinding,
												BOOL bCreate,
												BOOL fLock,
												ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	CComPtr<ISEOInitObject> pinitRoot;
	CComPtr<ISEODictionary> pdictTmp;
	CComQIPtr<IPropertyBag,&IID_IPropertyBag> ppropTmp;
	CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictRoot;
	CComBSTR bstrPath;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	if (!pszService) {
		return (E_POINTER);
	}
	if ((guidEventSource != GUID_NULL) && !pszBinding && !bCreate) {
		return (E_INVALIDARG);
	}
	hrRes = CComObject<CSEOMetaDictionary>::_CreatorClass::CreateInstance(NULL,
																		  IID_ISEOInitObject,
																		  (LPVOID *) &pinitRoot);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pdictTmp->SetStringW(L"MetabasePath",1,L"");
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	ppropTmp = pdictTmp;
	if (!ppropTmp) {
		return (E_NOINTERFACE);
	}
	hrRes = pinitRoot->Load(ppropTmp,NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pdictRoot = pinitRoot;
	if (!pdictRoot) {
		return (E_NOINTERFACE);
	}
	bstrPath = "LM/";
	bstrPath.Append(pszService);
	bstrPath.Append("/");
	bstrPath.Append(DW2W(dwVirtualServer));
	bstrPath.Append("/SEO");
	if (guidEventSource != GUID_NULL) {
		CStringGUID objGuid;

		bstrPath.Append("/BindingPoints/");
		objGuid = guidEventSource;
		if (!objGuid) {
			return (E_INVALIDARG);
		}
		bstrPath.Append((LPCOLESTR) objGuid);
		bstrPath.Append("/Bindings/");
		if (pszBinding) {
			bstrPath.Append(pszBinding);
		} else {
			if (!objGuid.CalcNew()) {
				return (E_FAIL);
			}
			bstrPath.Append((LPCOLESTR) objGuid);
		}
	}
again:
	hrRes = pdictRoot->GetInterfaceW(bstrPath,IID_ISEODictionary,(IUnknown **) ppdictResult);
	if (SUCCEEDED(hrRes) || (hrRes != SEO_E_NOTPRESENT) || !bCreate) {
		return (hrRes);
	}
	// We got an SEO_E_NOTPRESENT error, and the caller specified bCreate==TRUE, so we need
	// to create the sub-key.  We do this by writing an empty dictionary to the sub-key - we'll
	// empty the dictionary we used to initialize the root, and write that to the sub-key.
	CComVariant varEmpty;
	hrRes = pdictTmp->SetVariantW(L"MetabasePath",&varEmpty);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pdictRoot->SetInterfaceW(bstrPath,pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	bCreate = FALSE;
	goto again;
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOListenForEvent(	ISEORouter *piRouter,
										HANDLE hEvent,
									  	ISEOEventSink *psinkEventSink,
										BOOL bOnce,
									  	DWORD *pdwListenHandle) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCancelListenForEvent(	DWORD dwHandle) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateIStreamFromFileA(	HANDLE hFile,
												LPCSTR pszFile,
												IStream **ppstreamResult) {
	HRESULT hrRes;
	CComObject<CSEOStream> *pStream;
	ULARGE_INTEGER libOffset;

	if (!ppstreamResult) {
		return (E_POINTER);
	}
	*ppstreamResult = NULL;
	hrRes = CComObject<CSEOStream>::CreateInstance(&pStream);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pStream->AddRef();
	libOffset.QuadPart = 0;
	hrRes = pStream->Init(hFile,pszFile,libOffset,NULL);
	if (SUCCEEDED(hrRes)) {
		hrRes = pStream->QueryInterface(IID_IStream,(LPVOID *) ppstreamResult);
	}
	pStream->Release();
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateIStreamFromFileW(	HANDLE hFile,
												LPCWSTR pszFile,
												IStream **ppstreamResult) {
	HRESULT hrRes;
	CComObject<CSEOStream> *pStream;
	ULARGE_INTEGER libOffset;

	if (!ppstreamResult) {
		return (E_POINTER);
	}
	*ppstreamResult = NULL;
	hrRes = CComObject<CSEOStream>::CreateInstance(&pStream);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pStream->AddRef();
	libOffset.QuadPart = 0;
	hrRes = pStream->Init(hFile,pszFile,libOffset,NULL);
	if (SUCCEEDED(hrRes)) {
		hrRes = pStream->QueryInterface(IID_IStream,(LPVOID *) ppstreamResult);
	}
	pStream->Release();
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCopyDictionary(ISEODictionary *pdictIn, ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictTmp;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	*ppdictResult = NULL;
	hrRes = CComObject<CSEOMemDictionary>::_CreatorClass::CreateInstance(NULL,
																		 IID_ISEODictionary,
																		 (LPVOID *) &pdictTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	if (pdictIn) {
		CComPtr<IUnknown> punkEnum;

		hrRes = pdictIn->get__NewEnum(&punkEnum);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(punkEnum);
		if (!pevEnum) {
			return (E_NOINTERFACE);
		}
		VARIANT varName;
		VariantInit(&varName);
		while ((hrRes=pevEnum->Next(1,&varName,NULL))==S_OK) {
			VARIANT varValue;

			VariantInit(&varValue);
			hrRes = pdictIn->get_Item(&varName,&varValue);
			if (!SUCCEEDED(hrRes) || (varValue.vt == VT_EMPTY)) {
				VariantClear(&varName);
				return (hrRes);
			}
			hrRes = VariantChangeType(&varValue,&varValue,0,VT_UNKNOWN);
			if (SUCCEEDED(hrRes)) {
				CComQIPtr<ISEODictionary,&IID_ISEODictionary> pdictSub(varValue.punkVal);

				if (pdictSub) {
					CComPtr<ISEODictionary> pdictSubCopy;

					hrRes = SEOCopyDictionary(pdictSub,&pdictSubCopy);
					if (!SUCCEEDED(hrRes)) {
						VariantClear(&varName);
						return (hrRes);
					}
					varValue.punkVal->Release();
					varValue.punkVal = pdictSubCopy;
					varValue.punkVal->AddRef();
				}
			}
			hrRes = pdictTmp->put_Item(&varName,&varValue);
			VariantClear(&varName);
			VariantClear(&varValue);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
		}
		if (hrRes == S_FALSE) {
			hrRes = S_OK;
		}
	}
	*ppdictResult = pdictTmp;
	(*ppdictResult)->AddRef();
	return (hrRes);
}


static HRESULT ReadLineFromStream(IStream *pstreamIn, LPSTR *ppszLine) {
	HRESULT hrRes;
	const int c_iAllocSize = 512;
	LPSTR pszTmp = NULL;
	LPSTR pszCurr = NULL;
	LPSTR pszEnd = NULL;
	BOOL bInEscape = FALSE;
	BOOL bEOF = FALSE;

	if (!pstreamIn || !ppszLine) {
		return (E_POINTER);
	}
	CoTaskMemFree(*ppszLine);
	*ppszLine = NULL;
	while (1) {
		if (pszCurr == pszEnd) {
			LPSTR pszNew = (LPSTR) CoTaskMemRealloc(pszTmp,((pszCurr-pszTmp)+c_iAllocSize)*sizeof(*pszTmp));

			if (!pszNew) {
				CoTaskMemFree(pszTmp);
				return (E_OUTOFMEMORY);
			}
			pszCurr = pszNew + (pszCurr-pszTmp);
			pszEnd = pszCurr + c_iAllocSize;
			pszTmp = pszNew;
		}
		hrRes = pstreamIn->Read(pszCurr,sizeof(*pszCurr),NULL);
		if (!SUCCEEDED(hrRes)) {
			CoTaskMemFree(pszTmp);
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			// end-of-file - pretend like non-escaped '\n'
			bInEscape = FALSE;
			*pszCurr = '\n';
			bEOF = TRUE;
		}
		if (*pszCurr == '\r') {
			// always eat carriage returns - even escaped ones
			continue;
		}
		if (bInEscape) {
			switch (*pszCurr) {

				case 'n':
					// escape-n becomes linefeed
					*pszCurr = '\n';
					break;

				case 'r':
					// escape-r becomes carriage return
					*pszCurr = '\r';
					break;

				case '\n':
					// escaped-linefeed means line continuation
					pszCurr--;
					break;

// for now, don't allow embedded NULLs - this is because we return a NULL-terminated string
//				case '0':
//					// escape-0 means embedded NULL
//					*pszCurr = 0;
//					break;

				case 0:
					// escape-NULL - just eat
					pszCurr--;
					break;

				default:
					// escape-(anything else) is just passed through
					break;
			}
			bInEscape = FALSE;
		} else {
			BOOL bFinished = FALSE;

			switch (*pszCurr) {

				case '\\':
					// first character of escape sequence
					pszCurr--;
					bInEscape = TRUE;
					break;

				case '\n':
					// end-of-line
					bFinished = TRUE;
					break;

				case 0:
					// non-escaped NULL - just eat
					pszCurr--;
					break;
			}
			if (bFinished) {
				break;
			}
		}
		pszCurr++;
	}
	*pszCurr = 0;
	*ppszLine = pszTmp;
	return (bEOF?S_FALSE:S_OK);
}


static HRESULT SEOCreateMultiSzFromIStreamA(IStream *pstreamIn,
											DWORD *pdwCount,
											LPSTR **pppszNames,
											LPSTR **pppszValues) {
	HRESULT hrRes;
	LPSTR *ppszLines = NULL;
	DWORD dwLines = NULL;

	if (!pstreamIn || !pdwCount || !pppszNames || !pppszValues) {
		return (E_POINTER);
	}
	*pdwCount = 0;
	*pppszNames = NULL;
	*pppszValues = NULL;
	while (1) {
		LPSTR *ppszNew = (LPSTR *) CoTaskMemRealloc(ppszLines,sizeof(*ppszLines)*(dwLines+1));

		if (!ppszNew) {
			hrRes = E_OUTOFMEMORY;
			break;
		}
		ppszLines = ppszNew;
		ppszLines[dwLines] = NULL;
		hrRes = ReadLineFromStream(pstreamIn,&ppszLines[dwLines]);
		if (!SUCCEEDED(hrRes)) {
			break;
		}
		if (!ppszLines[dwLines][0] ||
			(ppszLines[dwLines][0] == '#') ||
			!strchr(ppszLines[dwLines],'=')) {
			if (hrRes == S_FALSE) {
				break;
			}
			CoTaskMemFree(ppszLines[dwLines]);
			continue;
		}
		dwLines++;
	}
	if (SUCCEEDED(hrRes)) {
		DWORD dwIdx;
		LPSTR pszNameCurr = NULL;
		LPSTR pszValueCurr = NULL;

		hrRes = S_OK;
		while (1) {
			for (dwIdx=0;dwIdx<dwLines;dwIdx++) {
				LPSTR pszEquals = strchr(ppszLines[dwIdx],'=');

				if (*pppszNames) {
					(*pppszNames)[dwIdx] = pszNameCurr;
					memcpy(pszNameCurr,
						   ppszLines[dwIdx],
						   (pszEquals-ppszLines[dwIdx])*sizeof(*pszNameCurr));
					(*pppszValues)[dwIdx] = pszValueCurr;
					strcpy(pszValueCurr,pszEquals+1);
				}
				pszNameCurr += pszEquals - ppszLines[dwIdx] + 1;
				pszValueCurr += strlen(pszEquals+1) + 1 + 1;	// multi-sz, so is double-NULL terminated
			}
			if (*pppszNames) {
				*pdwCount = dwLines;
				break;
			}
			if (!*pppszNames) {
				DWORD dwNameBytes = dwLines * sizeof(*pppszNames) + ((LPBYTE) pszNameCurr - (LPBYTE) NULL);
				DWORD dwValueBytes = dwLines * sizeof(*pppszValues) + ((LPBYTE) pszValueCurr - (LPBYTE) NULL);

				*pppszNames = (LPSTR *) CoTaskMemAlloc(dwNameBytes);
				*pppszValues = (LPSTR *) CoTaskMemAlloc(dwValueBytes);
				if (!*pppszNames || !*pppszValues) {
					hrRes = E_OUTOFMEMORY;
					break;
				}
				memset(*pppszNames,0,dwNameBytes);
				memset(*pppszValues,0,dwValueBytes);
				pszNameCurr = (LPSTR) ((LPBYTE) *pppszNames + dwLines * sizeof(*pppszNames));
				pszValueCurr = (LPSTR) ((LPBYTE) *pppszValues + dwLines * sizeof(*pppszValues));
			}
		}
	}
	if (!SUCCEEDED(hrRes)) {
		*pdwCount = 0;
		CoTaskMemFree(*pppszNames);
		CoTaskMemFree(*pppszValues);
	}
	for (DWORD dwIdx=0;dwIdx<dwLines;dwIdx++) {
		CoTaskMemFree(ppszLines[dwIdx]);
	}
	CoTaskMemFree(ppszLines);
	return (hrRes);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOCreateDictionaryFromIStream(IStream *pstreamIn, ISEODictionary **ppdictResult) {
	HRESULT hrRes;
	DWORD dwCount;
	LPSTR *ppszNames;
	LPSTR *ppszValues;

	if (!ppdictResult) {
		return (E_POINTER);
	}
	hrRes = SEOCreateMultiSzFromIStreamA(pstreamIn,&dwCount,&ppszNames,&ppszValues);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOCreateDictionaryFromMultiSzA(dwCount,
											(LPCSTR *) ppszNames,
											(LPCSTR *) ppszValues,
											TRUE,
											FALSE,
											ppdictResult);
	CoTaskMemFree(ppszNames);
	CoTaskMemFree(ppszValues);
	return (hrRes);
}


static HRESULT SEOWriteMultiSzToIStreamA(DWORD dwCount, LPCSTR *ppszNames, LPCSTR *ppszValues, IStream *pstreamOut) {

	return (E_NOTIMPL);
}


SEODLLDEF HRESULT STDAPICALLTYPE SEOWriteDictionaryToIStream(ISEODictionary *pdictIn, IStream *pstreamOut) {
	HRESULT hrRes;
	DWORD dwCount;
	LPSTR *ppszNames;
	LPSTR *ppszValues;

	if (!pstreamOut) {
		return (E_POINTER);
	}
	hrRes = SEOCreateMultiSzFromDictionaryA(pdictIn,&dwCount,&ppszNames,&ppszValues);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = SEOWriteMultiSzToIStreamA(dwCount,(LPCSTR *) ppszNames,(LPCSTR *) ppszValues,pstreamOut);
	CoTaskMemFree(ppszNames);
	CoTaskMemFree(ppszValues);
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\seodefs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    seodefs.h

Abstract:

    This module contains the definitions for all of the internal
    pieces of SEO.DLL.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	10/24/96	created

--*/


#ifndef _SEODEFS_INC
#define _SEODEFS_INC


#include <limits.h>
#include "resource.h"
#include "seo.h"
#if 1
#include "dbgtrace.h"
#else
	#define TraceFunctEnter(x)
	inline void _DummyFunctTrace(int a, ...) {}
	#define FunctTrace			_DummyFunctTrace
	inline void _DummyTraceFunctLeave() {}
	#define TraceFunctLeave		_DummyTraceFunctLeave
#endif


#ifdef DEBUG
	class CDebugModule {
		public:
			void Init() {
				InitializeCriticalSection(&m_csLock);
				m_dwData = 0;
				m_pData = NULL;
			};
			void Term() {
				if (m_pData) {
					for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
						//_ASSERTE(!m_pData[dwIdx].pszObject);
					}
					delete[] m_pData;
					m_pData = NULL;
					m_dwData = 0;
				}
				DeleteCriticalSection(&m_csLock);
			};
			void AddObject(LPVOID pvObject, LPCSTR pszObject) {
				EnterCriticalSection(&m_csLock);
				for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
					if (!m_pData[dwIdx].pvObject) {
						m_pData[dwIdx].pvObject = pvObject;
						m_pData[dwIdx].pszObject = pszObject;
						LeaveCriticalSection(&m_csLock);
						return;
					}
				}
				Data *pData = new Data[m_dwData+8];
				if (!pData) {
					LeaveCriticalSection(&m_csLock);
					return;
				}
				memcpy(pData,m_pData,sizeof(*pData)*m_dwData);
				memset(&pData[m_dwData],0,sizeof(*pData)*8);
				delete[] m_pData;
				m_pData = pData;
				pData[m_dwData].pvObject = pvObject;
				pData[m_dwData].pszObject = pszObject;
				m_dwData += 8;
				LeaveCriticalSection(&m_csLock);
			};
			void RemoveObject(LPVOID pvObject) {
				EnterCriticalSection(&m_csLock);
				for (DWORD dwIdx=0;dwIdx<m_dwData;dwIdx++) {
					if (m_pData[dwIdx].pvObject == pvObject) {
						m_pData[dwIdx].pvObject = NULL;
						m_pData[dwIdx].pszObject = NULL;
						break;
					}
				}
				LeaveCriticalSection(&m_csLock);
				_ASSERTE(dwIdx!=m_dwData);
			}
		private:
			typedef struct tagData {
				LPVOID pvObject;
				LPCSTR pszObject;
			} Data;
			CRITICAL_SECTION m_csLock;
			DWORD m_dwData;
			Data *m_pData;
	};
	#ifndef MODULE_DEBUG
		#define	MODULE_DEBUG		_ModuleDebug
	#endif
	#define DEFINE_DEBUG_MODULE		extern CDebugModule MODULE_DEBUG;
	#define ALLOC_DEBUG_MODULE		CDebugModule MODULE_DEBUG;
	#define INIT_DEBUG_MODULE		MODULE_DEBUG.Init();
	#define TERM_DEBUG_MODULE		MODULE_DEBUG.Term();
	#define ADD_DEBUG_OBJECT(x)		MODULE_DEBUG.AddObject(this,x);
	#define REMOVE_DEBUG_OBJECT		MODULE_DEBUG.RemoveObject(this);
#else
	#define DEFINE_DEBUG_MODULE
	#define ALLOC_DEBUG_MODULE
	#define INIT_DEBUG_MODULE
	#define TERM_DEBUG_MODULE
	#define ADD_DEBUG_OBJECT(x)
	#define REMOVE_DEBUG_OBJECT
#endif


#ifdef DEBUG
	template<class T>
	class CDebugObject {
		public:
			CDebugObject() { m_pszName = T::DebugObjectGetInitName(); };
			~CDebugObject() { m_pszName = T::DebugObjectGetTermName(); };
			BOOL Check() { return (((m_pszName==T::DebugObjectGetInitName())||(strcmp(m_pszName,T::DebugObjectGetInitName())==0))?TRUE:FALSE); };
		private:
			LPCSTR m_pszName;
	};
	#define DEBUG_OBJECT_DEF2(_class,_string,_suffix)	\
		public:	\
			static inline LPCSTR DebugObjectGetInitName() { return (_string); };	\
			static inline LPCSTR DebugObjectGetTermName() { return (_string " *** DELETED ***" ); };	\
			CDebugObject<_class> m_DebugObject##_suffix;	\
			inline BOOL DebugObjectCheck() { return (m_DebugObject##_suffix.Check()); };
	#define DEBUG_OBJECT_DEF(x)	DEBUG_OBJECT_DEF2(x,#x,x)
	#define DEBUG_OBJECT_CHECK 	_ASSERTE(DebugObjectCheck());
#else
	#define DEBUG_OBJECT_DEF2(_class,_string,_suffix)
	#define DEBUG_OBJECT_DEF(x)
	#define DEBUG_OBJECT_CHECK
#endif


DEFINE_DEBUG_MODULE


void MyMallocTerm();
BOOL MyMallocInit();
LPVOID MyMalloc(size_t cbBytes);
LPVOID MyRealloc(LPVOID pvBlock, size_t cbBytes);
BOOL MyReallocInPlace(LPVOID pvPtrToPtrToBlock, size_t cbBytes);
void MyFree(LPVOID pvBlock);
void MyFreeInPlace(LPVOID pvPtrToPtrToBlock);
void MySysFreeStringInPlace(BSTR *pstrBlock);


// SHREAD_POINTER destroys a pointer so it can't be used again.
// Not really necissary, so only included in DEBUG builds
#ifdef DEBUG
	#define SHREAD_POINTER(ptr) ptr = 0
#else // DEBUG
	#define SHREAD_POINTER(ptr)
#endif // DEBUG

#define RELEASE_AND_SHREAD_POINTER(ptr) if(ptr) ptr->Release(); SHREAD_POINTER(ptr)

// Compare two BSTR's.  Return true if they're equal
inline BOOL EqualBSTR(BSTR a, BSTR b) {
	return (CompareStringW(LOCALE_SYSTEM_DEFAULT, 0, a, -1, b, -1) == 2);
}

// Coerce a Variant into the desired type in-place
void VariantCoerce(VARIANTARG &var, VARTYPE varType);

// Turn the IUnknown parameter into an ISEODictionary
ISEODictionary *GetDictionary(IUnknown *piUnk);

// Read a subkey from an ISEODictionary and return it as another ISEODictionary
ISEODictionary *ReadSubBag(ISEODictionary *bag, LPCSTR str);

// Read a string from the Dictionary.
HRESULT ReadString(ISEODictionary *bag, LPCOLESTR property,
                   LPSTR psBuf, LPDWORD dwCount);

// Given a CLSID as a string, create an object of that CLSID
void *CreateFromString(LPCOLESTR str, REFIID iface);


template<class T, const IID *piid, class CDV = CComDynamicUnkArray>
class ATL_NO_VTABLE CSEOConnectionPointImpl : public IConnectionPointImpl<T,piid,CDV> {
	public:
		CSEOConnectionPointImpl() {
			m_dwCount = 0; };
		virtual void AdviseCalled(IUnknown *pUnk, DWORD *pdwCookie, REFIID riid, DWORD dwCount) {
			/* nothing */ };
		virtual void UnadviseCalled(DWORD dwCookie, REFIID riid, DWORD dwCount) {
			/* nothing */ };
		DWORD GetCount() {
			return (m_dwCount); };
	public:
		HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnk, DWORD *pdwCookie) {
			HRESULT hrRes;
			T *pT = (T *) this;

			pT->Lock();
			hrRes = IConnectionPointImpl<T,piid,CDV>::Advise(pUnk,pdwCookie);
			if (SUCCEEDED(hrRes)) {
				m_dwCount++;
				AdviseCalled(pUnk,pdwCookie,*piid,m_dwCount);
			}
			pT->Unlock();
			return (hrRes);
		}
		HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie) {
			HRESULT hrRes;
			T *pT = (T *) this;

			pT->Lock();
			hrRes = IConnectionPointImpl<T,piid,CDV>::Unadvise(dwCookie);
			if (SUCCEEDED(hrRes)) {
				m_dwCount--;
				UnadviseCalled(dwCookie,*piid,m_dwCount);
			}
			pT->Unlock();
			return (hrRes);
		}
	private:
		DWORD m_dwCount;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\seolock.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolock.h

Abstract:

	This module contains the definition for the Server
	Extension Object CEventLock class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/06/97	created
	dondu	04/07/97	changed to IEventLock and CEventLock

--*/


// seolock.h : Declaration of the CEventLock

/////////////////////////////////////////////////////////////////////////////
// CSEORouter
class ATL_NO_VTABLE CEventLock : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CEventLock, &CLSID_CEventLock>,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"EventLock Class",
								   L"Event.Lock.1",
								   L"Event.Lock");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CEventLock)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockRead();
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS);
		HRESULT STDMETHODCALLTYPE UnlockWrite();

	private:
		CShareLockNH m_lock;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\seoutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    seoutil.cpp

Abstract:

    This module contains the implementation for various utility
    functions.

Author:

    Don Dumitru (dondu@microsoft.com)

Revision History:

    dondu   10/24/96    created

--*/


#include "stdafx.h"
#include "seodefs.h"


static IMalloc *g_piMalloc;


void MyMallocTerm() {

    if (g_piMalloc) {
        g_piMalloc->Release();
        g_piMalloc = NULL;
    }
}


BOOL MyMallocInit() {
    HRESULT hrRes;
    IMalloc *piMalloc;

    if (!g_piMalloc) {
        hrRes = CoGetMalloc(1,&piMalloc);
        if (SUCCEEDED(hrRes)) {
            if (InterlockedCompareExchangePointer((void**)&g_piMalloc,piMalloc,NULL) != NULL) {
                piMalloc->Release();
            }
        }
    }
    return (g_piMalloc?TRUE:FALSE);
}


LPVOID MyMalloc(size_t cbBytes) {
    LPVOID pvRes;

    if (!MyMallocInit()) {
        return (NULL);
    }
    pvRes = g_piMalloc->Alloc(cbBytes);
    if (pvRes) {
        ZeroMemory(pvRes,g_piMalloc->GetSize(pvRes));
    }
    return (pvRes);
}


LPVOID MyRealloc(LPVOID pvBlock, size_t cbBytes) {
    size_t ulPrevSize = 0;
    size_t ulNewSize = 0;
    LPVOID pvRes;

    if (!MyMallocInit()) {
        return (NULL);
    }
    if (pvBlock) {
        ulPrevSize = g_piMalloc->GetSize(pvBlock);
        if (ulPrevSize == (size_t) -1) {
            ulPrevSize = 0;
        }
    }
    pvRes = g_piMalloc->Realloc(pvBlock,cbBytes);
    if (pvRes) {
        ulNewSize = g_piMalloc->GetSize(pvRes);
        if (ulNewSize == (size_t) -1) {
            ulNewSize = 0;
        }
        if (ulNewSize > ulPrevSize) {
            ZeroMemory(((LPBYTE) pvRes)+ulPrevSize,ulNewSize-ulPrevSize);
        }
    }
    return (pvRes);
}


BOOL MyReallocInPlace(LPVOID pvPtrToPtrToBlock, size_t cbBytes) {
    LPVOID pvRes;

    pvRes = MyRealloc(*((LPVOID *) pvPtrToPtrToBlock),cbBytes);
    if (pvRes || (*((LPVOID *) pvPtrToPtrToBlock) && !cbBytes)) {
        *((LPVOID *) pvPtrToPtrToBlock) = pvRes;
        return (TRUE);
    }
    return (FALSE);
}


void MyFree(LPVOID pvBlock) {

    if (!g_piMalloc ) {
        return;
    }
    FillMemory(pvBlock,g_piMalloc->GetSize(pvBlock),0xe4);
    g_piMalloc->Free(pvBlock);
}


void MyFreeInPlace(LPVOID pvPtrToPtrToBlock) {
    if(*((LPVOID *) pvPtrToPtrToBlock)) { // If there's something to free
        MyFree(*((LPVOID *) pvPtrToPtrToBlock));
        *((LPVOID *) pvPtrToPtrToBlock) = NULL;
    }
}


void MySysFreeStringInPlace(BSTR *pstrBlock) {

    if (*pstrBlock) {
        FillMemory(*pstrBlock,SysStringByteLen(*pstrBlock),0xe4);
    }
    SysFreeString(*pstrBlock);
    *pstrBlock = NULL;
}


// Coerce a Variant into the desired type in-place
void VariantCoerce(VARIANTARG &var, VARTYPE varType) {
    if(var.vt != varType) { // Only if not already right type
        HRESULT hr = VariantChangeType(&var, &var, 0, varType);
        if(FAILED(hr)) VariantClear(&var);
    }
}


// Turn the IUnknown parameter into an ISEODictionary
ISEODictionary *GetDictionary(IUnknown *piUnk) {
    if(!piUnk) return 0; // Nothing to query

    ISEODictionary *newBag = 0;
    HRESULT hr = piUnk->QueryInterface(IID_ISEODictionary, (void **) &newBag);

    if(FAILED(hr)) {
        _ASSERT(!newBag); // QI failed, so shouldn't have touched the pointer
        newBag = 0; // But make sure
    } else {
        _ASSERT(newBag); // Should be set, since function succeeded
    }

    return newBag;
}


// Read a subkey from an ISEODictionary and return it as another ISEODictionary
ISEODictionary *ReadSubBag(ISEODictionary *bag, LPCSTR str) {
    if(!bag) return 0;

    TraceFunctEnter("ReadSubBag");
    ISEODictionary *pNewBag = 0;

    HRESULT hr = bag->GetInterfaceA(str, IID_ISEODictionary, (IUnknown **) &pNewBag);
    if(FAILED(hr)) FunctTrace(0, "No entry for %s found", str);

    TraceFunctLeave();
    return pNewBag;
}


// Read a string from the Dictionary.
HRESULT ReadString(ISEODictionary *bag, LPCSTR property,
                   LPSTR psBuf, LPDWORD dwCount) {
    if(!bag) return 0;
    TraceFunctEnter("ReadString");

    HRESULT hr = bag->GetStringA(property, dwCount, psBuf);
    if(FAILED(hr)) FunctTrace(0, "No %s specified", property);

    TraceFunctLeave();
    return hr;
}


// Given a CLSID as a string, create an object of that CLSID
void *CreateFromString(LPCOLESTR str, REFIID iface) {
    TraceFunctEnter("CreateFromString");
    void *object = 0;
    CLSID thisCLSID;

    HRESULT hr = CLSIDFromString((LPOLESTR) str, &thisCLSID);

    if(SUCCEEDED(hr)) {
        hr = CoCreateInstance(thisCLSID, 0, CLSCTX_ALL, iface, &object);

        if(FAILED(hr)) {
            FunctTrace(0, "CoCreateInstance failed for CLSID: %s", str);
            _ASSERT(!object); // CoCreateInstance shouldn't have changed this
            object = 0; // Just to make sure
        }
    } else {
        FunctTrace(0, "Could not convert string to CLSID, for: %s", str);
    }

    TraceFunctLeave();
    return object;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\router.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	router.h

Abstract:

	This module contains the definition for the Server
	Extension Object Router class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/04/97	created

--*/


// router.h : Declaration of the CSEORouter

/////////////////////////////////////////////////////////////////////////////
// CSEORouter
class ATL_NO_VTABLE CSEORouter : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEORouter, &CLSID_CSEORouter>,
	public ISEORouter,
	public IDispatchImpl<IEventLock, &IID_IEventLock, &LIBID_SEOLib>,
	public IMarshal
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEORouter Class",
								   L"SEO.SEORouter.1",
								   L"SEO.SEORouter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEORouter)
		COM_INTERFACE_ENTRY(ISEORouter)
		COM_INTERFACE_ENTRY(IEventLock)
		COM_INTERFACE_ENTRY(IMarshal)
	END_COM_MAP()

	// ISEORouter
	public:
		HRESULT STDMETHODCALLTYPE get_Database(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Database(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE put_Database(ISEODictionary *pdictDatabase) {
			return (m_pRouter->put_Database(pdictDatabase)); }
		HRESULT STDMETHODCALLTYPE get_Server(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Server(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE put_Server(ISEODictionary *pdictServer) {
			return (m_pRouter->put_Server(pdictServer)); };
		HRESULT STDMETHODCALLTYPE get_Applications(ISEODictionary **ppdictResult) {
			return (m_pRouter->get_Applications(ppdictResult)); };
		HRESULT STDMETHODCALLTYPE GetDispatcher(REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
			return (m_pRouter->GetDispatcher(iidEvent,iidDesired,ppUnkResult)); };
		HRESULT STDMETHODCALLTYPE GetDispatcherByCLSID(REFCLSID clsidDispatcher, REFIID iidEvent, REFIID iidDesired, IUnknown **ppUnkResult) {
			return (m_pRouter->GetDispatcherByCLSID(clsidDispatcher,iidEvent,iidDesired,ppUnkResult)); };

	// IEventLock
	public:
		HRESULT STDMETHODCALLTYPE LockRead(int iTimeoutMS) {
			return (m_pLock->LockRead(iTimeoutMS)); };
		HRESULT STDMETHODCALLTYPE UnlockRead() {
			return (m_pLock->UnlockRead()); };
		HRESULT STDMETHODCALLTYPE LockWrite(int iTimeoutMS) {
			return (m_pLock->LockWrite(iTimeoutMS)); };
		HRESULT STDMETHODCALLTYPE UnlockWrite() {
			return (m_pLock->UnlockWrite()); };

	// IMarshal
	public:
		HRESULT STDMETHODCALLTYPE GetUnmarshalClass(REFIID iid,
												    void *pv,
												    DWORD dwDestContext,
												    void *pvDestContext,
												    DWORD mshlflags,
												    CLSID *pCid) {
			return (m_pMarshal->GetUnmarshalClass(iid,pv,dwDestContext,pvDestContext,mshlflags,pCid)); };
		HRESULT STDMETHODCALLTYPE GetMarshalSizeMax(REFIID riid,
													void *pv,
													DWORD dwDestContext,
													void *pvDestContext,
													DWORD mshlflags,
													ULONG *pSize) {
			return (m_pMarshal->GetMarshalSizeMax(riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)); };
		HRESULT STDMETHODCALLTYPE MarshalInterface(IStream *pStm,
												   REFIID riid,
												   void *pv,
												   DWORD dwDestContext,
												   void *pvDestContext,
												   DWORD mshlflags) {
			return (m_pMarshal->MarshalInterface(pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)); };
		HRESULT STDMETHODCALLTYPE UnmarshalInterface(IStream *pStm,REFIID riid,void **ppv) {
			return (m_pMarshal->UnmarshalInterface(pStm,riid,ppv)); };
		HRESULT STDMETHODCALLTYPE ReleaseMarshalData(IStream *pStm) {
			return (m_pMarshal->ReleaseMarshalData(pStm)); };
		HRESULT STDMETHODCALLTYPE DisconnectObject(DWORD dwReserved) {
			return (m_pMarshal->DisconnectObject(dwReserved)); };

	private:
		CComPtr<ISEORouter> m_pRouter;
		CComQIPtr<IEventLock,&IID_IEventLock> m_pLock;
		CComQIPtr<IMarshal,&IID_IMarshal> m_pMarshal;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\seolock.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolock.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object CEventLock class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/06/97	created
	dondu	04/07/97	changed to IEventLock and CEventLock

--*/


// seolock.cpp : Implementation of CEventLock
#include "stdafx.h"
#include "seodefs.h"
#include "rwnew.h"
#include "seolock.h"


HRESULT CEventLock::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CEventLock::FinalConstruct");

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CEventLock::FinalRelease() {
	TraceFunctEnter("CEventLock::FinalRelease");

	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CEventLock::LockRead(int iTimeoutMS) {

	m_lock.ShareLock();
	// tbd - implement timeouts
	return (S_OK);
}


HRESULT CEventLock::UnlockRead() {

	m_lock.ShareUnlock();
	return (S_OK);
}


HRESULT CEventLock::LockWrite(int iTimeoutMS) {

	m_lock.ExclusiveLock();
	return (S_OK);
}


HRESULT CEventLock::UnlockWrite() {

	m_lock.ExclusiveUnlock();
	// tbd - implement timeouts
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CSEOComModule : public CComModule {
	public:
		const GUID *GetAPPID();
		HRESULT WriteAPPID();
		HRESULT EraseAPPID();
};
extern CSEOComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CSEOComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\stream.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object CSEOStream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29	created

--*/


// stream.cpp : Implementation of CSEOStream
#include "stdafx.h"
#include "seodefs.h"
#include "stream.h"


/////////////////////////////////////////////////////////////////////////////
// CSEOStream


HRESULT CSEOStream::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEOStream::FinalConstruct");

	m_hFile = NULL;
	m_pszFile = NULL;
	m_hEvent = NULL;
	m_pSubStream = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOStream::FinalRelease() {
	TraceFunctEnter("CSEOStream::FinalRelease");

	Cleanup();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


void CSEOStream::Cleanup() {

	if (m_hFile) {
		CloseHandle(m_hFile);
		m_hFile = NULL;
	}
	if (m_pszFile) {
		CoTaskMemFree(m_pszFile);
		m_pszFile = NULL;
	}
	if (m_hEvent) {
		CloseHandle(m_hEvent);
		m_hEvent = NULL;
	}
	if (m_pSubStream) {
		m_pSubStream->Release();
		m_pSubStream = NULL;
	}
}


HRESULT CSEOStream::Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream) {

	Cleanup();
	if (pSubStream) {
		m_pSubStream = pSubStream;
		m_pSubStream->AddRef();
	} else {
		if (hFile) {
			if (!DuplicateHandle(GetCurrentProcess(),
								 hFile,
								 GetCurrentProcess(),
								 &m_hFile,
								 0,
								 FALSE,
								 DUPLICATE_SAME_ACCESS)) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
		}
		if (pszFile) {
			DWORD dwLen;

			dwLen = GetFullPathName(pszFile,0,NULL,NULL);
			if (!dwLen) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
			m_pszFile = (LPSTR) CoTaskMemAlloc((dwLen+1)*sizeof(*m_pszFile));
			if (!m_pszFile) {
				Cleanup();
				return (E_OUTOFMEMORY);
			}
			dwLen = GetFullPathName(pszFile,dwLen+1,m_pszFile,NULL);
			if (!dwLen) {
				HRESULT hrRes = HRESULT_FROM_WIN32(GetLastError());

				Cleanup();
				return (hrRes);
			}
		}
	}
	m_libOffset = libOffset;
	return (S_OK);
}


HRESULT CSEOStream::Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream) {
	USES_CONVERSION;

	return (Init(hFile,W2A(pszFile),libOffset,pSubStream));
}


HRESULT CSEOStream::Open() {

	if ((m_hFile && m_hEvent) || m_pSubStream) {
		return (S_OK);
	}
	if (!m_hEvent) {
		m_hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
		if (!m_hEvent) {
			return (HRESULT_FROM_WIN32(GetLastError()));
		}
		if (m_hFile) {
			return (S_OK);
		}
	}
	if (!m_pszFile) {
		return (OLE_E_BLANK);
	}
	m_hFile = CreateFile(m_pszFile,
						 GENERIC_READ|GENERIC_WRITE,
						 0,
						 NULL,
						 OPEN_ALWAYS,
						 FILE_ATTRIBUTE_NORMAL,
						 NULL);
	if (m_hFile == INVALID_HANDLE_VALUE) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT CSEOStream::ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	BOOL bRes;
	DWORD cbRead;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->ReadOffset(pv,cb,pcbRead,plibOffset));
	}
	OVERLAPPED ov = {0,0,plibOffset->LowPart,plibOffset->HighPart,m_hEvent};
	bRes = ReadFile(m_hFile,pv,cb,&cbRead,&ov);
	if (!bRes) {

		switch (GetLastError()) {

			case ERROR_HANDLE_EOF:
				cbRead = 0;
				break;

			case ERROR_IO_PENDING:
				if (!GetOverlappedResult(m_hFile,&ov,&cbRead,TRUE)) {
					return (HRESULT_FROM_WIN32(GetLastError()));
				}
				break;

			default:
				return (HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	plibOffset->QuadPart += cbRead;
	if (pcbRead) {
		*pcbRead = cbRead;
	}
	return (cbRead?S_OK:S_FALSE);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Read(void *pv, ULONG cb, ULONG *pcbRead) {

	return (ReadOffset(pv,cb,pcbRead,&m_libOffset));
}


HRESULT CSEOStream::WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	BOOL bRes;
	DWORD cbWritten;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->WriteOffset(pv,cb,pcbWritten,plibOffset));
	}
	OVERLAPPED ov = {0,0,plibOffset->LowPart,plibOffset->HighPart,m_hEvent};
	bRes = WriteFile(m_hFile,pv,cb,&cbWritten,&ov);
	if (!bRes) {

		switch (GetLastError()) {

			case ERROR_HANDLE_EOF:
				cbWritten = 0;
				break;

			case ERROR_IO_PENDING:
				if (!GetOverlappedResult(m_hFile,&ov,&cbWritten,TRUE)) {
					return (HRESULT_FROM_WIN32(GetLastError()));
				}
				break;

			default:
				return (HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	plibOffset->QuadPart += cbWritten;
	if (pcbWritten) {
		*pcbWritten = cbWritten;
	}
	return ((cbWritten==cb)?S_OK:STG_E_MEDIUMFULL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Write(void const* pv, ULONG cb, ULONG *pcbWritten) {

	return (WriteOffset(pv,cb,pcbWritten,&m_libOffset));
}


HRESULT CSEOStream::GetSize(ULARGE_INTEGER *plibSize) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->GetSize(plibSize));
	}
	if (!plibSize) {
		return (E_POINTER);
	}
	plibSize->LowPart = GetFileSize(m_hFile,&plibSize->HighPart);
	if ((plibSize->LowPart == 0xffffffff) && (GetLastError() != NO_ERROR)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	hrRes = S_OK;
	switch (dwOrigin) {

		case STREAM_SEEK_SET:
			if (dlibMove.QuadPart < 0) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) dlibMove.QuadPart;
			break;

		case STREAM_SEEK_CUR:
			if ((dlibMove.QuadPart < 0) && ((DWORDLONG) -dlibMove.QuadPart > m_libOffset.QuadPart)) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) ((LONGLONG) m_libOffset.QuadPart + dlibMove.QuadPart);
			break;

		case STREAM_SEEK_END:
			ULARGE_INTEGER libSize;

			hrRes = GetSize(&libSize);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			if ((dlibMove.QuadPart < 0) && ((DWORDLONG) -dlibMove.QuadPart > libSize.QuadPart)) {
				hrRes = E_INVALIDARG;
				break;
			}
			m_libOffset.QuadPart = (DWORDLONG) ((LONGLONG) libSize.QuadPart + dlibMove.QuadPart);
			break;

		default:
			hrRes = STG_E_INVALIDFUNCTION;
			break;
	}
	if (pdlibNewPosition) {
		*pdlibNewPosition = m_libOffset;
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOStream::SetSize(ULARGE_INTEGER libNewSize) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	if (m_pSubStream) {
		return (m_pSubStream->SetSize(libNewSize));
	}
	if ((SetFilePointer(m_hFile,libNewSize.LowPart,(LONG *) &libNewSize.HighPart,FILE_BEGIN) == 0xffff) &&
		(GetLastError() != NO_ERROR)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	if (!SetEndOfFile(m_hFile)) {
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	return (S_OK);
}


HRESULT CSEOStream::CopyToOffset(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *plibOffset) {
	HRESULT hrRes;
	LPVOID pv;
	ULARGE_INTEGER cbRead;
	ULARGE_INTEGER cbWritten;

	if (!pstm) {
		return (E_POINTER);
	}
	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	pv = alloca((DWORD) min(cb.QuadPart,4096));
	if (!pv) {
		return (E_OUTOFMEMORY);
	}
	cbRead.QuadPart = 0;
	cbWritten.QuadPart = 0;
	while (1) {
		DWORD cbTmpRead;
		DWORD cbTmpWrite;

		if (!cb.QuadPart) {
			hrRes = S_OK;
			break;
		}
		cbTmpRead = 0;
		hrRes = ReadOffset(pv,(DWORD) min(cb.QuadPart,4096),&cbTmpRead,plibOffset);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (cbTmpRead == 0) {
			hrRes = S_FALSE;
			break;
		}
		cbRead.QuadPart += cbTmpRead;
		cbTmpWrite = 0;
		hrRes = pstm->Write(pv,cbTmpRead,&cbTmpWrite);
		if (!SUCCEEDED(hrRes)) {
			if (hrRes == STG_E_MEDIUMFULL) {
				cbWritten.QuadPart += cbTmpWrite;
			}
			break;
		}
		cbWritten.QuadPart += cbTmpWrite;
		cb.QuadPart -= cbTmpRead;
	}
	if (pcbRead) {
		*pcbRead = cbRead;
	}
	if (pcbWritten) {
		*pcbWritten = cbWritten;
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten) {

	return (CopyToOffset(pstm,cb,pcbRead,pcbWritten,&m_libOffset));
}


HRESULT STDMETHODCALLTYPE CSEOStream::Commit(DWORD grfCommitFlags) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Revert(void) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Stat(STATSTG * pstatstg, DWORD grfStatFlag) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT CSEOStream::CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset) {
	HRESULT hrRes;

	if (!SUCCEEDED(hrRes=Open())) {
		return (hrRes);
	}
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOStream::Clone(IStream **pstm) {

	return (CloneOffset(pstm,m_libOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CSEOComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.
	LPOLESTR pszAPPID = NULL;	// The APPID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID and APPID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
			if (!*pparmeResult) {
				// If this is the first time through, see if an APPID is provided by the
				// module.
				const GUID *pappid = pmodule->GetAPPID();

				if (pappid) {
					// If there is an APPID, convert it to a string.
					HRESULT hrRes;

					hrRes = StringFromCLSID(*pappid,&pszAPPID);
					if (!SUCCEEDED(hrRes)) {
						// We failed to convert the APPID to a string.
						CoTaskMemFree(pszCLSID);
						return (hrRes);
					}
				}
			}
			if (pszAPPID) {
				// If the module provides an APPID, we need to add it to the map.
				if (*pparmeResult) {
					// If this isn't the first time through, then we already have the APPID as a string,
					// so we just need to put it in the map.
					(*pparmeResult)[dwCnt].szKey = L"APPID";
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszAPPID);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the APPID string and the fact that we have a APPID in the map.
				pbAdd += (wcslen(pszAPPID)+1) * sizeof(OLECHAR);
				dwCnt++;
				if (*pparmeResult) {
					// If this is not the first time through, make sure we clean up after ourselves.
					CoTaskMemFree(pszAPPID);
					pszAPPID = NULL;
				}
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (DWORD)(pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				CoTaskMemFree(pszAPPID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\dll\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\subdict.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	subdict.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Sub-Dictionary class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/09/97	created

--*/


// subdict.cpp : Implementation of CSEOSubDictionary
#include "stdafx.h"
#include "seodefs.h"
#include "subdict.h"


#define SSA(x)	((x)?(x):"")
#define SSW(x)	((x)?(x):L"")


#define _ALLOC_NAME_A(prefix,suffix)	(LPSTR) _alloca((strlen((prefix))+strlen((suffix))+1)*sizeof(CHAR))
inline LPSTR CopyNameA(LPSTR pszDest, LPCSTR pszPrefix, LPCSTR pszSuffix) {

	strcpy(pszDest,pszPrefix);
	strcat(pszDest,pszSuffix);
	return (pszDest);
}
#define ALLOC_NAME_A(prefix,suffix)	CopyNameA(_ALLOC_NAME_A(SSA(prefix),SSA(suffix)),SSA(prefix),SSA(suffix))

#define _ALLOC_NAME_W(prefix,suffix)	(LPWSTR) _alloca((wcslen((prefix))+wcslen((suffix))+1)*sizeof(WCHAR))
inline LPWSTR CopyNameW(LPWSTR pszDest, LPCWSTR pszPrefix, LPCWSTR pszSuffix) {

	wcscpy(pszDest,pszPrefix);
	wcscat(pszDest,pszSuffix);
	return (pszDest);
}
#define ALLOC_NAME_W(prefix,suffix)	CopyNameW(_ALLOC_NAME_W(SSW(prefix),SSW(suffix)),SSW(prefix),SSW(suffix))

#ifdef UNICODE
	#define ALLOC_NAME_T	ALLOC_NAME_W
#else
	#define ALLOC_NAME_T	ALLOC_NAME_A
#endif
#define ALLOC_NAME_OLE	ALLOC_NAME_W


HRESULT MakeNameAsVariant(VARIANT *pvarResult, VARIANT *pvarName, LPWSTR pszPrefix) {
	HRESULT hrRes;
	BSTR bstrTmp;

	VariantInit(pvarResult);
	if (pvarName && (pvarName->vt != VT_ERROR)) {
		hrRes = VariantChangeType(pvarResult,pvarName,0,VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
	} else {
		pvarResult->bstrVal = SysAllocString(L"");
		if (!pvarResult->bstrVal) {
			return (E_OUTOFMEMORY);
		}
	}
	bstrTmp = SysAllocStringLen(pvarResult->bstrVal,
								wcslen(pvarResult->bstrVal)+wcslen(pszPrefix?pszPrefix:L"")+1);
	if (!bstrTmp) {
		VariantClear(pvarResult);
		return (E_OUTOFMEMORY);
	}
	wcscat(bstrTmp,pszPrefix);
	SysFreeString(pvarResult->bstrVal);
	pvarResult->bstrVal = bstrTmp;
	return (S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSEOSubDictionary


HRESULT CSEOSubDictionary::FinalConstruct() {
	HRESULT hrRes;
	TraceFunctEnter("CSEOSubDictionary::FinalConstruct");

	m_pszPrefixA = NULL;
	m_pszPrefixW = NULL;
	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	TraceFunctLeave();
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOSubDictionary::FinalRelease() {
	TraceFunctEnter("CSEOSubDictionary::FinalRelease");

	m_pdictBase.Release();
	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CSEOSubDictionary::SetBaseA(ISEODictionary *pdictBase, LPCSTR pszPrefix) {

	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pdictBase.Release();
	if (pszPrefix) {
		DWORD dwLen = strlen(pszPrefix);

		m_pszPrefixA = (LPSTR) CoTaskMemAlloc((dwLen+1)*sizeof(CHAR));
		if (!m_pszPrefixA) {
			return (E_OUTOFMEMORY);
		}
		m_pszPrefixW = (LPWSTR) CoTaskMemAlloc((dwLen+2)*sizeof(WCHAR));
		if (!m_pszPrefixW) {
			CoTaskMemFree(m_pszPrefixA);
			m_pszPrefixA = NULL;
			return (E_OUTOFMEMORY);
		}
		strcpy(m_pszPrefixA,pszPrefix);
		MultiByteToWideChar(CP_ACP,0,pszPrefix,-1,m_pszPrefixW,dwLen+1);
		m_pdictBase = pdictBase;
	}
	return (S_OK);
}


HRESULT CSEOSubDictionary::SetBaseW(ISEODictionary *pdictBase, LPCWSTR pszPrefix) {

	if (m_pszPrefixA) {
		CoTaskMemFree(m_pszPrefixA);
		m_pszPrefixA = NULL;
	}
	if (m_pszPrefixW) {
		CoTaskMemFree(m_pszPrefixW);
		m_pszPrefixW = NULL;
	}
	m_pdictBase.Release();
	if (pszPrefix) {
		DWORD dwLen = wcslen(pszPrefix);

		m_pszPrefixA = (LPSTR) CoTaskMemAlloc((dwLen+2)*sizeof(CHAR));
		if (!m_pszPrefixA) {
			return (E_OUTOFMEMORY);
		}
		m_pszPrefixW = (LPWSTR) CoTaskMemAlloc((dwLen+1)*sizeof(WCHAR));
		if (!m_pszPrefixW) {
			CoTaskMemFree(m_pszPrefixA);
			m_pszPrefixA = NULL;
			return (E_OUTOFMEMORY);
		}
		WideCharToMultiByte(CP_ACP,0,pszPrefix,-1,m_pszPrefixA,dwLen+1,NULL,NULL);
		wcscpy(m_pszPrefixW,pszPrefix);
		m_pdictBase = pdictBase;
	}
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::get_Item(VARIANT *pvarName, VARIANT *pvarResult) {
	VARIANT varTmp;
	HRESULT hrRes;

	if (!pvarResult) {
		return (E_POINTER);
	}
	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	hrRes = MakeNameAsVariant(&varTmp,pvarName,m_pszPrefixW);
	if (!SUCCEEDED(hrRes)) {
		VariantInit(pvarResult);
		return (hrRes);
	}
	hrRes = m_pdictBase->get_Item(&varTmp,pvarResult);
	VariantClear(&varTmp);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::put_Item(VARIANT *pvarName, VARIANT *pvarValue) {
	VARIANT varTmp;
	HRESULT hrRes;

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	hrRes = MakeNameAsVariant(&varTmp,pvarName,m_pszPrefixW);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = m_pdictBase->put_Item(&varTmp,pvarValue);
	VariantClear(&varTmp);
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::get__NewEnum(IUnknown **ppunkResult) {

	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetVariantA(LPCSTR pszName, VARIANT *pvarResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetVariantA(pszTmp,pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetVariantW(LPCWSTR pszName, VARIANT *pvarResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetVariantW(pszTmp,pvarResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetVariantA(LPCSTR pszName, VARIANT *pvarValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetVariantA(pszTmp,pvarValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetVariantW(LPCWSTR pszName, VARIANT *pvarValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetVariantW(pszTmp,pvarValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetStringA(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetStringA(pszTmp,pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetStringW(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetStringW(pszTmp,pchCount,pszResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetStringA(LPCSTR pszName, DWORD chCount, LPCSTR pszValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetStringA(pszTmp,chCount,pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetStringW(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetStringW(pszTmp,chCount,pszValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetDWordA(LPCSTR pszName, DWORD *pdwResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetDWordA(pszTmp,pdwResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetDWordW(LPCWSTR pszName, DWORD *pdwResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetDWordW(pszTmp,pdwResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetDWordA(LPCSTR pszName, DWORD dwValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetDWordA(pszTmp,dwValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetDWordW(LPCWSTR pszName, DWORD dwValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetDWordW(pszTmp,dwValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetInterfaceA(LPCSTR pszName, REFIID iidDesired, IUnknown **ppunkResult) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetInterfaceA(pszTmp,iidDesired,ppunkResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::GetInterfaceW(LPCWSTR pszName, REFIID iidDesired, IUnknown **ppunkResult) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (SEO_E_NOTPRESENT);
	}
	return (m_pdictBase->GetInterfaceW(pszTmp,iidDesired,ppunkResult));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetInterfaceA(LPCSTR pszName, IUnknown *punkValue) {
	LPSTR pszTmp = ALLOC_NAME_A(m_pszPrefixA,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetInterfaceA(pszTmp,punkValue));
}


HRESULT STDMETHODCALLTYPE CSEOSubDictionary::SetInterfaceW(LPCWSTR pszName, IUnknown *punkValue) {
	LPWSTR pszTmp = ALLOC_NAME_W(m_pszPrefixW,pszName);

	if (!m_pdictBase) {
		return (E_OUTOFMEMORY);
	}
	return (m_pdictBase->SetInterfaceW(pszTmp,punkValue));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\subdict.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	subdict.h

Abstract:

	This module contains the definition for the Server
	Extension Object Sub-Dictionary class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/09/97	created

--*/


// item.h : Declaration of the CSEOSubDictionary

/////////////////////////////////////////////////////////////////////////////
// CSEOSubDictionary
class ATL_NO_VTABLE CSEOSubDictionary : 
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
//	public CComCoClass<CSEOSubDictionary, &CLSID_CSEOSubDictionary>,
	public IDispatchImpl<ISEODictionary, &IID_ISEODictionary, &LIBID_SEOLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

//	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//								   L"SEOSubDictionary Class",
//								   L"SEO.SEOSubDictionary.1",
//								   L"SEO.SEOSubDictionary");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOSubDictionary)
		COM_INTERFACE_ENTRY(ISEODictionary)
		COM_INTERFACE_ENTRY(IDispatch)
//		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEODictionary
	public:
		HRESULT STDMETHODCALLTYPE get_Item(VARIANT *pvarName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE put_Item(VARIANT *pvarName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE get__NewEnum(IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE GetVariantA(LPCSTR pszName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE GetVariantW(LPCWSTR pszName, VARIANT *pvarResult);
		HRESULT STDMETHODCALLTYPE SetVariantA(LPCSTR pszName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE SetVariantW(LPCWSTR pszName, VARIANT *pvarValue);
		HRESULT STDMETHODCALLTYPE GetStringA(LPCSTR pszName, DWORD *pchCount, LPSTR pszResult);
		HRESULT STDMETHODCALLTYPE GetStringW(LPCWSTR pszName, DWORD *pchCount, LPWSTR pszResult);
		HRESULT STDMETHODCALLTYPE SetStringA(LPCSTR pszName, DWORD chCount, LPCSTR pszValue);
		HRESULT STDMETHODCALLTYPE SetStringW(LPCWSTR pszName, DWORD chCount, LPCWSTR pszValue);
		HRESULT STDMETHODCALLTYPE GetDWordA(LPCSTR pszName, DWORD *pdwResult);
		HRESULT STDMETHODCALLTYPE GetDWordW(LPCWSTR pszName, DWORD *pdwResult);
		HRESULT STDMETHODCALLTYPE SetDWordA(LPCSTR pszName, DWORD dwValue);
		HRESULT STDMETHODCALLTYPE SetDWordW(LPCWSTR pszName, DWORD dwValue);
		HRESULT STDMETHODCALLTYPE GetInterfaceA(LPCSTR pszName, REFIID iidDesired, IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE GetInterfaceW(LPCWSTR pszName, REFIID iidDesired, IUnknown **ppunkResult);
		HRESULT STDMETHODCALLTYPE SetInterfaceA(LPCSTR pszName, IUnknown *punkValue);
		HRESULT STDMETHODCALLTYPE SetInterfaceW(LPCWSTR pszName, IUnknown *punkValue);

	// CSEOSubDictionary
	public:
		HRESULT SetBaseA(ISEODictionary *pdictBase, LPCSTR pszPrefix);
		HRESULT SetBaseW(ISEODictionary *pdictBase, LPCWSTR pszPrefix);

	private:
		CComPtr<ISEODictionary> m_pdictBase;
		LPSTR m_pszPrefixA;
		LPWSTR m_pszPrefixW;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\stream.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.h

Abstract:

	This module contains the definition for the Server
	Extension Object Stream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29/97	created

--*/


// stream.h : Declaration of the CSEOStream

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE CSEOStream : 
	public IStream,
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CSEOStream, &CLSID_CSEOStream>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		void Cleanup();
		HRESULT Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Open();
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOStream Class",
								   L"SEO.Stream.1",
								   L"SEO.Stream");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOStream)
		COM_INTERFACE_ENTRY(IStream)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		HANDLE m_hFile;
		LPSTR m_pszFile;
		ULARGE_INTEGER m_libOffset;
		HANDLE m_hEvent;
		CSEOStream *m_pSubStream;
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\idl\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\elem.h ===
#ifndef _ELEM_H_
#define _ELEM_H_

class CElem : public CObject
{
public:
    CElem();
    ~CElem();

    HKEY m_hKey;
    int m_index;
    CString m_ip;
    CString m_name;
    CString m_value;

    BOOL OpenReg(LPCTSTR szSubKey);
    void CloseReg();
    BOOL GetNext();
    void ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap);
    void Add(CMapStringToOb *pMap);
};

#endif // _ELEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\lib\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(MIDL_TLBDIR)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\lib\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\const.h ===
#ifndef CONST_H
#define CONST_H

//
// this is the max resource string length
//
#define MAX_STR_LEN 1024

//
// A whole load of defines
//

#define REG_ACTIVEMSG				_T("Software\\Microsoft\\Exchange\\Active Messaging")

#define REG_SERVICES				_T("System\\CurrentControlSet\\Services")

#define REG_EXCHANGEIMCPARAMETERS	_T("System\\CurrentControlSet\\Services\\MsExchangeIMC\\Parameters")
#define REG_DSASVC					_T("System\\CurrentControlSet\\Services\\DSASVC")		// Used only to point out upgrade path for Exchange
#define REG_ROUTING_SOURCES_SUFFIX	_T("\\Parameters\\RoutingSources");

#define REG_UNINSTALL				_T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REG_KEYRING					_T("Software\\Microsoft\\Keyring\\Parameters\\AddOnServices")
#define REG_EVENTLOG				_T("System\\CurrentControlSet\\Services\\EventLog\\System")
#define SZ_SVC_DEPEND				_T("IISADMIN\0Eventlog\0\0")
#define REG_B3_SETUP_STRING			_T("K2 Beta 3")
#define REG_SETUP_STRING			_T("K2 RTM")
#define REG_SETUP_STRING_MCIS_GEN	_T("MCIS 2.0")
#define REG_SETUP_STRING_STAXNT5WB2	_T("STAXNT5 WKS")
#define REG_SETUP_STRING_STAXNT5SB2	_T("STAXNT5 SRV")
#define REG_SETUP_STRING_NT5WKSB3	_T("STAXNT5 WKS Beta 3")
#define REG_SETUP_STRING_NT5SRVB3   _T("STAXNT5 SRV Beta 3")
#define REG_SETUP_STRING_NT5WKS		_T("STAX Win2000 WKS")
#define REG_SETUP_STRING_NT5SRV		_T("STAX Win2000 SRV")

// BINLIN: MCIS 1.0 name under control panel add/remove
#define SZ_MCIS10_NEWS_UNINST		_T("MCIS News Server")
#define SZ_MCIS10_MAIL_UNINST		_T("MCIS Mail Server")

#define SZ_SMTPSERVICENAME			_T("SMTPSVC")
#define SZ_NTFSDRVSERVICENAME			_T("NTFSDRV")
#define REG_SMTPPARAMETERS			_T("System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters")    
#define REG_SMTPPERFORMANCE			_T("System\\CurrentControlSet\\Services\\SMTPSVC\\Performance")
#define REG_NTFSPERFORMANCE			_T("System\\CurrentControlSet\\Services\\NTFSDRV\\Performance")
#define MDID_SMTP_ROUTING_SOURCES		8046

#define SZ_SMTP_QUEUEDIR			_T("\\Queue")
#define SZ_SMTP_PICKUPDIR			_T("\\Pickup")
#define SZ_SMTP_DROPDIR				_T("\\Drop")
#define SZ_SMTP_BADMAILDIR			_T("\\Badmail")
#define SZ_SMTP_MAILBOXDIR			_T("\\Mailbox")
#define SZ_SMTP_SORTTEMPDIR			_T("\\SortTemp")
#define SZ_SMTP_ROUTINGDIR			_T("\\Route")

#define SZ_NNTPSERVICENAME			_T("NNTPSVC")
#define REG_NNTPPARAMETERS			_T("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters")    
#define REG_NNTPPERFORMANCE			_T("System\\CurrentControlSet\\Services\\NntpSvc\\Performance")
#define REG_NNTPVROOTS				_T("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters\\Virtual Roots")    

#define REG_CIPARAMETERS			_T("System\\CurrentControlSet\\Control\\ContentIndex")

#define REG_INETINFOPARAMETERS		_T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters")
#define SZ_INETINFODISPATCH			_T("DispatchEntries")

#define SZ_MD_SERVICENAME			_T("IISADMIN")

#define REG_PRODUCT					_T("System\\CurrentControlSet\\Control\\ProductOptions")
#define REG_PRODUCTTYPE				_T("ProductType")

#define REG_SNMPPARAMETERS			_T("System\\CurrentControlSet\\Services\\SNMP\\Parameters" )
#define REG_SNMPEXTAGENT			_T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents" )
#define REG_SOFTWAREMSFT			_T("Software\\Microsoft")
#define REG_CURVERSION				_T("CurrentVersion")
#define MAJORVERSION				4
#define MINORVERSION				0

#define STACKSMAJORVERSION			2
#define STACKSMINORVERSION			0
#define STAXNT5MAJORVERSION			3
#define STAXNT5MINORVERSION			0


//
// Enumerated types
//
typedef enum _OS
{
	OS_NT, 
	OS_W95, 
	OS_OTHERS
	
} OS;

typedef enum _NT_OS_TYPE 
{
	OT_NT_UNKNOWN,
    OT_NTS, 
	OT_PDC_OR_BDC,
    OT_NTW, 
    OT_PDC, 
	OT_BDC, 
	OT_SAM,
	
} NT_OS_TYPE;

typedef enum _UPGRADE_TYPE 
{
	UT_NONE, 
	UT_20, 
	UT_30
	
} UPGRADE_TYPE;
        
typedef enum _INSTALL_MODE 
{
	IM_FRESH,
	IM_UPGRADE,
	IM_MAINTENANCE, 
	IM_DEGRADE,
	IM_UPGRADEK2,   // Upgrade from K2 RTM to NT5
	IM_UPGRADEB2,   // Upgrade from NT5 Beta2
	IM_UPGRADEB3,   // Upgrade from NT5 Beta3
    IM_UPGRADEWKS,  // Upgrade from NT5 Workstation to NT5 Server
    IM_UPGRADE10,   // Upgrade from MCIS 1.0 to NT5
    IM_UPGRADE20,   // Upgrade from MCIS 2.0 to NT5
	
} INSTALL_MODE;

typedef enum _ACTION_TYPE 
{
	AT_DO_NOTHING, 
	AT_FRESH_INSTALL, 
	AT_REINSTALL,
	AT_UPGRADE, 
	AT_REMOVE,
	AT_UPGRADEK2,
    AT_MAXAT

} ACTION_TYPE;

typedef enum _STATUS_TYPE 
{
	ST_UNKNOWN, 
	ST_INSTALLED, 
	ST_UNINSTALLED
	
} STATUS_TYPE;

typedef enum _MAIN_COMPONENT 
{
	MC_IMS, 
	MC_INS, 
	MC_NONE,
	MC_MAXMC
	
} MAIN_COMPONENT;

typedef enum _SUBCOMPONENT 
{
	SC_SMTP, 
	SC_NNTP,
    SC_SMTP_DOCS,
    SC_NNTP_DOCS, 
	SC_NONE,
	SC_MAXSC
	
} SUBCOMPONENT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\lib\seolib.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolib.cpp

Abstract:

	This module contains the implementations for various
	utility classes and functions of the Server	Extension
	Object system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	05/20/97	Created.

--*/


#include "stdafx.h"
#include "seo.h"
#include "seolib.h"


CEventBaseDispatcher::CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::~CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::CBinding::CBinding() {

	m_bIsValid = FALSE;
}


CEventBaseDispatcher::CBinding::~CBinding() {

	// nothing
}


HRESULT CEventBaseDispatcher::CBinding::Init(IEventBinding *piBinding) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProps;
	CComVariant varValue;

	if (!piBinding) {
		return (E_POINTER);
	}
	varValue.vt = VT_BOOL;
	hrRes = piBinding->get_Enabled(&varValue.boolVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_bIsValid = varValue.boolVal ? TRUE: FALSE;
	varValue.Clear();
	m_dwPriority = (DWORD) PRIO_DEFAULT;
	m_bExclusive = FALSE;
	m_piBinding = piBinding;
	hrRes = piBinding->get_SourceProperties(&pProps);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProps->Item(&CComVariant(L"Priority"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			if (varValue.lVal < PRIO_MIN) {
				varValue.lVal = PRIO_MIN;
			} else if (varValue.lVal > PRIO_MAX) {
				varValue.lVal = PRIO_MAX;
			}
			m_dwPriority = (DWORD) varValue.lVal;
		} else {
			hrRes = varValue.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				static struct {
					LPCWSTR pszString;
					DWORD dwValue;
				} sConvert[] = {{PRIO_HIGHEST_STR,PRIO_HIGHEST},
								{PRIO_HIGH_STR,PRIO_HIGH},
								{PRIO_MEDIUM_STR,PRIO_MEDIUM},
								{PRIO_LOW_STR,PRIO_LOW},
								{PRIO_LOWEST_STR,PRIO_LOWEST},
								{PRIO_DEFAULT_STR,PRIO_DEFAULT},
								{NULL,0}};
				for (DWORD dwIdx=0;sConvert[dwIdx].pszString;dwIdx++) {
					if (_wcsicmp(varValue.bstrVal,sConvert[dwIdx].pszString) == 0) {
						m_dwPriority = sConvert[dwIdx].dwValue;
						break;
					}
				}
			}
		}
	}
	varValue.Clear();
	hrRes = pProps->Item(&CComVariant(L"Exclusive"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			m_bExclusive = (varValue.boolVal ? TRUE : FALSE);
		}
	}
	hrRes = InitRuleEngine();
	// ignore result
	return (S_OK);
}


int CEventBaseDispatcher::CBinding::Compare(const CBinding& b) const {
    return (m_dwPriority - b.m_dwPriority);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine(IEventBinding *piBinding, REFIID iidDesired, IUnknown **ppUnkRuleEngine) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProperties;
	CComVariant varValue;
	CStringGUID objGuid;

	if (ppUnkRuleEngine) {
		*ppUnkRuleEngine = NULL;
	}
	if (!piBinding || !ppUnkRuleEngine) {
		return (E_POINTER);
	}
	hrRes = piBinding->get_SourceProperties(&pProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProperties->Item(&CComVariant(L"RuleEngine"),&varValue);
	if (!SUCCEEDED(hrRes) || (hrRes == S_FALSE)) {
		return (hrRes);
	}
	hrRes = SEOCreateObject(&varValue,piBinding,pProperties,iidDesired,ppUnkRuleEngine);
	return (SUCCEEDED(hrRes)?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine() {

	// default is to not to try to load a rule engine
	return (S_OK);
}


int CEventBaseDispatcher::CBindingList::Compare(CBinding* p1, CBinding* p2) {

	return (p1->Compare(*p2));
};


HRESULT CEventBaseDispatcher::CParams::CheckRule(CBinding& b) {

	// default behavior is to not pay attention to any "rules"
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::CallObject(IEventManager *piManager, CBinding& bBinding) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkSink;

	if (!piManager) {
		return (E_POINTER);
	}
	hrRes = piManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CallObject(bBinding,pUnkSink));
}


HRESULT CEventBaseDispatcher::CParams::CallObject(CBinding& bBinding, IUnknown *pUnkSink) {
	HRESULT hrRes;
	CComQIPtr<IEventSinkNotify,&IID_IEventSinkNotify> pSink;
	CComQIPtr<IDispatch,&IID_IEventSinkNotifyDisp> pSinkDisp;
	DISPPARAMS dpNoArgs = {NULL,NULL,0,0};

	// Default behavior is to call IEventSinkNotify::OnEvent, or to call
	// IEventSinkNotifyDisp::Invoke passing DISPID_VALUE (which maps to OnEvent).
	//
	// This means that the base dispatcher is able to invoke simple COM objects.  If you
	// provide your own CallObject() routine, your routine call delegate this this base
	// implementation if you want to "inherit" this functionality.
	if (!pUnkSink) {
		return (E_POINTER);
	}
	pSink = pUnkSink;
	if (!pSink) {
		pSinkDisp = pUnkSink;
	}
	if (!pSink && !pSinkDisp) {
		return (E_NOINTERFACE);
	}
	if (pSink) {
		hrRes = pSink->OnEvent();
		return (S_OK);
	}
	hrRes = pSinkDisp->Invoke(DISPID_VALUE,
							  IID_NULL,
							  GetUserDefaultLCID(),
							  DISPATCH_METHOD,
							  &dpNoArgs,
							  NULL,
							  NULL,
							  NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::Abort() {

	return (S_FALSE);
}


HRESULT CEventBaseDispatcher::Dispatcher(REFGUID rguidEventType, CParams *pParams) {
	HRESULT hrRes;
	CETData *petdData;
	BOOL bObjectCalled = FALSE;

	petdData = m_Data.Find(rguidEventType);
	if (!petdData) {
		return (S_FALSE);
	}
	for (DWORD dwIdx=0;dwIdx<petdData->Count();dwIdx++) {
		if (!petdData->Index(dwIdx)->m_bIsValid) {
			continue;
		}
		if (bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
			continue;
		}
		if (pParams->Abort() == S_OK) {
			break;
		}
		hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
		if (hrRes == S_OK) {
			if (pParams->Abort() == S_OK) {
				break;
			}
			hrRes = pParams->CallObject(m_piEventManager,*petdData->Index(dwIdx));
			if (!SUCCEEDED(hrRes)) {
				continue;
			}
			bObjectCalled = TRUE;
			if ((hrRes == S_FALSE) || petdData->Index(dwIdx)->m_bExclusive) {
				break;
			}
		}
	}
	return (bObjectCalled?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::SetContext(REFGUID rguidEventType, IEventRouter *piRouter, IEventBindings *piBindings) {
	CETData* petData;
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;

	if (!piRouter || !piBindings) {
		return (E_POINTER);
	}
	if (!m_piEventManager) {
		hrRes = CoCreateInstance(CLSID_CEventManager,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventManager,
								 (LPVOID *) &m_piEventManager);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		m_piRouter = piRouter;
	}
	petData = m_Data.Find(rguidEventType);
	if (!petData) {
		hrRes = AllocETData(rguidEventType,piBindings,&petData);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		petData->m_guidEventType = rguidEventType;
		hrRes = m_Data.Add(petData);
		if (!SUCCEEDED(hrRes)) {
			delete petData;
			return (hrRes);
		}
	}
	petData->RemoveAll();
	hrRes = piBindings->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pEnum = pUnkEnum;
	if (!pEnum) {
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varValue;
		CComQIPtr<IEventBinding,&IID_IEventBinding> pBinding;
		CBinding *pNewBinding;

		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			continue;
		}
		pBinding = varValue.punkVal;
		if (!pBinding) {
			_ASSERTE(FALSE);
			continue;
		}
		hrRes = AllocBinding(rguidEventType,pBinding,&pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pNewBinding->Init(pBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = petData->Add(pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			delete pNewBinding;
			return (hrRes);
		}
	}
	return (S_OK);
}


CEventBaseDispatcher::CETData::CETData() {

	// nothing
}


CEventBaseDispatcher::CETData::~CETData() {

	// nothing
}


CEventBaseDispatcher::CETData* CEventBaseDispatcher::CETDataList::Find(REFGUID guidEventType) {

	// tbd - optimize
	for (DWORD dwIdx=0;dwIdx<Count();dwIdx++) {
		if (Index(dwIdx)->m_guidEventType == guidEventType) {
			return (Index(dwIdx));
		}
	}
	return (NULL);
}


HRESULT CEventBaseDispatcher::AllocBinding(REFGUID rguidEventType,
										   IEventBinding *piBinding,
										   CBinding **ppNewBinding) {

	if (ppNewBinding) {
		*ppNewBinding = NULL;
	}
	if (!piBinding || !ppNewBinding) {
		return (E_POINTER);
	}
	*ppNewBinding = new CBinding;
	if (!*ppNewBinding) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::AllocETData(REFGUID guidEventType,
										  IEventBindings *piBindings,
										  CETData **ppNewETData) {

	if (ppNewETData) {
		*ppNewETData = NULL;
	}
	if (!piBindings || !ppNewETData) {
		return (E_POINTER);
	}
	*ppNewETData = new CETData;
	if (!*ppNewETData) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


static HRESULT SEOGetSources(REFGUID rguidSourceType, IEventSources **ppSources) {
	HRESULT hrRes;
	CComPtr<IEventManager> pManager;
	CComPtr<IEventSourceTypes> pSourceTypes;
	CComPtr<IEventSourceType> pSourceType;
	CComPtr<IEventSources> pSources;

	if (ppSources) {
		*ppSources = NULL;
	}
	if (!ppSources) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventManager,NULL,CLSCTX_ALL,IID_IEventManager,(LPVOID *) &pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pManager->get_SourceTypes(&pSourceTypes);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pSourceTypes->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSourceType)),&pSourceType);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSourceType) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSourceType->get_Sources(ppSources);
error:
	return (hrRes);
}


static HRESULT SEOGetSourcesEnum(REFGUID rguidSourceType, IEnumVARIANT **ppEnum) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;
	CComPtr<IUnknown> pUnkEnum;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pUnkEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppEnum);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSource, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSource)),ppSource);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppSource));
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComBSTR strDisplayName;
	CComBSTR strDesiredName;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszDisplayName) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	strDesiredName = pszDisplayName;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		strDisplayName.Empty();
		hrRes = pSource->get_DisplayName(&strDisplayName);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (wcscmp(strDisplayName,strDesiredName) == 0) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueBase {
	public:
		virtual BOOL Match(VARIANT *pValue) = 0;
};


static HRESULT SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, CValueBase *pValue, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComVariant varProperty;
	CComPtr<IEventPropertyBag> pProperties;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszProperty) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	varProperty = pszProperty;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		pProperties.Release();
		hrRes = pSource->get_Properties(&pProperties);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		varValue.Clear();
		hrRes = pProperties->Item(&varProperty,&varValue);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			continue;
		}
		if (pValue->Match(&varValue)) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueDWORD : public CValueBase {
	public:
		CValueDWORD(DWORD dwValue) {
			m_dwValue = dwValue;
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_I4);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if ((DWORD) pValue->lVal != m_dwValue) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		DWORD m_dwValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueDWORD(dwValue),ppSource));
}


class CValueBSTR : public CValueBase {
	public:
		CValueBSTR(LPCWSTR pszValue) {
			m_strValue = SysAllocString(pszValue);
		};
		CValueBSTR(LPCSTR pszValue) {
			USES_CONVERSION;
			m_strValue = SysAllocString(A2W(pszValue));
		};
		~CValueBSTR() {
			SysFreeString(m_strValue);
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_BSTR);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if (wcscmp(pValue->bstrVal,m_strValue) != 0) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		BSTR m_strValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueBSTR(pszValue),ppSource));
}


static HRESULT SEOGetRouter(IEventSource *pSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventBindingManager> pManager;
	CComPtr<IEventRouter> pRouter;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!pSource || !ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = pSource->GetBindingManager(&pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventRouter,NULL,CLSCTX_ALL,IID_IEventRouter,(LPVOID *) &pRouter);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pRouter->put_Database(pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	*ppRouter = pRouter;
	(*ppRouter)->AddRef();
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,rguidSource,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventRouter **ppRouter) {

	return (SEOGetRouter(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppRouter));
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszDisplayName,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,dwValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,pszValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


#include <initguid.h>

// This CLSID must match the one in SEO.DLL.
// {A4BE1350-1051-11d1-AA1E-00AA006BC80B}
DEFINE_GUID(CLSID_CEventServiceObject,
0xa4be1350, 0x1051, 0x11d1, 0xaa, 0x1e, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);


STDMETHODIMP SEOGetServiceHandle(IUnknown **ppUnkHandle) {

	return (CoCreateInstance(CLSID_CEventServiceObject,
							 NULL,
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) ppUnkHandle));
}


STDMETHODIMP SEOCreateObject(VARIANT *pvarClass,
							 IEventBinding *pBinding,
							 IUnknown *pInitProperties,
							 REFIID iidDesired,
							 IUnknown **ppUnkObject) {

	return (SEOCreateObjectEx(pvarClass,pBinding,pInitProperties,iidDesired,NULL,ppUnkObject));
}


STDMETHODIMP SEOCreateObjectEx(VARIANT *pvarClass,
							   IEventBinding *pBinding,
							   IUnknown *pInitProperties,
							   REFIID iidDesired,
							   IUnknown *pUnkCreateOptions,
							   IUnknown **ppUnkObject) {
	HRESULT hrRes;
	CStringGUID objGuid;
	BSTR strClass;
	CComQIPtr<IEventCreateOptions,&IID_IEventCreateOptions> pOpt;

	if (ppUnkObject) {
		*ppUnkObject = NULL;
	}
	if (!pvarClass || !ppUnkObject) {
		return (E_POINTER);
	}
	if (pUnkCreateOptions) {
		pOpt = pUnkCreateOptions;
	}
	if (pvarClass->vt == VT_BSTR) {
		strClass = pvarClass->bstrVal;
	} else if (pvarClass->vt == (VT_BYREF|VT_BSTR)) {
		strClass = *pvarClass->pbstrVal;
	} else {
		hrRes = VariantChangeType(pvarClass,pvarClass,0,VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		strClass = pvarClass->bstrVal;
	}
	objGuid.CalcFromProgID(strClass);
	if (!objGuid) {
		objGuid = strClass;
		if (!objGuid) {
			CComPtr<IBindCtx> pBindCtx;
			CComPtr<IMoniker> pMoniker;
			DWORD dwEaten;

			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			_ASSERTE(SUCCEEDED(hrRes));
			if (SUCCEEDED(hrRes)) {
				if (!pOpt || ((hrRes=pOpt->MkParseDisplayName(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL)) {
					hrRes = MkParseDisplayName(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
			}
			_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
			if (!SUCCEEDED(hrRes)) {
#if 0	// tbd - We try both the normal and the Ex versions of MkParseDisplayName.  Just use one.
				pBindCtx.Release();
				hrRes = CreateBindCtx(0,&pBindCtx);
				_ASSERTE(SUCCEEDED(hrRes));
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				if (!pOpt||((hrRes=pOpt->MkParseDisplayNameEx(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL) {
					hrRes = MkParseDisplayNameEx(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
				_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
#else
				return (hrRes);
#endif
			}
			pBindCtx.Release();
			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			if (!SUCCEEDED(hrRes)) {
				_ASSERTE(FALSE);
				return (hrRes);
			}
			if (!pOpt || ((hrRes=pOpt->BindToObject(pMoniker,
													pBindCtx,
													NULL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
				hrRes = pMoniker->BindToObject(pBindCtx,NULL,iidDesired,(LPVOID *) ppUnkObject);
			}
			_ASSERTE(!SUCCEEDED(hrRes)||!*ppUnkObject);
			// Fall through
		}
	}
	// At this point, objGuid will only be TRUE if either CalcFromProgID or
	// operator =(LPCOLESTR) succeeded.  If both of these failed, then it will
	// be FALSE and we will have attempted to interpret the SinkClass as a
	// moniker.
	if (!!objGuid) {	// Use !! to hack-past ambiguous-conversion issues...
		if (!pOpt || ((hrRes=pOpt->CoCreateInstance(objGuid,
													NULL,
													CLSCTX_ALL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
			hrRes = CoCreateInstance(objGuid,NULL,CLSCTX_ALL,iidDesired,(LPVOID *) ppUnkObject);
		}
		_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkObject);
	}
	// At this point, hrRes has the result either from pMoniker->BindToObject or
	// CoCreateInstance.
	if (SUCCEEDED(hrRes)) {
		if (!pOpt || ((hrRes=pOpt->Init(iidDesired,ppUnkObject,pBinding,pInitProperties))==E_NOTIMPL)) {
			hrRes = S_OK;
			CComQIPtr<IEventPersistBinding,&IID_IEventPersistBinding> pBindingInit;

			if (pBinding) {
				pBindingInit = *ppUnkObject;
			}
			if (pBindingInit) {
				HRESULT hrResTmp;

				hrResTmp = pBindingInit->Load(pBinding);
				_ASSERTE(SUCCEEDED(hrResTmp));
			} else {
				CComQIPtr<IPersistPropertyBag,&IID_IPersistPropertyBag> pInit;

				if (pInitProperties) {
					pInit = *ppUnkObject;
				}
				if (pInit) {
					HRESULT hrResTmp;
					CComQIPtr<IPropertyBag,&IID_IPropertyBag> pProps;

					pProps = pInitProperties;
					_ASSERTE(pProps);
					if (pProps) {
						hrResTmp = pInit->InitNew();
						_ASSERTE(SUCCEEDED(hrResTmp));
						if (SUCCEEDED(hrResTmp)) {
							hrResTmp = pInit->Load(pProps,NULL);	// tbd - pass an IErrorLog object
							_ASSERTE(SUCCEEDED(hrResTmp));
						}
					}
				}
			}
		}
		if (!SUCCEEDED(hrRes)) {
			(*ppUnkObject)->Release();
			*ppUnkObject = NULL;
		}
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_

class CInitApp;

extern CInitApp theApp;

BOOL IsFileExist(LPCTSTR szFile);

BOOL RunningAsAdministrator();

void DebugOutput(LPCTSTR szFormat, ...);
void DebugOutputSafe(TCHAR *pszfmt, ...);

LONG lodctr(LPCTSTR lpszIniFile);
LONG unlodctr(LPCTSTR lpszDriver);

INT Register_iis_smtp_nt5(BOOL fUpgrade, BOOL fReinstall);
INT Unregister_iis_smtp();
INT Register_iis_nntp_nt5(BOOL fUpgrade, BOOL fReinstall);
INT Unregister_iis_nntp();
INT Upgrade_iis_smtp_nt5_fromk2(BOOL fFromK2);
INT Upgrade_iis_smtp_nt5_fromb2(BOOL fFromB2);
INT Upgrade_iis_nntp_nt5_fromk2(BOOL fFromK2);
INT Upgrade_iis_nntp_nt5_fromb2(BOOL fFromB2);
void GetNntpFilePathFromMD(CString &csPathNntpFile, CString &csPathNntpRoot);

DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);

INT     InetStartService( LPCTSTR lpServiceName );
DWORD   InetQueryServiceStatus( LPCTSTR lpServiceName );
INT     InetStopService( LPCTSTR lpServiceName );
INT     InetDeleteService( LPCTSTR lpServiceName );
INT     InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies, LPCTSTR lpServiceDescription);
INT     InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies, LPCTSTR lpServiceDescription);
BOOL InetRegisterService(LPCTSTR pszMachine, LPCTSTR pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd = TRUE);
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
int ServicesRestartList_RestartServices(void);
int ServicesRestartList_Add(LPCTSTR szServiceName);

INT InstallPerformance(
                CString nlsRegPerf,
                CString nlsDll,
                CString nlsOpen,
                CString nlsClose,
                CString nlsCollect );
INT AddEventLog(CString nlsService, CString nlsMsgFile, DWORD dwType);
INT RemoveEventLog( CString nlsService );
INT RemoveAgent( CString nlsServiceName );

BOOL CreateLayerDirectory( CString &str );
BOOL SetNntpACL (CString &str, BOOL fAddAnonymousLogon = FALSE, BOOL fAdminOnly = FALSE);

int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style);
void GetErrorMsg(int errCode, LPCTSTR szExtraMsg);
void MyLoadString(int nID, CString &csResult);
DWORD GetDebugLevel(void);

void    MakePath(LPTSTR lpPath);
void    AddPath(LPTSTR szPath, LPCTSTR szName );

DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);

void SetupSetStringId_Wrapper(HINF hInf);

//
// Strings used for tracing.
//


extern LPCTSTR szInstallModes[];
extern TCHAR szSubcomponentNames[SC_MAXSC][24];
extern TCHAR szComponentNames[MC_MAXMC][24];

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\helper.cpp ===
#include "stdafx.h"
#include <loadperf.h>
#include <aclapi.h>
#include "setupapi.h"
#include "log.h"
#include "iiscnfg.h"
#include "iadmw.h"
#include "mdkey.h"

#define DBL_UNDEFINED   ((DWORD)-1)
DWORD gDebugLevel = DBL_UNDEFINED;
extern MyLogFile g_MyLogFile;

// Forward references
DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath);
DWORD GetPrincipalSID (LPTSTR Principal, PSID *Sid, BOOL *pbWellKnownSID);
DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount);

void DebugOutputFile(TCHAR* pszTemp)
{
    //
    //  NT5 doesn't want us to put all the debug string
    //  in debugger.  So we skip them based on a regkey.
    //  See GetDebugLevel().
    //  Todo: Log strings to a logfile!!!
    //  See IIS log.h, log.cpp for examples!
    //
    g_MyLogFile.LogFileWrite(pszTemp);
    if (gDebugLevel == DBL_UNDEFINED) {gDebugLevel = GetDebugLevel();}
    if (gDebugLevel)
    {
	    OutputDebugString(pszTemp);
    }

}

void DebugOutput(LPCTSTR szFormat, ...)
{
    va_list marker;
    const int chTemp = 1024;
	TCHAR   szTemp[chTemp];

	// Make sure the last two bytes are null in case the printf doesn't null terminate
	szTemp[chTemp-2] = szTemp[chTemp-1] = '\0';

    // Encompass this whole iisdebugout deal in a try-catch.
    // not too good to have this one access violating.
    // when trying to produce a debugoutput!
    __try
    {
        va_start( marker, szFormat );
        _vsnwprintf(szTemp, chTemp-2, szFormat, marker );
	    lstrcat(szTemp, _T("\n"));
        va_end( marker );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in DebugOutput().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }

    // output to log file and the screen.
    DebugOutputFile(szTemp);

    return;
}

// This function requires inputs like this:
//   iisDebugOutSafeParams2("this %1!s! is %2!s! and has %3!d! args", "function", "kool", 3);
//   you must specify the %1 deals.  this is so that
//   if something like this is passed in "this %SYSTEMROOT% %1!s!", it will put the string into %1 not %s!
void DebugOutputSafe(TCHAR *pszfmt, ...)
{
    // The count of parameters do not match
    va_list va;
    TCHAR *pszFullErrMsg = NULL;

    va_start(va, pszfmt);
    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                   (LPCVOID) pszfmt,
                   0,
                   0,
                   (LPTSTR) &pszFullErrMsg,
                   0,
                   &va);
    if (pszFullErrMsg)
    {
        // output to log file and the screen.
        DebugOutputFile(pszFullErrMsg);
    }
    va_end(va);

    if (pszFullErrMsg) {LocalFree(pszFullErrMsg);pszFullErrMsg=NULL;}
    return;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

INT InstallPerformance(
                CString nlsRegPerf,
                CString nlsDll,
                CString nlsOpen,
                CString nlsClose,
                CString nlsCollect )
{
    INT err = NERR_Success;

    if (theApp.m_eOS != OS_W95) {
        CRegKey regPerf( nlsRegPerf, HKEY_LOCAL_MACHINE );
        if (regPerf)
        {
            regPerf.SetValue(_T("Library"), nlsDll );
            regPerf.SetValue(_T("Open"),    nlsOpen );
            regPerf.SetValue(_T("Close"),   nlsClose );
            regPerf.SetValue(_T("Collect"), nlsCollect );
        }
    }

    return(err);
}
//
// Add eventlog to the registry
//

INT AddEventLog(CString nlsService, CString nlsMsgFile, DWORD dwType)
{
    INT err = NERR_Success;
    CString nlsLog = REG_EVENTLOG;
    nlsLog += _T("\\");
    nlsLog += nlsService;

    CRegKey regService( nlsLog, HKEY_LOCAL_MACHINE );
    if ( regService ) {
        regService.SetValue( _T("EventMessageFile"), nlsMsgFile, TRUE );
        regService.SetValue( _T("TypesSupported"), dwType );
    }
    return(err);
}

//
// Remove eventlog from the registry
//

INT RemoveEventLog( CString nlsService )
{
    INT err = NERR_Success;
    CString nlsLog = REG_EVENTLOG;

    CRegKey regService( HKEY_LOCAL_MACHINE, nlsLog );
    if ( regService )
        regService.DeleteTree( nlsService );
    return(err);
}

//
// Remove an SNMP agent from the registry
//

INT RemoveAgent( CString nlsServiceName )
{
    INT err = NERR_Success;
    do
    {
        CString nlsSoftwareAgent = REG_SOFTWAREMSFT;

        CRegKey regSoftwareAgent( HKEY_LOCAL_MACHINE, nlsSoftwareAgent );
        if ((HKEY)NULL == regSoftwareAgent )
            break;
        regSoftwareAgent.DeleteTree( nlsServiceName );

        CString nlsSnmpParam = REG_SNMPPARAMETERS;

        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ((HKEY) NULL == regSnmpParam )
            break;
        regSnmpParam.DeleteTree( nlsServiceName );

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( HKEY_LOCAL_MACHINE, nlsSnmpExt );
        if ((HKEY) NULL == regSnmpExt )
            break;

        CRegValueIter enumSnmpExt( regSnmpExt );

        CString strName;
        DWORD dwType;
        CString csServiceName;

        csServiceName = _T("\\") + nlsServiceName;
        csServiceName += _T("\\");

        while ( enumSnmpExt.Next( &strName, &dwType ) == NERR_Success )
        {
            CString nlsValue;

            regSnmpExt.QueryValue( strName, nlsValue );

            if ( nlsValue.Find( csServiceName ) != (-1))
            {
                // found it
                regSnmpExt.DeleteValue( (LPCTSTR)strName );
                break;
            }
        }
    } while (FALSE);
    return(err);
}

LONG lodctr(LPCTSTR lpszIniFile)
{
    CString csCmdLine = _T("lodctr ");
    csCmdLine += theApp.m_csSysDir;
    csCmdLine += _T("\\");
    csCmdLine += lpszIniFile;

    return (LONG)(LoadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE));
}

LONG unlodctr(LPCTSTR lpszDriver)
{
    CString csCmdLine = _T("unlodctr ");
    csCmdLine += lpszDriver;

    return (LONG)(UnloadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE));
}

//
// Given a directory path, set everyone full control security
//

BOOL SetNntpACL (CString &str, BOOL fAddAnonymousLogon, BOOL fAdminOnly)
{
    DWORD dwRes, dwDisposition;
    PSID pEveryoneSID = NULL;
    PSID pAnonymousLogonSID = NULL;
    PSID pLocalSystemSID = NULL;
    PSID pAdminSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    const int cMaxExplicitAccess = 4;
    EXPLICIT_ACCESS ea[cMaxExplicitAccess];
    int cExplicitAccess = 0;
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    LONG lRes;
    BOOL fRet = FALSE;

    // Create a security descriptor for the files
	ZeroMemory(ea, sizeof(ea));
    
    // Create a well-known SID for the Everyone group.
	if (fAdminOnly) 
	{
		if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
			SECURITY_LOCAL_SYSTEM_RID,
			0, 0, 0, 0, 0, 0, 0,
			&pLocalSystemSID) )
		{
			goto Exit;
		}
		if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS,
			0, 0, 0, 0, 0, 0,
			&pAdminSID) )
		{
		goto Exit;
		}

		ea[0].grfAccessPermissions = GENERIC_ALL;
		ea[0].grfAccessMode = SET_ACCESS;
		ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
		ea[0].Trustee.ptstrName  = (LPTSTR) pLocalSystemSID;

		ea[1].grfAccessPermissions = GENERIC_ALL;
		ea[1].grfAccessMode = SET_ACCESS;
		ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

		cExplicitAccess = 2;
		
	}
	else 
	{
		if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
	                 SECURITY_WORLD_RID,
	                 0, 0, 0, 0, 0, 0, 0,
	                 &pEveryoneSID) )
		{
			goto Exit;
		}

		// Initialize an EXPLICIT_ACCESS structure for an ACE.
		// The ACE will allow Everyone read access to the key.

		ea[0].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
		ea[0].grfAccessMode = DENY_ACCESS;
		ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

		ea[1].grfAccessPermissions = GENERIC_ALL;
		ea[1].grfAccessMode = SET_ACCESS;
		ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
		ea[1].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

		cExplicitAccess = 2;

		if (fAddAnonymousLogon) {

	    	if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
	                 SECURITY_ANONYMOUS_LOGON_RID,
	                 0, 0, 0, 0, 0, 0, 0,
	                 &pAnonymousLogonSID) )
			{
				goto Exit;
			}

			ea[2].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
			ea[2].grfAccessMode = DENY_ACCESS;
			ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
			ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
			ea[2].Trustee.TrusteeType = TRUSTEE_IS_USER;
			ea[2].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

			ea[3].grfAccessPermissions = GENERIC_ALL;
			ea[3].grfAccessMode = SET_ACCESS;
			ea[3].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
			ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
			ea[3].Trustee.TrusteeType = TRUSTEE_IS_USER;
			ea[3].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;
			cExplicitAccess = 4;
		}
	}

    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAcl(cExplicitAccess, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        goto Exit;
    }

    // Initialize a security descriptor.

    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
                         SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSD == NULL)
    {
        goto Exit;
    }

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        goto Exit;
    }

    // Add the ACL to the security descriptor.

    if (!SetSecurityDescriptorDacl(pSD,
        TRUE,     // fDaclPresent flag
        pACL,
        FALSE))   // not a default DACL
    {
        goto Exit;
    }

    // Initialize a security attributes structure.


    fRet = SetFileSecurity (str, DACL_SECURITY_INFORMATION, pSD);

Exit:
	if (pEveryoneSID)
		FreeSid(pEveryoneSID);
	if (pAnonymousLogonSID)
		FreeSid(pAnonymousLogonSID);
	if (pLocalSystemSID)
		FreeSid(pLocalSystemSID);
	if (pAdminSID)
		FreeSid(pAdminSID);
    if (pACL)
        LocalFree(pACL);
    if (pSD)
        LocalFree(pSD);
    return fRet;

}

//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( CString &str )
{
    BOOL fReturn = TRUE;

    do
    {
        INT index=0;
        INT iLength = str.GetLength();

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            GetCurrentDirectory( MAX_PATH+1, szCurrentDir );

            if ( !SetCurrentDirectory( str.Left( index + 1 )))
            {
                if (( fReturn = CreateDirectory( str.Left( index + 1 ), NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style)
{
    int iReturn = IDOK;

    // make sure it goes to DebugOutput
    DebugOutput(_T("MyMessageBox: Title:%s, Msg:%s"), lpszTheTitle, lpszTheMessage);

    if (style & MB_ABORTRETRYIGNORE)
    {
        iReturn = IDIGNORE;
    }

    return iReturn;
}

void GetErrorMsg(int errCode, LPCTSTR szExtraMsg)
{
	TCHAR pMsg[_MAX_PATH];

	FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
		pMsg, _MAX_PATH, NULL);
    lstrcat(pMsg, szExtraMsg);
    MyMessageBox(NULL, pMsg, _T(""), MB_OK | MB_SETFOREGROUND);
    return;
}

DWORD GetDebugLevel(void)
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), &hkey);
    if (err != ERROR_SUCCESS) {return 0;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OC Manager Debug Level"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);
    return rc;
}

void MyLoadString(int nID, CString &csResult)
{
    TCHAR buf[MAX_STR_LEN];

    if (LoadString(theApp.m_hDllHandle, nID, buf, MAX_STR_LEN))
        csResult = buf;

    return;
}

void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}

void AddPath(LPTSTR szPath, LPCTSTR szName )
{
        LPTSTR p = szPath;
    ASSERT(szPath);
    ASSERT(szName);

    // Find end of the string
    while (*p){p = _tcsinc(p);}

        // If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
                {_tcscat(szPath, _T("\\"));}

        // if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

        // Add new name to existing path string
        _tcscat(szPath, szName);
}

// GetPrincipalSID is from \nt\private\inet\iis\ui\setup\osrc\dcomperm.cpp

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    DebugOutput(_T("GetPrincipalSID:Principal=%s"), Principal);

    DWORD returnValue=ERROR_SUCCESS;
    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    csPrincipal.MakeLower();
    if ( csPrincipal.Find(_T("administrators")) != -1 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if (csPrincipal.Find(_T("system")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;

    } else if (csPrincipal.Find(_T("networkservice")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_NETWORK_SERVICE_RID;

    } else if (csPrincipal.Find(_T("service")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SERVICE_RID;
    } else if (csPrincipal.Find(_T("interactive")) != -1) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if (csPrincipal.Find(_T("everyone")) != -1) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
		                            dwRID[0],
		                            dwRID[1],
		                            dwRID[2],
		                            dwRID[3],
		                            dwRID[4],
		                            dwRID[5],
		                            dwRID[6],
		                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    Principal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}


// SetAdminACL taken from \nt\private\inet\iis\ui\setup\osrc\helper.cpp

DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount)
{
    DebugOutputSafe(_T("SetAdminACL(%1!s!) Start."), szKeyPath);

    int iErr=0;
    DWORD dwErr=ERROR_SUCCESS;

    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    PSID pServiceSID = NULL;
    PSID pNetworkServiceSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (NULL == pSD) {
    	dwErr = ERROR_NOT_ENOUGH_MEMORY;
    	DebugOutput(_T("LocalAlloc failed"));
    	goto Cleanup;
    }

    iErr = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    if (iErr == 0)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:InitializeSecurityDescriptor FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Get Local Admins Sid
    dwErr = GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Administrators) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Get Local Service Sid
    dwErr = GetPrincipalSID (_T("Service"), &pServiceSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Local Service) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Get Network Service Sid
    dwErr = GetPrincipalSID (_T("NetworkService"), &pNetworkServiceSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Network Service) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Get everyone Sid
    dwErr = GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Everyone) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pServiceSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pNetworkServiceSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if ( !pACLNew )
    {
        dwErr=ERROR_NOT_ENOUGH_MEMORY;
        DebugOutput(_T("SetAdminACL:pACLNew LocalAlloc(LPTR,  FAILED. size = %u GetLastError()= 0x%x"), cbACL, dwErr);
        goto Cleanup;
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:InitializeAcl FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC),pAdminsSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pAdminsSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_UNSECURE_PROPS_READ | MD_ACR_ENUM_KEYS),pServiceSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pServiceSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS),pNetworkServiceSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pNetworkServiceSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

#if 0			// Don't allow Everyone to have perms
    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,dwAccessForEveryoneAccount,pEveryoneSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pEveryoneSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }
#endif

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorDacl(pACLNew) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorOwner(pAdminsSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorGroup(pAdminsSID) FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    if (!b && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:MakeSelfRelativeSD FAILED.  GetLastError()= 0x%x"), dwErr);
        goto Cleanup;
    }

    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:GlobalAlloc FAILED. cboutpSD = %u  GetLastError()= 0x%x"), cboutpSD, dwErr);
        goto Cleanup;
    }

    b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:MakeSelfRelativeSD() FAILED. cboutpSD = %u GetLastError()= 0x%x"),cboutpSD, dwErr);
        goto Cleanup;
    }

    // Apply the new security descriptor to the metabase
    DebugOutput(_T("SetAdminACL:Write the new security descriptor to the Metabase. Start."));
    dwErr = WriteSDtoMetaBase(outpSD, szKeyPath);
    DebugOutput(_T("SetAdminACL:Write the new security descriptor to the Metabase.   End."));

Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (outpSD){GlobalFree(outpSD);}
  if (pAdminsSID){FreeSid(pAdminsSID);}
  if (pServiceSID){FreeSid(pServiceSID);}
  if (pNetworkServiceSID){FreeSid(pNetworkServiceSID);}
  if (pEveryoneSID){FreeSid(pEveryoneSID);}
  if (pSD){LocalFree((HLOCAL) pSD);}
  if (pACLNew){LocalFree((HLOCAL) pACLNew);}
  DebugOutputSafe(_T("SetAdminACL(%1!s!)  End."), szKeyPath);
  return (dwErr);
}


DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

	// LogHeapState(FALSE, __FILE__, __LINE__);

	do
	{
		dwReturn = SetAdminACL(szKeyPath, dwAccessForEveryoneAccount);
		// LogHeapState(FALSE, __FILE__, __LINE__);
		if (FAILED(dwReturn))
		{
		  // SetErrorFlag(__FILE__, __LINE__);
			if (bDisplayMsgOnErrFlag == TRUE)
			  {
			    CString msg;
			    MyLoadString(IDS_RETRY, msg);
                iMsg = MyMessageBox( NULL, msg, _T(""), MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto SetAdminACL_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto SetAdminACL_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto SetAdminACL_wrap_Exit;
			}
		}
                                    else
                                    {
                                                      break;
                                    }
	} while ( FAILED(dwReturn) );

SetAdminACL_wrap_Exit:
	return dwReturn;
}
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath)
{
    DebugOutput(_T("WriteSDtoMetaBase: Start"));
    DWORD dwReturn = E_FAIL;
    DWORD dwLength = 0;
    CMDKey cmdKey;

    if (!outpSD)
    {
        dwReturn = ERROR_INVALID_SECURITY_DESCR;
        goto WriteSDtoMetaBase_Exit;
    }

    // Apply the new security descriptor to the metabase
    dwLength = GetSecurityDescriptorLength(outpSD);

    // open the metabase
    // stick it into the metabase.  warning those hoses a lot because
    // it uses encryption.  rsabase.dll
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), dwdata = %u; outpSD = %p, Start"), dwLength, outpSD );

        dwReturn = cmdKey.SetData(MD_ADMIN_ACL,METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)outpSD);
        if (FAILED(dwReturn))
        {
	  // SetErrorFlag(__FILE__, __LINE__);
            DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), FAILED. Code=0x%x.  End."), dwReturn);
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), Success.  End."));
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = E_FAIL;
    }

WriteSDtoMetaBase_Exit:
    DebugOutput(_T("WriteSDtoMetaBase:   End.  Return=0x%x"), dwReturn);
    return dwReturn;
}

void SetupSetStringId_Wrapper(HINF hInf)
{
    // Note, we only care about the intel variants since they're the only ones
    // special cased in the .INFs
    // Not anymore, we handles the [SourceDisksName] section as well
    SYSTEM_INFO SystemInfo;
    GetSystemInfo( &SystemInfo );
    TCHAR szSourceCatOSName[20];

    _tcscpy(szSourceCatOSName, _T("\\i386"));
    switch(SystemInfo.wProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_AMD64:
        _tcscpy(szSourceCatOSName, _T("\\AMD64"));
        break;

	case PROCESSOR_ARCHITECTURE_IA64:
    	_tcscpy(szSourceCatOSName, _T("\\IA64"));
    	break;

    case PROCESSOR_ARCHITECTURE_INTEL:
        if (IsNEC_98) {
            _tcscpy(szSourceCatOSName, _T("\\Nec98"));
        }
        break;

    default:
        break;
    }

	// 34000 is no longer used
    //SetupSetDirectoryIdEx(hInf, 34000, szSourceCatOSName, SETDIRID_NOT_FULL_PATH, 0, 0);
    SetupSetDirectoryIdEx(hInf, 34001, szSourceCatOSName, SETDIRID_NOT_FULL_PATH, 0, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\dummy.cpp ===
#include "stdafx.h"

#include "setupapi.h"
#include "ocmanage.h"

#pragma hdrstop

/* =================================================================

The sequence of OCM Calls are as follows:

OC_PREINITIALIZE
OC_INIT_COMPONENT
OC_SET_LANGUAGE
OC_QUERY_STATE
OC_CALC_DISK_SPACE
OC_REQUEST_PAGES

UI Appears with Welcome, EULA, and mode page

OC_QUERY_STATE
OC_QUERY_SKIP_PAGE

OC Page "Check boxes" appears

OC_QUERY_IMAGE

Detail pages
Wizard pages ...

OC_QUEUE_FILE_OPS
OC_QUERY_STEP_COUNT
OC_ABOUT_TO_COMMIT_QUEUE
OC_NEED_MEDIA (if required)
OC_COMPLETE_INSTALLATION

OC_CLEANUP

*/
DWORD
DummyOcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD d;

    switch(Function) 
	{

    case OC_PREINITIALIZE:
#ifdef UNICODE
        d = OCFLAG_UNICODE;
#else
        d = OCFLAG_ANSI;
#endif
        break;

    case OC_INIT_COMPONENT:
		d = NO_ERROR;
        break;

    case OC_SET_LANGUAGE:
        d = TRUE;
        break;

    case OC_QUERY_IMAGE:
        d = (DWORD)NULL;
        break;

    case OC_REQUEST_PAGES:
        d = 0;
        break;

    case OC_QUERY_STATE:
        d = SubcompOff;
		break;

    case OC_QUERY_CHANGE_SEL_STATE:
		d = 0;
		break;

    case OC_CALC_DISK_SPACE:
        d = NO_ERROR;
        break;

    case OC_QUEUE_FILE_OPS:
        d = NO_ERROR;
		break;

    case OC_NEED_MEDIA:
        d = 1;
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = 0;
        break;

    case OC_QUERY_STEP_COUNT:
        d = 0;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        d = NO_ERROR;
		break;

    case OC_COMPLETE_INSTALLATION:
        d = NO_ERROR;
		break;

    case OC_CLEANUP:
        d = 0;
		break;

    default:
        d = 0;
        break;
    }

    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\elem.cpp ===
#include "stdafx.h"

#include "elem.h"

CElem::CElem()
{
    m_hKey = NULL;
    m_index = 0;
    m_ip = _T("");
    m_name = _T("");
    m_value = _T("");
}

CElem::~CElem()
{
    if (m_hKey) 
        RegCloseKey(m_hKey);
}

BOOL CElem::OpenReg(LPCTSTR szSubKey)
{
    BOOL fReturn = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &m_hKey) == ERROR_SUCCESS)
        fReturn = TRUE;
    else
        m_hKey = NULL;

    return (fReturn);
}

void CElem::CloseReg()
{
    if (m_hKey) {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CElem::GetNext()
{
    BOOL fReturn = FALSE;
    LONG err = ERROR_SUCCESS;
    TCHAR szBufferL[_MAX_PATH], szBufferR[_MAX_PATH];
    DWORD dwBufferL = _MAX_PATH, dwBufferR = _MAX_PATH;

    err = RegEnumValue(m_hKey, m_index, szBufferL, &dwBufferL, NULL, NULL, (LPBYTE)szBufferR, &dwBufferR);
    if (err == ERROR_SUCCESS) {
        LPTSTR token;
        m_index++;
        m_value = szBufferR;
        token = _tcstok(szBufferL, _T(","));
        if (token) {
            m_name = token;
            token = _tcstok(NULL, _T(","));
            if (token) {
                m_ip = token;
            } else {
                m_ip = _T("null");
            }
            fReturn = TRUE;
        }
    }

    return (fReturn);
}

void CElem::ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap)
{
    if ( OpenReg(szSubKey) ) {
        while (GetNext()) {
            Add(pMap);
        }
        CloseReg();
    }
}

void CElem::Add(CMapStringToOb *pMap)
{
    CObject *pObj;
    CMapStringToString *pNew;

    if (pMap->Lookup(m_ip, pObj) == TRUE) {
        pNew = (CMapStringToString*)pObj;
        pNew->SetAt(m_name, m_value);
    } else {
        pNew = new CMapStringToString;
        if (pNew != NULL) {		// Better to lose an entry than AV
	        pNew->SetAt(m_name, m_value);
	        pMap->SetAt(m_ip, (CObject*)pNew);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\dllmain.cpp ===
#include "stdafx.h"
#include "k2suite.h"

#include <ole2.h>
#include "helper.h"

#include "setupapi.h"
#include "ocmanage.h"

#include "utils.h"

#include "log.h"
#include "wizpages.h"

#pragma hdrstop

void CreateNNTPGroups(void);
/*
SETUPMODE_UNKNOWN
SETUPMODE_MINIMAL
SETUPMODE_TYPICAL
SETUPMODE_LAPTOP
SETUPMODE_CUSTOM

SETUPMODE_STANDARD_MASK
SETUPMODE_PRIVATE_MASK
*/

#ifndef UNICODE
#error UNICODE not defined
#endif

OCMANAGER_ROUTINES gHelperRoutines;
HINF gMyInfHandle;
HANDLE gMyModuleHandle;
HANDLE g_hUnattended = INVALID_HANDLE_VALUE;

// Logging class
MyLogFile g_MyLogFile;

TCHAR szSysDrive[3] = _T("C:");

TCHAR szComponentNames[MC_MAXMC][24] =
{
    _T("ims"),
    _T("ins")
};

TCHAR szSubcomponentNames[SC_MAXSC][24] =
{
    _T("iis_smtp"),
    _T("iis_nntp"),
    _T("iis_smtp_docs"),
    _T("iis_nntp_docs")
};

TCHAR szDocComponentNames[2][24] =
{
    _T("iis_smtp_docs"),
    _T("iis_nntp_docs")
};

TCHAR szActionTypeNames[AT_MAXAT][24] =
{
    _T("AT_DO_NOTHING"),
    _T("AT_FRESH_INSTALL"),
    _T("AT_REINSTALL"),
    _T("AT_UPGRADE"),
    _T("AT_REMOVE"),
    _T("AT_UPGRADEK2")
};

#define NUM_OC_STATES        (OC_QUERY_IMAGE_EX + 1)
TCHAR szOCMStates[NUM_OC_STATES][40] =
{
    _T("OC_PREINITIALIZE"),
    _T("OC_INIT_COMPONENT"),
    _T("OC_SET_LANGUAGE"),
    _T("OC_QUERY_IMAGE"),
    _T("OC_REQUEST_PAGES"),
    _T("OC_QUERY_CHANGE_SEL_STATE"),
    _T("OC_CALC_DISK_SPACE"),
    _T("OC_QUEUE_FILE_OPS"),
    _T("OC_NOTIFICATION_FROM_QUEUE"),
    _T("OC_QUERY_STEP_COUNT"),
    _T("OC_COMPLETE_INSTALLATION"),
    _T("OC_CLEANUP"),
    _T("OC_QUERY_STATE"),
    _T("OC_NEED_MEDIA"),
    _T("OC_ABOUT_TO_COMMIT_QUEUE"),
    _T("OC_QUERY_SKIP_PAGE"),
	_T("OC_WIZARD_CREATED"),
	_T("OC_FILE_BUSY	"),
	_T("OC_EXTRA_ROUTINES"),
	_T("OC_QUERY_IMAGE_EX"),
};

LPCTSTR szInstallModes[] = {
	_T("IM_FRESH"),
	_T("IM_UPGRADE"),
	_T("IM_MAINTENANCE"),
	_T("IM_DEGRADE"),
	_T("IM_UPGRADEK2"),   // Upgrade from K2 RTM to NT5
	_T("IM_UPGRADEB2"),   // Upgrade from NT5 Beta2
	_T("IM_UPGRADEB3"),   // Upgrade from NT5 Beta3
    _T("IM_UPGRADEWKS"),  // Upgrade from NT5 Workstation to NT5 Server
    _T("IM_UPGRADE10"),   // Upgrade from MCIS 1.0 to NT5
    _T("IM_UPGRADE20"),   // Upgrade from MCIS 2.0 to NT5
};


unsigned MyStepCount;

CInitApp theApp;

DWORD OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#ifdef _WIN64
   DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#endif
DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD BringALLIISClusterResourcesOffline(void);

BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    This routine is called by CRT when _DllMainCRTStartup is the
    DLL entry point.

Arguments:

    Standard Win32 DLL Entry point parameters.

Return Value:

    Standard Win32 DLL Entry point return code.

--*/
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        gMyModuleHandle = DllHandle;
        //
        // Fall through to process first thread
        //
        g_MyLogFile.LogFileCreate(_T("imsins.log"));

    case DLL_THREAD_ATTACH:

        b = TRUE;
        break;

    case DLL_PROCESS_DETACH:
        g_MyLogFile.LogFileClose();
        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return(b);
}

DWORD GetComponentFromId(LPCTSTR ComponentId)
{
    DWORD i;

    if (!ComponentId)
        return(MC_NONE);

    for (i = 0; i < (DWORD)MC_MAXMC; i++)
        if (!lstrcmpi(ComponentId, szComponentNames[i]))
            return(i);
    return(MC_NONE);
}

DWORD GetSubcomponentFromId(LPCTSTR SubcomponentId)
{
    DWORD i;

    if (!SubcomponentId)
        return(SC_NONE);

    for (i = 0; i < (DWORD)SC_MAXSC; i++)
        if (!lstrcmpi(SubcomponentId, szSubcomponentNames[i]))
            return(i);
    return(SC_NONE);
}

ACTION_TYPE GetSubcompActionFromCheckboxState(DWORD Id)
{
    DWORD State = 0;
    DWORD OldState = 0;

    ACTION_TYPE at = AT_DO_NOTHING;

    // Get the check box state
    State = gHelperRoutines.QuerySelectionState(
                        gHelperRoutines.OcManagerContext,
                        szSubcomponentNames[Id],
                        OCSELSTATETYPE_CURRENT
                        );
    if (GetLastError() != NO_ERROR)
    {
        DebugOutput(_T("Failed to get current state for <%s> (%u)"),
                        szSubcomponentNames[Id], GetLastError());
        State = 0;
    }

    // Check orignal state
    OldState = gHelperRoutines.QuerySelectionState(
                        gHelperRoutines.OcManagerContext,
                        szSubcomponentNames[Id],
                        OCSELSTATETYPE_ORIGINAL
                        );
    if (GetLastError() != NO_ERROR)
    {
        DebugOutput(_T("Failed to get original state for <%s> (%u)"),
                        szSubcomponentNames[Id], GetLastError());
        OldState = 0;
    }

    DebugOutput(_T("GetSubcompActionFromCheckboxState(%s): Old state=%d, state=%d"),
    	szSubcomponentNames[Id], OldState, State);

    if (State && !OldState)
    {
        // Change in state from OFF->ON = install docs
        at = AT_FRESH_INSTALL;

        DebugOutput(_T("Installing subcomponent <%s>"), szSubcomponentNames[Id]);
    }
    else if (!State && OldState)
    {
        // Change in state from ON->OFF = uninstall docs
        at = AT_REMOVE;

        DebugOutput(_T("Removing subcomponent <%s>"), szSubcomponentNames[Id]);
    }
    else if (State && OldState)
    {
        // Change in state from ON->ON : couple of cases here...
        if (theApp.m_eState[Id] == IM_UPGRADE || theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE10 || theApp.m_eState[Id] == IM_UPGRADE20)
        {
            // Upgrade if we were upgrading...
            at = AT_UPGRADE;

            DebugOutput(_T("Upgrading subcomponent <%s>"), szSubcomponentNames[Id]);
        }

        if (GetIMSSetupMode() == IIS_SETUPMODE_REINSTALL || (theApp.m_fNTGuiMode && ((theApp.m_eState[Id] == IM_MAINTENANCE) || (theApp.m_eState[Id] == IM_UPGRADEB2))))
        {
            // Reinstall if doing minor NT5 os upgrade, both from NT5 Beta2, or NT5 Beta3
            at = AT_REINSTALL;

            DebugOutput(_T("Reinstalling subcomponent <%s>, %s, IMS Reinstall=%s"), szSubcomponentNames[Id],
            	szInstallModes[theApp.m_eState[Id]],
            	(GetIMSSetupMode() == IIS_SETUPMODE_REINSTALL) ? _T("TRUE") : _T("FALSE"));
        }

        if (!theApp.m_fValidSetupString[Id]) {
            at = AT_REINSTALL;
            DebugOutput(_T("Reinstalling subcomponent <%s> (Invalid setup string)"), szSubcomponentNames[Id]);
        }

    }

    return(at);
}


BOOL IsSubcomponentCore(DWORD dwSubcomponentId)
{
    if (dwSubcomponentId == SC_SMTP || dwSubcomponentId == SC_NNTP)
        return TRUE;
    return FALSE;
}

STATUS_TYPE GetSubcompInitStatus(DWORD Id)
{
    STATUS_TYPE nStatus = ST_UNINSTALLED;
    BOOL OriginalState;

    if (Id != SC_NONE)
    {
        OriginalState = gHelperRoutines.QuerySelectionState(
                            gHelperRoutines.OcManagerContext,
                            szSubcomponentNames[Id],
                            OCSELSTATETYPE_ORIGINAL
                            );
        if (OriginalState == 1)
            nStatus = ST_INSTALLED;
        if (OriginalState == 0)
            nStatus = ST_UNINSTALLED;
    }

    return(nStatus);
}

/*

    The subcomponent action is a table-driven value which
    is dependent on 3 things:
    1) the master install mode
    2) the installed state of the subcomponent in question
    3) the state of the subcomponent check box

    We use the following matrix to determine the action.
    Note that an 'x' indicates invalid combinations and
    should have been coerced earlier by
    CInitApp::DetectPreviousINstallations().

    ----------------+-----------------------+-----------------------
    Check box        |            1            |            0
    ----------------+-----------------------+-----------------------
        \ Component    | Fresh    Upgrade Maint.    | Fresh      Upgrade Maint.
    Global            |                        |
    ----------------+-----------------------+-----------------------
    Fresh           | FRESH    x        x        | NOTHING x          x
    Upgrade         | FRESH    UPGRADE    x        | NOTHING NOTHING x
    Maintenance     | FRESH    UPGRADE    NOTHING    | NOTHING NOTHING REMOVE
    ----------------+-----------------------+-----------------------

*/
ACTION_TYPE GetSubcompAction(DWORD Id)
{
    ACTION_TYPE atReturn = AT_DO_NOTHING;
    ACTION_TYPE atSubcomp = GetSubcompActionFromCheckboxState(Id);

    DebugOutput(_T("GetSubcompAction(): %s=%s"), szSubcomponentNames[Id], szActionTypeNames[atSubcomp]);

    //
    //  Let's do it the way I thing we should do and modify it
    //  if errors found.
    //
    return atSubcomp;
}

void CreateAllRequiredDirectories(DWORD Id)
{
    ACTION_TYPE atComp;

    // If SMTP is being installed fresh, we need to create
    // the Queue, Pickup, Drop, and Badmail directories
    if (Id != SC_NNTP)
    {
        atComp = GetSubcompAction(Id);
        if (atComp == AT_FRESH_INSTALL)
        {
            if (Id == SC_SMTP)
            {
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_QUEUEDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_BADMAILDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_DROPDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_PICKUPDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_SORTTEMPDIR);
            }
            CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_ROUTINGDIR);
            CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_MAILBOXDIR);
        }
    }
}

LPTSTR szServiceNames[MC_MAXMC] =
{
    SZ_SMTPSERVICENAME,
    SZ_NNTPSERVICENAME,
};

BOOL GetInetpubPathFromPrivData(CString &csPathInetpub)
{
    TCHAR szPath[_MAX_PATH];
    UINT uType, uSize;
    // If we are not upgrading, we get the info from the private data
    uSize = _MAX_PATH * sizeof(TCHAR);
    if ((gHelperRoutines.GetPrivateData(gHelperRoutines.OcManagerContext,
                                _T("iis"),
                                _T("PathWWWRoot"),
                                (LPVOID)szPath,
                                &uSize,
                                &uType) == NO_ERROR) &&
        (uType == REG_SZ))
    {
        GetParentDir(szPath, csPathInetpub.GetBuffer(512));
        csPathInetpub.ReleaseBuffer();
        return TRUE;
    }
    else
        return FALSE;
}

void SetupMailAndNewsRoot( void )
{
    if (!theApp.m_fMailPathSet)
        theApp.m_csPathMailroot = theApp.m_csPathInetpub + _T("\\mailroot");
    if (!theApp.m_fNntpPathSet)
    {
        theApp.m_csPathNntpFile = theApp.m_csPathInetpub + _T("\\nntpfile");
        theApp.m_csPathNntpRoot = theApp.m_csPathNntpFile + _T("\\root");
    }
}

/* =================================================================

The sequence of OCM Calls are as follows:

OC_PREINITIALIZE
OC_INIT_COMPONENT
OC_SET_LANGUAGE
OC_QUERY_STATE
OC_CALC_DISK_SPACE
OC_REQUEST_PAGES

UI Appears with Welcome, EULA, and mode page

OC_QUERY_STATE
OC_QUERY_SKIP_PAGE

OC Page "Check boxes" appears

OC_QUERY_IMAGE

Detail pages
Wizard pages ...

OC_QUEUE_FILE_OPS
OC_QUERY_STEP_COUNT
OC_ABOUT_TO_COMMIT_QUEUE
OC_NEED_MEDIA (if required)
OC_COMPLETE_INSTALLATION

OC_CLEANUP

*/

// NT5 - Leave the DummyOcEntry there for safeguard

DWORD
DummyOcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

extern "C"
DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR d = 0;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    // Set the current top-level component so other functions can access it!
    theApp.m_dwCompId = CompId;

    // Output some debug information ...
    if (Function == OC_PREINITIALIZE || Function == OC_INIT_COMPONENT) {
	    DebugOutput(
            _T("Entering OCEntry; Component = <%s> (%u)"),
            ComponentId?ComponentId:_T(""), CompId);
    } else {
	    DebugOutput(
            _T("Entering OCEntry; Component = <%s> (%u), Subcomponent = <%s> (%u)"),
            ComponentId?ComponentId:_T(""), CompId,
            SubcomponentId?SubcomponentId:_T(""), Id);
    }
    DebugOutput(
            _T("\tFunction = %s (%u), Param1 = %08X (%u), Param2 = %p (%p)"),
            (Function <  NUM_OC_STATES) ? szOCMStates[Function] : _T("unknown state"),
            Function,
            (DWORD)Param1, (DWORD)Param1,
            (DWORD_PTR)Param2, (DWORD_PTR)Param2);

// NT5 - Leave the DummyOcEntry there for safeguard
    // HACK for standalone only!!
    // We are forced to handle the IIS section for standalone or we'll face an AV
    if (CompId == MC_NONE)
    {
        // Well, we will ignore all master sections that we do not know about.
        // This includes the IIS Master section
        DebugOutput(_T("Unknown master section, calling DummyOcEntry ..."));
        d = DummyOcEntry(ComponentId,
                            SubcomponentId,
                            Function,
                            Param1,
                            Param2);
        DebugOutput(_T("DummyOcEntry returning %u"), d);
        return(d);
    }

    switch(Function)
    {
    case OC_PREINITIALIZE:
        d = OC_PREINITIALIZE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_INIT_COMPONENT:
        d = OC_INIT_COMPONENT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_SET_LANGUAGE:
        d = OC_SET_LANGUAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

#ifdef _WIN64
    case OC_QUERY_IMAGE_EX:
    	d = OC_QUERY_IMAGE_EX_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;
#endif

    case OC_QUERY_IMAGE:
        d = OC_QUERY_IMAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_REQUEST_PAGES:
        d = OC_REQUEST_PAGES_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STATE:
        d = OC_QUERY_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        d = OC_QUERY_CHANGE_SEL_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_SKIP_PAGE:
        d = OC_QUERY_SKIP_PAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CALC_DISK_SPACE:
        d = OC_CALC_DISK_SPACE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        d = OC_QUEUE_FILE_OPS_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NEED_MEDIA:
        d = OC_NEED_MEDIA_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = OC_NOTIFICATION_FROM_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        d = OC_QUERY_STEP_COUNT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        d = OC_ABOUT_TO_COMMIT_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_COMPLETE_INSTALLATION:
        d = OC_COMPLETE_INSTALLATION_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CLEANUP:
        d = OC_CLEANUP_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    default:
        d = 0;
        break;
    }

    DebugOutput(_T("Leaving OCEntry.  Return=%d"), d);

    return(d);

}



//
// Param1 = char width flags
// Param2 = unused
//
// Return value is a flag indicating to OC Manager
// which char width we want to run in. Run in "native"
// char width.
//
DWORD OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;

#ifdef UNICODE
    d = OCFLAG_UNICODE;
#else
    d = OCFLAG_ANSI;
#endif

    return d;
}


//
// Param1 = unused
// Param2 = points to SETUP_INIT_COMPONENT structure
//
// Return code is Win32 error indicating outcome.
//
DWORD OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d;
    BOOL    b;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    PSETUP_INIT_COMPONENT InitComponent = (PSETUP_INIT_COMPONENT)Param2;

    theApp.m_hDllHandle = (HINSTANCE)gMyModuleHandle;

    // Check for workstation or server!
    theApp.m_fNTUpgrade_Mode = (InitComponent->SetupData.OperationFlags & SETUPOP_NTUPGRADE) > 0;
    theApp.m_fNTGuiMode = (InitComponent->SetupData.OperationFlags & SETUPOP_STANDALONE) == 0;
    theApp.m_fNtWorkstation = InitComponent->SetupData.ProductType == PRODUCT_WORKSTATION;

    // a superset of m_fNTGuiMode and controlpanel add/remove
    theApp.m_fInvokedByNT = theApp.m_fNTGuiMode;

    // if ran from sysoc.inf then set m_fInvokedByNT (for control panel add/remove)
    TCHAR szCmdLine1[_MAX_PATH+1];
    szCmdLine1[_MAX_PATH] = '\0';
    _tcsncpy(szCmdLine1, GetCommandLine(), _MAX_PATH);
    _tcslwr(szCmdLine1);
    if (_tcsstr(szCmdLine1, _T("sysoc.inf"))) {theApp.m_fInvokedByNT = TRUE;}

    // Call this stuff after setting m_fNTGuiMode and m_fNtWorkstation
    // since it maybe used in InitApplication().
    if ( theApp.InitApplication() == FALSE )
    {
        // setup should be terminated.
        d = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    //
    // The OC Manager passes us some information that we want to save,
    // such as an open handle to our per-component INF. As long as we have
    // a per-component INF, append-open any layout file that is
    // associated with it, in preparation for later inf-based file
    // queuing operations.
    //
    // We save away certain other stuff that gets passed to us now,
    // since OC Manager doesn't guarantee that the SETUP_INIT_COMPONENT
    // will persist beyond processing of this one interface routine.
    //

    if (InitComponent->ComponentInfHandle == INVALID_HANDLE_VALUE) {
        MyMessageBox(NULL, _T("Invalid inf handle."), _T(""), MB_OK | MB_SETFOREGROUND);
        d = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    theApp.m_hInfHandle[CompId] = InitComponent->ComponentInfHandle;

    theApp.m_csPathSource = InitComponent->SetupData.SourcePath;
    gHelperRoutines = InitComponent->HelperRoutines;

    // See if we are doing an unattended install
    theApp.m_fIsUnattended = (((DWORD)InitComponent->SetupData.OperationFlags) & SETUPOP_BATCH);
    if (theApp.m_fIsUnattended)
    {
        // Save the file handle as well ...
        DebugOutput(_T("Entering unattended install mode"));
        g_hUnattended = gHelperRoutines.GetInfHandle(INFINDEX_UNATTENDED,
                                                     gHelperRoutines.OcManagerContext);
    }

    // We must see if the Exchange IMC is installed. If it is we
    // will disable SMTP so we don't hose IMC. Make sure this check is
    // AFTER the check to see if we are doing unattended setup.
    if (CompId == MC_IMS)
    {
        theApp.m_fSuppressSmtp = DetectExistingSmtpServers();
    }

    // Set up the directory ID for Inetpub
    b = SetupSetDirectoryId(theApp.m_hInfHandle[CompId], 32768, theApp.m_csPathInetpub);

    //  Setup strind id for 34000/34001
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    d = NO_ERROR;

OC_INIT_COMPONENT_Func_Exit:

    return d;
}



//
// Param1 = low 16 bits specify Win32 LANGID
// Param2 = unused
//
// Return code is a boolean indicating whether we think we
// support the requested language. We remember the language id
// and say we support the language. A more exact check might involve
// looking through our resources via EnumResourcesLnguages() for
// example, or checking our inf to see whether there is a matching
// or closely matching [strings] section. We don't bother with
// any of that here.
//
// Locate the component and remember the language id for later use.
//
DWORD OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = TRUE;
    return d;
}
#ifdef _WIN64
DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{

    HBITMAP hBitMap = NULL;
    HBITMAP * phBitMapInput = (HBITMAP *) Param2;
    OC_QUERY_IMAGE_INFO * MyQueryInfo = (OC_QUERY_IMAGE_INFO *) Param1;

	DWORD CompId = GetComponentFromId(ComponentId);
	DWORD Id = GetSubcomponentFromId(SubcomponentId);

    if(MyQueryInfo->ComponentInfo == SubCompInfoSmallIcon)
    {
        if (Id != SC_NONE)
        {
            switch (Id)
            {
            case SC_SMTP:
                hBitMap = LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case SC_NNTP:
                hBitMap = LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            case SC_SMTP_DOCS:
            case SC_NNTP_DOCS:
                hBitMap = LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_DOCS));
                break;

            default:
                break;
            }
        }
        else
        {
            switch (CompId)
            {
            // Load top-level bitmaps for group
            case MC_IMS:
                hBitMap = LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case MC_INS:
                hBitMap = LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            default:
                break;
            }
        }

        if (hBitMap)
            *phBitMapInput = (HBITMAP) hBitMap;
    }

    return (hBitMap != NULL);

}
#endif


DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR d = (DWORD)NULL;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    if (LOWORD(Param1) == SubCompInfoSmallIcon)
    {
        if (Id != SC_NONE)
        {
            switch (Id)
            {
            case SC_SMTP:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case SC_NNTP:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            case SC_SMTP_DOCS:
            case SC_NNTP_DOCS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_DOCS));
                break;

            default:
                break;
            }
        }
        else
        {
            switch (CompId)
            {
            // Load top-level bitmaps for group
            case MC_IMS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case MC_INS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            default:
                break;
            }
        }

    }

    return d;
}


DWORD OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    WizardPagesType PageType;
    PSETUP_REQUEST_PAGES pSetupRequestPages = NULL;
    UINT MaxPages;
    HPROPSHEETPAGE pPage;

    PageType = (WizardPagesType)Param1;

    if ( PageType == WizPagesWelcome ) {

        // NT5 - No Welcome page
        if (theApp.m_fInvokedByNT)
        {
            d = 0;
        }

        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if ( PageType == WizPagesMode ) {
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
        MaxPages = pSetupRequestPages->MaxPages;
        pSetupRequestPages->MaxPages = 0;
        switch (theApp.m_eInstallMode)
        {
        case IM_UPGRADE:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            break;
        case IM_MAINTENANCE:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            break;
        case IM_FRESH:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            break;
        default:
            pSetupRequestPages->MaxPages = 0;
        }

        d = pSetupRequestPages->MaxPages;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if (!theApp.m_fWizpagesCreated && (PageType == WizPagesEarly))
    {
        // Get the pages, if we don't want it, we'll skip it later
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;

        if (theApp.m_fInvokedByNT)
        {
            pSetupRequestPages->MaxPages = 0;
            d = 0;
            goto OC_REQUEST_PAGES_Func_Exit;
        }

        d = 0;

        // Once we returned the Wizard pages, we will not return for
        // subsequent calls
        theApp.m_fWizpagesCreated = TRUE;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if ( PageType == WizPagesFinal ) {
        // Get the pages, if we don't want it, we'll skip it later
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
        MaxPages = pSetupRequestPages->MaxPages;
        pSetupRequestPages->MaxPages = 0;

        // NT5 - No Final page
        if (theApp.m_fInvokedByNT)
        {
            pSetupRequestPages->MaxPages = 0;
        }
        d = pSetupRequestPages->MaxPages;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    d = 0;

OC_REQUEST_PAGES_Func_Exit:

    return d;
}



DWORD OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = SubcompUseOcManagerDefault;
    DWORD   CompId, Id;
    ACTION_TYPE atComp;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    if (Id != SC_NONE)
    {
        // Merge all subcomponents here including iis_nntp_docs, iis_smtp_docs!
        // We track core components such as iis_nntp and iis_smtp here.
        // We track whether a component is active here: if it is queried of
        // its initial state, we assume that it's active
        theApp.m_fActive[CompId][Id] = TRUE;

        switch (Param1) {
            case OCSELSTATETYPE_ORIGINAL:
                switch (GetIMSSetupMode()) {
                    case IIS_SETUPMODE_UPGRADEONLY:
                        atComp = GetSubcompAction(Id);

                        if (atComp == AT_UPGRADE || atComp == AT_REINSTALL)
                        {
                            //  3/30/99 - Both cases have original state turn ON!
                            //  IM_REMOVE?
                            d = SubcompOn;
                        }
                        else
                        {
                            d = SubcompUseOcManagerDefault;
                        }

                        break;

                    default:
                        d = SubcompUseOcManagerDefault;
                        break;
                }

                DebugOutput(_T("Original state is: %s"),
                            (d == SubcompUseOcManagerDefault)?_T("DEFAULT"):
                                (d == SubcompOn)?_T("ON"):_T("OFF"));
                break;

            case OCSELSTATETYPE_CURRENT:

                // If we are doing unattended setup, we will override all
                // other modes ...
                if (theApp.m_fIsUnattended)
                {
                    d = GetUnattendedModeFromSetupMode(g_hUnattended, CompId, SubcomponentId);

                    // We force SMTP to be off if we are suppressing it
                    // Bug 130734: Leave SMTP installed on the box if IMC is there
                    if (theApp.m_fSuppressSmtp &&
                            (Id == SC_SMTP || Id == SC_SMTP_DOCS) &&
                            (GetIMSSetupMode() == IIS_SETUPMODE_CUSTOM))
                    {
                            //d = SubcompOff;
                            //DebugOutput(_T("Suppressed SMTP %s"), (Id == SC_SMTP_DOCS)?_T("Docs"):_T(""));
                    }
                    break;
                }

                switch (GetIMSSetupMode()) {
                    case IIS_SETUPMODE_REMOVEALL:
                        d = SubcompOff;
                        break;

                    case IIS_SETUPMODE_MINIMUM:
                    case IIS_SETUPMODE_TYPICAL:
                    case IIS_SETUPMODE_CUSTOM:
                        // Here's a new catch: if we are installing SMTP and
                        // we are asked to suppress it because of existence of
                        theApp.m_eState[Id] = IM_FRESH;
                        break;


                    case IIS_SETUPMODE_UPGRADEONLY:
// NT5 - Same here, for upgradeonly, we compare against our orignal state
// If it's ON, it's ON, if it's OFF, it's OFF
                    case IIS_SETUPMODE_ADDEXTRACOMPS:
                    case IIS_SETUPMODE_ADDREMOVE:
                    case IIS_SETUPMODE_REINSTALL:
                        d = gHelperRoutines.QuerySelectionState(
                                 gHelperRoutines.OcManagerContext,
                                 SubcomponentId,
                                 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
                        break;

                    default:
                        _ASSERT(FALSE);
                        break;
                }

                DebugOutput(_T("Current state is: %s"),
                            (d == SubcompUseOcManagerDefault)?_T("DEFAULT"):
                                (d == SubcompOn)?_T("ON"):_T("OFF"));
                break;
            default:
                break;
        }
    }

    return d;
}


// Called by OCMANAGE when a selection state is changed
// Param1 - Proposed new selection state 0=unselected, non-0=selected
// return value: 0 rejected, non-0 accepted
DWORD OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 1;
    DWORD CompId, Id;
    BOOL OriginalState;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);
    OriginalState = gHelperRoutines.QuerySelectionState(
		gHelperRoutines.OcManagerContext,
		SubcomponentId,
		OCSELSTATETYPE_ORIGINAL
		) ;

	//
	// If this is the parent component, the subcomponent will be SC_NONE.  We only
	// allow the state change if we were explicitly selected
	//

	if (Id == SC_NONE) {
		// Parent case
		if ((BOOL)Param1 &&
			(((UINT)(ULONG_PTR)Param2) & OCQ_DEPENDENT_SELECTION) &&
			!(((UINT)(ULONG_PTR)Param2) & OCQ_ACTUAL_SELECTION))
		{
			d = 0;
		}
	} else {
		// Child case

        if (OriginalState == 1)
        {
            if ((BOOL)Param1)
                d = 1;
            else
            {
                // In upgrade case, we don't allow user to uncheck previously
                // installed components
                if ((GetIMSSetupMode() == IIS_SETUPMODE_ADDEXTRACOMPS) ||
                    (theApp.m_eState[Id] == IM_UPGRADE || theApp.m_eState[Id] == IM_UPGRADE10 || theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE20))
                    d = 0;
            }
        }

    }

    DebugOutput(_T("New state is: %s"),d?_T("Accepted"):_T("Rejected"));

    return d;
}


//
// gets called right before we show your page!
//
DWORD OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;

    WizardPagesType PageType = (WizardPagesType)Param1;

    theApp.m_dwSetupMode = GetIMSSetupMode();
    switch (theApp.m_dwSetupMode) {
        case IIS_SETUPMODE_UPGRADEONLY:
        case IIS_SETUPMODE_REMOVEALL:
        case IIS_SETUPMODE_MINIMUM:
        case IIS_SETUPMODE_TYPICAL:
        case IIS_SETUPMODE_REINSTALL:
            d = 1;
            break;

        case IIS_SETUPMODE_ADDREMOVE:
        case IIS_SETUPMODE_CUSTOM:

            // We have to handle Unattended setup here:
            // If unattended, we will skip all wizard pages
            if (theApp.m_fIsUnattended)
            {
                d = 1;
                break;
            }
            // Else fall thru ...

        case IIS_SETUPMODE_ADDEXTRACOMPS:
            break;
    }

    return d;
}


//
// Param1 = 0 if for removing component or non-0 if for adding component
// Param2 = HDSKSPC to operate on
//
// Return value is Win32 error code indicating outcome.
//
// In our case the private section for this component/subcomponent pair
// is a simple standard inf install section, so we can use the high-level
// disk space list api to do what we want.

// HACK: we need to determine which components are active and which
// are not. This determination must occur after OC_QUERY_STATE and
// before OC_REQUEST_PAGES
DWORD OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    DWORD   CompId, Id;
    BOOL    b;
    TCHAR   SectionName[128];
    DWORD   dwErr;


    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    theApp.m_eInstallMode = theApp.DetermineInstallMode(CompId);

    // Logic is not correct here !!!
    //

    if (SubcomponentId) {
        b = TRUE;
        _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));

        if (Param1 != 0) { // add component
            b = SetupAddInstallSectionToDiskSpaceList(
                Param2,
                theApp.m_hInfHandle[CompId],
                NULL,
                SectionName,
                0,0
                );
        } else { // removing component
            b = SetupRemoveInstallSectionFromDiskSpaceList(
                Param2,
                theApp.m_hInfHandle[CompId],
                NULL,
                SectionName,
                0,0
                );
        }

        if (!b)
        {
            dwErr = GetLastError();
        }

        d = b ? NO_ERROR : GetLastError();
    }

    return d;
}


//
// Param1 = unused
// Param2 = HSPFILEQ to operate on
//
// Return value is Win32 error code indicating outcome.
//
// OC Manager calls this routine when it is ready for files to be copied
// to effect the changes the user requested. The component DLL must figure out
// whether it is being installed or uninstalled and take appropriate action.
// For this sample, we look in the private data section for this component/
// subcomponent pair, and get the name of an uninstall section for the
// uninstall case.
//
// Note that OC Manager calls us once for the *entire* component
// and then once per subcomponent. We ignore the first call.
//
DWORD OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    BOOL    b;
    TCHAR   SectionName[128];
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    if (!SubcomponentId)
    {
        // We will setup the proper public directory from IIS private data
        if (! GetInetpubPathFromPrivData(theApp.m_csPathInetpub))
        {
            // Fail to get private data from wwwroot to get inetpub path
            // Try to get it from metabase
            GetInetpubPathFromMD( theApp.m_csPathInetpub );
        }
        SetupSetDirectoryId(theApp.m_hInfHandle[CompId], 32768, theApp.m_csPathInetpub);

        // For unattended setup, we need to change the NntpFile, NntpRoot, and MailRoot
        // based on m_csPathInetpub
        // NT5 - Not just for unattended, we want to set these path no matter what
        SetupMailAndNewsRoot();

        // We will remove all shared files if we are doing a K2 uninstall
        if (GetIMSSetupMode() == IIS_SETUPMODE_REMOVEALL)
        {
            _stprintf(SectionName,TEXT("iis_%s_uninstall"),ComponentId);
            DebugOutput(_T("Queueing <%s>"), SectionName);

            // Remove all shared files
            b = SetupInstallFilesFromInfSection(
                     theApp.m_hInfHandle[CompId],
                     NULL,
                     Param2,
                     SectionName,
                     //theApp.m_csPathSource,     // BUGBUGBUG: Should be NULL!!!
                     NULL,
                     SP_COPY_IN_USE_NEEDS_REBOOT
                     );

            d = b ? NO_ERROR : GetLastError();
        }
    }
    else
    {
        ACTION_TYPE atComp;

        if (Id != SC_NONE)
        {
            // We have a known subcomponent, so process it as such
            // Can be iis_nntp, iis_smtp, iis_nntp_docs, iis_smtp_docs...
            atComp = GetSubcompAction(Id);
            if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REMOVE || atComp == AT_REINSTALL)
                b = TRUE;
            else
                goto OC_QUEUE_FILE_OPS_Func_Exit;
        }
        else
        {
            // If this is not a real subcomponent, nor is it documentation, we
            // break out of the loop. Otherwise we will queue the documentation
            // files
            goto OC_QUEUE_FILE_OPS_Func_Exit;
        }

        _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, (atComp == AT_REMOVE) ? _T("uninstall") : _T("install"));
        DebugOutput(_T("Queueing <%s>"), SectionName);

        UINT uiCopyMode = SP_COPY_IN_USE_NEEDS_REBOOT;

        //  Handles NT5 Beta2-> Beta3 upgrade as well as upgrade between builds in Beta3
        //  If it's not these cases, we do FORCE_NEWER.  Otherwise, we just copy over the new bits.
        //  11/28/98 - FORCE_NEWER seems to be causing more trouble in K2 upgrade as well
        //  since we have 5.5.1774 verion in K2 while 5.0.19xx in NT5.  Take it out!
        //if (atComp != AT_REINSTALL || theApp.m_eState[Id] != IM_UPGRADEB2)
        //    uiCopyMode |= SP_COPY_FORCE_NEWER;

        b = SetupInstallFilesFromInfSection(
                 theApp.m_hInfHandle[CompId],
                 NULL,
                 Param2,
                 SectionName,
                 //theApp.m_csPathSource,     // BUGBUGBUG: should be NULL
                 NULL,
                 uiCopyMode
                 );

        d = b ? NO_ERROR : GetLastError();

        if (atComp != AT_FRESH_INSTALL && atComp != AT_DO_NOTHING) {
        	//
        	// See if we can open the directory.  If we can't, then we
        	// don't bother to delete the files
        	//

        	HANDLE h = CreateFile(
                (LPCTSTR)theApp.m_csPathInetpub,
                GENERIC_WRITE,
                FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL);

            if (h != INVALID_HANDLE_VALUE) {

            	DebugOutput(_T("Removing webadmin"));

            	b = SetupInstallFilesFromInfSection(
                 	theApp.m_hInfHandle[CompId],
                 	NULL,
                 	Param2,
                 	TEXT("remove_webadmin"),
                 	NULL,
                 	uiCopyMode
                 	);

            	d = b ? NO_ERROR : GetLastError();

            	CloseHandle(h);
            } else {
            	DebugOutput(_T("Not removing webadmin, GLE %d"), GetLastError);
            }
        }

        // Handle the MCIS 1.0 upgrade case for mail and news where
        // we delete the old files left over from MCIS 1.0
        if (IsSubcomponentCore(Id))
        {
            if (theApp.m_eState[Id] == IM_UPGRADE10)
            {
                // Establish the section name and queue files for removal
                _stprintf(SectionName,
                            TEXT("%s_mcis10_product_upgrade"),
                            SubcomponentId);
                DebugOutput(_T("Queueing <%s>"), SectionName);
                b = SetupInstallFilesFromInfSection(
                    theApp.m_hInfHandle[CompId],
                    NULL,
                    Param2,
                    SectionName,
                    //theApp.m_csPathSource,      // BUGBUGBUG: should be NULL
                    NULL,
                    0
                    );
            }
        }

    }

OC_QUEUE_FILE_OPS_Func_Exit:

    return d;
}


DWORD OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    return d;
}


DWORD OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    return d;
}


//
// Param1 = unused
// Param2 = unused
//
// Return value is an arbitrary 'step' count or -1 if error.
//
// OC Manager calls this routine when it wants to find out how much
// work the component wants to perform for nonfile operations to
// install/uninstall a component/subcomponent.
// It is called once for the *entire* component and then once for
// each subcomponent in the component.
//
// One could get arbitrarily fancy here but we simply return 1 step
// per subcomponent. We ignore the "entire component" case.
//
DWORD OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 2;

    return d;
}


DWORD OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    TCHAR   SectionName[128];
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    SetCurrentDirectory(theApp.m_csPathInetsrv);
    if (Id == SC_NONE)
    {
        if (!theApp.m_fNTGuiMode)
        {
            if (GetSubcompAction(Id) != AT_DO_NOTHING) {
                BringALLIISClusterResourcesOffline();
                StopServiceAndDependencies(SZ_MD_SERVICENAME, TRUE);
            }
        }
    }
    else if (IsSubcomponentCore(Id))
    {
        // for SC_NNTP & SC_SMTP...
        ACTION_TYPE atComp = GetSubcompAction(Id);
        if (atComp == AT_REMOVE)
        {
            // For each component that we are removing, we will
            // unregister the service.
            switch (Id)
            {
            case SC_SMTP:
                Unregister_iis_smtp();
                RemoveServiceFromDispatchList(SZ_SMTPSERVICENAME);
                break;
            case SC_NNTP:
                Unregister_iis_nntp();
                RemoveServiceFromDispatchList(SZ_NNTPSERVICENAME);
                break;
            }

            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("uninstall"));
            SetupInstallFromInfSection(
                        NULL, theApp.m_hInfHandle[CompId], SectionName,
                        SPINST_REGISTRY, NULL, NULL, //theApp.m_csPathSource,
                        0, NULL, NULL, NULL, NULL );
        }
        else if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REINSTALL)
        {
            // NT5 - We need to unregister mnntpsnp.dll
            // when upgrading from NT4 MCIS20 to NT5 Server

            // in the K2 to MCIS upgrade for NNTP we need to unregister
            // the K2 version of the admin and plug in the MCIS version
            // of it.
            if (Id == SC_NNTP && theApp.m_eState[Id] == IM_UPGRADE20) {
                CString csOcxFile;

                csOcxFile = theApp.m_csPathInetsrv + _T("\\mnntpsnp.dll");
                RegisterOLEControl(csOcxFile, FALSE);
            }

            // If upgrade from MCIS2.0, we need to remove "Use Express" from registry
            // to disable Active Messaging.
            if (Id == SC_SMTP && theApp.m_eState[Id] == IM_UPGRADE20)
            {
                CRegKey regActiveMsg( REG_ACTIVEMSG, HKEY_LOCAL_MACHINE );
                if ((HKEY) regActiveMsg )
                {
                    regActiveMsg.DeleteValue( _T("Use Express"));
                }
            }

            // A new component should be started
            theApp.m_fStarted[CompId] = TRUE;
        }
    }

	CoFreeUnusedLibrariesEx(0, 0);

    gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);

    return d;
}


DWORD OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    TCHAR   SectionName[128];
    BOOL    b;
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    SetCurrentDirectory(theApp.m_csPathInetsrv);
    if (Id != SC_NONE)
    {
        ACTION_TYPE atComp = GetSubcompAction(Id);
        // Here we determine if we need to create or remove the doc links
        if (!IsSubcomponentCore(Id))
        {
            // iis_nntp_docs or iis_smtp_docs...
            // We are processing docs, see if we are adding or removing

            if (atComp == AT_REMOVE || atComp == AT_UPGRADE)
            {
                //
                //  For both AT_REMOVE, or AT_UPGRADE, including K2, MCIS10, or MCIS20
                //  we need to remove these old links.
                //
                if (CompId == MC_IMS)
                {
                    RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MAIL_DOCS,
                                    FALSE);  // NT5 - For SMTP, this is always FALSE for Wks & Srv
                    //  11/30/98 - Don't care what are we upgrading from, just get rid of the link
                    //if (theApp.m_eNTOSType == OT_NTS)
                    {
                        RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MCIS_MAIL_DOCS,
                                    TRUE);
                    }
                }
                else if (CompId == MC_INS)
                {
                    // remove K2 DOC link anyway regardless of MCIS/K2 remove-all
                    RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_NEWS_DOCS,
                                    FALSE);
                    //  11/30/98 - Don't care what are we upgrading from, just get rid of the link
                    //if (theApp.m_eNTOSType == OT_NTS)
                    {
                        RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MCIS_NEWS_DOCS,
                                    TRUE);
                    }
                }

                //
                //  Todo: remove any possible DOC's links created by Setup
                //  during fresh install.
                //
            }
        }
        else // if (!IsSubcomponentCore(Id))
        {
            //  Core components iis_nntp or iis_smtp
            if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REINSTALL)
            {
                b = (atComp == AT_UPGRADE) ? TRUE : FALSE;
                BOOL bReinstall = (atComp == AT_REINSTALL);
                if (atComp == AT_FRESH_INSTALL || theApp.m_eState[Id] == IM_UPGRADE10)
                {
                    // do this only if we are fresh-install, or upgrade from MCIS 1.0
                    // add any freshly installed or upgrading services to
                    // the dispatch list
                    AddServiceToDispatchList(szServiceNames[Id]);
                }

                // Next, we want to create all the required directories
                // for fresh setup
                CreateAllRequiredDirectories(Id);

                // Now, we realized that by stopping and restarting the IISADMIN
                // service we can rid ourselves of a lot of Metabase problems,
                // especially the 80070094 (ERROR_PATH_BUSY) problems

                if (!theApp.m_fNTGuiMode)
                {
                    // BUGBUG: don't stop any services???
                    // We should stop all services only if we are not running GUI Mode setup
                    // Don't want to do that since Spooler may be needed by other
                    // components during setup!!!

                    BringALLIISClusterResourcesOffline();
                    StopServiceAndDependencies(SZ_MD_SERVICENAME, TRUE);
                    InetStartService(SZ_MD_SERVICENAME);
                    Sleep(2000);
                }

                //  Need to decide which functions to call here:
                //  1) Fresh install, or upgrade from MCIS 1.0 - Register_iis_xxxx_nt5
                //  2) Upgrade from NT4 K2, MCIS 2.0 - Register_iis_xxxx_nt5_fromk2( fFromK2 )
                //  3) Upgrade from NT5 Beta2, or Beta3 - Upgrade_iis_xxxx_nt5_fromb2( fBeta2 )
                if (atComp == AT_UPGRADE && (theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE20))
                {
                    //  2) Upgrade from NT4 K2, MCIS 2.0 - Register_iis_xxxx_nt5_fromk2( fFromK2 )
                    BOOL    fFromK2 = (theApp.m_eState[Id] == IM_UPGRADEK2) ? TRUE : FALSE;
                    switch (Id)
                    {
                    case SC_SMTP:
                        Upgrade_iis_smtp_nt5_fromk2( fFromK2 );
                        break;
                    case SC_NNTP:
                        GetNntpFilePathFromMD(theApp.m_csPathNntpFile, theApp.m_csPathNntpRoot);
                        Upgrade_iis_nntp_nt5_fromk2( fFromK2 );
                        break;
                    }
                }
                else if (atComp == AT_REINSTALL && (theApp.m_eState[Id] == IM_UPGRADEB2 || theApp.m_eState[Id] == IM_MAINTENANCE || !theApp.m_fValidSetupString[Id]))
                {
                    //  3) Upgrade from NT5 Beta2, or Beta3 - Upgrade_iis_xxxx_nt5_fromb2( fBeta2 )
                    BOOL    fFromB2 = (theApp.m_eState[Id] == IM_UPGRADEB2) ? TRUE : FALSE;
                    switch (Id)
                    {
                    case SC_SMTP:
                        Upgrade_iis_smtp_nt5_fromb2( fFromB2 );
                        break;
                    case SC_NNTP:
                        Upgrade_iis_nntp_nt5_fromb2( fFromB2 );
                        break;
                    }
                }
                else
                {
                    //  1) Fresh install, or upgrade from MCIS 1.0 - Register_iis_xxxx_nt5
                    switch (Id)
                    {
                    case SC_SMTP:
                        Register_iis_smtp_nt5(b, bReinstall);
                        break;
                    case SC_NNTP:
                        Register_iis_nntp_nt5(b, bReinstall);
                        break;
                    }
                }

                // Update the registry
                _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
                SetupInstallFromInfSection(
                            NULL, theApp.m_hInfHandle[CompId], SectionName,
                            SPINST_REGISTRY, NULL, NULL, //theApp.m_csPathSource,
                            0, NULL, NULL, NULL, NULL );


                // BINLIN: For MCIS 1.0 to NT5 upgrade
                // Perform AddReg/DelReg operation for this upgrade only.
                if (theApp.m_eState[Id] == IM_UPGRADE10)
                {
                    // Establish the section name and queue files for removal
                    _stprintf(SectionName,
                                TEXT("%s_mcis10_product_upgrade"),
                                SubcomponentId);
                    SetupInstallFromInfSection(
                                NULL,
                                theApp.m_hInfHandle[CompId],
                                SectionName,
                                SPINST_REGISTRY,
                                NULL,
                                //theApp.m_csPathSource,
                                NULL,
                                0, NULL, NULL, NULL, NULL );

                    // also remove the control panel add/remove items..
                    // ..and program groups
                    if (Id == SC_SMTP)
                    {
                        RemoveUninstallEntries(SZ_MCIS10_MAIL_UNINST);
                        RemoveMCIS10MailProgramGroup();
                    }
                    else
                    {
                        RemoveUninstallEntries(SZ_MCIS10_NEWS_UNINST);
                        RemoveMCIS10NewsProgramGroup();
                    }
                }
            }
            else if (atComp == AT_REMOVE)
            {
                // A removed component should not be re-started
                theApp.m_fStarted[CompId] = FALSE;
            }

            //
            // start the service if its appropriate
            //
            if (theApp.m_fStarted[CompId]) {
                InetStartService(szServiceNames[CompId]);
                if (Id == SC_NNTP && atComp == AT_FRESH_INSTALL) {
                    // if this is a fresh install than we need to make
                    // the nntp groups
                    CreateNNTPGroups();

                }
            }
        } // if (!IsSubcomponentCore(Id))
    } // if (Id != SC_NONE)

    gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);

    return d;
}


DWORD OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //if (!SubcomponentId)
    {

        if (!theApp.m_fNTGuiMode)
        {

            ServicesRestartList_RestartServices();

        }

    }

    return d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\k2suite.h ===
#ifndef _K2SUITE_H_
#define _K2SUITE_H_

#define IIS_SETUPMODE_UPGRADEONLY	SETUPMODE_UPGRADEONLY
#define IIS_SETUPMODE_ADDEXTRACOMPS	SETUPMODE_ADDEXTRACOMPS

#define IIS_SETUPMODE_ADDREMOVE		SETUPMODE_ADDREMOVE
#define IIS_SETUPMODE_REINSTALL		SETUPMODE_REINSTALL
#define IIS_SETUPMODE_REMOVEALL		SETUPMODE_REMOVEALL

#define IIS_SETUPMODE_MINIMUM		SETUPMODE_MINIMAL
#define IIS_SETUPMODE_TYPICAL		SETUPMODE_TYPICAL
#define IIS_SETUPMODE_CUSTOM		SETUPMODE_CUSTOM

#endif //_K2SUITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\initapp.h ===
#ifndef _INITAPP_H_
#define _INITAPP_H_

typedef PVOID HINF;

class CInitApp : public CObject
{
public:
        CInitApp();
        ~CInitApp();
public:
    int m_err;
    HINSTANCE m_hDllHandle;
    HINF m_hInfHandle[MC_MAXMC];

    // machine status
    CString m_csMachineName;

    CString m_csSysDir;
    CString m_csSysDrive;

    CString m_csPathSource;
    CString m_csPathInetsrv;
    CString m_csPathInetpub;
    CString m_csPathMailroot;
	CString m_csPathNntpRoot;
	CString m_csPathNntpFile;
	BOOL	m_fMailPathSet;
	BOOL	m_fNntpPathSet;

    NT_OS_TYPE m_eNTOSType;
    OS m_eOS;
    BOOL m_fNT4;                // TRUE if OS is NT
    BOOL m_fNT5;                // TRUE if OS is NT
    BOOL m_fW95;                // TRUE if OS is NT

    BOOL m_fTCPIP;               // TRUE if TCP/IP is installed

    UPGRADE_TYPE m_eUpgradeType;       //  UT_NONE, UT_OLDFTP, UT_10, UT_20
    INSTALL_MODE m_eInstallMode;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    DWORD m_dwSetupMode;

	DWORD m_dwCompId;			// Stores the current top-level component
	BOOL  m_fWizpagesCreated;	// TRUE if wizard pages already created

	BOOL m_fActive[MC_MAXMC][SC_MAXSC];
	INSTALL_MODE m_eState[SC_MAXSC];
	BOOL m_fValidSetupString[SC_MAXSC];

	BOOL m_fStarted[MC_MAXMC];

    // Some Specific flags set from ocmanage
    BOOL m_fNTUpgrade_Mode;
    BOOL m_fNTGuiMode;
    BOOL m_fNtWorkstation;
    BOOL m_fInvokedByNT; // superset of m_fNTGuiMode and ControlPanel which contains sysoc.inf


	BOOL m_fIsUnattended;
	BOOL m_fSuppressSmtp;		// TRUE if another SMTP server is detected and we
								// should not install on top of it.

    ACTION_TYPE m_eAction;    // AT_FRESH, AT_ADDREMOVE, AT_REINSTALL, AT_REMOVEALL, AT_UPGRADE

    CString m_csLogFileFormats;

public:
    // Implementation

public:
    BOOL InitApplication();
    BOOL GetMachineStatus();
	INSTALL_MODE DetermineInstallMode(DWORD dwComponent);
    BOOL GetLogFileFormats();

private:
    BOOL GetMachineName();
    BOOL GetSysDirs();
    BOOL GetOS();
    BOOL GetOSVersion();
    BOOL GetOSType();
    BOOL SetInstallMode();
	BOOL DetectPreviousInstallations();
	BOOL CheckForADSIFile();
	BOOL VerifyOSForSetup();
    void SetSetupParams();
};

/////////////////////////////////////////////////////////////////////////////
#endif  // _INITAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\initapp.cpp ===
#include "stdafx.h"
#include "k2suite.h"

#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "mdkey.h"
#include "mdentry.h"

#include "ocmanage.h"

#include "..\..\admin\logui\resource.h"

static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
static TCHAR    szWindowsNTOrg[] = _T("Software\\Microsoft\\Windows NT\\CurrentVersion");

extern void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption);

extern "C"
{
    typedef LONG (*P_NetSetupFindSoftwareComponent)( PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase,     // optional, may be NULL
                PDWORD pcchRegBase ); // optional, NULL if pszRegBase is NULL
}

CInitApp::CInitApp()
{
	DWORD dwMC, dwSC;

    m_err = 0;
    m_hDllHandle = NULL;

	//
    // Establish the type of setup (MCIS / K2) using conditionally-compiled code
    // NT5 - Still leave this member variable here to get setup dll to build.
    // TODO: Get rid of it completely and only use m_eNTOSType and m_eOS.
    //

    // machine status
    m_csMachineName = _T("");

    m_csSysDir = _T("");
    m_csSysDrive = _T("");

    m_csPathSource = _T("");
    m_csPathInetsrv = _T("");  // the primary destination defaults to m_csSysDir\inetsrv
    m_csPathInetpub = _T("");
    m_csPathMailroot = _T("");
    m_csPathNntpRoot = _T("");
    m_csPathNntpFile = _T("");
	m_fMailPathSet = FALSE;
	m_fNntpPathSet = FALSE;

    DWORD   dwType;
    DWORD   dwErr;

    m_eOS = OS_NT;                  // OS_W95, OS_NT, OS_OTHERS
    m_fNT4 = FALSE;                 // TRUE if NT 4.0 (SP2) or greater
    m_fNT5 = FALSE;
    m_fW95 = FALSE;                 // TRUE if Win95 (build xxx) or greater

    m_eNTOSType = OT_NTS;           // OT_PDC, OT_SAM, OT_BDC, OT_NTS, OT_NTW

    m_fTCPIP = FALSE;               // TRUE if TCP/IP is installed

    m_eUpgradeType = UT_NONE;       //  UT_NONE, UT_OLDFTP, UT_10, UT_20
    m_eInstallMode = IM_FRESH;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    m_dwSetupMode = IIS_SETUPMODE_CUSTOM;

	m_fWizpagesCreated = FALSE;

	for (dwSC = 0; dwSC < SC_MAXSC; dwSC++)
	{
		m_eState[dwSC] = IM_FRESH;
		m_fValidSetupString[dwSC] = TRUE;
	}

	for (dwMC = 0; dwMC < MC_MAXMC; dwMC++)
	{
	    m_hInfHandle[dwMC] = NULL;
        m_fStarted[dwMC] = FALSE;

		for (dwSC = 0; dwSC < SC_MAXSC; dwSC++)
			m_fActive[dwMC][dwSC] = FALSE;
	}

    m_fNTUpgrade_Mode=0;
    m_fNTGuiMode=0;
    m_fNtWorkstation=0;
    m_fInvokedByNT = 0;

	m_fIsUnattended = FALSE;
	m_fSuppressSmtp = FALSE;
}

CInitApp::~CInitApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CInitApp object <Global variable>

BOOL CInitApp::GetMachineName()
{
    TCHAR buf[ CNLEN + 10 ];
    DWORD dwLen = CNLEN + 10;

    m_csMachineName = _T("");

    if ( GetComputerName( buf, &dwLen ))
    {
        if ( buf[0] != _T('\\') )
        {
            m_csMachineName = _T("\\");
            m_csMachineName += _T("\\");
        }

        m_csMachineName += buf;

    } else
        m_err = IDS_CANNOT_GET_MACHINE_NAME;

    return ( !(m_csMachineName.IsEmpty()) );
}

// Return TRUE, if NT or Win95
BOOL CInitApp::GetOS()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VerInfo );

    switch (VerInfo.dwPlatformId) {
    case VER_PLATFORM_WIN32_NT:
        m_eOS = OS_NT;
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        m_eOS = OS_W95;
        break;
    default:
        m_eOS = OS_OTHERS;
        break;
    }

    if ( m_eOS == OS_OTHERS )
        m_err = IDS_OS_NOT_SUPPORT;

    return (m_eOS != OS_OTHERS);
}

// Support NT 4.0 (SP2) or greater
BOOL CInitApp::GetOSVersion()
{
    BOOL fReturn = FALSE;

    if ( m_eOS == OS_NT )
    {
        m_fNT4 = FALSE;
        m_fNT5 = FALSE;

        OSVERSIONINFO vInfo;

        vInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx(&vInfo) )
        {
            // check if it's NT5 or NT 4.0 (SP2)
            if ( vInfo.dwMajorVersion >= 4 ) {
                if (vInfo.dwMajorVersion >= 5) {
                    m_fNT5 = TRUE;
                    fReturn = TRUE;
                } else {
                    CRegKey regSP(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Windows"), KEY_READ);
                    if ((HKEY)regSP) {
                        DWORD dwSP = 0;
                        regSP.QueryValue(_T("CSDVersion"), dwSP);
                        if (dwSP < 0x300) {
                            m_err = IDS_NT4_SP3_NEEDED;
                            return FALSE;
                        }
                        if (dwSP >= 0x300) {
                            m_fNT4 = TRUE;
                            fReturn = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (m_eOS == OS_W95)
    {
        fReturn = TRUE;
    }

    if ( !fReturn )
        m_err = IDS_OS_VERSION_NOT_SUPPORTED;

    return (fReturn);
}

// find out it's a NTS, PDC, BDC, NTW, SAM(PDC)
BOOL CInitApp::GetOSType()
{
    BOOL fReturn = TRUE;

    if ( m_eOS == OS_NT )
    {
        // If we are in NT guimode setup
        // then the registry key stuff is not yet setup
        // use the passed in ocmanage.dll stuff to determine
        // what we are installing upon.
        if (theApp.m_fNTGuiMode)
        {
                if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                else {m_eNTOSType = OT_NTS;}
        }
        else
        {
            CRegKey regProductPath( HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\ProductOptions"), KEY_READ);

            if ( (HKEY)regProductPath )
            {
                CString strProductType;
                LONG lReturnedErrCode = regProductPath.QueryValue( _T("ProductType"), strProductType );
                if (lReturnedErrCode == ERROR_SUCCESS)
                {
                    strProductType.MakeUpper();

                    // ToDo: Sam ?
                    if (strProductType == _T("WINNT")) {
                        m_eNTOSType = OT_NTW;
                    }
                    else if (strProductType == _T("SERVERNT"))
                    {
                        m_eNTOSType = OT_NTS;
                    }
                    else if (strProductType == _T("LANMANNT"))
                    {
                        m_eNTOSType = OT_PDC_OR_BDC;
                    }
                    else
                    {
                        fReturn = FALSE;
                    }

#if 0
//
// Replace with above code from iis
//
                    } else {

                        INT err = NERR_Success;
                        BYTE *pBuffer;
                        if ((err = NetServerGetInfo(NULL, 101, &pBuffer)) == NERR_Success) {
                            LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;

                            if (pInfo->sv101_type & SV_TYPE_DOMAIN_CTRL)
                                m_eNTOSType = OT_PDC;
                            else if (pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)
                                m_eNTOSType = OT_BDC;
                            else if (pInfo->sv101_type & SV_TYPE_SERVER_NT)
                                m_eNTOSType = OT_NTS;
                            else
                                fReturn = FALSE;
                        } else {
                            fReturn = FALSE;
                        }
                    }
#endif

                }
                else
                {
                    // Shoot, we can't get the registry key,
                    // let's try using the ocmanage.dll passed in stuff.
                    if (theApp.m_fNTGuiMode)
                    {
                        if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                        else {m_eNTOSType = OT_NTS;}
                    }
                    else
                    {
                        GetErrorMsg(lReturnedErrCode, _T("System\\CurrentControlSet\\Control\\ProductOptions"));
                        m_eNTOSType = OT_NTS; // default to stand-alone NTS
                    }
                }
            }
            else
            {
                // Shoot, we can't get the registry key,
                // let's try using the ocmanage.dll passed in stuff.
                if (theApp.m_fNTGuiMode)
                {
                    if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                    else {m_eNTOSType = OT_NTS;}
                }
                else
                {
                    GetErrorMsg(ERROR_CANTOPEN, _T("System\\CurrentControlSet\\Control\\ProductOptions"));
                    m_eNTOSType = OT_NTS; // default to stand-alone NTS
                }
            }
        }
    }

    if ( !fReturn )
        m_err = IDS_CANNOT_DETECT_OS_TYPE;

    return(fReturn);
}

// Checks for NT Server
BOOL CInitApp::VerifyOSForSetup()
{
	// Make sure we have NT5 Server/Workstation, or NT4 SP3 Server
	if ((m_eOS != OS_NT) ||
		(m_fNT4 && m_eNTOSType == OT_NTW))
	{
        m_err = IDS_NT_SERVER_REQUIRED;
        return FALSE;
	}
	return(TRUE);
}

// Get WinDir and SysDir of the machine
//  WinDir = C:\winnt           SysDir = C:\Winnt\system32
BOOL CInitApp::GetSysDirs()
{
    BOOL fReturn = TRUE;

    TCHAR buf[_MAX_PATH];

    GetSystemDirectory( buf, _MAX_PATH);
    m_csSysDir = buf;

    buf[2] = _T('\0');  // now buf contains the system drive letter
    m_csSysDrive = buf;

    return fReturn;
}

BOOL CInitApp::SetInstallMode()
{
    BOOL fReturn = TRUE;

    m_eInstallMode = IM_FRESH;
    m_eUpgradeType = UT_NONE;

	// We will detect which version of IMS components we
	// have. We will then use that information to see
	// which install mode we should be in
	DetectPreviousInstallations();

    return(fReturn);
}

LPCTSTR aszServiceKeys[SC_MAXSC] =
{
	REG_SMTPPARAMETERS,
	REG_NNTPPARAMETERS,
	REG_SMTPPARAMETERS,
	REG_NNTPPARAMETERS,
};

// Detect previous installations of each component, we use a simple
// approach which checks the servicename\parameter registry value
BOOL CInitApp::DetectPreviousInstallations()
{
	DWORD i;
	DWORD dwMajorVersion = 0;
	DWORD dwMinorVersion = 0;
	INSTALL_MODE eMode = IM_FRESH;

	for (i = 0; i < SC_MAXSC; i++)
	{
		// See if the key is there ...
        CRegKey regSvc(HKEY_LOCAL_MACHINE, aszServiceKeys[i], KEY_READ);
        if ((HKEY)regSvc)
		{
			// Key is there, see if we have the version info
			// If we have version info (2.0), then we have a
			// comparable install (maintenance mode), if the
			// version info is not there, we have an upgrade.
            // Version check
			CString csSetupString;
			LONG lReturn1 = regSvc.QueryValue(_T("MajorVersion"), dwMajorVersion);
			LONG lReturn2 = regSvc.QueryValue(_T("MinorVersion"), dwMinorVersion);
            if (lReturn1 == NERR_Success && lReturn2 == NERR_Success)
			{
				DebugOutput(_T("DetectPreviousInstallations(%s): Version %d.%d"),
					szSubcomponentNames[i], dwMajorVersion, dwMinorVersion);
				// Got the key, just a check to see we have version 3.0 - NT5 Workstation/Server
	            if ((dwMajorVersion == STAXNT5MAJORVERSION) &&
					(dwMinorVersion == STAXNT5MINORVERSION))
                {
                    // This is STAXNT5 Setup on top of STAXNT5, check to see if it's NTW or NTS
                    // a) If we are running NTW setup and NTW is installed, IM_MAINTENANCE
                    // b) If we are running NTS setup and NTS is installed, IM_MAINTENANCE
                    // c) If we are running NTS setup and NTW is installed, IM_UPGRADEK2 (?) - NYI
                    // e) If we are running NTW setup and NTS is installed, IM_MAINTENANCE (?)
                    //

                    //  11/4/98 - Just to cut these cases simplier:
                    //  a) NT5 Beta2 -> NT5 Beta3, IM_UPGRADEB2 - include refresh bits, add keys
                    //  b) NT5 Beta3 -> Nt5 Beta3, IM_MAINTENANCE - only refresh bits

					if (regSvc.QueryValue(_T("SetupString"), csSetupString) == NERR_Success)
					{
						DebugOutput(_T("DetectPreviousInstallations(%s): SetupString=%s"),
							szSubcomponentNames[i], (LPCTSTR)csSetupString);

                        if ((csSetupString == REG_SETUP_STRING_STAXNT5WB2 /*&& OT_NTW == m_eNTOSType*/) ||
                            (csSetupString == REG_SETUP_STRING_STAXNT5SB2 /*&& OT_NTS == m_eNTOSType*/))
						{
							// Upgrade from NT5 Beta2
							eMode = IM_UPGRADEB2;
						}
                        else if ((csSetupString == REG_SETUP_STRING_NT5WKSB3 /*&& OT_NTW == m_eNTOSType*/) ||
                                 (csSetupString == REG_SETUP_STRING_NT5SRVB3 /*&& OT_NTS == m_eNTOSType*/))
                        {
                            //  Upgrade between NT5 Beta3 bits
                            eMode = IM_MAINTENANCE;
                        }
                        else if ((csSetupString == REG_SETUP_STRING_NT5WKS /*&& OT_NTW == m_eNTOSType*/) ||
                                 (csSetupString == REG_SETUP_STRING_NT5SRV /*&& OT_NTS == m_eNTOSType*/))

                        {
                            //  Final release code..
                            eMode = IM_MAINTENANCE;
                        }
                        else
                            {
                            //  Other Setup string - Dump it out and treat it as FRESH
                            DebugOutput(_T("Unknown SetupString <%s>"), csSetupString);
                            eMode = IM_FRESH;
							m_fValidSetupString[i] = FALSE;
                        }
/*
                        else if (csSetupString == REG_SETUP_STRING_STAXNT5WB2 && OT_NTS == m_eNTOSType)
						{
							// Upgrade from NT5 Workstation to NT5 Server
                            // TODO:
                            //   This is NYI since we don't know what we need to do during this upgrade
                            //   But this case is similar to our K2 upgrade to MCIS 2.0.  Use IM_MAINTENANCE
                            //   for now.
							eMode = IM_MAINTENANCE;
						}
						else
						{
							// Downgrade from NT5 Server to NT5 Workstation
                            // TODO:
                            //   We also don't know what to do in this case yet.  Use IM_MAINTENANCE just
                            //   like old MCIS 2.0->K2 downgrade in IIS 4.0.
							eMode = IM_MAINTENANCE;
						}
*/
					}
					else
					{
						// No setup string, ooops, something is wrong,
                        // treat it as fresh
						eMode = IM_FRESH;
						m_fValidSetupString[i] = FALSE;
					}
                }
                else if ((dwMajorVersion == STACKSMAJORVERSION) &&
                         (dwMinorVersion == STACKSMINORVERSION))
                {
                    //
                    // This is upgrading from NT4 MCIS 2.0/K2 to NT5.  We are in this case
                    // only during NT4->NT5 upgrade.
                    // TODO: Handle following upgrade cases:
                    // a) If we are running NT5 Workstation setup, is it valid to upgrade
                    //    from NT4 Server to NT5 Workstation?  It's will be IM_UPGRADE for now.
                    // b) If NT5 Server setup, then it's most likely IM_UPGRADE as well
                    // Need to figure out what need to be done during these upgrade case with IIS
                    //

                    // But first, let's detect if it's upgrading from K2 or MCIS 2.0:
					// a) Read the SetupString from registry
                    // b) If it's prefix with K2, then it's K2, MCIS 2.0, then it's MCIS 2.0
                    //    Note: we only support K2 RTM upgrade
                    // c) For any other cases, force a fresh install

					if (regSvc.QueryValue(_T("SetupString"), csSetupString) == NERR_Success)
					{
						DebugOutput(_T("DetectPreviousInstallations(%s): SetupString=%s"),
							szSubcomponentNames[i], (LPCTSTR)csSetupString);

						CString csMCIS20(REG_SETUP_STRING_MCIS_GEN);
                        if (csSetupString == REG_SETUP_STRING)
                        {
                            // K2 upgrade
                            eMode = IM_UPGRADEK2;
                        }
                        else if ((csSetupString.GetLength() >= csMCIS20.GetLength()) && (csSetupString.Left(csMCIS20.GetLength()) == csMCIS20))
						{
							// MCIS 2.0 upgrade
							eMode = IM_UPGRADE20;
						}
#if 0
                        //  BINLIN - Don't support this anymore, IM_UPGRADEB3 is used for NT5
						else if (csSetupString == REG_B3_SETUP_STRING)
						{
							// Upgrade from Beta 3, we won't support this case
                            // but leave it here for now.
							eMode = IM_UPGRADEB3;
						}
#endif
						else
						{
							// Unsupported setup string, treat it as fresh
							eMode = IM_FRESH;
						}
					}
					else
					{
						// No setup string, treat it as K2 upgrade
                        // Should it be MCIS 2.0, or Fresh install???
						eMode = IM_UPGRADEK2;
					}

				}
                else
                {
                    // Not STAXNT5, nor MCIS 2.0, so we invalidate the install,
                    // whatever that is, and force a clean install.
                    eMode = IM_FRESH;
                }
			}
			else
			{
				// No version key, so we have MCIS 1.0

                // For NT5, this is also upgrade for:
                // a) NT4 MCIS 1.0 -> NT5 Server
                // TODO: ???
				eMode = IM_UPGRADE10;
			}
		}
		else
		{
			// Key is not even there, we consider it a fresh
			// install for this service
			eMode = IM_FRESH;
		}

		// Now we should know which mode we're in, so we can compare
		// the component mode with the global install mode. If they
		// are incompatible (i.e. the registry is inconsistent/screwed
		// up), we have to do coercion and force a clean install on
		// some components.
		//
		// We use the following coercion matrix:
		// -----------------+--------------------------------------
		//     \ Component	|	Fresh		Upgrade		Maintenance
		// Global			|
		// -----------------+--------------------------------------
		//  Fresh           |	OK			Fresh		Fresh
		//  Upgrade         |	OK			OK			Fresh
		//  Maintenance     |	OK			OK			OK
		// -----------------+--------------------------------------
		//
		// If an incompatible pair is detected, the component mode
		// will be coerced to a fresh install, since we cannot trust
		// the original install anymore.
		/*
		if ((m_eInstallMode == IM_FRESH) &&
			(eMode == IM_UPGRADE || eMode == IM_MAINTENANCE))
			eMode = IM_FRESH;
		if ((m_eInstallMode == IM_UPGRADE) &&
			(eMode == IM_MAINTENANCE))
			eMode = IM_FRESH;
		*/

		// Set the component mode if the component is deemed active in
		// OC_QUERY_STATE. If the component is not active, we will
		// indicate it as so.
		m_eState[i] = eMode;
		DebugOutput(_T("DetectPreviousInstallations(%s): %s"),
			szSubcomponentNames[i], szInstallModes[eMode]);
	}
	return TRUE;
}

// This determines the master install mode using the install
// mode of each component
INSTALL_MODE CInitApp::DetermineInstallMode(DWORD dwComponent)
{
	// We will use the following rules to determine the master
	// install mode:
	//
	// 1) If one or more components are in maintenance mode, then
	//    the master mode is IM_MAINTENANCE
	// 2) If (1) is not satisfied and one or more of the
	//    components are in upgrade mode, then the master mode
	//    becomes IM_UPGRADE
	// 3) If both (1) and (2) are not satisfied, the master
	//    install mode becomes IM_FRESH
	DWORD i;

	for (i = 0; i < SC_MAXSC; i++)
		if (m_fActive[dwComponent][i] && m_eState[i] == IM_MAINTENANCE) {
			DebugOutput(_T("DetermineInstallMode(%s:%s): IM_MAINTENANCE"),
				szComponentNames[dwComponent], szSubcomponentNames[i]);
			return(IM_MAINTENANCE);
		}

	for (i = 0; i < SC_MAXSC; i++)
		if (m_fActive[dwComponent][i] &&
            (m_eState[i] == IM_UPGRADE || m_eState[i] == IM_UPGRADEK2 || m_eState[i] == IM_UPGRADE20 || m_eState[i] == IM_UPGRADE10)) {
			DebugOutput(_T("DetermineInstallMode(%s:%s): IM_UPGRADE"),
				szComponentNames[dwComponent], szSubcomponentNames[i]);
			return(IM_UPGRADE);
		}

	DebugOutput(_T("DetermineInstallMode(%s): IM_FRESH"),
		szComponentNames[dwComponent]);

	return(IM_FRESH);
}

// Init/Set m_csGuestName, m_csGuestPassword, destinations
void CInitApp::SetSetupParams()
{
    // init all 4 destinations
    m_csPathInetsrv = m_csSysDir + _T("\\inetsrv");
    m_csPathInetpub = m_csSysDrive + _T("\\Inetpub");
    m_csPathMailroot = m_csPathInetpub + _T("\\mailroot");
    m_csPathNntpFile = m_csPathInetpub + _T("\\nntpfile");
    m_csPathNntpRoot = m_csPathNntpFile + _T("\\root");
    return;
}

BOOL CInitApp::GetMachineStatus()
{
    if ( ( !GetMachineName() )  ||    // m_csMachineName
         ( !GetOS() )           ||    // m_fOSNT
         ( !GetOSVersion() )    ||    // NT 4.0 (Build 1381) or greater
         ( !GetOSType() )       ||    // m_eOSType = NT_SRV or NT_WKS
         ( !VerifyOSForSetup() )||    // Must be NT server v4.0 SP2 or 5.0
         ( !GetSysDirs() )      ||    // m_csSysDir
         ( !SetInstallMode()) )       // errmsg: if down grade the product
    {
        return FALSE;
    }

    SetSetupParams();                // Guest account, destinations

	// figure out the old nntp file and nntp root if this is an NNTP upgrade
	if (m_eState[SC_NNTP] == IM_UPGRADE10) {
		CRegKey regMachine = HKEY_LOCAL_MACHINE;
		CRegKey regNNTP(REG_NNTPPARAMETERS, regMachine);
		if ((HKEY) regNNTP) {
			CString csArtTable;
			CString csVRoot;

			if (regNNTP.QueryValue(_T("ArticleTableFile"), csArtTable) == ERROR_SUCCESS) {
				// trim off the \article.hsh from the end
				int iLastSlash = csArtTable.ReverseFind('\\');
				if (iLastSlash == -1) {
					iLastSlash = csArtTable.ReverseFind('/');
				}

				if (iLastSlash > 1) {
					theApp.m_csPathNntpFile = csArtTable.Left(iLastSlash);
				}
			}

			// BUGBUG - later on we might want to get NNTP root too.  right
			// now it isn't used for upgraded values, so we don't bother
			// we'll set it to be under nntpfile just in case it is needed
			// for something
			theApp.m_csPathNntpRoot = theApp.m_csPathNntpFile + "\\root";
		}
	}

    return TRUE;
}

BOOL CInitApp::InitApplication()
// Return Value:
// TRUE: application is initiliazed correctly, continue processing
// FALSE: application is missing some required parameters, like the correct OS, TCPIP, etc.
//        setup should be terminated.
{
    BOOL fReturn = FALSE;

    do {
        if (!RunningAsAdministrator())
        {
            PopupOkMessageBox(IDS_NOT_ADMINISTRATOR, _T("Error"));
            break;
        }

        // Get Machine Status:
        // m_eInstallMode(Fresh, Maintanence, Upgrade, Degrade),
        // m_eUpgradeType(PROD 2.0, PROD 3.0)

        if ( !GetMachineStatus() )
        {
            PopupOkMessageBox(m_err, _T("Error"));
            break;
        }

        fReturn = TRUE;

    } while (0);

    return fReturn;
}

BOOL
CInitApp::GetLogFileFormats() {

    const DWORD cLogResourceIds = 4;

    static const DWORD dwLogResourceIds[cLogResourceIds] = {
        IDS_MTITLE_NCSA,
        IDS_MTITLE_ODBC,
        IDS_MTITLE_MSFT,
        IDS_MTITLE_XTND
    };

    const DWORD cStringLen = 512;
    TCHAR str[cStringLen];

    HINSTANCE hInstance;
    CString csLogUiPath;

    m_csLogFileFormats = "";
    csLogUiPath = m_csPathInetsrv + _T("\\logui.ocx");

    hInstance = LoadLibraryEx((LPCTSTR)csLogUiPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hInstance == NULL)
        return FALSE;

    for (DWORD i=0; i<cLogResourceIds; i++) {
        if (LoadString(hInstance, dwLogResourceIds[i], str, cStringLen) != 0) {
            if (!m_csLogFileFormats.IsEmpty())
                m_csLogFileFormats += _T(",");
            m_csLogFileFormats += str;
        }
    }

    FreeLibrary(hInstance);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\log.h ===
#include <Windows.h>
#include <io.h>
#include <stdio.h>
#include <time.h>
#include <direct.h>
#include <prsht.h>
#include <commctrl.h>
#include <regstr.h>
#include <objbase.h>
#include <winnetwk.h>
#include <tchar.h>
#include <shlobj.h>
#include <shellapi.h>

#include "stdafx.h"
#include "resource.h"

// Stuff for logfile
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );

class MyLogFile
{
protected:
	// for our log file
	TCHAR		m_szLogFileName[MAX_PATH];

	// logfile2
	HANDLE  m_hFile;

public:
    TCHAR		m_szLogFileName_Full[MAX_PATH];

    MyLogFile();
    ~MyLogFile();

	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileWrite(TCHAR * pszFormatString, ...);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\log.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "log.h"


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;
BOOL	fLogCriticalSectionInited = FALSE;

//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));

	m_hFile = NULL;
	
	// initialize the critical section
	fLogCriticalSectionInited = FALSE;
	if( InitializeCriticalSectionAndSpinCount( &critical_section, 0 ) ) 
		fLogCriticalSectionInited = TRUE;
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	if (fLogCriticalSectionInited)
		DeleteCriticalSection( &critical_section );
	fLogCriticalSectionInited = FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
	TCHAR szDrive_only[_MAX_DRIVE];
	TCHAR szPath_only[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];
	TCHAR szFilename_bak[_MAX_PATH];

	if (!fLogCriticalSectionInited) return FALSE;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
		TCHAR szModuleFileName[_MAX_PATH];

		// if a logfilename was not specified then use the module name.
		GetModuleFileName(NULL, szModuleFileName, _MAX_PATH);

		// get only the filename
		_tsplitpath( szModuleFileName, NULL, NULL, szFilename_only, NULL);
		_tcscat(szFilename_only, _T(".LOG"));

		_tcscpy(m_szLogFileName, szFilename_only);
	}
	else
	{
		_tcscpy(m_szLogFileName, lpLogFileName);
	}

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)/sizeof(m_szLogFileName_Full[0])))
    {
        AddPath(m_szLogFileName_Full, m_szLogFileName);
        if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
			_tsplitpath( m_szLogFileName_Full, szDrive_only, szPath_only, szFilename_only, NULL);

			_tcscpy(szFilename_bak, szDrive_only);
			_tcscat(szFilename_bak, szPath_only);
			_tcscat(szFilename_bak, szFilename_only);
            _tcscat(szFilename_bak, _T(".BAK"));

            SetFileAttributes(szFilename_bak, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szFilename_bak);
            if (MoveFile(m_szLogFileName_Full, szFilename_bak) == 0)
			{
				// This failed
                MyMessageBox(NULL,_T("LogFile MoveFile Failed"),_T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
			}
        }

		// Open existing file or create a new one.
		m_hFile = CreateFile(m_szLogFileName_Full,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
		{
			m_hFile = NULL;
			MyMessageBox(NULL, _T("Unable to create log file iis5.log"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		}
		else 
		{
			iReturn = TRUE;
		}

		LogFileWrite(_T("LogFile Open.\r\n"));
	}


	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{

	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
		return TRUE;
	}

	return FALSE;
}

//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{

    if (m_hFile)
    {
		// because of the global flags and such, we'll make this critical
		EnterCriticalSection( &critical_section );

		va_list args;
		const DWORD cchBufferSize = 1000;
		TCHAR pszFullErrMsg[cchBufferSize];
		char   pszFullErrMsgA[cchBufferSize+2];	// Room for the CRLF, just in case
		pszFullErrMsgA[0] = '\0';

		DWORD dwBytesWritten = 0;

        va_start(args, pszFormatString);
		_vsntprintf(pszFullErrMsg, cchBufferSize, pszFormatString, args); 
		pszFullErrMsg[cchBufferSize-1] = '\0';
		va_end(args);

        if (*pszFullErrMsg)
        {

			// convert to ascii then write to stream
		    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, sizeof(pszFullErrMsgA), NULL, NULL );

			// Get timestamp
			SYSTEMTIME  SystemTime;
			GetLocalTime(&SystemTime);
			char szDateandtime[50];
			sprintf(szDateandtime,"[%d/%d/%d %2.2d:%2.2d:%2.2d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
			// Write time to stream
			if (m_hFile) {
				WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);
			if (nLen < 2) {
				nLen = 2;
				strcpy(pszFullErrMsgA, "\r\n");
			} else if (pszFullErrMsgA[nLen-1] != '\n') {
				strcat(pszFullErrMsgA, "\r\n");
			} else if (pszFullErrMsgA[nLen-2] != '\r') {
				char * pPointer = NULL;
				pPointer = pszFullErrMsgA + (nLen-1);
				strcpy(pPointer, "\r\n");
			}

			// Write Regular data to stream
			if (m_hFile) {
				WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);
			}
        }

		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\mdentry.cpp ===
#include "stdafx.h"

#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"

#include "setupapi.h"
#include "elem.h"
#include "mdentry.h"
#include "inetinfo.h"
#include "helper.h"

DWORD atodw(LPCTSTR lpszData)
{
    DWORD i = 0, sum = 0;
    TCHAR *s, *t;

    s = (LPTSTR)lpszData;
    t = (LPTSTR)lpszData;

    while (*t)
        t++;
    t--;

    if (*s == _T('0') && (*(s+1) == _T('x') || *(s+1) == _T('X')))
        s += 2;

    while (s <= t) {
        if ( *s >= _T('0') && *s <= _T('9') )
            i = *s - _T('0');
        else if ( *s >= _T('a') && *s <= _T('f') )
            i = *s - _T('a') + 10;
        else if ( *s >= _T('A') && *s <= _T('F') )
            i = *s - _T('A') + 10;
        else
            break;

        sum = sum * 16 + i;
        s++;
    }
    return sum;
}

#define MAX_FIELDS  12
#define FIELD_SEPERATOR   _T("\t")
LPTSTR field[MAX_FIELDS];
BYTE g_DataBuf[1024 * 16];
DWORD g_dwValue;

// Split a line of entry into 10 fields for MDEntry datatype
BOOL SplitLine(LPTSTR szLine)
{
    int i = 0;
    TCHAR *token;

    token = _tcstok(szLine, FIELD_SEPERATOR);
    while (token && i < MAX_FIELDS) {
        field[i++] = token;
        token = _tcstok(NULL, FIELD_SEPERATOR);
    }

    if (i == MAX_FIELDS)
        return TRUE;
    else
	{
		SetLastError(ERROR_INVALID_DATA);
        return FALSE;
	}
}

// Fill in the structure of MDEntry
BOOL SetupMDEntry(LPTSTR szLine, BOOL fUpgrade)
{
    BOOL fMigrate;
    BOOL fKeepOldReg;
    HKEY hRegRootKey;
    LPTSTR szRegSubKey;
    LPTSTR szRegValueName;
	LPBYTE pbData = g_DataBuf;
	DWORD cbData;
	static TCHAR szMDPath[MAX_PATH];
	MDEntry mdentry, *pMDEntry = &mdentry;
	DWORD dwIndex=0;
	TCHAR pszEnumName[MAX_PATH];
	DWORD cbEnumName = sizeof(pszEnumName);
	BOOL fDoSet;
	BOOL fSetOnlyIfNotPresent;

    if (!SplitLine(szLine))
        return FALSE;

    if ( lstrcmp(field[0], _T("1")) == 0) {
        fMigrate = (TRUE && fUpgrade);
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = FALSE;
	} else if (lstrcmp(field[0], _T("2")) == 0) {
        fMigrate = (TRUE && fUpgrade);
		fDoSet = FALSE;
		fSetOnlyIfNotPresent = FALSE;
	} else if (lstrcmp(field[0], _T("4")) == 0) {
        fMigrate = FALSE;
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = TRUE;
    } else {
        fMigrate = FALSE;
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = FALSE;
	}

    if ( lstrcmp(field[1], _T("1")) == 0)
        fKeepOldReg = TRUE;
    else
        fKeepOldReg = FALSE;

    if (lstrcmpi(field[2], _T("HKLM")) == 0)
        hRegRootKey = HKEY_LOCAL_MACHINE;
    else if (lstrcmpi(field[2], _T("HKCR")) == 0)
        hRegRootKey = HKEY_CLASSES_ROOT;
    else if (lstrcmpi(field[2], _T("HKCU")) == 0)
        hRegRootKey = HKEY_CURRENT_USER;
    else if (lstrcmpi(field[2], _T("HKU")) == 0)
        hRegRootKey = HKEY_USERS;
    else
        hRegRootKey = HKEY_LOCAL_MACHINE;

    szRegSubKey = field[3];
    szRegValueName = field[4];

    pMDEntry->szMDPath = field[5];
    pMDEntry->dwMDIdentifier = _ttoi(field[6]);
    pMDEntry->dwMDAttributes = atodw(field[7]);
    pMDEntry->dwMDUserType = _ttoi(field[8]);
    pMDEntry->dwMDDataType = _ttoi(field[9]);
    pMDEntry->dwMDDataLen = _ttoi(field[10]);

    DebugOutput(_T("SetupMDEntry(): szLine: field[4]=%s, [5]=%s, [6]=%s"), field[4], field[5], field[6]);

    if ( pMDEntry->dwMDDataType == DWORD_METADATA ) {
        g_dwValue = atodw(field[11]);
        pMDEntry->pbMDData = (LPBYTE) &g_dwValue;

    } else if ( pMDEntry->dwMDDataType == BINARY_METADATA ) {

		BYTE	rgbBinaryBuf[4096];
		TCHAR	rgtcByteValue[3] = { _T('\0'), _T('\0'), _T('\0') };
		LPTSTR	pbBinary = field[11];
		DWORD	dwCount = lstrlen(pbBinary);
		DWORD	dwLen = 0;

		if ((dwCount+1)/2 > sizeof(rgbBinaryBuf))
			return FALSE;

		// Convert to binary data:
		// "000102030405ff06" becomes
		// BYTE [] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0xff, 0x06 }
		while (dwCount)
		{
			if (dwCount == 1)
			{
				rgtcByteValue[0] = *pbBinary++;
				rgtcByteValue[1] = _T('\0');
				dwCount--;
			}
			else
			{
				rgtcByteValue[0] = *pbBinary++;
				rgtcByteValue[1] = *pbBinary++;
				dwCount -= 2;
			}

			rgbBinaryBuf[dwLen++] = (BYTE)atodw(rgtcByteValue);
		}
			
		// Set the records straight
		pMDEntry->pbMDData = rgbBinaryBuf;
        pMDEntry->dwMDDataLen = dwLen;

    } else {
		TCHAR szStringBuf[4096];
		TCHAR *pszStringData = field[11];

		*szStringBuf = 0;
		//
		// do env substitution if necessary
		//	
		int iStart, iEnd = 0;
		do {
			for (iStart = iEnd; pszStringData[iStart] != 0; iStart++) {
				if (pszStringData[iStart] == _T('%')) break;
			}
			if (pszStringData[iStart] != 0) {
				// copy from the last substitution to here
				pszStringData[iStart] = 0;
				lstrcat(szStringBuf, pszStringData + iEnd);
				pszStringData[iStart] = _T('%');
				// find the end %
				for (iEnd = iStart + 1; pszStringData[iEnd] != 0; iEnd++) {
					if (pszStringData[iEnd] == _T('%')) break;
				}
				if (iStart + 1 == iEnd) {
					// found %%, replace with %
					lstrcat(szStringBuf, _T("%"));
					iEnd++;
				} else if (pszStringData[iEnd] != 0) {
					// do the substitution
					pszStringData[iEnd] = 0;
					DWORD cbBuf = lstrlen(szStringBuf);
					GetEnvironmentVariable(pszStringData + iStart + 1,
									       szStringBuf+cbBuf,
										   sizeof(szStringBuf)/sizeof(szStringBuf[0])-cbBuf);
					pszStringData[iEnd] = _T('%');
					iEnd++;
				} else {
					// no ending %, copy the rest
					lstrcat(szStringBuf, pszStringData + iStart);
				}
			}
		} while (pszStringData[iStart] != 0);
		lstrcat(szStringBuf, pszStringData + iEnd);
		lstrcpy(pszStringData, szStringBuf);

		pMDEntry->pbMDData = (LPBYTE)pszStringData;
    }

	BOOL fMore = TRUE;
	while (fMore) {
		//
		// reg enumeration support
		//
		TCHAR szBuf[MAX_PATH + 1];
		LPTSTR szRegKey = szBuf;
		// see if there is an '*' in the szRegSubKey field
		int iStar;
		for (iStar = 0; szRegSubKey[iStar] != 0; iStar++) {
			if (szRegSubKey[iStar] == _T('*')) break;
		}
		if (szRegSubKey[iStar] != 0 && (szRegSubKey[iStar + 1] == _T('\\') ||
										szRegSubKey[iStar + 1] == 0))
		{
			DWORD ec;
			HKEY hKey = NULL;
	
			// copy the base
			szRegSubKey[iStar] = 0;
			lstrcpy(szRegKey, szRegSubKey);
			szRegSubKey[iStar] = _T('*');
			// open the key
			ec = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
			if (ec == ERROR_SUCCESS) {
				// do an enum to find out what we should be opening
				cbEnumName = sizeof(pszEnumName) / sizeof(pszEnumName[0]);
				ec = RegEnumKeyEx(hKey, dwIndex++, pszEnumName, &cbEnumName,
								  NULL, NULL, 0, NULL);
				if (ec != ERROR_SUCCESS) {
					fMore = FALSE;
					RegCloseKey(hKey);
					continue;
				} else {
					fMore = TRUE;
				}
				lstrcat(szRegKey, pszEnumName);
				if (szRegSubKey[iStar + 1] != 0)
					lstrcat(szRegKey, szRegSubKey + iStar + 1);
				RegCloseKey(hKey);
			} else {
				// couldn't open key
				lstrcpy(szRegKey, szRegSubKey);
				fMore = FALSE;
			}
		} else {
			// no star
			lstrcpy(szRegKey, szRegSubKey);
			fMore = FALSE;
		}
			
	    // migrate if necessary
	    if (fMigrate) {
		    HKEY hKey = NULL;
			LONG err = ERROR_SUCCESS;
			DWORD dwType = 0;
			cbData = sizeof(g_DataBuf);
			err = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
			if ( err == ERROR_SUCCESS ) {
		        err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, pbData, &cbData);
				if (err == ERROR_MORE_DATA) {
#ifdef DEBUG
					DebugBreak();
#endif
				}
	            if ( err == ERROR_SUCCESS)
				{
	                pMDEntry->pbMDData = pbData;
	                pMDEntry->dwMDDataLen = cbData;
					fDoSet = TRUE;
	            }
	
	            if (fKeepOldReg == FALSE)
	                err = RegDeleteValue(hKey, szRegValueName);
	
	            RegCloseKey(hKey);
	        }
	    } else if (fKeepOldReg == FALSE) {
	        HKEY hKey = NULL;
	        LONG err = ERROR_SUCCESS;
	        DWORD dwType = 0;
	        err = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
	        if ( err == ERROR_SUCCESS ) {
	            err = RegDeleteValue(hKey, szRegValueName);
	            RegCloseKey(hKey);
	        }
	    }
	
	    switch (pMDEntry->dwMDDataType) {
	    case DWORD_METADATA:
	        pMDEntry->dwMDDataLen = 4;
	        break;
	    case STRING_METADATA:
	    case EXPANDSZ_METADATA:
	        pMDEntry->dwMDDataLen = (lstrlen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
	        break;
	    case MULTISZ_METADATA:
			// We only allow a single string even for a multi-sz.
			pMDEntry->dwMDDataLen = (lstrlen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);

			// Append the second NULL and bump the length by one at the same time
			*(LPTSTR)((LPBYTE)pMDEntry->pbMDData + pMDEntry->dwMDDataLen) = _T('\0');
			pMDEntry->dwMDDataLen += sizeof(TCHAR);
			break;
	    case BINARY_METADATA:
			// Everything is set upstream
	        break;
	    }

		if (fDoSet) {
			SetMDEntry(pMDEntry, pszEnumName, fSetOnlyIfNotPresent);
		}
	}

    return TRUE;
}

void SetMDEntry(MDEntry *pMDEntry, LPTSTR pszEnumName, BOOL fSetOnlyIfNotPresent)
{
    CMDKey cmdKey;
    BOOL fSet = TRUE;

	TCHAR szBuf[MAX_PATH + 1];
	LPTSTR szMDPath = szBuf;
	
    DebugOutput(_T("SetMDEntry(): pMDEntry=0x%x"), pMDEntry);

    if (pszEnumName != NULL) {
		// see if there is an '*' in the szMDPath field
		int iStar;
		for (iStar = 0; pMDEntry->szMDPath[iStar] != 0; iStar++) {
			if (pMDEntry->szMDPath[iStar] == _T('*')) break;
		}
		if (pMDEntry->szMDPath[iStar] != 0 && (pMDEntry->szMDPath[iStar + 1] == _T('\\') ||
											   pMDEntry->szMDPath[iStar + 1] == 0))
		{
			// copy the base
			pMDEntry->szMDPath[iStar] = 0;
			lstrcpy(szMDPath, pMDEntry->szMDPath);
			pMDEntry->szMDPath[iStar] = _T('*');
			// copy the substitued path
			lstrcat(szMDPath, pszEnumName);
			// finish the copy
			if (pMDEntry->szMDPath[iStar + 1] != 0)
				lstrcat(szMDPath, pMDEntry->szMDPath + iStar + 1);
		} else {
			// no star
			szMDPath = pMDEntry->szMDPath;
		}
	} else {
		szMDPath = pMDEntry->szMDPath;
	}
	
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)szMDPath);
    if ( (METADATA_HANDLE)cmdKey ) {
        BYTE pbData[32];
        DWORD dwAttr, dwUType, dwDType;
        DWORD dwLen=sizeof(pbData);
        if (fSetOnlyIfNotPresent && cmdKey.GetData(
            pMDEntry->dwMDIdentifier,
            &dwAttr,
            &dwUType,
            &dwDType,
            &dwLen,
            pbData)) {
            fSet = FALSE;
        }
        if (fSet) {
            cmdKey.SetData(
                pMDEntry->dwMDIdentifier,
                pMDEntry->dwMDAttributes,
                pMDEntry->dwMDUserType,
                pMDEntry->dwMDDataType,
                pMDEntry->dwMDDataLen,
                pMDEntry->pbMDData);
        }
        cmdKey.Close();
    }

    return;
}

void MigrateIMSToMD(HINF hInf, LPCTSTR szServerName,
					LPCTSTR szSection,
					DWORD dwRoutingSourcesMDID,
					BOOL fUpgrade,
					BOOL k2UpgradeToEE)
{
	TCHAR buf[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;

	CString csDefaultSiteName;

	DebugOutput(_T("MigradeIMSToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

	GetComputerName(buf, &dwLen);

    AddVRootsToMD(szServerName, fUpgrade);

    // Migrate Virtual Roots and routing sources only on upgrade case
	if (fUpgrade && !k2UpgradeToEE)
	{
		MigrateRoutingSourcesToMD(szServerName, dwRoutingSourcesMDID);
	}

    theApp.GetLogFileFormats();

	MyLoadString(IDS_SMTP_DEFAULT_SITE_NAME, csDefaultSiteName);

	SetEnvironmentVariable(_T("__INETPUB"), theApp.m_csPathInetpub);
	SetEnvironmentVariable(_T("__MAILROOT"), theApp.m_csPathMailroot);
	SetEnvironmentVariable(_T("__EQUALS"), _T("="));
	SetEnvironmentVariable(_T("__EMPTY"), _T(""));
	SetEnvironmentVariable(_T("__SEMICOL"), _T(";"));
	SetEnvironmentVariable(_T("__SMTP_DEFAULT_SITE_NAME"), csDefaultSiteName);
	SetEnvironmentVariable(_T("__SMTP_LOG_FILE_FORMATS"), theApp.m_csLogFileFormats);
	SetEnvironmentVariable(_T("__MACHINENAME"), buf);

    MigrateInfSectionToMD(hInf, szSection, fUpgrade);

	if (!fUpgrade && !k2UpgradeToEE)
	{
		// If we are not upgrading, we will have to install the default
		// Mailroots and routing sources
		CString csFreshSection = szSection;
		csFreshSection += _T("_FRESH");
	    MigrateInfSectionToMD(hInf, (LPCTSTR)csFreshSection, fUpgrade);
	}

	SetEnvironmentVariable(_T("__INETPUB"), NULL);
	SetEnvironmentVariable(_T("__MAILROOT"), NULL);
	SetEnvironmentVariable(_T("__EQUALS"), NULL);
	SetEnvironmentVariable(_T("__EMPTY"), NULL);
	SetEnvironmentVariable(_T("__SEMICOL"), NULL);
	SetEnvironmentVariable(_T("__SMTP_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__SMTP_LOG_FILE_FORMATS"), NULL);
	SetEnvironmentVariable(_T("__MACHINENAME"), NULL);

}

void MigrateNNTPToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade)
{
	TCHAR buf[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;

	DebugOutput(_T("MigradeNNTPToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

    GetComputerName(buf, &dwLen);

    // About Virtual Roots
    AddVRootsToMD(_T("NNTPSVC"), fUpgrade);

	CString csDefaultSiteName;
	CString csServiceName;
	CString csAdminName;
	CString csAdminEmail;

	MyLoadString(IDS_NNTP_DEFAULT_SITE_NAME, csDefaultSiteName);
	MyLoadString(IDS_NNTP_SERVICE_NAME, csServiceName);
	MyLoadString(IDS_NNTP_DEFAULT_ADMIN_NAME, csAdminName);
	MyLoadString(IDS_NNTP_DEFAULT_ADMIN_EMAIL, csAdminEmail);

    theApp.GetLogFileFormats();

	SetEnvironmentVariable(_T("__NNTPFILE"), theApp.m_csPathNntpFile);
	SetEnvironmentVariable(_T("__NNTPROOT"), theApp.m_csPathNntpRoot);
	SetEnvironmentVariable(_T("__MACHINENAME"), buf);
	SetEnvironmentVariable(_T("__INETPUB"), theApp.m_csPathInetpub);
	SetEnvironmentVariable(_T("__EMPTY"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_SITE_NAME"), csDefaultSiteName);
	SetEnvironmentVariable(_T("__NNTP_SERVICE_NAME"), csServiceName);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_NAME"), csAdminName);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_EMAIL"), csAdminEmail);
	SetEnvironmentVariable(_T("__NNTP_LOG_FILE_FORMATS"), theApp.m_csLogFileFormats);

    MigrateInfSectionToMD(hInf, szSection, fUpgrade);

	SetEnvironmentVariable(_T("__NNTPFILE"), NULL);
	SetEnvironmentVariable(_T("__NNTPROOT"), NULL);
	SetEnvironmentVariable(_T("__MACHINENAME"), NULL);
	SetEnvironmentVariable(_T("__INETPUB"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_SERVICE_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_EMAIL"), NULL);
	SetEnvironmentVariable(_T("__NNTP_LOG_FILE_FORMATS"), NULL);
}

void CreateVRMap(CMapStringToOb *pMap, LPCTSTR szVRootRegKey, LPCTSTR szRootDir, DWORD dwMdFlags, BOOL fUpgrade)
{
    CMapStringToString *pGlobalObj;

    DebugOutput(_T("CreateVRMap(): pMap=0x%x, szVRootRegKey=%s, szRootDir=%s, dwMdFlags=%d, fUpgrade=%d"), pMap, szVRootRegKey, szRootDir, dwMdFlags, fUpgrade);

    if (fUpgrade) {
        CElem elem;
        elem.ReadRegVRoots(szVRootRegKey, pMap);
    }

    if (pMap->IsEmpty() || pMap->Lookup(_T("null"), (CObject*&)pGlobalObj) == FALSE)
	{
        CString ip, name, value;
        CMapStringToString *pNew;
        pNew = new CMapStringToString;
        if (pNew != NULL) {
	        ip = _T("null");
	        name = _T("/");
	        value.Format(_T("%s,,%d"), szRootDir, dwMdFlags);
	        pNew->SetAt(name, value);

	        pMap->SetAt(ip, pNew);
        }
    }
}

void MigrateInfSectionToMD(HINF hFile, LPCTSTR szSection, BOOL fUpgrade)
{
    TCHAR szLine[3 * 1024];		// So SetupMDEntry won't cause problems
    DWORD dwLineLen = 0, dwRequiredSize;
	DWORD dwIndex = 0;

    BOOL b = FALSE;

    INFCONTEXT Context;

    DebugOutput(_T("MigrateInfSectionToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

    b = SetupFindFirstLine(hFile, szSection, NULL, &Context);
    if (!b) return;

    while (b) {
		BOOL fLoop = TRUE;
#ifdef DEBUG
        b = SetupGetLineText(&Context, NULL, NULL,
							NULL, NULL, 0, &dwRequiredSize);
		_ASSERT(dwRequiredSize < sizeof(szLine));
#endif
		ZeroMemory(szLine, sizeof(szLine));
        if (SetupGetLineText(&Context, NULL, NULL,
							 NULL, szLine, sizeof(szLine)/sizeof(szLine[0]), NULL) == FALSE)
		{
			// We're done
            return;
		}

		dwIndex++;
		if (!SetupMDEntry(szLine, fUpgrade))
		{
			// If this fails we wiil not set up metabase stuff.
			_stprintf(szLine, TEXT("SplitLine [%s] line %u"),
						szSection, dwIndex);
			SetErrMsg(szLine, GetLastError());
		}

        b = SetupFindNextLine(&Context, &Context);
    }

    return;
}

void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm)
{
    // csValue should be in format of "<path>,<username>,<perm>"
    CString csPath, csUserName;
    int i;

    DebugOutput(_T("SplitVRString(): csValue=%s, szPath=%s, szUserName=%s"), csValue, szPath, szUserName);

    csValue.TrimLeft();
    csValue.TrimRight();
    csPath = csValue;
    csUserName = _T("");
    *pdwPerm = 0;

    i = csValue.Find(_T(","));
    if (i != -1) {
        csPath = csValue.Mid(0, i);
        csPath.TrimRight();

        csValue = csValue.Mid(i+1);
        csValue.TrimLeft();

        i = csValue.Find(_T(","));
        if (i != -1) {
            csUserName = csValue.Mid(0, i);
            csUserName.TrimRight();
            csValue = csValue.Mid(i+1);
            csValue.TrimLeft();
            *pdwPerm = (DWORD)_ttoi((LPCTSTR)csValue);
        }
    }

    lstrcpyn(szPath, (LPCTSTR)csPath,_MAX_PATH);
    lstrcpyn(szUserName, (LPCTSTR)csUserName,_MAX_PATH);
    return;
}

void ApplyGlobalToMDVRootTree(CString csKeyPath, CMapStringToString *pGlobalObj)
{
    DebugOutput(_T("ApplyGlobalToMDVRootTree(): csKeyPath=%s, pGlobalObj=0x%x"), csKeyPath, pGlobalObj);

    if (pGlobalObj->GetCount() == 0)
        return;

    POSITION pos = pGlobalObj->GetStartPosition();
    while (pos) {
        BOOL fSkip = FALSE;
        CMDKey cmdKey;
        CString csName, csValue, csPath;

        pGlobalObj->GetNextAssoc(pos, csName, csValue);
        csPath = csKeyPath;
        if (csName.GetLength() > 0 && csName.Compare(_T("/")) != 0)
        {
            csPath += _T("/");
            csPath += csName; // LM/*SVC/N//iisadmin
        }

        cmdKey.OpenNode(csPath);
        if ( (METADATA_HANDLE)cmdKey ) {
            if (csName.Compare(_T("/")) == 0) {
                if (cmdKey.IsEmpty() == FALSE)
                    fSkip = TRUE;
            } else {
                fSkip = TRUE;
            }
            cmdKey.Close();
        }

        if ( !fSkip ) {
            CreateMDVRootTree(csKeyPath, csName, csValue);
        }
    }
}
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue)
{
    CMDKey cmdKey;

    DebugOutput(_T("CreateMDVRootTree(): csKeyPath=%s, csName=%s, csValue=%s"), csKeyPath, csName, csValue);

    csKeyPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
        csKeyPath += csName;   // LM/W3SVC/N/Root/iisadmin
    csKeyPath.MakeUpper();

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) {
        TCHAR szPath[_MAX_PATH], szUserName[_MAX_PATH];
        DWORD dwPerm;

        memset( (PVOID)szPath, 0, sizeof(szPath));
        memset( (PVOID)szUserName, 0, sizeof(szUserName));
        SplitVRString(csValue, szPath, szUserName, &dwPerm);
        cmdKey.SetData(
            MD_VR_PATH,
            METADATA_INHERIT,
            IIS_MD_UT_FILE,
            STRING_METADATA,
            (lstrlen(szPath) + 1) * sizeof(TCHAR),
            (LPBYTE)szPath);

		if (szUserName[0] != _T('\0')) { // do have username and path is UNC
            cmdKey.SetData(
                MD_VR_USERNAME,
                METADATA_INHERIT,
                IIS_MD_UT_FILE,
                STRING_METADATA,
                (lstrlen(szUserName) + 1) * sizeof(TCHAR),
                (LPBYTE)szUserName);
        }
        cmdKey.SetData(
            MD_ACCESS_PERM,
            METADATA_INHERIT,
            IIS_MD_UT_FILE,
            DWORD_METADATA,
            4,
            (LPBYTE)&dwPerm);

        cmdKey.Close();
    }
}

int GetMultiStrLen(LPTSTR p)
{
    int c = 0;

    while (1) {
        if (*p) {
            p++;
            c++;
        } else {
            c++;
            if (*(p+1)) {
                p++;
            } else {
                c++;
                break;
            }
        }
    }
    return c;
}

UINT GetInstNumber(LPCTSTR szMDPath, UINT i)
{
	return 1;
}
int GetPortNum(LPCTSTR szSvcName)
{
    CString csPath = _T("SYSTEM\\CurrentControlSet\\Control\\Service Provider\\Service Types\\");
    csPath += szSvcName;

    DWORD dwPort = 0;
    if (lstrcmpi(szSvcName, _T("SMTPSVC")) == 0)
        dwPort = 25;
     if (lstrcmpi(szSvcName, _T("NNTPSVC")) == 0)
        dwPort = 119;

    CRegKey regKey(HKEY_LOCAL_MACHINE, csPath);
    if ( (HKEY)regKey ) {
        regKey.QueryValue(_T("TcpPort"), dwPort);
    }

    return (int)dwPort;
}

void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    UINT i = 1;  // instance number is in range of 1 - 4 billion
    UINT n;
    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/*SVC"
	csRoot.MakeUpper();
    TCHAR Buf[10];
    CMDKey cmdKey;

    DebugOutput(_T("AddVRMapToMD(): szSvcName=%s"), szSvcName );

    CMapStringToString *pGlobalObj;
    pMap->Lookup(_T("null"), (CObject*&)pGlobalObj);

    POSITION pos0 = pMap->GetStartPosition();
    while (pos0) {
        CMapStringToString *pObj;
        CString csIP;
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);
		TCHAR szIP[256];

		lstrcpy(szIP, csIP);
		if (lstrcmp(szIP, TEXT("null")) == 0) szIP[0] = 0;

        n = GetInstNumber(csRoot, i);
        _itot(n, Buf, 10);
        CString csKeyPath = csRoot;
        csKeyPath += _T("/");
        csKeyPath += Buf; //  "LM/*SVC/N"

        cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.Close();

            MDEntry stMDEntry;

			HGLOBAL hBlock = NULL;
			hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
			if (hBlock) {
	            stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
	            stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;  // need to be created in iiscnfg.h
	            stMDEntry.dwMDAttributes = METADATA_INHERIT;
	            stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
	            stMDEntry.dwMDDataType = MULTISZ_METADATA;
	            _stprintf((LPTSTR)hBlock, _T("%s:%d:"), szIP, GetPortNum(szSvcName));
	            stMDEntry.dwMDDataLen = GetMultiStrLen((LPTSTR)hBlock) * sizeof(TCHAR);
	            stMDEntry.pbMDData = (LPBYTE)hBlock;
	            SetMDEntry(&stMDEntry, NULL);
			}

            POSITION pos1 = pObj->GetStartPosition();
            while (pos1) {
                CString csValue;
                CString csName;
                pObj->GetNextAssoc(pos1, csName, csValue);
                CreateMDVRootTree(csKeyPath, csName, csValue);
            }
        }

        if (szIP[0] != 0) {
            ApplyGlobalToMDVRootTree(csKeyPath, pGlobalObj);
        }

        i = n+1;
    }
}

void EmptyMap(CMapStringToOb *pMap)
{
    POSITION pos = pMap->GetStartPosition();
    while (pos) {
        CString csKey;
        CMapStringToString *pObj;
        pMap->GetNextAssoc(pos, csKey, (CObject*&)pObj);
        delete pObj;
    }
    pMap->RemoveAll();
}

void SsyncVRoots(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    CString csParam = _T("System\\CurrentControlSet\\Services\\");
    csParam += szSvcName;
    csParam += _T("\\Parameters");
    CRegKey regParam(HKEY_LOCAL_MACHINE, csParam);
    if ((HKEY)regParam) {
        // remove the old virtual roots key
        regParam.DeleteTree(_T("Virtual Roots"));

        // recreate the key
        CRegKey regVRoots(_T("Virtual Roots"), (HKEY)regParam);
        if ((HKEY)regVRoots) {
            CMapStringToString *pGlobalObj;
            pMap->Lookup(_T("null"), (CObject*&)pGlobalObj);
            POSITION pos = pGlobalObj->GetStartPosition();
            while (pos) {
                CString csValue;
                CString csName;
                pGlobalObj->GetNextAssoc(pos, csName, csValue);
                regVRoots.SetValue(csName, csValue);
            }
        }
    }
}

void AddVRootsToMD(LPCTSTR szSvcName, BOOL fUpgrade)
{
    CMapStringToOb Map;

    DebugOutput(_T("AddVRootsToMD(): szSvcName=%s, fUpgrade=%d"), szSvcName, fUpgrade );

    if (lstrcmpi(szSvcName, _T("NNTPSVC")) == 0)
        CreateVRMap(&Map, REG_NNTPVROOTS, theApp.m_csPathNntpRoot,
						MD_ACCESS_READ | MD_ACCESS_WRITE, fUpgrade);
    else if (lstrcmpi(szSvcName, _T("SMTPSVC")) == 0)
        return;

    AddVRMapToMD(szSvcName, &Map);

    EmptyMap(&Map);
}

BOOL MigrateRoutingSourcesToMD(LPCTSTR szSvcName, DWORD dwMDID)
{
	BOOL fResult = TRUE;
	DWORD ec;
	HKEY hKey = NULL;
	CString csKey;
	CString csRegKey;

	DWORD dwType;
	DWORD dwIndex;

	TCHAR pszEnumName[MAX_PATH];
	TCHAR pszData[MAX_PATH];
	const int cchMultiSz = 4096;
	TCHAR pszMultiSz[cchMultiSz+1];
	TCHAR *pszTemp = pszMultiSz;
	DWORD cbEnumName = sizeof(pszEnumName);
	DWORD cbData = sizeof(pszData);
	DWORD cchData;
	DWORD cbMultiSz;
	
	DebugOutput(_T("MigrateRoutingSourcesToMD(): szSvcName=%s, dwMDID=%d"), szSvcName, dwMDID);

	// Initialize the paths
	csRegKey = REG_SERVICES;
	csRegKey += _T("\\");
	csRegKey += szSvcName;
	csRegKey += REG_ROUTING_SOURCES_SUFFIX;
	csKey = _T("LM/");
	csKey += szSvcName;
	csKey += _T("/1/Parameters");
	
	// Initialize the MultiSz
	pszMultiSz[0] = pszMultiSz[1] = 0;

	// Open the key
	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)csRegKey, 0, KEY_ALL_ACCESS, &hKey);
	if (ec == ERROR_SUCCESS)
	{
		dwIndex = 0;
		do
		{
			// do an enum to find out what we should be opening
			cbEnumName = sizeof(pszEnumName) / sizeof(TCHAR);
			cbData = sizeof(pszData);

			ec = RegEnumValue(hKey, dwIndex++, pszEnumName, &cbEnumName,
							  NULL, &dwType, (LPBYTE)pszData, &cbData);
			if (ec != ERROR_SUCCESS)
			{
				// We are done if no more items, error otherwise
				if (ec != ERROR_NO_MORE_ITEMS)
				{
					TCHAR DebugStr[128];

					wsprintf(DebugStr,
							_T("\nError migrating routing sources (%u)\n"),
							ec);
					DebugOutput(DebugStr);
					
					fResult = FALSE;
				}
				break;
			}

			// Process this value, basically, append it to the multisz
			DebugOutput(pszData);
			cchData = cbData / sizeof(TCHAR);
			if (pszTemp -pszMultiSz + cchData > cchMultiSz - 1) {
				DebugOutput(_T("Too many routing sources\n"));
				fResult = FALSE;
				break;
			}
			lstrcpyn(pszTemp, pszData, cchData);
			pszTemp += cchData;

		} while (1);

		// Add the final terminating NULL;
		*pszTemp++ = 0;

		RegCloseKey(hKey);

		// Now, we have the full MultiSz of routing sources, we can set it to
		// the Metabase.
		cbMultiSz = (DWORD)(pszTemp - pszMultiSz);
		if (cbMultiSz == 1)
			cbMultiSz++;

        MDEntry stMDEntry;
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKey;
        stMDEntry.dwMDIdentifier = dwMDID;
        stMDEntry.dwMDAttributes = 0;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = MULTISZ_METADATA;
        stMDEntry.dwMDDataLen = cbMultiSz * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)pszMultiSz;
        SetMDEntry(&stMDEntry, NULL);
	}
	else
	{
		DebugOutput(_T("Unable to open registry key: "));
		DebugOutput(csRegKey);
		fResult = FALSE;
	}

	DebugOutput(_T("\nFinished Migrating Routing Sources\n"));
	return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\mdentry.h ===
#ifndef _MDENTRY_H_
#define _MDENTRY_H_

class CDWord : public CObject
{
protected:
    DWORD m_dwData;

public:
    CDWord(DWORD dwData) { m_dwData = dwData; }
    ~CDWord() {};

    operator DWORD () { return m_dwData; }
};

// fMigrate, fKeepOldReg, hRegRootKey, szRegSubKey, szRegValueName, 
// szMDPath, dwMDId, dwMDAttr, dwMDuType, dwMDdType, dwMDDataLen, szMDData 

typedef struct _MDEntry {
    LPTSTR szMDPath;
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    LPBYTE pbMDData;
} MDEntry;

DWORD atodw(LPCTSTR lpszData);
BOOL SplitLine(LPTSTR szLine);
// if the regkey part of szLine contains a * then this can enumerate across the keys.
// to enumerate dwIndex should be set to 0 on the first call.  pszKey gets the name where
// the * is in the regkey name.  if pszKey == \0 then enumeration is done.  dwIndex should
// be incremented on each call
BOOL SetupMDEntry(LPTSTR szLine, BOOL fUpgrade);
void SetMDEntry(MDEntry *pMDEntry, LPTSTR pszKey, BOOL fSetOnlyIfNotPresent=FALSE);
void MigrateNNTPToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade);
void MigrateIMSToMD(
					HINF hInf, 
					LPCTSTR szServerName, 
					LPCTSTR szSection, 
					DWORD dwRoutingSourcesMDID, 
					BOOL fUpgrade,
					BOOL k2UpgradeToEE = FALSE
					);
void MigrateInfSectionToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade);
void AddVRootsToMD(LPCTSTR szSvcName, BOOL fUpgrade);
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue);
void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm);

BOOL MigrateRoutingSourcesToMD(LPCTSTR szSvcName, DWORD dwMDID);

#endif // _MDENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_

interface IMSAdminBase;

void SetErrMsg(LPTSTR szMsg, HRESULT hRes);

class CMDKey : public CObject
{
protected: 
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    BOOL m_fNeedToClose;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE ()
        { return m_hKey; }
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    void OpenNode(LPCTSTR pchSubKeyPath);
    // to open an existing MD key, or create one if doesn't exist
    void CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    void Close();

    void DeleteNode(LPCTSTR pchSubKeyPath);

    BOOL IsEmpty();
    int GetNumberOfSubKeys();

    BOOL SetData(
     DWORD id,
     DWORD attr,
     DWORD uType,
     DWORD dType,
     DWORD cbLen,
     LPBYTE pbData);
    BOOL GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen,
     LPBYTE pbData);
    void DeleteData(DWORD id, DWORD dType);

};

#endif // _MDKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\nntp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"

#include "mdentry.h"

#include "utils.h"

#include "nntptype.h"
#include "nntpapi.h"
#include "userenv.h"
#include "userenvp.h"

GUID 	g_NNTPGuid   = { 0xe2939ef0, 0xaae2, 0x11d0, 0xb0, 0xba,
						 0x00, 0xaa, 0x00, 0xc1, 0x48, 0xbe };

typedef NET_API_STATUS (NET_API_FUNCTION *LPFNNntpCreateNewsgroup)(LPWSTR, DWORD, LPNNTP_NEWSGROUP_INFO);

void CreateNewsgroup(TCHAR *szComputerName,
					 LPFNNntpCreateNewsgroup lpfnNCN,
					 TCHAR *szGroupName)
{
	DWORD dwErr = 0;
	NNTP_NEWSGROUP_INFO NewsgroupInfo;

	ZeroMemory(&NewsgroupInfo, sizeof(NewsgroupInfo));
	NewsgroupInfo.cbNewsgroup = (lstrlen(szGroupName) + 1) * sizeof(WCHAR);
	NewsgroupInfo.Newsgroup = (PUCHAR) szGroupName;

	DWORD rc = (*lpfnNCN)(szComputerName, 1, &NewsgroupInfo);
#ifdef DEBUG
	TCHAR szBuf[1024];

	swprintf(szBuf, _T("CreateNewsgroup returned %lu"), rc);
	DebugOutput(szBuf);
#endif
}

void CreateNNTPGroups(void) {
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
	DWORD cb = MAX_COMPUTERNAME_LENGTH;
	LPFNNntpCreateNewsgroup lpfnNCN = NULL;
	HINSTANCE hInst = 0;

	do {
		if (!(hInst = LoadLibrary(_T("nntpapi.dll")))) break;
		if (!(lpfnNCN = (LPFNNntpCreateNewsgroup) GetProcAddress(hInst, "NntpCreateNewsgroup"))) break;
		if (!(GetComputerName(szComputerName, &cb))) break;

// the server creates these groups now
#if 0
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.rmgroup"));
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.newgroup"));
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.cancel"));
#endif
		CreateNewsgroup(szComputerName, lpfnNCN, _T("microsoft.public.ins"));

		// post the welcome message
		CString csSrc = theApp.m_csPathInetsrv + _T("\\infomsg.nws");
		CString csDest = theApp.m_csPathNntpFile + _T("\\pickup\\infomsg.nws");
		MoveFileEx(csSrc, csDest, MOVEFILE_COPY_ALLOWED);
	} while (FALSE);

	if (hInst != NULL) FreeLibrary(hInst);
}

INT Register_iis_nntp_nt5(BOOL fUpgrade, BOOL fReinstall)
//
//  fUpgrade == TRUE:
//  1) IM_UPGRADEK2
//  2) IM_UPGRADE10
//  3) IM_UPGRADE20
//  4) IM_UPGRADE - obsolete
//
//  fReinstall == TRUE:
//  minor NT5 OS (between builds) upgrades
//
{
    INT err = NERR_Success;
    CString csBinPath;

    BOOL fSvcExist = FALSE;
    BOOL fSetACL = FALSE;

    // for minor NT5 os upgrade
    if (fReinstall)
    {
        return err;
    }

    //
    // These are common things need to be done:
    // NT5 - The following code will be executed for either AT_UPGRADE, or AT_FRESH_INSTALL
    // For Component - INS, SubComponent - iis_nntp.
    // AT_UPGRADE = IM_UPGRADE, IM_UPGRADE10, IM_UPGRADEK2, IM_UPGRADE20
    // AT_FRESH_INSTALL = IM_FRESH
    //

    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    // NT5 - for UPGRADEK2 or UPGRADE20, skip anything after this
    if (theApp.m_eNTOSType == OT_NTS && (theApp.m_eState[SC_NNTP] == IM_UPGRADEK2 || theApp.m_eState[SC_NNTP] == IM_UPGRADE20))
    {
        return err;
    }

	// add the nntpkey.dll to the keyring
    CRegKey regKeyring( _T("Software\\Microsoft\\Keyring\\Parameters\\AddOnServices"), regMachine );
    if ((HKEY) regKeyring) {
		CString csPath = theApp.m_csPathInetsrv + _T("\\nntpkey.dll");
	    regKeyring.SetValue(_T("NNTP"), csPath);
	}

	// if this is an upgrade then we need to remove the nntpcfg.dll key
	CRegKey regInetmgr( _T("Software\\Microsoft\\InetMGR\\Parameters\\AddOnServices"), regMachine);
	if ((HKEY) regInetmgr) {
		regInetmgr.DeleteValue(_T("NNTP"));
	}

    // Create or Config NNTP service
    CString csDisplayName;
    CString csDescription;

    MyLoadString( IDS_NNTPDISPLAYNAME, csDisplayName );
    MyLoadString(IDS_NNTPDESCRIPTION, csDescription);
    csBinPath = theApp.m_csPathInetsrv + _T("\\inetinfo.exe") ;

    err = InetCreateService(SZ_NNTPSERVICENAME,
						(LPCTSTR)csDisplayName,
						(LPCTSTR)csBinPath,
						SERVICE_AUTO_START,
						SZ_SVC_DEPEND,
						(LPCTSTR)csDescription);
    if ( err != NERR_Success )
    {
        if (err == ERROR_SERVICE_EXISTS)
		{
			fSvcExist = TRUE;
			err = InetConfigService(SZ_NNTPSERVICENAME,
							(LPCTSTR)csDisplayName,
							(LPCTSTR)csBinPath,
							SZ_SVC_DEPEND,
							(LPCTSTR)csDescription);
			if (err != NERR_Success)
			{
				SetErrMsg(_T("NNTP InetConfigService failed"), err);
			}
		}
    }

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // NT5 - only set the fUpgrade to TRUE is we are doing MCIS10 to NT5 upgrade
    // to migrate registry key to metabase.
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG"), fUpgrade && theApp.m_eState[SC_NNTP] == IM_UPGRADE10);
		SetAdminACL_wrap(_T("LM/NNTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
		SetAdminACL_wrap(_T("LM/NNTPSVC"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

    // Create key \System\CurrentControlSet\Services\NntpSvc\Performance:
    // Add the following values:
    // Library = nntpctrs.DLL
    // Open = OpenNNTPPerformanceData
    // Close = CloseNNTPPerformanceData
    // Collect = CollectNNTPPerformanceData
    InstallPerformance(REG_NNTPPERFORMANCE,
					_T("nntpctrs.DLL"),
					_T("OpenNntpPerformanceData"),
					_T("CloseNntpPerformanceData"),
					_T("CollectNntpPerformanceData"));

	//
	// We used to register the NNTP MIB agent here.  Now we unregister it in
	// case we're upgrading since it's no longer supported
	//

	RemoveAgent( SZ_NNTPSERVICENAME );

    // Create key \System\CurrentControlSet\Services\EventLog\System\NntpSvc:
    // Add the following values:
    // EventMessageFile = ..\nntpmsg.dll
    // TypesSupported = 7
    csBinPath = theApp.m_csPathInetsrv + _T("\\nntpsvc.dll");
    AddEventLog( SZ_NNTPSERVICENAME, csBinPath, 0x07 );
    if (!fSvcExist) {
        InetRegisterService( theApp.m_csMachineName,
							SZ_NNTPSERVICENAME,
							&g_NNTPGuid, 0, 119, TRUE );
    }

    // load counter
    unlodctr( SZ_NNTPSERVICENAME );
    lodctr(_T("nntpctrs.ini"));

	// set SYSTEM\CurrentControlSet\Control\ContentIndex\IsIndexingNNTPSvc to 1
    CRegKey regCIParam( REG_CIPARAMETERS, regMachine );
    if ((HKEY) regCIParam) {
		regCIParam.SetValue(_T("IsIndexingNNTPSvc"), (DWORD) 1);
	}



    // create some paths
    CreateLayerDirectory( theApp.m_csPathInetpub );

    fSetACL = !IsFileExist( (LPCTSTR) theApp.m_csPathNntpFile );
    CreateLayerDirectory( theApp.m_csPathNntpFile );
    if (fSetACL) SetNntpACL ( theApp.m_csPathNntpFile, FALSE, TRUE ); //set admin ACL

    fSetACL = !IsFileExist( (LPCTSTR) theApp.m_csPathNntpRoot );
    CreateLayerDirectory( theApp.m_csPathNntpRoot );
    // set the root directories for NNTP to be everyone full control and let it propergate
    if (fSetACL) SetNntpACL ( theApp.m_csPathNntpRoot, TRUE ); // set everyone+Anon ACL


    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\pickup" );
    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\failedpickup" );
    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\drop" );
    CreateLayerDirectory( theApp.m_csPathNntpRoot + "\\_temp.files_");

    return err;
}

INT Upgrade_iis_nntp_nt5_fromk2(BOOL fFromK2)
//
//  Handle upgrade from K2 and MCIS 2.0
//
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from %s to B3 ..."), (fFromK2)? _T("NT4 K2") : _T("MCIS 2.0"));

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // For K2 or MCIS 2.0 upgrade, add whatever necessary keys here
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG_UPGRADEK2"), FALSE);
		SetAdminACL_wrap(_T("LM/NNTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
		SetAdminACL_wrap(_T("LM/NNTPSVC"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

	// remove items from the K2 program groups
    if (fFromK2)
    {
        // upgrade from K2, remove those K2 links
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_WEBADMIN, FALSE);
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README, FALSE);
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README_K2, FALSE);
    }
	else
	{
        // upgrade from MCIS 2.0, remove thos MCIS links
		RemoveInternetShortcut(MC_INS,  IDS_PROGITEM_NEWS_WEBADMIN, TRUE);
		RemoveInternetShortcut(MC_INS,  IDS_PROGITEM_MCIS_NEWS_README, TRUE);
		RemoveISMLink();
	}

    return err;
}

INT Upgrade_iis_nntp_nt5_fromb2(BOOL fFromB2)
//
//  Handle upgrades from Beta2 -> Beta3, or minor NT5 Beta3 upgrades
//
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from NT5 %s to B3 ..."), (fFromB2)? _T("B2") : _T("B3"));

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    if (!fFromB2)
    {
        //  If it's just upgrades between B3 bits, don't need to do any metabase operations.
        return err;
    }

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // NT5 - only set the fUpgrade to TRUE is we are doing MCIS10 to NT5 upgrade
    // to migrate registry key to metabase.
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG_UPGRADEB2"), FALSE);
    }

    return err;
}

INT Unregister_iis_nntp()
{
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

	// Unregister all of the NNTP sources in the SEO binding database
	UnregisterSEOSourcesForNNTP();

	// Unregister the OLE objets
    CString csOcxFile;
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, FALSE);
   	csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#if 0
// Don't unregiser these three DLL on uninstall
// as they may be needed by SMTP and IMAP
    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#if 0
// can't unregister mailmsg.dll since this will break SMTP
    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, FALSE);

    if (theApp.m_eNTOSType == OT_NTS)
        RemoveAgent( SZ_NNTPSERVICENAME );
    RemoveEventLog( SZ_NNTPSERVICENAME );
    unlodctr( SZ_NNTPSERVICENAME );
    InetDeleteService(SZ_NNTPSERVICENAME);
    InetRegisterService( theApp.m_csMachineName,
					SZ_NNTPSERVICENAME,
					&g_NNTPGuid, 0, 119, FALSE );

    // remove LM/NNTPSVC in the metabase
    if (DetectExistingIISADMIN())
    {
        CMDKey cmdKey;
        cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(_T("NNTPSVC"));
            cmdKey.Close();
        }

	    // remove the News key from the w3svc in the metabase
	    cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(_T("w3svc/1/root/News"));
            cmdKey.Close();
        }
    }

	// remove items from the K2 program groups
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_WEBADMIN, FALSE);
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README, FALSE);
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README_K2, FALSE);
	if (theApp.m_eNTOSType == OT_NTS)
	{
		RemoveInternetShortcut(MC_INS,
						IDS_PROGITEM_NEWS_WEBADMIN,
						TRUE);
		RemoveInternetShortcut(MC_INS,
						IDS_PROGITEM_MCIS_NEWS_README,
						TRUE);
		RemoveISMLink();
	}
    //
    //  remove the one and only webadmin link from "administrative tools"
    //
	RemoveNt5InternetShortcut(MC_INS,
					IDS_PROGITEM_NEWS_WEBADMIN);

    return (0);
}

void GetNntpFilePathFromMD(CString &csPathNntpFile, CString &csPathNntpRoot)
{
    TCHAR   szXover[] = _T("\\xover.hsh");
    TCHAR   szPathXover[_MAX_PATH];
    TCHAR   szPathNntpRoot[_MAX_PATH];
    TCHAR   szPathNntpFile[_MAX_PATH];

    ZeroMemory( szPathNntpRoot, sizeof(szPathNntpRoot) );
    ZeroMemory( szPathNntpFile, sizeof(szPathNntpFile) );
    ZeroMemory( szPathXover, sizeof(szPathXover) );

    // Called only during K2 Beta2 to Beta3 upgrade,
    // We use the existing nntpfile/nntproot setting,
    //  1/20/99 - BINLIN : Should support K2 to NT5 upgrade as well
    //if (theApp.m_eState[SC_NNTP] == IM_UPGRADEB2)
    {
        CMDKey NntpKey;
        DWORD  dwScratch;
        DWORD  dwType;
        DWORD  dwLength;

        // Get NntpRoot path
        NntpKey.OpenNode(_T("LM/NntpSvc/1/Root"));
        if ( (METADATA_HANDLE)NntpKey )
        {
            dwLength = _MAX_PATH;

            if (NntpKey.GetData(3001, &dwScratch, &dwScratch,
                                &dwType, &dwLength, (LPBYTE)szPathNntpRoot))
            {
                if (dwType == STRING_METADATA)
                {

                    csPathNntpRoot.Empty();
                    lstrcpy( csPathNntpRoot.GetBuffer(512), szPathNntpRoot );
                    csPathNntpRoot.ReleaseBuffer();
                }
            }
        }
        NntpKey.Close();

        // Get NntpFile path from old XOVER path
        NntpKey.OpenNode(_T("LM/NntpSvc/1"));
        if ( (METADATA_HANDLE)NntpKey )
        {
            dwLength = _MAX_PATH;

            if (NntpKey.GetData(45161, &dwScratch, &dwScratch,
                                &dwType, &dwLength, (LPBYTE)szPathXover))
            {
                if (dwType == STRING_METADATA)
                {
                    dwScratch = lstrlen(szXover);
                    dwLength = lstrlen(szPathXover);

                    // If it ends with "\\xover.hsh", then we copy the prefix into csPathNntpFile
                    if ((dwLength > dwScratch) &&
                        !lstrcmpi(szPathXover + (dwLength - dwScratch), szXover))
                    {
                        lstrcpyn( szPathNntpFile, szPathXover, (dwLength - dwScratch + 1));
                    }

                    csPathNntpFile.Empty();
                    lstrcpy( csPathNntpFile.GetBuffer(512), szPathNntpFile );
                    csPathNntpFile.ReleaseBuffer();
                }
            }
        }
        NntpKey.Close();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\mdkey.cpp ===
#include "stdafx.h"

#define INITGUID
#define _WIN32_DCOM
#undef DEFINE_GUID      // Added for NT5 migration
#include <ole2.h>
#include <coguid.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"

#define TIMEOUT_VALUE 5000

CMDKey::CMDKey()
{
    m_pcCom = NULL;
    m_hKey = NULL;
    m_fNeedToClose = FALSE;
}

CMDKey::~CMDKey()
{
    this->Close();
}

void SetErrMsg(LPTSTR szMsg, HRESULT hRes)
{
    CString csMsg;
    csMsg.Format(_T("%s, %x"), szMsg, hRes);
    MyMessageBox(NULL, csMsg, _T("IMS/INS Metabase Error"), 
					MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);

    return;
}

void TraceErrMsg(LPTSTR szMsg, HRESULT hRes)
{
    CString csMsg;
    csMsg.Format(_T("%s, %x"), szMsg, hRes);
	DebugOutput(csMsg);
    return;
}

void CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    BOOL fInitialized = FALSE;
    HRESULT hRes;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];
	DWORD dwRetry = 0;

    DebugOutput(_T("OpenNode(): pchSubKeyPath=%s"), pchSubKeyPath);

    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) {
        *szSubKeyPath = L'\0';
    } else {
        lstrcpyn(szSubKeyPath, pchSubKeyPath, _MAX_PATH);
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG || hRes == RPC_E_CHANGED_MODE ) {
        fInitialized = TRUE;
        if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG )
            m_fNeedToClose = TRUE; // need to be closed later
    }

    if (!fInitialized) {
        SetErrMsg(_T("CoInitializeEx"), hRes);
    } else {
		dwRetry = 0;
		do
		{
	        hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);

			if (FAILED(hRes))
			{
				TraceErrMsg(_T("Retrying on OpenNode::CoGetClassObject"), hRes);

				// Add a small delay
				Sleep(100);
			}

		} while ((FAILED(hRes)) && (++dwRetry < 5));

        if (FAILED(hRes)) {
            SetErrMsg(_T("CoGetClassObject"), hRes);
        } else {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
            pcsfFactory->Release();
            if (FAILED(hRes)) {
                SetErrMsg(_T("CoCreateInstance"), hRes);
            } else {
				dwRetry = 0;
				do
				{
					hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
										  szSubKeyPath,
										  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
										  TIMEOUT_VALUE,
										  &m_hKey);
					if (FAILED(hRes))
					{
						TraceErrMsg(_T("Retrying on OpenNode::OpenKey"), hRes);

						// Add a small delay
						Sleep(100);
					}

				} while ((FAILED(hRes)) && (++dwRetry < 5));
                if (FAILED(hRes)) {
                    if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                        SetErrMsg(_T("OpenKey"), hRes);
                    }
                } else {
                    b = TRUE;
                }
            } // end of CoCreateInstance
        } // end of CoGetClassObject
    }

    if (!b) {
        this->Close();
    }

    return;
}

void CMDKey::CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath)
{
    BOOL fInitialized = FALSE;
    HRESULT hRes;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];
	DWORD dwRetry = 0;

    DebugOutput(_T("CreateNode(): hKeyBase=0x%x, pchSubKeyPath=%s"), hKeyBase, pchSubKeyPath);
    
    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) {
        *szSubKeyPath = L'\0';
    } else {
        lstrcpyn(szSubKeyPath, pchSubKeyPath, _MAX_PATH);
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG || hRes == RPC_E_CHANGED_MODE ) {
        fInitialized = TRUE;
        if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG )
            m_fNeedToClose = TRUE; // need to be closed later
    }

    if (!fInitialized) {
        SetErrMsg(_T("CoInitializeEx"), hRes);
    } else {
        hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
        if (FAILED(hRes)) {
            SetErrMsg(_T("CoGetClassObject"), hRes);
        } else {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
            pcsfFactory->Release();
            if (FAILED(hRes)) {
                SetErrMsg(_T("CoCreateInstance"), hRes);
            } else {
				hRes = m_pcCom->OpenKey(hKeyBase,
									  szSubKeyPath,
									  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
									  TIMEOUT_VALUE,
									  &m_hKey);
                if (FAILED(hRes)) 
				{
                    if (hRes == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                        METADATA_HANDLE RootHandle;
                        hRes = m_pcCom->OpenKey(hKeyBase,
                                      L"",
                                      METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                      TIMEOUT_VALUE,
                                      &RootHandle);
                        hRes = m_pcCom->AddKey(RootHandle, szSubKeyPath);
                        if (FAILED(hRes)) {
                            SetErrMsg(_T("AddKey"), hRes);
                        } 
                        hRes = m_pcCom->CloseKey(RootHandle);
                        if (FAILED(hRes)) {
                            SetErrMsg(_T("CloseKey of AddKey"), hRes);
                        } 
						else 
						{
							dwRetry = 0;
                            do
							{
								// open it again to set m_hKey
								hRes = m_pcCom->OpenKey(hKeyBase,
											  szSubKeyPath,
											  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
											  TIMEOUT_VALUE,
											  &m_hKey);
								if (FAILED(hRes))
								{
									TraceErrMsg(_T("Retrying on CreateNode::OpenKey"), hRes);

									// Add a small delay
									Sleep(100);
								}

							} while ((FAILED(hRes)) && (++dwRetry < 5));

                            if (FAILED(hRes)) {
                                SetErrMsg(_T("OpenKey"), hRes);
                            } else {
                                b = TRUE;
                            }
                        }
                    } else {
                        SetErrMsg(_T("OpenKey"), hRes);
                    }
                } else {
                    b = TRUE;
                } // end of OpenKey
            } // end of CoCreateInstance
        } // end of CoGetClassObject
    } // end of CoInitializeEx

    if (!b) {
        this->Close();
    }

    return;
}

void CMDKey::Close()
{
    HRESULT hRes;
    if (m_pcCom) {
        if (m_hKey)
            hRes = m_pcCom->CloseKey(m_hKey);

		// Call save data anyway for good measure
		hRes = m_pcCom->SaveData();
        hRes = m_pcCom->Release();
    }
    if (m_fNeedToClose)
        CoUninitialize();

    m_pcCom = NULL;
    m_hKey = NULL;
    m_fNeedToClose = FALSE;

    return;
}
#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;

BOOL CMDKey::IsEmpty()
{
    int ReturnIndex;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    HRESULT hRes;
    UCHAR ReturnBuf[256];
    FILL_RETURN_BUFF;
    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
    hRes = m_pcCom->EnumData(m_hKey, L"", &mdrData, 0, &dwRequiredDataLen);
    if (FAILED(hRes)) {
        if(hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) ||
           hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) ) {
            return TRUE;
        } else {
            SetErrMsg(_T("EnumData"), hRes);
        }
    }
    return (hRes != ERROR_SUCCESS);
}

int CMDKey::GetNumberOfSubKeys()
{
    int i=0;
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR NameBuf[METADATA_MAX_NAME_LEN];
    while (hRes == ERROR_SUCCESS) {
        hRes = m_pcCom->EnumKeys(m_hKey, L"", NameBuf, i++);
    }
    if (hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
        return (--i);
    else {
        SetErrMsg(_T("EnumKeys"), hRes);
        return (0);
    }
}

BOOL CMDKey::SetData(
     DWORD id,
     DWORD attr,
     DWORD uType,
     DWORD dType,
     DWORD cbLen, // number of bytes
     LPBYTE pbData)
{
    HRESULT hRes;
    METADATA_RECORD mdrData;
    WCHAR *pData = NULL;
	BOOL fRet = FALSE;

    switch (dType) 
	{
	case DWORD_METADATA:
        pData = (WCHAR *)pbData;
		break;
	case BINARY_METADATA:
        pData = (WCHAR *)pbData;
		break;
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        pData = (WCHAR *)pbData;
        break;

    case MULTISZ_METADATA:
        pData = (WCHAR *)pbData;
        break;

    default:
        break;

    }

    if (cbLen > 0) 
	{
        MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);

        hRes = m_pcCom->SetData(m_hKey, L"", &mdrData);
        if (FAILED(hRes)) 
            SetErrMsg(_T("SetData"), hRes);
		else
			fRet = TRUE;
    }

	if (pData && (pData != (WCHAR *)pbData))
		LocalFree(pData);

    return(fRet);
}

// Note: only use to access the AnonyName and AnonyPassword,
// buffer size 256 is big enough here
// sneely: Now used to see if a key exists as well.
BOOL CMDKey::GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen, // number of bytes
     LPBYTE pbData)
{
    int ReturnIndex;
    BOOL fReturn = FALSE;
    HRESULT hRes;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    UCHAR ReturnBuf[256];
    FILL_RETURN_BUFF;
    MD_SET_DATA_RECORD(&mdrData, id, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);

    hRes = m_pcCom->GetData(m_hKey, L"", &mdrData, &dwRequiredDataLen);
    if (FAILED(hRes)) {
		// MCIS uses this to see if an MD value exists, so we don't
		// complain if it's not found.
        //SetErrMsg(_T("GetData"), hRes);
    } else {
        *pdwAttr = mdrData.dwMDAttributes;
        *pdwUType = mdrData.dwMDUserType;
        *pdwDType = mdrData.dwMDDataType;
        *pcbLen = mdrData.dwMDDataLen; // number of SBCS chars + ending \0
        fReturn = TRUE;
        switch (*pdwDType) {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            break;
        default:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            break;
        }
    }

    return fReturn;
}

void CMDKey::DeleteData(DWORD id, DWORD dType)
{
    m_pcCom->DeleteData(m_hKey, L"", id, dType);

    return;
}

void CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) {
        lstrcpyn(szSubKeyPath, pchSubKeyPath, _MAX_PATH);

        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\offline.cpp ===
#include "stdafx.h"
#include <clusapi.h>
#include <resapi.h>

#define INITIAL_RESOURCE_NAME_SIZE 256 // In characters not in bytes
#define IIS_RESOURCE_TYPE_NAME L"IIS Server Instance"
#define SMTP_RESOURCE_TYPE_NAME L"SMTP Server Instance"
#define NNTP_RESOURCE_TYPE_NAME L"NNTP Server Instance"

#define MAX_OFFLINE_RETRIES 5 // Number of times to try and take a resources offline before giving up 
#define DELAY_BETWEEN_CALLS_TO_OFFLINE 1000*2 // in milliseconds

DWORD BringALLIISClusterResourcesOffline(void);

#ifdef UNIT_TEST
int main()
{
	DWORD dwResult = ERROR_SUCCESS;

	dwResult = BringALLIISClusterResourcesOffline();

	return dwResult;
}
#endif

/****************************************************
*
* Known "problem": If a resource doesn't come offline after the five
* retries than the function continues to try to take the other iis resources
* offline but there is no error reported. You could change this pretty simply I think.
*
*****************************************************/
DWORD BringALLIISClusterResourcesOffline(void)
{
	//
	// The return code
	//
	DWORD dwError = ERROR_SUCCESS;
	
	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;


	//
	// Open the cluster
	//
	if ( !(hCluster = OpenCluster(NULL)) )
	{
		dwError = GetLastError();
		goto clean_up;
	}

	//
	// Get Enumerator for the cluster resouces
	// 
	if ( !(hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE )) )
	{
		dwError = GetLastError();
		goto clean_up;	
	}
	
	//
	// Enumerate the Resources in the cluster
	// 
	
	//
	// Allocate memory to hold the cluster resource name as we enumerate the resources
	//
	if ( !(lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR))) )
	{
		dwError = GetLastError();
		goto clean_up;
	}

	// 
	// Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
	//
	while( ERROR_NO_MORE_ITEMS  != 
	       (dwResultClusterEnum = ClusterEnum(hClusResEnum,
			              dwResourceIndex, 
				      &dwObjectType, 
				      lpwszResourceName,
				      &dwClusterEnumResourceNameLength )) )
	{		
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

			if ( !(hResource = OpenClusterResource( hCluster, lpwszResourceName )) )
			{
				dwError = GetLastError();
				break;
			}

			//
			// If the resource type is "IIS Server Instance",
			// "SMTP Server Instance" or "NNTP Server Instance" then delete it
			//
			if ( ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource) || 
                ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource) || 
                ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource) )
			{

				//
				// If the resource doesn't come offline quickly then wait 
				//
				if ( ERROR_IO_PENDING == OfflineClusterResource( hResource ) )
				{
					for(int iRetry=0; iRetry < MAX_OFFLINE_RETRIES; iRetry++)
					{
						Sleep( DELAY_BETWEEN_CALLS_TO_OFFLINE );

						if ( ERROR_SUCCESS == OfflineClusterResource( hResource ) )
						{
							break;
						}
					}	
				}
			}

			CloseClusterResource( hResource );
			
			dwResourceIndex++;
		}
			
		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;

			if ( !(lpwszResourceNameTmp = 
			      (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0)) )
			{
				dwError = GetLastError();

				LocalFree( lpwszResourceName );	
				lpwszResourceName = NULL;
				break;
			} else {
				lpwszResourceName = lpwszResourceNameTmp;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:

	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}
			


	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\registry.cpp ===
#include "stdafx.h"

// open an existing key
CRegKey :: CRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam )
    : m_hKey( NULL ),
    m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS ;

    if ( pchSubKey )
        err = ::RegOpenKeyEx( hKeyBase, pchSubKey, 0, regSam, & m_hKey ) ;
    else
        m_hKey = hKeyBase ;

    if ( err != ERROR_SUCCESS )
    {
        if (m_hKey)
            ::RegCloseKey(m_hKey);
        m_hKey = NULL ;
    }
}

//  Constructor creating a new key/opening a key if already exist, and set value if specified
CRegKey :: CRegKey (
    LPCTSTR lpSubKey,
    HKEY hKeyBase,
    LPCTSTR lpValueName,
    DWORD dwType,
    LPBYTE lpValueData,
    DWORD cbValueData)
    : m_hKey( NULL ),
    m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS;

    err = ::RegCreateKeyEx( hKeyBase, lpSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, & m_hKey, & m_dwDisposition ) ;
    if ( err != ERROR_SUCCESS) {
        if ( m_hKey )
            ::RegCloseKey( m_hKey ) ;
        m_hKey = NULL ;
    } else {
        if (lpValueName)
            ::RegSetValueEx(m_hKey, lpValueName, 0, dwType, (const LPBYTE)lpValueData, cbValueData);
    }
}

CRegKey :: ~ CRegKey ()
{
    if ( m_hKey )
        ::RegCloseKey( m_hKey ) ;
}


    //  Prepare to read a value by finding the value's size.
LONG CRegKey :: PrepareValue (
    LPCTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pcbSize,
    BYTE ** ppbData )
{
    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( *this,
                      (TCHAR *) pchValueName,
                      0, pdwType,
                      chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 )
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA )
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( *this,
                         (TCHAR *) pchValueName,
                     0, pdwType,
                     *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )
    {
        delete [] *ppbData ;
    }

    return err ;
}

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CString & strResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if (( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, DWORD & dwResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_DWORD || cbData != sizeof dwResult )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    }
    while ( FALSE ) ;

    // Memory leak...
    //if ( err )
    //{
        delete [] pabData ;
    //}

    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err )
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ )
        {
            abResult[i] = pabData[i] ;
        }
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, LPTSTR szMultiSz, DWORD dwSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( dwSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(szMultiSz, pabData, cbData);
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

//  Overloaded value setting members.
LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand )
{
    LONG err = 0;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    fExpand ? REG_EXPAND_SZ : REG_SZ,
                    (const BYTE *) szResult,
                    (_tcsclen(szResult) + 1) * sizeof(_TCHAR) ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, DWORD dwResult )
{
    LONG err = 0;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CByteArray & abResult )
{

    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( ( err == 0 ) && pbData)
    {
        err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       pbData,
                       cbSize ) ;
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult,
                       cbSize ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szMultiSz, DWORD dwSize )
{

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_MULTI_SZ,
                       (const BYTE *)szMultiSz,
                       dwSize ) ;

    return err ;
}

LONG CRegKey::DeleteValue( LPCTSTR pchKeyName )
{
    LONG err = 0;
    err = ::RegDeleteValue( *this, pchKeyName );
    return(err);
}

LONG CRegKey::DeleteTree( LPCTSTR pchKeyName )
{
    LONG err = 0;
    CRegKey regSubKey( *this, pchKeyName );

    if ( NULL != (HKEY) regSubKey )
    {
        CString strName;
        CTime cTime;

        while (TRUE)
        {
            CRegKeyIter regEnum( regSubKey );

            if ( regEnum.Next( &strName, &cTime ) != ERROR_SUCCESS )
            {
                break;
            }

            regSubKey.DeleteTree( strName );
        }
        // delete myself
        err = ::RegDeleteKey( *this, pchKeyName );
    }
    return(err);

}

LONG CRegKey :: FlattenValue (
    CByteArray & abData,
    DWORD * pcbSize,
    BYTE ** ppbData )
{
    LONG err = 0 ;

    DWORD i ;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = DWORD(abData.GetSize()))
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ )
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err ;
}


LONG CRegKey :: QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo )
{
    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    return err ;
}

CRegKeyIter :: CRegKeyIter ( CRegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    if ( err )
    {
        //ReportError( err ) ;
    }
}

CRegKeyIter :: ~ CRegKeyIter ()
{
    delete [] m_p_buffer ;
}


    // Get the name (and optional last write time) of the next key.
LONG CRegKeyIter :: Next ( CString * pstrName, CTime * pTime )
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter,
                  m_dw_index,
              m_p_buffer,
                  & dwNameSize,
                  NULL,
                  NULL,
                  NULL,
                  & ftDummy ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err ;
}


CRegValueIter :: CRegValueIter ( CRegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    if ( err )
    {
        //ReportError( err ) ;
    }

}

CRegValueIter :: ~ CRegValueIter ()
{
    delete [] m_p_buffer ;
}

LONG CRegValueIter :: Next ( CString * pstrName, DWORD * pdwType )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;

    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
    {
        *pstrName = m_p_buffer ;
    }
    CATCH_ALL(e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL
    }

    return err ;
}

LONG CRegValueIter :: Next ( CString * pstrName, CString * pstrValue )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    TCHAR szValue[_MAX_PATH];
    DWORD dwValue = _MAX_PATH * sizeof(TCHAR);

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  NULL,
                  (LPBYTE)szValue,
                  &dwValue ) ;

    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
        {
            *pstrName = m_p_buffer ;
            *pstrValue = szValue;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\regctrl.h ===
#ifndef _REGCTRL_H_
#define _REGCTRL_H_

//
// This function registers an OLE control
//
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);

//
// This function registers all OLE controls from a given INF section
// Note the filenames may contain environment strings. Make sure you
// set them before calling this function
//
DWORD RegisterOLEControlsFromInfSection(HINF hFile, LPCTSTR szSectionName, BOOL fRegister);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\regctrl.cpp ===
#include "stdafx.h"
#include "setupapi.h"
#include "ole2.h"


typedef HRESULT (CALLBACK *HCRET)(void);

//
// This function registers an OLE control
//
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction)
{
    HINSTANCE hDll = NULL;
    HCRET hProc = NULL;
	DWORD dwErr = NO_ERROR;

	CoInitialize(NULL);
	if (GetFileAttributes(lpszOcxFile) != 0xFFFFFFFF)
	{
		hDll = LoadLibraryEx(lpszOcxFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
		if (hDll) 
		{
			if (fAction)
				hProc = (HCRET)GetProcAddress(hDll, "DllRegisterServer");
			else
				hProc = (HCRET)GetProcAddress(hDll, "DllUnregisterServer");
    
			if (hProc)
				dwErr = (*hProc)();
			else
				dwErr = GetLastError();
    
			FreeLibrary(hDll);
		} 
		else 
		{
			dwErr = GetLastError();
		}
	}
	CoUninitialize();

    return(dwErr);
}


//
// This function registers all OLE controls from a given INF section
//
DWORD RegisterOLEControlsFromInfSection(HINF hFile, LPCTSTR szSectionName, BOOL fRegister)
{
	LPTSTR		szLine;
    DWORD		dwLineLen = 0;
	DWORD		dwRequiredSize;
	DWORD		dwErr = NO_ERROR;
    BOOL		b = TRUE;
	TCHAR		szPath[MAX_PATH];

    INFCONTEXT	Context;

    if (!SetupFindFirstLine(hFile, szSectionName, NULL, &Context))
        return(GetLastError());

    if (szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)))
        dwLineLen = 1024;
    else
        return(GetLastError());

    while (b) 
	{
        b = SetupGetLineText(&Context, NULL, NULL, 
							NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen) 
		{
            free(szLine);
            if (szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)))
                dwLineLen = dwRequiredSize;
            else
                return(GetLastError());
        }

        if (SetupGetLineText(&Context, NULL, NULL, 
							NULL, szLine, dwRequiredSize, NULL) == FALSE)
		{
			free(szLine);
            return(GetLastError());
		}

		// Expand the line to a fully-qualified path
		if (ExpandEnvironmentStrings(szLine, szPath, MAX_PATH) < MAX_PATH)
		{
			// Call function to register OLE control
			RegisterOLEControl(szPath, fRegister);
		}
		else
		{
			dwErr = ERROR_MORE_DATA;
			break;
		}

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine)
        free(szLine);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\registry.h ===
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

/****************************************************************************
REGISTRY.H
****************************************************************************/

//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( LPCTSTR pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              LPCTSTR pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS ) ;

    //  Constructor creating a new key.
    CRegKey ( LPCTSTR lpSubKey,
            HKEY hKeyBase,
            LPCTSTR lpValueName = NULL,
            DWORD dwType = 0,
            LPBYTE lpValueData = NULL,
            DWORD cbValueData = 0);

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
            //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( LPCTSTR pchValueName, CString & strResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
	LONG QueryValue ( LPCTSTR pchValueName, LPTSTR szMultiSz, DWORD dwSize );

    //  Overloaded value setting members.
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand = FALSE ) ;
    LONG SetValue ( LPCTSTR pchValueName, DWORD dwResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szMultiSz, DWORD dwSize );

    LONG DeleteValue( LPCTSTR pchKeyName );
    LONG DeleteTree( LPCTSTR pchKeyName );
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;
    LONG Next ( CString * pstrName, CString * pstrValue );

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
        DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

#endif  // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by C:\stacks\lang\usa\setup.rc
//
#define VER_FF_PATCHED                  0
//#define IDS_MD_COM_DISPLAYNAME          1
//#define IDS_PROGGROUP_OLD_IIS           2
//#define IDS_PROGGROUP_OLD_PWS           3
//#define IDS_PROGGROUP_OLD_PWS_W95       4
//#define IDS_PROGITEM_SETUP_PWS          5
//#define IDS_PROGITEM_SETUP_IIS          6
//#define IDS_CTRLPANEL_TITLE             7
//#define IDS_CANNOT_LOAD_ODBCCP32DLL     8
//#define IDS_PROGITEM_PWSITE             10
//#define IDS_NS_IIS_ICONTITLE            12
#define IDS_CANNOT_GET_MACHINE_NAME     13
#define IDS_OS_NOT_SUPPORT              14
#define IDS_CANNOT_DETECT_OS_TYPE       15
//#define IDS_ERROR_DEGRADE               16
//#define IDS_PWS                         17
//#define IDS_IIS                         18
#define IDS_OS_VERSION_NOT_SUPPORTED    20
//#define IDS_GUEST_NAME                  21
//#define IDS_NO_TCPIP                    22
//#define IDS_NO_SUPPORT_ON_K2PDC         23
//#define IDS_USER_COMMENT                24
//#define IDS_USER_FULLNAME               25
//#define IDS_PROGITEM_INETMGR            26
//#define IDS_PROGITEM_KEYRING            27
//#define IDS_PROGITEM_PRODDOC            28
//#define IDS_PERF_MON_FILE               29
//#define IDS_WWWDISPLAYNAME              30
//#define IDS_SPUDDISPLAYNAME             31
//#define IDS_ACCESSDENIED                32
//#define IDS_FTPDISPLAYNAME              33
//#define IDS_REMOVE_GOPHER               34
//#define IDS_PROGITEM_HTMLA              35
//#define IDS_CREATEUSER_FAIL             36
//#define IDS_EULA_ACCEPTED               37
//#define IDS_EULA_DECLINED               38
//#define IDS_VERSION_STRING              39
//#define IDS_SELECT_DIR                  40
#define IDS_NOT_ADMINISTRATOR           41
//#define IDS_NO_SUPPORT_ON_PWS10         42
//#define IDS_NO_SUPPORT_ON_FRONTPG       43
#define IDS_NT4_SP3_NEEDED              44
//#define IDS_NT4_SP3_RISK_WARNING        45
//#define IDS_NO_SUPPORT_ON_PREVIIS       46
#define IDS_NT_SERVER_REQUIRED          47
#define IDS_IIS_REQUIRED                48
#define IDS_PREVIOUS_MCIS_DETECTED      49
#define IDS_SMTPDISPLAYNAME             50
#define IDS_POP3DISPLAYNAME             51
#define IDS_IMAPDISPLAYNAME             52
#define IDS_NNTPDISPLAYNAME             53
#define IDS_INVALID_MAILROOT            54
#define IDS_CONFIRM_CREATE_MAILROOT     55
#define IDS_DISK_NOT_NTFS               56
#define IDS_INVALID_DEFAULT_DOMAIN      57
#define IDS_CANT_CREATE_MAILROOT        58
#define IDS_MAILROOT_NOT_DIRECTORY      59
#define IDS_MAILROOT_NOT_FIXED          60
#define IDS_CONFIRM_REMOVE_ALL_IMS      61
#define IDS_PROGGROUP_NEWS              62
#define IDS_PROGITEM_NEWS_WEBADMIN      63
#define IDS_PROGITEM_NEWS_DOCS          64
#define IDS_PROGGROUP_ADMINTOOLS        65
#define IDS_PROGITEM_NEWS_README        66
//#define IDS_ITEMPATH_NEWS_WEBADMIN      67
//#define IDS_ITEMPATH_NEWS_DOCS          68
//#define IDS_ITEMPATH_NEWS_README        70
//#define IDS_IEXPLORE                    71
#define IDS_PROGGROUP_MAIL              72
#define IDS_PROGITEM_MAIL_SMTP_WEBADMIN 73
//#define IDS_PROGITEM_MAIL_POP3_WEBADMIN 74
//#define IDS_PROGITEM_MAIL_IMAP_WEBADMIN 75
#define IDS_PROGITEM_MAIL_DOCS          76
#define IDS_PROGITEM_MAIL_README        77
//#define IDS_ITEMPATH_MAIL_SMTP_WEBADMIN 78
//#define IDS_ITEMPATH_MAIL_POP3_WEBADMIN 79
//#define IDS_ITEMPATH_MAIL_IMAP_WEBADMIN 80
//#define IDS_ITEMPATH_MAIL_DOCS          81
//#define IDS_ITEMPATH_MAIL_README        82
//#define IDS_CANT_CREATE_NNTPFILE        83
//#define IDS_NNTPFILE_NOT_DIRECTORY      84
//#define IDS_NNTPFILE_NOT_FIXED          85
//#define IDS_INVALID_NNTPFILE            86
//#define IDS_CONFIRM_CREATE_NNTPFILE     87
//#define IDS_CONFIRM_REMOVE_MCIS10_POP3  88
//#define IDS_CANNOT_CONTINUE_WITH_POP3   89
//#define IDS_CANNOT_CHECK_SMTP_WO_NTFS   90
//#define IDS_MAIL_AND_NEWS               91
//#define IDS_MAIL_ONLY                   92
//#define IDS_NEWS_ONLY                   93
//#define IDS_CONFIRM_REMOVE_ALL_INS      94
#define IDS_DEFAULT_IIS_PROGRAM_GROUP   95
#define IDS_DEFAULT_NT_PROGRAM_GROUP    96
#define IDS_PROGGROUP_MCIS10_NEWS       97
#define IDS_PROGITEM_MCIS10_NEWS_WEBADMIN 98
#define IDS_PROGITEM_MCIS10_NEWS_STARTPAGE 99
#define IDS_PROGGROUP_MCIS10_MAIL       100
#define IDS_PROGITEM_MCIS10_MAIL_WEBADMIN 101
#define IDS_PROGITEM_MCIS10_MAIL_STARTPAGE 102
//#define IDS_CONFIRMATION_TEXT           103
#define IDS_MESSAGEBOX_TEXT             104
#define IDS_SUPPRESS_SMTP               105
//#define IDS_INVALID_DSA_ENTERPRISE      106
//#define IDS_DSA_ERROR_SERVERINSTALL     107
//#define IDS_DSA_ERROR_DAPI_NOLOAD       108
//#define IDS_DSA_ERROR_DAPI_FCTN_NOLOAD  109
//#define IDS_DSA_NOHANDLE                110
//#define IDS_DSADISPLAYNAME              111
//#define IDS_DSA_ERROR_CHKDISK           112
//#define IDS_DSA_USERPASS_INVALID        113
//#define IDS_DSA_WARNING_FAILED_POSTMASTER 114
//#define IDS_IIS_CORRUPT                 115
//#define IDS_ADSI_REQUEST                116
//#define IDS_ADSI_REQUIRED_ERR           117
//#define IDS_ADSI_INSTALL_FAILED         118
//#define IDS_NO_K2_SMTP                  119
//#define IDS_EXCHANGE_DS_EXISTS          120
//#define IDS_CONFIRM_REMOVE_ALL_MCIS_MAIL 121
#define IDS_NNTP_DEFAULT_SITE_NAME      122
#define IDS_NNTP_SERVICE_NAME           123
#define IDS_NNTP_DEFAULT_ADMIN_NAME     124
#define IDS_NNTP_DEFAULT_ADMIN_EMAIL    125
#define IDB_BITMAP1                     126
//#define IDS_NNTP_LOG_FILE_FORMATS       127
#define IDS_SMTP_DEFAULT_SITE_NAME      128
//#define IDS_POP3_DEFAULT_SITE_NAME      129
//#define IDS_IMAP_DEFAULT_SITE_NAME      130
//#define IDS_SMTP_LOG_FILE_FORMATS       131
//#define IDS_BITMAP_NTOP                 132
//#define IDS_BITMAP_SMTP                 133
//#define IDS_BITMAP_NNTP                 134
//#define IDS_BITMAP_MCIS_MAIL            135
//#define IDS_BITMAP_MCIS_NEWS            136
//#define IDS_BITMAP_MAIL_SERVER          137
//#define IDS_BITMAP_MS                   138
//#define IDS_BITMAP_NEWS_SERVER          139
//#define IDS_CONFIRM_REMOVE_ALL_MCIS_NEWS 140
//#define IDS_CONFIRM_REMOVE_MCIS_SMTP    141
//#define IDS_DSA_WARNING_FAILED_SECURITY 142
#define IDS_PROGGROUP_MCIS_MAIL_AND_NEWS 143
#define IDS_PROGITEM_MCIS_MAIL_DOCS		144
#define IDS_PROGITEM_MCIS_MAIL_README	145
#define IDS_PROGITEM_ISM				146
//#define IDS_ITEMPATH_ISM				147
//#define IDS_MMC							148
//#define IDS_MCIS_MAIL_ONLY              149
//#define IDS_MCIS_NEWS_ONLY              150
//#define IDS_ROUTE_THRU_DISABLED			151
#define IDS_PROGITEM_MCIS_NEWS_DOCS		152
#define IDS_PROGITEM_MCIS_NEWS_README	153
//#define IDS_NT_REQUIRED					154
//#define IDS_CANNOT_ADMIN_MCIS_MMC		155
//#define IDS_CONFIRM_REMOVE_ALL_RK		156
//#define IDS_MMC_REQUIRED				157
#define IDS_MCIS_2_0					158
//#define IDS_DSA_ADMINISTRATORS			159
//#define IDS_DSA_LOGON_FAILURE			160
//#define IDS_MAIL_AND_NEWS_SETUP			161
//#define IDS_MAIL_ONLY_SETUP             162
//#define IDS_NEWS_ONLY_SETUP             163
//#define IDS_MCIS_MAIL_ONLY_SETUP        164
//#define IDS_MCIS_NEWS_ONLY_SETUP        165
#define IDS_RETRY                       166
#define IDS_PROGITEM_NEWS_README_K2     167
#define IDS_PROGITEM_MAIL_README_K2     168
#define IDS_NNTPDESCRIPTION				169
#define IDS_SMTPDESCRIPTION				170

//#define	idsRegLicenseInfoKey			400
//#define	idsRegDisplayName				401
//#define	idsRegMode						402
//#define	idsProdFamilyName				403
//#define	idsProdName						404
//#define	idsMDBShortName					405

#define LANGID_US                       0409
#if 0
#define IDD_PROPPAGE_WELCOME            501
#define IDD_PROPPAGE_PUBLISH_DIR        502
#define IDD_PROPPAGE_END                503
#define IDD_PROPPAGE_EULA               504
#define IDD_BROWSEDIRECTORY             505
#define IDD_PROPPAGE_MODE_MAINTANENCE   506
#define IDD_PROPPAGE_MODE_FRESH         507
#define IDD_PROPPAGE_MODE_UPGRADE       508
#define IDD_PROPPAGE_DEFAULT_DOMAIN     509
#define IDD_PROPPAGE_MAILROOT_DIR       510
#define IDD_PROPPAGE_DSA_ACCOUNT        511
#define IDD_PROPPAGE_NNTPFILE_DIR       512
#define IDD_PROPPAGE_NNTPROOT_DIR       513
#define IDD_PROPPAGE_DSA                514
#endif
//#define IDB_WELCOMESMTP                 600
//#define IDB_WELCOMENNTP                 601
//#define IDB_BANNER                      602
#define IDB_NNTP                        603
#define IDB_SMTP                        604
//#define IDB_POP3                        605
//#define IDB_IMAP                        606
#define IDB_DOCS                        607
//#define IDB_DSA                         608
//#define IDB_MMC                         609
#if 0
#define IDC_LICENSE_TEXT                1000
#define IDC_EULA_ACCEPT                 1001
#define IDC_EULA_DECLINE                1002
#define IDC_WWW_PUB_GROUP               1003
#define IDC_FTP_PUB_GROUP               1004
#define IDC_WWW_PUB_EDIT                1005
#define IDC_FTP_PUB_EDIT                1006
#define IDC_WWW_PUB_BROWSE              1007
#define IDC_FTP_PUB_BROWSE              1008
#define IDC_ADDREMOVE                   1009
#define IDC_REINSTALL                   1010
#define IDC_REMOVEALL                   1011
#define IDC_MINIMUM                     1012
#define IDC_TYPICAL                     1013
#define IDC_CUSTOM                      1014
#define IDC_UPGRADEONLY                 1015
#define IDC_ADDEXTRACOMPS               1016
#define IDC_FRAME_WELCOME               1017
#define IDC_FRAME_BANNER                1018
#define IDC_DEFAULT_DOMAIN_EDIT         1019
#define IDC_DEFAULT_DOMAIN_GROUP        1020
#define IDC_MAILROOT_DIR_GROUP          1021
#define IDC_MAILROOT_DIR_EDIT           1022
#define IDC_MAILROOT_DIR_BROWSE         1023
#define IDC_NNTPROOT_DIR_GROUP          1024
#define IDC_NNTPROOT_DIR_EDIT           1025
#define IDC_NNTPROOT_DIR_BROWSE         1026
#define IDC_NNTPFILE_DIR_GROUP          1027
#define IDC_NNTPFILE_DIR_EDIT           1028
#define IDC_NNTPFILE_DIR_BROWSE         1029
#define IDC_DSA_ENTERPRISE_GROUP        1030
#define IDC_DSA_SITE_GROUP              1031
#define IDC_DSA_ENTERPRISE_EDIT         1032
#define IDC_DSA_SITE_EDIT               1033
#define IDC_stc1                        1034
#define IDC_stc2                        1035
#define IDC_stc3                        1036
#define IDC_stc4                        1037
#define IDC_lst1                        1038
#define IDC_lst2                        1039
#define IDC_cmb1                        1040
#define IDC_cmb2                        1041
#define IDC_edt1                        1042
#define IDC_DSA_PASSWORD_GROUP          1043
#define IDC_DSA_ACCOUNT_GROUP           1044
#define IDC_DSA_ACCOUNT_EDIT            1045
#define IDC_DSA_PASSWORD_EDIT           1046
#define IDC_FRAME_BANNER_MS             2009
#define IDC_FRAME_BANNER_TITLE          2010
#define IDC_FRAME_BANNER_DSA_PASS       2011
#endif

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1024
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\seoutils.cpp ===
#include "stdafx.h"

#include "utils.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include "seo.h"
#include "seolib.h"

#include "seo_i.c"

#define INITGUID
#include <initguid.h>
#include "smtpguid.h"

#define STR_SMTP_NTFSDRV_DISPLAY_NAME   "Exchange Ntfs Store Driver"
#define STR_SMTP_NTFSDRV_SINKCLASS      "Exchange.NtfsDrv"
#define LONG_SMTP_NTFSDRV_PRIORITY      28000

// {C028FD82-F943-11d0-85BD-00C04FB960EA}
DEFINE_GUID(NNTP_SOURCE_TYPE_GUID, 
0xc028fd82, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

DEFINE_GUID(GUID_SMTP_NTFSDRV_BINDING,
0x609b7e3a, 0xc918, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

HRESULT RegisterSEOService() 
{
    HRESULT hr;
    //
    // see if we've done the service level registration by getting the list
    // of source types and seeing if the SMTP source type is registered
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    if (FAILED(hr))
        return hr;

    // if this failed then we need to register the source type and event
    // component categories
    if (hr == S_FALSE)
    {
        // register the component categories
        CComPtr<IEventComCat> pComCat;
        hr = CoCreateInstance(CLSID_CEventComCat, NULL, CLSCTX_ALL,
                              IID_IEventComCat, (LPVOID *) &pComCat);
        if (hr != S_OK)
            return hr;

        // register the source type
        hr = pSourceTypes->Add(bstrSourceTypeGUID, &pSourceType);
        if (FAILED(hr))
            return hr;

        _ASSERT(hr == S_OK);
        CComBSTR bstrSourceTypeDisplayName = "SMTP Server";
        hr = pSourceType->put_DisplayName(bstrSourceTypeDisplayName);
        if (FAILED(hr))
            return hr;

        hr = pSourceType->Save();
        if (FAILED(hr))
            return hr;

        // add the event types to the source type
        CComPtr<IEventTypes> pEventTypes;
        hr = pSourceType->get_EventTypes(&pEventTypes);
        if (FAILED(hr))
            return hr;

        //
        // Register the event categories
        //
        struct {
            CONST GUID * pcatid;
            LPSTR szDisplayName;
        }  rgCATTable[] = {
            //
            // Protocol event categories
            //
            { &CATID_SMTP_ON_INBOUND_COMMAND,              "SMTP Protocol OnInboundCommand" },
            { &CATID_SMTP_ON_SERVER_RESPONSE,              "SMTP Protocol OnServerResponse" },
            { &CATID_SMTP_ON_SESSION_START,                "SMTP Protocol OnSessionStart" },
            { &CATID_SMTP_ON_MESSAGE_START,                "SMTP Protocol OnMessageStart" },
            { &CATID_SMTP_ON_PER_RECIPIENT,                "SMTP Protocol OnPerRecipient" },
            { &CATID_SMTP_ON_BEFORE_DATA,                  "SMTP Protocol OnBeforeData" },
            { &CATID_SMTP_ON_SESSION_END,                  "SMTP Protocol OnSessionEnd" },

            { &CATID_SMTP_LOG, 								"SMTP OnEventLog" },

            //
            // Transport event categories
            //
            { &CATID_SMTP_STORE_DRIVER,                    "SMTP StoreDriver" },
            { &CATID_SMTP_TRANSPORT_SUBMISSION,            "SMTP Transport OnSubmission" },
            { &CATID_SMTP_TRANSPORT_PRECATEGORIZE,         "SMTP Transport OnPreCategorize" },
            { &CATID_SMTP_TRANSPORT_CATEGORIZE,            "SMTP Transport OnCategorize" },
            { &CATID_SMTP_TRANSPORT_POSTCATEGORIZE,        "SMTP Transport OnPostCategorize" },
            { &CATID_SMTP_TRANSPORT_ROUTER,                "SMTP Transport OnGetMessageRouter" },
            { &CATID_SMTP_MSGTRACKLOG,                     "SMTP Transport OnMsgTrackLog" },
            { &CATID_SMTP_DNSRESOLVERRECORDSINK,           "SMTP Transport OnDnsResolveRecord" },
            { &CATID_SMTP_MAXMSGSIZE,                      "SMTP Transport OnMaxMsgSize" },
            { &CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS,	"SMTP Transport GetAuxiliaryDomainInfoFlags" }
        };

        for(DWORD dwCount = 0; 
            dwCount < (sizeof(rgCATTable)/sizeof(rgCATTable[0])); 
            dwCount++) {

            CComBSTR bstrCATID = (LPCOLESTR) CStringGUID( *(rgCATTable[dwCount].pcatid) );
            CComBSTR bstrDisplayName = rgCATTable[dwCount].szDisplayName;
            //
            // Register the category
            //
            hr = pComCat->RegisterCategory( bstrCATID, bstrDisplayName, 0);
            if(FAILED(hr))
                return hr;
            //
            // Add the category to the SMTP source type
            //
            hr = pEventTypes->Add( bstrCATID );
            if(FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

HRESULT pRegisterSEOForSmtp(BOOL fSetUpSourceType)
{
    HRESULT hr;
    CComPtr<IEventUtil> pEventUtil;
    TCHAR szDisplayName[32];
    CComPtr<IEventBindingManager> pBindingManager;
    CComPtr<IEventBindings> pBindings;
    CComPtr<IEventBinding> pBinding;
    CComPtr<IEventPropertyBag> pSourceProps;

    DebugOutput(_T("Registering Server Events"));

    // Register the source type, event types
    if (fSetUpSourceType)
    {
        DebugOutput(_T("Setting up source and event types"));
        hr = RegisterSEOService();
    }

    // Set up the default site (instance)
    lstrcpy(szDisplayName,_T("smtpsvc 1"));

    hr = CoCreateInstance(CLSID_CEventUtil,NULL,CLSCTX_ALL,IID_IEventUtil,(LPVOID *) &pEventUtil);
    if (FAILED(hr)) return(hr);
    hr = pEventUtil->RegisterSource(CComBSTR((LPCWSTR) CStringGUID(GUID_SMTP_SOURCE_TYPE)),
                                    CComBSTR((LPCWSTR) CStringGUID(GUID_SMTPSVC_SOURCE)),
                                    1,
                                    CComBSTR(_T("smtpsvc")),
                                    CComBSTR(_T("")),
                                    CComBSTR(_T("event.metabasedatabasemanager")),
                                    CComBSTR(szDisplayName),
                                    &pBindingManager);
    if (FAILED(hr)) goto Exit;
    hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_STORE_DRIVER)),
                                       &pBindings);

    if (FAILED(hr)) goto Exit;

    // Set up the NTFS driver sink
    hr = pBindings->Add(CComBSTR((LPCWSTR) CStringGUID(GUID_SMTP_NTFSDRV_BINDING)),&pBinding);
    if (FAILED(hr)) goto Exit;
    hr = pBinding->put_DisplayName(CComBSTR(STR_SMTP_NTFSDRV_DISPLAY_NAME));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->put_SinkClass(CComBSTR(STR_SMTP_NTFSDRV_SINKCLASS));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->get_SourceProperties(&pSourceProps);
    if (FAILED(hr)) goto Exit;
    hr = pSourceProps->Add(CComBSTR(_T("priority")),&CComVariant(LONG_SMTP_NTFSDRV_PRIORITY));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->Save();
    if (FAILED(hr)) goto Exit;

//  hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_ON_DELIVERY)),
//                                 &pBindings);

Exit:
    return(hr);
}

HRESULT RegisterSEOForSmtp(BOOL fSetUpSourceType)
{
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = pRegisterSEOForSmtp(fSetUpSourceType);
    CoUninitialize();

    return(hr);
}

HRESULT UnregisterSEOSourcesForSourceType(GUID guidSourceType) {
    HRESULT hr;

    //
    // find the NNTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK) return hr;
    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr)) return hr;
    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(guidSourceType);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK) return hr;

    //
    // get the list of sources registered for this source type
    //
    CComPtr<IEventSources> pSources;
    hr = pSourceType->get_Sources(&pSources);
    if (FAILED(hr)) return hr;
    CComPtr<IEnumVARIANT> pSourceEnum;
    hr = pSources->get__NewEnum((IUnknown **) &pSourceEnum);
    if (FAILED(hr)) return hr;

    do {
        VARIANT varSource;

        hr = pSourceEnum->Next(1, &varSource, NULL);
        if (FAILED(hr)) return hr;
        if (hr == S_OK) {
            if (varSource.vt == VT_DISPATCH) {
                CComPtr<IEventSource> pSource;

                // QI for the IEventSource interface
                hr = varSource.punkVal->QueryInterface(IID_IEventSource, 
                                                     (void **) &pSource);
                if (FAILED(hr)) return hr;
                varSource.punkVal->Release();

                // get the binding manager
                CComBSTR bstrSourceID;
                hr = pSource->get_ID(&bstrSourceID);
                if (FAILED(hr)) return hr;

                hr = pSources->Remove(&CComVariant(bstrSourceID));
                _ASSERT(SUCCEEDED(hr));

                pSource.Release();
            } else {
                _ASSERT(FALSE);
            }
        }
    } while (hr == S_OK);

    return S_OK;
}

HRESULT UnregisterSEOSourcesForSMTP(void) {
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = UnregisterSEOSourcesForSourceType(GUID_SMTP_SOURCE_TYPE);
    CoUninitialize();

    return hr;
}

HRESULT UnregisterSEOSourcesForNNTP(void) {
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = UnregisterSEOSourcesForSourceType(NNTP_SOURCE_TYPE_GUID);
    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#ifdef _DEBUG
#undef _DEBUG
#endif

#include <tchar.h>
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#undef ASSERT
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>

extern "C"
{
#include <ntsam.h>
#include <ntlsa.h>
#include <lm.h>
#include <lmerr.h>
}

#include "resource.h"
#include "registry.h"
#include "const.h"
#include "initapp.h"
#include "helper.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\runadmin.cpp ===
#include "stdafx.h"

//
// Check whether we are running as administrator on the machine
// or not
//

// Copy it from MSDN
// Windows Articles: Networking Articles, Windows NT Security

BOOL RunningAsAdministrator()
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    // First we must open a handle to the access token for this thread.
    
    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
#endif //_CHICAGO_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\smtp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"

#include "utils.h"
#include "regctrl.h"
#include "userenv.h"
#include "userenvp.h"

GUID    g_SMTPGuid   = { 0x475e3e80, 0x3193, 0x11cf, 0xa7, 0xd8,
						 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x35 };

static TCHAR szShortSvcName[] = _T("SMTP");

INT Register_iis_smtp_nt5(BOOL fUpgrade, BOOL fReinstall)
{
    INT err = NERR_Success;
    CString csBinPath;

    BOOL fSvcExist = FALSE;

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

	if (fReinstall)
		return err;

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

        // System\CurrentControlSet\Services\SMTPSVC\Parameters
        InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

        // Software\Microsoft\Keyring\Parameters
		CString csSmtpkeyDll;
        CRegKey regKeyring( REG_KEYRING, regMachine );
        if ((HKEY) regKeyring )
		{
			csSmtpkeyDll = theApp.m_csPathInetsrv;
			csSmtpkeyDll += _T("\\smtpkey.dll");
			regKeyring.SetValue( szShortSvcName, csSmtpkeyDll );
		}

		// If we are upgrading, we will first delete the service and re-register
		if (fUpgrade)
		{
			InetDeleteService(SZ_SMTPSERVICENAME);
			InetRegisterService( theApp.m_csMachineName, 
							SZ_SMTPSERVICENAME, 
							&g_SMTPGuid, 0, 25, FALSE );
		}

		// Create or Config SMTP service
		CString csDisplayName;
		CString csDescription;

		MyLoadString( IDS_SMTPDISPLAYNAME, csDisplayName );
		MyLoadString(IDS_SMTPDESCRIPTION, csDescription);
		csBinPath = theApp.m_csPathInetsrv + _T("\\inetinfo.exe") ;

		err = InetCreateService(SZ_SMTPSERVICENAME, 
							(LPCTSTR)csDisplayName, 
							(LPCTSTR)csBinPath, 
							theApp.m_fSuppressSmtp ? SERVICE_DISABLED : SERVICE_AUTO_START, 
							SZ_SVC_DEPEND,
							(LPCTSTR)csDescription);
		if ( err != NERR_Success )
		{
			if (err == ERROR_SERVICE_EXISTS)
			{
				fSvcExist = TRUE;
				err = InetConfigService(SZ_SMTPSERVICENAME, 
								(LPCTSTR)csDisplayName, 
								(LPCTSTR)csBinPath, 
								SZ_SVC_DEPEND,
								(LPCTSTR)csDescription);
				if (err != NERR_Success)
				{
					SetErrMsg(_T("SMTP InetConfigService failed"), err);
				}
			}
		}

        if (fIISADMINExists)
        {
            // Migrate registry keys to the metabase. Or create from default values
		    // if fresh install
            MigrateIMSToMD(theApp.m_hInfHandle[MC_IMS],
						    SZ_SMTPSERVICENAME, 
						    _T("SMTP_REG"), 
						    MDID_SMTP_ROUTING_SOURCES,
						    fUpgrade);
	    SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
	    SetAdminACL_wrap(_T("LM/SMTPSVC"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
        }

        // Create key \System\CurrentControlSet\Services\SmtpSvc\Performance:
        // Add the following values:
        // Library = smtpctrs.DLL
        // Open = OpenSMTPPerformanceData
        // Close = CloseSMTPPerformanceData
        // Collect = CollectSMTPPerformanceData
        InstallPerformance(REG_SMTPPERFORMANCE, 
						_T("smtpctrs.DLL"), 
						_T("OpenSmtpPerformanceData"),
						_T("CloseSmtpPerformanceData"), 
						_T("CollectSmtpPerformanceData"));
        InstallPerformance(REG_NTFSPERFORMANCE, 
						_T("snprfdll.DLL"), 
						_T("NTFSDrvOpen"),
						_T("NTFSDrvClose"), 
						_T("NTFSDrvCollect"));

		//
		// We used to register the SMTPB agent here.  Now we unregister it in
		// case we're upgrading since it's no longer supported
		//

		RemoveAgent( SZ_SMTPSERVICENAME );
 
        // Create key \System\CurrentControlSet\Services\EventLog\System\SmtpSvc:
        // Add the following values:
        // EventMessageFile = ..\smtpmsg.dll
        // TypesSupported = 7
        csBinPath = theApp.m_csPathInetsrv + _T("\\smtpsvc.dll");
        AddEventLog( SZ_SMTPSERVICENAME, csBinPath, 0x07 );

        if (!fSvcExist) 
		{
            InetRegisterService( theApp.m_csMachineName, 
								SZ_SMTPSERVICENAME, 
								&g_SMTPGuid, 0, 25, TRUE );
        }

        // Unload the counters and then reload them
        err = unlodctr( SZ_SMTPSERVICENAME );
	    err = unlodctr( SZ_NTFSDRVSERVICENAME );

        err = lodctr(_T("smtpctrs.ini"));
        err = lodctr(_T("ntfsdrct.ini"));

        // register OLE objects
		SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
		SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

		err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
												_T("SMTP_REGISTER"), 
												TRUE);

		SetEnvironmentVariable(_T("__SYSDIR"), NULL);
		SetEnvironmentVariable(_T("__INETSRV"), NULL);

		// Server Events: We are clean installing MCIS, so we make sure we set up
		// everything, including the source type and event types.
		RegisterSEOForSmtp(TRUE);

    } while ( 0 );

    return err;
}

INT Unregister_iis_smtp()
{
    CRegKey regMachine = HKEY_LOCAL_MACHINE;
	INT err = NERR_Success;

	// Unregister all of the NNTP sources in the SEO binding database
	UnregisterSEOSourcesForSMTP();

	// Unregister the OLE objets
	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);

	err = RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_UNREGISTER"), 
											FALSE);

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

	// Bug 51537: Remove MIB from K2 SMTP
	RemoveAgent( SZ_SMTPSERVICENAME );
	
	RemoveEventLog( SZ_SMTPSERVICENAME );
    
	err = unlodctr( SZ_SMTPSERVICENAME );
	err = unlodctr( SZ_NTFSDRVSERVICENAME );
    
	InetDeleteService(SZ_SMTPSERVICENAME);
    InetRegisterService( theApp.m_csMachineName, 
					SZ_SMTPSERVICENAME, 
					&g_SMTPGuid, 0, 25, FALSE );

	// Blow away the Services\SMTPSVC registry key
	CRegKey RegSvcs(HKEY_LOCAL_MACHINE, REG_SERVICES);
	if ((HKEY)RegSvcs)
	{
		RegSvcs.DeleteTree(SZ_SMTPSERVICENAME);
		RegSvcs.DeleteTree(SZ_NTFSDRVSERVICENAME);
	}

    // Blow away SMTP key manager
    CRegKey regKeyring( HKEY_LOCAL_MACHINE, REG_KEYRING );
    if ((HKEY) regKeyring )
	{
		regKeyring.DeleteValue(szShortSvcName);
	}

    // remove LM/SMTPSVC in the metabase
    if (DetectExistingIISADMIN())
    {
        CMDKey cmdKey;
        cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(SZ_SMTPSERVICENAME);
            cmdKey.Close();
        }
    }
     
	// remove K2 items from the program groups
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
					FALSE);
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_README,
					FALSE);
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_README_K2,
					FALSE);

	RemoveInternetShortcut(MC_IMS, 
				IDS_PROGITEM_MCIS_MAIL_README,
				TRUE);
	RemoveInternetShortcut(MC_IMS, 
				IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
				TRUE);

    //
    //  remove the one and only webadmin link from "administrative tools"
    //
	RemoveNt5InternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN);

    return(err);
}
 
INT Upgrade_iis_smtp_nt5_fromk2(BOOL fFromK2)
{
    //  This function handles upgrade from NT4 K2, or MCIS 2.0
    INT err = NERR_Success;
    CString csBinPath;

	DebugOutput(_T("Upgrading from %s to B3 ..."), (fFromK2)? _T("NT4 K2") : _T("MCIS 2.0"));

    BOOL    fSvcExist = FALSE;

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\SMTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

    if (fIISADMINExists)
    {
        // Migrate registry keys to the metabase. Or create from default values
		// if fresh install
        MigrateIMSToMD(theApp.m_hInfHandle[MC_IMS],
						SZ_SMTPSERVICENAME, 
						_T("SMTP_REG_UPGRADEK2"), 
						MDID_SMTP_ROUTING_SOURCES,
						TRUE);
	    // bugbug: x5 bug 72284, nt bug 202496  Uncomment this when NT
	    // is ready to accept these changes
	    SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
	    SetAdminACL_wrap(_T("LM/SMTPSVC"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

    // Unload the counters and then reload them
    err = unlodctr( SZ_SMTPSERVICENAME );
    err = unlodctr( SZ_NTFSDRVSERVICENAME );

    err = lodctr(_T("smtpctrs.ini"));
    err = lodctr(_T("ntfsdrct.ini"));

	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);
	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_REGISTER"), 
											TRUE);

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

	// Server Events: We are clean installing MCIS, so we make sure we set up
	// everything, including the source type and event types.
	RegisterSEOForSmtp(TRUE);

	if (fFromK2)
    {
        // upgrade from K2, remove those K2 links
        RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
					    FALSE);
	    RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_README,
					    FALSE);
	    RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_README_K2,
					    FALSE);
    }
    else
    {
        // upgrade from MCIS 2.0, remove those MCIS links
	    RemoveInternetShortcut(MC_IMS, 
				    IDS_PROGITEM_MCIS_MAIL_README,
				    TRUE);
	    RemoveInternetShortcut(MC_IMS, 
				    IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
				    TRUE);
        RemoveISMLink();
    }
 
    return err;
}

INT Upgrade_iis_smtp_nt5_fromb2(BOOL fFromB2)
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from NT5 %s to B3 ..."), (fFromB2)? _T("B2") : _T("B3"));

	//  If it's just upgrades between B3 bits, don't need to do any metabase operations.
	if (!fFromB2)
		return err;

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

	// set the K2 Upgrade key to true.
	if (fIISADMINExists)
    {
        MigrateIMSToMD( theApp.m_hInfHandle[MC_IMS],
                        NULL,
                        _T("SMTP_REG_K2_TO_EE"),
                        0,
                        FALSE,
                        TRUE );
        MigrateIMSToMD( theApp.m_hInfHandle[MC_IMS],
                        SZ_SMTPSERVICENAME,
                        _T("SMTP_REG_UPGRADEB2"),
                        MDID_SMTP_ROUTING_SOURCES,
						FALSE );
        SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
        SetAdminACL_wrap(_T("LM/SMTPSVC"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_REGISTER"), 
											TRUE);

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

	// Server Events: We are upgrading from K2, so we will register the 
	// default site (instance) and the MBXSINK binding.
	RegisterSEOForSmtp(FALSE);

    // System\CurrentControlSet\Services\SMTPSVC\Parameters
	InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

	return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\utils.cpp ===
#include "stdafx.h"

#include "userenv.h"
#include "userenvp.h"

#include "shlobj.h"
#include "utils.h"

#include "mddefw.h"
#include "mdkey.h"

#include "wizpages.h"

#include "ocmanage.h"
#include "setupapi.h"
#include "k2suite.h"

extern OCMANAGER_ROUTINES gHelperRoutines;

DWORD GetUnattendedMode(HANDLE hUnattended, LPCTSTR szSubcomponent)
{
	BOOL		b = FALSE;
	TCHAR		szLine[1024];
	DWORD		dwMode = SubcompUseOcManagerDefault;
	CString		csMsg;

	csMsg = _T("GetUnattendedMode ");
	csMsg += szSubcomponent;
	csMsg += _T("\n");
	DebugOutput((LPCTSTR)csMsg);

	// Try to get the line of interest
	if (hUnattended && (hUnattended != INVALID_HANDLE_VALUE))
	{
		b = SetupGetLineText(NULL, hUnattended, _T("Components"),
							 szSubcomponent, szLine, sizeof(szLine)/sizeof(szLine[0]), NULL);
		if (b)
		{
			csMsg = szSubcomponent;
			csMsg += _T(" = ");
			csMsg += szLine;
			csMsg += _T("\n");
			DebugOutput((LPCTSTR)csMsg);

			// Parse the line
			if (!lstrcmpi(szLine, _T("on")))
			{
				dwMode = SubcompOn;
			}
			else if (!lstrcmpi(szLine, _T("off")))
			{
				dwMode = SubcompOff;
			}
			else if (!lstrcmpi(szLine, _T("default")))
			{
				dwMode = SubcompUseOcManagerDefault;
			}
		}
		else
			DebugOutput(_T("SetupGetLineText failed."));
	}

	return(dwMode);
}

DWORD GetUnattendedModeFromSetupMode(
			HANDLE	hUnattended,
			DWORD	dwComponent,
			LPCTSTR	szSubcomponent)
{
	BOOL		b = FALSE;
	TCHAR		szProperty[64];
	TCHAR		szLine[1024];
	DWORD		dwMode = SubcompUseOcManagerDefault;
	DWORD		dwSetupMode;

	DebugOutput(_T("GetUnattendedModeFromSetupMode %s"), szSubcomponent);

	// Try to get the line of interest
	if (hUnattended && (hUnattended != INVALID_HANDLE_VALUE))
	{
		dwSetupMode = GetIMSSetupMode();
		switch (dwSetupMode)
		{
		case IIS_SETUPMODE_MINIMUM:
		case IIS_SETUPMODE_TYPICAL:
		case IIS_SETUPMODE_CUSTOM:
			// One of the fresh modes
			lstrcpy(szProperty, _T("FreshMode"));
			break;

		case IIS_SETUPMODE_UPGRADEONLY:
		case IIS_SETUPMODE_ADDEXTRACOMPS:
			// One of the upgrade modes
			lstrcpy(szProperty, _T("UpgradeMode"));
			break;

		case IIS_SETUPMODE_ADDREMOVE:
		case IIS_SETUPMODE_REINSTALL:
		case IIS_SETUPMODE_REMOVEALL:
			// One of the maintenance modes
			lstrcpy(szProperty, _T("MaintenanceMode"));
			break;

		default:
			// Error! Use defaults
			return(SubcompUseOcManagerDefault);
		}

		// Get the specified line
		b = SetupGetLineText(
					NULL,
					hUnattended,
					_T("Global"),
					szProperty,
					szLine,
					sizeof(szLine)/sizeof(szLine[0]),
					NULL);
		if (b)
		{
			DWORD dwOriginalMode;

			DebugOutput(_T("%s = %s"), szProperty, szLine);

			// See which setup mode we will end up with
			if (!lstrcmpi(szLine, _T("Minimal")))
				dwSetupMode = IIS_SETUPMODE_MINIMUM;
			else if (!lstrcmpi(szLine, _T("Typical")))
				dwSetupMode = IIS_SETUPMODE_TYPICAL;
			else if (!lstrcmpi(szLine, _T("Custom")))
				dwSetupMode = IIS_SETUPMODE_CUSTOM;
			else if (!lstrcmpi(szLine, _T("AddRemove")))
				dwSetupMode = IIS_SETUPMODE_ADDREMOVE;
			else if (!lstrcmpi(szLine, _T("RemoveAll")))
				dwSetupMode = IIS_SETUPMODE_REMOVEALL;
			else if (!lstrcmpi(szLine, _T("UpgradeOnly")))
				dwSetupMode = IIS_SETUPMODE_UPGRADEONLY;
			else if (!lstrcmpi(szLine, _T("AddExtraComps")))
				dwSetupMode = IIS_SETUPMODE_ADDEXTRACOMPS;
			else
				return(SubcompUseOcManagerDefault);

			// Get the custom unattended setting
			dwMode = GetUnattendedMode(hUnattended, szSubcomponent);

			// Do the right thing based on the setup mode
			SetIMSSetupMode(dwSetupMode);
			switch (dwSetupMode)
			{
			case IIS_SETUPMODE_MINIMUM:
			case IIS_SETUPMODE_TYPICAL:
				// Minimum & typical means the same:
				// Install all for SMTP, none for NNTP
				DebugOutput(_T("Unattended mode is MINIMUM/TYPICAL"));
				if (dwComponent == MC_IMS)
					dwMode = SubcompOn;
				else
					dwMode = SubcompOff;
				break;

			case IIS_SETUPMODE_CUSTOM:
				// For custom we use the custom setting
				DebugOutput(_T("Unattended mode is CUSTOM"));
				break;

			case IIS_SETUPMODE_UPGRADEONLY:
				// Return the original state
				DebugOutput(_T("Unattended mode is UPGRADEONLY"));
				dwMode = gHelperRoutines.QuerySelectionState(
						 gHelperRoutines.OcManagerContext,
						 szSubcomponent,
						 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
				break;

			case IIS_SETUPMODE_ADDEXTRACOMPS:
				// Turn it on only if the old state is off and the
				// custom state is on
				DebugOutput(_T("Unattended mode is ADDEXTRACOMPS"));
				dwOriginalMode = gHelperRoutines.QuerySelectionState(
						 gHelperRoutines.OcManagerContext,
						 szSubcomponent,
						 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
				if (dwOriginalMode == SubcompOff &&
					dwMode == SubcompOn)
					dwMode = SubcompOn;
				else
					dwMode = dwOriginalMode;
				break;

			case IIS_SETUPMODE_ADDREMOVE:
				// Return the custom setting
				DebugOutput(_T("Unattended mode is ADDREMOVE"));
				break;

			case IIS_SETUPMODE_REMOVEALL:
				// Kill everything
				DebugOutput(_T("Unattended mode is REMOVEALL"));
				dwMode = SubcompOff;
				break;
			}

			DebugOutput(_T("Unattended state for %s is %s"),
					szSubcomponent,
					(dwMode == SubcompOn)?_T("ON"):_T("OFF"));
		}
		else
		{
			if (GetLastError() != ERROR_LINE_NOT_FOUND)
				DebugOutput(_T("SetupGetLineText failed (%x)."), GetLastError());
		}
	}

	return(dwMode);
}

BOOL DetectExistingSmtpServers()
{
    // Detect other mail servers
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\MsExchangeIMC\Parameters
    CRegKey regSMTPParam( regMachine, REG_EXCHANGEIMCPARAMETERS, KEY_READ );
    if ((HKEY) regSMTPParam )
	{
		CString csCaption;

		DebugOutput(_T("IMC detected, suppressing SMTP"));

		if (!theApp.m_fIsUnattended && !theApp.m_fNTGuiMode)
		{
			MyLoadString(IDS_MESSAGEBOX_TEXT, csCaption);
			PopupOkMessageBox(IDS_SUPPRESS_SMTP, csCaption);
		}

		return(TRUE);
	}

	DebugOutput(_T("No other SMTP servers detected, installing IMS."));
	return(FALSE);
}

BOOL DetectExistingIISADMIN()
{
    //
    //  Detect is IISADMIN service exists
    //
    //  This is to make sure we don't do any metabase operation if
    //  IISADMIN doesn't exists, especially in the uninstall cases.
    //
    DWORD dwStatus = 0;
    dwStatus = InetQueryServiceStatus(SZ_MD_SERVICENAME);
    if (0 == dwStatus)
    {
        // some kind of error occur during InetQueryServiceStatus.
        DebugOutput(_T("DetectExistingIISADMIN() return FALSE"));
        return (FALSE);
    }

    return(TRUE);
}

BOOL InsertSetupString( LPCSTR REG_PARAMETERS )
{
    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    CRegKey regParam( (LPCTSTR) REG_PARAMETERS, regMachine );
    if ((HKEY) regParam) {
        regParam.SetValue( _T("MajorVersion"), (DWORD)STAXNT5MAJORVERSION );
        regParam.SetValue( _T("MinorVersion"), (DWORD)STAXNT5MINORVERSION );
        regParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

        switch (theApp.m_eNTOSType) {
        case OT_NTW:
            regParam.SetValue( _T("SetupString"), REG_SETUP_STRING_NT5WKSB3 );
            break;

        default:
            _ASSERT(!"Unknown OS type");
            // Fall through

        case OT_NTS:
        case OT_PDC_OR_BDC:
        case OT_PDC:
        case OT_BDC:
            regParam.SetValue( _T("SetupString"), REG_SETUP_STRING_NT5SRVB3 );
            break;
        }
    }

    return TRUE;
}

// Scans a multi-sz and finds the first occurrence of the
// specified string
LPTSTR ScanMultiSzForSz(LPTSTR szMultiSz, LPTSTR szSz)
{
	LPTSTR lpTemp = szMultiSz;

	do
	{
		if (!lstrcmpi(lpTemp, szSz))
			return(lpTemp);

		lpTemp += lstrlen(lpTemp);
		lpTemp++;

	} while (*lpTemp != _T('\0'));

	return(NULL);
}

// Removes the said string from a MultiSz
// This places a lot of faith in the caller!
void RemoveSzFromMultiSz(LPTSTR szSz)
{
	LPTSTR lpScan = szSz;
	TCHAR  tcLastChar;

	lpScan += lstrlen(szSz);
	lpScan++;

	tcLastChar = _T('x');
	while ((tcLastChar != _T('\0')) ||
		   (*lpScan != _T('\0')))
	{
		tcLastChar = *lpScan;
		*szSz++ = *lpScan++;
	}

	*szSz++ = _T('\0');

	// Properly terminate it if it's the last one
	if (*lpScan == _T('\0'))
		*szSz = _T('\0');
}

// This walks the multi-sz and returns a pointer between
// the last string of a multi-sz and the second terminating
// NULL
LPTSTR GetEndOfMultiSz(LPTSTR szMultiSz)
{
	LPTSTR lpTemp = szMultiSz;

	do
	{
		lpTemp += lstrlen(lpTemp);
		lpTemp++;

	} while (*lpTemp != _T('\0'));

	return(lpTemp);
}

// This appends a string to the end of a multi-sz
// The buffer must be long enough
BOOL AppendSzToMultiSz(LPTSTR szMultiSz, LPTSTR szSz, DWORD dwMaxSize)
{
	LPTSTR szTemp = szMultiSz;
	DWORD dwLength = lstrlen(szSz);

	// If the string is empty, do not append!
	if (*szMultiSz == _T('\0') &&
		*(szMultiSz + 1) == _T('\0'))
		szTemp = szMultiSz;
	else
	{
		szTemp = GetEndOfMultiSz(szMultiSz);
		dwLength += (DWORD)(szTemp - szMultiSz);
	}

	if (dwLength >= dwMaxSize)
		return(FALSE);

	lstrcpy(szTemp, szSz);
	szMultiSz += dwLength;
	*szMultiSz = _T('\0');
	*(szMultiSz + 1) = _T('\0');
	return(TRUE);
}

BOOL AddServiceToDispatchList(LPTSTR szServiceName)
{
	TCHAR szMultiSz[4096];
	DWORD dwSize = 4096;

	CRegKey RegInetInfo(REG_INETINFOPARAMETERS, HKEY_LOCAL_MACHINE);
	if ((HKEY)RegInetInfo)
	{
		// Default to empty string if not exists
		szMultiSz[0] = _T('\0');
		szMultiSz[1] = _T('\0');

		if (RegInetInfo.QueryValue(SZ_INETINFODISPATCH, szMultiSz, dwSize) == NO_ERROR)
		{
			// Walk the list to see if the value is already there
			if (ScanMultiSzForSz(szMultiSz, szServiceName))
				return(TRUE);
		}

		// Create the value and add it to the list
		if (!AppendSzToMultiSz(szMultiSz, szServiceName, dwSize))
			return(FALSE);

		// Get the size of the new Multi-sz
		dwSize = (DWORD)(GetEndOfMultiSz(szMultiSz) - szMultiSz) + 1;

		// Write the value back to the registry
		if (RegInetInfo.SetValue(SZ_INETINFODISPATCH, szMultiSz, dwSize * (DWORD) sizeof(TCHAR)) == NO_ERROR)
			return(TRUE);
	}

	// If the InetInfo key is not here, there isn't much we can do ...
	return(FALSE);
}

BOOL RemoveServiceFromDispatchList(LPTSTR szServiceName)
{
	TCHAR szMultiSz[4096];
	DWORD dwSize = 4096;
	LPTSTR szTemp;
	BOOL fFound = FALSE;

	CRegKey RegInetInfo(HKEY_LOCAL_MACHINE, REG_INETINFOPARAMETERS);
	if ((HKEY)RegInetInfo)
	{
		if (RegInetInfo.QueryValue(SZ_INETINFODISPATCH, szMultiSz, dwSize) == NO_ERROR)
		{
			// Walk the list to see if the value is already there
			while (szTemp = ScanMultiSzForSz(szMultiSz, szServiceName))
			{
				RemoveSzFromMultiSz(szTemp);
				fFound = TRUE;
			}
		}

		// Write the value back to the registry if necessary, note we
		// will indicate success if the string is not found
		if (!fFound)
			return(TRUE);

		// Get the size of the new Multi-sz
		dwSize = (DWORD)(GetEndOfMultiSz(szMultiSz) - szMultiSz) + 1;

		// Write the value back to the registry
		if (RegInetInfo.SetValue(SZ_INETINFODISPATCH, szMultiSz, dwSize * (DWORD) sizeof(TCHAR)) == NO_ERROR)
			return(TRUE);
	}

	// If the InetInfo key is not here, there isn't much we can do ...
	return(FALSE);
}

void GetIISProgramGroup(CString &csGroupName, BOOL fIsMcisGroup)
{
	TCHAR	szName[_MAX_PATH];
	CString csTempName;
	UINT uType, uSize;

	if (fIsMcisGroup) {
		csGroupName = "";
	} else {
		// Get the NT program group name from the private data
		uSize = _MAX_PATH * sizeof(TCHAR);
		{
			// We use the default group name
			MyLoadString(IDS_DEFAULT_NT_PROGRAM_GROUP, csTempName);
			lstrcpy(szName, csTempName.GetBuffer(_MAX_PATH));
	        csTempName.ReleaseBuffer();
		}
		csGroupName = szName;
		csGroupName += _T("\\");

		// Get the IIS program group name from the private data
		uSize = _MAX_PATH * sizeof(TCHAR);
		{
			// We use the default group name
			MyLoadString(IDS_DEFAULT_IIS_PROGRAM_GROUP, csTempName);
			lstrcpy(szName, csTempName.GetBuffer(_MAX_PATH));
	        csTempName.ReleaseBuffer();
		}
		csGroupName += szName;
	}
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);

BOOL GetFullPathToProgramGroup(DWORD dwMainComponent, CString &csGroupName, BOOL fIsMcisGroup)
{
	// add items to the program group
	CString csTemp;
	TCHAR	szPath[MAX_PATH];

	// Get the program group name from the private data
	GetIISProgramGroup(csTemp, fIsMcisGroup);

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	// Load up the resource string for the group
	if (fIsMcisGroup)
		MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);
	else
		MyLoadString(dwMainComponent == MC_IMS?IDS_PROGGROUP_MAIL:IDS_PROGGROUP_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	DebugOutput(_T("Program group loaded: %s"), (LPCTSTR)csGroupName);

	return(TRUE);
}

BOOL GetFullPathToAdminGroup(DWORD dwMainComponent, CString &csGroupName)
{
	// add items to the program group
	CString csTemp;
	TCHAR	szPath[MAX_PATH];

	// Get the program group name from the private data
	MyLoadString( IDS_PROGGROUP_ADMINTOOLS, csTemp );

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	DebugOutput(_T("Program group loaded: %s"), (LPCTSTR)csGroupName);

	return(TRUE);
}

BOOL RemoveProgramGroupIfEmpty(DWORD dwMainComponent, BOOL fIsMcisGroup)
{
	// add items to the program group
	CString csGroupName;
	CString csTemp;
	TCHAR	szPath[MAX_PATH];
	BOOL	fResult;

	// Get the program group name from the private data
	GetIISProgramGroup(csTemp, fIsMcisGroup);

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	// Load up the resource string for the group
	if (fIsMcisGroup)
		MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);
	else
		MyLoadString(dwMainComponent == MC_IMS?IDS_PROGGROUP_MAIL:IDS_PROGGROUP_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	DebugOutput(_T("Removing Program group: %s"), (LPCTSTR)csGroupName);

    fResult = RemoveDirectory((LPCTSTR)csGroupName);
	if (fResult && fIsMcisGroup)
	{
		SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, (LPCTSTR)csGroupName, 0);

		csGroupName = szPath;
		MyLoadString(IDS_MCIS_2_0, csTemp);
		csGroupName += csTemp;
		fResult = RemoveDirectory((LPCTSTR)csGroupName);
	}
	if (fResult)
	{
	    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, (LPCTSTR)csGroupName, 0);
	}

	return(fResult);
}

BOOL RemoveInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, BOOL fIsMcisGroup)
{
	CString csItemPath;
	CString csDisplayName;

	MyLoadString(dwDisplayNameId, csDisplayName);

	// Build the full path to the program link
	GetFullPathToProgramGroup(dwMainComponent, csItemPath, fIsMcisGroup);
	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Removing shortcut file: %s"), (LPCTSTR)csItemPath);

	DeleteFile((LPCTSTR)csItemPath);
    SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);

	RemoveProgramGroupIfEmpty(dwMainComponent, fIsMcisGroup);
	return(TRUE);
}

BOOL RemoveNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId)
{
	CString csItemPath;
	CString csDisplayName;

	MyLoadString(dwDisplayNameId, csDisplayName);

	// Build the full path to the program link
	GetFullPathToAdminGroup(dwMainComponent, csItemPath);
	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Removing shortcut file: %s"), (LPCTSTR)csItemPath);

	DeleteFile((LPCTSTR)csItemPath);
    SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);

 	return(TRUE);
}

BOOL RemoveMCIS10MailProgramGroup()
{
	CString csGroupName;
	CString csNiceName;

	MyLoadString(IDS_PROGGROUP_MCIS10_MAIL, csGroupName);

	MyLoadString(IDS_PROGITEM_MCIS10_MAIL_STARTPAGE, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	MyLoadString(IDS_PROGITEM_MCIS10_MAIL_WEBADMIN, csNiceName);
	MyDeleteItemEx(csGroupName, csNiceName);

	return(TRUE);
}

BOOL RemoveMCIS10NewsProgramGroup()
{
	CString csGroupName;
	CString csNiceName;

    // BINLIN:
    // BUGBUG: need to figure out how to get
    // the old MCIS 1.0 program group path
	MyLoadString(IDS_PROGGROUP_MCIS10_NEWS, csGroupName);

	MyLoadString(IDS_PROGITEM_MCIS10_NEWS_STARTPAGE, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	MyLoadString(IDS_PROGITEM_MCIS10_NEWS_WEBADMIN, csNiceName);
	MyDeleteItemEx(csGroupName, csNiceName);

	return(TRUE);
}

BOOL RemoveUninstallEntries(LPCTSTR szInfFile)
{
	// All components are removed, we will have to remove
	// the Add/Remove option from the control panel
	CRegKey regUninstall( HKEY_LOCAL_MACHINE, REG_UNINSTALL);
	if ((HKEY)regUninstall)
		regUninstall.DeleteTree(szInfFile);
	else
		return(FALSE);
	return(TRUE);
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    lstrcpy(szFile, lpszShortcut);

    // only call SHFileOperation if this file/link exists
    if (0xFFFFFFFF != GetFileAttributes(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        SHFileOperation(&fos);
    }

    return TRUE;
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;

    szPath[0] = NULL;

    if (NOERROR != SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms)) return;

    if (!SHGetPathFromIDList(pidlPrograms, szPath)) return;
    nLen = lstrlen(szPath);
    if (szGroupName) {
        if (nLen == 0 || szPath[nLen-1] != _T('\\'))
            lstrcat(szPath, _T("\\"));
        lstrcat(szPath, szGroupName);
    }
    return;
}

BOOL MyAddGroup(LPCTSTR szGroupName)
{
    TCHAR szPath[MAX_PATH];
	CString csPath;

    MyGetGroupPath(szGroupName, szPath);
	csPath = szPath;
    CreateLayerDirectory(csPath);
    SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, 0);

    return TRUE;
}

BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    lstrcpy(szFile, szPath);
    lstrcat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
       while (bFindFile)
       {
           if(*(FindData.cFileName) != _T('.'))
           {
               fReturn = FALSE;
               break;
           }

           //find the next file
           bFindFile = FindNextFile(hFind, &FindData);
       }

       FindClose(hFind);
    }

    return fReturn;
}

BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
	BOOL			  fResult;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    lstrcpy(szFile, szPath);
    lstrcat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
       while (bFindFile)
       {
           if(*(FindData.cFileName) != _T('.'))
           {
              //copy the path and file name to our temp buffer
              lstrcpy(szFile, szPath);
              lstrcat(szFile, _T("\\"));
              lstrcat(szFile, FindData.cFileName);
              //add a second NULL because SHFileOperation is looking for this
              lstrcat(szFile, _T("\0"));

              //delete the file
              fos.pFrom = szFile;
              SHFileOperation(&fos);
          }
          //find the next file
          bFindFile = FindNextFile(hFind, &FindData);
       }
       FindClose(hFind);
    }

    fResult = RemoveDirectory(szPath);
	if (fResult)
	{
	    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);
	}

	return(fResult);
}

void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    lstrcat(szPath, _T("\\"));
    lstrcat(szPath, szAppName);
    lstrcat(szPath, _T(".lnk"));

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName))
        MyDeleteGroup(szGroupName);
}

// Use to delete files with extension other than ".lnk"
void MyDeleteItemEx(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    lstrcat(szPath, _T("\\"));
    lstrcat(szPath, szAppName);

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName))
        MyDeleteGroup(szGroupName);
}

BOOL RemoveISMLink()
{
	// add items to the program group
	CString csGroupName;
 	CString csNiceName;
 	CString csTemp;

	DebugOutput(_T("Removing ISM link ..."));

	// Get the program group name from the private data
	GetIISProgramGroup(csGroupName, TRUE);

	MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	MyLoadString(IDS_PROGITEM_ISM, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	return(TRUE);
}

void GetInetpubPathFromMD(CString& csPathInetpub)
{
    TCHAR   szw3root[] = _T("\\wwwroot");
    TCHAR   szPathInetpub[_MAX_PATH];

    ZeroMemory( szPathInetpub, sizeof(szPathInetpub) );

    CMDKey W3Key;
    DWORD  dwScratch;
    DWORD  dwType;
    DWORD  dwLength;

    // Get W3Root path
    W3Key.OpenNode(_T("LM/W3Svc/1/Root"));
    if ( (METADATA_HANDLE)W3Key )
    {
        dwLength = _MAX_PATH;

        if (W3Key.GetData(3001, &dwScratch, &dwScratch,
                          &dwType, &dwLength, (LPBYTE)szPathInetpub))
        {
            if (dwType == STRING_METADATA)
            {
                dwScratch = lstrlen(szw3root);
                dwLength = lstrlen(szPathInetpub);

                // If it ends with "\\wwwroot", then we copy the prefix into csPathInetpub
                if ((dwLength > dwScratch) &&
                    !lstrcmpi(szPathInetpub + (dwLength - dwScratch), szw3root))
                {
                    csPathInetpub.Empty();
                    lstrcpyn( csPathInetpub.GetBuffer(512), szPathInetpub, (dwLength - dwScratch + 1));
                    csPathInetpub.ReleaseBuffer();
                }

                // otherwise fall back to use the default...
            }
        }
        W3Key.Close();
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\svc.cpp ===
#include "stdafx.h"
#include <winsvc.h>
#include <winsock2.h>
#include <nspapi.h>
#include "w3svc.h"
#include <inetsvcs.h>

#define PROCESS_SIZE    256+1

TCHAR gServicesWhichMustBeRestarted[20][PROCESS_SIZE];
int gServicesWhichMustBeRestarted_nextuse;
int gServicesWhichMustBeRestarted_total;

int ServicesRestartList_EntryExists(LPCTSTR szServiceName)
{
    int iFoundMatch = FALSE;

    // loop thru the whole list
    for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
    {
        if (_tcsicmp(gServicesWhichMustBeRestarted[i], szServiceName) == 0)
        {
            iFoundMatch = TRUE;
            break;
        }
    }

    return iFoundMatch;
}


int ServicesRestartList_Add(LPCTSTR szServiceName)
{
    DebugOutput(_T("ServicesRestartList_Add() on Service %s"), szServiceName);

    // check if this value already exists in the globalarary
    if (ServicesRestartList_EntryExists(szServiceName)) {return FALSE;}
    
    // move info into global array
    if (gServicesWhichMustBeRestarted_nextuse < 20)
    {
        _tcscpy(gServicesWhichMustBeRestarted[gServicesWhichMustBeRestarted_nextuse],szServiceName);
        // increment counter to array
        // increment next use space
        ++gServicesWhichMustBeRestarted_total;
        ++gServicesWhichMustBeRestarted_nextuse;
        return TRUE;
    }
    return FALSE;
}

int ServicesRestartList_RestartServices(void)
{
    int iReturn = FALSE;
    INT err = 0;

    // loop thru the whole list and restart the services in reverse
    // order from how they were entered?
    if (gServicesWhichMustBeRestarted_total >= 1)
    {
        DebugOutput(_T("RestartServices() Start."));
        for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
        {
            err = InetStartService(gServicesWhichMustBeRestarted[i]);
            DebugOutput(_T("Start service %s. err=%x"), gServicesWhichMustBeRestarted[i], err);
        }
        DebugOutput(_T("RestartServices()  End."));
    }

    return iReturn;
}

INT InetStartService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    DebugOutput(_T("Starting %s service..."), lpServiceName);

    do {
        // set up the service first
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
            break; // service already started and running

        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            //&& svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            && svcStatus.dwCurrentState != SERVICE_RUNNING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);
    
    DebugOutput(_T("Service started with 0x%x"), err);

    return(err);
}

DWORD InetQueryServiceStatus( LPCTSTR lpServiceName )
{
    DWORD dwStatus = 0;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS svcStatus;

    DebugOutputSafe(_T("InetQueryServiceStatus() on %1!s!\n"), lpServiceName);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::QueryServiceStatus( hService, &svcStatus ) )
        {
            err = GetLastError();
            DebugOutputSafe(_T("InetQueryServiceStatus() failed: err=%1!d!\n"), err);
            break;
        }

        dwStatus = svcStatus.dwCurrentState;

    } while (0);

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    DebugOutputSafe(_T("InetQueryServiceStatus() return: dwStatus=%1!d!\n"), dwStatus);

    return( dwStatus );
}

INT InetStopService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    DebugOutputSafe(_T("Stopping %1!s! service...\n"), lpServiceName);

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
		{
			err = ERROR_SERVICE_NOT_ACTIVE;
            break; // service already stopped
		}

         if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
        {
            if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
            {
                err = GetLastError();
                break;
            }
            for ( dwSleepTotal = 0 ;
                dwSleepTotal < dwSvcMaxSleep
                && (QueryServiceStatus( hService, & svcStatus ))
                //&& svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                && svcStatus.dwCurrentState != SERVICE_STOPPED ;
                dwSleepTotal += dwSvcSleepInterval )
            {
                ::Sleep( dwSvcSleepInterval ) ;
            }
        }

        if ( svcStatus.dwCurrentState != SERVICE_STOPPED )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    DebugOutput(_T("Service stopped with 0x%x"), err);

    return(err);
}

INT InetDeleteService( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    /*
    The DeleteService function marks a service for deletion from the service control manager database.
    The database entry is not removed until all open handles to the service have been closed by calls
    to the CloseServiceHandle function, and the service is not running. A running service is stopped
    by a call to the ControlService function with the SERVICE_CONTROL_STOP control code.
    If the service cannot be stopped, the database entry is removed when the system is restarted.
    The service control manager deletes the service by deleting the service key and its subkeys from
    the registry.
    */
    // To delete service immediately, we need to stop service first
    InetStopService(lpServiceName);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::DeleteService( hService ) )
        {
            err = GetLastError();
            break;
        }
    } while (0);

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName,
    LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies, 
    LPCTSTR lpServiceDescription)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_WIN32_SHARE_PROCESS, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                lpDependencies, _T("LocalSystem"), NULL );
        if ( !hService )
        {
            err = GetLastError();
            break;
        }

        if (lpServiceDescription) {
            SERVICE_DESCRIPTION desc;
            desc.lpDescription = (LPTSTR)lpServiceDescription;
            if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &desc)) {
                err = GetLastError();
                break;
            }
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName,
    LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies,
    LPCTSTR lpServiceDescription)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        if ( !::ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE,
                lpBinaryPathName, NULL, NULL, lpDependencies, _T("LocalSystem"), NULL, lpDisplayName) )
        {
            err = GetLastError();
            break;
        }

        if (lpServiceDescription) {
            SERVICE_DESCRIPTION desc;
            desc.lpDescription = (LPTSTR)lpServiceDescription;
            if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &desc)) {
                err = GetLastError();
                break;
            }
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);          \
       ( pSvcTypeValue)->dwValueType = ( dwType);        \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);        \
       ( pSvcTypeValue)->lpValueName = ( lpValName);     \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))

BOOL InetRegisterService( LPCTSTR pszMachine, LPCTSTR   pszServiceName,
                   GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd )
{
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
             // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD SapValue = SapId;
    DWORD TcpPortValue = TcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR) {

        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pGuid;
    serviceInfo.lpMachineName     =  (LPTSTR)pszMachine;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);


    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There are totally 3 values associated with this service if we're doing
    //  both SPX and TCP, there's only one value if TCP.
    //

    if ( SapId )
    {
        lpServiceTypeInfo->dwValueCount = 3;
    } else
    {
        lpServiceTypeInfo->dwValueCount = 1;
    }
    lpServiceTypeInfo->lpTypeName   = (LPTSTR)pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;

    if ( SapId )
    {
        //
        // 1st value: tells the SAP that this is a connection oriented service.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_SAP,                    // Name Space
                                  SERVICE_TYPE_VALUE_CONN,   // ValueName
                                  &Value1                    // actual value
                                  );

        //
        // 2nd Value: tells SAP about object type to be used for broadcasting
        //   the service name.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 1),
                                  NS_SAP,
                                  SERVICE_TYPE_VALUE_SAPID,
                                  &SapValue);

        //
        // 3rd value: tells TCPIP name-space provider about TCP/IP port to be used.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 2),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);

    } else
    {
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                    NS_DNS,
                                    SERVICE_TYPE_VALUE_TCPPORT,
                                    &TcpPortValue);
    }
    //
    // Finally, call SetService to actually perform the operation.
    //

    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     ( fAdd ) ? SERVICE_ADD_TYPE : SERVICE_DELETE_TYPE,       // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    if ( err == SOCKET_ERROR)
	{
		Value1 = GetLastError();
		return(FALSE);
	}
	return(TRUE);

} // InetRegisterService()

//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    DebugOutput(_T("StopServiceAndDependencies():%s Service"), ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
	int iReturn = FALSE;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL) 
	{
        Err = GetLastError();
		DebugOutput(_T("StopServiceAndDependencies():OpenSCManager: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL ) 
	{
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             DebugOutput(_T("StopServiceAndDependencies():%s Service does not exist."), ServiceName);
        }
        else
        {
             DebugOutput(_T("StopServiceAndDependencies():OpenService: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus)) 
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
	{
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING ) 
		{
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) ) 
			{
                Err = GetLastError();
                DebugOutput(_T("StopServiceAndDependencies():EnumDependentServices: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) 
			{
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
			{
                Err = GetLastError();

				// check if the service is already stopped..
				if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
				{
					// check if the service is alread stopped.
					if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
					{
						if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
							{
                            iReturn = TRUE;
                            goto Cleanup;
                            }
					}
				}
				else
				{
                    // The service must be in a hung mode.  Let's kill it.
                    // Todo: NYI
                    DebugOutput(_T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it."), ServiceName);
                    //KillService(ServiceHandle);
                    //goto WaitLoop;
				}
			
                goto Cleanup;
            }

        }
		else 
		{
			// check if the service is already stopped..
			if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
			{
				// check if the service is alread stopped.
				if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
				{
					if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
						{
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
				}
			}
			else
			{
					// The service must be in a hung mode.  Let's kill it.
					DebugOutput(_T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it."), ServiceName);
					//KillService(ServiceHandle);
					//goto WaitLoop;
			}
		
            goto Cleanup;
        }
    }
    else
    {
        // We successfully asked the service to stop...
    }


    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout<45; Timeout++ ) 
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) 
		{
			// The service successfully stopped.
            DebugOutput(_T("StopServiceAndDependencies(): %s Service stopped."), ServiceName);
			iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
		{
            Err = GetLastError();
			DebugOutput(_T("StopServiceAndDependencies():QueryServiceStatus: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
            goto Cleanup;
        }

     }

    // if we get here then the service failed to stop.
    DebugOutput(_T("StopServiceAndDependencies(): failed to stop %s service."), ServiceName);

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
	if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <stdarg.h>

DWORD GetUnattendedMode(HANDLE hUnattended, LPCTSTR szSubcomponent);
DWORD GetUnattendedModeFromSetupMode(
			HANDLE	hUnattended, 
			DWORD	dwComponent,
			LPCTSTR	szSubcomponent);

BOOL DetectExistingSmtpServers();
BOOL DetectExistingIISADMIN();

BOOL AddServiceToDispatchList(LPTSTR szServiceName);
BOOL RemoveServiceFromDispatchList(LPTSTR szServiceName);

BOOL GetFullPathToProgramGroup(DWORD dwMainComponent, CString &csGroupName, BOOL fIsMcisGroup);
BOOL GetFullPathToAdminGroup(DWORD dwMainComponent, CString &csGroupName);
BOOL RemoveProgramGroupIfEmpty(DWORD dwMainComponent, BOOL fIsMcisGroup);

BOOL RemoveInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, BOOL fIsMcisGroup);

BOOL RemoveNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId);

BOOL RemoveMCIS10MailProgramGroup();
BOOL RemoveMCIS10NewsProgramGroup();

BOOL RemoveUninstallEntries(LPCTSTR szInfFile);

BOOL RemoveISMLink();

void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
void MyDeleteItemEx(LPCTSTR szGroupName, LPCTSTR szAppName);

void GetInetpubPathFromMD(CString& csPathInetpub);
 
HRESULT RegisterSEOService();
HRESULT RegisterSEOForSmtp(BOOL fSetUpSourceType);

BOOL InsertSetupString( LPCSTR REG_PARAMETERS );

HRESULT UnregisterSEOSourcesForNNTP(void);
HRESULT UnregisterSEOSourcesForSMTP(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\wizpages.cpp ===
#include "stdafx.h"
#include "ocmanage.h"

#include "setupapi.h"

#include "utils.h"

extern OCMANAGER_ROUTINES gHelperRoutines;
extern HANDLE gMyModuleHandle;

void SetIMSSetupMode(DWORD dwSetupMode)
{
    gHelperRoutines.SetSetupMode(gHelperRoutines.OcManagerContext, dwSetupMode);
}

DWORD GetIMSSetupMode()
{
    return(gHelperRoutines.GetSetupMode(gHelperRoutines.OcManagerContext));
}

void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption)
{
	CString csText;

	MyLoadString(dwMessageId, csText);
    MyMessageBox(NULL, csText, szCaption,
				MB_OK | MB_TASKMODAL | MB_SETFOREGROUND | MB_TOPMOST);
}

// C:\Inetpub\wwwroot ===> C:\Inetpub
BOOL GetParentDir(LPCTSTR szPath, LPTSTR szParentDir)
{
    LPTSTR p = (LPTSTR)szPath;
    if (!szPath || !*szPath)
		return(FALSE);

    while (*p)
        p++;

    p--;
    while (p >= szPath && *p != _T('\\'))
        p--;

    *szParentDir = _T('\0');
    if (p == szPath)
        lstrcpy(szParentDir, _T("\\"));
    else
        lstrcpyn(szParentDir, szPath, (size_t)(p - szPath + 1));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\setup\wizpages.h ===
#ifndef _WIZPAGES_H
#define _WIZPAGES_H

void SetIMSSetupMode(DWORD dwSetupMode);
DWORD GetIMSSetupMode();

BOOL GetParentDir(LPCTSTR szPath, LPTSTR szParentDir);

void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption = NULL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\simauth2\encode.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name:
      encoded.cpp

   Abstract:
      This module is copied from IIS fcache.cxx which contains the encoding/decoding routines.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

#ifdef __cplusplus
};
#endif

#include "dbgutil.h"
#include <tcpdll.hxx>
#include <inetinfo.h>
#include "simauth2.h"

#include <dbgtrace.h>

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (int)(bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\shuttle\cpool.cpp ===
//#---------------------------------------------------------------
//  File:       CPool.cpp
//
//  Synopsis:   This file implements the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

#include    <windows.h>
#include    "cpool.h"
#include    "dbgtrace.h"
#include    <randfail.h>

#define     PREAMBLE    (BYTE)'H'
#define     POSTAMBLE   (BYTE)'C'
#define     FILLER      (BYTE)0xCC


//
// Define internal Debug structs designed to help find over/underwrites
//
#ifdef DEBUG
#ifndef DISABLE_CPOOL_DEBUG
#define	CPOOL_DEBUG
#endif
#endif

#ifdef CPOOL_DEBUG

#define	HEAD_SIGNATURE	(DWORD)'daeH'
#define	TAIL_SIGNATURE	(DWORD)'liaT'

#define	FREE_STATE		(DWORD)'eerF'
#define	USED_STATE		(DWORD)'desU'

//
// forward declaration
//
class CPoolDebugTail;

//
// Prefix for CPool instances when in debug mode
//
class CPoolDebugHead {

	public:
		//
		// declared so normal CPool free list can clobber this member
		//
		void*	m_pLink;

		CPoolDebugHead();
		~CPoolDebugHead( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// Function to mark the instance in use
		//
		void MarkInUse( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// Function to mark the instance free
		//
		void MarkFree( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// class signature
		//
		DWORD	m_dwSignature;

		//
		// state; either FREE_STATE or USED_STATE
		//
		DWORD	m_dwState;

		//
		// time of allocation
		//
		SYSTEMTIME	m_time;

		//
		// ThreadID which alloc'd/free'd memory
		//
		DWORD	m_dwThreadID;

		//
		// tail pointer used to find the end
		//
		CPoolDebugTail UNALIGNED	*m_pTailDebug;

		//
		// parent CPool signature
		//
		DWORD	m_dwPoolSignature;

		//
		// parent CPool Fragment
		//
		LPVOID	m_PoolFragment;
};


//
// Suffix for CPool instances when in debug mode
//
class CPoolDebugTail {

	public:
		CPoolDebugTail();
		~CPoolDebugTail( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// routine to validate the integrity of the instance
		//
		void	IsValid( DWORD dwPoolSignature, DWORD cInstanceSize );

		//
		// class signature
		//
		DWORD	m_dwSignature;

		//
		// tail pointer used to find the end
		//
		CPoolDebugHead UNALIGNED	*m_pHeadDebug;
};

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::CPoolDebugHead( void ) :
					m_dwState( FREE_STATE ),
					m_dwSignature( HEAD_SIGNATURE ),
					m_pTailDebug( NULL )
{
	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugHead
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::~CPoolDebugHead( void )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
}

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkInUse
//
//  Synopsis:   Called when instance is allocated
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkInUse( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
 	_ASSERT( m_dwState == FREE_STATE );

 	m_dwState = USED_STATE;

	//
	// validate that the application portion is not tampered with
	//
	for (	LPBYTE pb = (LPBYTE)(this+1);
			pb < (LPBYTE)m_pTailDebug;
			pb++ )
	{
		_ASSERT( *pb == FILLER );
	}

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkFree
//
//  Synopsis:   Called when instance is freed
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkFree( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );

	//
	// Check and set the state
	//
 	_ASSERT( m_dwState == USED_STATE );
 	m_dwState = FREE_STATE;

	//
	// check enough to call IsValid
	//
	_ASSERT( m_pTailDebug != 0 );
	_ASSERT( (DWORD_PTR)m_pTailDebug > (DWORD_PTR)this );

	_ASSERT( m_dwThreadID != 0 ) ;

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// set the application data to filler
	//
	FillMemory( (LPBYTE)(this+1),
				(DWORD)((LPBYTE)m_pTailDebug - (LPBYTE)(this+1)),
				FILLER );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugTail
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::CPoolDebugTail( void ) :
					m_dwSignature( TAIL_SIGNATURE ),
					m_pHeadDebug( NULL )
{
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugTail
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::~CPoolDebugTail( void )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );
}


//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   check validity of instance
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugTail::IsValid( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );

	//
	// validate that the head is offset at the correct location
	//
	_ASSERT( m_pHeadDebug != NULL );
	_ASSERT( (DWORD_PTR)m_pHeadDebug == (DWORD_PTR)(this+1) - cInstanceSize );

	//
	// validate the head structure
	//
	_ASSERT( m_pHeadDebug->m_dwSignature == HEAD_SIGNATURE );
	_ASSERT( m_pHeadDebug->m_dwPoolSignature == dwPoolSignature );
	_ASSERT( m_pHeadDebug->m_pTailDebug == this );
	_ASSERT( m_pHeadDebug->m_dwState == FREE_STATE ||
			 m_pHeadDebug->m_dwState == USED_STATE );
}


#endif

//+---------------------------------------------------------------
//
//  Function:   CPool
//
//  Synopsis:   constructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm	Created         5 Jul 1995
//
//----------------------------------------------------------------
CPool::CPool( DWORD dwSignature ) : m_dwSignature( dwSignature )
{
    TraceFunctEnter( "CPool::CPool" );

    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	//
	// Debug variables to help catch heap bugs
	//
	m_pLastAlloc = NULL;
	m_pLastExtraAlloc = NULL;

	m_cTotalFrees = 0;
	m_cTotalAllocs = 0;
	m_cTotalExtraAllocs = 0;

	m_cInstanceSize = 0;

	//
	// Avail + InUse should equal Committed if we're not
	// in grow/alloc or free.  Diagnostic and admin only
	// This will keep code in critsec as small as possible
	//
	m_cNumberAvail = 0;
	m_cNumberInUse = 0;
	m_cNumberCommitted = 0;

    InitializeCriticalSection( &m_PoolCriticalSection );

	//
	// initialize the fragment member variables
	//
	m_cFragmentInstances = 0;
	m_cFragments = 0;
	ZeroMemory( m_pFragments, sizeof(m_pFragments) );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   ~CPool
//
//  Synopsis:   destructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CPool::~CPool( void )
{
    TraceFunctEnter( "CPool::~CPool" );

    _ASSERT( m_cNumberInUse == 0 );

	for ( int i=0; i<MAX_CPOOL_FRAGMENTS; i++ )
	{
		_ASSERT( m_pFragments[i] == NULL );
	}

    DebugTrace( (LPARAM)this,
                "CPool: %x  EntryCount: %d   ContentionCount: %d, Allocs: %d, Frees: %d",
                m_dwSignature,
                GetEntryCount(),
                GetContentionCount(),
                GetTotalAllocCount(),
                GetTotalFreeCount() );

    DeleteCriticalSection( &m_PoolCriticalSection );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   Alloc
//
//  Synopsis:   Allocates a new instance from the pool
//
//  Arguments:  void
//
//  Returns:    pointer to the new instance
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void* CPool::Alloc( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Alloc" );
#endif

    Link* pAlloc;

    IsValid();

    //
    // Randfail for debug versions
    //
#if defined( DEBUG )
    if ( fTimeToFail() ) {
        return NULL;
    }
#endif

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable.  inc before the alloc so this var wraps
	// the actual allocation
	//
	InterlockedIncrement( (LPLONG)&m_cNumberInUse );

	//
	// check the extra pointer to avoid the critsec path if
	// possible.  big wins because we can potentially avoid
	// the extra code and the wait on semaphore
	//
	pAlloc = (Link*)InterlockedExchangePointer( (void**)&m_pExtraFreeLink, NULL );
	if ( pAlloc == NULL )
	{

    	EnterCriticalSection( &m_PoolCriticalSection );

	    //
    	// commit more memory if the list is empty
	    //
    	if ( (m_pFreeList == NULL) && (m_cNumberCommitted < m_cMaxInstances) )
	    {
			GrowPool();
		}

    	//
	    // try to allocate a Descriptor from the free list
    	//
	    if ( (pAlloc = m_pFreeList) != NULL )
		{
			m_pFreeList = pAlloc->pNext;
		}

		m_pLastAlloc = pAlloc;
	    LeaveCriticalSection( &m_PoolCriticalSection );
	}
	else
	{
		m_pLastExtraAlloc = pAlloc;
	    m_cTotalExtraAllocs++;
	}

	//
	// alloc failed
	//	
	if ( pAlloc == NULL )
	{
		InterlockedDecrement( (LPLONG)&m_cNumberInUse );
	}
	else
	{
		//
		// debug/admin use only - ok to do outside of critsec
		//
	    m_cTotalAllocs++;

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = (CPoolDebugHead*)pAlloc;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pAlloc >= pHead->m_PoolFragment );
		_ASSERT( (char*)pAlloc <  (char*)pHead->m_PoolFragment +
								  m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkInUse( m_dwSignature, m_cInstanceSize );
		pAlloc = (Link*)(pHead+1);
#endif

	}

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Alloc: 0x%08X", pAlloc );
    TraceFunctLeave();
#endif
    return	(void*)pAlloc;
}


//+---------------------------------------------------------------
//
//  Function:   Free
//
//  Synopsis:   frees the instances
//
//  Arguments:  pInstance - a pointer to the CDescriptor
//
//  Returns:    void
//
//  History:    gordm    Created         5 Jul 1995
//
//----------------------------------------------------------------
void CPool::Free( void* pInstance )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Free" );
#endif

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = ((CPoolDebugHead*)pInstance) - 1;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pInstance >=pHead->m_PoolFragment);
		_ASSERT( (char*)pInstance < (char*)pHead->m_PoolFragment +
									m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkFree( m_dwSignature, m_cInstanceSize );
		pInstance = (void*)pHead;
#endif

    IsValid();

    _ASSERT(m_cNumberInUse > 0);

	pInstance = (void*)InterlockedExchangePointer( (PVOID *)&m_pExtraFreeLink, pInstance );
	//
	// free the previous extra pointer if one existed
	//
	if ( pInstance != NULL )
	{
	    EnterCriticalSection( &m_PoolCriticalSection );

		((Link*)pInstance)->pNext = m_pFreeList;
		 m_pFreeList = (Link*)pInstance;

    	LeaveCriticalSection( &m_PoolCriticalSection );
	}

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable. We'll think this list is empty only
	// when we get to this point.  This var is inc'd before entering
	// the critsec and is dec'd if the operation fails.
	//
	InterlockedDecrement( (LPLONG)&m_cNumberInUse );

	//
	// debug/admin use only - ok to do outside of critsec - deletes don't fail
	//
    m_cTotalFrees++;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Freed: 0x%08X", pInstance );
    TraceFunctLeave();
#endif
}



//
// setup a const DWORD for size manipulation
//
const DWORD	KB = 1024;

//+---------------------------------------------------------------
//
//  Function:   ReserveMemory
//
//  Synopsis:   Initializes the pool
//
//  Arguments:  NumDescriptors - the number of total descriptors in the pool
//              DescriptorSize - the size of any one descriptor
//              Signature      - object signature
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReserveMemory(	DWORD MaxInstances,
							DWORD InstanceSize,
							DWORD IncrementSize )
{
    TraceFunctEnter( "CPool::ReserveMemory" );

	DWORD cFragments;
	DWORD cFragmentInstances;
	DWORD cIncrementInstances;

	_ASSERT( MaxInstances != 0 );
	_ASSERT( InstanceSize >= sizeof(struct Link) );

#ifdef CPOOL_DEBUG
	InstanceSize += sizeof( CPoolDebugHead ) + sizeof( CPoolDebugTail );
#endif

	if ( IncrementSize == DEFAULT_ALLOC_INCREMENT )
	{
		//
		// ensure we go to the OS for at least 8 instances at a time
		//
		if ( InstanceSize <= 4*KB / 8 )
		{
			cIncrementInstances = 4*KB / InstanceSize;
		}
		else if ( InstanceSize <= 64*KB / 8 )
		{
			cIncrementInstances = 64*KB / InstanceSize;
		}
		else
		{
			cIncrementInstances = min( MaxInstances, 8 );
		}
	}
	else
	{
		cIncrementInstances = IncrementSize;
	}

	//
	// now calculate the number larger fragments
	//
	if ( cIncrementInstances > MaxInstances )
	{
		//
		// no need for CPool; but we shouldn't alloc more than necessary
		//
		cFragmentInstances = cIncrementInstances = MaxInstances;
		cFragments = 1;
	}
	else
	{
		//
		// Round up MaxInstances to a integral number of IncrementSize
		//
	    MaxInstances += cIncrementInstances - 1;
    	MaxInstances /= cIncrementInstances;
    	MaxInstances *= cIncrementInstances;

		//
		// as an initial attempt divide the number of instances by max frags
		//
		cFragmentInstances = (MaxInstances + MAX_CPOOL_FRAGMENTS - 1) /
						MAX_CPOOL_FRAGMENTS;

		if ( cFragmentInstances == 0 )
		{
			cFragmentInstances = MaxInstances;
			cFragments = 1;
		}
		else
		{
			//
			// round up the number of instances in a fragment to an
			// integral number of IncrementSizes
			//
			cFragmentInstances += cIncrementInstances - 1;
			cFragmentInstances /= cIncrementInstances;
			cFragmentInstances *= cIncrementInstances;

			//
			// recalculate the number of fragments required based on the integral
			// number of IncrementSizes ( last one may no longer be required )
			//
			cFragments = (MaxInstances + cFragmentInstances - 1) /
						cFragmentInstances;
		}
	}

	_ASSERT( cFragments > 0 );
	_ASSERT( cFragments*cFragmentInstances >= MaxInstances );

	m_cInstanceSize = InstanceSize;
	m_cMaxInstances = MaxInstances;
	m_cFragments    = cFragments;

	m_cFragmentInstances  = cFragmentInstances;
	m_cIncrementInstances = cIncrementInstances;

	TraceFunctLeave();
	return	TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   ReleaseMemory
//
//  Synopsis:   Releases the pool
//
//  Arguments:  none
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReleaseMemory( void )
{
    TraceFunctEnter( "CPool::ReleaseMemory" );

	BOOL	bFree = TRUE;
	DWORD	i, cStart;

    EnterCriticalSection( &m_PoolCriticalSection );

	for ( i=cStart=0; i<m_cFragments; i++, cStart += m_cFragmentInstances )
	{
		LPVOID	pHeap = m_pFragments[i];
		if ( pHeap != NULL )
		{
			_ASSERT( cStart < m_cNumberCommitted );

			DWORD	cSize = min( m_cFragmentInstances, m_cNumberCommitted-cStart );

			_VERIFY( bFree = VirtualFree( pHeap, cSize*m_cInstanceSize, MEM_DECOMMIT ) );
			_VERIFY( bFree &=VirtualFree( pHeap, 0, MEM_RELEASE ) );

			if ( bFree == FALSE )
			{
				ErrorTrace( (LPARAM)this, "VirtualFree failed: err %d", GetLastError() );
				break;
			}	

			m_pFragments[i] = NULL;
		}
		else
		{
			break;
		}
	}
    LeaveCriticalSection( &m_PoolCriticalSection );

	//
	// zero out important data fields
	//
    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	m_cNumberCommitted = 0;

	return	bFree;
}

#ifdef CPOOL_DEBUG
//+---------------------------------------------------------------
//
//  Function:   InitDebugInstance
//
//  Synopsis:   sets up the appropriate debug class variables
//
//  Arguments:  void* pInstance: the new instance
//				DWORD dwPoolSignature: parent Pool signature
//				DWORD cInstanceSize: size of the enlarged instance
//
//  Returns:    void
//
//  History:    gordm		Created			11 Jan 1996
//
//----------------------------------------------------------------
void InitDebugInstance(
	char* pInstance,
	DWORD dwPoolSignature,
	DWORD cInstanceSize,
	LPVOID pPoolFragment
	)
{
	CPoolDebugHead* pHead = new( pInstance ) CPoolDebugHead();
	CPoolDebugTail* pTail = new( pInstance +
								 cInstanceSize -
								 sizeof(CPoolDebugTail) ) CPoolDebugTail();

	pHead->m_pTailDebug = pTail;
	pTail->m_pHeadDebug = pHead;

	//
	// helps with debugging to see the parent CPool signature
	//
	pHead->m_dwPoolSignature = dwPoolSignature;

	//
	// helps with asserts for valid ranges
	//
	pHead->m_PoolFragment = pPoolFragment;

	//
	// fake out the state before calling mark Free
	//
	pHead->m_dwState = USED_STATE;
	pHead->MarkFree( dwPoolSignature, cInstanceSize );
}
#endif


//+---------------------------------------------------------------
//
//  Function:   GrowPool
//
//  Synopsis:   grows the number of committed instances in the pool
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void CPool::GrowPool( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::GrowPool" );
#endif

	DWORD	cFragment = m_cNumberCommitted / m_cFragmentInstances;
	DWORD	cStart = m_cNumberCommitted % m_cFragmentInstances;
	DWORD   cbSize = (cStart+m_cIncrementInstances) * m_cInstanceSize;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Expanding the pool to %d descriptors",
				cNewCommit );
#endif

	//
	// if we're starting a new fragment
	//
	if ( cStart == 0 )
	{
		//
		// if we are at a boundary of a fragment Reserve the next fragment
		m_pFragments[cFragment] = VirtualAlloc(
									NULL,
									m_cFragmentInstances*m_cInstanceSize,
									MEM_RESERVE | MEM_TOP_DOWN,
									PAGE_NOACCESS
									);

		if ( m_pFragments[cFragment] == NULL )
		{
#ifdef ALLOC_TRACING
			ErrorTrace( (LPARAM)this,
						"Could not reserve more memory: error = %d",
						GetLastError() );
#endif
			return;
		}

	}

	LPVOID	pHeap = m_pFragments[cFragment];

	if ( VirtualAlloc(  pHeap,
						cbSize,
						MEM_COMMIT,
						PAGE_READWRITE ) != NULL )
	{
        char* pStart = (char*)pHeap + cStart*m_cInstanceSize;
        char* pLast =  (char*)pHeap + cbSize - m_cInstanceSize;

		//
		// run the list joining the next pointers
		// possible because we own the critsec
		//
        for ( char* p=pStart; p<pLast; p+=m_cInstanceSize)
        {

#ifdef CPOOL_DEBUG
			InitDebugInstance( p, m_dwSignature, m_cInstanceSize, pHeap );
#endif
			//
			// statement works for CPOOL_DEBUG as well because
			// we reserve the first 4 bytes of CPoolDebugHead
			//
			((Link*)p)->pNext = (Link*)(p+m_cInstanceSize);
		}

		//
		// terminate and then set the head to beginning of new list
		//
#ifdef CPOOL_DEBUG
		InitDebugInstance( pLast, m_dwSignature, m_cInstanceSize, pHeap );
#endif

		((Link*)pLast)->pNext = NULL;
		m_pFreeList = (Link*)pStart;

		m_cNumberCommitted += m_cIncrementInstances;
	}

#ifdef	ALLOC_TRACING
	else
	{
		ErrorTrace( (LPARAM)this,
					"Could not commit another descriptor: error = %d",
					GetLastError() );
	}
    TraceFunctLeave();
#endif

}


//+---------------------------------------------------------------
//
//  Function:   GetContentionCount
//
//  Synopsis:   Returns the contention count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetContentionCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->ContentionCount :
			0 ;
}

//+---------------------------------------------------------------
//
//  Function:   GetEntryCount
//
//  Synopsis:   Returns the entry count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetEntryCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->EntryCount :
			0 ;
}



//+---------------------------------------------------------------
//
//  Function:   GetInstanceSize
//
//  Synopsis:   Returns the application's instance size
//
//  Arguments:  void
//
//  Returns:    the instance size of the app
//
//----------------------------------------------------------------
DWORD CPool::GetInstanceSize( void )
{
#ifdef CPOOL_DEBUG
	return	m_cInstanceSize - sizeof(CPoolDebugHead) - sizeof(CPoolDebugTail);
#else
	return	m_cInstanceSize;
#endif
}



#ifdef DEBUG
//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   Validates the pool signature
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
inline void CPool::IsValid( void )
{
	_ASSERT( m_cMaxInstances != 0 );
	_ASSERT( m_cInstanceSize >= sizeof(struct Link) );
	_ASSERT( m_cIncrementInstances != 0 );
	_ASSERT( m_dwSignature != 0 );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\simauth2\simauth.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simauth.cpp

Abstract:

    This module contains definition for the CSecurityCtx class.

Revision History:

--*/

#if !defined(dllexp)
#define dllexp  __declspec( dllexport )
#endif  // !defined( dllexp )

#ifdef __cplusplus
extern "C" {
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

#ifdef __cplusplus
};
#endif

#include <dbgutil.h>
#include <tcpdll.hxx>
#include <inetinfo.h>

#include <simauth2.h>
#include <dbgtrace.h>

//
// SSL and SSPI related include files
//
extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>
#include <ntlmsp.h>
#include <ntdsapi.h>
}


//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Points to protocol blocks
//

extern BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 );

//
// critsec protecting the following three items
//
CRITICAL_SECTION    critProviderPackages;
inline void LockPackages( void ) { EnterCriticalSection( &critProviderPackages ); }
inline void UnlockPackages( void ) { LeaveCriticalSection( &critProviderPackages ); }

//
// "installed" packages the server should support
//
PAUTH_BLOCK ProviderPackages = NULL;

//
// count of "installed" packages the server should support
//
DWORD       cProviderPackages = 0;

//
// memory for names of "installed" packages the server should support
//
LPSTR       ProviderNames = NULL;

//
// Global gibraltar object and allow guest flag
//

BOOL        CSecurityCtx::m_AllowGuest = TRUE;
BOOL        CSecurityCtx::m_StartAnonymous = TRUE;
HANDLE    CSecurityCtx::m_hTokenAnonymous = NULL;


inline BOOL
IsExperimental(
            LPSTR   Protocol
            )
/*++

Routine Description:

    determines if the security package is marked as experimental ( ie X- )

Arguments:

    LPSTR: name of the protocol or authentication package

Return Value:

    BOOL: TRUE if starts with X-

--*/
{
    return  (Protocol[0] == 'X' || Protocol[0] == 'x') && Protocol[1] == '-';
}

inline LPSTR
PackageName(
            LPSTR   Protocol
            )
/*++

Routine Description:

    returns the core security package name stripping X- if necessary

Arguments:

    LPSTR: name of the protocol or authentication package

Return Value:

    LPSTR: package name

--*/
{
    return  IsExperimental( Protocol ) ? Protocol + 2 : Protocol ;
}


BOOL
CSecurityCtx::Initialize(
            BOOL                    fAllowGuest,
            BOOL                    fStartAnonymous
            )
/*++

Routine Description:

    Activates the security package

Arguments:

    PIIS_SERVER_INSTANCE is a ptr to a virtual server instance

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("CSecurityCtx::Initialize")

    m_AllowGuest = fAllowGuest;
    m_StartAnonymous = fStartAnonymous;

    if (m_StartAnonymous)
    {
        //  This is only used by NNTP. And - NNTP only call it once in InitializeService
        //  so we don't need any ref count on it.

        //  Impersonate Anonymous token on this thread
        if (!ImpersonateAnonymousToken(GetCurrentThread()))
        {
            DWORD   dw = GetLastError();
            ErrorTrace(0, "ImpersonateAnonymousToken() failed %x", dw);
            return FALSE;
        }

        //  Get current thread token
        _ASSERT(m_hTokenAnonymous == NULL);
        if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &m_hTokenAnonymous))
        {
            ErrorTrace(0, "OpenThreadToken() failed %x", GetLastError());
            ::RevertToSelf();
            return FALSE;
        }
        
        ::RevertToSelf();
    }

    InitializeCriticalSection( &critProviderPackages );

    LEAVE
    return(TRUE);

} // Initialize

VOID
CSecurityCtx::Terminate(
            VOID
            )
/*++

Routine Description:

    Terminates the security package

Arguments:

    None.

Return Value:

    None.

--*/
{
    ENTER("CSecurityCtx::Terminate")

    //
    // Close cached credential handles
    //

    if (m_hTokenAnonymous)
    {
        CloseHandle(m_hTokenAnonymous);
        m_hTokenAnonymous = NULL;
    }

    if ( ProviderPackages != NULL )
    {
        LocalFree( (PVOID)ProviderPackages );
        ProviderPackages = NULL;
    }

    if ( ProviderNames != NULL )
    {
        LocalFree( (PVOID)ProviderNames );
        ProviderNames = NULL;
    }

    DeleteCriticalSection( &critProviderPackages );

    LEAVE
    return;

} // Terminate

CSecurityCtx::CSecurityCtx(
    PIIS_SERVER_INSTANCE pIisInstance,
    DWORD AuthFlags,
    DWORD InstanceAuthFlags,
    TCP_AUTHENT_INFO *pTcpAuthInfo
    ) :
        TCP_AUTHENT( AuthFlags ),
        m_IsAuthenticated( FALSE ),
        m_IsAnonymous( FALSE ),
        m_IsClearText( FALSE ),
        m_IsGuest( FALSE ),
        m_LoginName( NULL ),
        m_PackageName( NULL ),
        m_dwInstanceAuthFlags(InstanceAuthFlags),
        m_ProviderNames(NULL),
        m_ProviderPackages(NULL),
        m_cProviderPackages(0),
        m_fBase64((AuthFlags & TCPAUTH_BASE64) ? TRUE : FALSE)
/*++

Routine Description:

    Class constructor

Arguments:

    None.

Return Value:

    None

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::CSecurityCtx");

    m_szCleartextPackageName[0] = '\0';
    m_szMembershipBrokerName[0] = '\0';

    //
    //  The instance will cache this info from the metabase
    //  and pass it in on the constructor.
    //

    if ( pTcpAuthInfo )
    {
        m_TCPAuthentInfo.strAnonUserName.Copy(pTcpAuthInfo->strAnonUserName);
        m_TCPAuthentInfo.strAnonUserPassword.Copy(pTcpAuthInfo->strAnonUserPassword);
        m_TCPAuthentInfo.strDefaultLogonDomain.Copy(pTcpAuthInfo->strDefaultLogonDomain);
        m_TCPAuthentInfo.dwLogonMethod = pTcpAuthInfo->dwLogonMethod;
        m_TCPAuthentInfo.fDontUseAnonSubAuth = pTcpAuthInfo->fDontUseAnonSubAuth;
    }

    if ( m_StartAnonymous )
    {
        //
        //  m_dwInstanceAuthFlags is set at class's ctor
        //

        //
        // if Anonymous logon is not allowed return immediately
        //
        if ( m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS )
        {
            m_IsAnonymous = TRUE;
            m_IsAuthenticated = TRUE;
            m_IsClearText = TRUE;

        }
    }
} // CSecurityCtx

CSecurityCtx::~CSecurityCtx(
                VOID
                )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
    //
    // no reason to do the remainder of Reset()
    //
    if ( m_LoginName != NULL )
    {
        LocalFree( (PVOID)m_LoginName);
        m_LoginName = NULL;
    }

    if ( m_PackageName != NULL )
    {
        LocalFree( (PVOID)m_PackageName);
        m_PackageName = NULL;
    }
} // ~CSecurityCtx


HANDLE
CSecurityCtx::QueryImpersonationToken()
/*++

Routine Description:

    get impersonation token - overriding base class
    if it's nntp anonymous, use m_hTokenAnonymous instead of going into TCP_AUTHENT

Arguments:

    None.

Return Value:

    token handle

--*/

{
    if (m_IsAnonymous) return m_hTokenAnonymous;
    else return TCP_AUTHENT::QueryImpersonationToken();
}



VOID
CSecurityCtx::Reset(
                VOID
                )
/*++

Routine Description:

    resets the instance to reauth user

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( m_LoginName != NULL )
    {
        LocalFree( (PVOID)m_LoginName);
        m_LoginName = NULL;
    }

    if ( m_PackageName != NULL )
    {
        LocalFree( (PVOID)m_PackageName);
        m_PackageName = NULL;
    }

    m_IsAuthenticated = FALSE;
    m_IsAnonymous = FALSE;
    m_IsGuest = FALSE;

    TCP_AUTHENT::Reset();

} // Reset

VOID
CSecurityCtx::SetCleartextPackageName(
                LPSTR           szCleartextPackageName,
                LPSTR           szMembershipBrokerName
                )
/*++

Routine Description:

    Sets the cleartext auth package name

Arguments:

    szCleartextPackageName - Name of package

Return Value:

    None

--*/
{
    TraceFunctEnter("SetCleartextPackageName");

    if (szCleartextPackageName)
        lstrcpy(m_szCleartextPackageName, szCleartextPackageName);
    else
        m_szCleartextPackageName[0] = '\0';

    if (szMembershipBrokerName)
        lstrcpy(m_szMembershipBrokerName, szMembershipBrokerName);
    else
        m_szMembershipBrokerName[0] = '\0';

    DebugTrace(0,"CleartextPackageName is %s MembershipBrokerName is %s", m_szCleartextPackageName, m_szMembershipBrokerName);
}

BOOL
CSecurityCtx::SetInstanceAuthPackageNames(
    DWORD cProviderPackages,
    LPSTR ProviderNames,
    PAUTH_BLOCK ProviderPackages)
/*++
Routine Description:

    set the supported SSPI packages per instance basis

--*/
{
    TraceFunctEnter( "CSecurityCtx::SetInstanceAuthPackageNames" );

    if (cProviderPackages == 0 || ProviderNames == NULL || ProviderPackages == NULL)
    {
        ErrorTrace( 0, "Invalid Parameters");

        return FALSE;
    }

    m_cProviderPackages = cProviderPackages;
    m_ProviderNames = ProviderNames;
    m_ProviderPackages = ProviderPackages;

    return TRUE;
}

BOOL
CSecurityCtx::GetInstanceAuthPackageNames(
                OUT LPBYTE      ReplyString,
                IN OUT PDWORD   ReplySize,
                IN PKG_REPLY_FMT    PkgFmt
                )
/*++

Routine Description:

    get the supported SSPI packages per instance basis.

    different than set in that the packages are returned using various
    delimeters to make it easier for the client to format the buffer.

Arguments:

    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.
    PkgFmt - Format of the reply string.

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::GetInstanceAuthPackageNames" );

    LPSTR   pszNext = (LPSTR)ReplyString;
    DWORD   cbReply = 0;
    DWORD   cbDelim;
    LPSTR   pbDelim;

    _ASSERT(PkgFmt == PkgFmtSpace || PkgFmt == PkgFmtCrLf);

    switch (PkgFmt)
    {
    case PkgFmtCrLf:
        {
            pbDelim = "\r\n";
            cbDelim = 2;
            break;
        }

    case PkgFmtSpace:
    default:
        {
            pbDelim = " ";
            cbDelim = 1;
            break;
        }
    }

    //
    // while in this loop ensure the contents dont change
    //

    for ( DWORD i=0; i < m_cProviderPackages; i++ )
    {
        LPSTR   pszName = m_ProviderPackages[i].Name;
        DWORD   cbName = lstrlen( pszName );

        //
        // +1 is for trailing space
        //
        if ( cbReply + cbName + cbDelim > *ReplySize )
        {
            break;
        }
        else
        {
            CopyMemory( pszNext, pszName, cbName );

            //
            // add the space separator
            //
            CopyMemory(pszNext + cbName, pbDelim, cbDelim);

            //
            // inc for loop pass
            //
            cbReply += cbName + cbDelim;
            pszNext += cbName + cbDelim;
        }
    }

    //
    // stamp the final trailing space with a NULL char
    //
    if ( cbReply > 0 && PkgFmt == PkgFmtSpace)
    {
        cbReply--;

        ReplyString[ cbReply ] = '\0';

        DebugTrace( 0, "Protocols: %s", ReplyString );
    }

    *ReplySize = cbReply;

    return  TRUE;
}

BOOL
CSecurityCtx::SetAuthPackageNames(
                LPSTR lpMultiSzProviders,
                DWORD cchMultiSzProviders
                )
/*++

Routine Description:

    set the supported SSPI packages

Arguments:

    lpMultiSzProviders is the same format as returned by
    RegQueryValueEx for REG_MULTI_SZ values

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::SetAuthPackageNames" );

    LPSTR   psz, pszCopy = NULL;
    DWORD   i, cProviders;

    PAUTH_BLOCK pBlock = NULL;

    if ( lpMultiSzProviders == NULL || cchMultiSzProviders == 0 )
    {
        ErrorTrace( 0, "Invalid Parameters: 0x%08X, %d",
                    lpMultiSzProviders, cchMultiSzProviders );

        goto    error;
    }

    pszCopy = (LPSTR)LocalAlloc( 0, cchMultiSzProviders );
    if ( pszCopy == NULL )
    {
        ErrorTrace( 0, "LocalAlloc failed: %d", GetLastError() );
        goto    error;
    }

    CopyMemory( pszCopy, lpMultiSzProviders, cchMultiSzProviders );

    //
    // cchMultiSzProviders-1 is to avoid adding an additional provider
    // for the terminating NULL char
    //
    for ( i=0, cProviders=0, psz=pszCopy; i<cchMultiSzProviders-1; i++, psz++ )
    {
        if ( *psz == '\0' )
        {
            cProviders++;
        }
    }

    //
    // ensure we're at the end and hence at the second terminating NULL char
    //
    _ASSERT( *psz == '\0' );

    if ( cProviders < 1 )
    {
        ErrorTrace( 0, "No valid providers were found" );
        goto    error;
    }


    pBlock = (PAUTH_BLOCK)LocalAlloc( 0, cProviders * sizeof(AUTH_BLOCK) );
    if ( pBlock == NULL )
    {
        ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
        goto    error;
    }

    //
    // start at 1 since 0 indicates the Invalid protocol
    //
    for ( i=0, psz=pszCopy; i<cProviders; i++ )
    {
        //
        // this would be the place to check whether the package was valid
        //
        DebugTrace( 0, "Protocol: %s, Package: %s", psz, PackageName(psz) );

        pBlock[i].Name = psz;

        psz += lstrlen(psz) + 1;
    }

    //
    // set global to new value; autoupdate will require critsec and mem free
    //

    LockPackages();

    //
    // if we're replacing already set packages; free their memory
    //
    if ( ProviderPackages != NULL )
    {
        LocalFree( (PVOID)ProviderPackages );
        ProviderPackages = NULL;
    }

    if ( ProviderNames != NULL )
    {
        LocalFree( (PVOID)ProviderNames );
        ProviderNames = NULL;
    }

    ProviderPackages = pBlock;
    cProviderPackages = cProviders;
    ProviderNames = pszCopy;

    UnlockPackages();


    return  TRUE;

error:

    if ( pszCopy != NULL )
    {
        DebugTrace( 0, "Cleaning up pszCopy" );
        _VERIFY( LocalFree( (LPVOID)pszCopy ) == NULL );
    }

    if ( pBlock != NULL )
    {
        DebugTrace( 0, "Cleaning up pBlock" );
        _VERIFY( LocalFree( (LPVOID)pBlock ) == NULL );
    }
    return  FALSE;

} // SetAuthPackageNames

BOOL
CSecurityCtx::GetAuthPackageNames(
                OUT LPBYTE      ReplyString,
                IN OUT PDWORD   ReplySize,
                IN PKG_REPLY_FMT    PkgFmt
                )
/*++

Routine Description:

    get the supported SSPI packages

    different than set in that the packages are returned using various
    delimeters to make it easier for the client to format the buffer.

Arguments:

    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.
    PkgFmt - Format of the reply string.

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::GetAuthPackageNames" );

    LPSTR   pszNext = (LPSTR)ReplyString;
    DWORD   cbReply = 0;
    DWORD   cbDelim;
    LPSTR   pbDelim;

    _ASSERT(PkgFmt == PkgFmtSpace || PkgFmt == PkgFmtCrLf);

    switch (PkgFmt)
    {
    case PkgFmtCrLf:
        {
            pbDelim = "\r\n";
            cbDelim = 2;
            break;
        }

    case PkgFmtSpace:
    default:
        {
            pbDelim = " ";
            cbDelim = 1;
            break;
        }
    }

    //
    // while in this loop ensure the contents dont change
    //
    LockPackages();

    for ( DWORD i=0; i<cProviderPackages; i++ )
    {
        LPSTR   pszName = ProviderPackages[i].Name;
        DWORD   cbName = lstrlen( pszName );

        //
        // +1 is for trailing space
        //
        if ( cbReply + cbName + cbDelim > *ReplySize )
        {
            break;
        }
        else
        {
            CopyMemory( pszNext, pszName, cbName );

            //
            // add the space separator
            //
            CopyMemory(pszNext + cbName, pbDelim, cbDelim);

            //
            // inc for loop pass
            //
            cbReply += cbName + cbDelim;
            pszNext += cbName + cbDelim;
        }
    }

    //
    // free access to the list
    //
    UnlockPackages();

    //
    // stamp the final trailing space with a NULL char
    //
    if ( cbReply > 0 && PkgFmt == PkgFmtSpace)
    {
        cbReply--;

        ReplyString[ cbReply ] = '\0';

        DebugTrace( 0, "Protocols: %s", ReplyString );
    }

    *ReplySize = cbReply;

    return  TRUE;
} // GetAuthPackageNames

BOOL
CSecurityCtx::ProcessUser(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        pszUser,
    OUT REPLY_LIST* pReply
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszUser -   user name
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessUser");

    DWORD   nameLen;


    //
    // if we're already logged on reset the user credentials
    //
    if ( m_IsAuthenticated )
    {
        Reset();
    }

    //
    // Don't allow user to overwrite the existing name.
    //

    if ( m_LoginName != NULL  )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    if ( (m_dwInstanceAuthFlags & INET_INFO_AUTH_CLEARTEXT) == 0 )
    {
        *pReply = SecPermissionDenied;
        return  FALSE;
    }

    if ( pszUser == NULL )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    nameLen = lstrlen( pszUser ) + 1;


    //
    // if anonymous is not allowed; fail a zero length user name
    //
    if ( nameLen <= 1 &&
        (m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS) == 0 )
    {
        *pReply = SecPermissionDenied;
        return  FALSE;
    }


    m_LoginName = (PCHAR)LocalAlloc( 0, nameLen );
    if ( m_LoginName == NULL )
    {
        *pReply = SecInternalErr;
        return  FALSE;
    }

    CopyMemory( m_LoginName, pszUser, nameLen );

    //
    // Tell client to send the password
    //
    *pReply = SecNeedPwd;
    return  TRUE;
}

BOOL
CSecurityCtx::ShouldUseMbs( void )
/*++

Routine Description:

    Determines if MBS_BASIC is being used.

Arguments:

Return Value:

    TRUE if successful

--*/
{
    CHAR *pszCtPackage;

    //
    // Simple heuristics: if we have a cleartext package
    // name, we will use MBS if the current package name
    // is NULL,
    //

    pszCtPackage = PackageName(m_szCleartextPackageName);
    if (pszCtPackage[0] != '\0' && !m_PackageName)
    {
        return(TRUE);
    }

    return(FALSE);
}

#define __STRCPYX(s, cs, len) \
    lstrcpy((s), (cs)); (s) += (len)

BOOL
CSecurityCtx::MbsBasicLogon(
    IN LPSTR        pszUser,
    IN LPSTR        pszPass,
    OUT BOOL        *pfAsGuest,
    OUT BOOL        *pfAsAnonymous
    )
/*++

Routine Description:

    Perform a MBS Basic logon sequence

Arguments:

    pszUser         - Username, can be NULL
    pszPass         - Password, may be NULL
    pfAsGuest       - Returns TRUE is logged on as guest
    pfAsAnonymous   - Returns TRUE is anonymous account used
    pReply          - Pointer to reply string id
    psi             - Server information block

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::MbsBasicLogon");

    BYTE        pbBlob[MAX_ACCT_DESC_LEN];
    DWORD       dwBlobLength;
    BUFFER      OutBuf;
    DWORD       dwOutBufSize;
    BOOL        fMoreData;
    BOOL        fRet;
    CHAR        *pTemp;
    SecBuffer   InSecBuff[2];
    SecBufferDesc InSecBuffDesc;

    // PU2_BASIC_AUTHENTICATE_MSG   pAuthMsg = (PU2_BASIC_AUTHENTICATE_MSG)pbBlob;

    _ASSERT(pfAsGuest);
    _ASSERT(pfAsAnonymous);

    if (!pszUser || !pszPass || !pfAsGuest || !pfAsAnonymous)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Input parameters NULL");
        return(FALSE);
    }

    *pfAsGuest = FALSE;
    *pfAsAnonymous = FALSE;

    if (lstrlen(pszUser) > UNLEN)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Username too long");
        return(FALSE);
    }

    if (lstrlen(pszPass) > PWLEN)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Password too long");
        return(FALSE);
    }

    //
    // With all the user name and password information, we will
    // build up a BLOB and then simply call Converse()
    //
    // The BLOB contains credential string of the format:
    // user:password\0
    //
    pTemp = (CHAR *)pbBlob;
    // __STRCPYX(pTemp, psi->QueryServiceName(), lstrlen(psi->QueryServiceName()));
    // __STRCPYX(pTemp, ":", 1);
    __STRCPYX(pTemp, pszUser, lstrlen(pszUser));
    __STRCPYX(pTemp, ":", 1);
    __STRCPYX(pTemp, pszPass, lstrlen(pszPass));

    //
    // Get the size of everything, not just the credentials
    //
    dwBlobLength = (DWORD)(pTemp - (CHAR *)pbBlob) + 1;

    //
    // U2 now requires 2 SecBuffer for MBS_BASIC
    //
    InSecBuffDesc.ulVersion = 0;
    InSecBuffDesc.cBuffers  = 2;
    InSecBuffDesc.pBuffers  = &InSecBuff[0];

    InSecBuff[0].cbBuffer   = dwBlobLength;
    InSecBuff[0].BufferType = SECBUFFER_TOKEN;
    InSecBuff[0].pvBuffer   = pbBlob;

    DebugTrace(0,"MbsBasicLogon: cleartext is %s membership is %s", m_szCleartextPackageName, m_szMembershipBrokerName);

    BYTE            pbServer[sizeof(WCHAR)*MAX_PATH+sizeof(UNICODE_STRING)];
    UNICODE_STRING* pusU2Server = (UNICODE_STRING*)pbServer;
    WCHAR* pwszU2Server = (WCHAR*)((UNICODE_STRING*)pbServer+1);
    if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szMembershipBrokerName, -1, pwszU2Server,
        MAX_PATH))
    {
        return FALSE;
    }

    pusU2Server->Length = (USHORT) (wcslen(pwszU2Server) * sizeof(WCHAR));
    pusU2Server->MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));
    pusU2Server->Buffer = (PWSTR)sizeof(UNICODE_STRING);

    InSecBuff[1].cbBuffer   = sizeof(pbServer);
    InSecBuff[1].BufferType = SECBUFFER_PKG_PARAMS;
    InSecBuff[1].pvBuffer   =  (PVOID)pbServer;


    //
    // Just call Converse() to do all the work!
    // We blow away tha anon password immediately after we're done.
    //

    fRet = ConverseEx(&InSecBuffDesc,
                    NULL,                       // SecBuffer is not encoded
                    &OutBuf,
                    &dwOutBufSize,
                    &fMoreData,
                    &m_TCPAuthentInfo,  
                    m_szCleartextPackageName,
                    NULL, NULL, NULL);

    //
    // Check the return values
    //
    if (fRet)
    {
        StateTrace((LPARAM)this, "Authentication succeeded");

        //
        // This is a one-shot deal, so we do not expect any more data
        //
        if (fMoreData)
        {
            SetLastError(ERROR_MORE_DATA);
            ErrorTrace((LPARAM)this, "Internal error: More data not expected");
            return(FALSE);
        }

        //
        // We should also expect zero returned buffer length
        //
        // _ASSERT(dwOutBufSize == 0);
    }

    return(fRet);
}

BOOL
CSecurityCtx::ProcessPass(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        pszPass,
    OUT REPLY_LIST* pReply
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszPass -   password
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessPass");
    DWORD   dwTick;
    BOOL    fRet;
    TCP_AUTHENT_INFO tai; // use default ctor

    //
    // give username first
    //
    if ( m_LoginName == NULL )
    {
        *pReply = SecNoUsername;
        return  FALSE;
    }

    if ( pszPass == NULL )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    //
    // Get tick count for tracing
    //
    dwTick = GetTickCount();

    //
    // Added for U2 BASIC authentication: We check if the current
    // package is the U2 BASIC package. If not, we do the usual 
    // ClearTextLogon() call. If so, we will call MBS
    //

    if (ShouldUseMbs())
    {
        //
        // This uses U2 BASIC
        //
        StateTrace((LPARAM)pIisInstance, "Doing Cleartext auth with package: <%s>",
                    m_szCleartextPackageName);

        fRet = MbsBasicLogon(m_LoginName,
                            pszPass,
                            &m_IsGuest,
                            &m_IsAnonymous);
    }
    else
    {
        //
        // K2_TODO: need to fill in TCP_AUTHENT_INFO !
        //
        tai.dwLogonMethod = LOGON32_LOGON_NETWORK;

        fRet = ClearTextLogon(
                            m_LoginName,
                            pszPass,
                            &m_IsGuest,
                            &m_IsAnonymous,
                            pIisInstance,
                            &tai
                            );
    }

    //
    // Trace ticks for logon
    //
    dwTick = GetTickCount() - dwTick;
    DebugTrace( (LPARAM)this,
                "ClearTextLogon took %u ticks", dwTick );

    if ( fRet )
    {

        if ( m_IsGuest && m_AllowGuest == FALSE )
        {
            ErrorTrace( (LPARAM)this, "Guest acct disallowed %s",
                        m_LoginName );
        }
        else if ( m_IsAnonymous &&
                ( m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS ) == 0 )
        {
            ErrorTrace( (LPARAM)this, "Anonymous logon disallowed %s",
                        m_LoginName );
        }
        else
        {
            *pReply = m_IsAnonymous ? SecAuthOkAnon : SecAuthOk ;
            return  m_IsAuthenticated = TRUE;
        }
    }
    else
    {
        ErrorTrace( (LPARAM)this,
                    "ClearTextLogon failed for %s: %d",
                    m_LoginName, GetLastError());

        //
        // reset the logon session to force the app to start over again
        //
        Reset();
    }

    *pReply = SecPermissionDenied;
    return  FALSE;
}

BOOL
CSecurityCtx::ProcessTransact(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        Blob,
    IN OUT LPBYTE   ReplyString,
    IN OUT PDWORD   ReplySize,
    OUT REPLY_LIST* pReply,
    IN DWORD        BlobLength
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszPass -   password
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessTransact");

    //
    // if we're already logged on reset the user credentials
    //
    if ( m_IsAuthenticated )
    {
        Reset();
    }


    //
    // If this is a new session, the first transact is the
    // protocol name
    //

    if ( m_PackageName == NULL )
    {
        PAUTH_BLOCK pBlock;

        LPSTR   protocol;
        DWORD   i;
        BOOL    bFound = FALSE;

        if ( (m_dwInstanceAuthFlags & INET_INFO_AUTH_NT_AUTH) == 0 )
        {
            *pReply = SecPermissionDenied;
            return  FALSE;
        }

        if ( (protocol = Blob) == NULL )
        {
            *pReply = SecSyntaxErr;
            return  FALSE;
        }

        //
        // if its an X- protocol strip the X- header
        //
        protocol = PackageName( protocol );

        //
        // See if this is a supported protocol
        // while in this loop ensure the contents dont change
        //
        LockPackages();

        for ( i=0; i < m_cProviderPackages; i++ )
        {
            pBlock = &m_ProviderPackages[i];

            //
            // get the name of the Block's package and strip any X-
            //
            LPSTR   pszPackageName = PackageName( pBlock->Name );

            if ( lstrcmpi( pszPackageName, protocol ) == 0 )
            {
                //
                // See if the package chosen was GSSAPI. If it was, then set 
                // m_PackageName to "Negotiate". This is required because the 
                // SASL GSSAPI mechanism maps to the NT Negotiate package
                //

                LPSTR pszPackageNameToUse = pszPackageName;

                if (lstrcmpi( pszPackageName, "GSSAPI") == 0)
                    pszPackageNameToUse = "Negotiate";
            
                DWORD   cb = lstrlen( pszPackageNameToUse ) + 1;

                DebugTrace( (LPARAM)this,
                            "Found: %s, Protocol %s, NT Package %s",
                            pszPackageName, pBlock->Name, pszPackageNameToUse );
                //
                // maintain a local copy of the package name in case
                // the list changes during the negotiation
                //
                m_PackageName = (PCHAR)LocalAlloc( 0, cb );
                if ( m_PackageName == NULL )
                {
                    *pReply = SecInternalErr;

                    //
                    // free access to the list
                    //
                    UnlockPackages();
                    return  FALSE;
                }

                CopyMemory( m_PackageName, pszPackageNameToUse, cb );
                bFound = TRUE;

                break;
            }
        }

        //
        // free access to the list
        //
        UnlockPackages();

        if ( bFound == FALSE )
        {
            //
            // not found
            //
            ErrorTrace( (LPARAM)this,
                        "could not find: %s", protocol );
            //
            // here's where we need to build the response string
            // app needs to call us to enum the installed packages
            // to the app can properly format the enumerated
            // "installed" packages within a protocol specific err msg
            //
            *pReply = SecProtNS;
            return  FALSE;
        }
        else
        {
            //
            // +OK response
            //
            *pReply = SecProtOk;
            return  TRUE;
        }
    }
    else
    {
        DWORD   nBuff;
        BOOL    moreData;
        BOOL    fRet;
        DWORD   dwTick;
        BUFFER  outBuff;

        if ( Blob == NULL )
        {
            *pReply = SecSyntaxErr;
            return  FALSE;
        }

        //
        // Get tick count for tracing
        //
        dwTick = GetTickCount();

        // m_PackageName must already be set by now
        _ASSERT(m_PackageName);

        if (!lstrcmpi(m_PackageName, "DPA") && m_szMembershipBrokerName && m_szMembershipBrokerName[0]) {
            SecBuffer   InSecBuff[2];
            SecBufferDesc InSecBuffDesc;
            BUFFER  DecodedBuf[2]; // scratch pad for decoding the sec buff

            DebugTrace(NULL,"DPA broker server is %s", m_szMembershipBrokerName);

            //
            //  for DPA authentication, we need to pass in 2 sec buffers
            //
            InSecBuffDesc.ulVersion = 0;
            InSecBuffDesc.cBuffers  = 2;
            InSecBuffDesc.pBuffers  = &InSecBuff[0];

            //
            // Fill in the first sec buffer
            // This contains the security blob sent by client, and is already encoded
            //
            InSecBuff[0].cbBuffer   = BlobLength ? BlobLength : lstrlen(Blob);
            InSecBuff[0].BufferType = SECBUFFER_TOKEN;
            InSecBuff[0].pvBuffer   = Blob;

            //
            // Fill in the second sec buffer, which contains the U2 broker id
            // Since ConverseEx will decode both sec buf, we need to encode
            // the second buf before calling ConverseEx
            //
            BYTE            pbServer[sizeof(WCHAR)*MAX_PATH+sizeof(UNICODE_STRING)];
            UNICODE_STRING* pusU2Server = (UNICODE_STRING*)pbServer;
            WCHAR* pwszU2Server = (WCHAR*)((UNICODE_STRING*)pbServer+1);
            BUFFER EncBuf;
            if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szMembershipBrokerName, -1, pwszU2Server,
                MAX_PATH))
            {
                ErrorTrace((LPARAM)this, "MultiByteToWideChar FAILED");
                return FALSE;
            }
            pusU2Server->Length = (USHORT) (wcslen(pwszU2Server) * sizeof(WCHAR));
            pusU2Server->MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));
            pusU2Server->Buffer = (PWSTR)sizeof(UNICODE_STRING);
            
            DWORD dwSize = MAX_PATH + sizeof(UNICODE_STRING);

            if (!uuencode((PBYTE)pbServer, dwSize, &EncBuf, m_fBase64)) {
                ErrorTrace((LPARAM)this, "uuencode FAILED");
                return FALSE;
            }

            InSecBuff[1].cbBuffer   = EncBuf.QuerySize();
            InSecBuff[1].BufferType = SECBUFFER_PKG_PARAMS;
            InSecBuff[1].pvBuffer   =  EncBuf.QueryPtr();

            fRet = ConverseEx(&InSecBuffDesc,
                            DecodedBuf,                     
                            &outBuff,
                            &nBuff,
                            &moreData,
                            &m_TCPAuthentInfo,  
                            m_PackageName,
                            NULL, NULL, NULL);
        }
        else {
            //
            //  for non-DPA authentication (i.e. NTLM, etc)
            //

            fRet = Converse(Blob,
                            BlobLength ? BlobLength : lstrlen(Blob),
                            &outBuff,
                            &nBuff,
                            &moreData,
                            &m_TCPAuthentInfo,  
                            m_PackageName);
        }
        //
        // Trace ticks for conversing
        //
        dwTick = GetTickCount() - dwTick;
        DebugTrace((LPARAM)this, "Converse(%s) took %u ticks", m_PackageName, dwTick );

        if ( fRet )
        {
            DebugTrace( (LPARAM)this,
                        "Converse ret TRUE, nBuff: %d, moredata %d",
                        nBuff, moreData );

            if ( moreData )
            {
                _ASSERT( nBuff != 0 );

                CopyMemory( ReplyString, outBuff.QueryPtr(), nBuff );
                *ReplySize = nBuff;

                //
                // reply equals SecNull to tell the app to send
                // this buffer to remote client/server
                //
                *pReply = SecNull;
                return  TRUE;

            } else {

                STR strUser;    // was BUFFER buff pre-K2

                if ( m_IsGuest && m_AllowGuest == FALSE )
                {
                    SetLastError( ERROR_LOGON_FAILURE );
                    *pReply = SecPermissionDenied;
                    return  FALSE;
                }

                if ( TCP_AUTHENT::QueryUserName( &strUser ) )
                {
                    m_LoginName = (PCHAR)LocalAlloc( 0, strUser.QuerySize() );
                    if ( m_LoginName != NULL )
                    {
                        CopyMemory( m_LoginName,
                                    strUser.QueryPtr(),
                                    strUser.QuerySize() );

                        DebugTrace( (LPARAM)this,
                                    "Username: %s, size %d",
                                    m_LoginName, strUser.QuerySize() );

                        *pReply = SecAuthOk;
                    }
                    else
                    {
                        ErrorTrace( (LPARAM)this,
                                    "LocalAlloc failed. err: %d",
                                    GetLastError() );
                        *pReply = SecInternalErr;
                    }
                    strUser.Resize(0);
                }
                else
                {
                    ErrorTrace( (LPARAM)this,
                                "QueryUserName failed. err: %d",
                                GetLastError() );
                    *pReply = SecInternalErr;

                    //
                    // Firewall around NT bug where negotiation succeeds even though
                    // it should really have failed (when an empty buffer is passed
                    // to AcceptSecurityContext). In this case, the QueryUserName is
                    // the only valid check - gpulla.
                    //

                    return m_IsAuthenticated = FALSE;
                }
                return  m_IsAuthenticated = TRUE;
            }
        }
        else
        {
            SECURITY_STATUS ss = GetLastError();
            ErrorTrace( (LPARAM)this,
                        "Converse failed. err: 0x%08X", ss );

            *pReply = SecPermissionDenied;
        }
    }
    return  FALSE;
}

BOOL
CSecurityCtx::ProcessAuthInfo(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN AUTH_COMMAND     Command,
    IN LPSTR            Blob,
    IN OUT LPBYTE       ReplyString,
    IN OUT PDWORD       ReplySize,
    OUT REPLY_LIST*     pReply,
    IN OPTIONAL DWORD   BlobLength
    )
/*++

Routine Description:

    Process AUTHINFO commands

Arguments:

    Command  - Authinfo command received
    Blob - Blob accompanying the command
    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.

Return Value:

    None.

--*/
{
    //
    // transition codes to support backward compatibility
    // will be removed later when everybody has moved to new version of simauth2
    //
    if (!m_ProviderPackages) {
        m_ProviderPackages = ProviderPackages;
        m_ProviderNames = ProviderNames;
        m_cProviderPackages = cProviderPackages;
    }


    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessAuthInfo");

    BOOL    bSuccess = FALSE;

    START_TRY

    //
    // We currently support USER, PASSWORD, and TRANSACT
    //

    switch( Command )
    {
     case AuthCommandUser:
        bSuccess = ProcessUser( pIisInstance, Blob, pReply );
        break;

     case AuthCommandPassword:
        bSuccess = ProcessPass( pIisInstance, Blob, pReply );
        break;

     case AuthCommandTransact:
        bSuccess = ProcessTransact( pIisInstance,
                                    Blob,
                                    ReplyString,
                                    ReplySize,
                                    pReply,
                                    BlobLength );
        break;
    
     default:
        if ( m_IsAuthenticated )
        {
            Reset();
        }
        *pReply = SecSyntaxErr;
    }

    TRY_EXCEPT
    END_TRY

    _ASSERT( *pReply < NUM_SEC_REPLIES );
    if ((DWORD)*pReply >= NUM_SEC_REPLIES)
        *pReply = SecInternalErr;

    return  bSuccess;

} // ProcessAuthInfo

BOOL CSecurityCtx::ClientConverse(
    IN VOID *           pBuffIn,
    IN DWORD            cbBuffIn,
    OUT BUFFER *        pbuffOut,
    OUT DWORD *         pcbBuffOut,
    OUT BOOL *          pfNeedMoreData,
    IN PTCP_AUTHENT_INFO pTAI,
    IN CHAR *           pszPackage,
    IN CHAR *           pszUser,
    IN CHAR *           pszPassword,
    IN PIIS_SERVER_INSTANCE psi)
/*++

Routine Description:

    Processes AUTH blobs for a client (ie, for an outbound connection). This is
    a simple wrapper around TCP_AUTHENT::Converse; it will map Internet protocol
    keywords to NT security package names.

Arguments:

    Same as that for TCP_AUTHENT::Converse

Return Value:

    Same as that for TCP_AUTHENT::Converse
--*/
{
    LPSTR pszPackageToUse = pszPackage;

    if (pszPackage != NULL && 
            (lstrcmpi(pszPackage, "GSSAPI") == 0) ) {
        pszPackageToUse = "Negotiate";
    }

    return( Converse( 
                pBuffIn, cbBuffIn,
                pbuffOut, pcbBuffOut, pfNeedMoreData, 
                pTAI, pszPackageToUse,
                pszUser, pszPassword,
                psi) );
}

//
// Figure out if the local machine is a member of a domain, or in a
// workgroup.  If we aren't in a domain then we don't want to call into
// ResetServicePrincipleNames.
//
// This function returns TRUE in error cases, because it is better to
// call into ResetServicePrininpleNames by mistake then it is to 
// skip calling it.
//
// Implemented using this algorithm:
// 
//   There are many ways to find out if you are in a work group.  You can
//   call LsaOpenPolicy /
//   LsaQueryInformationPolicy(PolicyDnsDomainInformation) / LsaClose, and
//   check if the SID is non-null.  That's authoritative.
// 
//   -Rich (Richard B. Ward (Exchange))
//
BOOL fInDomain() {
    TraceFunctEnter("fInDomain");
    
    LSA_HANDLE lsah;
    LSA_OBJECT_ATTRIBUTES objAttr;
    POLICY_DNS_DOMAIN_INFO *pDnsInfo;
    NTSTATUS ec;

    // cache the results of this here.  one can't join a domain without
    // rebooting, so this safe to do once
    static BOOL fDidCheck = FALSE;
    static BOOL fRet = TRUE;

    if (!fDidCheck) {
        ZeroMemory(&objAttr, sizeof(objAttr));

        ec = LsaOpenPolicy(NULL,
                           &objAttr,
                           POLICY_VIEW_LOCAL_INFORMATION,
                           &lsah);
        if (ec == ERROR_SUCCESS) {
            ec = LsaQueryInformationPolicy(lsah,
                                           PolicyDnsDomainInformation,
                                           (void **) &pDnsInfo);
            if (ec == ERROR_SUCCESS) {
                DebugTrace(0, "pDnsInfo = %x", pDnsInfo);
                // we are in a domain if there is a Sid
                if (pDnsInfo && pDnsInfo->Sid) {
                    fRet = TRUE;
                } else {
                    fRet = FALSE;
                }
                fDidCheck = TRUE;

                LsaFreeMemory(pDnsInfo);
            } else {
                DebugTrace(0, "LsaQueryInformationPolicy failed with %x", ec);
            }

            LsaClose(lsah);
        } else {
            DebugTrace(0, "LsaOpenPolicy failed with %x", ec);
        }
    }

    TraceFunctLeave();
    return fRet;
}


BOOL
CSecurityCtx::ResetServicePrincipalNames(
    IN LPCSTR szServiceClass)
/*++

Routine Description:

    Unregisters all service principal names for the given service from the
    local machine's computer account object.  

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"

Return Value:

    None.

--*/
    
{
    
    DWORD dwErr;

    if (fInDomain()) {
        dwErr = DsServerRegisterSpnA(
                    DS_SPN_DELETE_SPN_OP,
                    szServiceClass,
                    NULL);
    } else {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return( FALSE );
    } else {
        return( TRUE );
    }

}

BOOL
CSecurityCtx::RegisterServicePrincipalNames(
    IN LPCSTR szServiceClass,
    IN LPCSTR szFQDN)
/*++

Routine Description:

    Registers service specific SPNs for the provided FQDN. The list of SPNs is
    generated by doing a gethostbyname on the FQDN, and using the returned IP
    addresses as th SPNs.

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"
    szFQDN: The FQDN of the virtual server. It will be used to do a 
        gethostbyname and retrieve a list of IP addresses to use.

Return Value:

    None.

--*/
    
{
    DWORD dwErr, cIPAddresses;

    if (fInDomain()) {
        dwErr = DsServerRegisterSpnA(
                    DS_SPN_ADD_SPN_OP,
                    szServiceClass,
                    NULL);
    } else {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return( FALSE );
    } else {
        return( TRUE );
    }

}

#define MAX_SPN     260

BOOL
CSecurityCtx::SetTargetPrincipalName(
    IN LPCSTR szServiceClass,
    IN LPCSTR szTargetIPOrFQDN)
/*++

Routine Description:

    Unregisters all service principal names for the given service from the
    local machine's computer account object.  

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"

Return Value:

    None.

--*/
    
{
    DWORD dwErr, cbTargetSPN;
    CHAR szTargetSPN[MAX_SPN];

    cbTargetSPN = sizeof(szTargetSPN);

    dwErr = DsClientMakeSpnForTargetServerA(
                szServiceClass,
                szTargetIPOrFQDN,
                &cbTargetSPN,
                szTargetSPN);

    if (dwErr == ERROR_SUCCESS) {

        return( SetTargetName(szTargetSPN) );

    } else {

        SetLastError(dwErr);

        return( FALSE );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\simssl2\credcach.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    credcach.cxx

Abstract:

    This module contains the code to associate and cache SSPI credential
    handles with local server addresses

Author:

Comments :

This is a two-level cache : the first level is at the instance level [INSTANCE_CACHE_ITEM]
and just contains a pointer to the actual item holding the credential handles. The second level
[CRED_CACHE_ITEM] holds the actual credential handles, as well as pointers to the mappers.

An INSTANCE_CACHE_ITEM points to a CRED_CACHE_ITEM, with a single CRED_CACHE_ITEM potentially
being referenced by several INSTANCE_CACHE_ITEMS, if several instances share the relevant data.

      Each instance has 3 SSL-related components : the server certificate for the instance, the
certificate mappers for the instance and the trusted issuers for the instance [a combination of
the certificates in the ROOT store and the Certificate Trust List associated with the server]. Two
instances can share a CRED_CACHE_ITEM under the following circumstances :

1. The same server certificate
2. No/Same CTL
3. No mappers

The INSTANCE_CACHE_ITEM entries are keyed off "<instance ptr>"; the CRED_CACHE_ITEM
entries are keyed off an "SSL info" blob which can be used to uniquely distinguish between
credential sets that don't fulfill the criteria listed above. The SSL info blob is obtained by
querying the instance and consists of "<SHA1 hash of server cert>:<SHA1 hash of CTL>",
which has the advantage of being fixed length [20 bytes for cert hash, 20 bytes for CTL hash,
1 byte for ':']. If there is no CTL, the length is still 41, but everything after the CERT has is
zeroed out

Revision History:

	Nimish Khanolkar		FEB'98		Changes related to having one cert per instance
--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>

}

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <iadm.h>
#include <mb.hxx>
#include <iiscnfg.h>
//#include <iiscnfgp.h>
#include <refb.hxx>

#include <cmnull.hxx>
#include <iiscrmap.hxx>

#include "iistypes.hxx"

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
#include <ntsecapi.h>
#include <spseal.h>
#include <schnlsp.h>
#include ".\credcach.hxx"
#include <w3svc.h>
}

#include "iiscert.hxx"
#include "iisctl.hxx"
#include "capiutil.hxx"


#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#ifdef  UNIT_TEST
DEBUG_PRINTS  *  g_pDebug = 0;
#endif

#define SSPIFILT_CERT_MAP_LIST  "CertMapList"
#define SSPIFILT_INIT_MAP       "CreateInstance"
#define SSPIFILT_TERM_MAP       "TerminateMapper"

//
//  Globals
//

LIST_ENTRY CredCacheList;
LIST_ENTRY InstanceCacheList;
CRED_CACHE_ITEM* g_pcciClient = NULL;

IMDCOM*    pMDObject;

IMSAdminBaseW* pAdminObject;


//
//  Prototypes
//

BOOL
LoadKeys(
    IN  IIS_SSL_INFO *pSSLInfo,
	IN	PVOID		 pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
	IN  LPSTR        pszMdPath
    );

BOOL
AddFullyQualifiedItem(
    IN  WCHAR *             pwszServerPrefix,
    CHAR *                  pszId,
    IN  UINT                cId,
    CHAR *                  pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    );

BOOL
AddItem(
    CHAR *				pszAddress,
    LPVOID				pvInstanceId,
    RefBlob*			pCert11,
    RefBlob*			pCertW,
    IIS_SSL_INFO		*pSSLInfo,
    CRED_CACHE_ITEM**	ppcci,
    DWORD				dwInstanceId,
	LPSTR				pszMdPath
    );

BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    );

BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
	LPVOID		pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    );


VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );


BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob );



VOID
InitCredCache(
    VOID
    )
/*++

Routine Description:

    Initializes the credential cache

--*/
{
    InitializeListHead( &CredCacheList );
    InitializeListHead( &InstanceCacheList );
}


VOID
FreeCredCache(
    VOID
    )
/*++

Routine Description:

    Releases all of the memory associated with the credential cache

--*/
{
    //LIST_ENTRY * pEntry;
    CRED_CACHE_ITEM * pcci;
    INSTANCE_CACHE_ITEM * pici;

    while ( !IsListEmpty( &InstanceCacheList ))
    {
        pici = CONTAINING_RECORD( InstanceCacheList.Flink,
                                  INSTANCE_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pici->m_ListEntry );

        delete pici;
    }

    while ( !IsListEmpty( &CredCacheList ))
    {
        pcci = CONTAINING_RECORD( CredCacheList.Flink,
                                  CRED_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pcci->m_ListEntry );

        pcci->Release();
    }

    if ( g_pcciClient != NULL )
    {
        g_pcciClient->Release();
        g_pcciClient = NULL;
    }
}


BOOL
LookupFullyQualifiedCredential(
    IN  WCHAR *             pwszServerPrefix,
    IN  CHAR *              pszIpAddress,
    IN  DWORD               cbAddress,
    IN  CHAR *              pszPort,
    IN  DWORD               cbPort,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszIpAddress - Address name for this credential
    cbAddress - Number of bytes (including '\0') of pszIpAddress
    pszPort - Port ID for this credential
    cbPort - Number of bytes ( including '\0') of pszPort
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    ppCCI - Receives pointer to a Credential Cache Item
    pvsmc - ptr to map context using the instance specified in pvInstanceId
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_INVALID_NAME is returned.

--*/
{
    INSTANCE_CACHE_ITEM *   pcci;
    LIST_ENTRY *            pEntry;
    CHAR                    achId[MAX_ADDRESS_LEN];
//    LPSTR                   p = achId;
    UINT                    cId = 0;

/*NimishK : not needed
    //
    // build ID of this credential request : IP address + port + instance
    //

    memcpy( p, pszIpAddress, cbAddress );
    p += cbAddress;
    *p++ = ':';
    memcpy( p, pszPort, cbPort );
    p += cbPort;
    *p++ = ':';

	// An INSTANCE_CACHE_ITEM is keyed of Instance ptr
//    *(LPVOID*)p = pvInstanceId;
//    cId = sizeof(LPVOID);
*/

RescanList:

    for ( pEntry  = InstanceCacheList.Flink;
          pEntry != &InstanceCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, INSTANCE_CACHE_ITEM, m_ListEntry );

		// An INSTANCE_CACHE_ITEM is keyed of Instance ptr. Compare it.
        if ( pcci->m_pvInstanceId == pvInstanceId )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci->m_pcci;
                pcci->m_pcci->AddRef();
                return TRUE;
            }

            SetLastError( ERROR_INVALID_NAME );
            *ppCCI = NULL;
            return FALSE;
        }
    }

    //
    //  This address isn't in the list, try getting it credential cache then
    //  rescan the list for the new item.  Note we leave the list locked
    //  while we try and get the item.  This prevents multiple threads from
    //  trying to create the same item
    //

    if ( !AddFullyQualifiedItem( pwszServerPrefix, achId, cId, pszIpAddress, pszPort, pvInstanceId, pvsmc, dwInstanceId ))
    {
        return FALSE;
    }

    goto RescanList;
}


VOID
ReleaseCredential(
    CRED_CACHE_ITEM * pcci
    )
/*++

Routine Description:

    Release a credential acquired via LookupFullyQualifiedCredential()

Arguments:

    pCCI - pointer to a Credential Cache Item

Returns:

    Nothing

--*/
{
    if ( pcci )
    {
        pcci->Release();
    }
}

//
// Secret value names. Each value exist in 4 variants,
// used to access the Lsa secret, the 1st one using IP + port
// the 2nd one IP only, the 3rd one port only
// The 4th entry specify designate the default value ( common to all address and ports )
//

LPSTR SecretTableA[4] =
{
    "%s:%s", "%s", "%0.0s%s", "default",
};

LPWSTR SecretTableW[4] =
{
    L"%S:%S", L"%S", L"%0.0S%S", L"default",
};

BOOL
GetMDSecret(
    MB*             pMB,
    LPSTR           pszObj,
    DWORD           dwId,
    UNICODE_STRING**ppusOut
    )
{
    DWORD           dwL = 0;
    PUNICODE_STRING pusOut = NULL;

    if ( pMB->GetData( pszObj,
                       dwId,
                       IIS_MD_UT_SERVER,
                       BINARY_METADATA,
                       NULL,
                       &dwL,
                       METADATA_SECURE ) || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        if ( (pusOut = (PUNICODE_STRING)LocalAlloc( LMEM_FIXED, sizeof(UNICODE_STRING) )) &&
             (pusOut->Buffer = (WORD*)LocalAlloc( LMEM_FIXED, dwL )) )
        {
            if ( pMB->GetData( pszObj,
                               dwId,
                               IIS_MD_UT_SERVER,
                               BINARY_METADATA,
                               pusOut->Buffer,
                               &dwL,
                               METADATA_SECURE ) )
            {
                pusOut->Length = pusOut->MaximumLength = (WORD)dwL;
                *ppusOut = pusOut;
                return TRUE;
            }
        }

        if (pusOut) {
            if (pusOut->Buffer) {
                LocalFree( pusOut->Buffer );
            }
            LocalFree( pusOut );
        }
    }

    return FALSE;
}


BOOL
GetAdminSecret(
    WCHAR *         pwszServerPrefix,
    IMSAdminBaseW*  pAdminObj,
    LPWSTR          pszObj,
    DWORD           dwId,
    UNICODE_STRING**ppusOut
    )
{
    DWORD           dwL = 0;
    DWORD           dwErr = 0;
    PUNICODE_STRING pusOut;
    HRESULT hRes = S_OK;
    METADATA_HANDLE RootHandle;
    METADATA_RECORD mdRecord;
    WCHAR           wszMetabaseRoot[256] ;

    wsprintfW( wszMetabaseRoot, SSL_SERVICE_KEYS_MD_PATH_W, pwszServerPrefix ) ;

    hRes = pAdminObject->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                wszMetabaseRoot,
                METADATA_PERMISSION_READ,
                100,
                &RootHandle
                );

    if (FAILED(hRes)) {
        return FALSE ;
    }

    mdRecord.dwMDIdentifier = dwId;
    mdRecord.dwMDAttributes = METADATA_SECURE;
    mdRecord.dwMDUserType   = IIS_MD_UT_SERVER;
    mdRecord.dwMDDataType   = BINARY_METADATA;
    mdRecord.dwMDDataLen    = dwL;
    mdRecord.pbMDData       = NULL;

    hRes = pAdminObj->GetData(  RootHandle,
                                pszObj,
                                &mdRecord,
                                &dwL ) ;

    if( FAILED(hRes) && (HRESULTTOWIN32( hRes ) == ERROR_INSUFFICIENT_BUFFER) )
    {
        if ( (pusOut = (PUNICODE_STRING)LocalAlloc( LMEM_FIXED, sizeof(UNICODE_STRING) )) &&
             (pusOut->Buffer = (WORD*)LocalAlloc( LMEM_FIXED, dwL )) )
        {
            mdRecord.dwMDIdentifier = dwId;
            mdRecord.dwMDAttributes = METADATA_SECURE;
            mdRecord.dwMDUserType   = IIS_MD_UT_SERVER;
            mdRecord.dwMDDataType   = BINARY_METADATA;
            mdRecord.dwMDDataLen    = dwL;
            mdRecord.pbMDData       = (PBYTE)pusOut->Buffer;

            hRes = pAdminObj->GetData(  RootHandle,
                                        pszObj,
                                        &mdRecord,
                                        &dwL );
            if( SUCCEEDED( hRes ) )
            {
                pusOut->Length = pusOut->MaximumLength = (WORD)mdRecord.dwMDDataLen;
                *ppusOut = pusOut;
                pAdminObject->CloseKey(RootHandle);
                return TRUE;
            }
            dwErr = GetLastError();
        }

        if (pusOut) {
            if (pusOut->Buffer) {
                LocalFree( pusOut->Buffer );
            }
            LocalFree( pusOut );
        }
    }

    pAdminObject->CloseKey(RootHandle);
    return FALSE;
}

BOOL
AddFullyQualifiedItem(
    IN  WCHAR *             pwszServerPrefix,
    IN  CHAR *              pszId,
    IN  UINT                cId,
    IN  CHAR *              pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    This routine must be single threaded

Arguments:

    pszId - ID of cache entry to add
    pszAddress - Address name for this credential
    pszPort - port for this credential
    pvInstanceId - ptr to be used as service instance ID for this credential
    pvsmc - ptr to map context using the instance specified in pvInstanceId
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure

--*/
{

    CHAR              achSecretNameA[MAX_SECRET_NAME+1];
/*	// NimishK : I don't think these are used anymore
	//WCHAR             achSecretName[MAX_SECRET_NAME+1];
    //UNICODE_STRING *  SecretValue[3];
    //DWORD             i;
    //DWORD             j;
*/
    BOOL              fRet = TRUE;
    INSTANCE_CACHE_ITEM * pcci;
    RefBlob*          pBlob11 = NULL;
    RefBlob*          pBlobW = NULL;
    CRED_CACHE_ITEM * pci;

	//Added for CAPI stuff
	IIS_SSL_INFO      *pSSLInfoObj = NULL;
	PBYTE             pbSSLBlob = NULL;

    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)pvsmc;

	//Need to clean this up with pvInstanceId->QueryMDPath()
	CHAR   szMDPath[256] ;
	wsprintf( szMDPath, "/LM/%S/%d", pwszServerPrefix,dwInstanceId ) ;

/*
// Nimishk : I dont think this is needed

    MB                mb( pMDObject );

    CHAR              szMetabaseRoot[256] ;

    wsprintf( szMetabaseRoot, SSL_SERVICE_KEYS_MD_PATH, pwszServerPrefix ) ;

    if ( !mb.Open( szMetabaseRoot ))
    {
        return FALSE;
    }
*/
/* NimishK cId is no longer used

    if ( cId > MAX_ADDRESS_LEN )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
*/

    //
    //  Create and initialize the context item
    //

    pcci = new INSTANCE_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

//    memcpy( pcci->m_achId, pszId, cId );
//    pcci->m_cbId = cId;
    pcci->m_pvInstanceId = pvInstanceId;

    pcci->m_fValid = FALSE;
    pcci->m_pcci = NULL;

    InsertTailList( &InstanceCacheList, &pcci->m_ListEntry );

/*Nimishk : Dont need this anymore
    //
    //  Retrieve the secret from the registry
    //

    fRet = FALSE;

    memset( SecretValue, 0, sizeof( SecretValue ));
*/

	//
	// Get the "SSL id" blob used to locate the CRED_CACHE_ITEM for this instance
	//
	if ( pvInstanceId )
	{
		IIS_SERVER_INSTANCE *pIISInstance = (IIS_SERVER_INSTANCE *) pvInstanceId;


		if ( ( pSSLInfoObj = pIISInstance->QueryAndReferenceSSLInfoObj()) &&
			 GenerateSSLIdBlob( pSSLInfoObj,
								(PBYTE) achSecretNameA ) )
		{
			fRet = TRUE ;
		}
	}

	if ( fRet )
    {
        if( psmc )
        {
            //
            // Retrieve blobs pointing to cert 1:1 mapper & cert wildcard mapper
            //

            if ( !psmc->ServerSupportFunction(  pvInstanceId,
                                                (LPVOID)&pBlob11,
                                                SIMSSL_PROPERTY_MTCERT11 ) )
            {
                pBlob11 = NULL;
            }

            if ( !psmc->ServerSupportFunction(  pvInstanceId,
                                                (LPVOID)&pBlobW,
                                                SIMSSL_PROPERTY_MTCERTW ) )
            {
                pBlobW = NULL;
            }
        }

        //
        // All instances w/o mappers maps to NULL, so that they share a CRED_CACHE_ENTRY
        //

        if ( pBlob11 == NULL && pBlobW == NULL )
        {
            pvInstanceId = NULL;
        }

        //
        // try fo find it in cache
        // returned cache entry's refcount is incremented by LookupCredential or AddItem
        // if successfull
        //

        if ( !LookupCredential( (LPSTR)achSecretNameA, pvInstanceId, &pci ) )
        {
            if ( GetLastError() == ERROR_NO_MORE_ITEMS )
            {
                //
                //  This address isn't in the list, try getting it from the lsa then
                //  rescan the list for the new item.  Note we leave the list locked
                //  while we try and get the item.  This prevents multiple threads from
                //  trying to create the same item
                //

                if ( AddItem( (LPSTR)achSecretNameA,
								pvInstanceId,
								pBlob11,
								pBlobW,
								pSSLInfoObj,
								&pci,
								dwInstanceId,
								(LPSTR)szMDPath ) )
                {
                    pcci->m_pcci = pci;
                    pcci->m_fValid = TRUE;
                }
            }
        }
        else
        {
            pcci->m_pcci = pci;
            pcci->m_fValid = TRUE;
        }
    }

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //
/* Not needed anymore

    for ( i = 0; i < 3; i++ )
    {
        if( SecretValue[i] != NULL )
        {
            LocalFree( SecretValue[i]->Buffer );
            LocalFree( SecretValue[i] );
        }
    }
*/
    //
    // Release blob now. CRED_CACHE_ITEM added a reference to them
    // if entry created
    //

    if ( pBlob11 != NULL )
    {
        pBlob11->Release();
    }
    if ( pBlobW != NULL )
    {
        pBlobW->Release();
    }

	//
	// Release IIS_SSL_INFO object, since we're done with it
	//
	if ( pSSLInfoObj )
	{
		IIS_SSL_INFO::Release( pSSLInfoObj );
	}

    return TRUE;
}


BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    ppCCI - Receives pointer to a Credential Cache Item

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_NO_MORE_ITEMS is returned.
    If key exist but entry invalid then ERROR_INVALID_NAME is returned.

--*/
{
    CRED_CACHE_ITEM * pcci;
    LIST_ENTRY *      pEntry;

    for ( pEntry  = CredCacheList.Flink;
          pEntry != &CredCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, CRED_CACHE_ITEM, m_ListEntry );

        if ( !memcmp( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN ) &&
             pcci->m_pvInstanceId == pvInstanceId )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci;
                pcci->AddRef();
                return TRUE;
            }

            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
    }

    SetLastError( ERROR_NO_MORE_ITEMS );

    return FALSE;
}


BOOL
AddItem(
    CHAR * pszAddress,
    LPVOID pvInstanceId,
    RefBlob* pCert11,
    RefBlob* pCertW,
    IIS_SSL_INFO *pSSLInfoObj,
    CRED_CACHE_ITEM** ppcci,
    DWORD             dwInstanceId,
	LPSTR             pszMdPath
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    This routine must be single threaded

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as service instance ID for this credential
    pCert11 - ptr to blob storing cert 1:1 mapper or NULL if no mapper
    pCertW - ptr to blob storing cert wildcard mapper or NULL if no mapper
    pSSLInfObj - pointer to SSL info to be used for this item
    ppCCI - Receives pointer to a Credential Cache Item
    dwInstanceId - w3 instance ID

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL              fRet = TRUE;
    BOOL              fRetM;
    BOOL              fRetL;
    CRED_CACHE_ITEM * pcci;

    //
    //  Create and initialize the context item
    //

    pcci = new CRED_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    memcpy( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN );
    pcci->m_pvInstanceId = pvInstanceId;

    memset( pcci->m_ahCred, 0, sizeof( pcci->m_ahCred ));
    memset( pcci->m_ahCredMap, 0, sizeof( pcci->m_ahCredMap ));
    memset( pcci->m_acbTrailer, 0, sizeof( pcci->m_acbTrailer ));
    memset( pcci->m_acbHeader, 0, sizeof( pcci->m_acbHeader ));

    InsertTailList( &CredCacheList, &pcci->m_ListEntry );

    //
    // build cert mapper DLLs array
    //

    if ( fRetM = InitializeCertMapping( pCert11 ? pCert11->QueryPtr() : NULL,
                                        pCertW ? pCertW->QueryPtr() : NULL,
										pSSLInfoObj ? (LPVOID) pSSLInfoObj : NULL,
                                        &pcci->m_ppMappers,
                                        &pcci->m_cNbMappers,
                                        dwInstanceId ) )
    {
        //
        //  LoadKeys will zero out these values on success or failure.  Note
        //  the password is stored as an ansi string because the SSL
        //  security structure is expecting an ANSI string
        //

        fRetL = LoadKeys( pSSLInfoObj,
						  pvInstanceId,
                          pcci->m_ppMappers,
                          pcci->m_cNbMappers,
                          pcci->m_ahCred,
                          &pcci->m_cCred,
                          pcci->m_ahCredMap,
                          &pcci->m_cCredMap,
						  pszMdPath );
    }
    else
    {
        fRetL = FALSE;
    }

    //
    //  Indicate the credential handle is valid on this address if we
    //  succeeded
    //

    if ( fRetL && fRetM )
    {
        pcci->m_fValid = TRUE;
    }
    else
    {
        pCert11 = NULL;
        pCertW = NULL;

        if ( fRetM && !fRetL )
        {
            TerminateCertMapping( pcci->m_ppMappers, pcci->m_cNbMappers );
            pcci->m_ppMappers = NULL;
            pcci->m_cNbMappers = 0;
        }
    }

    //
    // Store reference to mappers
    //

    if ( pcci->m_pBlob11 = pCert11 )
    {
        pCert11->AddRef();
    }

    if ( pcci->m_pBlobW = pCertW )
    {
        pCertW->AddRef();
    }

	//
	// Store reference to SSL info
	//
	if ( pcci->m_pSslInfo = pSSLInfoObj )
	{
		pSSLInfoObj->Reference();
	}

    //
    // Add ref, as will be referenced by *ppcci
    //

    pcci->AddRef();

    *ppcci = pcci;

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //

    return TRUE;
}


BOOL
LoadKeys(
    IN IIS_SSL_INFO *pSSLInfoObj,
	IN	PVOID		 pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
	IN  LPSTR        pszMdPath
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pSSLInfoObj - object containing SSL info to be used for this credential set
    ppMappers - ptr to array of mapper DLLs
    cNbMappers - number of entry in ppMappers
    phCreds - ptr to array where to store credential handles w/o cert mapping
    pcCred - ptr to counter where to store number of entry in phCreds
    phCredsMap - ptr to array where to store credential handles w/ cert mapping
    pcCredMap - ptr to counter where to store number of entry in phCredsMap
	pszMdPath - path to metabase properties

Returns:

    TRUE on success, FALSE on failure.

--*/
{
    ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

    //SCH_CRED                    creds;
	// CAPI stuff
	SCHANNEL_CRED               xcreds;
    HCERTSTORE hRootStore;

/*NimishK
//		SCH_CRED_SECRET_CAPI        scsp;
//  	SCH_CRED_PUBLIC_CERTCHAIN   scpc;
*/

	SECURITY_STATUS             scRet;
    SECURITY_STATUS             scRetM;
    TimeStamp                   tsExpiry;
    DWORD                       i;

/*NimishK
//    LPVOID                      ascsp[1];
//    LPVOID                      ascpc[1];
//    DWORD                       dwV;
//		MB                          mb( pMDObject );
//		BUFFER                      buAlg;
*/

	// Added for CAPI stuff
    PCCERT_CONTEXT              pcCert = NULL;
    LPVOID                      pcreds;

    *pcCred             = 0;
    *pcCredMap          = 0;

    memset(&xcreds, 0, sizeof(xcreds));
    xcreds.dwVersion = SCHANNEL_CRED_VERSION;

	if ( pSSLInfoObj->GetCertificate() &&
		pSSLInfoObj->GetCertificate()->IsValid() )
	{
		xcreds.cCreds = 1;
		xcreds.paCred = pSSLInfoObj->GetCertificate()->QueryCertContextAddr();
	}
    else
    {
        return TRUE;
    }

    xcreds.cMappers = cNbMappers ;
    xcreds.aphMappers = ppMappers;

	if (pSSLInfoObj->GetTrustedIssuerStore( &hRootStore ))
	{
		xcreds.hRootStore = hRootStore;
	}
	else
	{
		xcreds.hRootStore = NULL;
	}

    pcreds = (LPVOID) &xcreds;

    for ( i = 0; pEncProviders[i].pszName && i < MAX_PROVIDERS; i++ )
    {
        if ( !pEncProviders[i].fEnabled )
        {
            continue;
        }

        //creds.cMappers = 0;
		//CAPI
		// Credentials with no client cert mapping at all
		//
		((SCHANNEL_CRED*)pcreds)->cMappers = 0;
		((SCHANNEL_CRED*)pcreds)->dwFlags = SCH_CRED_NO_SYSTEM_MAPPER;

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRet = g_AcquireCredentialsHandle(  NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCreds[*pcCred],  // Handle
                                            &tsExpiry );

        PRINTF((buff, "Cred %08x:%08x : mapper %08x\n", phCreds[*pcCred], NULL ));

		//
		// DS mapper only - no mappers passed to AcquireCredentialsHandle(), clear the flag
		// telling Schannel not to use the DS mapper
		//
		if ( pSSLInfoObj->UseDSMapper() )
		{
			((SCHANNEL_CRED*)pcreds)->cMappers = 0;
			((SCHANNEL_CRED*)pcreds)->dwFlags = 0;
//			DBGPRINTF((DBG_CONTEXT,
//					   "[SSPIFILT] Using DS mapper \n"));

		}
		//
		// IIS mappers only - pass mappers to AcquireCredentialsHandle(), set flag in each one
		// indicating that only IIS mappers are to be called, keep flag telling Schannel
		// not to use DS mapper [set to SCH_CRED_NO_SYSTEM_MAPPER above]
		//
		else
		{
			((SCHANNEL_CRED*)pcreds)->cMappers = cNbMappers;
			for ( DWORD dwI = 0; dwI < cNbMappers; dwI++ )
			{
				((SCHANNEL_CRED*)pcreds)->aphMappers[dwI]->m_dwFlags = SCH_FLAG_DEFAULT_MAPPER;

			}
//			DebugTrace(NULL,
//					   "[SSPIFILT] Using IIS mappers \n"));
		}

        //creds.cMappers = cNbMappers;

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRetM = g_AcquireCredentialsHandle( NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCredsMap[*pcCredMap],  // Handle
                                            &tsExpiry );

        //PRINTF((buff, "Cred %08x:%08x : mapper %08x\n", phCredsMap[*pcCredMap], creds.aphMappers ));
        // Null out creds, it doesn't seem to be used
        PRINTF( (buff, "Cred %08x:%08x ", phCredsMap[*pcCredMap] ));

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        if ( !FAILED( scRetM ) && !FAILED( scRet ) )
        {
            *pcCred += 1;
            *pcCredMap += 1;
        }
    }

	if ( xcreds.hRootStore )
	{
		CertCloseStore( xcreds.hRootStore,
						0 );
	}
    //
    // Tell the caller about it.
    //

    if ( !*pcCred && FAILED( scRet ))
    {
        SetLastError( scRet );

        return FALSE;
    }

    return TRUE;
}


BOOL
GetSecretW(
    WCHAR *            pszSecretName,
    UNICODE_STRING * * ppSecretValue
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        ppSecretValue - Receives pointer to secret value.  Memory should be
            freed by calling LsaFreeMemory

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL                  fResult;
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    unicodeSecret.Buffer        = pszSecretName;
    unicodeSecret.Length        = wcslen( pszSecretName ) * sizeof(WCHAR);
    unicodeSecret.MaximumLength = unicodeSecret.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       (PLSA_UNICODE_STRING *) ppSecretValue );

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}   // GetSecretW


BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
	LPVOID      pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    )
/*++
    Description:

        Initialize the cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    HKEY                hKey;
    DWORD               dwType;
    DWORD               cbData;
    BOOL                fSt = TRUE;
    LPSTR               pszMapList = NULL;
    LPSTR               p;
    LPSTR               pDll;
    UINT                cMaxMap;
    PFN_INIT_CERT_MAP   pfnInit;
    HINSTANCE           hInst;
    PMAPPER_VTABLE      pVT;
    DWORD               cNbMappers = 0;
    HMAPPER**           ppMappers = NULL;
    IisMapper*          pIM;

    if ( pCert11 == NULL && pCertW == NULL )
    {
        *pppMappers = NULL;
        *pdwMappers = 0;

        return TRUE;
    }

    //
    // Open reg, count # mappers, allocate array, populate array
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey ) == NO_ERROR )
    {

        if ( RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_SZ &&
             (pszMapList = (LPSTR)LocalAlloc( LMEM_FIXED, cbData )) &&
             RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              (LPBYTE)pszMapList,
                              &cbData ) == ERROR_SUCCESS )
        {
            //
            // Count mappers, allocate structures
            //

            for ( cMaxMap = 1, p = pszMapList ;
                  p = strchr( p, ',' ) ;
                  ++p, ++cMaxMap )
            {
            }

            if ( !(ppMappers = (HMAPPER**)LocalAlloc( LMEM_FIXED,
                    sizeof(HMAPPER*) * cMaxMap )) )
            {
                fSt = FALSE;
                goto cleanup;
            }

            //
            // Load libraries, call init entry point
            //

            for ( pDll = pszMapList, cNbMappers = 0 ;
                  *pDll ;
                )
            {
                p = strchr( pDll, ',' );
                if ( p )
                {
                    *p = '\0';
                }

                if ( (hInst = LoadLibrary( pDll )) )
                {
                    //
                    // Use CreateInstance() entry point if present
                    //

                    if ( (pfnInit = (PFN_INIT_CERT_MAP)GetProcAddress(
                                hInst,
                                SSPIFILT_INIT_MAP )) )
                    {
                        if ( SEC_E_OK != (pfnInit)( (HMAPPER**)&pIM ) )
                        {
                            FreeLibrary( hInst );
                            goto next;
                        }

                        //
                        // Mapper handle its own HMAPPER allocation,
                        // will be freed when refcount drops to zero.
                        // Initial refcount is 1
                        //

                        ppMappers[cNbMappers] = (HMAPPER*)pIM;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
						pIM->pvInfo = pSslInfo;
						//Nimishk : Not sure if this is needed
						pIM->dwInstanceId = dwInstanceId;
                    }
                    else
                    {
                        pIM = (IisMapper*)LocalAlloc( LMEM_FIXED, sizeof(IisMapper) );
                        ppMappers[cNbMappers] = (HMAPPER*)pIM;

                        pIM->hMapper.m_vtable = pVT = &pIM->mvtEntryPoints;
                        pIM->hMapper.m_dwMapperVersion = MAPPER_INTERFACE_VER;
                        pIM->hMapper.m_Reserved1 = NULL;

                        pIM->hInst = hInst;
                        pIM->lRefCount = 0;
                        pIM->fIsIisCompliant = FALSE;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
						pIM->pvInfo = pSslInfo;
                        pIM->dwInstanceId = dwInstanceId;

                        if ( !(pVT->ReferenceMapper
                                = (REF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "ReferenceMapper" )) ||
                             !(pVT->DeReferenceMapper
                                = (DEREF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "DeReferenceMapper" )) ||
                             !(pVT->GetIssuerList
                                = (GET_ISSUER_LIST_FN)GetProcAddress(
                                        hInst,
                                        "GetIssuerList" )) ||
                             !(pVT->GetChallenge
                                = (GET_CHALLENGE_FN)GetProcAddress(
                                        hInst,
                                        "GetChallenge" )) ||
                             !(pVT->MapCredential
                                = (MAP_CREDENTIAL_FN)GetProcAddress(
                                        hInst,
                                        "MapCredential" )) ||
                             !(pVT->GetAccessToken
                                = (GET_ACCESS_TOKEN_FN)GetProcAddress(
                                        hInst,
                                        "GetAccessToken" )) ||
                             !(pVT->CloseLocator
                                = (CLOSE_LOCATOR_FN)GetProcAddress(
                                        hInst,
                                        "CloseLocator" ))
                            )
                        {
                            LocalFree( pIM );
                            FreeLibrary( hInst );
                            goto next;
                        }

						//
                        // optional functions
                        //

                        if ( !(pVT->QueryMappedCredentialAttributes
                                = (QUERY_MAPPED_CREDENTIAL_ATTRIBUTES_FN)GetProcAddress(
                                        hInst,
                                        "QueryMappedCredentialAttributes" )) )
                        {
                            pVT->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;
                        }
                    }

                    //
                    // Valid mapper. Store reference
                    //

                    ++cNbMappers;
                }
next:
                if ( p )
                {
                    pDll = p + 1;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            fSt = FALSE;
        }

        RegCloseKey( hKey );
    }


cleanup:
    if ( fSt == FALSE )
    {
        if ( ppMappers != NULL )
        {
            LocalFree( ppMappers );
        }
    }
    else
    {
        *pppMappers = ppMappers;
        *pdwMappers = cNbMappers;
    }

    if ( pszMapList != NULL )
    {
        LocalFree( pszMapList );
    }

    return fSt;
}


VOID
SetMapperToEmpty(
    UINT        cMappers,
    HMAPPER**   pMappers
    )
/*++
    Description:

        Set ptr to Null mapper ( fail Mapping requests )

    Arguments:

        cMappers - mapper count in pCertMapDlls, pMappers
        pMappers - ptr to array of mappers

    Returns:
        Nothing

--*/
{
    PMAPPER_VTABLE  pTbl;

    while ( cMappers-- )
    {
        if ( (*(IisMapper**)pMappers)->fIsIisCompliant )
        {
            pTbl = (*pMappers)->m_vtable;

            //
            // switch to infocomm-embedded mapper, so we can FreeLibrary the
            // mapper DLL. refcount is decremented, because we now longer
            // have a reference to the HMAPPER struct.
            //

            pTbl->ReferenceMapper = NullReferenceMapper;
            pTbl->DeReferenceMapper = NullDeReferenceMapper;
            pTbl->GetIssuerList = NullGetIssuerList;
            pTbl->GetChallenge = NullGetChallenge;
            pTbl->MapCredential = NullMapCredential;
            pTbl->GetAccessToken = NullGetAccessToken;
            pTbl->CloseLocator = NullCloseLocator;
			pTbl->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;

            if ( (*(IisMapper**)pMappers)->hInst != NULL )
            {
                FreeLibrary( (*(IisMapper**)pMappers)->hInst );
            }

            (pTbl->DeReferenceMapper)( *pMappers );
        }

        ++pMappers;
    }
}


BOOL
TerminateCertMapping(
    HMAPPER** ppMappers,
    DWORD cNbMappers
    )
/*++
    Description:

        Terminate access to cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    //
    // call terminate mapper for all DLLs, FreeLibrary
    //

    if ( ppMappers != NULL )
    {
        SetMapperToEmpty( cNbMappers, ppMappers );
        LocalFree( ppMappers );
    }

    return TRUE;
}


CRED_CACHE_ITEM::~CRED_CACHE_ITEM(
    )
{
    if ( m_fValid )
    {
        DWORD i;

        for ( i = 0; i < m_cCred; i++ )
        {
            g_FreeCredentialsHandle( &m_ahCred[i] );
        }
        for ( i = 0; i < m_cCredMap; i++ )
        {
            g_FreeCredentialsHandle( &m_ahCredMap[i] );
        }

        TerminateCertMapping( m_ppMappers, m_cNbMappers );

        if ( m_pBlob11 )
        {
            m_pBlob11->Release();
        }
        if ( m_pBlobW )
        {
            m_pBlobW->Release();
        }
		if ( m_pSslInfo )
		{
			IIS_SSL_INFO::Release( m_pSslInfo );
		}
    }
}

BOOL
LookupClientCredential(
    IN  WCHAR*  pwszServerPrefix,
    IN  BOOL    fUseCertificate,
    OUT CRED_CACHE_ITEM** ppCCI
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    fUseCertificate - if TRUE, binds client certificate to cred handle
    ppCCI - Receives pointer to a Credential Cache Item

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_INVALID_NAME is returned.

--*/
{
    TimeStamp       tsExpiry;
    DWORD           i, j;
    CredHandle*     phCreds;
    DWORD*          pcCred;
    BOOL            fCertSet = FALSE;
    WCHAR           achSecretName[MAX_SECRET_NAME+1];
    //CHAR            achSecretNameA[MAX_SECRET_NAME+1];
    UNICODE_STRING* SecretValue[3];
    PVOID           pvPublicKey;
    DWORD           cbPublicKey;
    PVOID           pvPrivateKey;
    DWORD           cbPrivateKey;
    CHAR *          pszPassword;
    SCH_CRED                    creds;
    SCH_CRED_SECRET_PRIVKEY     scsp;
    SCH_CRED_PUBLIC_CERTCHAIN   scpc;
    SECURITY_STATUS             scRet;
    //SECURITY_STATUS             scRetM;
    LPVOID                      ascsp[1];
    LPVOID                      ascpc[1];

    //TraceFunctEnter( "LookupClientCredential" );

    *ppCCI = NULL;

    //
    // first time thru allocate the single cache entry
    //
    if ( g_pcciClient == NULL )
    {
        g_pcciClient = new CRED_CACHE_ITEM;

        if ( g_pcciClient == NULL )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }


        //pcciClient->m_cbAddr = 0;

        g_pcciClient->m_cCred  = 0;
        g_pcciClient->m_cCredMap = 0;
        g_pcciClient->m_fValid = FALSE;
        g_pcciClient->m_cNbMappers = 0;
        g_pcciClient->m_ppMappers = NULL;
        g_pcciClient->m_pBlob11 = NULL;
        g_pcciClient->m_pBlobW = NULL;

        memset( g_pcciClient->m_ahCred, 0, sizeof( g_pcciClient->m_ahCred ));
        memset( g_pcciClient->m_ahCredMap, 0, sizeof( g_pcciClient->m_ahCredMap ));
        memset( g_pcciClient->m_acbTrailer, 0, sizeof( g_pcciClient->m_acbTrailer ));
        memset( g_pcciClient->m_acbHeader, 0, sizeof( g_pcciClient->m_acbHeader ));
        memset( g_pcciClient->m_acbBlockSize, 0, sizeof( g_pcciClient->m_acbBlockSize ));

        //
        // only the provider name is required for OUTBOUND connections
        //

        phCreds = g_pcciClient->m_ahCred;
        pcCred = &g_pcciClient->m_cCred;
        memset( SecretValue, 0, sizeof( SecretValue ));

        if( fUseCertificate )
        {
            //
            // get certificate from metabase and fill in SCH_CRED struct
            //

            //
            // Try the 4 possible secret names
            //

            for ( j = 0 ; j < 4 ; ++j )
            {
                wsprintfW(  achSecretName,
                            SecretTableW[j],
                            L"127.0.0.1", L"563" );

                if ( GetAdminSecret( pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_PUBLIC_KEY,
                                     &SecretValue[0] ) &&
                    GetAdminSecret(  pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_PRIVATE_KEY,
                                     &SecretValue[1] ) &&
                    GetAdminSecret(  pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_KEY_PASSWORD,
                                     &SecretValue[2] ) )
                {
                    fCertSet = TRUE;
                    pvPublicKey  = SecretValue[0]->Buffer;
                    cbPublicKey  = SecretValue[0]->Length;
                    pvPrivateKey = SecretValue[1]->Buffer;
                    cbPrivateKey = SecretValue[1]->Length;
                    pszPassword  = (char*) SecretValue[2]->Buffer;
                    break;
                }
            }

            if( fCertSet )
            {
                //*pcCred             = 0;
                scsp.dwType         = SCHANNEL_SECRET_PRIVKEY;
                scsp.pPrivateKey    = ((PBYTE)pvPrivateKey);
                scsp.cbPrivateKey   = cbPrivateKey;
                scsp.pszPassword    = pszPassword;

                scpc.dwType         = SCH_CRED_X509_CERTCHAIN;
                scpc.cbCertChain    = cbPublicKey - CERT_DER_PREFIX;
                scpc.pCertChain     = ((PBYTE) pvPublicKey) + CERT_DER_PREFIX;

                creds.dwVersion     = SCH_CRED_VERSION;
                ascsp[0]            = (LPVOID)&scsp;
                ascpc[0]            = (LPVOID)&scpc;
                creds.paSecret      = (LPVOID*)&ascsp;
                creds.paPublic      = (LPVOID*)&ascpc;
                creds.cCreds        = 1;
                creds.cMappers      = 0;
            }
        }

        for ( i = 0; pEncProviders[i].pszName && i < MAX_PROVIDERS; i++ )
        {
            if ( !pEncProviders[i].fEnabled )
            {
                //DebugTrace( 0, "%s disabled", EncProviders[i].pszName );
                continue;
            }

            scRet = g_AcquireCredentialsHandle( NULL,                       // My name (ignored)
                                                pEncProviders[i].pszName,   // Package
                                                SECPKG_CRED_OUTBOUND,       // Use
                                                NULL,                       // Logon Id (ign.)
                                                fCertSet ? &creds : NULL,   // auth data
                                                NULL,                       // dce-stuff
                                                NULL,                       // dce-stuff
                                                &phCreds[*pcCred],          // Handle
                                                &tsExpiry );

            if ( !FAILED( scRet ))
            {
                //DebugTrace( 0, "%s credential: 0x%08X",
                //          EncProviders[i].pszName,
                //          phCreds[*pcCred] );

                *pcCred += 1;
            }
        }

        if( fCertSet )
        {
            //
            // Zero out and free the key data memory, on success or fail
            //

            ZeroMemory( scsp.pPrivateKey, scsp.cbPrivateKey );
            ZeroMemory( scpc.pCertChain, scpc.cbCertChain );
            ZeroMemory( pszPassword, strlen( pszPassword ));
        }

        for ( i = 0; i < 3; i++ )
        {
            if( SecretValue[i] != NULL )
            {
                LocalFree( SecretValue[i]->Buffer );
                LocalFree( SecretValue[i] );
            }
        }

        //
        // Tell the caller about it.
        //

        if ( !*pcCred && FAILED( scRet ))
        {
            SetLastError( scRet );
            return FALSE;
        }
        else
        {
            g_pcciClient->m_fValid = TRUE;
            g_pcciClient->AddRef();
            *ppCCI = g_pcciClient;
            return TRUE;
        }
    }
    else if ( g_pcciClient->m_fValid == FALSE )
    {
        //
        // cache was allocated but the initialization failed
        //
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }
    else
    {
        //
        // cache was successfully allocated and initialized on a previous call
        //
        g_pcciClient->AddRef();
        *ppCCI = g_pcciClient;
        return TRUE;
    }
}

BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob )
/*++

   Description

       Function called to get blob of data that uniquely identifies this set of SSL info

   Arguments:

        pSSLInfoObj - object containing SSL info to be used to generate the blob
        pbBlob - buffer that gets updated with blob

   Returns:

        True on success, FALSE on failure

--*/
{
    //
    // If we haven't loaded the info yet, do so now
    //
    IIS_SERVER_CERT *pCert = pSSLInfoObj->GetCertificate();

    IIS_CTL *pCTL = pSSLInfoObj->GetCTL();

    //
    // Definitely need a certificate
    //
    if ( !pCert || !pCert->IsValid())
    {
        return FALSE;
    }

    DWORD dwSize = MAX_SSL_ID_LEN;
    PBYTE pbCurrent = pbBlob;

    //
    // Clear out old crud
    //
    memset( pbBlob, 0, MAX_SSL_ID_LEN );

    //
    //Try to get the cert hash
    //
	if ( !CertGetCertificateContextProperty( pCert->QueryCertContext(),
                                             CERT_SHA1_HASH_PROP_ID,
                                             (PVOID) pbCurrent,
                                             &dwSize ) )
    {
        return FALSE;
    }

    ASSERT( dwSize == SHA1_HASH_LEN );

    pbCurrent += dwSize;
    dwSize = MAX_SSL_ID_LEN - dwSize - 1;


    //
    // Get and append the CTL hash, if there is one
    //
    if (  pCTL && pCTL->IsValid() )
    {
        if ( !CertGetCTLContextProperty( pCTL->QueryCTLContext(),
                                         CERT_SHA1_HASH_PROP_ID,
                                         (PVOID) pbCurrent,
                                         &dwSize ) )
        {
            return FALSE;
        }

        ASSERT( dwSize == SHA1_HASH_LEN );

        pbBlob[SHA1_HASH_LEN] = ':';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\simssl2\simssl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    security.cpp

Abstract:

    This module contains definition for the CSecurityCtx class.

Author:

    Johnson Apacible (JohnsonA)     18-Sept-1995

Revision History:

--*/

#if !defined(dllexp)
#define dllexp  __declspec( dllexport )
#endif  // !defined( dllexp )
/*
#include <dbgutil.h>
#include <tcpdll.hxx>
#include <tcpsvcs.h>
#include <tcpdebug.h>
#include <tsvcinfo.hxx>
#include <inetdata.h>
*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>
#include <dbgtrace.h>

#include <inetinfo.h>
//
// SSL and SSPI related include files
//

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <iadm.h>
#include <mb.hxx>

#define DEFINE_SIMSSL_GLOBAL

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
#include <ntsecapi.h>
#include <spseal.h>
//#include <sslsp.h>
#include <schnlsp.h>
#include ".\credcach.hxx"
}

#include <certnotf.hxx>
//#include "sslmsgs.h"

#include "simssl2.h"

#define CORE_SSL_KEY_LIST_SECRET      L"%S_KEY_LIST"



//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );



#define MAX_SECRET_NAME       255
#define MAX_ADDRESS_LEN       64

typedef VOID (WINAPI FAR *PFN_SCHANNEL_INVALIDATE_CACHE)(
    VOID
);

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );

//
//  The list of encryption packages we support.  PCT goes first since it's a
//  superset of SSL
//

struct _ENC_PROVIDER EncProviders[] =
{
    UNISP_NAME_W,  ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W, ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W, ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W, ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};


struct _ENC_PROVIDER EncLsaProviders[] =
{
    UNISP_NAME_W L" X",     ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W L" X",    ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};

struct _ENC_PROVIDER*   pEncProviders = EncProviders;

//
// service specific string names
//

WCHAR       CEncryptCtx::wszServiceName[16];
//char      CEncryptCtx::szLsaPrefix[16];
BOOL        CEncryptCtx::m_IsSecureCapable = FALSE;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE   CEncryptCtx::m_hSecurity = NULL;
HINSTANCE   CEncryptCtx::m_hLsa = NULL;
PVOID       CEncryptCtx::m_psmcMapContext = NULL;

//
// g_pSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTableW g_pSecFuncTableW = NULL;
HINSTANCE g_hSchannel = NULL;
//
// NB : Under NT 5, the SslEmptyCache function is no longer supported
//
PFN_SCHANNEL_INVALIDATE_CACHE g_pfnFlushSchannelCache = NULL;

#if 0
LSAOPENPOLICY           g_LsaOpenPolicy = NULL;
LSARETRIEVEPRIVATEDATA  g_LsaRetrievePrivateData = NULL;
LSACLOSE                g_LsaClose = NULL;
LSANTSTATUSTOWINERROR   g_LsaNtStatusToWinError = NULL;
LSAFREEMEMORY           g_LsaFreeMemory = NULL;
#endif

VOID
AsciiStringToUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        )
{
    while ( (*UnicodeString++ = (WCHAR)*AsciiString++) != (WCHAR)'\0');

} // AsciiStringToUnicode

BOOL
CEncryptCtx::Initialize(
            LPSTR       pszServiceName,
            IMDCOM*     pImdcom,
            PVOID       psmcMapContext,
            PVOID       pvAdminBase
            //LPSTR     pszLsaPrefix
            )
/*++

Routine Description:

    Activates the security package

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("CEncryptCtx::Initialize")

    BOOL            fSuccess = FALSE;
    DWORD           cb;
    SECURITY_STATUS ss;
    PSecPkgInfoW    pPackageInfo = NULL;
    ULONG           cPackages;
    ULONG           i;
    ULONG           fCaps;
    DWORD           dwEncFlags = ENC_CAPS_DEFAULT;
    DWORD           cProviders = 0;
#if 0
    UNICODE_STRING* punitmp;
    WCHAR           achSecretName[MAX_SECRET_NAME+1];
#endif
    OSVERSIONINFO   os;
    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)psmcMapContext;

    extern  IMDCOM* pMDObject ;
    extern  IMSAdminBaseW* pAdminObject ;

    pMDObject = pImdcom ;
    m_psmcMapContext = psmcMapContext ;
    pAdminObject = (IMSAdminBaseW*)pvAdminBase ;

    //
    // deal with different security packages DLL on different platforms
    //

    INITSECURITYINTERFACE pfInitSecurityInterfaceW = NULL;

    _ASSERT( m_hSecurity == NULL );
    _ASSERT( m_hLsa == NULL );

    //
    // load dll.
    //

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    _VERIFY( GetVersionEx( &os ) );

    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
        m_hSecurity = LoadLibrary("security");
    }
    else
    {
        m_hSecurity = LoadLibrary("secur32");
    }

    if ( m_hSecurity == NULL )
    {
        ErrorTrace( 0, "LoadLibrary failed: %d", GetLastError() );
        goto quit;
    }

    //
    // only on NT get the LSA function pointers
    //
    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
#if 0
        m_hLsa = LoadLibrary("advapi32");
        if ( m_hLsa == NULL )
        {
            ErrorTrace( 0, "LoadLibrary ADVAPI32 failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaOpenPolicy = (LSAOPENPOLICY)
                        GetProcAddress( m_hLsa, "LsaOpenPolicy" );

        if ( g_LsaOpenPolicy == NULL )
        {
            ErrorTrace( 0, "LsaOpenPolicy GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaRetrievePrivateData = (LSARETRIEVEPRIVATEDATA)
                        GetProcAddress( m_hLsa, "LsaRetrievePrivateData" );

        if ( g_LsaRetrievePrivateData == NULL )
        {
            ErrorTrace( 0, "LsaRetrievePrivateData GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaClose = (LSACLOSE)
                        GetProcAddress( m_hLsa, "LsaClose" );

        if ( g_LsaClose == NULL )
        {
            ErrorTrace( 0, "LsaClose GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaNtStatusToWinError = (LSANTSTATUSTOWINERROR)
                        GetProcAddress( m_hLsa, "LsaNtStatusToWinError" );

        if ( g_LsaNtStatusToWinError == NULL )
        {
            ErrorTrace( 0, "LsaNtStatusToWinError GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaFreeMemory = (LSAFREEMEMORY)
                        GetProcAddress( m_hLsa, "LsaFreeMemory" );

        if ( g_LsaFreeMemory == NULL )
        {
            ErrorTrace( 0, "LsaFreeMemory GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }
#endif
    }
    //
    // get function addresses for ansi entries.
    //

    pfInitSecurityInterfaceW = (INITSECURITYINTERFACE)
                                GetProcAddress( m_hSecurity, SECURITY_ENTRYPOINTW );

    if ( pfInitSecurityInterfaceW == NULL )
    {
        ErrorTrace( 0, "GetProcAddress failed: %d", GetLastError() );
        goto quit;
    }

    g_pSecFuncTableW = (SecurityFunctionTableW*)((*pfInitSecurityInterfaceW)());

    if ( g_pSecFuncTableW == NULL )
    {
        ErrorTrace( 0, "SecurityFunctionTable failed: %d", GetLastError() );
        goto quit;
    }

    //
    // Initialize cached credential data
    //

    InitializeCriticalSection( &csGlobalLock );
    InitCredCache();
    if ( g_hSchannel = LoadLibrary( "schannel.dll" ) )
    {
        g_pfnFlushSchannelCache = (PFN_SCHANNEL_INVALIDATE_CACHE)GetProcAddress(
                    g_hSchannel, "SslEmptyCache" );
    }

    //
    // Client implementations do not require Lsa secrets
    //

    if ( pszServiceName )
    {
        cb = lstrlen( pszServiceName ) + 1;
        if ( cb*2 > sizeof( wszServiceName ) )
        {
            ErrorTrace( 0, "szServiceName too long" );
            goto quit;
        }
        //CopyMemory( szServiceName, pszServiceName, cb );
        AsciiStringToUnicode( wszServiceName, pszServiceName );
    }


#if 0
    if ( pszLsaPrefix )
    {
        cb = lstrlen( pszLsaPrefix ) + 1;
        if ( cb > sizeof( szLsaPrefix ) )
        {
            ErrorTrace( 0, "szLsaPrefix too long" );
            goto quit;
        }
        CopyMemory( szLsaPrefix, pszLsaPrefix, cb );
    }
#endif


    //
    //  Get the list of security packages on this machine
    //

    ss = g_EnumerateSecurityPackages( &cPackages, &pPackageInfo );

    if ( ss != STATUS_SUCCESS )
    {
        ErrorTrace( 0, "g_EnumerateSecurityPackages failed: 0x%08X", ss );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto quit;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  We'll only use the security package if it supports connection
        //  oriented security and it supports the appropriate side (client
        //  or server)
        //

        fCaps = pPackageInfo[i].fCapabilities;

        if ( fCaps & SECPKG_FLAG_STREAM )
        {
            if ( fCaps & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCaps & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Does it match one of our known packages and are we configured
            //  to use it?
            //

            for ( int j = 0; pEncProviders[j].pszName != NULL; j++ )
            {
                if ( !wcscmp( pPackageInfo[i].Name, pEncProviders[j].pszName ) &&
                     pEncProviders[j].dwFlags & dwEncFlags )
                {
                    pEncProviders[j].fEnabled = TRUE;
                    cProviders++;
                }
            }
        }
    }

    g_FreeContextBuffer( pPackageInfo );

    if ( !cProviders )
    {
        //
        //  The package wasn't found, fail this filter's load
        //

        ErrorTrace( 0, "No security packages were found" );
        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        //
        // not a fatal error
        //
        fSuccess = TRUE;
        goto quit;
    }

#if 0
    //
    //  The package is installed.  Check to see if there are any keys
    //  installed
    //

    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT && pszLsaPrefix )
    {
        wsprintfW(  achSecretName,
                    CORE_SSL_KEY_LIST_SECRET,
                    szLsaPrefix );

        if ( !GetSecretW( achSecretName, &punitmp ) )
        {
            ErrorTrace( 0, "GetSecretW returned error %d", GetLastError() );

            //
            //  Looks like no secrets are installed, fail to load, don't log an
            //  event
            //

            SetLastError( NO_ERROR );

            //
            // not a fatal error
            //
            fSuccess = TRUE;
            goto quit;
        }
        g_LsaFreeMemory( punitmp );
    }
#endif

    if ( psmc )
    {
        if (!psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED ))
            {
                _ASSERT( FALSE );
                fSuccess = FALSE;
                goto quit;
            }
    }

    //
    // if we got here everything is cool for secure communications
    //
    fSuccess = m_IsSecureCapable = TRUE;

quit:
    if ( fSuccess == FALSE )
    {
        if ( m_hSecurity != NULL )
        {
            FreeLibrary( m_hSecurity );
            m_hSecurity = NULL;
        }

        if ( m_hLsa != NULL )
        {
            FreeLibrary( m_hLsa );
            m_hLsa = NULL;
        }
    }

    LEAVE

    return  fSuccess;

} // Initialize

VOID
CEncryptCtx::Terminate(
            VOID
            )
/*++

Routine Description:

    Terminates the security package

Arguments:

    None.

Return Value:

    None.

--*/
{

    ENTER("CEncryptCtx::Terminate")

    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)m_psmcMapContext;

    //
    // Close cached credential handles
    //

    FreeCredCache();

    //
    // NB : Under NT 5, the SslEmptyCache function is no longer supported
    //
#if 0
    if ( g_pfnFlushSchannelCache )
    {
        (g_pfnFlushSchannelCache)();
    }
#endif

    if ( g_hSchannel )
    {
        FreeLibrary( g_hSchannel );
    }

    if ( psmc )
    {
        if (!psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED ))
            {
                _ASSERT( FALSE );
            }
    }

    DeleteCriticalSection( &csGlobalLock );

    if ( m_hSecurity != NULL )
    {
        FreeLibrary( m_hSecurity );
        m_hSecurity = NULL;
    }

    if ( m_hLsa != NULL )
    {
        FreeLibrary( m_hLsa );
        m_hLsa = NULL;
    }

    LEAVE
    return;

} // Terminate


CEncryptCtx::CEncryptCtx( BOOL IsClient, DWORD dwSslAccessPerms ) :
    m_IsClient( IsClient ),
    m_haveSSLCtxtHandle( FALSE ),
    m_cbSealHeaderSize( 0 ),
    m_cbSealTrailerSize( 0 ),
    m_IsAuthenticated( FALSE ),
    m_IsNewSSLSession( TRUE ),
    m_IsEncrypted( FALSE ),
    m_phCredInUse( NULL ),
    m_iCredInUse( 0 ),
    m_phCreds( NULL ),
    m_dwSslAccessPerms( dwSslAccessPerms ),
    m_hSSPToken( NULL ),
    m_dwKeySize( 0 )


/*++

Routine Description:

    Class constructor

Arguments:

    None.

Return Value:

    None

--*/
{

    ZeroMemory( (PVOID)&m_hSealCtxt, sizeof(m_hSealCtxt) );

} // CEncryptCtx




CEncryptCtx::~CEncryptCtx(
                VOID
                )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
    Reset();

} // ~CEncryptCtx




VOID
CEncryptCtx::Reset(
                VOID
                )
/*++

Routine Description:

    resets the instance to reauth user

Arguments:

    None.

Return Value:

    None

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::Reset" );

    m_cbSealHeaderSize = 0;
    m_cbSealTrailerSize = 0;
    m_IsAuthenticated = FALSE;
    m_IsNewSSLSession = TRUE;
    m_IsEncrypted = FALSE;
    m_phCredInUse = NULL;
    m_iCredInUse = 0;

    if ( m_haveSSLCtxtHandle == TRUE )
    {
        g_DeleteSecurityContext( &m_hSealCtxt );
        m_haveSSLCtxtHandle = FALSE;
    }

    ZeroMemory( (PVOID)&m_hSealCtxt, sizeof(m_hSealCtxt) );

    //mikeswa 4/1/99
    //According to JBanes, it is not legal to Free the credentials
    //handle before deleting the associated security context.
    //Moving release to after delete just in case this is the
    //final release.
    if (m_phCreds != NULL) {
        ((CRED_CACHE_ITEM *) m_phCreds)->Release();
    }
    m_phCreds = NULL;

    //
    //  Close the NT token obtained during cert mapping
    //

    if( m_hSSPToken )
    {
        _ASSERT( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT );
        _VERIFY( CloseHandle( m_hSSPToken ) );
        m_hSSPToken = NULL;
    }

} // ~CEncryptCtx





BOOL
CEncryptCtx::SealMessage(
                IN LPBYTE Message,
                IN DWORD cbMessage,
                OUT LPBYTE pBuffOut,
                OUT DWORD  *pcbBuffOut
                )
/*++

Routine Description:

    Encrypt message

Arguments:

    Message - message to be encrypted
    cbMessage - size of message to be encrypted

Return Value:

    Status of operation

--*/
{
    SECURITY_STATUS ss = ERROR_NOT_SUPPORTED;
    SecBufferDesc   inputBuffer;
    SecBuffer       inBuffers[3];
    DWORD           encryptedLength;
    DWORD           iBuff = 0;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::SealMessage");

    if ( m_haveSSLCtxtHandle ) {

        encryptedLength = cbMessage + GetSealHeaderSize() + GetSealTrailerSize();

        DebugTrace( (LPARAM)this,
                    "InBuf: 0x%08X, OutBuf: 0x%08X, in: %d, max: %d, out: %d",
                    Message, pBuffOut, cbMessage,
                    *pcbBuffOut, encryptedLength );

        //
        // don't do the MoveMemory if the app is SSL/PCT buffer aware
        //

        if ( Message != pBuffOut + GetSealHeaderSize() )
        {
            MoveMemory( pBuffOut + GetSealHeaderSize(),
                        Message,
                        cbMessage );
        }

        if ( GetSealHeaderSize() )
        {
            inBuffers[iBuff].pvBuffer = pBuffOut;
            inBuffers[iBuff].cbBuffer = GetSealHeaderSize();
            inBuffers[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }

        inBuffers[iBuff].pvBuffer = pBuffOut + GetSealHeaderSize();
        inBuffers[iBuff].cbBuffer = cbMessage;
        inBuffers[iBuff].BufferType = SECBUFFER_DATA;

        iBuff++;

        if ( GetSealTrailerSize() )
        {
            inBuffers[iBuff].pvBuffer = pBuffOut + GetSealHeaderSize() + cbMessage;
            inBuffers[iBuff].cbBuffer = GetSealTrailerSize();
            inBuffers[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }

        inputBuffer.cBuffers = iBuff;
        inputBuffer.pBuffers = inBuffers;
        inputBuffer.ulVersion = SECBUFFER_VERSION;

        ss = g_SealMessage(
                &m_hSealCtxt,
                0,
                &inputBuffer,
                0
                );

        *pcbBuffOut = encryptedLength;

        DebugTrace( (LPARAM)this, "SealMessage returned: %d, 0x%08X", ss, ss );
    }

    SetLastError(ss);
    return (ss == STATUS_SUCCESS);

} // SealMessage



BOOL
CEncryptCtx::UnsealMessage(
                IN LPBYTE Message,
                IN DWORD cbMessage,
                OUT LPBYTE *DecryptedMessage,
                OUT PDWORD DecryptedMessageSize,
                OUT PDWORD ExpectedMessageSize,
                OUT LPBYTE *NextSealMessage
                )
/*++

Routine Description:

    Decrypt message

Arguments:

    Message - message to be encrypted
    cbMessage - size of message to be encrypted

Return Value:

    Status of operation

--*/
{

    SECURITY_STATUS ss;
    SecBufferDesc   inputBuffer;
    SecBuffer       inBuffers[4];
    DWORD qOP;

    //
    // if the app wants to know the start of the next seal msg init to NULL
    //
    if ( NextSealMessage != NULL )
    {
        *NextSealMessage = NULL;
    }


    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::UnsealMessage");

    DebugTrace( (LPARAM)this,
                "initial ptr: 0x%08X, count: %d",
                Message, cbMessage );

    if ( m_haveSSLCtxtHandle ) {

        inBuffers[0].pvBuffer = Message;
        inBuffers[0].cbBuffer = cbMessage;
        inBuffers[0].BufferType = SECBUFFER_DATA;

        inBuffers[1].pvBuffer = NULL;
        inBuffers[1].cbBuffer = 0;
        inBuffers[1].BufferType = SECBUFFER_EMPTY;

        inBuffers[2].pvBuffer = NULL;
        inBuffers[2].cbBuffer = 0;
        inBuffers[2].BufferType = SECBUFFER_EMPTY;

        inBuffers[3].pvBuffer = NULL;
        inBuffers[3].cbBuffer = 0;
        inBuffers[3].BufferType = SECBUFFER_EMPTY;

        //
        // one for the data and one for the head and/or tail
        //
        inputBuffer.cBuffers = 4;
//      if ( GetSealHeaderSize() )  inputBuffer.cBuffers++;
//      if ( GetSealTrailerSize() ) inputBuffer.cBuffers++;
//      if ( NextSealMessage )      inputBuffer.cBuffers++;

        inputBuffer.pBuffers = inBuffers;
        inputBuffer.ulVersion = SECBUFFER_VERSION;

        ss = g_UnsealMessage(
                &m_hSealCtxt,
                &inputBuffer,
                0,
                &qOP
                );

        if(ss == SEC_I_RENEGOTIATE)
        {
            //
            // We do not support renegotiation. Renegotiation makes no sense
            // in the context of an SMTP/NNTP client - because there should be
            // no need to change TLS session parameters in mid-stream. Only
            // applications that require different security-levels for different
            // transactions within the same session have use for renegotiation.
            //

            SetLastError(ss);
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        if ( NT_SUCCESS(ss) )
        {
            for (DWORD i=0;i<inputBuffer.cBuffers;i++)
            {
                if ( inBuffers[i].BufferType == SECBUFFER_DATA )
                {
                    *DecryptedMessage = (LPBYTE)inBuffers[i].pvBuffer;
                    *DecryptedMessageSize = inBuffers[i].cbBuffer;

                    DebugTrace( (LPARAM)this,
                                "unsealed ptr: 0x%08X, count: %d",
                                *DecryptedMessage, *DecryptedMessageSize );

                    //
                    // if the app wants to know the start of the next seal msg
                    //
                    if ( NextSealMessage != NULL )
                    {
                        for ( ;i<inputBuffer.cBuffers;i++ )
                        {
                            if ( inBuffers[i].BufferType == SECBUFFER_EXTRA )
                            {
                                *NextSealMessage = (LPBYTE)inBuffers[i].pvBuffer;
                                DebugTrace( (LPARAM)this,
                                            "Found extra buffer: 0x%08X",
                                            *NextSealMessage );
                                break;
                            }
                        }
                    }

                    return  TRUE;
                }
            }
            return  FALSE;
        }
        else if( ss == SEC_E_INCOMPLETE_MESSAGE )
        {
            for( DWORD i=0; i<inputBuffer.cBuffers;i++ )
            {
                if( inBuffers[i].BufferType == SECBUFFER_MISSING )
                {
                    *ExpectedMessageSize = inBuffers[i].cbBuffer;
                }
            }
        }
        SetLastError(ss);
    }
    return  FALSE;
} // UnsealMessage


//
// set this define to allow schannel to allocate responses in InitializeSecurityContext
//
#define SSPI_ALLOCATE_MEMORY


DWORD
CEncryptCtx::EncryptConverse(
                IN PVOID        InBuffer,
                IN DWORD        InBufferSize,
                OUT LPBYTE      OutBuffer,
                IN OUT PDWORD   OutBufferSize,
                OUT PBOOL       MoreBlobsExpected,
                IN CredHandle*  pCredHandle,
                OUT PULONG      pcbExtra
                )
{
/*++

Routine Description:

    Internal private routine for attempting to use a given protocol

Arguments:

  InBuffer: ptr to apps input buffer
  InBufferSize: count of input buffer
  OutBuffer: ptr to apps output buffer
  OutBuffer: ptr to apps max size of output buffer and resultant output count
  MoreBlobsExpected: expect more data from the client ?
  pCredHandle: ptr to the credential handle to use
  pcbExtra: Sometimes, even after the handshake succeeds, all the data in InBuffer
    may not be used up. This is because the other side may have started sending
    non-handshake (application) data. The param returns the length of this unprocessed
    "tail" which should be processed using Decrypt functions.

Return Value:

  TRUE if negotiation succeeded.
  FALSE if negotiation failed.

--*/
    SECURITY_STATUS     ss;
    DWORD               error = NO_ERROR;
    SecBufferDesc       inBuffDesc;
    SecBuffer           inSecBuff[2];
    SecBufferDesc       outBuffDesc;
    SecBuffer           outSecBuff;
    PCtxtHandle         pCtxtHandle;
    DWORD               contextAttributes = 0 ;
    TimeStamp           lifeTime;
    DWORD               dwMaxBuffer = *OutBufferSize;
    SECURITY_STATUS     sc;
    SECURITY_STATUS     scR;
    HANDLE              hSSPToken = NULL;
    PCCERT_CONTEXT pClientCert = NULL;

    // Init vars used to check/return the number of bytes unprocessed by SSL handshake
    _ASSERT (pcbExtra);
    inSecBuff[1].BufferType = SECBUFFER_EMPTY;
    *pcbExtra = 0;

    BOOL                fCert = TRUE;
    SecPkgContext_StreamSizes   sizes;
#ifdef DEBUG
    SecPkgContext_ProtoInfo spcPInfo;
    SECURITY_STATUS     ssProto;
#endif
    SecPkgContext_KeyInfo spcKInfo;
    SECURITY_STATUS     ssInfo;

    //
    // See if we have enough data
    //

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::EncryptConverse");

    pCtxtHandle = &m_hSealCtxt;

    _ASSERT(OutBuffer != NULL && "Must pass in an OutBuffer");
    if(NULL == OutBuffer) {
        ss = E_INVALIDARG;
        goto error_exit;
    }

ScanNextPacket:
    outBuffDesc.ulVersion = 0;
    outBuffDesc.cBuffers  = 1;
    outBuffDesc.pBuffers  = &outSecBuff;

    //
    // need to set cbBuffer to zero because sslsspi will leave it
    // uninitialized when the converse completes
    //
    outSecBuff.cbBuffer   = dwMaxBuffer;
    outSecBuff.BufferType = SECBUFFER_TOKEN;
    outSecBuff.pvBuffer   = OutBuffer;

    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    if ( ARGUMENT_PRESENT(InBuffer) )
    {
        inBuffDesc.ulVersion = 0;
        inBuffDesc.cBuffers  = 2;
        inBuffDesc.pBuffers  = &inSecBuff[0];

        inSecBuff[0].cbBuffer   = InBufferSize;
        inSecBuff[0].BufferType = SECBUFFER_TOKEN;
        inSecBuff[0].pvBuffer   = InBuffer;

        inSecBuff[1].cbBuffer   = 0;
        inSecBuff[1].BufferType = SECBUFFER_EMPTY;
        inSecBuff[1].pvBuffer   = NULL;
    }

    if ( m_IsClient ) {

        DWORD   contextAttributes;
        LPVOID  pvBuffer;
        DWORD   cbBuffer;

        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

#ifdef SSPI_ALLOCATE_MEMORY
        pvBuffer = outSecBuff.pvBuffer;
        cbBuffer = outSecBuff.cbBuffer;

        outSecBuff.pvBuffer = NULL;
        outSecBuff.cbBuffer = 0;
#endif

        DWORD dwIscReq =    ISC_REQ_STREAM |
                            ISC_REQ_SEQUENCE_DETECT |
                            ISC_REQ_REPLAY_DETECT   |
                            ISC_REQ_EXTENDED_ERROR  |
                            ISC_REQ_MANUAL_CRED_VALIDATION |  // to remove implicit call to WinVerifyTRust
#ifdef SSPI_ALLOCATE_MEMORY
                            ISC_REQ_ALLOCATE_MEMORY |
#endif
                            ISC_REQ_CONFIDENTIALITY;

        if( ( m_dwSslAccessPerms & MD_ACCESS_NEGO_CERT )   ||
            ( m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) ||
            ( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT )  ) {
            dwIscReq |= ISC_REQ_MUTUAL_AUTH;
        }

        if (m_IsNewSSLSession) {
            dwIscReq |= ISC_REQ_USE_SUPPLIED_CREDS;
        }

        ss = g_InitializeSecurityContext(
                                    pCredHandle,
                                    m_IsNewSSLSession ? NULL : pCtxtHandle,
                                    wszServiceName,
                                    dwIscReq,
                                    0,
                                    SECURITY_NATIVE_DREP,
                                    m_IsNewSSLSession ? NULL : &inBuffDesc,
                                    0,
                                    pCtxtHandle,
                                    &outBuffDesc,
                                    &contextAttributes,
                                    &lifeTime
                                    );

#ifdef SSPI_ALLOCATE_MEMORY
        if ( NT_SUCCESS( ss ) && outSecBuff.pvBuffer )
        {
            DebugTrace( (LPARAM)this,
                        "Output %d bytes, Maximum %d bytes",
                        outSecBuff.cbBuffer,
                        cbBuffer );

            if ( outSecBuff.cbBuffer <= cbBuffer )
            {
                CopyMemory( pvBuffer, outSecBuff.pvBuffer, outSecBuff.cbBuffer );
            }
            else
            {
                ss = SEC_E_INSUFFICIENT_MEMORY;
            }

            g_FreeContextBuffer( outSecBuff.pvBuffer );
        }
#endif

    } else {

        //
        //  This is the server side
        //

        DWORD dwAscReq = ASC_REQ_STREAM |
                         ASC_REQ_CONFIDENTIALITY |
                         ASC_REQ_EXTENDED_ERROR  |
                         ASC_REQ_SEQUENCE_DETECT |
                         ASC_REQ_REPLAY_DETECT;

        //
        //  Set the mutual auth attribute if we are configured
        //  to negotiate, require or map client certs
        //

        if( ( m_dwSslAccessPerms & MD_ACCESS_NEGO_CERT )   ||
            ( m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) ||
            ( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT )  ) {
            dwAscReq |= ASC_REQ_MUTUAL_AUTH;
        }

        ss = g_AcceptSecurityContext(
                                pCredHandle,
                                m_IsNewSSLSession ? NULL : pCtxtHandle,
                                &inBuffDesc,
                                dwAscReq,
                                SECURITY_NATIVE_DREP,
                                pCtxtHandle,
                                &outBuffDesc,
                                &contextAttributes,
                                &lifeTime
                                );

        DebugTrace((LPARAM)this,
            "AcceptSecurityContext returned win32 error %d (%x)",
            ss, ss);

        if( outSecBuff.pvBuffer != OutBuffer && outSecBuff.cbBuffer ) {
            //
            //  SSPI workaround - if the buffer got allocated by SSPI
            //  copy it over and free it..
            //

            if ( outSecBuff.cbBuffer <= dwMaxBuffer )
            {
                CopyMemory( OutBuffer, outSecBuff.pvBuffer, outSecBuff.cbBuffer );
            }
            else
            {
                ss = SEC_E_INSUFFICIENT_MEMORY;
            }

            g_FreeContextBuffer( outSecBuff.pvBuffer );
        }

    }

    //
    //  Negotiation succeeded, there is extra stuff left in the buffer
    //  Return the number of the unused bytes.
    //
    if( ss == SEC_E_OK && inSecBuff[1].BufferType == SECBUFFER_EXTRA ) {
        *pcbExtra = inSecBuff[1].cbBuffer;

    } else if( ss == SEC_I_CONTINUE_NEEDED && inBuffDesc.pBuffers[1].cbBuffer ) {
        //
        //  Need to process next SSL packet by calling Init/AcceptSecurityContext again
        //  Should ASSERT that InBuffer <= OrigInBuffer + OrigInBufferSize
        //
        _ASSERT( !outSecBuff.cbBuffer );
        InBuffer = (LPSTR)InBuffer + InBufferSize - inBuffDesc.pBuffers[1].cbBuffer;
        InBufferSize = inBuffDesc.pBuffers[1].cbBuffer;
        goto ScanNextPacket;

    } else if ( ss == SEC_E_INCOMPLETE_MESSAGE ) {
        //
        //  Not enough data from server... need to read more before proceeding
        //  If there is unconsumed data, the new data is to be appended to it
        //
        *pcbExtra = InBufferSize;

    } else if ( !NT_SUCCESS( ss ) ) {

        ErrorTrace( (LPARAM)this,"%s failed with %x\n",
                    m_IsClient ?
                    "InitializeSecurityContext" :
                    "AcceptSecurityContext",
                    ss );

        if ( ss == SEC_E_LOGON_DENIED ) {
            ss = ERROR_LOGON_FAILURE;
        }
        goto error_exit;
    }

    //
    // Only query the context attributes if this is a new session, and the
    // Accept/Initialize have returned SEC_E_OK (ie, the channel has been fully
    // established)
    //
    if( ss == SEC_E_OK ) {

        ssInfo = g_QueryContextAttributes(
                            pCtxtHandle,
                            SECPKG_ATTR_KEY_INFO,
                            &spcKInfo
                            );

        if ( ssInfo != SEC_E_OK ) {
            ErrorTrace( (LPARAM)this,
                        "Cannot get SSL\\PCT Key Info. Err %x",ssInfo );
            //goto error_exit;
        } else {
            //  Note the key size
            m_dwKeySize = spcKInfo.KeySize;
            if ( spcKInfo.sSignatureAlgorithmName )
                g_FreeContextBuffer( spcKInfo.sSignatureAlgorithmName );
            if ( spcKInfo.sEncryptAlgorithmName )
                g_FreeContextBuffer( spcKInfo.sEncryptAlgorithmName );
        }
    }

    m_haveSSLCtxtHandle = TRUE;

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) ) {

        ss = g_CompleteAuthToken( pCtxtHandle, &outBuffDesc );

        if ( !NT_SUCCESS( ss )) {
            ErrorTrace( (LPARAM)this,
                        "CompleteAuthToken failed. Err %x",ss );
            goto error_exit;
        }
    }

    *OutBufferSize = outSecBuff.cbBuffer;

    *MoreBlobsExpected= (ss == SEC_I_CONTINUE_NEEDED) ||
                        (ss == SEC_I_COMPLETE_AND_CONTINUE) ||
                        (ss == SEC_E_INCOMPLETE_MESSAGE);

    if ( *MoreBlobsExpected == FALSE )
    {

        //
        // HACK: SSLSSPI leaves outSecBuff.cbBuffer uninitialized
        // after final successful call for client side connections
        //
        if ( m_IsClient && *OutBufferSize == dwMaxBuffer )
        {
            *OutBufferSize = 0;
        }

        //
        // we're done so get the SSPI header/trailer sizes for SealMessage
        //
        ss = g_QueryContextAttributes(
                            pCtxtHandle,
                            SECPKG_ATTR_STREAM_SIZES,
                            &sizes
                            );

        if ( ss != SEC_E_OK ) {
            ErrorTrace( (LPARAM)this,
                        "Cannot get SSL\\PCT Header Length. Err %x",ss );
            goto error_exit;
        }

        m_cbSealHeaderSize = sizes.cbHeader;
        m_cbSealTrailerSize = sizes.cbTrailer;

        DebugTrace( (LPARAM)this, "Header: %d, Trailer: %d",
                    m_cbSealHeaderSize, m_cbSealTrailerSize );

        if(!m_IsClient)
        {
            scR = g_QueryContextAttributes( pCtxtHandle,
                                          SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                          &pClientCert );

            if ( !NT_SUCCESS( scR ) || !pClientCert )
            {
                fCert = FALSE;
            }
            else
            {
                CertFreeCertificateContext( pClientCert);
                DebugTrace((LPARAM)this, "[OnAuthorizationInfo] Certificate available!\n");
            }

            //
            // check if client authentication available
            //

            if ( 1 /*|| pssc->IsMap()*/ )
            {
                sc = g_QuerySecurityContextToken(   pCtxtHandle,
                                                    &hSSPToken );

                if ( !NT_SUCCESS( sc ) || (hSSPToken == (HANDLE)0x00000001) )
                {
                    hSSPToken = NULL;
                }
            }

            if ( !fCert && hSSPToken != NULL )
            {
                CloseHandle( hSSPToken );
                hSSPToken = NULL;
            }

            if( !(m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) && hSSPToken != NULL )
            {
                DebugTrace( (LPARAM)this,"NT token not required - closing");
                CloseHandle( hSSPToken );
                hSSPToken = NULL;
            }

            if( (m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) && !fCert )
            {
                //
                //  We require client cert - bail !
                //  Converse will return ERROR_ACCESS_DENIED
                //
                _ASSERT( !hSSPToken );
                return FALSE;
            }

            if( hSSPToken )
            {
                _ASSERT( fCert );
                m_hSSPToken = hSSPToken;
                m_IsAuthenticated = TRUE;
            } else if(m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) {
                //
                //  We need to map cert to token - but token is NULL
                //
                return FALSE;
            }
        }
    }

    return TRUE;

error_exit:

    SetLastError(ss);
    return FALSE;

} // EncryptConverse


DWORD
CEncryptCtx::Converse(
                IN PVOID    InBuffer,
                IN DWORD    InBufferSize,
                OUT LPBYTE  OutBuffer,
                OUT PDWORD  OutBufferSize,
                OUT PBOOL   MoreBlobsExpected,
                IN LPSTR    LocalIpAddr,
                IN LPSTR    LocalPort,
                IN LPVOID   lpvInstance,
                IN DWORD    dwInstance,
                OUT PULONG  pcbExtra
                )
/*++

Routine Description:

    Internal private routine for attempting to use a given protocol

Arguments:

  InBuffer: ptr to apps input buffer
  InBufferSize: count of input buffer
  OutBuffer: ptr to apps output buffer
  OutBuffer: ptr to apps max size of output buffer and resultant output count
  MoreBlobsExpected: expect more data from the client ?
  LocalIpAddr: stringized local IP addr for the connection
  pcbExtra: See description of EncryptConverse
                
Return Value:

    Win32/SSPI error code

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::Converse");

    DWORD               dwMaxBuffer = *OutBufferSize;
    DWORD               i, cbCreds;
    CredHandle*         pCredArray = NULL;

    if ( m_IsNewSSLSession )
    {
        if ( m_IsClient )
        {
            //
            //  Get the credentials for the client
            //

            LockGlobals();
            if ( !LookupClientCredential(
                                    wszServiceName,
                                    (BOOL)m_dwSslAccessPerms,
                                    (CRED_CACHE_ITEM**)&m_phCreds ) )
            {
                ErrorTrace( (LPARAM)this,
                            "LookupClientCredential failed, error 0x%lx",
                            GetLastError() );

                UnlockGlobals();
                goto error_exit;
            }
            UnlockGlobals();
        }
        else
        {
            DebugTrace( (LPARAM)this,
                        "LookupCredential for %S on %s",
                        wszServiceName, LocalIpAddr );

            //
            //  Get the credentials for this IP address
            //

            LockGlobals();
            if ( !LookupFullyQualifiedCredential(
                                    wszServiceName,
                                    LocalIpAddr,
                                    lstrlen(LocalIpAddr),
                                    LocalPort,
                                    lstrlen(LocalPort),
                                    lpvInstance,
                                    (CRED_CACHE_ITEM**)&m_phCreds,
                                    m_psmcMapContext,
                                    dwInstance ))
            {
                ErrorTrace( (LPARAM)this,
                            "LookupCredential failed, error 0x%lx",
                            GetLastError() );

                UnlockGlobals();
                goto error_exit;
            }
            UnlockGlobals();

        }

        //
        // run thru all initialized credentials look for a package which
        // will accept this connection
        //
        CRED_CACHE_ITEM*    phCreds = (CRED_CACHE_ITEM*)m_phCreds;

        //
        //  For server: Need to use SSL access perms
        //  to figure out whether to use CredMap or Cred
        //

        if( !m_IsClient && (m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) )
        {
            cbCreds = phCreds->m_cCredMap;
            pCredArray = phCreds->m_ahCredMap;
        } else {
            cbCreds = phCreds->m_cCred;
            pCredArray = phCreds->m_ahCred;
        }
    }
    else
    {
        //
        // hack to only allow one pass thru the loop
        //
        cbCreds = 1;
        pCredArray = m_phCredInUse;
    }

    //
    // Do the conversation
    //

    for ( i=0; i<cbCreds; i++, pCredArray++ )
    {
        if ( EncryptConverse(InBuffer,
                            InBufferSize,
                            OutBuffer,
                            OutBufferSize,
                            MoreBlobsExpected,
                            pCredArray,
                            pcbExtra ) )
        {
            if ( m_IsNewSSLSession )
            {
                //
                // if the first time remember which credential succeeded.
                //
                m_phCredInUse = pCredArray;
                m_iCredInUse = i;

                m_IsNewSSLSession = FALSE;
            }
            return  NO_ERROR;
        }
    }

    //
    // We failed
    //

error_exit:

    if(OutBuffer)
        *OutBuffer = 0;

    if(OutBufferSize)
        *OutBufferSize = 0;

    DWORD   error = GetLastError();

    if ( error == NO_ERROR ) {
        error = ERROR_ACCESS_DENIED;
    }
    return  error;

} // Converse



//+---------------------------------------------------------------
//
//  Function:   DecryptInputBuffer
//
//  Synopsis:   decrypted input read from the client
//
//  Arguments:  pBuffer:        ptr to the input/output buffer
//              cbInBuffer:     initial input length of the buffer
//              pcbOutBuffer:   total length of decrypted/remaining
//                              data. pcbOutBuffer - pcbParsable is
//                              the length of offset for next read
//              pcbParsable:    length of decrypted data
//              pcbExpected:    length of remaining unread data for
//                              full SSL message
//
//  Returns:    DWORD   Win32/SSPI error core
//
//----------------------------------------------------------------
DWORD CEncryptCtx::DecryptInputBuffer(
                IN LPBYTE   pBuffer,
                IN DWORD    cbInBuffer,
                OUT DWORD*  pcbOutBuffer,
                OUT DWORD*  pcbParsable,
                OUT DWORD*  pcbExpected
            )
{
    LPBYTE  pDecrypted;
    DWORD   cbDecrypted;
    DWORD   cbParsable = 0;
    LPBYTE  pNextSeal;
    LPBYTE  pStartBuffer = pBuffer;
    BOOL    fRet;

    //
    // initialize to zero so app does not inadvertently post large read
    //
    *pcbExpected = 0;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::DecryptInputBuffer" );

    while( fRet = UnsealMessage(pBuffer,
                                cbInBuffer,
                                &pDecrypted,
                                &cbDecrypted,
                                pcbExpected,
                                &pNextSeal ) )
    {
        DebugTrace( (LPARAM)this,
                    "Decrypted %d bytes at offset %d",
                    cbDecrypted,
                    pDecrypted - pStartBuffer );

        //
        // move the decrypted data to the front of buffer
        //
        MoveMemory( pStartBuffer + cbParsable,
                    pDecrypted,
                    cbDecrypted );

        //
        // increment where the next parsing should take place
        //
        cbParsable += cbDecrypted;

        //
        // move to the next potential seal buffer
        //
        if ( pNextSeal != NULL )
        {
            _ASSERT( pNextSeal >= pStartBuffer );
            _ASSERT( pNextSeal <= pBuffer + cbInBuffer );
            //
            // remove header, body and trailer from input buffer length
            //
            cbInBuffer -= (DWORD)(pNextSeal - pBuffer);
            pBuffer = pNextSeal;
        }
        else
        {
            //
            // in this case we received a seal message at the boundary
            // of the IO buffer
            //
            cbInBuffer = 0;
            break;
        }
    }

    *pcbParsable = cbParsable;
    *pcbOutBuffer= cbParsable + cbInBuffer;

    if ( fRet == FALSE )
    {
        DWORD   dwError = GetLastError();

        DebugTrace( (LPARAM)this,
                    "UnsealMessage returned: 0x%08X",
                    GetLastError() );

        //
        // deal with seal fragments at the end of the IO buffer
        //
        if ( dwError == SEC_E_INCOMPLETE_MESSAGE )
        {
            _ASSERT( cbInBuffer != 0 );

            //
            // move the remaining memory forward
            //
            MoveMemory( pStartBuffer + cbParsable,
                        pBuffer,
                        cbInBuffer );

            DebugTrace( (LPARAM)this,
                        "Seal fragment remaining: %d bytes",
                        cbInBuffer );
        }
        else
        {
            return  dwError;
        }
    }

    return  NO_ERROR;
}



//+---------------------------------------------------------------
//
//  Function:   IsEncryptionPermitted
//
//  Synopsis:   This routine checks whether encryption is getting
//              the system default LCID and checking whether the
//              country code is CTRY_FRANCE.
//
//  Arguments:  void
//
//  Returns:    BOOL: supported
//
//----------------------------------------------------------------
BOOL
IsEncryptionPermitted(void)
{
    LCID    DefaultLcid;
    CHAR    CountryCode[10];
    CHAR    FranceCode[10];

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if ( LANGIDFROMLCID( DefaultLcid ) == 0x40c )
    {
        return  FALSE;
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if ( GetLocaleInfo( DefaultLcid,
                        LOCALE_ICOUNTRY,
                        CountryCode,
                        sizeof(CountryCode) ) == 0 )
    {
        return  FALSE;
    }

    wsprintf( FranceCode, "%d", CTRY_FRANCE );

    //
    // if the country codes matches France return FALSE
    //
    return  lstrcmpi( CountryCode, FranceCode ) == 0 ? FALSE : TRUE ;
}



//+---------------------------------------------------------------
//
//  Function:   GetAdminInfoEncryptCaps
//
//  Synopsis:   sets the magical buts to send the IIS admin program
//
//  Arguments:  PDWORD: ptr to the dword bitmask
//
//  Returns:    void
//
//----------------------------------------------------------------
VOID CEncryptCtx::GetAdminInfoEncryptCaps( PDWORD pdwEncCaps )
{
    *pdwEncCaps = 0;

    if ( m_IsSecureCapable == FALSE )
    {
        *pdwEncCaps |= (IsEncryptionPermitted() ?
                        ENC_CAPS_NOT_INSTALLED :
                        ENC_CAPS_DISABLED );
    }
    else
    {
        //
        // for all enabled encryption providers set the flags bit
        //
        for ( int j = 0; EncProviders[j].pszName != NULL; j++ )
        {
            if ( TRUE == EncProviders[j].fEnabled )
            {
                *pdwEncCaps |= EncProviders[j].dwFlags;
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// From here to the end of the file is code stolen from the Athena group from
// the file called thorsspi.cpp
//
// minor mods have been made to incorporate msntrace functionality and to
// fit in the CEncryptCtx class definition
//

/////////////////////////////////////////////////////////////////////////////
//
// CompareDNStoCommonName()
//
// Description:
//  Compare a DNS name to a common name field value
//
// Parameters:
//  pDNS - string containing DNS name - *WARNING* will be munged
//  pCN  - string containing common name field value
//
// Return:
//  TRUE if they match
//
// Comments:
//  There are two ways for these two strings to match. The first is that
//  they contain exactly the same characters. The second involved the use
//  of a single wildcard character in the common name field value. This
//  wildcard character ('*') can only be used once, and if used must be
//  the first character of the field.
//
// ASSUMES: the caller will allow pDNS and pCN to be uppercased and changed.
//
BOOL CompareDNStoCommonName(LPSTR pDNS, LPSTR pCN)
{
    int nCountPeriods = 1;  // start of DNS amount to virtual '.' as prefix
    BOOL fExactMatch = TRUE;
    LPSTR pBakDNS = pDNS;
    LPSTR pBakCN = pCN;

    _ASSERT(pDNS);
    _ASSERT(pCN);

    CharUpper(pDNS);
    CharUpper(pCN);

    while ((*pDNS == *pCN || *pCN == '*') && *pDNS && *pCN)
        {
        if (*pDNS != *pCN)
            fExactMatch = FALSE;

        if (*pCN == '*')
            {
            nCountPeriods = 0;
            if (*pDNS == '.')
                pCN++;
            else
                pDNS++;
            }
        else
            {
            if (*pDNS == '.')
                nCountPeriods++;
            pDNS++;
            pCN++;
            }
        }

    // if they are sized 0, we make sure not to say they match.
    if (pBakDNS == pDNS || pBakCN == pCN)
        fExactMatch = FALSE;

    return (*pDNS == 0) && (*pCN == 0) && ((nCountPeriods >= 2) || fExactMatch);
}

/////////////////////////////////////////////////////////////////////////////
//
// CompareDNStoMultiCommonName()
//
// Description:
//  Compare a DNS name to a comma delimited list of common name fields.
//
// Parameters:
//  pDNS - string containing DNS name - *WARNING* will munge
//  pCN  - string containing common name field value - *WARNING* will munge
//
// Return:
//  TRUE if they match
//
// ASSUMES: the caller will allow pDNS and pCN to be uppercased and changed.
//
BOOL CompareDNStoMultiCommonName(LPSTR pDNS, LPSTR pCN)
{
    LPSTR pComma;
    LPSTR lpszCommonName;
    BOOL retval = FALSE;    // assume we won't find a match
    BOOL done = FALSE;      // assume we're not done

    lpszCommonName = pCN;

    do {
        // If there is a space, turn it into a null terminator to isolate the first
        // DNS name in the string
        lpszCommonName = strstr(lpszCommonName, "CN=");

        if (lpszCommonName)
            {
            // jump past "CN=" string
            lpszCommonName += 3;

            pComma = strchr(lpszCommonName, ',');
            if (pComma)
                *pComma = 0;

            // See if this component is a match
            retval = CompareDNStoCommonName(pDNS, lpszCommonName);

            // Now restore the comma (if any) that was overwritten
            if (pComma)
                {
                *pComma = ',';
                lpszCommonName = pComma + 1;
                }
            else
                {
                // If there were no more commas, then we're done
                done = TRUE;
                }
            }
        } while (!retval && !done && lpszCommonName && *lpszCommonName);

    return retval;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function checks if pDns is a subdomain of pCn.
//      Basic rule: A wildcard character '*' at the beginning of a DNS name
//      matches any number of components. i.e. a wildcard implies that we will
//      match all subdomains of a given domain.
//
//          microsoft.com == microsoft.com
//          *.microsoft.com == microsoft.com
//          *.microsoft.com == foo.microsoft.com
//          *.microsoft.com == foo.bar.microsoft.com
//
//      Note that the arguments are modified (converted to uppercase).
//  Arguments:
//      pDns - DNS name to which we are trying to connect
//      pCn - Common name in certificate
//  Returns:
//      TRUE if subdomain, FALSE otherwise
//-----------------------------------------------------------------------------
BOOL MatchSubDomain (LPSTR pDns, LPSTR pCn)
{
    LPSTR pCnBegin = NULL;
    int cbDns = 0;
    int cbCn = 0;

    _ASSERT (pDns);
    _ASSERT (pCn);

    CharUpper(pDns);
    CharUpper(pCn);

    cbDns = lstrlen (pDns);
    cbCn = lstrlen (pCn);

    //  check if we have an initial wildcard: this is only allowed as "*.restofdomain"
    if (cbCn >= 2 && *pCn == '*') {
        pCn++;  //  we have a wildcard, try to get parent domain
        if (*pCn != '.')
            return FALSE;   //  Bad syntax, '.' must follow wildcard
        else
            pCn++;  //  Skip wildcard, get to parent domain part

        cbCn -= 2;  //  Update string length
    }

    if (cbDns < cbCn)   //  subdomains must be >= parent domains in length
        return FALSE;

    //
    //  If subdomain is > parent domain, verify that there is a '.' between
    //  the subdomain part and parent domain part. This is to guard from matching
    //  *.microsoft.com with foobarmicrosoft.com since all we do after this
    //  line of code is check that the parent is a substring of the subdomain
    //  at the end.
    //
    if (cbDns != cbCn && pDns[cbDns - cbCn - 1] != '.')
        return FALSE;

    pCnBegin = pCn;
    pCn += cbCn;
    pDns += cbDns;

    //  Walk backwards doing matching
    for (; pCnBegin <= pCn && *pCn == *pDns; pCn--, pDns--);

    //
    //  Check if we terminated without a mismatch,
    //
    return (pCnBegin > pCn);
}

#define CompareCertTime(ft1, ft2)   (((*(LONGLONG *)&ft1) > (*(LONGLONG *)&ft2))                    \
                                        ? 1                                                         \
                                        : (((*(LONGLONG *)&ft1) == (*(LONGLONG *)&ft2)) ? 0 : -1 ))



//+---------------------------------------------------------------
//
//  Function:   CheckCertificateCommonName
//
//  Synopsis:   verifies the intended host name matches the
//              the name contained in the certificate
//  This function, checks a given hostname against the current certificate
//  stored in an active SSPI Context Handle. If the certificate containts
//  a common name, and it matches the passed in hostname, this function
//  will return TRUE
//
//  Arguments:  IN LPSTR: DNS host name
//
//  Returns:    BOOL
//
//----------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateCommonName( IN LPSTR pszHostName )
{
    DWORD               dwErr;
    BOOL                fIsCertGood = FALSE;
    SecPkgContext_Names CertNames;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckCertificateCommonName" );

    CertNames.sUserName = NULL;

    if ( !pszHostName )
    {
        goto quit;
    }

    dwErr = g_QueryContextAttributes(&m_hSealCtxt,
                                    SECPKG_ATTR_NAMES,
                                    (PVOID)&CertNames);
    if (dwErr != ERROR_SUCCESS)
    {
        ErrorTrace( (LPARAM)this,
                    "QueryContextAttributes failed to retrieve CN, returned %#x",
                    dwErr );
        goto quit;
    }

    DebugTrace( (LPARAM)this,
                "QueryContextAttributes returned CN=%.200s",
                CertNames.sUserName );

    fIsCertGood = CompareDNStoMultiCommonName(pszHostName, CertNames.sUserName);

quit:
    if ( CertNames.sUserName )
    {
        LocalFree( CertNames.sUserName );
    }

    return fIsCertGood;
}


//-------------------------------------------------------------------------
//  Description:
//      Verifies that the subject of the certificate matches the FQDN of
//      the server we are talking to. Does some wildcard matching if there
//      are '*' characters at the beginning of the cert subject.
//  Arguments:
//      pCtxtHandle The context of an established SSL connection
//      pszServerFqdn FQDN of server to which we are talking (from who we
//          received the certificate).
//  Returns:
//      TRUE match found, FALSE unmatched
//-------------------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateSubjectName (IN LPSTR pszServerFqdn)
{
    CHAR pszSubjectStackBuf[256];
    LPSTR pszSubject = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cSize = 0;
    DWORD cSubject = 0;
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CEncryptCtx::VerifySubject");

    _ASSERT (pszServerFqdn);

    dwErr = g_QueryContextAttributes(
                        &m_hSealCtxt,
                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                        &pCertContext);

    if (dwErr != SEC_E_OK) {
        StateTrace ((LPARAM) this, "Cannot get Context Handle %x", dwErr);
        goto Exit;
    }

    //
    //  Check the size of the buffer needed, if it's small enough we'll
    //  just use the fixed size stack buffer, otherwise allocate on heap.
    //

    cSize = CertGetNameString (
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    NULL,
                    0);

    if (cSize <= sizeof(pszSubjectStackBuf)) {

        pszSubject = pszSubjectStackBuf;
        cSubject = sizeof (pszSubjectStackBuf);

    } else {

        pszSubject = new CHAR [cSize];
        if (NULL == pszSubject) {
            ErrorTrace ((LPARAM) this, "No memory to alloc subject string.");
            goto Exit;
        }
        cSubject = cSize;
    }

    //
    //  Get the subject of the certificate
    //

    cSize = CertGetNameString (
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,
                NULL,
                pszSubject,
                cSubject);

    if (cSize == 1 && pszSubject[0] == '\0') {
        //
        //  If the CERT_NAME_SIMPLE_DISPLAY_TYPE could not be found in the cert,
        //  the API returns a zero length NULL terminated string.
        //
        StateTrace ((LPARAM) this, "Certificate subject not found");
        goto Exit;
    }

    StateTrace ((LPARAM) this, "Certificate subject: %s, FQDN: %s",
        pszSubject, pszServerFqdn);

    if (MatchSubDomain(pszServerFqdn, pszSubject)) {
        //
        //  Certificate matches the server FQDN we're talking to
        //
        fRet = TRUE;
    }

Exit:

    //
    // Delete the Subject buffer if we were using the heap
    //

    if (pszSubject != pszSubjectStackBuf)
        delete [] pszSubject;

    if (pCertContext)
        CertFreeCertificateContext (pCertContext);

    StateTrace ((LPARAM) this, "Returning: %s", fRet ? "TRUE" : "FALSE");
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;

}

//---------------------------------------------------------------------
//  Description:
//      Checks if the certificate for this CEncryptCtx chains up to a
//      trusted CA.
//  Returns:
//      TRUE if certificate is trusted.
//      FALSE if the certificate is untrusted or if trust could not be
//          verified (temporary errors can cause this).
//  Source:
//      MSDN sample
//---------------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateTrust ()
{
    BOOL fRet = FALSE;
    DWORD dwErr = SEC_E_OK;
    DWORD dwFlags = 0;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_ENHKEY_USAGE EnhkeyUsage;
    CERT_USAGE_MATCH CertUsage;
    CERT_CHAIN_PARA ChainPara;

    TraceFunctEnterEx ((LPARAM) this, "CEncryptCtx::CheckCertificateTrust");

    dwErr = g_QueryContextAttributes (
                            &m_hSealCtxt,
                            SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                            &pCertContext);


    if (SEC_E_OK != dwErr) {
        ErrorTrace ((LPARAM) this, "g_QueryContextAttributes failed, err - %8x", dwErr);
        fRet = FALSE;
        goto Exit;
    }

    //
    //  ChainPara is a struct used to match specific certificates using OIDs
    //  We don't need this and initialize it to empty (no OIDs)
    //
    EnhkeyUsage.cUsageIdentifier = 0;
    EnhkeyUsage.rgpszUsageIdentifier = NULL;
    CertUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertUsage.Usage  = EnhkeyUsage;
    ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainPara.RequestedUsage = CertUsage;

    dwFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN | CERT_CHAIN_CACHE_END_CERT;

    fRet = CertGetCertificateChain (
                            NULL,           //  Use the default chaining engine
                            pCertContext,   //  The end certificate to be checked
                            NULL,           //  Expiration checking... use currenttime
                            NULL,           //  Additional cert stores: none
                            &ChainPara,     //  Chaining criteria: none, this is an empty struct
                            dwFlags,        //  Options: how to check chain
                            NULL,           //  reserved param
                            &pChainContext);//  Returned chain context


    if (!fRet) {
        dwErr = GetLastError ();
        ErrorTrace ((LPARAM) this, "Unable to create certificate chain, err - %8x", dwErr);
        goto Exit;
    }

    DebugTrace ((LPARAM) this, "Status of certificate chain - %8x",
        pChainContext->TrustStatus.dwErrorStatus);

    if (CERT_TRUST_NO_ERROR == pChainContext->TrustStatus.dwErrorStatus) {
        DebugTrace ((LPARAM) this, "Certificate trust verified");
        fRet = TRUE;
    } else {
        ErrorTrace ((LPARAM) this, "Certificate is untrusted, status - %8x",
            pChainContext->TrustStatus.dwErrorStatus);
        fRet = FALSE;
    }

Exit:
    if (pCertContext)
        CertFreeCertificateContext (pCertContext);

    if (pChainContext)
        CertFreeCertificateChain (pChainContext);

    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

//+---------------------------------------------------------------
//
//  Function:   CheckCertificateExpired
//
//  Synopsis:   verifies the ccertificate has not expired
//              returns TRUE if the cert is valid
//
//  Arguments:  void
//
//  Returns:    BOOL cert is good
//
//----------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateExpired( void )
{
    SYSTEMTIME  st;
    FILETIME    ftCurTime;
    DWORD       dwErr;

    SecPkgContext_Lifespan CertLifeSpan;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckCertificateExpired" );

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ftCurTime)) return FALSE;

    dwErr = g_QueryContextAttributes(&m_hSealCtxt,
                                    SECPKG_ATTR_LIFESPAN,
                                    (PVOID)&CertLifeSpan);
    if ( dwErr != ERROR_SUCCESS )
    {
        ErrorTrace( (LPARAM)this,
                    "QueryContextAttributes failed to retrieve cert lifespan, returned %#x",
                    dwErr);
        return  FALSE;
    }

    return  CompareCertTime( CertLifeSpan.tsStart, ftCurTime ) < 0 &&
            CompareCertTime( CertLifeSpan.tsExpiry, ftCurTime) > 0 ;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckServerCert
//
//  Synopsis:   Checks to see if a server cert has been installed.
//
//  Arguments:  [LocalIpAddr] -- IP Address of virtual server
//              [LocalPort] -- Port of virtual server
//              [lpvInstance] -- Pointer to IIS_SERVER_INSTANCE object
//              [dwInstance] -- Virtual server id
//
//  Returns:    TRUE if there is a cert for this virtual server
//
//-----------------------------------------------------------------------------

BOOL CEncryptCtx::CheckServerCert(
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance)
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckServerCert" );

    BOOL fRet = FALSE;
    CRED_CACHE_ITEM *pCCI;

    DebugTrace( (LPARAM)this,
                "CheckServerCert for %S on %s",
                wszServiceName, LocalIpAddr );

    //
    //  Get the credentials for this IP address
    //

    LockGlobals();
    if ( fRet = LookupFullyQualifiedCredential(
                            wszServiceName,
                            LocalIpAddr,
                            lstrlen(LocalIpAddr),
                            LocalPort,
                            lstrlen(LocalPort),
                            lpvInstance,
                            &pCCI,
                            m_psmcMapContext,
                            dwInstance ))
    {
        IIS_SERVER_CERT *pCert = pCCI->m_pSslInfo->GetCertificate();
        // Log the status of the cert if we got one
        if ( pCert )
        {
             fRet = TRUE;
        }
        else
            fRet = FALSE;

        pCCI->Release();

    } else {

        ErrorTrace( (LPARAM)this,
                    "LookupCredential failed, error 0x%lx",
                    GetLastError() );

    }

    UnlockGlobals();

    TraceFunctLeave();

    return( fRet );
}

//+---------------------------------------------------------------
//
//  Function:   NotifySslChanges
//
//  Synopsis:   This is called when SSL settings change
//
//  Arguments:  dwNotifyType
//              pInstance
//
//  Returns:    VOID
//
//----------------------------------------------------------------

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    )
{
    LockGlobals();

    if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED )
    {
        FreeCredCache();

        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif
    }
    else if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ||
              dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED )
    {
        FreeCredCache();
    }
    else if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED )
    {
        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif
        //SSPI_FILTER_CONTEXT::FlushOnDelete();
    }
    else
    {
        _ASSERT( FALSE );
    }

    UnlockGlobals();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\smtpaddr\address.cxx ===
/*
 * Copyright (c) 1985 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        address.cxx

   Abstract:

        This module defines the module for the address (CAddr)
		class.

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:
   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <windows.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <string.h>
#include <listmacr.h>
#include <abtype.h>
#include <abook.h>
#include <address.hxx>

//initialize the pool
CPool  CAddr::Pool(ADDRESS_SIGNATURE_VALID);
#if defined(TDC)
LPFNAB_FREE_MEMORY CAddr::pfnABFreeMemory = NULL;
#endif

//
// Statics
//
static BOOL pStripAddrQuotes( char *lpszAddress, char **lpDomain );
static BOOL pStripAddrSpaces(char *lpszAddress);

// Quick and dirty string validation
static BOOL pValidateStringPtr(LPSTR lpwszString, DWORD dwMaxLength)
{
	if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
		return(FALSE);
	while (dwMaxLength--)
		if (*lpwszString++ == 0)
			return(TRUE);
	return(FALSE);
}


//This routine scans an address for illegal characters
//in a name
BOOL IsInvalidAddr(char *Address)
{
	char * addr = Address;

    for (; *addr != '\0'; addr++)
    {
        if ((*addr & 0340) == 0200)
            break;
    }
    if (*addr == '\0')
    {
        return FALSE;
    }

	SetLastError (ERROR_INVALID_DATA);
    return TRUE;
}

// Forward declaration of pValidateLocalPartOrDomain
BOOL pValidateLocalPartOrDomain(char *lpszStart,
								DWORD dwLength,
								BOOL fLocalPart);


/*++
	Name :
	  CAddr:CAddr

    Description:
      This is the default constructor for this class.
	  It just initializes the member variables.

    Arguments:	None

    Returns:

      nothing

    Limitations:

--*/
CAddr::CAddr(void)
{
   m_Signature = ADDRESS_SIGNATURE_VALID;
   m_Flags = ADDRESS_NO_DOMAIN;
   m_PlainAddrSize = 0;
   m_DomainOffset = NULL;
   m_HashInfo = NULL;
   m_Error = 0;
   m_listEntry.Flink = NULL;
   m_listEntry.Blink = NULL;
}

CAddr::~CAddr(VOID)
{		
	m_Signature = ADDRESS_SIGNATURE_FREE;
	m_Flags = 0;
	m_listEntry.Flink = NULL;
	m_listEntry.Blink = NULL;
	m_HashInfo = NULL;
}

/*++
	Name :
	  CAddr:CAddr(char * address)

    Description:
      This is the default constructor for this class.
	  It just initializes the member variables.

    Arguments:	None

    Returns:

      nothing

    Limitations:

--*/
CAddr::CAddr(char * Address)
{
   m_Signature = ADDRESS_SIGNATURE_VALID;
   m_Flags = ADDRESS_NO_DOMAIN;
   m_PlainAddrSize = 0;
   m_DomainOffset = NULL;
   m_HashInfo= NULL;
   m_Error = 0;
   m_listEntry.Flink = NULL;
   m_listEntry.Blink = NULL;


   if(Address == NULL)
   {
	  SetLastError(ERROR_INVALID_DATA);
	  return;
   }

   // This is an email name, extract its clean representation
   ExtractCleanEmailName(	m_PlainAddress,
							&m_DomainOffset,
							&m_PlainAddrSize,
							Address);

   if (m_PlainAddrSize > MAX_INTERNET_NAME)
   {
      m_PlainAddrSize = 0;
	  SetLastError (ERROR_INVALID_DATA);
   }
   else
   {
	  if(m_DomainOffset)	
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN; //turn off the no domain flag.
   }
}

/*++
	Name :
	CAddr::InitializeAddress

    Description:
	This function parses an RFC address, stripping out
	all comments, and gets back an internet address

    Arguments:	
	Address - RCF address from client
	ADDRTYPE - specify if address came from FROM or RCPT command

    Returns:

    TRUE if the RFC addressed was correctly parsed.
	FALSE otherwise.

--*/
BOOL CAddr::InitializeAddress(char * Address, ADDRTYPE NameType)
{

	if(::IsInvalidAddr(Address))
		return(FALSE);

	m_PlainAddress[0] = '\0';
	m_DomainOffset = NULL;
	m_PlainAddrSize = 0;

	// We have a special case for domains treated as addresses
	if (NameType == CLEANDOMAIN)
	{
		DWORD AddressSize = 0;
		char  szCleanAddress[MAX_DOMAIN_NAME+1];

		AddressSize = lstrlen(Address);

		if (AddressSize > MAX_DOMAIN_NAME)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// We want an ABSOLUTELY clean domain name, but we will strip
		// out leading and trailing spaces for them
		lstrcpy(szCleanAddress, Address);
		if (!pStripAddrSpaces(szCleanAddress))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		AddressSize = lstrlen(szCleanAddress);
		if (!pValidateLocalPartOrDomain(szCleanAddress, AddressSize, FALSE))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// This is a clean domain name, fill in the fields, and
		// return a positively
		lstrcpy(m_PlainAddress, szCleanAddress);
		m_PlainAddrSize = lstrlen(szCleanAddress);
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN;
		return(TRUE);			
	}

	// This is an email name, extract its clean representation
	if (!ExtractCleanEmailName(	m_PlainAddress,
								&m_DomainOffset,
								&m_PlainAddrSize,
								Address))
		return(FALSE);

	// Take care of the flag
	if (!m_DomainOffset)
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN;

	// Further, we validate the whole local-part[@domain] email name
	// Special case: if the address is <>, then we skip the validation
	if (strcmp(m_PlainAddress, "<>"))
	{
		if (!ValidateCleanEmailName(m_PlainAddress, m_DomainOffset))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
	}
	else if (NameType != FROMADDR)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// Take care of other anomalies ...
	if (m_DomainOffset)
	{
		// Make sure there is a local-part
		if (m_DomainOffset <= m_PlainAddress)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// EMPIRE WTOP Bug 47233: Need to accept longer email names if they add up
		// to less than MAX_INTERNET_NAME. This is for replication of users across
		// a site connector. Due to this reason, we removed the user name check to
		// make sure it is less than MAX_EMAIL_NAME.
	}
	else
	{
		// We have no domain, make sure it is not an empty string
		if (m_PlainAddress[0] == '\0')
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// EMPIRE WTOP Bug 47233: Need to accept longer email names if they add up
		// to less than MAX_INTERNET_NAME. This is for replication of users across
		// a site connector. Due to this reason, we removed the user name check to
		// make sure it is less than MAX_EMAIL_NAME.
	}
	return(TRUE);
}

/*++
	Name :
	CAddr::CreateAddress

    Description:
	This function allocates memory for a CAddr
	class and calls StripAddrComments to

    Arguments:	
	pszDest - Destination where new address should go
	pszSrc  - Source buffer of address to strip comments from

    Returns:

      a pointer to a CAddr if comments were stripped and the format
	  of the address is legal.
	  NULL otherwise

--*/
CAddr * CAddr::CreateAddress(char * Address, ADDRTYPE NameType)
{
    CAddr * NewAddress;

	//create the memory for the address
	NewAddress = new CAddr ();
	if (!NewAddress)
	 {
	    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	    return NULL;
	 }

	//now initialize it
    if (!NewAddress->InitializeAddress(Address, NameType))
	{
		delete NewAddress;
		return NULL;
	}

	//we have a good address...or so we think
	return NewAddress;
}

/*++
	Name :
	CAddr::CreateKnownAddress

    Description:
	This function allocates memory for a CAddr
	class and sets "Address" as the internet
	address for this class.  No error checking
	is done.  It is assumed that the caller
	performed all necessary error checking

    Arguments:	
	Address - Internet Address to initialize
	the class with

    Returns:
	  a pointer to a CAddr if memory could be allocated
	  NULL otherwise

--*/
CAddr * CAddr::CreateKnownAddress(char * Address)
{
    CAddr * NewAddress = NULL;
		
	//create the memory for the address
	NewAddress = new CAddr (Address);
	if (!NewAddress)
	 {
	    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	    return NULL;
	 }

	if(!NewAddress->GetAddrSize())
	{
	  delete NewAddress;
	  NewAddress = NULL;
	}

	return NewAddress;
}


/*++
	Name :
	CAddr::ReplaceAddress

    Description:
		Replaces the address stored in this
		CAddr with the one passed in
    Arguments:	
		Address - new address

    Returns:
		TRUE if the address could be replaced.
		FALSE if we run out of memory, the new
		address is NULL, or the size of the
		address is zero

--*/
BOOL CAddr::ReplaceAddress(const char * Address)
{
	_ASSERT(IsValid());

	if(Address == NULL)
	{
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}

	ExtractCleanEmailName(	m_PlainAddress,
							&m_DomainOffset,
							&m_PlainAddrSize,
							(char *)Address);

	if (m_PlainAddrSize > MAX_INTERNET_NAME)
	{
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}

	if(m_DomainOffset)
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN; //turn off the no domain flag.
	
	return TRUE;
}


/*++

    Name :
        CAddr::CAddr

    Description:
        returns a pointer to the 1st CAddr in the local list

    Arguments:
        a pointer to a PLIST_ENTRY

    Returns:

--*/
CAddr * CAddr::GetFirstAddress(PLIST_ENTRY HeadOfList, PLIST_ENTRY * AddressLink)
{
  PLIST_ENTRY ListEntry = NULL;
  CAddr * FirstAddress = NULL;

  //if the list is not empty, get the first address
  if(!IsListEmpty (HeadOfList))
  {
    ListEntry = HeadOfList->Flink;
    FirstAddress = CONTAINING_RECORD( ListEntry, CAddr, m_listEntry);
	_ASSERT(FirstAddress->IsValid());

    *AddressLink = ListEntry->Flink;      //get the next link
  }

  return FirstAddress;
}

/*++

    Name :
        CAddr::GetNextAddress

    Description:
        returns a pointer to the next CAddr in the local list

    Arguments:
        a pointer to a PLIST_ENTRY

    Returns:

--*/
CAddr * CAddr::GetNextAddress(PLIST_ENTRY HeadOfList, PLIST_ENTRY * AddressLink)
{
  CAddr * NextAddress = NULL;

  //make sure we are not at the end of the list
  if((*AddressLink) != HeadOfList)
  {
    NextAddress = CONTAINING_RECORD(*AddressLink, CAddr, m_listEntry);
	_ASSERT(NextAddress->IsValid());
    *AddressLink = (*AddressLink)->Flink;
  }

  return NextAddress;
}



/*++

    Name :
		CAddr::RemoveAllAddrs

    Description:
        Deletes all address from a CAddr list

    Arguments:
        a pointer to the head of the list

    Returns:

--*/
void CAddr::RemoveAllAddrs(PLIST_ENTRY HeadOfList)
{
  PLIST_ENTRY  pEntry;
  CAddr  * pAddr;

  // Remove all addresses
  while (!IsListEmpty (HeadOfList))
  {
    pEntry = RemoveHeadList(HeadOfList);
    pAddr = CONTAINING_RECORD( pEntry, CAddr, m_listEntry);
    delete pAddr;
  }

}

/*++

	Name :
		CAddr::RemoveAddress

    Description:
		removes an address from a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/
void CAddr::RemoveAddress(IN OUT CAddr * pEntry)
{
	if(pEntry != NULL)
	{
	  _ASSERT(pEntry->IsValid());

	  //Remove from list of addresses
	  RemoveEntryList( &pEntry->QueryListEntry());
	}
}


/*++

	Name :
		CAddr::InsertAddrHeadList

    Description:
		insert an address into the head of a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/

void CAddr::InsertAddrHeadList(PLIST_ENTRY HeadOfList, CAddr *pEntry)
{
	_ASSERT(pEntry);
	_ASSERT(pEntry->IsValid());

	InsertHeadList(HeadOfList, &pEntry->QueryListEntry());
}

/*++

	Name :
		CAddr::InsertAddrTailList

    Description:
		insert an address into the head of a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/

void CAddr::InsertAddrTailList(PLIST_ENTRY HeadOfList, CAddr *pEntry)
{
	_ASSERT(pEntry);
	_ASSERT(pEntry->IsValid());

	InsertTailList(HeadOfList, &pEntry->QueryListEntry());
}

// ========================================================================
//
// Validation Parser stuff added by KeithLau on 7/25/96
//

#define	QUOTE_SQUARE			0x1
#define	QUOTE_ANGLE				0x2
#define	QUOTE_QUOTES			0x4
#define QUOTE_PARENTHESES		0x8
#define	MAX_QUOTE_TYPES			3

static char acOpen[MAX_QUOTE_TYPES] = { '[', '<', '\"' };
static char acClose[MAX_QUOTE_TYPES] = { ']', '>', '\"' };

static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 char		cSearch,
										 LPBOOL		lpfNotFound,
										 DWORD		dwDefaultState);

static inline BOOL IsControl(char ch)
{
	return( ((ch >= 0) && (ch <= 31)) || (ch == 127) );
}

static BOOL IsSpecial(char ch)
{
	switch (ch)
	{
	case '(':
	case ')':
	case '<':
	case '>':
	case '@':
	case ',':
	case ':':
	case ';':
	case '\\':
	case '\"':
	case '.':
	case '[':
	case ']':
		return(TRUE);
	default:
		return(FALSE);
	}
}

static BOOL pIsSpecialOrSpace(char ch)
{
	return((ch == ' ') || (ch == '\t') || (ch == '\0') || IsSpecial(ch));
		
}

static BOOL pValidateAsciiString(char *lpszString)
{
	// Verifies that a string only contains ASCII chars (0-127)
	// Relies totally on upstream pointer checking
	_ASSERT(lpszString);
	if (!lpszString)
		return(FALSE);

	while (*lpszString)
	{
		if ((*lpszString >= 0) && (*lpszString <= 127))
			lpszString++;
		else
			return(FALSE);
	}
	return(TRUE);
}

static BOOL pValidateAtom(char *lpszStart, DWORD dwLength)
{
	// Atoms can be any ASCII char, except specials, controls, and spaces
	// Note zero-length atom is invalid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (!dwLength)
		return(FALSE);

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == ' ') ||
			(IsSpecial(*lpszStart)) ||
			(IsControl(*lpszStart))
			)
		{
			// Process quoted (escape) char
			if (*lpszStart == '\\')
			{
				if (!dwLength)
					return(FALSE);
				else
				{
					lpszStart++;
					dwLength--;
				}
			}
			else
				return(FALSE);
		}

		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateAtomNoWildcard(char *lpszStart, DWORD dwLength)
{
	// Atoms can be any ASCII char, except specials, controls, and spaces
	// Note zero-length atom is invalid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (!dwLength)
		return(FALSE);

	while (dwLength)
	{
		// Apart from the usual, we also dislike the asterisk wildcard character.
		// This is just for domains.
		dwLength--;
		if ((*lpszStart == ' ') ||
			(*lpszStart == '*') ||
			(IsSpecial(*lpszStart)) ||
			(IsControl(*lpszStart))
			)
			return(FALSE);
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateQtext(char *lpszStart, DWORD dwLength)
{
	// Qtext can be any ASCII char, except '\"', '\\', and CR
	// Note zero-length is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == '\"') ||
			(*lpszStart == '\r')
			)
			return(FALSE);

		// Process quoted (escape) char
		if (*lpszStart == '\\')
		{
			if (!dwLength)
				return(FALSE);
			else
			{
				lpszStart++;
				dwLength--;
			}
		}
			
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateDtext(char *lpszStart, DWORD dwLength)
{
	// Dtext can be any ASCII char, except '\"', '\\', and CR
	// Note zero-length is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == '[') ||
			(*lpszStart == ']') ||
			(*lpszStart == '\r')
			)
			return(FALSE);

		// Process quoted (escape) char
		if (*lpszStart == '\\')
		{
			if (!dwLength)
				return(FALSE);
			else
			{
				lpszStart++;
				dwLength--;
			}
		}
			
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateQuotedString(char *lpszStart, DWORD dwLength)
{
	// Quoted-stirngs are quotes between Qtext
	// an empty Qtext is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (dwLength < 2)
		return(FALSE);

	if ((*lpszStart != '\"') ||
		(lpszStart[dwLength-1] != '\"'))
		return(FALSE);

	return(pValidateQtext(lpszStart + 1, dwLength - 2));
}

static BOOL pValidateDomainLiteral(char *lpszStart, DWORD dwLength)
{
	// Domain-literals are square braces between Dtext
	// an empty Dtext is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (dwLength < 2)
		return(FALSE);

	if ((*lpszStart != '[') ||
		(lpszStart[dwLength-1] != ']'))
		return(FALSE);

	return(pValidateDtext(lpszStart + 1, dwLength - 2));
}

static BOOL pValidateWord(char *lpszStart, DWORD dwLength)
{
	// A word is any sequence of atoms and quoted-strings
	// words may not be zero-length by inheritance
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if ((pValidateAtom(lpszStart, dwLength)) ||
		(pValidateQuotedString(lpszStart, dwLength)))
		return(TRUE);

	return(FALSE);
}

static BOOL pValidateSubdomain(char *lpszStart, DWORD dwLength)
{
	// A subdomain may be an atom or domain-literal
	// words may not be zero-length by inheritance
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if ((pValidateAtomNoWildcard(lpszStart, dwLength)) ||
		(pValidateDomainLiteral(lpszStart, dwLength)))
		return(TRUE);

	return(FALSE);
}

//
// Since validating the local part is so similar to validating the
// domain part, we write one function to do both. If fLocalPart
// is TRUE, we treat it as the local part of an email address, if
// it is FALSE, we treat it as the domain part.
//
static BOOL pValidateLocalPartOrDomain(char *lpszStart, DWORD dwLength, BOOL fLocalPart)
{
	// A domain is one or more dot-delimited sub-domains, where a local-part
	// is one or more dot-delimited words
	// We rely on upstream calls to make sure the string is properly
	// NULL-terminated
	char *lpszBegin, *lpszEnd;
	BOOL  fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	lpszBegin = lpszStart;
	lpszEnd = (char *)NULL;

	while (lpszEnd = pFindNextUnquotedOccurrence(lpszBegin, '.', &fNotFound, 0))
	{
		// If it starts with a dot or has 2 dots in a row, we fail!
		if (lpszBegin == lpszEnd)
			return(FALSE);

		// Now, check if the chunk is indeed a valid token
		if (fLocalPart)
		{
			if (!pValidateWord(lpszBegin, (DWORD)(lpszEnd - lpszBegin)))
				return(FALSE);
		}
		else
		{
			if (!pValidateSubdomain(lpszBegin, (DWORD)(lpszEnd - lpszBegin)))
				return(FALSE);
		}

		// Allright, go to the next guy
		lpszBegin = lpszEnd + 1;
	}

	if (!fNotFound)
		return(FALSE);

	// If it ends with a dot, it's also bad
	lpszEnd = lpszStart + dwLength;
	if (lpszEnd == lpszBegin)
		return(FALSE);

	// Don't forget the last chunk
	if (fLocalPart)
		return(pValidateWord(lpszBegin, (DWORD)(lpszEnd - lpszBegin)));
	else
		return(pValidateSubdomain(lpszBegin, (DWORD)(lpszEnd - lpszBegin)));
}

static BOOL pValidatePhrase(char *lpszStart, DWORD dwLength)
{
	// A phrase is a collection of words, possibly separated
	// by spaces
	// We don't validate for now ...
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	return(TRUE);
}


//
// The following functions attempt to extract a clean addr-spec
// in the form of local-part[@domain] from a generic address
// Note that groups are not supported at this point
//
static BOOL pExtractAddressFromRouteAddress(char	*lpszStart,
											DWORD	dwLength,
											char	*lpCleanAddress)
{
	// A route address is in the form:
	// phrase < [1#(@ domain) :] addr-spec >
	char *lpMarker;
	char *lpRoute;
	BOOL fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	// First, find the opening angle brace
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, '<', &fNotFound, 0);
	if (!lpMarker)
		return(FALSE);

	// Between lpStart and lpMarker is the phrase
	_ASSERT(lpMarker >= lpszStart);
	if (!pValidatePhrase(lpszStart, (DWORD)(lpMarker - lpszStart)))
		return(FALSE);

	// Now, find the closing angle bracket
	_ASSERT(*lpMarker == '<');
	lpszStart = lpMarker + 1;
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, '>',
					&fNotFound, QUOTE_ANGLE);
	if (!lpMarker)
		return(FALSE);

	_ASSERT(*lpMarker == '>');

	// There should be nothing but white space after the closing brace
	//Trim the whitespace or flag an error
	char * lpTemp = lpMarker;
	while(*++lpTemp != '\0')
	{
		if(*lpTemp != ' ' && *lpTemp != '\t')
			return(FALSE);
	}
	*(lpMarker + 1) = '\0';

	// The special address <> is reserved for NDR, and should be
	// allowed
	if (lpszStart == lpMarker)
	{
		lpCleanAddress[0] = '<';
		lpCleanAddress[1] = '>';
		lpCleanAddress[2] = '\0';
		return(TRUE);
	}

	// The stuff enclosed in the angle braces is an addr-spec, and
	// optionally preceded by route specifiers. We don't care about
	// route specifiers, but we have to skip them.
	lpRoute = pFindNextUnquotedOccurrence(lpszStart, ':',  &fNotFound, 0);

	if (!lpRoute)
	{
		// If we have no colon, then the whole lump should be the
		// addr-spec
		_ASSERT(lpMarker >= lpszStart);
		*lpMarker++ = '\0';
		lstrcpyn(lpCleanAddress, lpszStart, (DWORD)(lpMarker - lpszStart));
		return(TRUE);
	}
	else
	{
		// We found a colon, the stuff to its right should be the
		// addr-spec. As usual, we don't validate the route specifiers
		lpRoute++;
		_ASSERT(lpMarker >= lpRoute);
		*lpMarker++ = '\0';
		lstrcpyn(lpCleanAddress, lpRoute, (DWORD)(lpMarker - lpRoute));
		return(TRUE);
	}
}

static BOOL pExtractAddressFromMailbox(	char	*lpszStart,
										DWORD	dwLength,
										char	*lpCleanAddress)
{
	// A mailbox can either be an addr-spec, or a route address
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (pExtractAddressFromRouteAddress(lpszStart, dwLength, lpCleanAddress))
		return(TRUE);

	// If it's not a route address, trhen it should ba an addr-spec
	lstrcpyn(lpCleanAddress, lpszStart, dwLength + 1);
	return(TRUE);
}

static BOOL pExtractAddressFromGroup(	char	*lpszStart,
										DWORD	dwLength,
										char	*lpCleanAddress)
{
	// We always return false
	return(FALSE);

	/*
	// A group is in the form:
	// phrase : [#mailbox] ;
	char *lpMarker;
	char *lpSemiColon;
	BOOL fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	// First, find the opening angle brace
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, ':', &fNotFound, 0);
	if (!lpMarker || fNotFound)
		return(FALSE);

	// Between lpStart and lpMarker is the phrase
	_ASSERT(lpMarker >= lpszStart);
	if (!pValidatePhrase(lpszStart, (DWORD)(lpMarker - lpszStart)))
		return(FALSE);

	// Between the colon
	lpMarker++;	
	lpSemiColon = pFindNextUnquotedOccurrence(lpMarker, ';', &fNotFound, 0);
	if (!lpSemiColon || fNotFound)
		return(FALSE);

	_ASSERT(lpSemiColon >= lpMarker);
	if (lpSemiColon == lpMarker)
		;
	 */
}

static BOOL pExtractAddress(	char	*lpszStart,
								DWORD	dwLength,
								char	*lpCleanAddress)
{
	// A address is either an mailbox, or a group
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	*lpCleanAddress = '\0';
	if (pExtractAddressFromMailbox(lpszStart, dwLength, lpCleanAddress) ||
		pExtractAddressFromGroup(lpszStart, dwLength, lpCleanAddress))
		return(TRUE);
	return(FALSE);
}


// This function finds braces pairs in a given string, and returns
// pointers to the start and end of the first occurence of a
// [nested] pair of braces. The starting and ending character
// may be specified by the caller (starting and ending chars
// must be unique).
static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 char		cSearch,
										 LPBOOL		lpfNotFound,
										 DWORD		dwDefaultState)
{
	DWORD	dwState = dwDefaultState;
	DWORD	i;
	char	ch;
	char	*lpStart = lpszString;
	BOOL	fFallThru;

	*lpfNotFound = FALSE;

	// If dwState is 0, then we are not inside any kind of quotes
	while (ch = *lpStart)
	{
		// If we are not in any quotes, and the char is found,
		// then we are done!
		if (!dwState && (ch == cSearch))
			return(lpStart);

		// Another disgusting kludge, BUT WORKS!!
		// For closing parentheses, we don't it in the
		// acClose[] set, so we have to explicitly check for them
		// here, since pMatchParentheses is very dependent on this.
		// For open parentheses, similar case: since parentheses
		// nest, we allow multiple open braces
		if (dwState == QUOTE_PARENTHESES)
		{
			if (((cSearch == ')') || (cSearch == '(')) &&
				(ch == cSearch))
				return(lpStart);
		}

		// If it is a quoted char, we can skip it and the following
		// char right away ... If the char following a quote '\' is
		// the terminating NULL, we have an error.
		if (ch == '\\')
		{
			lpStart++;
			if (!*lpStart)
				return(NULL);

			// Quoted pairs not allowed outside quotes!
			// if (!dwState)
			//	return(NULL);
		}
		else
		{
			// See if we have a state change ...
			for (i = 0; i < MAX_QUOTE_TYPES; i++)
			{
				// Check the close case, too
				fFallThru = TRUE;

				// See if we have an opening quote of any sort
				if (ch == acOpen[i])
				{
					// If it is an open brace, it shouldn't be a close brace
					// EXCEPT: quotes.
					fFallThru = FALSE;

					// Special case for quotes: open = close
					if (dwState & (1 << i))
					{
						// This is not a quoted pair, error!
						// If it is a quote, and if the current state is
						// inside quotes, then we let it
						if ((ch == '\"') && (dwState == QUOTE_QUOTES))
							fFallThru = TRUE;
						else
							return(NULL);
					}
					else if (!dwState)
					{
						// We are not in any quotes, so we can safely
						// claim we are now inside quotes
						dwState |= (1 << i);
					}
				}

				// See if we have an closing quote of any sort
				if (fFallThru && (ch == acClose[i]))
				{
					if (dwState & (1 << i))
					{
						// We are closing the correct kind of quote,
						// so we cancel it ...
						dwState = 0;

						// Do a second check, in case we are looking
						// for a close quote
						if (ch == cSearch)
							return(lpStart);
					}
					else if (!dwState)
					{
						// We are not in any quotes, so we have
						// unmatched quotes!
						return(NULL);
					}
				}
			}
		}
	
		lpStart++;
	}

	*lpfNotFound = TRUE;
	return(NULL);
}

static BOOL pMatchParentheses(	char		**ppszStart,
								char		**ppszEnd,
								LPDWORD		lpdwPairs)
{
	DWORD	dwIteration	= 0;
	DWORD	dwState = 0;
	char	*lpszString	= *ppszStart;
	char	*lpStart;
	char	*lpEnd;
	BOOL	fNotFound = FALSE;

	*lpdwPairs = 0;
	lpStart	= *ppszStart;
	lpEnd	= *ppszEnd;
	
	for (;;)
	{
		// Find open brace
		if (!(lpStart = pFindNextUnquotedOccurrence(lpStart, '(', &fNotFound, dwState)))
		{
			// If it's not found, we're done, else it's a format error!
			if (fNotFound)
				break;
			else
				return(FALSE);
		}

		// Save the start position, and since we are inside the first open
		// parenthesis, we force suppress all quotes mode in subsequent
		// open parenthesis searches
		if (!dwIteration)
		{
			*ppszStart = lpStart;
			dwState = QUOTE_PARENTHESES;
		}
		
		// If iteration > 0 and the start pointer surpasses
		// the end pointer, we have the end of the first set
		// of [nested] braces
		if (dwIteration && (lpStart > lpEnd))
			break;

		// Find close brace
		if (!(lpEnd = pFindNextUnquotedOccurrence(lpEnd, ')',
						&fNotFound, QUOTE_PARENTHESES)))
			return(FALSE);

		// Open brace pointer must always be in front of close
		// brace.
		if (lpStart > lpEnd)
			return(FALSE);

		// Next iteration
		lpStart++;
		lpEnd++;
		dwIteration++;
	}

	// Fill in the end pointer and leave (start ptr already
	// filled in)
	if (dwIteration)
		lpEnd--;
	*lpdwPairs = dwIteration;
	*ppszEnd = lpEnd;
	return(TRUE);
}


/*++
	Name :
	  pStripAddrComments

    Description:
	This function strips comments from an RFC address

    Arguments:	
	lpszAddress - Original address comes in, and clean addres comes out

    Returns:

      TRUE if comments were stripped and the format
	  of the address is legal.
	  FALSE otherwise

--*/
static BOOL pStripAddrComments(char *lpszAddress)
{

	char		*lpCopyStart;
	char		*lpStart, *lpEnd;
	DWORD		dwPairs;
	DWORD		dwCopyLen;

	// First, we strip the comments
	// We call the function above to find matching parenthesis pairs
	lpStart = lpszAddress;
	lpEnd	= lpszAddress;
	do
	{
		// Mark the actual start
		lpCopyStart = lpEnd;

		if (!pMatchParentheses(&lpStart, &lpEnd, &dwPairs))
		{
			// Failed!
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		if (dwPairs)
		{
			// If fFound, then we found some comments
			_ASSERT(*lpStart == '(');
			_ASSERT(*lpEnd == ')');

			// Copy the stuff over, excluding comments
			_ASSERT(lpStart >= lpCopyStart);
			dwCopyLen = (DWORD)(lpStart - lpCopyStart);
			
			// Reset the pointer, and match again ...
			lpEnd++;
			lpStart = lpEnd;
		}
		else
		{
			dwCopyLen = lstrlen(lpCopyStart);
		}

		while (dwCopyLen--)
		{
			*lpszAddress++ = *lpCopyStart++;
		}

	} while (dwPairs);

	// Terminate the string
	*lpszAddress = '\0';

	return(TRUE);
}

/*++
	Name :
	  pStripAddrSpaces

    Description:
	This function strips extraneous spaces from an RFC address
	An extraneous space is one that is not in a quoted pair, and
	not inside any quoting pairs

    Arguments:	
	lpszAddress - Original address comes in, and clean addres comes out

    Returns:

      TRUE if spaces were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripAddrSpaces(char *lpszAddress)
{
	char *lpszWrite;
	char *lpszCopyStart;
	char *lpszSearch;
	DWORD dwCopyLen, i;
	BOOL fNotFound;
	BOOL fValidSpace;
	char cSet[2] = { ' ', '\t' };

	// First, get rid of spaces, then TABs
	for (i = 0; i < 2; i++)
	{
		lpszWrite = lpszAddress;
		lpszCopyStart = lpszAddress;
		lpszSearch = lpszAddress;

		do
		{
			lpszCopyStart = lpszSearch;

			// Find unquoted space
			lpszSearch = pFindNextUnquotedOccurrence(lpszSearch,
								cSet[i], &fNotFound, 0);

			// We cannot just allow casual spaces; An unquoted space
			// must satisfy one or more of the following:
			// 1) Leading space
			// 2) Trailiing space
			// 3) A space or TAB is in either side or both sides of the space
			// 4) A special character is on either or both sides of the space
			if (lpszSearch)
			{
				// Make sure it satisfies the above
				fValidSpace = FALSE;
				if (lpszSearch > lpszAddress)
				{
					if (pIsSpecialOrSpace(*(lpszSearch - 1)))
						fValidSpace = TRUE;
				}
				else
					fValidSpace = TRUE;
				if (pIsSpecialOrSpace(*(lpszSearch + 1)))
					fValidSpace = TRUE;

				if (!fValidSpace)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				_ASSERT(lpszSearch >= lpszCopyStart);
				dwCopyLen = (DWORD)(lpszSearch - lpszCopyStart);
				lpszSearch++;
			}
			else
				dwCopyLen = lstrlen(lpszCopyStart);

			// 1) Leading spaces are automatically stripped!
			while (dwCopyLen--)
			{
				*lpszWrite++ = *lpszCopyStart++;
			}

		} while (lpszSearch);

		// If the reason it failed is not because it cannot find one,
		// we have a formatting error here!
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		*lpszWrite = '\0';
	}

	return(TRUE);
}

/*++
	Name :
	  pStripAddrQuotes

    Description:
	This function strips all quotes in the local part of an address.
	All quotes pairs within quotes are also collapsed.

    Arguments:	
	lpszLocalPart - Local part comes in, and comes out without quotes

    Returns:

      TRUE if quotes were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripAddrQuotes(char *lpszLocalPart, char **lpDomain)
{
	char *lpszWrite;
	char *lpszCopyStart;
	char *lpszSearch;
	DWORD dwCopyLen;
	DWORD dwState = 0;
	BOOL fNotFound;

	_ASSERT(lpDomain);
	
	// First, get rid of quotes
	lpszWrite = lpszLocalPart;
	lpszCopyStart = lpszLocalPart;
	lpszSearch = lpszLocalPart;

	do
	{
		lpszCopyStart = lpszSearch;

		// Find next quote
		lpszSearch = pFindNextUnquotedOccurrence(lpszSearch,
							'\"', &fNotFound, dwState);
		if (lpszSearch)
		{
			// Toggle the state
			dwState = (dwState)?0:QUOTE_QUOTES;

			// Found a quote, copy all the stuff before the space
			_ASSERT(lpszSearch >= lpszCopyStart);
			dwCopyLen = (DWORD)(lpszSearch - lpszCopyStart);
			lpszSearch++;

			// Move the domain offset back each time we find
			// an unquoted quote
			if (*lpDomain)
				(*lpDomain)--;
		}
		else
			dwCopyLen = lstrlen(lpszCopyStart);

		while (dwCopyLen--)
		{
			// Another caveat: since we are stripping out the
			// quotes, we must also take care of the quoted
			// pairs. That is, we must remove the backslash
			// delimiting each quoted pair.
			if (*lpszCopyStart == '\\')
			{
				// If the last char of the string is a backslash, or
				// if the backslash is not within quotes, error!
				// CAUTION: if dwState == QUOTE_QUOTES, this means
				// that the stuff we are copying is OUTSIDE of the quote,
				// since we are copying stuff before the found quote
				if ((dwState == QUOTE_QUOTES) || !dwCopyLen)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}
				lpszCopyStart++;
				dwCopyLen--;
			}
			*lpszWrite++ = *lpszCopyStart++;
		}

	} while (lpszSearch);

	*lpszWrite = '\0';

	// If the reason it failed is not because it cannot find one,
	// we have a formatting error here!
	if (!fNotFound)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// If we are left with no closing quote, then we also have an error
	if (dwState == QUOTE_QUOTES)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}
		
	return(TRUE);
}


/*++
	Name :
	  pStripUucpRoutes

    Description:
	This function strips all UUCP routing paths

    Arguments:	
	lpszAddress - lpszAddress comes in, and comes out without UUCP paths

    Returns:

      TRUE if UUCP routes were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripUucpRoutes(char *lpszAddress)
{
	char *lpszDomainOffset;
	char *lpszCopyStart;
	char *lpszSearch;
	BOOL fNotFound;

	if (!(lpszDomainOffset = pFindNextUnquotedOccurrence(lpszAddress, '@', &fNotFound, 0)))
		if (!fNotFound)
			return(FALSE);
	
	lpszSearch = lpszAddress;
	lpszCopyStart = NULL;

	// Find the last BANG
	while (lpszSearch = pFindNextUnquotedOccurrence(lpszSearch, '!', &fNotFound, 0))
	{
		// If an unquoted bang occurs after the @ sign, we will return error
		if (lpszDomainOffset && (lpszSearch > lpszDomainOffset))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		lpszCopyStart = lpszSearch++;
	}

	// If the reason is other than not found, we have an error
	if (!fNotFound)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}
		
	if (lpszCopyStart)
	{
		lpszCopyStart++;
		while (*lpszCopyStart)
			*lpszAddress++ = *lpszCopyStart++;
		*lpszAddress = '\0';
	}

	return(TRUE);
}


/*++

	Name :
		CAddr::ValidateDomainName

    Description:
		Determines whether a specified domain name is valid

    Arguments:
		lpszDomainName - ANSI domain name string to validate

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateDomainName(char *lpszDomainName)
{
	char szClean[MAX_INTERNET_NAME+1];

	_ASSERT(lpszDomainName);

	// Routine checking
	if ((!lpszDomainName) ||
		(!pValidateStringPtr(lpszDomainName, MAX_INTERNET_NAME+1)))
		return(FALSE);

	if (!pValidateAsciiString(lpszDomainName))
		return(FALSE);

	// Strip all comments
	lstrcpy(szClean, lpszDomainName);

	if (!pStripAddrComments(szClean))
		return(FALSE);

	if (!pStripAddrSpaces(szClean))
		return(FALSE);

	// Call our appropriate private
	return(pValidateLocalPartOrDomain(szClean, lstrlen(szClean), FALSE));
}

/*++

	Name :
		CAddr::ExtractCleanEmailName

    Description:
		Extracts an absolutely clean email name from an address, quotes
		are NOT stripped for the local part.

    Arguments:
		lpszCleanEmail - Pre allocated buffer to return the clean address
		ppszDomainOffset - Pointer to '@' symbol separating the local-part
		                   and the domain; NULL if not domain is specified
						   in the address.
		lpdwCleanEmailLength - Length of the whole clean email returned
		lpszSource - Source address to clean up

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ExtractCleanEmailName(	char	*lpszCleanEmail,
									char	**ppszDomainOffset,
									DWORD	*lpdwCleanEmailLength,
									char	*lpszSource)
{
	char szClean[MAX_INTERNET_NAME+1];
	char *lpDomainOffset;
	BOOL fNotFound;

    TraceFunctEnter("CAddr::ExtractCleanEmailName");

	_ASSERT(lpszSource);
	_ASSERT(lpszCleanEmail);
	_ASSERT(ppszDomainOffset);
	_ASSERT(lpdwCleanEmailLength);

	// Routine checking
	if (!lpszSource ||
		!pValidateStringPtr(lpszSource, MAX_INTERNET_NAME+1) ||
		!lpszCleanEmail ||
		IsBadWritePtr(lpszCleanEmail, MAX_INTERNET_NAME+1) ||
		!ppszDomainOffset ||
		IsBadWritePtr(ppszDomainOffset, sizeof(char *)) ||
		!lpdwCleanEmailLength ||
		IsBadWritePtr(lpdwCleanEmailLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	szClean[0] = '\0';
	if (!pValidateAsciiString(lpszSource)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	// Strip all comments and spaces
	lstrcpy(szClean, lpszSource);

	StateTrace(0, "  Source: %s", szClean);

	if (!pStripAddrComments(szClean))
		goto LeaveWithError;

	StateTrace(0, "  Comments stripped: %s", szClean);

	// Extract the clean email name in a simple local-part@domain
	// form. However, the local part may still have UUCP headers
	if (!pExtractAddress(szClean, lstrlen(szClean), lpszCleanEmail))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	StateTrace(0, "  Address: %s", lpszCleanEmail);

	// Strip comments again ...
	if (!pStripAddrComments(lpszCleanEmail)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	StateTrace(0, "  Comments stripped (2): %s", lpszCleanEmail);

	if (!pStripAddrSpaces(lpszCleanEmail)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	StateTrace(0, "  Spaces stripped: %s", lpszCleanEmail);

	// Now we examine the clean address, and try to locate the
	// local-part and the domain
	lpDomainOffset = pFindNextUnquotedOccurrence(lpszCleanEmail,
							'@', &fNotFound, 0);
	if (lpDomainOffset)
	{
		_ASSERT(lpDomainOffset >= lpszCleanEmail);
		if (lpDomainOffset == lpszCleanEmail)
		{
			// First char cannot be '@'
			SetLastError(ERROR_INVALID_DATA);
			goto LeaveWithError;
		}
	}
	else
	{
		// If it's not found, we assume there's no domain
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			goto LeaveWithError;
		}
	}

	*lpdwCleanEmailLength = lstrlen(lpszCleanEmail);
	*ppszDomainOffset = lpDomainOffset;
	TraceFunctLeave();
	return(TRUE);

LeaveWithError:
	ErrorTrace(0, "CAddr::ExtractCleanEmailName failed");
	TraceFunctLeave();
	return(FALSE);
}

/*++

	Name :
		CAddr::ValidateCleanEmailName

    Description:
		Determines whether a specified email name is valid.
		The input email name must be clean, i.e. no comments,
		spaces, routing specifiers, etc.

    Arguments:
		lpszCleanEmailName - ANSI email name string to validate
		lpszDomainOffset - Pointer to '@' sign in email string

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateCleanEmailName(	char	*lpszCleanEmailName,
									char	*lpszDomainOffset)
{
	DWORD	dwLength, dwDomainLength;

    TraceFunctEnterEx(0, "CAddr::ValidateCleanEmailName");

	_ASSERT(lpszCleanEmailName);

	if (!lpszCleanEmailName ||
		!pValidateStringPtr(lpszCleanEmailName, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	if (lpszDomainOffset)
	{
		_ASSERT(*lpszDomainOffset == '@');
		_ASSERT(lpszDomainOffset > lpszCleanEmailName);
		dwLength = (DWORD)(lpszDomainOffset - lpszCleanEmailName);
		dwDomainLength = lstrlen(lpszCleanEmailName) - dwLength - 1;
		*lpszDomainOffset++ = '\0';
	}
	else
		dwLength = lstrlen(lpszCleanEmailName);

	StateTrace(0, "  Local-part: %s", lpszCleanEmailName);

	if (!pValidateLocalPartOrDomain(lpszCleanEmailName,
									dwLength,
									TRUE))
	{
		ErrorTrace(0, "Invalid local part");
		goto LeaveWithError;
	}

	if (lpszDomainOffset)
	{
		StateTrace(0, "  Domain: %s", lpszDomainOffset);
		if (!pValidateLocalPartOrDomain(lpszDomainOffset,
									    dwDomainLength, FALSE))
		{
			ErrorTrace(0, "Invalid domain");
			goto LeaveWithError;
		}
	}

	// Restore the string ...
	if (lpszDomainOffset)
		*--lpszDomainOffset = '@';
	TraceFunctLeave();
	return(TRUE);

LeaveWithError:
	if (lpszDomainOffset)
		if (*--lpszDomainOffset == '\0')
			*lpszDomainOffset = '@';
	ErrorTrace(0, "CAddr::ValidateCleanEmailName failed");
	TraceFunctLeave();
	return(FALSE);
}


/*++

	Name :
		CAddr::ValidateEmailName

    Description:
		Determines whether a specified email name is valid

    Arguments:
		lpszEmailName - ANSI email name string to validate
		fDomainOptional - TRUE if domain is optional, FLASE forces
		                  a domain to be included.

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateEmailName(	char	*lpszEmailName,
								BOOL	fDomainOptional)
{
	char	szSource[MAX_INTERNET_NAME+1];
	char	*lpDomainOffset;
	DWORD	dwLength;

	szSource[0] = '\0';
	if (!ExtractCleanEmailName(	szSource,
								&lpDomainOffset,
								&dwLength,
								lpszEmailName))
		return(FALSE);

	if (!fDomainOptional &&	!lpDomainOffset)
		return(FALSE);

	return(ValidateCleanEmailName(szSource, lpDomainOffset));
}

/*++

	Name :
		CAddr::FindStartOfDomain

    Description:
		Finds the start of the domain part from a CLEAN email
		address. The clean address may not contain
		any comments, routing specifications, UUCP addresses,
		and the such. No validation is done for the "clean
		address".

    Arguments:
		lpszCleanEmail - ANSI CLEAN email name string whose local
						 part to extract

    Returns:
		A pointer to the '@' sign separating the local part and
		the domain. NULL if the '@' sign is not found. Note that
		'@' signs enclosed in quotes or in a proper quoted pair
		are skipped.

--*/
CHAR * CAddr::FindStartOfDomain(CHAR *lpszCleanEmail)
{
	BOOL fNotFound;

	return(pFindNextUnquotedOccurrence(lpszCleanEmail,
							'@', &fNotFound, 0));
}


//---[ CAddr::GetRFC822AddressCount ]------------------------------------------
//
//
//  Description: 
//      Counts the number of addresses in a RFC822 list of addresses.
//  Parameters:
//      IN  szAddressList       List of addresses to count
//  Returns:
//      # of recipients in list
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CAddr::GetRFC822AddressCount(char *szAddressList)
{
    DWORD   cRecips = 0;
    LPSTR   szCommentStart = szAddressList;
    LPSTR   szCommentEnd = szAddressList;
    LPSTR   szSearchStart = szAddressList;
    LPSTR   szSearchDelimiter = NULL; //ptr to delimiter
    LPSTR   szLastDelimiter = NULL; //ptr to last delimiter found
    BOOL    fSeenAlphaNum = FALSE;
    BOOL    fInQuote = TRUE;
	DWORD   dwPairs = 0;
    CHAR    chSaved = '\0';
    CHAR    *pchChanged = NULL;
    BOOL    fDelimiterNotFound = TRUE;
    CHAR    rgchDelimiters[] = {',', ';', '\0'};


    //We look for RFC822 delimiters (, or ;) that are not in comments (which 
    //are delimited by ()'s or which are in quotes.

    //No string... no recips
    if (!szAddressList)
        goto Exit;
        
    //If we have any string... we start out with 1 recip
    cRecips++;

	// First, we strip the comments
	// We call the function above to find matching parenthesis pairs
	do
	{
        //Set start of search to start of string being scanned for ()'s
        szSearchStart = szCommentStart;

		if (!pMatchParentheses(&szCommentStart, &szCommentEnd, &dwPairs))
		{
			// Failed!
            cRecips = 0;
            goto Exit;
		}
        
		if (dwPairs) //we have comments
		{
			//We found some comments
			_ASSERT(*szCommentStart == '(');
			_ASSERT(*szCommentEnd == ')');

            //If the first character of our search was a '('... then we
            //should not bother searching for delimiters
            if (szSearchStart == szCommentStart)
            {
    			szCommentStart = szCommentEnd + 1;
                continue;
            }

            //Set the end of our search for delimiters & set to NULL character
            pchChanged = szCommentStart;
            chSaved = *szCommentStart;
            *szCommentStart = '\0';

			// Reset the pointers, and match again ...
			szCommentEnd++;
			szCommentStart = szCommentEnd;
		}
		else
		{
            //We found no further comments... there is no need to save a character
            chSaved = '\0';
            pchChanged = NULL;
		}

        
        //Now we will search for unqoted delimiters in this uncommented section

        //Iterate over all the delimiters we have
        for (CHAR *pchDelimiter = rgchDelimiters; *pchDelimiter; pchDelimiter++)
        {
            szSearchDelimiter = szSearchStart;
            do
            {
                szSearchDelimiter = pFindNextUnquotedOccurrence(
                                        szSearchDelimiter, *pchDelimiter,
                                        &fDelimiterNotFound, 0);

                if (!fDelimiterNotFound)
                {
                    _ASSERT(*pchDelimiter == *szSearchDelimiter);
                    cRecips++;

                    if (szSearchDelimiter && (szSearchDelimiter > szLastDelimiter))
                        szLastDelimiter = szSearchDelimiter;
                }
                else 
                {
                    //We know we won't find anymore in this section
                    break;
                }

            //Keep on looping while we are still finding delimiters and we are not
            //at the end of the string
            } while (!fDelimiterNotFound && 
                     szSearchDelimiter && *szSearchDelimiter &&
                     *(++szSearchDelimiter));
        }

        //Restore changed character
        if (pchChanged && ('\0' != chSaved))
            *pchChanged = chSaved;

	} while (dwPairs);

    //Make sure the last delimiter was not at the end of the buffer
    if (szLastDelimiter && cRecips && *szLastDelimiter)
    {
        while (*(++szLastDelimiter))
        {
            //if it is not a space... count it as a recipient
            if (!isspace((UCHAR)*szLastDelimiter))
                goto Exit;
        }
        //Only whitespace after last delimiter... we have counted 1 too many recips
        cRecips--;
    }

  Exit:
	return cRecips;
}


//---[ IsRecipientInRFC822AddressList ]----------------------------------------
//
//
//  Description: 
//      Determines if a given recipient is in the given RFC822 formatted 
//      recipient list.
//  Parameters:
//      IN  szAddressList       Address list to check in
//      IN  szRecip             Recipient Address to check for
//  Returns:
//      TRUE if there was a match
//      FALSE if there was no match
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAddr::IsRecipientInRFC822AddressList(char *szAddressList, char *szRecip)
{
    LPSTR   szRecipEnd = NULL;
    CHAR    chSaved    = '\0';
    LPSTR   szCurrentAddress = szAddressList;
    BOOL    fFound = FALSE;
    DWORD   cbAddress;       

    if (!szAddressList || !szRecip)
        goto Exit;

    //Convert everything to lower case so we match correctly
    szCurrentAddress = szAddressList;
    do
    {
        *szCurrentAddress = (CHAR) tolower(*szCurrentAddress);
    } while(*(++szCurrentAddress));

    szCurrentAddress = szRecip;
    do 
    {
        *szCurrentAddress = (CHAR) tolower(*szCurrentAddress);
    } while(*(++szCurrentAddress));
  
    //skip past white space in recipient
    while (*szRecip && isspace((UCHAR)*szRecip))
            szRecip++;

    //Find and skip past extranious trailing whitespace
    cbAddress = strlen(szRecip);
    szRecipEnd = szRecip + cbAddress/sizeof(CHAR);
    szRecipEnd--;

    while (isspace((UCHAR)*szRecipEnd))
    {
        cbAddress--;
        szRecipEnd--;
    }

    //Make szRecipEnd point to last space
    szRecipEnd++;

    //Null terminate before trailing whitespace
    chSaved = *szRecipEnd;
    *szRecipEnd = '\0';

    //Search for addresss as substring, and see if it looks like a lone address
    for (szCurrentAddress = strstr(szAddressList, szRecip);
         szCurrentAddress && !fFound;
         szCurrentAddress = strstr(++szCurrentAddress, szRecip))
    {
        //look for surrounding characters to not match partial addresses
        //We don't want "user" to match "user1" or "user@foo" or "foo@user"
        if ((szCurrentAddress != szAddressList))
        {
            if (!pIsSpecialOrSpace(*(szCurrentAddress-1)) || 
                ('@' == *(szCurrentAddress-1)))
                continue;
        }


        if (szCurrentAddress[cbAddress/sizeof(CHAR)])
        {
            if (!pIsSpecialOrSpace(szCurrentAddress[cbAddress/sizeof(CHAR)]) ||
                ('@' == szCurrentAddress[cbAddress/sizeof(CHAR)]))
               continue;
        }

        //The address looks like a match
        fFound = TRUE;
        break;
           
    }
         
  Exit:

    //Restore saved space
    if (szRecipEnd && chSaved)
        *szRecipEnd = chSaved;

    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\smtpaddr\addr821.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

        addr821.cxx

   Abstract:

        Set of functions to parse RFC 821 addresses.

   Author:

           Keith Lau		(KeithLau)		2/17/98

   Project:

          SMTP Server DLL

   Functions Exported:
   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <windows.h>
#include <dbgtrace.h>

#include <addr821.hxx>

#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2)

// Quick and dirty string validation
static BOOL pValidateStringPtr(LPSTR lpwszString, DWORD dwMaxLength)
{
	if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
		return(FALSE);
	while (dwMaxLength--)
		if (*lpwszString++ == 0)
			return(TRUE);
	return(FALSE);
}

// ========================================================================
//
// Validation Parser stuff created by KeithLau on 2/17/98
//

static char acOpen[] =	"\"[<(";
static char acClose[] =	"\"]>)";

//
// NOTE: RFC 821 and RFC 822 versions of this function are different!!
//
// This function finds braces pairs in a given string, and returns
// pointers to the start and end of the first occurence of a
// [nested] pair of braces. The starting and ending character
// may be specified by the caller (starting and ending chars
// must be unique).
#define MAX_STATE_STACK_DEPTH		64
#define OPEN_DELIMITER				0x1
#define CLOSE_DELIMITER				0x2
#define OPEN_AND_CLOSE_DELIMITER	(OPEN_DELIMITER | CLOSE_DELIMITER)

typedef struct _BYTE_BUCKET
{
	char	cClosingDelimiter;	// If this is an open delimiter,
								// this stores the correesponding closing
								// delimiter. Not used otherwise
	BYTE	fFlags;				// Flags, whether it is a delimiter

} BYTE_BUCKET;

static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 DWORD		dwStringLength,
										 char		cSearch,
										 char		*lpszOpenDelimiters,
										 char		*lpszCloseDelimiters,
										 LPBOOL		lpfNotFound)
{
	char	rgcState[MAX_STATE_STACK_DEPTH];
	DWORD_PTR	dwState = 0;
	DWORD	dwDelimiters = 0;
	DWORD	i;
	char	ch;
	char	*lpStart = lpszString;
	BOOL	fFallThru;

	BYTE_BUCKET	rgbBucket[128];

	TraceFunctEnter("pFindNextUnquotedOccurrence");

	if (cSearch > 127)
		return(NULL);

	*lpfNotFound = FALSE;

	dwDelimiters = lstrlen(lpszOpenDelimiters);
	if (dwDelimiters != (DWORD)lstrlen(lpszCloseDelimiters))
		return(NULL);

	// Populate the bit bucket
	ZeroMemory(rgbBucket, 128 * sizeof(BYTE_BUCKET));
	for (i = 0; i < dwDelimiters; i++)
	{
		rgbBucket[lpszOpenDelimiters[i]].cClosingDelimiter = lpszCloseDelimiters[i];
		rgbBucket[lpszOpenDelimiters[i]].fFlags |= OPEN_DELIMITER;
		rgbBucket[lpszCloseDelimiters[i]].fFlags |= CLOSE_DELIMITER;
	}

	// dwState is the stack of unmatched open delimiters
	while (ch = *lpStart)
	{
		if (!dwStringLength)
			break;

		// Track the length
		dwStringLength--;

		// See if valid ASCII
		if (ch > 127)
			return(NULL);

		// If we are not in any quotes, and the char is found,
		// then we are done!
		if (!dwState && (ch == cSearch))
		{
			DebugTrace((LPARAM)0, "Found %c at %p", ch, lpStart);
			return(lpStart);
		}

		// If it is a quoted char, we can skip it and the following
		// char right away ... If the char following a quote '\' is
		// the terminating NULL, we have an error.
		if (ch == '\\')
		{
			lpStart++;
			if (!*lpStart)
				return(NULL);

			dwStringLength--;
		}
		else
		{
			// Check the close case, too
			fFallThru = TRUE;

			// See if we have an opening quote of any sort
			if (rgbBucket[ch].fFlags & OPEN_DELIMITER)
			{
				// This is used to take care of the case when the
				// open and close delimiters are the same. If it is
				// an open delimiter, we do not check the close
				// case unless the close delimiter is the same.
				fFallThru = FALSE;

				// Special case for open = close
				if (dwState &&
					rgcState[dwState-1] == ch &&
					(rgbBucket[ch].fFlags & OPEN_AND_CLOSE_DELIMITER) == OPEN_AND_CLOSE_DELIMITER)
				{
					// Stack is not empty, top of stack contains the same
					// quote, and open quote == close, this is actually a
					// close quote in disguise.
					fFallThru = TRUE;
				}
				else
				{
					// Push the new open quote in the stack
					if (dwState == MAX_STATE_STACK_DEPTH)
						return(FALSE);

					DebugTrace((LPARAM)0, "Push[%u]: %c, looking for %c",
							dwState, ch, rgbBucket[ch].cClosingDelimiter);
					rgcState[dwState++] = rgbBucket[ch].cClosingDelimiter;
				}
			}

			// See if we have a closing quote of any sort
			if (fFallThru && (rgbBucket[ch].fFlags & CLOSE_DELIMITER))
			{
				if (dwState)
				{
					// If we are closing the correct kind of quote,
					// pop the stack
					if (rgcState[dwState-1] == ch)
					{
						dwState--;
						DebugTrace((LPARAM)0, "Pop[%u] %c", dwState, ch);

						// Do a second check, in case we are looking
						// for a close quote
						if (!dwState && ch == cSearch)
						{
							DebugTrace((LPARAM)0, "Found %c at %p", ch, lpStart);
							return(lpStart);
						}
					}
					else
					{
						// Completely wrong closing brace.
						return(FALSE);
					}
				}
				else
				{
					// We are not in any quotes but we still see a
					// closing quote, so we have reached the end of our
					// current search scope!
					// Note that this is considered as not found
					// instead of an error
					*lpfNotFound = TRUE;
					return(NULL);
				}
			}
		}

		lpStart++;
	}

	*lpfNotFound = TRUE;

	TraceFunctLeave();
	return(NULL);
}

static inline BOOL IsCrOrLf(char ch)
{
	return(ch == '\r' || ch == '\n');
}

static inline BOOL IsControl(char ch)
{
	return( ((ch >= 0) && (ch <= 31)) || (ch == 127) );
}

//
//    <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
//              | "," | ";" | ":" | "@"  """ | the control
//              characters (ASCII codes 0 through 31 inclusive and
//              127)
//
static BOOL IsSpecial(char ch)
{
	switch (ch)
	{
	case '(':
	case ')':
	case '<':
	case '>':
	case '@':
	case ',':
	case ':':
	case ';':
	case '\\':
	case '\"':
	case '.':
	case '[':
	case ']':
		return(TRUE);
	default:
		return(IsControl(ch));
	}
}

static BOOL pIsSpecialOrSpace(char ch)
{
	return((ch == ' ') || (ch == '\t') || (ch == '\0') || IsSpecial(ch));

}

//
//    <x> ::= any one of the 128 ASCII characters (no exceptions)
//
static inline BOOL pIsX(char ch)
{
	return(TRUE);
}

//
//    <a> ::= any one of the 52 alphabetic characters A through Z
//              in upper case and a through z in lower case
//
static inline BOOL pIsA(char ch)
{
	return(((ch < 'A' || ch > 'z') || (ch > 'Z' && ch < 'a'))?FALSE:TRUE);
}

//
//    <d> ::= any one of the ten digits 0 through 9
//
static inline BOOL pIsD(char ch)
{
	return((ch < '0' || ch > '9')?FALSE:TRUE);
}

//
//    <c> ::= any one of the 128 ASCII characters, but not any
//              <special> or <SP>
//
static inline BOOL pIsC(char ch)
{
	return((ch == ' ' || IsSpecial(ch))?FALSE:TRUE);
}

//
//    <q> ::= any one of the 128 ASCII characters except <CR>,
//              <LF>, quote ("), or backslash (\)
//
static inline BOOL pIsQ(char ch)
{
	return((ch == '\"' || ch == '\\' || IsCrOrLf(ch))?FALSE:TRUE);
}

//
//    <number> ::= <d> | <d> <number>
//
static BOOL pValidateNumber(char *lpszStart, DWORD dwLength)
{
	if (!dwLength)
		return(FALSE);

	while (dwLength--)
	{
		if (!pIsD(*lpszStart++))
			return(FALSE);
	}
	return(TRUE);
}

//
//    <dotnum> ::= <snum> "." <snum> "." <snum> "." <snum>
//    <snum> ::= one, two, or three digits representing a decimal
//                 integer value in the range 0 through 255
//
static BOOL pValidateDotnum(char *lpszStart, DWORD dwLength)
{
	char	ch;
	DWORD	dwSnums = 0;
	DWORD	dwNumLength = 0;
	DWORD	dwValue = 0;

	if (!dwLength || dwLength > 15)
		return(FALSE);

	while (dwLength--)
	{
		ch = *lpszStart++;

		if (pIsD(ch))
		{
			// Do each digit and calculate running total
			dwValue *= 10;
			dwValue += (ch - '0');
			dwNumLength++;
		}
		else if (ch == '.')
		{
			// There must be a number before each dot and
			// the running total must be between 0 and 255
			if (!dwNumLength)
				return(FALSE);
			if (dwValue > 255)
				return(FALSE);

			// Reset the counter
			dwSnums++;
			dwValue = 0;
			dwNumLength = 0;
		}
		else
			return(FALSE);
	}

	// Do the last snum
	if (!dwNumLength)
		return(FALSE);
	if (dwValue > 255)
		return(FALSE);
	dwSnums++;

	// Each IP address must have 4 snums
	if (dwSnums != 4)
		return(FALSE);
	return(TRUE);
}

//
//    <quoted-string> ::=  """ <qtext> """
//    <qtext> ::=  "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>
//
static BOOL pValidateQuotedString(char *lpszStart, DWORD dwLength)
{
	char	ch;

	// At least 3 chars
	if (dwLength < 3)
		return(FALSE);

	// Must begin and end with double quotes
	if (lpszStart[0] != '\"' || lpszStart[dwLength-1] != '\"')
		return(FALSE);

	// Factor out the quotes
	dwLength -= 2;
	lpszStart++;

	// The inside must be <qtext>
	while (dwLength--)
	{
		ch = *lpszStart++;

		// Each character must be either an escape pair or <q>
		if (ch == '\\')
		{
			if (!dwLength)
				return(FALSE);
			dwLength--;
			lpszStart++;
		}
		else if (!pIsQ(ch))
			return(FALSE);
	}
	return(TRUE);
}

//
//    <dot-string> ::= <string> | <string> "." <dot-string>
//    <string> ::= <char> | <char> <string>
//    <char> ::= <c> | "\" <x>
//
static BOOL pValidateDotString(char *lpszStart, DWORD dwLength)
{
	char	ch;
	BOOL	fChar = FALSE;

	if (!dwLength)
		return(FALSE);

	while (dwLength--)
	{
		ch = *lpszStart++;

		if (ch == '\\')
		{
			// Escape pair
			if (!dwLength)
				return(FALSE);
			dwLength--;
			lpszStart++;
			fChar = TRUE;
		}
		else if (ch == '.')
		{
			// 1) Must not start with a dot,
			// 2) Consecutive dots are not allowed
			if (!fChar)
				return(FALSE);

			// Reset the flag
			fChar = FALSE;
		}
		else if (pIsC(ch))
			fChar = TRUE;
		else
			return(FALSE);
	}

	// Cannot end with a dot
	if (ch == '.')
		return(FALSE);
	return(TRUE);
}

//
// Note: Original RFC 821:
//    <name> ::= <a> <ldh-str> <let-dig>
//    <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
//    <let-dig> ::= <a> | <d>
//    <let-dig-hyp> ::= <a> | <d> | "-"
//
// Our implementation:
//    <name> ::= <let-dig-hyp-und> | <let-dig-hyp-und> <name>
//    <let-dig-hyp-und> ::= <a> | <d> | "-" | "_"
//
// Reasons:
// 1) 3COM start their domains with a digit
// 2) Some customers start their domain names with underscores,
//    and some comtain underscores.
//
static BOOL pValidateName(char *lpszStart, DWORD dwLength)
{
	char	ch;

	if (!dwLength)
		return(FALSE);

	while (dwLength--)
	{
		ch = *lpszStart++;

		if (pIsA(ch) || pIsD(ch) || ch == '-' || ch == '_')
			;
		else
			return(FALSE);
	}
	return(TRUE);
}

//
//    <local-part> ::= <dot-string> | <quoted-string>
//
static BOOL pValidateLocalPart(char *lpszStart, DWORD dwLength)
{
	if (!dwLength)
		return(FALSE);

	return(pValidateDotString(lpszStart, dwLength) ||
			pValidateQuotedString(lpszStart, dwLength));
}

//
//    <element> ::= <name> | "#" <number> | "[" <dotnum> "]"
//
static BOOL pValidateElement(char *lpszStart, DWORD dwLength)
{
	char	ch;

	if (!dwLength)
		return(FALSE);

	ch = *lpszStart;
	if (ch == '#')
		// This is the # <number> form
		return(pValidateNumber(lpszStart+1, dwLength-1));
	else if (ch == '[')
	{
		if (lpszStart[dwLength-1] != ']')
			return(FALSE);

		// This is a domain literal
		return(pValidateDotnum(lpszStart+1, dwLength-2));
	}

	// Validate as a name
	return(pValidateName(lpszStart, dwLength));
}

//
//  sub-domain ::= let-dig *(ldh-str)
//  ldh-str = *( Alpha / Digit / "-" ) let-dig
//	let-dig = Alpha / Digit
//
static BOOL pValidateDRUMSSubDomain(char *lpszStart, DWORD dwLength)
{
	unsigned char	ch;
    DWORD ec;
	if (!dwLength)
		return(FALSE);

	// validate all of the characters in the name
	while (dwLength--)
	{
		ch = (unsigned char) *lpszStart++;
        // this list of characters comes from NT, dnsvldnm.doc.  we
        // also allow #, [, and ]
        if ((ch >= 1 && ch <= 34) ||
            (ch >= 36 && ch <= 41) ||
            (ch == 43) ||
            (ch == 44) ||
            (ch == 47) ||
            (ch >= 58 && ch <= 64) ||
            (ch == 92) ||
            (ch == 94) ||
            (ch == 96) ||
            (ch >= 123))
        {
            return FALSE;
        }
	} //while

	//We have a valid subdomain
	return (TRUE);
}

//
// ======================================================
//

BOOL FindNextUnquotedOccurrence(char	*lpszString,
                                DWORD	dwStringLength,
                                char	cSearch,
                                char	**ppszLocation)
{
    BOOL fNotFound = FALSE;
    *ppszLocation = pFindNextUnquotedOccurrence(lpszString,
                                    dwStringLength,cSearch, acOpen,acClose, &fNotFound);

    if (!*ppszLocation)
    {
            // If failed but not because of not found, then bad line
            if (!fNotFound)
            {
                SetLastError(ERROR_INVALID_DATA);
                return FALSE;
            }
    }
    return TRUE;

}

//
// This function extracts an email address from the given command line
// and returns the tail of the line after the address. Any angle braces
// present will be included as part of the 821 address. The returned
// address is not validated at all.
//
BOOL Extract821AddressFromLine(	char	*lpszLine,
								char	**ppszAddress,
								DWORD	*pdwAddressLength,
								char	**ppszTail)
{
	DWORD	dwAddressLength = 0;
	char	*pAddressEnd;
	BOOL	fNotFound;

    TraceFunctEnter("Extract821AddressFromLine");

	_ASSERT(lpszLine);
	_ASSERT(ppszAddress);
	_ASSERT(pdwAddressLength);
	_ASSERT(ppszTail);

	// Initialize
	*ppszAddress = lpszLine;
	*pdwAddressLength = 0;
	*ppszTail = lpszLine;

	// Routine checking
	if (!lpszLine ||
		 // Big enough for MAX_INTERNET_NAME + any options on mail from/rcpt to
		!pValidateStringPtr(lpszLine, MAX_INTERNET_NAME + 2000) ||
		!ppszAddress ||
		IsBadWritePtr(ppszAddress, sizeof(char *)) ||
		!ppszTail ||
		IsBadWritePtr(ppszTail, sizeof(char *)) ||
		!pdwAddressLength ||
		IsBadWritePtr(pdwAddressLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}

	// Skip all leading spaces
	while (*lpszLine == ' ')
		lpszLine++;

	// The first unquoted space indicates the end of the address
	pAddressEnd = pFindNextUnquotedOccurrence(lpszLine,
						lstrlen(lpszLine), ' ', acOpen, acClose, &fNotFound);
	if (!pAddressEnd)
	{
		// If failed but not because of not found, then bad line
		if (!fNotFound)
			return(FALSE);

		// Space not found, the entire line is the address
		dwAddressLength = lstrlen(lpszLine);
		pAddressEnd = lpszLine + dwAddressLength;
		*ppszTail = pAddressEnd;
	}
	else
	{
		// Calculate the length
		dwAddressLength = (DWORD)(pAddressEnd - lpszLine);

		// Get the start of the tail, after all the spaces
		while (*pAddressEnd == ' ')
			pAddressEnd++;
		*ppszTail = pAddressEnd;
	}

	if (dwAddressLength < 1 || dwAddressLength > MAX_INTERNET_NAME)
		return(FALSE);

	*ppszAddress = lpszLine;
	*pdwAddressLength = dwAddressLength;

	DebugTrace((LPARAM)0, "Extracted \"%*s\"", dwAddressLength, lpszLine);

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a RFC 821 address with optional angle braces
// and extracts the canonical form of the address. All at-domain-list
// entries are removed. Angle braces will be matched and removed.
// Mismatched angle braces are considered invalid. The returned address
// will be in the <local-part> "@" <domain> form.
//
// There must be no leading or trailing spaces included.
//
// jstamerj 1999/01/13 14:02:13: Modified to remove a trailing '.' from the <domain> portion of the address
//
BOOL ExtractCanonical821Address(	char	*lpszAddress,
									DWORD	dwAddressLength,
									char	**ppszCanonicalAddress,
									DWORD	*pdwCanonicalAddressLength)
{
	char	*pAddressStart;
	BOOL	fNotFound;

    TraceFunctEnter("ExtractCanonical821Address");

	_ASSERT(lpszAddress);
	_ASSERT(ppszCanonicalAddress);
	_ASSERT(pdwCanonicalAddressLength);

	// Initialize
	*ppszCanonicalAddress = lpszAddress;
	*ppszCanonicalAddress = 0;

	// Routine checking
	if (!lpszAddress ||
		 // Big enough for MAX_INTERNET_NAME + any options on mail from/rcpt to
		!pValidateStringPtr(lpszAddress, MAX_INTERNET_NAME + 2000) ||
		!ppszCanonicalAddress ||
		IsBadWritePtr(ppszCanonicalAddress, sizeof(char *)) ||
		!pdwCanonicalAddressLength ||
		IsBadWritePtr(pdwCanonicalAddressLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}

	// See how many layers of nesting we have, and match
	// each pair of angle braces
	while (*lpszAddress == '<')
	{
		if (!dwAddressLength--)
			return(FALSE);

		if (lpszAddress[dwAddressLength] != '>')
			return(FALSE);

		if (!dwAddressLength--)
			return(FALSE);

		lpszAddress++;
	}


	// Next, skip all at-domain-list entries and get to
	// the meat of the address
	do
	{
		// Skip all leading spaces
		while (*lpszAddress == ' ')
		{
			lpszAddress++;
			if (!dwAddressLength--)
				return(FALSE);
		}

		//skip all the trailing spaces
		while (*(lpszAddress + dwAddressLength - 1) == ' ')
		{
			if (!dwAddressLength--)
				return(FALSE);
		}


		// Initialize lest it falls through right away
		pAddressStart = lpszAddress;

		if (*lpszAddress == '@')
		{
			// Yep, there's a domain route there ...
			// Skip it ...
			pAddressStart = pFindNextUnquotedOccurrence(lpszAddress,
								dwAddressLength, ',', acOpen, acClose, &fNotFound);
			if (!pAddressStart)
			{
				if (!fNotFound)
					return(FALSE);

				// No comma, now see if we get a semicolon
				pAddressStart = pFindNextUnquotedOccurrence(lpszAddress,
									dwAddressLength, ':', acOpen, acClose, &fNotFound);
				if (!pAddressStart)
				{
					// No semicolon either, this is a bad address
					return(FALSE);
				}

				// This is a semicolon, so we break out
				pAddressStart++;
				dwAddressLength -= (DWORD)(pAddressStart - lpszAddress);
				break;
			}

			// We have a comma, we let it iterate
			pAddressStart++;
			dwAddressLength -= (DWORD)(pAddressStart - lpszAddress);

			lpszAddress = pAddressStart;
		}
		else
			break;

	} while (dwAddressLength);

	// Skip all leading spaces
	while (*pAddressStart == ' ')
	{
		pAddressStart++;
		if (!dwAddressLength--)
			return(FALSE);
	}
    if((dwAddressLength > 1) && // Must be at least 2 for the address "@."
       (pAddressStart[dwAddressLength-1] == '.')) {
        //
        // jstamerj 1999/01/13 14:05:39:
        //  If the domain part of the address has a trailing '.', do
        //  not count it in the canonical length
        //
        LPSTR pDomain;
        BOOL fNotFound;
        // Find the domain
        pDomain = pFindNextUnquotedOccurrence(
            pAddressStart,
            dwAddressLength - 1,
            '@',
            acOpen,
            acClose,
            &fNotFound);
        //
        // If we found the '@' and the '.' is after the '@' (it must
        // be if we really found it), then shorten the canonical
        // address so that it doesn't include '.'
        //
        if((fNotFound == FALSE) &&
           (&(pAddressStart[dwAddressLength]) > pDomain))
            dwAddressLength--;
    }

	if (dwAddressLength < 1 || dwAddressLength > MAX_INTERNET_NAME)
		return(FALSE);

	// Fill in the output
	*ppszCanonicalAddress = pAddressStart;
	*pdwCanonicalAddressLength = dwAddressLength;

	DebugTrace((LPARAM)0, "Extracted \"%*s\"", dwAddressLength, pAddressStart);

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a RFC 821 domain in canonical form
// and validates it according to the RFC 821 grammar
// (some modifications for real-life scenarios)
//
// <domain> ::=  <element> | <element> "." <domain>
//
BOOL Validate821Domain(	char	*lpszDomain,
						DWORD	dwDomainLength)
{
	char	*pSubdomainOffset;
	DWORD	dwSubdomainLength;
	BOOL	fNotFound;

    TraceFunctEnter("Validate821Domain");

	_ASSERT(lpszDomain);

	// Routine checking
	if (!lpszDomain ||
		!pValidateStringPtr(lpszDomain, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}

	// Find each subdomain
	do
	{
		pSubdomainOffset = pFindNextUnquotedOccurrence(lpszDomain,
							dwDomainLength,  '.', acOpen, acClose, &fNotFound);
		if (!pSubdomainOffset)
		{
			if (!fNotFound)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Not found and nothing left, domain ends with a dot, invalid.
			if (!dwDomainLength)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// No domain, so email alias is all there is
			dwSubdomainLength = dwDomainLength;
		}
		else
		{
			// Calculate domain parameters
			dwSubdomainLength = (DWORD)(pSubdomainOffset - lpszDomain);

			// Adjust for the dot
			dwDomainLength--;
		}

		// Cannot allow leading dot or consecutive dots
		if (!dwSubdomainLength)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// Check each subdomain as an element
		if (!pValidateElement(lpszDomain, dwSubdomainLength))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// Adjust the length and pointers
		dwDomainLength -= dwSubdomainLength;

		// Skip past dot and scan again
		lpszDomain = pSubdomainOffset + 1;

	} while (dwDomainLength);

	// Make sure no dot's found, either
	if (!fNotFound)
	{
		// If a dot's found, the domain ends with a dot and it's uncool.
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a DRUMS domain in canonical form
// and validates it strictly, according to the DRUMS grammar
//
// Domain ::= sub-domain 1*("." sub-domain) | address-literal
//   address-literal ::= "[" IPv4-address-literal |
//                  IPv6-address-literal | General-address-literal "]"
//   IPv4-address-literal ::= snum 3("." snum)
//   IPv6-address-literal ::= "IPv6" SP <<what did we finally decide on?>>
//   General-address-literal ::= Standardized-tag SP String
//   Standardized-tag ::= String (Specified in a standards-track RFC
//                                and registered with IANA)
//   snum = one, two, or three digits representing a decimal
//     integer value in the range 0 through 255

BOOL ValidateDRUMSDomain(	char	*lpszDomain,
                            DWORD   dwDomainLength)
{

	char	*pSubdomainOffset;
	DWORD	dwSubdomainLength;
	BOOL	fNotFound;
	char    *szEndofString;

    TraceFunctEnter("Validate821Domain");

	_ASSERT(lpszDomain);

	// Routine checking
	if (!dwDomainLength || dwDomainLength > MAX_INTERNET_NAME)
			return(FALSE);

	if (!lpszDomain ||
		!pValidateStringPtr(lpszDomain, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}

	// Skip all leading spaces
	while (*lpszDomain == ' ')
        lpszDomain++;

	//It has to be either in address-literal format or subdomain format
	//
	if (*lpszDomain == '[')
	{
		//It is an Address literal
		//Skip trailing white space
		szEndofString = &lpszDomain[lstrlen(lpszDomain) - 1];
		while(*szEndofString == ' ')
			szEndofString--;

		if (*szEndofString != ']')
			return(FALSE);

		// This is a domain literal
		return(pValidateDotnum(lpszDomain+1, dwDomainLength-2));
	}
	else
	{
		//This is in subdomain format
		do
		{
			pSubdomainOffset = pFindNextUnquotedOccurrence(lpszDomain,
								dwDomainLength,  '.', acOpen, acClose, &fNotFound);
			if (!pSubdomainOffset)
			{
				if (!fNotFound)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				// Not found and nothing left, domain ends with a dot, invalid.
				if (!dwDomainLength)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				// No domain, so email alias is all there is
				dwSubdomainLength = dwDomainLength;
			}
			else
			{
				// Calculate domain parameters
				dwSubdomainLength = (DWORD)(pSubdomainOffset - lpszDomain);

				// Adjust for the dot
				//NimishK : **Check with Keith if this should be subdomain.
				dwDomainLength--;
			}

			// Cannot allow leading dot or consecutive dots
			if (!dwSubdomainLength)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Check each subdomain
			if (!pValidateDRUMSSubDomain(lpszDomain, dwSubdomainLength))
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Adjust the length and pointers
			dwDomainLength -= dwSubdomainLength;

			// Skip past dot and scan again
			lpszDomain = pSubdomainOffset + 1;

		} while (dwDomainLength);

		// Make sure no dot's found, either
		if (!fNotFound)
		{
			// If a dot's found, the domain ends with a dot and it's uncool.
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		TraceFunctLeave();
		return(TRUE);

	}

	TraceFunctLeave();
	return(TRUE);
}


//
// This function takes in a RFC 821 address in canonical form
// (<local-part> ["@" <domain>]) and validates it according to the
// RFC 821 grammar (some modifications for real-life scenarios)
//
BOOL Validate821Address(	char	*lpszAddress,
							DWORD	dwAddressLength)
{
	char	*pDomainOffset;
	DWORD	dwEmailLength;
	DWORD	dwDomainLength;
	BOOL	fNotFound;

    TraceFunctEnter("Validate821Address");

	_ASSERT(lpszAddress);

	// Routine checking
	if (!lpszAddress ||
		!pValidateStringPtr(lpszAddress, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}

	// Find the domain
	pDomainOffset = pFindNextUnquotedOccurrence(lpszAddress,
						dwAddressLength, '@', acOpen, acClose, &fNotFound);
	if (!pDomainOffset)
	{
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// No domain, so email alias is all there is
		dwEmailLength = dwAddressLength;
	}
	else
	{
		// Calculate domain parameters
		dwEmailLength = (DWORD)(pDomainOffset - lpszAddress);
		dwDomainLength = dwAddressLength - dwEmailLength - 1;
		pDomainOffset++;
	}

	// Do the check for email name
	if (!pValidateLocalPart(lpszAddress, dwEmailLength))
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// Now check domain, if applicable
	if (pDomainOffset)
	{
		return(Validate821Domain(pDomainOffset, dwDomainLength));
	}

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a RFC 821 address in canonical form
// (<local-part> ["@" <domain>]) and extracts the domain part
//
BOOL Get821AddressDomain(	char	*lpszAddress,
							DWORD	dwAddressLength,
							char	**ppszDomain)
{
    char	*pDomainOffset;
    BOOL	fNotFound       = FALSE;
    BOOL    fReturn         = TRUE;

    TraceFunctEnter("Get821AddressDomain");

    _ASSERT(lpszAddress);

    // Find the domain
    pDomainOffset = pFindNextUnquotedOccurrence(lpszAddress,
                        dwAddressLength, '@', acOpen, acClose, &fNotFound);
    if (!pDomainOffset && !fNotFound)
    {
        SetLastError(ERROR_INVALID_DATA);
        fReturn = FALSE;
        goto Exit;
    }

    if (fNotFound)
    {
        *ppszDomain = NULL;
        goto Exit;
    }

    *ppszDomain = pDomainOffset + 1;

    // Validate that the domain part is <= 255 chars
    if ((dwAddressLength - (*ppszDomain - lpszAddress)) > 255)
    {
        *ppszDomain = NULL;
        SetLastError(ERROR_INVALID_DATA);
        fReturn = FALSE;
        goto Exit;
    }

Exit:
    TraceFunctLeave();
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\snprfdll\exprfdll.h ===
/*==========================================================================*\

    Module:        exprfdll.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the declaration for exprfdll, a perf dll. This
                   is for the dll that runs in perfmon. It supports multiple
                   libraries (monitored services.)
    
\*==========================================================================*/

#ifndef _exprfdll_h_
#define _exprfdll_h_

#include "snprflib.h"

///////////////////////////////////////////////////////////////////////////////
//
// Misc defines
//
///////////////////////////////////////////////////////////////////////////////
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) (((x+sizeof(QWORD)-1)/sizeof(QWORD))*sizeof(QWORD))
#define MAX_PERF_LIBS 8

#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


///////////////////////////////////////////////////////////////////////////////
//
// Declare utility functions
//
///////////////////////////////////////////////////////////////////////////////

//
// Figure out the query type of the perf request
//
DWORD GetQueryType (LPWSTR lpValue);

//
// Determines if a number is in a space delimited unicode string.
//   this is used to parse the request to see which object counters are
//   asked for.
//
BOOL IsNumberInUnicodeList (DWORD dwNumber, LPCWSTR lpwszUnicodeList);


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectData defines the data retrieved from the shared memory for
//      each perf object exposed by a library (see PerfLibraryData below)
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectData
{   
private:
    //
    // Internal variables
    //
    BOOL                        m_fObjectRequested;
    DWORD                       m_dwSpaceNeeded;
    
    //
    // These are pointers to things inside the shared memory...
    //
    // First the object definition
    PERF_OBJECT_TYPE*           m_pObjType;

    // Array of counter defintions
    PERF_COUNTER_DEFINITION*    m_prgCounterDef;

    // Pointer to a dword that tells the size of the counter data
    //   (PERF_COUNTER_BLOCK + all the counter values)
    DWORD*                      m_pdwCounterData;

    // The following point to the actual data for the counters...
    //   use pCounterBlock for numInst == -1, else use m_pbCounterBlockTotal for
    //   the first instanced counters (_Total)
    PERF_COUNTER_BLOCK*         m_pCounterBlock;
    PBYTE                       m_pbCounterBlockTotal;

    // This points to the first shared memory mapping.
    SharedMemorySegment*        m_pSMS;

    // These tell us how many instances can be stored in each mapping.
    DWORD                       m_dwInstancesPerMapping;
    DWORD                       m_dwInstances1stMapping;

    // This is the length of the object definition in the first mapping.
    DWORD                       m_dwDefinitionLength;

    // Keep the object name around to create more named mappings when needed.
    WCHAR                       m_wszObjectName[MAX_OBJECT_NAME];
    
public:
    PerfObjectData();
    ~PerfObjectData();

    BOOL GetPerformanceStatistics (LPCWSTR pcwstrObjectName);
    DWORD SpaceNeeded (DWORD, LPCWSTR pcwstrObjects);
    void SavePerformanceData (VOID**, DWORD*, DWORD*);
    void CopyInstanceData(PBYTE pb, INSTANCE_DATA *pInst);

    void AddToTotal (
        PERF_COUNTER_BLOCK *pcbTotalCounter,
        PERF_COUNTER_BLOCK *pcbInstCounter);

    void Close (void);
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibraryData is data from the shared memory about a single perf library.
//
///////////////////////////////////////////////////////////////////////////////
class PerfLibraryData
{
private:    
    //
    // Handle and pointer for the shared memory
    //
    HANDLE              m_hShMem;
    PBYTE               m_pbShMem;

    // Data from the shared memory
    DWORD               m_dwObjects;
    OBJECTNAME*         m_prgObjectNames;

    // Data for each of the objects exposed by the library
    PerfObjectData      m_rgObjectData[MAX_PERF_OBJECTS];

    
public: 
    // Methods for dealing with the library data
    PerfLibraryData();
    ~PerfLibraryData();
    
    BOOL GetPerformanceStatistics (LPCWSTR pcwstrLibrary);
    DWORD SpaceNeeded (DWORD, LPCWSTR pcwstrObjects);
    void SavePerformanceData (VOID**, DWORD*, DWORD*);
    void Close (void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\staxmem\exchmem.c ===
/*
 -	E X C H M E M . C
 -
 *	Purpose:
 *		
 *
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#define _CRTIMP __declspec(dllexport)
#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

#ifdef DEBUG
#include <imagehlp.h>
#endif

#include <limits.h>
#include <exchmem.h>
#include "_exchmem.h"
#include "excpt.h"
#include "io.h"

#ifndef	DEBUG
#define	USEMPHEAP
#endif

#ifdef USEMPHEAP
#include <mpheap.h>
#endif

//	Global heap assigned to the process by NT

HANDLE					hProcessHeap		= NULL;
#ifdef USEMPHEAP
HANDLE					hMpHeap				= NULL;
ULONG					cRefHeap			= -1;
#else
LPHEAPTBL				pheaptbl			= NULL;
CRITICAL_SECTION		csMHeap;
#endif
DWORD					tlsiHeapHint		= 0;

//	Debug Support for leak detection and memory usage tracking.

#ifdef DEBUG

static HMODULE			hMod;
static HINSTANCE		hinstRunTime		= NULL;
static BOOL				fDbgEnable			= FALSE;
static BOOL				fCallStacks			= FALSE;
static BOOL				fSymInitialize		= FALSE;
static BOOL				fProcessIsService	= FALSE;

static LPFMALLOC		pfMalloc			= NULL;
static LPFREALLOC		pfRealloc			= NULL;
static LPFFREE			pfFree				= NULL;
static LPFCALLOC		pfCalloc			= NULL;
static LPFSTRDUP		pfStrDup			= NULL;
static LPFMEMSIZE		pfMemSize			= NULL;

static BOOL				fAssertLeaks		= FALSE;
static BOOL				fDumpLeaks			= FALSE;
static BOOL				fDumpLeaksDebugger	= FALSE;
static BOOL				fUseVirtual			= FALSE;
static ULONG			cbVirtualAlign		= 1;
static BOOL				fFailuresEnabled	= FALSE;
static BOOL				fHeapMonitorUI		= FALSE;
static BOOL				fOverwriteDetect	= FALSE;
static BOOL				fValidateMemory		= FALSE;
static BOOL				fTrackFreedMemory	= FALSE;
static DWORD			cEntriesFree		= 512;
static BOOL				fAssertValid		= FALSE;
static BOOL				fTrapOnInvalid		= FALSE;
static BOOL				fSymbolLookup		= FALSE;

static BOOL				fFillMemory			= FALSE;
static BYTE				chAllocFillByte		= chDefaultAllocFill;
static BYTE				chFreeFillByte		= chDefaultFreeFill;

static BOOL				fTrackMem			= FALSE;
static DWORD			cFrames				= 0;
static FILE *			hTrackLog			= NULL;
static CRITICAL_SECTION	csTrackLog;
static char				rgchExeName[16];
static char				rgchLogPath[MAX_PATH];
BOOL					fChangeTrackState 	= FALSE;

static ULONG			iAllocationFault	= 0;

#define NBUCKETS		8192
#define UlHash(_n)		((ULONG)(((_n & 0x000FFFF0) >> 4) % NBUCKETS))

typedef struct _symcache
{
	DWORD_PTR	dwAddress;
	DWORD_PTR	dwOffset;
	CHAR		rgchSymbol[248];
	
} SYMCACHE, * PSYMCACHE;

static PSYMCACHE		rgsymcacheHashTable = NULL;

static CRITICAL_SECTION	csHeapList;
static PHEAP			pheapList			= NULL;
CHAR * PszGetSymbolFromCache(DWORD_PTR dwAddress, DWORD_PTR * pdwOffset);
VOID AddSymbolToCache(DWORD_PTR dwAddress, DWORD_PTR dwOffset, CHAR * pszSymbol);
BOOL FTrackMem();
VOID StartTrace(BOOL fFresh);
VOID StopTrace();

typedef struct
{
	WORD wApi;
	DWORD_PTR rgdwCallStack[32];
	DWORD_PTR rgdwArgs[5];
	DWORD dwTickCount;
	DWORD dwThreadId;
} MEMTRACE;
MEMTRACE * 	rgmemtrace 			= NULL;
DWORD 		dwmemtrace 			= 0;
DWORD		dwTrackMemInMem		= 0;

#endif	// DEBUG


/*
 -	DllMain
 -
 *	Purpose:
 *		Entry point called by CRT entry point.
 *
 */

BOOL
APIENTRY
DllMain(
	HANDLE hModule,
	DWORD dwReason,
	LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);
#ifdef USEMPHEAP
		tlsiHeapHint = TlsAlloc();
#else
		//	Init the CS that protects access to the
		//	global Multiple Heap data structs.
		
		InitializeCriticalSection(&csMHeap);

		//	Now, if Debug build then do a lot of initialization
		//	including creating a debug process heap.  If not
		//	Debug, then just get the ProcessHeap from system.
#endif		
#ifdef DEBUG
		InitDebugExchMem(hModule);
#else
		hProcessHeap = GetProcessHeap();
#endif	
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef USEMPHEAP
		TlsFree(tlsiHeapHint);
#else
		//	Delete the Multiple Heap CS
		
		DeleteCriticalSection(&csMHeap);
#endif		
		//	Tear-down our Debug support
		
#ifdef DEBUG
		UnInitDebugExchMem();
#endif	
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
//	The Handle based ExchMem APIs
//-----------------------------------------------------------------------------

HANDLE
WINAPI
ExchHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
#ifndef DEBUG
	if (dwFlags & HEAP_NO_FREE)
		dwFlags &= ~(HEAP_NO_FREE);
#endif

	return ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize);
}
	
	
BOOL
WINAPI
ExchHeapDestroy(
	HANDLE	hHeap)
{
	return ExHeapDestroy(hHeap);
}
	

LPVOID
WINAPI
ExchHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize)
{
	return ExHeapAlloc(hHeap, dwFlags, dwSize);
}
	
	
LPVOID
WINAPI
ExchHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize)
{
	if (!pvOld)
		return ExchHeapAlloc(hHeap, dwFlags, dwSize);
		
	return ExHeapReAlloc(hHeap, dwFlags, pvOld, dwSize);
}
	
	
BOOL
WINAPI
ExchHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree)
{
	return ExHeapFree(hHeap, dwFlags, pvFree);
}


SIZE_T
WINAPI
ExchHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags)
{
	return ExHeapCompact(hHeap, dwFlags);
}


BOOL
WINAPI
ExchHeapLock(
	HANDLE hHeap)
{
	return ExHeapLock(hHeap);
}


BOOL
WINAPI
ExchHeapUnlock(
	HANDLE hHeap)
{
	return ExHeapUnlock(hHeap);
}


BOOL
WINAPI
ExchHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry)
{
	return ExHeapWalk(hHeap, lpEntry);
}


SIZE_T
WINAPI
ExchHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	return ExHeapSize(hHeap, dwFlags, lpMem);
}


BOOL
WINAPI
ExchHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	return ExHeapValidate(hHeap, dwFlags, lpMem);
}


//-----------------------------------------------------------------------------
//	The Multiple Heap APIs
//-----------------------------------------------------------------------------


HANDLE
WINAPI
ExchMHeapCreate(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
#ifndef	USEMPHEAP
	HANDLE		hheap0;
	HANDLE *	phHeaps;
	ULONG		iHeap;

	EnterCriticalSection(&csMHeap);
	
	//	Called twice?  The first person in gets to set the number
	//	of heaps in the table.  Subsequent calls result in an AddRef
	//	to the current table and this table is returned to the caller.

	if (pheaptbl)
	{
		pheaptbl->cRef++;
		goto ret;
	}

	//	If they didn't specify or they asked for too few then we'll set this
	
	if (cHeaps == 0)
		cHeaps = cHeapsDef;

	hheap0 = ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize);

	if (!hheap0)
	{
		DebugTrace("Failed to create initial heap for MHeap APIs!\n");
		goto ret;
	}

	pheaptbl = (LPHEAPTBL)ExHeapAlloc(hheap0, 0,
			sizeof(HEAPTBL) + (cHeaps-1)*sizeof(HANDLE));

	if (!pheaptbl)
	{
		DebugTrace("Failed to allocate MHeap Table for MHeap APIs!\n");
		ExHeapDestroy(hheap0);
		goto ret;
	}

	memset(pheaptbl, 0, sizeof(HEAPTBL) + (cHeaps-1)*sizeof(HANDLE));
	
	pheaptbl->cRef			= 1;
	pheaptbl->cHeaps		= cHeaps;
	pheaptbl->rghheap[0]	= hheap0;

	//	Now, create the remaining heaps for the table.
	
	for (iHeap = 1, phHeaps = &pheaptbl->rghheap[1]; iHeap < cHeaps; iHeap++, phHeaps++)
	{
		if (!(*phHeaps = ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize)))
		{
			DebugTrace("Failed to create additional heaps for MHeap APIs!\n");
			ExchMHeapDestroy();
			goto ret;
		}
	}

ret:
	LeaveCriticalSection(&csMHeap);

	return (HANDLE)pheaptbl;

#else
	//	Called twice?  The first person in gets to set the number
	//	of heaps in the table.  Subsequent calls result in an AddRef
	//	to the current table and this table is returned to the caller.

	if (InterlockedIncrement(&cRefHeap) != 0)
	{
		Assert(hMpHeap);
		return hMpHeap;
	}
	else
	{
		//
		//	NB: MpHeap doesn't support max size of heap.
		//
		return hMpHeap = MpHeapCreate(dwFlags, dwInitialSize, cHeaps);
	}
#endif
	
}
	
	
BOOL
WINAPI
ExchMHeapDestroy(void)
{
#ifndef	USEMPHEAP
	HANDLE		hHeap;
	ULONG		iHeap;

	EnterCriticalSection(&csMHeap);
	
	//	If we are called too many times, we'll complain in the
	//	Debug build, but otherwise, just return successfully!
	
	if (!pheaptbl)
	{
		DebugTrace("ExchMHeapDestroy called on invalid heap table!\n");
		goto ret;
	}
	
	//	When our RefCount goes to zero, we tear-down the MHeap Table.
	
	if (--pheaptbl->cRef == 0)
	{
		for (iHeap = pheaptbl->cHeaps-1; iHeap > 0; iHeap-- )
		{
			if (hHeap = pheaptbl->rghheap[iHeap])
				ExHeapDestroy(hHeap);
		}

		hHeap = pheaptbl->rghheap[0];
		ExHeapFree(hHeap, 0, pheaptbl);
		ExHeapDestroy(hHeap);
		pheaptbl = NULL;
	}

ret:
	LeaveCriticalSection(&csMHeap);

	return TRUE;
#else
	BOOL fRet = 1;

	if (hMpHeap)
	{
		//
		//	On last terminate blow away the heap.
		//
		if (InterlockedDecrement(&cRefHeap) < 0)
		{
			fRet = MpHeapDestroy(hMpHeap);
			hMpHeap = NULL;
		}
	}

	return fRet;
#endif
}


//DWORD GetRetAddr(void)
//{
//	DWORD *	pdwStack;	
//
//	__asm mov pdwStack, ebp
//
//	pdwStack = (DWORD *)*pdwStack;
//	pdwStack = (DWORD *)*pdwStack;
//
//	return *(pdwStack + 1);
//}


LPVOID
WINAPI
ExchMHeapAlloc(
	DWORD	dwSize)
{
#ifdef	USEMPHEAP
	return MpHeapAlloc(hMpHeap, 0, dwSize);
#else
	HANDLE		hheap;
	LPVOID		pv;

	hheap = pheaptbl->rghheap[GetCurrentThreadId() & (pheaptbl->cHeaps-1)];

    //Raid X5:195963 We never want to allocate/reallocate 
    //less memory than what we have been requested.
    if (dwSize + cbMHeapHeader < dwSize) {
        DebugTrace("Trying to allocate a negative amount of memory!\n");
        return NULL;
    }

	pv = ExHeapAlloc(hheap, 0, dwSize + cbMHeapHeader);
	
	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapAlloc failed to allocate a new block!\n");
		return NULL;
	}

	*(HANDLE *)pv = hheap;

	return MHeapPvFromPv(pv);
#endif
}
	
LPVOID
WINAPI
ExchMHeapAllocDebug(
			   DWORD	dwSize, char *szFile, DWORD dwLine)
{
#ifdef	USEMPHEAP
	return MpHeapAlloc(hMpHeap, 0, dwSize);
#else
	HANDLE		hheap;
	LPVOID		pv;

	hheap = pheaptbl->rghheap[GetCurrentThreadId() & (pheaptbl->cHeaps-1)];

    //Raid X5:195963 We never want to allocate/reallocate 
    //less memory than what we have been requested.
    if (dwSize + cbMHeapHeader < dwSize) {
        DebugTrace("Trying to allocate a negative amount of memory!\n");
        return NULL;
    }

	pv = ExHeapAlloc(hheap, 0, dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapAlloc failed to allocate a new block!\n");
		return NULL;
	}

	*(HANDLE *)pv = hheap;

	if (fDbgEnable)
	{
		HeapSetName2(hheap, pv, "File: %s, Line: %d", szFile, dwLine);
	}

	return MHeapPvFromPv(pv);
#endif
}


LPVOID
WINAPI
ExchMHeapReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize)
{
#ifdef	USEMPHEAP
	return MpHeapReAlloc(hMpHeap, pvOld, dwSize);
#else
	LPVOID		pv;

    //Raid X5:195963 We never want to allocate/reallocate 
    //less memory than what we have been requested.
    if (dwSize + cbMHeapHeader < dwSize) {
        DebugTrace("Trying to allocate a negative amount of memory!\n");
        return NULL;
    }

    pv = ExHeapReAlloc(
			HandleFromMHeapPv(pvOld),
			0,
			PvFromMHeapPv(pvOld),
			dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapReAlloc failed to reallocate a block!\n");
		return NULL;
	}

	return MHeapPvFromPv(pv);
#endif
}
	
LPVOID
WINAPI
ExchMHeapReAllocDebug(
				 LPVOID	pvOld,
				 DWORD	dwSize, char *szFile, DWORD dwLine)
{
#ifdef	USEMPHEAP
	return MpHeapReAlloc(hMpHeap, pvOld, dwSize);
#else
	LPVOID		pv;

    //Raid X5:195963 We never want to allocate/reallocate 
    //less memory than what we have been requested.
    if (dwSize + cbMHeapHeader < dwSize) {
        DebugTrace("Trying to allocate a negative amount of memory!\n");
        return NULL;
    }

	pv = ExHeapReAlloc(
					   HandleFromMHeapPv(pvOld),
					   0,
					   PvFromMHeapPv(pvOld),
					   dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapReAlloc failed to reallocate a block!\n");
		return NULL;
	}

	if (fDbgEnable)
	{
		HeapSetName2(HandleFromMHeapPv(MHeapPvFromPv(pv)), pv, "File: %s, Line: %d", szFile, dwLine);
	}

	return MHeapPvFromPv(pv);
#endif
}

	
BOOL
WINAPI
ExchMHeapFree(
	LPVOID	pvFree)
{
#ifdef	USEMPHEAP
	if (pvFree)
	{
		return MpHeapFree(hMpHeap, pvFree);
	}
	else
		return FALSE;
#else
	if (pvFree)
	{
		return ExHeapFree(
				HandleFromMHeapPv(pvFree),
				0,
				PvFromMHeapPv(pvFree));
	}
	else
		return FALSE;
#endif
}


SIZE_T
WINAPI
ExchMHeapSize(
	LPVOID	pvSize)
{
	if (pvSize)
	{
#ifdef	USEMPHEAP
		return MpHeapSize(hMpHeap, 0, pvSize);
#else
		return ((ExHeapSize(
							HandleFromMHeapPv(pvSize),
							0,
							PvFromMHeapPv(pvSize))) - cbMHeapHeader);
#endif
	}
	else
		return 0;
}


//-----------------------------------------------------------------------------
//	The Heap Handle-less APIs
//-----------------------------------------------------------------------------

LPVOID
WINAPI
ExchAlloc(
	DWORD	dwSize)
{
#ifdef DEBUG
	if (!hProcessHeap)
	{
		hProcessHeap = DebugHeapCreate(0, 0, 0);
		HeapSetHeapName(hProcessHeap, "Default ExchMem Heap");
	}
#endif	// DEBUG

	return ExHeapAlloc(hProcessHeap, 0, dwSize);
}


LPVOID
WINAPI
ExchReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize)
{
	if (!pvOld)
		return ExchAlloc(dwSize);
		
	return ExHeapReAlloc(hProcessHeap, 0, pvOld, dwSize);
}
	

BOOL
WINAPI
ExchFree(
	LPVOID	pvFree)
{
	return ExHeapFree(hProcessHeap, 0, pvFree);
}


SIZE_T
WINAPI
ExchSize(
	LPVOID	pv)
{
#ifdef DEBUG
	if (!hProcessHeap)
	{
		hProcessHeap = DebugHeapCreate(0, 0, 0);
		HeapSetHeapName(hProcessHeap, "Default ExchMem Heap");
	}
#endif	// DEBUG

	return ExHeapSize(hProcessHeap, 0, pv);
}


//-----------------------------------------------------------------------------
//	All debug code starts here!
//-----------------------------------------------------------------------------

#ifdef DEBUG

//-----------------------------------------------------------------------------
//	Implementaion of C-Runtimes that use malloc memory
//-----------------------------------------------------------------------------

static char szDebugIni[]			= "EXCHMEM.INI";

static char szSectionAppNames[]		= "Apps To Track";

static char szSectionHeap[]			= "Memory Management";
static char szKeyUseVirtual[]		= "VirtualMemory";
static char szKeyVirtualAlign[]		= "VirtualAlign";
static char szKeyAssertLeaks[]		= "AssertLeaks";
static char szKeyDumpLeaks[]		= "DumpLeaks";
static char szKeyDumpLeaksDebugger[]= "DumpLeaksToDebugger";
static char szKeyFillMem[]			= "FillMemory";
static char szKeyAllocFillByte[]	= "AllocFillByte";
static char szKeyFreeFillByte[]		= "FreeFillByte";
static char szKeyTrackMem[]			= "TrackMemory";
static char szKeyTrackMemInMem[]	= "TrackMemoryInMemory";
static char szKeyStackFrames[]		= "StackFrames";
static char szKeySymbolLookup[]		= "SymbolLookup";
static char szKeyOverwriteDetect[]	= "OverwriteDetect";
static char szKeyValidateMemory[]	= "ValidateMemory";
static char szKeyTrackFreedMemory[]	= "TrackFreedMemory";
static char szKeyFreedMemorySize[]	= "FreedMemorySize";
static char szKeyAssertValid[]		= "AssertValid";
static char szKeyTrapOnInvalid[]	= "TrapOnInvalid";
static char szKeySymPath[]			= "SymPath";
static char szKeyLogPath[]			= "LogPath";

static char szSectionAF[]			= "Heap Resource Failures";
static char szKeyAFEnabled[]		= "FailuresEnabled";
static char szKeyAFStart[]			= "AllocsToFirstFailure";
static char szKeyAFInterval[]		= "FailureInterval";
static char szKeyAFBufSize[]		= "FailureSize";

static char szKeyHeapMon[]			= "MonitorHeap";
static char szHeapMonDLL[]			= "GLHMON32.DLL";
static char szHeapMonEntry[]		= "HeapMonitor";
static char szGetSymNameEntry[]		= "GetSymbolName";

static char szAllocationFault[]		= "FaultingAllocationNumber";

/*
 -	InitDebugExchMem
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL InitDebugExchMem(HMODULE hModule)
{
	ULONG	cch;
	char *	pch;
	char	rgchModulePath[MAX_PATH];
	
	//	Get the executable name and search look in exchmem.ini
	//	to see if we are interested in memory tracing for this
	//	process.  The ini section looks like this:
	//
	//		[Apps To Track]
	//		store=1
	//		emsmta=0
	//		dsamain=0
	//
	//	etc.  This sample specifies that only the store is to
	//	be enabled for memory tracking.
	
	GetModuleFileName(NULL, rgchModulePath, MAX_PATH);
	RemoveExtension(rgchModulePath);

	pch = rgchModulePath + lstrlen(rgchModulePath) - 1;
	
	while (*pch != '\\' && pch >= rgchModulePath)
		pch--;

	lstrcpy(rgchExeName, ++pch);
	
	fDbgEnable = !!(BOOL)GetPrivateProfileIntA(szSectionAppNames,
				rgchExeName, 0, szDebugIni);

	//	Store module handle in global var
	
	hMod = hModule;

	if (!hinstRunTime)
	{
		hinstRunTime = LoadLibrary("msvcrt.dll");
		
		if (!hinstRunTime)
		{
			DebugTrace("EXCHMEM: Failed to load the run-time dll!\n");
			return FALSE;
		}
		
		pfMalloc = (LPFMALLOC)GetProcAddress(hinstRunTime, "malloc");
		
		if (!pfMalloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of malloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfRealloc = (LPFREALLOC)GetProcAddress(hinstRunTime, "realloc");
		
		if (!pfRealloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of realloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfFree = (LPFFREE)GetProcAddress(hinstRunTime, "free");
		
		if (!pfFree)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of free in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfCalloc = (LPFCALLOC)GetProcAddress(hinstRunTime, "calloc");
		
		if (!pfCalloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of calloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfStrDup = (LPFSTRDUP)GetProcAddress(hinstRunTime, "_strdup");
		
		if (!pfStrDup)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of _strdup in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfMemSize = (LPFMEMSIZE)GetProcAddress(hinstRunTime, "_msize");
		
		if (!pfMemSize)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of _msize in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
	}
	
	//	Lookup symbols or just log addresses?

	fSymbolLookup = GetPrivateProfileIntA(szSectionHeap, szKeySymbolLookup, 0, szDebugIni);

	if (!fDbgEnable)
	{
		if (fSymbolLookup && !fSymInitialize)
		{
			char	rgchSymPath[MAX_PATH];

			rgsymcacheHashTable = VirtualAlloc(
											   NULL,
											   NBUCKETS*sizeof(SYMCACHE),
											   MEM_COMMIT,
											   PAGE_READWRITE);

			if (rgsymcacheHashTable == NULL)
			{
				return FALSE;
			}
			GetPrivateProfileString(szSectionHeap,
									szKeySymPath,
									"c:\\exchsrvr\\bin;.",
									rgchSymPath,
									MAX_PATH-1,
									szDebugIni);

			{
				DWORD	dwOptions;

				dwOptions = SymGetOptions();
				SymSetOptions(dwOptions | SYMOPT_DEFERRED_LOADS);
			}

			SymInitialize(GetCurrentProcess(), rgchSymPath, TRUE);
			fSymInitialize = TRUE;
		}
		goto ret;
	}
		
	//	This CS protects access to a list of all live heaps
	
	InitializeCriticalSection(&csHeapList);
	
	//	Initialize support for memory monitoring and leak detection
	
	fDumpLeaks = GetPrivateProfileIntA(szSectionHeap, szKeyDumpLeaks, 0, szDebugIni);
	fDumpLeaksDebugger = GetPrivateProfileIntA(szSectionHeap, szKeyDumpLeaksDebugger, 0, szDebugIni);
	fAssertLeaks = GetPrivateProfileIntA(szSectionHeap, szKeyAssertLeaks, 0, szDebugIni);
	fUseVirtual = GetPrivateProfileIntA(szSectionHeap, szKeyUseVirtual, 0, szDebugIni);
	
	if (fUseVirtual)
		cbVirtualAlign = GetPrivateProfileIntA(szSectionHeap, szKeyVirtualAlign, 1, szDebugIni);
		
	fFillMemory = GetPrivateProfileIntA(szSectionHeap, szKeyFillMem, 0, szDebugIni);

	if (fFillMemory)
	{
		char	szFillByte[8];
		
		//	Set the memory fill characters.
	
		if (GetPrivateProfileString(
				szSectionHeap,
				szKeyAllocFillByte,
				"", szFillByte,
				sizeof(szFillByte)-1,
				szDebugIni))
			chAllocFillByte = HexByteToBin(szFillByte);

		if (GetPrivateProfileString(
				szSectionHeap,
				szKeyFreeFillByte,
				"", szFillByte,
				sizeof(szFillByte)-1,
				szDebugIni))
			chFreeFillByte = HexByteToBin(szFillByte);
	}
	
//$ISSUE
	//	For now, just use virtual to detect overwrites!
	//	Maybe I'll change this later to use pads on the
	//	front and back side of a block. -RLS
	
	fOverwriteDetect = GetPrivateProfileIntA(szSectionHeap, szKeyOverwriteDetect, 0, szDebugIni);
	fValidateMemory = GetPrivateProfileIntA(szSectionHeap, szKeyValidateMemory, 0, szDebugIni);
	fTrackFreedMemory = GetPrivateProfileIntA(szSectionHeap, szKeyTrackFreedMemory, 0, szDebugIni);
	cEntriesFree = GetPrivateProfileIntA(szSectionHeap, szKeyFreedMemorySize, 512, szDebugIni);
	fAssertValid = GetPrivateProfileIntA(szSectionHeap, szKeyAssertValid, 0, szDebugIni);
	fTrapOnInvalid = GetPrivateProfileIntA(szSectionHeap, szKeyTrapOnInvalid, 0, szDebugIni);
	fHeapMonitorUI = GetPrivateProfileIntA(szSectionHeap, szKeyHeapMon, 0, szDebugIni);
	fFailuresEnabled = GetPrivateProfileIntA(szSectionAF, szKeyAFEnabled, 0, szDebugIni);



	//	Get file path to write log files into
		
	GetPrivateProfileString(szSectionHeap,
				szKeyLogPath,
				".\\",
				rgchLogPath,
				MAX_PATH-1,
				szDebugIni);
		
	cch = lstrlen(rgchLogPath);
	
	if (rgchLogPath[cch-1] != '\\')
	{
		rgchLogPath[cch]   = '\\';
		rgchLogPath[cch+1] = '\0';
	}
				
	//	Initialize support for memory usage tracking
	
	fTrackMem = GetPrivateProfileIntA(szSectionHeap, szKeyTrackMem, 0, szDebugIni);
	if (fTrackMem)
		StartTrace(TRUE);

	// This is for keeping track of the last x mem functions in a circular list in memory.
	// This doesn't slow things down as much as tracing everything to disk and can be useful
	// in finding memory problems that are timing related.
	
	dwTrackMemInMem = GetPrivateProfileIntA(szSectionHeap, szKeyTrackMemInMem, 0, szDebugIni);
	if (dwTrackMemInMem)
	{
		fTrackMem = TRUE;
		rgmemtrace = VirtualAlloc(
					   NULL,
					   dwTrackMemInMem*sizeof(MEMTRACE),
					   MEM_COMMIT,
					   PAGE_READWRITE);
	}

	//	How many Stack Frames does the user want traced?
	
	cFrames = GetPrivateProfileIntA(szSectionHeap, szKeyStackFrames, 0, szDebugIni);
	
	if (cFrames > NSTK)
		cFrames = NSTK;

	//	This is used in the debug build to determine if we will
	//	allow the HeapMonitor UI or not.  We do not allow it if
	//	the process that is attaching to us is a service.

	fProcessIsService = IsProcessRunningAsService();

	//	Initialize the symbols stuff for imagehlp.dll

	fCallStacks = (fDumpLeaks || fAssertLeaks || fTrackMem || fHeapMonitorUI || fValidateMemory);
	
	if (cFrames && fCallStacks && !fSymInitialize)
	{
		char	rgchSymPath[MAX_PATH];
		
		rgsymcacheHashTable = VirtualAlloc(
								NULL,
								NBUCKETS*sizeof(SYMCACHE),
								MEM_COMMIT,
								PAGE_READWRITE);
		
		if (rgsymcacheHashTable == NULL)
		{
			return FALSE;
		}
		GetPrivateProfileString(szSectionHeap,
				szKeySymPath,
				"c:\\exchsrvr\\bin;.",
				rgchSymPath,
				MAX_PATH-1,
				szDebugIni);

		{
			DWORD	dwOptions;

			dwOptions = SymGetOptions();
			SymSetOptions(dwOptions | SYMOPT_DEFERRED_LOADS);
		}

		SymInitialize(GetCurrentProcess(), rgchSymPath, TRUE);
		fSymInitialize = TRUE;
	}

ret:	
	return TRUE;
}


/*
 -	UnInitDebugExchMem
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID UnInitDebugExchMem(VOID)
{
	PHEAP pheap = pheapList;
	
	while (pheap)
	{
		if (fDumpLeaks && (pheap->ulFlags & HEAP_NO_FREE))
			HeapDumpLeaks(pheap, TRUE);
		
		pheap = pheap->pNext;	
	}
	
	if (hProcessHeap)
		DebugHeapDestroy(hProcessHeap);
	
	if (hinstRunTime)
	{
		FreeLibrary(hinstRunTime);
		
		hinstRunTime	= NULL;
		pfMalloc		= NULL;
		pfRealloc		= NULL;
		pfFree			= NULL;
		pfCalloc		= NULL;
		pfStrDup		= NULL;
		pfMemSize		= NULL;
	}
	
	if (fDbgEnable)
	{
		if (fSymInitialize)
		{
			VirtualFree(rgsymcacheHashTable, NBUCKETS*sizeof(SYMCACHE), MEM_DECOMMIT);
			VirtualFree(rgsymcacheHashTable, 0, MEM_RELEASE);
			SymCleanup(GetCurrentProcess());
			fSymInitialize = FALSE;
		}
		
		DeleteCriticalSection(&csHeapList);
		
		StopTrace();

		if (dwTrackMemInMem)
		{
			VirtualFree(rgmemtrace, dwTrackMemInMem*sizeof(MEMTRACE), MEM_DECOMMIT);
			VirtualFree(rgmemtrace, 0, MEM_RELEASE);
		}
	}
}


/*
 -	calloc
 -
 *	Purpose:
 *		Replace the calloc() function supplied in the c-runtimes.  Like
 *		malloc() except zero fills the memory that is allocated.
 *
 *	Parameters:
 *		cStructs		Number of objects the caller wants room for
 *		cbStructs		Size of an individual object
 *
 *	Returns:
 *		pv				Pointer to zero filled memory of size: cStructs*cbStructs
 *
 */

void *
__cdecl
calloc(
	size_t cStructs,
	size_t cbStructs)
{
	void * pv;
	
	pv = pfCalloc(cStructs, cbStructs);
	
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)(cStructs*cbStructs);
		rgdwArgs[2] = (DWORD_PTR)pv;
		
		LogCurrentAPI(API_HEAP_ALLOC, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
	return pv;
}


/*
 -	free
 -
 *	Purpose:
 *		To free memory allocated with malloc(0, realloc(), or calloc().
 *
 *	Parameters:
 *		pv				Pointer to memory buffer to free
 *
 *	Returns:
 *		void
 *
 */

void
__cdecl
free(
	void *pv)
{
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)pv;
		rgdwArgs[2] = (pv ? (DWORD_PTR)pfMemSize(pv) : 0);
		
		LogCurrentAPI(API_HEAP_FREE, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
	pfFree(pv);
}


/*
 -	malloc
 -
 *	Purpose:
 *		To allocate a memory buffer of size cb.
 *
 *	Parameters:
 *		cb				Size of memory buffer to allocate
 *
 *	Returns:
 *		pv				Pointer to memory buffer
 *
 */

void *
__cdecl
malloc(
	size_t cb)
{
	void * pv;
	
	pv = pfMalloc(cb);
	
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)cb;
		rgdwArgs[2] = (DWORD_PTR)pv;
		
		LogCurrentAPI(API_HEAP_ALLOC, rgdwCallers, cFrames, rgdwArgs, 3);
	}

	return pv;
}


/*
 -	realloc
 -
 *	Purpose:
 *		To resize a memory buffer allocated with malloc().
 *
 *	Parameters:
 *		pv				Pointer to original memory buffer
 *		cb				New size of memory buffer to be allocated
 *
 *	Returns:
 *		pvNew			Pointer to new memory buffer
 *
 */

void *
__cdecl
realloc(
	void *pv,
	size_t cb)
{
	void * pvNew;
	DWORD dwSize;
	BOOL fTrackMem = FTrackMem();

	if (fDbgEnable && fTrackMem)
		dwSize = (pv ? pfMemSize(pv) : 0);
	
	pvNew = pfRealloc(pv, cb);
	
	if (fDbgEnable && fTrackMem)
	{
		DWORD_PTR	rgdwArgs[5];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = dwSize;
		rgdwArgs[2] = (DWORD_PTR)pv;
		rgdwArgs[3] = (DWORD_PTR)cb;
		rgdwArgs[4] = (DWORD_PTR)pvNew;
		
		LogCurrentAPI(API_HEAP_REALLOC, rgdwCallers, cFrames, rgdwArgs, 5);
	}

	return pvNew;
}


/*
 -	_strdup
 -
 *	Purpose:
 *		To allocate a memory buffer large enough to hold sz, copy
 *		the contents of sz into the new buffer and return the new
 *		buffer to the caller (i.e. make a copy of the string).
 *
 *	Parameters:
 *		sz				Pointer to null terminated string to copy
 *
 *	Returns:
 *		szNew			Pointer to new copy of sz
 *
 */

char *
__cdecl
_strdup(
	const char *sz)
{
	return pfStrDup(sz);
}


//-----------------------------------------------------------------------------
//	ExchMem Heap Debug Implementation
//-----------------------------------------------------------------------------


VOID
EnqueueHeap(PHEAP pheap)
{
	EnterCriticalSection(&csHeapList);
	
	if (pheapList)
		pheap->pNext = pheapList;

	pheapList = pheap;

	LeaveCriticalSection(&csHeapList);
}


VOID
DequeueHeap(PHEAP pheap)
{
	PHEAP	pheapPrev = NULL;
	PHEAP	pheapCurr;
	
	EnterCriticalSection(&csHeapList);
	
	pheapCurr = pheapList;

	while (pheapCurr)
	{
		if (pheapCurr == pheap)
			break;
		
		pheapPrev = pheapCurr;
		pheapCurr = pheapCurr->pNext;	
	}
	
	if (pheapCurr)
	{
		if (pheapPrev)
			pheapPrev->pNext = pheapCurr->pNext;
		else
			pheapList = pheapCurr->pNext;
	}

	LeaveCriticalSection(&csHeapList);
}


HANDLE
WINAPI
DebugHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
	HANDLE	hDataHeap = 0;
	HANDLE	hBlksHeap = 0;
	PHEAP	pheap = NULL;
	
	if (!fDbgEnable)
		return HeapCreate(dwFlags, dwInitialSize, dwMaxSize);

	//	The first thing we must do is create a heap that we will
	//	allocate our Allocation Blocks on.  We also allocate our
	//	debug Heap object on this heap.

	hBlksHeap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0);
	
	if (!hBlksHeap)
	{
		DebugTrace("HEAP_Open: Failed to create new heap!\n");
		goto ret;
	}
	
	//	Allocate the thing we hand back to the caller on this new heap.
	
	pheap = HeapAlloc(hBlksHeap, 0, sizeof(HEAP));
	
	if (!pheap)
	{
		DebugTrace("HEAP_Alloc: Failed to allocate heap handle!\n");
		HeapDestroy(hBlksHeap);
		hBlksHeap = NULL;
		goto ret;
	}
	
	//	Initialize all the goodies we store in this thing.
	//	Hook this heap into the global list of heaps we've
	//	created in this context.
	
	memset(pheap, 0, sizeof(HEAP));

	pheap->pfnSetName	= (LPHEAPSETNAME)HeapSetNameFn;
	pheap->hBlksHeap	= hBlksHeap;
	pheap->ulFlags		= HEAP_LOCAL;

	if (dwFlags & HEAP_NO_FREE)
	{
		pheap->ulFlags |= HEAP_NO_FREE;
		dwFlags &= ~(HEAP_NO_FREE);
	}
	
	InitializeCriticalSection(&pheap->cs);
	
	// VirtualMemory default is FALSE

	if (fUseVirtual)
	{
		pheap->ulFlags |= HEAP_USE_VIRTUAL;

		// We always want virtual allocations on RISC to be 4-byte aligned
		// because all our code assumes that the beginning of an allocation
		// is aligned on machine word boundaries.  On other platforms,
		// changing this behavior is non-fatal, but on RISC platforms we'll
		// get alignment faults everywhere.
		
#if defined(_X86_)
		if (cbVirtualAlign == 4)
#else
			cbVirtualAlign = 4;
#endif
			pheap->ulFlags |= HEAP_USE_VIRTUAL_4;
	}
		
	// DumpLeaks default is TRUE

	if (fDumpLeaks)
		pheap->ulFlags |= HEAP_DUMP_LEAKS;
	
	// AssertLeaks default is FALSE

	if (fAssertLeaks)
		pheap->ulFlags |= HEAP_ASSERT_LEAKS;
	
	// FillMem default is TRUE

	if (fFillMemory)
	{
		pheap->ulFlags |= HEAP_FILL_MEM;
		pheap->chFill = chAllocFillByte;
	}

	//  Set up artificial failures.  If anything is set in our ini file, then
	//  HEAP_FAILURES_ENABLED gets set.

	if (fFailuresEnabled)
	{
		pheap->ulFlags |= HEAP_FAILURES_ENABLED;

		pheap->ulFailStart = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFStart, 0, szDebugIni);
		
		pheap->ulFailInterval = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFInterval, 0, szDebugIni);

		pheap->ulFailBufSize = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFBufSize, 0, szDebugIni);

		pheap->iAllocationFault = GetPrivateProfileIntA(szSectionAF,
				szAllocationFault, 0, szDebugIni);
	}

	//	If the user wants Heap Monitor UI, the spin a thread to manage a
	//	DialogBox that can display the status of the heap at all times.

	if (fHeapMonitorUI && !fProcessIsService)
		if (FRegisterHeap(pheap))
			pheap->ulFlags |= HEAP_HEAP_MONITOR;

	//	If we are not using virtual memory allocators, then we
	//	create another heap to allocate the users data in.
	
	if (!fUseVirtual)
	{
		hDataHeap = HeapCreate(dwFlags, dwInitialSize, dwMaxSize);

		if (!hDataHeap)
		{
			DebugTrace("HeapAlloc: Failed to allocate heap handle!\n");
			HeapDestroy(hBlksHeap);
			pheap = NULL;
			goto ret;
		}
		
		pheap->hDataHeap = hDataHeap;
	}

	//	Name heap
	
	HeapSetHeapName1(pheap, "ExchMem Heap: %08lX", pheap);

	//	Remove heap from list
	
	EnqueueHeap(pheap);

	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = dwInitialSize;
		rgdwArgs[1] = dwMaxSize;
		rgdwArgs[2] = (DWORD_PTR)hDataHeap;
		
		LogCurrentAPI(API_HEAP_CREATE, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
ret:
	return (HANDLE)pheap;
}	


BOOL
WINAPI
DebugHeapDestroy(
	HANDLE	hHeap)
{
	PHEAP	pheap = (PHEAP)hHeap;
	HANDLE	hDataHeap = pheap->hDataHeap;
	HANDLE	hBlksHeap = pheap->hBlksHeap;

	if (!fDbgEnable)
		return HeapDestroy(hHeap);
		
	//	Remove heap from list
	
	DequeueHeap(pheap);
	
	//	Dump memory leaks if we're supposed to.
	
	if (fDumpLeaks && !(pheap->ulFlags & HEAP_NO_FREE))
		HeapDumpLeaks(pheap, FALSE);
	
	//
	//	Free the entries in the free list.
	//
	//	This isn't totally necessary, since destroying the heap destroys the free list, but what the
	//	heck, it's cleaner to do it this way.
	//
	while (pheap->phblkFree)
	{
		PHBLK phblk = pheap->phblkFree;

		pheap->phblkFree = phblk->phblkFreeNext;

		//
		//	And now free up the block for real, it's too old.
		//

		if (fUseVirtual)
			VMFreeEx((fOverwriteDetect ? PvHeadFromPv(phblk->pv) : phblk->pv), cbVirtualAlign);
		else
			HeapFree(pheap->hDataHeap, 0,
							(fOverwriteDetect ? PvHeadFromPv(phblk->pv) : phblk->pv));
		
		HeapFree(pheap->hBlksHeap, 0, phblk);

	}

	//	Destroy the HeapMonitor thread and un-load the DLL
	
	UnRegisterHeap(pheap);
	
	if (fHeapMonitorUI && pheap->hInstHeapMon)
		FreeLibrary(pheap->hInstHeapMon);

	DeleteCriticalSection(&pheap->cs);
	
	//	Clean-up and leave.  Closing frees leaks, so we're cool!
	
	if (!fUseVirtual && hDataHeap)
	{
		HeapDestroy(hDataHeap);
	}
		
	if (hBlksHeap)
	{
		HeapFree(hBlksHeap, 0, pheap);
		HeapDestroy(hBlksHeap);
	}
	
	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)hDataHeap;
		
		LogCurrentAPI(API_HEAP_DESTROY, rgdwCallers, cFrames, rgdwArgs, 1);
	}
	
	return TRUE;
}


LPVOID
WINAPI
DebugHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize)
{
	PHEAP	pheap = (PHEAP)hHeap;
	PHBLK	phblk = NULL;
	LPVOID	pvAlloc = NULL;
	
	if (!fDbgEnable)
		return HeapAlloc(hHeap, dwFlags, dwSize);
		
	// Note:  To be consistent with other (e.g. system) allocators,
	// we have to return a valid allocation if dwSize == 0.  So, we
	// allow a dwSize of 0 to actually be allocated.  (See bug 3556 in
	// the sqlguest:exchange database.)

	EnterCriticalSection(&pheap->cs);

	if (fFailuresEnabled)
	{
		if (pheap->ulAllocNum == pheap->iAllocationFault)
		{
			DebugTrace("HeapRealloc: Allocation Fault hit\n");
			DebugBreak();
		}

		if (FForceFailure(pheap, dwSize))
		{
			DebugTrace("HeapAlloc: Artificial Failure\n");
			pvAlloc = NULL;
			pheap->ulAllocNum++;
	        LeaveCriticalSection(&pheap->cs);
			goto ret;
		}
	}

	//	We have to leave the CS before calling HeapAlloc in case the user
	//	created this heap with the HEAP_GENERATE_EXCEPTIONS flag set, which,
	//	if thrown, would cause us to exit here with our CS held - a bad thing...
	
	LeaveCriticalSection(&pheap->cs);

	if (fUseVirtual)
		pvAlloc = VMAllocEx((fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize), cbVirtualAlign);
	else
		pvAlloc = HeapAlloc(pheap->hDataHeap, dwFlags,
				(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize));
	
	//	Now, re-aquire the CS and finish our work.  We do not create the
	//	BlksHeap with the HEAP_GENERATE_EXCEPTIONS flag so we're cool.
	
	EnterCriticalSection(&pheap->cs);

	if (pvAlloc)
	{
		phblk = (PHBLK)HeapAlloc(pheap->hBlksHeap, 0, sizeof(HBLK));
		
		if (phblk)
		{
			if (fOverwriteDetect)
			{
				//	Fill the Head and Tail overwrite detection
				//	blocks special fill character: 0xAB.
				
				memset(pvAlloc,
						chOWFill,
						cbOWSection);
						
				memset(PvTailFromPvHead(pvAlloc, dwSize),
						chOWFill,
						cbOWSection);
				
				//	Now, advance pvAlloc to user portion of buffer
				
				pvAlloc = PvFromPvHead(pvAlloc);		
			}
			
			phblk->pheap		= pheap;
			phblk->szName[0]	= '\0';
			phblk->ulSize		= dwSize;
			phblk->ulAllocNum	= ++pheap->ulAllocNum;
			phblk->pv			= pvAlloc;
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;

			ZeroMemory(phblk->rgdwCallers, cFrames*sizeof(DWORD));
			ZeroMemory(phblk->rgdwFree, cFrames*sizeof(DWORD));

			PhblkEnqueue(phblk);

			if (fCallStacks)
				GetCallStack(phblk->rgdwCallers, cFrames);

			if (fFillMemory && !(dwFlags & HEAP_ZERO_MEMORY))
				memset(pvAlloc, pheap->chFill, (size_t)dwSize);

			if (FTrackMem())
			{
				DWORD_PTR	rgdwArgs[4];

				rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
				rgdwArgs[1] = dwSize;
				rgdwArgs[2] = (DWORD_PTR)pvAlloc;
		
				LogCurrentAPI(API_HEAP_ALLOC, phblk->rgdwCallers, cFrames, rgdwArgs, 3);
			}
		}
		else
		{
			if (fUseVirtual)
				VMFreeEx(pvAlloc, cbVirtualAlign);
			else
				HeapFree(pheap->hDataHeap, dwFlags, pvAlloc);
			
			pvAlloc = NULL;	
		}
	}

	LeaveCriticalSection(&pheap->cs);
	
ret:
	return pvAlloc;
}	


LPVOID
WINAPI
DebugHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize)
{
	PHEAP	pheap = (PHEAP)hHeap;
	LPVOID	pvNew = NULL;
	PHBLK	phblk;
	UINT	cbOld;

	if (!fDbgEnable)
		return HeapReAlloc(hHeap, dwFlags, pvOld, dwSize);
		
	if (pvOld == 0)
	{
		pvNew = DebugHeapAlloc(hHeap, dwFlags, dwSize);
	}
	else
	{
		EnterCriticalSection(&pheap->cs);

		if (fValidateMemory)
		{
			if (!HeapValidatePv(pheap, pvOld, "DebugHeapReAlloc"))
			{
				LeaveCriticalSection(&pheap->cs);
				goto ret;
			}
		}
		
		phblk	= PvToPhblk(pheap, pvOld);
		cbOld	= (UINT)CbPhblkClient(phblk);

		PhblkDequeue(phblk);

		//	We have to leave the CS before calling HeapReAlloc in case the user
		//	created this heap with the HEAP_GENERATE_EXCEPTIONS flag set, which,
		//	if thrown, would cause us to exit here with our CS held - a bad thing...
	
		LeaveCriticalSection(&pheap->cs);

		if (fFailuresEnabled && pheap->ulAllocNum >= pheap->iAllocationFault)
		{
			DebugTrace("HeapRealloc: Allocation Fault hit\n");
			DebugBreak();
		}
		else if (fFailuresEnabled && FForceFailure(pheap, dwSize) && (dwSize > cbOld))
		{
			InterlockedIncrement((LPLONG)&pheap->ulAllocNum);
			pvNew = 0;
			DebugTrace("HeapRealloc: Artificial Failure\n");
		}
		else if (fUseVirtual)
			pvNew = VMReallocEx(fOverwriteDetect ? PvHeadFromPv(pvOld) : pvOld,
								(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize),
								cbVirtualAlign);
		else
			pvNew = HeapReAlloc(pheap->hDataHeap, dwFlags,
					(fOverwriteDetect ? PvHeadFromPv(pvOld) : pvOld),
					(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize));

		//	Now, re-aquire the CS and finish our work.
		
		EnterCriticalSection(&pheap->cs);

		if (pvNew)
		{
			if (fOverwriteDetect)
			{
				//	Fill the Head and Tail overwrite detection
				//	blocks special fill character: 0xAB.
				
				memset(pvNew,
						chOWFill,
						cbOWSection);

				memset(PvTailFromPvHead(pvNew, dwSize),
						chOWFill,
						cbOWSection);

				//	Now, advance pvNew to user portion of buffer

				pvNew = PvFromPvHead(pvNew);		
			}
			
			if (fCallStacks)
				GetCallStack(phblk->rgdwCallers, cFrames);

			if (fFillMemory && (dwSize > cbOld) && !(dwFlags & HEAP_ZERO_MEMORY))
				memset((LPBYTE)pvNew + cbOld, pheap->chFill, dwSize - cbOld);

			phblk->pv			= pvNew;
			phblk->ulSize		= dwSize;
			phblk->ulAllocNum	= ++pheap->ulAllocNum;
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;
		}
		else
		{
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;
		}		

		PhblkEnqueue(phblk);

		if (FTrackMem())
		{
			DWORD_PTR	rgdwArgs[5];

			rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
			rgdwArgs[1] = (DWORD_PTR)cbOld;
			rgdwArgs[2] = (DWORD_PTR)pvOld;
			rgdwArgs[3] = dwSize;
			rgdwArgs[4] = (DWORD_PTR)pvNew;
			
			LogCurrentAPI(API_HEAP_REALLOC, phblk->rgdwCallers, cFrames, rgdwArgs, 5);
		}

   		LeaveCriticalSection(&pheap->cs);
	}

ret:	
	return pvNew;
}	

PHBLK
PhblkSearchFreeList(PHEAP pheap, LPVOID pv)
{
	PHBLK phblkT = pheap->phblkFree;

	//
	//	Walk the free list looking for this block, and if we find it, free it.
	//
	while (phblkT != NULL)
	{
		if (phblkT->pv == pv)
		{
			return phblkT;
		}
		phblkT = phblkT->phblkFreeNext;
	}
	return NULL;
}



BOOL
WINAPI
DebugHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree)
{
	PHEAP	pheap = (PHEAP)hHeap;
	BOOL	fRet = TRUE;
	DWORD 	dwSize = 0;

	if (!fDbgEnable)
		return HeapFree(hHeap, dwFlags, pvFree);
		
	EnterCriticalSection(&pheap->cs);

	//
	//	If we're tracking freed memory, then we don't actually free the blocks, we remember where they
	//	are on the freed block list.
	//
	if (pvFree)
	{
		PHBLK	phblk;

		phblk = PvToPhblk(pheap, pvFree);
		dwSize = (size_t)CbPhblkClient(phblk);

		if (!fValidateMemory || HeapValidatePv(pheap, pvFree, "DebugHeapFree"))
		{
			//
			//	remove this phblk from the list of allocated blocks - as far as the heap is concerned, it's
			//	no longer allocated.
			//
			PhblkDequeue(phblk);

			//
			//	And fill the block with the free block pattern if appropriate.
			//

			if (fFillMemory)
			{

				memset(pvFree, chFreeFillByte, dwSize);

			}

			if (fTrackFreedMemory)
			{
				PHBLK phblkT;

				if (fCallStacks)
					GetCallStack(phblk->rgdwFree, cFrames);

				//
				//	Now insert this free block onto the head of the free block list
				//
				phblkT = pheap->phblkFree;
				pheap->phblkFree = phblk;
				phblk->phblkFreeNext = phblkT;

				//
				//	And then check to see if we have "too many" free entries.
				//
				if (++pheap->cEntriesFree > cEntriesFree)
				{
					PHBLK *phblkPrev = &pheap->phblkFree;

					//
					//	There are too many entries on the free list, so we need to remove the last one.
					//
					
					phblkT = pheap->phblkFree;
					
					while (phblkT->phblkFreeNext != NULL)
					{
						phblkPrev = &phblkT->phblkFreeNext;
						phblkT = phblkT->phblkFreeNext;
					}
				
					Assert(*phblkPrev);
					*phblkPrev = NULL;

					//
					//	And now free up the block for real, it's too old.
					//

					if (fUseVirtual)
						VMFreeEx((fOverwriteDetect ? PvHeadFromPv(phblkT->pv) : phblkT->pv), cbVirtualAlign);
					else
						fRet = HeapFree(pheap->hDataHeap, dwFlags,
										(fOverwriteDetect ? PvHeadFromPv(phblkT->pv) : phblkT->pv));

					HeapFree(pheap->hBlksHeap, 0, phblkT);	
				}
			}
			else	// We're not tracking freed memory, so we can really free the memory right now.
			{

				//
				//	And now free up the block for real.
				//

				if (fUseVirtual)
					VMFreeEx((fOverwriteDetect ? PvHeadFromPv(pvFree) : pvFree), cbVirtualAlign);
				else
					fRet = HeapFree(pheap->hDataHeap, dwFlags,
									(fOverwriteDetect ? PvHeadFromPv(pvFree) : pvFree));

				HeapFree(pheap->hBlksHeap, 0, phblk);	
			}
		}
	}	

	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
		rgdwArgs[1] = (DWORD_PTR)pvFree;
		rgdwArgs[2] = dwSize;
		
		LogCurrentAPI(API_HEAP_FREE, rgdwCallers, cFrames, rgdwArgs, 3);
	}

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapLock(
	HANDLE hHeap)
{
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapLock(hHeap);
		
	EnterCriticalSection(&pheap->cs);
	
	return HeapLock(pheap->hDataHeap);
}


BOOL
WINAPI
DebugHeapUnlock(
	HANDLE hHeap)
{
	BOOL	fRet;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapUnlock(hHeap);
		
	fRet = HeapUnlock(pheap->hDataHeap);
	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry)
{
	BOOL	fRet;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapWalk(hHeap, lpEntry);
		
	EnterCriticalSection(&pheap->cs);

	fRet = HeapWalk(pheap->hDataHeap, lpEntry);

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	BOOL	fRet = TRUE;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapValidate(hHeap, dwFlags, lpMem);
		
	EnterCriticalSection(&pheap->cs);

	if (!fUseVirtual)
		fRet = HeapValidate(pheap->hDataHeap, dwFlags,
					(lpMem != NULL && fOverwriteDetect ? PvHeadFromPv(lpMem) : lpMem));

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
	
}


SIZE_T
WINAPI
DebugHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	PHEAP	pheap = (PHEAP)hHeap;
	SIZE_T	cb = 0;

	if (!fDbgEnable)
		return HeapSize(hHeap, dwFlags, lpMem);
		
	EnterCriticalSection(&pheap->cs);

	if ((fValidateMemory ? HeapValidatePv(pheap, (LPVOID)lpMem, "DebugHeapSize") : 1))
	{
		if (fUseVirtual)
		{
			cb = (UINT)VMGetSizeEx((LPVOID)lpMem, cbVirtualAlign);
		}
		else
		{
			cb = HeapSize(pheap->hDataHeap, dwFlags,
					(fOverwriteDetect ? PvHeadFromPv(lpMem) : lpMem));

		}
		if (fOverwriteDetect)
		{
			cb -= 2*cbOWSection;
		}
	}

	LeaveCriticalSection(&pheap->cs);

	return cb;
}


SIZE_T
WINAPI
DebugHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags)
{
	PHEAP	pheap = (PHEAP)hHeap;
	SIZE_T	cbLargestFreeBlk = 0;

	if (!fDbgEnable)
		return HeapCompact(hHeap, dwFlags);
		
	EnterCriticalSection(&pheap->cs);

	if (!fUseVirtual)
		cbLargestFreeBlk = HeapCompact(pheap->hDataHeap, dwFlags);

	LeaveCriticalSection(&pheap->cs);

	return cbLargestFreeBlk;
}


//-----------------------------------------------------------------------------
//	Debug Support routines
//-----------------------------------------------------------------------------

/*
 -	FRegisterHeap
 -
 *	Purpose:
 *		If the user wants to monitor the Heap, then load the DLL with
 *		the HeapMonitor UI.
 */

BOOL FRegisterHeap(PHEAP pheap)
{
	HINSTANCE			hInst;
	LPHEAPMONPROC		pfnHeapMon;
	LPGETSYMNAMEPROC	pfnGetSymName;
	
	pheap->hInstHeapMon = 0;
	pheap->pfnGetSymName = NULL;

	hInst = LoadLibrary(szHeapMonDLL);
	
	if (!hInst)
	{
		DebugTrace("FRegisterHeap: Failed to LoadLibrary GLHMON32.DLL.\n");
		goto ret;
	}

	pfnHeapMon = (LPHEAPMONPROC)GetProcAddress(hInst, szHeapMonEntry);
		
	if (!pfnHeapMon)
	{
		DebugTrace("FRegisterHeap: Failed to GetProcAddress of HeapMonitor.\n");
		FreeLibrary(hInst);
		goto ret;
	}
	
	pfnGetSymName = (LPGETSYMNAMEPROC)GetProcAddress(hInst, szGetSymNameEntry);
		
	if (!pfnGetSymName)
	{
		DebugTrace("FRegisterHeap: Failed to GetProcAddress of GetSymName.\n");
	}
	
 	pheap->hInstHeapMon = hInst;
	
	if (!pfnHeapMon(pheap, HEAPMON_LOAD))
	{
		DebugTrace("FRegisterHeap: Call to HeapMonitor failed.\n");
		pheap->hInstHeapMon = 0;
		goto ret;
	}
	
 	pheap->pfnHeapMon		= pfnHeapMon;
	pheap->pfnGetSymName  = pfnGetSymName;
	
ret:
	return (pheap->hInstHeapMon ? TRUE : FALSE);
}


VOID UnRegisterHeap(PHEAP pheap)
{
	if (pheap->pfnHeapMon)
		pheap->pfnHeapMon(pheap, HEAPMON_UNLOAD);
}


/*
 -	HeapDumpLeaksHeader
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID HeapDumpLeaksHeader(FILE * hf, PHEAP pheap, BOOL fNoFree)
{
	char	szDate[16];
	char	szTime[16];
	
	GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, "MMM dd yy", szDate, 16);
	GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, "hh':'mm':'ss tt", szTime, 16);
	
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	fprintf(hf, "DATE: %s\n", szDate);
	fprintf(hf, "TIME: %s\n\n", szTime);
	fprintf(hf, "HEAP NAME: %s\n", pheap->szHeapName);
	fprintf(hf, "MAX ALLOC: %ld\n", pheap->ulAllocNum);
	fprintf(hf, "LEAKED NO_FREE HEAP: %s\n", (fNoFree? "YES" : "NO"));
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n");
	fprintf(hf, "AllocNum, BlkName, Size, Address, Frame1, Frame2, Frame3, Frame4, Frame5, Frame6, Frame7, Frame8, Frame9, Frame10, Frame11, Frame12\n");

}


/*
 -	HeapDumpLeaksFooter
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID HeapDumpLeaksFooter(FILE * hf, DWORD cLeaks, DWORD cbLeaked)
{
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	fprintf(hf, "TOTAL NUM OF LEAKS: %ld\n", cLeaks);
	fprintf(hf, "TOTAL BYTES LEAKED: %ld\n", cbLeaked);
	fprintf(hf, "END\n");
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\n");
}


/*
 -	HeapDumpLeakedBlock
 -
 *	Purpose:
 *		To report individual memory leaks through DebugTrace and the
 *		HeapLeakHook breakpoint function.
 */

VOID HeapDumpLeakedBlock(FILE * hf, PHEAP pheap, PHBLK phblk)
{
	char	rgchSymbols[4096];
	HANDLE	hProcess = GetCurrentProcess();

	fprintf(hf, "%ld, %s, %ld, %p",
			phblk->ulAllocNum,
			*phblk->szName ? phblk->szName : "NONAME",
			CbPhblkClient(phblk),
			PhblkToPv(phblk));

	*rgchSymbols = '\0';
	GetStackSymbols(hProcess, rgchSymbols, phblk->rgdwCallers, cFrames);

	if (hf)
		fprintf(hf, "%s\n", rgchSymbols);

	if (fDumpLeaksDebugger)
	{
		char *szSymbol = rgchSymbols;
		char *szSymbolNext = rgchSymbols;
		int iSymbol = 0;

		Trace("Block#%d, %s, %ld, %08lX:\n", phblk->ulAllocNum, *phblk->szName ? phblk->szName : "NONAME",
			  CbPhblkClient(phblk), PhblkToPv(phblk));

		while ((szSymbolNext = strchr(szSymbol, ',')) != NULL)
		{
			*szSymbolNext++ = '\0';
			if (*szSymbol != '\0' && strcmp(szSymbol, "0") != 0)
			{
				Trace("\t[%d]: %s\n", iSymbol, szSymbol);
			}
			szSymbol += strlen(szSymbol)+1;
			iSymbol += 1;
		}

		//
		//	Dump the last entry in the call stack.
		//
		if (*szSymbol != '\0' && strcmp(szSymbol, "0") != 0)
		{
			Trace("\t[%d]: %s\n", iSymbol, szSymbol);
		}
	}
}


/*
 -	HeapDumpLeaks
 -
 *	Purpose:
 *		Gets called at HeapClose time to report any memory leaks against
 *		this heap.  There are 2 reporting fascilities used by this routine:
 *
 *			=> Asserts (via TrapSz)
 *			=> Trace files
 *			=> Debug trace tags (via DebugTrace)
 *
 *		The Debug Trace is the default method if no others are specified
 *		or if the others are in-appropriate for the given platform.
 */

VOID HeapDumpLeaks(PHEAP pheap, BOOL fNoFree)
{
	PHBLK	phblk;
	BOOL	fDump = !!(pheap->ulFlags & HEAP_DUMP_LEAKS);
	BOOL	fAssert = !!(pheap->ulFlags & HEAP_ASSERT_LEAKS);
	char	szLeakLog[MAX_PATH];
	DWORD	cLeaks = 0;
	DWORD	cbLeaked = 0;
	FILE *	hLeakLog = NULL;
	
	GetLogFilePath(rgchLogPath, ".mem", szLeakLog);

	hLeakLog = fopen(szLeakLog, "a");

	if (!hLeakLog)
		goto ret;

	if (pheap->phblkHead != NULL)
	{
		if (fAssert)
		{
			AssertSz(FALSE, "Memory Leak Detected, dumping leaks");
		}

		if (!fSymInitialize)
		{
			rgsymcacheHashTable = VirtualAlloc(
											   NULL,
											   NBUCKETS*sizeof(SYMCACHE),
											   MEM_COMMIT,
											   PAGE_READWRITE);
								
			if (rgsymcacheHashTable == NULL)
			{
				return;
			}
			SymInitialize(GetCurrentProcess(), NULL, TRUE);
			fSymInitialize = TRUE;
		}

		HeapDumpLeaksHeader(hLeakLog, pheap, fNoFree);

		if (fDump)
		{
			for (phblk = pheap->phblkHead; phblk; phblk = phblk->phblkNext)
			{
				HeapDumpLeakedBlock(hLeakLog, pheap, phblk);
				cLeaks++;
				cbLeaked += phblk->ulSize;
			}
		}
	}
	HeapDumpLeaksFooter(hLeakLog, cLeaks, cbLeaked);

ret:
	if (hLeakLog)
		fclose(hLeakLog);
}


/*
 -	HeapValidatePhblk
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapValidatePhblk(PHEAP pheap, PHBLK phblk, char ** pszReason)
{
	if (IsBadWritePtr(phblk, sizeof(HBLK)))
	{
		*pszReason = "Block header cannot be written to";
		goto err;
	}

	if (phblk->pheap != pheap)
	{
		*pszReason = "Block header does not have correct pointer back to heap";
		goto err;
	}

	if (phblk->phblkNext)
	{
		if (IsBadWritePtr(phblk->phblkNext, sizeof(HBLK)))
		{
			*pszReason = "Block header has invalid next link pointer";
			goto err;
		}

		if (phblk->phblkNext->phblkPrev != phblk)
		{
			*pszReason = "Block header points to a next block which doesn't "
				"point back to it";
			goto err;
		}
	}

	if (phblk->phblkPrev)
	{
		if (IsBadWritePtr(phblk->phblkPrev, sizeof(HBLK))) {
			*pszReason = "Block header has invalid prev link pointer";
			goto err;
		}

		if (phblk->phblkPrev->phblkNext != phblk)
		{
			*pszReason = "Block header points to a prev block which doesn't "
				"point back to it";
			goto err;
		}
	}
	else if (pheap->phblkHead != phblk)
	{
		*pszReason = "Block header has a zero prev link but the heap doesn't "
			"believe it is the first block";
		goto err;
	}

	if (phblk->ulAllocNum > pheap->ulAllocNum)
	{
		*pszReason = "Block header has an invalid internal allocation number";
		goto err;
	}

	return TRUE;

err:
	return FALSE;
}


/*
 -	HeapDidAlloc
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapDidAlloc(PHEAP pheap, LPVOID pv)
{
	PHBLK	phblk;
	char *	pszReason;
	BOOL	fDidAlloc = FALSE;

	for (phblk = pheap->phblkHead; phblk; phblk = phblk->phblkNext)
	{
		AssertSz(HeapValidatePhblk(pheap, phblk, &pszReason),
				"Invalid block header in ExchMem");

		if (!HeapValidatePhblk(pheap, phblk, &pszReason))
			DebugTrace2("Block header (phblk=%08lX) is invalid\n%s", phblk, pszReason);

		if (PhblkToPv(phblk) == pv)
		{
			fDidAlloc = TRUE;
			break;
		}
	}

	return fDidAlloc;
}


/*
 -	DumpFailedValidate
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID DumpFailedValidate(char * szFailed, DWORD_PTR * rgdwStack)
{
	FILE *	hLog = NULL;
	char	szValidateLog[MAX_PATH];
	char    rgchBuff[2048];

	lstrcpy(rgchBuff, "Stack Trace: ");
	
	GetStackSymbols(GetCurrentProcess(), rgchBuff, rgdwStack, cFrames);
	
	//	Create validate log file name
	
	GetLogFilePath(rgchLogPath, ".val", szValidateLog);

	//	Open the Log File and write results
		
	hLog = fopen(szValidateLog, "a");
			
	if (hLog)
	{
		fprintf(hLog, "%s", szFailed);
		fprintf(hLog, "%s\n\n", rgchBuff);
		fclose(hLog);
	}
}


/*
 -	HeapValidatePv
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapValidatePv(PHEAP pheap, LPVOID pv, char * pszFunc)
{
	PHBLK	phblk;
	char *	pszReason;
	char	szBuff[1024];
	DWORD_PTR	rgdwStack[NSTK];
	LPBYTE	pb;

	phblk = PvToPhblk(pheap, pv);
	
	if (!phblk)
	{
		//
		//	Let's see if this block is on the free list.
		//

		if (fTrackFreedMemory && (phblk = PhblkSearchFreeList(pheap, pv)))
		{
			char rgchStackFree[2048];
			char rgchStackAlloc[2048];

			strcpy(szBuff, "Attempt to free already freed memory");

			if (fAssertValid)
				AssertSz(0, szBuff);

			//
			// Dump call stack that corresponds to the earlier free.
			//

			GetStackSymbols(GetCurrentProcess(), rgchStackFree, phblk->rgdwFree, cFrames);
			GetStackSymbols(GetCurrentProcess(), rgchStackAlloc, phblk->rgdwCallers, cFrames);

			Trace("Call stack of freeing routine: \n");
			Trace("%s\n", rgchStackFree);
			
			Trace("Call stack of allocating routine: \n");
			Trace("%s\n", rgchStackAlloc);

			if (fTrapOnInvalid)
				DebugBreak();

		}
		else
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) which was either "
					 "not allocated in heap '%s' or has already been freed but is not on the free list.\n",
					 pszFunc, pv, pheap->szHeapName);

			if (fAssertValid)
				AssertSz(0, szBuff);

			if (fTrapOnInvalid)
				DebugBreak();

			GetCallStack(rgdwStack, cFrames);
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);
		}
				
		return FALSE;
	}

	if (fOverwriteDetect)
	{
		pb = (LPBYTE)PvHeadFromPv(pv);
		
		if ((pb[0] != chOWFill) || (pb[1] != chOWFill) ||
			(pb[2] != chOWFill) || (pb[3] != chOWFill))
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) from heap '%s' "
					"which appears to have been under-written.\n",
					pszFunc, pv, pheap->szHeapName);
					
			if (fAssertValid)
				AssertSz(0, szBuff);
			
			if (fTrapOnInvalid)
				DebugBreak();
				
			GetCallStack(rgdwStack, cFrames);	
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);

			return FALSE;
		}

		pb = (LPBYTE)PvTailFromPv(pv, phblk->ulSize);
		
		if ((pb[0] != chOWFill) || (pb[1] != chOWFill) ||
			(pb[2] != chOWFill) || (pb[3] != chOWFill))
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) from heap '%s' "
					"which appears to have been over-written.\n",
					pszFunc, pv, pheap->szHeapName);
					
			if (fAssertValid)
				AssertSz(0, szBuff);
			
			if (fTrapOnInvalid)
				DebugBreak();
				
			GetCallStack(rgdwStack, cFrames);	
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);

			return FALSE;
		}
	}

	if (!HeapValidatePhblk(pheap, phblk, &pszReason))
	{
		wsprintf(szBuff, "%s detected an invalid memory block (%08lX) in heap '%s'.  %s.\n",
				pszFunc, pv, pheap->szHeapName, pszReason);
					
		if (fAssertValid)
			AssertSz(0, szBuff);
				
		if (fTrapOnInvalid)
			DebugBreak();
					
		GetCallStack(rgdwStack, cFrames);	
		DumpFailedValidate(szBuff, rgdwStack);
		DebugTrace(szBuff);

		return FALSE;
	}

	return TRUE;
}


/*
 -	PhblkEnqueue
 -
 *	Purpose:
 *		To add a newly allocated block to the allocation list hanging
 *		off the heap.  We do an InsertSorted because the HeapMonitor
 *		will need to reference the allocations ordered by their
 *		location in the heap.  Since the monitor will walk the heap
 *		often, it is more efficient to do the sort up front.
 */

VOID PhblkEnqueue(PHBLK phblk)
{
	phblk->phblkNext = phblk->pheap->phblkHead;
	
	if (phblk->phblkNext)
		phblk->phblkNext->phblkPrev = phblk;
	
	phblk->pheap->phblkHead = phblk;
	
	//	I am going to disable the InsertSorted behavior for now for performance
	//	reasons.  It is only done this way because of GLHMON which I don't believe
	//	to be widely used at this point anyway.  I'm not even sure if this is
	//	important to GLHMON since it has the ability to sort blocks by other fields.
	
/*	PHBLK	phblkCurr = NULL;
	PHBLK	phblkNext = phblk->pheap->phblkHead;
	
	while (phblkNext)
	{
		if (phblkNext > phblk)
			break;
		
		phblkCurr = phblkNext;
		phblkNext = phblkCurr->phblkNext;
	}
	
	if (phblkNext)
	{
		phblk->phblkNext		= phblkNext;
		phblk->phblkPrev		= phblkCurr;
		phblkNext->phblkPrev	= phblk;
	}
	else
	{
		phblk->phblkNext = NULL;
		phblk->phblkPrev = phblkCurr;
	}

	if (phblkCurr)
		phblkCurr->phblkNext = phblk;
	else
		phblk->pheap->phblkHead = phblk;
 */
}


/*
 -	PhblkDequeue
 -
 *	Purpose:
 *		To remove a freed block from the list of allocations hanging
 *		off the heap.
 */

VOID PhblkDequeue(PHBLK phblk)
{
	//
	//	We should never be dequeuing an already freed block.
	//
	Assert(phblk->phblkFreeNext == NULL);

	if (phblk->phblkNext)
		phblk->phblkNext->phblkPrev = phblk->phblkPrev;
	
	if (phblk->phblkPrev)
		phblk->phblkPrev->phblkNext = phblk->phblkNext;
	else
		phblk->pheap->phblkHead = phblk->phblkNext;
}


/*
 -	HexByteToBin
 -
 *	Purpose:
 *		Takes a hex string and converts the 2 msd's to a byte, ignoring
 *		the remaining digits.  This function assumes the string is
 *		formatted as: 0xnn, otherwise it simply returns 0x00.
 */

BYTE HexByteToBin(LPSTR sz)
{
	int i, n[2], nT;

	if (*sz++ != '0')
		return 0x00;

	nT = *sz++;

	if (nT != 'x' && nT != 'X')
		return 0x00;

	for (i = 0; i < 2; i++)
	{
		nT = *sz++;
		
		if (nT >= '0' && nT <= '9')
			n[i] = nT - '0';
		else if (nT >= 'A' && nT <= 'F')
			n[i] = nT - 'A' + 10;
		else if (nT >= 'a' && nT <= 'f')
			n[i] = nT - 'a' + 10;
		else
			return (BYTE)0x00;
	}	

	n[0] <<= 4;
	return (BYTE)((BYTE)n[0] | (BYTE)n[1]);
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void __cdecl HeapSetHeapNameFn(PHEAP pheap, char *pszFormat, ...)
{
	char	sz[512];
	va_list	vl;

	if (fDbgEnable)
	{
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);

		lstrcpyn(pheap->szHeapName, sz, sizeof(pheap->szHeapName));
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID __cdecl HeapSetNameFn(PHEAP pheap, LPVOID pv, char *pszFormat, ...)
{
	char	sz[512];
	PHBLK	phblk;
	va_list	vl;

	phblk = PvToPhblk(pheap, pv);

	if (phblk)
	{
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);

		lstrcpyn(phblk->szName, sz, sizeof(phblk->szName));
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

char * HeapGetName(PHEAP pheap, LPVOID pv)
{
	PHBLK	phblk;

	phblk = PvToPhblk(pheap, pv);

	if (phblk)
		return(phblk->szName);

	return("");
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL FForceFailure(PHEAP pheap, ULONG cb)
{
	//  First, see if we're past our start of failures point

	if (pheap->ulFailStart && (pheap->ulFailStart <= pheap->ulAllocNum))
	{
		//  If so, then are we at an interval where we should return errors?
		
		if ((pheap->ulFailInterval)
			&& ((pheap->ulAllocNum - pheap->ulFailStart)%pheap->ulFailInterval) == 0)
		{
			//  return that we should fail here

			return TRUE;
		}

		//  Check to see if the alloc size is greater than allowed

		if (pheap->ulFailBufSize && cb >= pheap->ulFailBufSize)
			return TRUE;

	}

	//  Otherwise, no error is returned for this alloc

	return FALSE;
}


/*
 -	PvToPhblk
 -
 *	Purpose:
 *		Finds the HBLK for this allocation in the heap's active list.
 */

PHBLK PvToPhblk(PHEAP pheap, LPVOID pv)
{
	PHBLK phblk;

	EnterCriticalSection(&pheap->cs);
	
	phblk = pheap->phblkHead;
	
	while (phblk)
	{
		if (phblk->pv == pv)
			break;
		
		phblk = phblk->phblkNext;	
	}
	
	LeaveCriticalSection(&pheap->cs);
	
	return phblk;
}


/*
 -	IsRunningAsService
 -
 *	Purpose:
 *		Determine if the process that attached to us is running as a
 *		service or not.
 *
 *	Parameters:
 *		VOID
 *
 *	Returns:
 *		fService		TRUE if a service, FALSE if not
 *
 */

BOOL IsProcessRunningAsService(VOID)
{
	HANDLE			hProcessToken	= NULL;
	DWORD			dwGroupLength	= 50;
    PTOKEN_GROUPS	ptokenGroupInfo	= NULL;
    PSID			psidInteractive	= NULL;
    PSID			psidService		= NULL;
    SID_IDENTIFIER_AUTHORITY siaNt	= SECURITY_NT_AUTHORITY;
	BOOL			fService		= FALSE;
    DWORD			i;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		goto ret;

    ptokenGroupInfo = (PTOKEN_GROUPS)LocalAlloc(0, dwGroupLength);

    if (ptokenGroupInfo == NULL)
		goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, ptokenGroupInfo,
		dwGroupLength, &dwGroupLength))
	{
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			goto ret;

		LocalFree(ptokenGroupInfo);
		ptokenGroupInfo = NULL;
	
		ptokenGroupInfo = (PTOKEN_GROUPS)LocalAlloc(0, dwGroupLength);
	
		if (ptokenGroupInfo == NULL)
			goto ret;
	
		if (!GetTokenInformation(hProcessToken, TokenGroups, ptokenGroupInfo,
			dwGroupLength, &dwGroupLength))
		{
			goto ret;
		}
    }

    //	We now know the groups associated with this token.  We want to look
    //	to see if the interactive group is active in the token, and if so,
    //	we know that this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know
    //	we're a service.
    //
    //	The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
		0, 0, 0, 0, 0, &psidInteractive))
	{
		goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
		0, 0, 0, 0, &psidService))
	{
		goto ret;
    }

    for (i = 0; i < ptokenGroupInfo->GroupCount ; i += 1)
	{
		PSID psid = ptokenGroupInfo->Groups[i].Sid;
	
		//	Check to see if the group we're looking at is one of
		//	the 2 groups we're interested in.
	
		if (EqualSid(psid, psidInteractive))
		{
			//	This process has the Interactive SID in its token.
			//	This means that the process is running as an EXE.

			goto ret;
		}
		else if (EqualSid(psid, psidService))
		{
			//	This process has the Service SID in its token.  This means that
			//	the process is running as a service running in a user account.

			fService = TRUE;
			goto ret;
		}
    }

    //	Neither Interactive or Service was present in the current
    //	users token.  This implies that the process is running as
    //	a service, most likely running as LocalSystem.

	fService = TRUE;

ret:

	if (psidInteractive)
		FreeSid(psidInteractive);

	if (psidService)
		FreeSid(psidService);

	if (ptokenGroupInfo)
		LocalFree(ptokenGroupInfo);

	if (hProcessToken)
		CloseHandle(hProcessToken);

    return fService;
}


/*
 -	DebugTraceFn
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void __cdecl DebugTraceFn(char *pszFormat, ...)
{
	char	sz[4096];
	va_list	vl;

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	OutputDebugStringA(sz);
	OutputDebugStringA("\r");
}


/*
 -	AssertFn
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void AssertFn(char * szFile, int nLine, char * szMsg)
{
	int nRet;
	char szInfo[1024];

	wsprintf(szInfo, "File %.64s @ line %d%s%s",
			szFile,
			nLine,
			(szMsg) ? (": ") : (""),
			(szMsg) ? (szMsg) : (""));

	// OK to continue, CANCEL to break.

	nRet = MessageBox(NULL, szInfo, "ExchMem Assert", MB_OKCANCEL | MB_ICONSTOP | MB_SERVICE_NOTIFICATION | MB_TOPMOST);

	if (nRet == IDCANCEL)
		DebugBreak();
}


void
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	if (fSymbolLookup)
	{
		GetCallStack(rgdwCaller, cFind);
	}
	else
	{
		ZeroMemory(rgdwCaller, cFind*sizeof(DWORD));
	}
}

BOOL FTrackMem()
{
	if (InterlockedCompareExchange(&fChangeTrackState,FALSE,TRUE))
	{
		fTrackMem = !fTrackMem;
	
		if (fTrackMem)
			StartTrace(FALSE);
		else
			StopTrace();
	}
		
	return fTrackMem;
}

void
StartTrace(BOOL fFresh)
{
	char	szTrackLog[MAX_PATH];
		
	GetLogFilePath(rgchLogPath, ".trk", szTrackLog);

	InitializeCriticalSection(&csTrackLog);
			
	//	Open the Log File
			
	hTrackLog = fopen(szTrackLog, fFresh ? "wt" : "at");
			
	if (!hTrackLog)
	{
		DeleteCriticalSection(&csTrackLog);
		fTrackMem = FALSE;
	}
}

void
StopTrace()
{
	DeleteCriticalSection(&csTrackLog);

	if (hTrackLog)
	{
		fclose(hTrackLog);
		hTrackLog = NULL;
	}

	fTrackMem = FALSE;
}

//-------------------------------------------------------------------------------------
// Description:
//      Copies szAppend to szBuf and updates szBuf to point to the terminating NULL of
//      of the copied bytes. cbMaxBuf is max chars available in szBuf. cbAppend is
//      strlen(szAppend). If cbAppend > cbMaxBuf, as many characters as possible are
//      copied to szBuf (including terminating NULL).
//-------------------------------------------------------------------------------------
#define ExchmemSafeAppend(szBuf, cbMaxBuf, szAppend, cbAppend) {					\
			int iWritten;															\
																					\
			if(NULL != lstrcpyn(szBuf, szAppend, cbMaxBuf)) {						\
				iWritten = ((int)cbMaxBuf < (int)cbAppend) ? cbMaxBuf : cbAppend;	\
				szBuf += iWritten;													\
				cbMaxBuf -= iWritten;												\
			}																		\
		}

void
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwAddress, char rgchSymbol[], DWORD cbSymbol)
{
	CHAR				rgchModuleName[16];
	BOOL				fSym;
	IMAGEHLP_MODULE		mi = {0};
	PIMAGEHLP_SYMBOL	psym = NULL;
	LPSTR				pszSymName = NULL;
	CHAR				rgchLine[256];
	LPSTR				pszT = NULL;
	DWORD_PTR			dwOffset = 0;
	int 				cbAppend = 0;
	PCHAR				pchSymbol = rgchSymbol;

	mi.SizeOfStruct  = sizeof(IMAGEHLP_MODULE);

	pszSymName = pfMalloc(256);

	if (!pszSymName)
		goto ret;
	
	psym = pfMalloc(sizeof(IMAGEHLP_SYMBOL) + 256);

	if (!psym)
		goto ret;

	ZeroMemory(psym, sizeof(IMAGEHLP_SYMBOL) + 256);
	psym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
	psym->MaxNameLength = 256;

	rgchSymbol[0] = '\0';
	if (SymGetModuleInfo(hProcess, dwAddress, &mi))
	{
		lstrcpy(rgchModuleName, mi.ModuleName);
		RemoveExtension(rgchModuleName);

		cbAppend = wsprintf(rgchLine, "(%s)", rgchModuleName);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
	}
	else
		ExchmemSafeAppend(pchSymbol, cbSymbol, "none", sizeof("none") - 1);

	if (fSymbolLookup)
	{
		//
		//	Make sure we always get the address of the symbol, since the symbol lookup isn't accurate for
		//	all modules.
		//
		cbAppend = wsprintf(rgchLine, "(0x%p):", dwAddress);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);

		pszT = PszGetSymbolFromCache(dwAddress, &dwOffset);

		if (!pszT)
		{
			fSym = SymGetSymFromAddr(hProcess,
									 dwAddress,
									 &dwOffset,
									 psym);
			if (fSym)
			{
				if (!SymUnDName(psym, pszSymName, 248))
					lstrcpyn(pszSymName, &(psym->Name[1]), 248);

				AddSymbolToCache(dwAddress, dwOffset, pszSymName);

				pszT = pszSymName;
			}
		}

		if (pszT)
		{
			ExchmemSafeAppend(pchSymbol, cbSymbol, pszT, lstrlen(pszT));
			cbAppend = wsprintf(rgchLine, "+0x%x", dwOffset);
			ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
		}
		else
		{
			cbAppend = wsprintf(rgchLine, "(0x%08x)", dwAddress);
			ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
		}
	}
	else
	{
		cbAppend = wsprintf(rgchLine, "(0x%08x)", dwAddress);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
	}

ret:	
	if (psym)
		pfFree(psym);

	if (pszSymName)
		pfFree(pszSymName);
}


/*
 -	GetCallStack
 -
 *	Purpose:
 *		Uses the imagehlp APIs to get the call stack.
 *
 *	Parameters:
 *		pdwCaller			An array of return addresses
 *		cFind				Count of stack frames to get
 *
 *	Returns:
 *		VOID
 *
 */

VOID GetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	BOOL            fMore;
	STACKFRAME      stkfrm = {0};
	CONTEXT         ctxt;
	HANDLE			hThread;
	HANDLE			hProcess;

	if (!cFind)
		return;

	hThread = GetCurrentThread();
	hProcess = GetCurrentProcess();

	ZeroMemory(&ctxt, sizeof(CONTEXT));
	ZeroMemory(rgdwCaller, cFind * sizeof(DWORD));

	ctxt.ContextFlags = CONTEXT_FULL;

	if (!GetThreadContext(hThread, &ctxt))
	{
		stkfrm.AddrPC.Offset = 0;
	}
	else
	{
#if defined(_M_IX86)
		_asm
		{
			mov stkfrm.AddrStack.Offset, esp
			mov stkfrm.AddrFrame.Offset, ebp
			mov stkfrm.AddrPC.Offset, offset DummyLabel
DummyLabel:
		}
#elif defined(_M_MRX000)
		stkfrm.AddrPC.Offset = ctxt.Fir;
		stkfrm.AddrStack.Offset = ctxt.IntSp;
		stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_ALPHA)
		stkfrm.AddrPC.Offset = (ULONG_PTR)ctxt.Fir;
		stkfrm.AddrStack.Offset = (ULONG_PTR)ctxt.IntSp;
		stkfrm.AddrFrame.Offset = (ULONG_PTR)ctxt.IntSp;
#elif defined(_M_PPC)
		stkfrm.AddrPC.Offset = ctxt.Iar;
		stkfrm.AddrStack.Offset = ctxt.Gpr1;
		stkfrm.AddrFrame.Offset = ctxt.Gpr1;
#else
		stkfrm.AddrPC.Offset = 0;
#endif
	}


	stkfrm.AddrPC.Mode = AddrModeFlat;
	stkfrm.AddrStack.Mode = AddrModeFlat;
	stkfrm.AddrFrame.Mode = AddrModeFlat;

	//	Eat the first one

	fMore = StackWalk(
#ifdef _M_IX86
					  IMAGE_FILE_MACHINE_I386,
#elif defined(_M_MRX000)
					  IMAGE_FILE_MACHINE_R4000,
#elif defined(_M_ALPHA)
#if !defined(_M_AXP64)
					  IMAGE_FILE_MACHINE_ALPHA,
#else
					  IMAGE_FILE_MACHINE_ALPHA64,
#endif
#elif defined(_M_PPC)
					  IMAGE_FILE_MACHINE_POWERPC,
#else
					  IMAGE_FILE_MACHINE_UNKNOWN,
#endif
					  hProcess,
					  hThread,
					  &stkfrm,
					  &ctxt,
					  (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
					  SymFunctionTableAccess,
					  SymGetModuleBase,
					  NULL);

	while (fMore && (cFind > 0))
	{
		fMore = StackWalk(
#ifdef _M_IX86
						  IMAGE_FILE_MACHINE_I386,
#elif defined(_M_MRX000)
						  IMAGE_FILE_MACHINE_R4000,
#elif defined(_M_ALPHA)
						  IMAGE_FILE_MACHINE_ALPHA,
#elif defined(_M_AXP64)
						  IMAGE_FILE_MACHINE_ALPHA64,
#elif defined(_M_PPC)
						  IMAGE_FILE_MACHINE_POWERPC,
#else
						  IMAGE_FILE_MACHINE_UNKNOWN,
#endif
						  hProcess,
						  hThread,
						  &stkfrm,
						  &ctxt,
						  (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
						  SymFunctionTableAccess,
						  SymGetModuleBase,
						  NULL);

		if (!fMore)
			break;

		*rgdwCaller++ = stkfrm.AddrPC.Offset;
		cFind -= 1;
	}
}


/*
 -	RemoveExtension
 -
 *	Purpose:
 *		Strips the file extension from a file path.
 *
 *	Parameters:
 *		psz				File path to strip extension from
 *
 *	Returns:
 *		void
 */

VOID RemoveExtension(LPSTR psz)
{
	LPSTR szLast = NULL;
	while (*psz)
	{
		if (*psz == '.')
		{
			szLast = psz;
		}
		psz++;
	}
	if (szLast)
	{
		*szLast = '\0';
	}
}


/*
 -	GetLogFilePath
 -
 *	Purpose:
 *		Build a log file path from a supplied path, the current
 *		executables name, and a supplied file extension.
 *
 *	Parameters:
 *		szPath			[in]  Path to new log file
 *		szExt			[in]  New log file extension
 *		szFilePath		[out] Newly constructed log file path
 *
 *	Returns:
 *		void
 */

VOID GetLogFilePath(LPSTR szPath, LPSTR szExt, LPSTR szFilePath)
{
	lstrcpy(szFilePath, szPath);
	lstrcat(szFilePath, rgchExeName);
	lstrcat(szFilePath, szExt);
}


/*
 -	PszGetSymbolFromCache
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

CHAR * PszGetSymbolFromCache(DWORD_PTR dwAddress, DWORD_PTR * pdwOffset)
{
	ULONG	ulBucket = UlHash(dwAddress);
	
	if (rgsymcacheHashTable[ulBucket].dwAddress == dwAddress)
	{
		*pdwOffset = rgsymcacheHashTable[ulBucket].dwOffset;
		return rgsymcacheHashTable[ulBucket].rgchSymbol;
	}

	return NULL;
}


/*
 -	AddSymbolToCache
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID AddSymbolToCache(DWORD_PTR dwAddress, DWORD_PTR dwOffset, CHAR * pszSymbol)
{
	ULONG	ulBucket = UlHash(dwAddress);

	rgsymcacheHashTable[ulBucket].dwAddress = dwAddress;
	rgsymcacheHashTable[ulBucket].dwOffset = dwOffset;
	lstrcpy(rgsymcacheHashTable[ulBucket].rgchSymbol, pszSymbol);
}


/*
 -	GetStackSymbols
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

VOID
GetStackSymbols(
	HANDLE hProcess,
	CHAR * rgchBuff,
	DWORD_PTR * rgdwStack,
	DWORD cFrames)
{
	DWORD				i;
	DWORD_PTR				dwAddress;
	LPSTR				pszSymName = NULL;
	
	pszSymName = pfMalloc(256);

	if (!pszSymName)
		goto ret;

	for (i = 0; i < cFrames; i++)
	{
		if ((dwAddress = rgdwStack[i]) != 0)
		{
			ExchmemFormatSymbol(hProcess, dwAddress, pszSymName, 256);

			lstrcat(rgchBuff, ",");
			lstrcat(rgchBuff, pszSymName);
		}
		else
			lstrcat(rgchBuff, ",0");
	}
	
ret:
	if (pszSymName)
		pfFree(pszSymName);
		
	return;
}


/*
 -	LogCurrentAPI
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

VOID LogCurrentAPI(
	WORD wApi,
	DWORD_PTR *rgdwCallStack,
	DWORD cFrames,
	DWORD_PTR *rgdwArgs,
	DWORD cArgs)
{
	CHAR    rgchT[64];
	CHAR	rgchKeys[8] = "CDARF";
	CHAR    rgchBuff[8192];
	DWORD	cbWritten;

	if (dwTrackMemInMem)
	{
		long lCurr;
		
		// Instead of writing out to a file, just maintain the data in a circular memory list.
		// The overflow check is not thread safe, but if we lose an entry or two after two billion
		// memory functions, oh well.
		if (dwmemtrace == 0xefffffff)
		{
			dwmemtrace = 1;
			lCurr = 0;
		}
		else
			lCurr = (InterlockedIncrement((LONG *)&dwmemtrace) - 1) % dwTrackMemInMem;
			
		memset(&rgmemtrace[lCurr],0,sizeof(MEMTRACE));
		rgmemtrace[lCurr].wApi = wApi;
		memcpy(rgmemtrace[lCurr].rgdwCallStack,rgdwCallStack,cFrames*sizeof(DWORD_PTR));
		memcpy(rgmemtrace[lCurr].rgdwArgs,rgdwArgs,cArgs*sizeof(DWORD_PTR));
		rgmemtrace[lCurr].dwTickCount = GetTickCount();
		rgmemtrace[lCurr].dwThreadId = GetCurrentThreadId();
		return;
	}

	sprintf(rgchBuff, "%c,%lu,%lu", rgchKeys[wApi], GetTickCount(), GetCurrentThreadId());
	
	if (cFrames)
		GetStackSymbols(GetCurrentProcess(), rgchBuff, rgdwCallStack, cFrames);

	switch (wApi)
	{
	case API_HEAP_CREATE:
		sprintf(rgchT,    ",%ld",      rgdwArgs[0]);	// cbInitSize
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbMaxSize
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[2]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_DESTROY:
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_FREE:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X", rgdwArgs[1]);	// pvFree
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld\n",      rgdwArgs[2]);	// cbFree
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_ALLOC:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbAlloc
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[2]);	// pvAlloc
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_REALLOC:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbOld
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[2]);	// pvOld
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",	   rgdwArgs[3]);	// cbNew
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[4]);	// pvNew
		lstrcat(rgchBuff, rgchT);
		break;
	}

	EnterCriticalSection(&csTrackLog);
	WriteFile((HANDLE)_get_osfhandle(_fileno(hTrackLog)), rgchBuff, strlen(rgchBuff), &cbWritten, NULL);
	LeaveCriticalSection(&csTrackLog);
}


//-----------------------------------------------------------------------------
//	Virtual Memory Support
//-----------------------------------------------------------------------------

#define PAGE_SIZE		4096
#define PvToVMBase(pv)	((LPVOID)((ULONG_PTR)pv & ~0xFFFF))

/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL
VMValidatePvEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	LPVOID	pvBase;
	LPBYTE	pb;

	pvBase = PvToVMBase(pv);

	pb = (BYTE *)pvBase + sizeof(ULONG);

	while (pb < (BYTE *)pv)
	{
		if (*pb++ != 0xAD)
		{
			char szBuff[1024];
			
			wsprintf(szBuff, "VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
			AssertSz(0, szBuff);
			return FALSE;
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					char szBuff[1024];
					
					wsprintf(szBuff, "VMValidatePvEx(pv=%08lX): Block trailer has been overwritten", pv);
					AssertSz(0, szBuff);
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

LPVOID
WINAPI
VMAllocEx(
	ULONG	cb,
	ULONG	cbCluster)
{
	ULONG	cbAlloc;
	LPVOID	pvR;
	LPVOID	pvC;
	ULONG 	cbPad	= 0;

	// a cluster size of 0 means don't use the virtual allocator.

	AssertSz(cbCluster != 0, "Cluster size is zero.");

	if (cb > 0x400000)
		return NULL;

	if (cb % cbCluster)
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc	= sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
	cbAlloc -= cbAlloc % PAGE_SIZE;
	cbAlloc	+= PAGE_SIZE;

	pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

	if (pvR == 0)
		return NULL;

	pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (pvC != pvR)
	{
		VirtualFree(pvR, 0, MEM_RELEASE);
		return NULL;
	}

	*(ULONG *)pvC = cb;

	memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
		(UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

	if (cbPad)
		memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
			(UINT) cbPad);

	return ((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID
WINAPI
VMFreeEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	VMValidatePvEx(pv, cbCluster);

	if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
	{
		char szBuff[1024];
		
		wsprintf(szBuff, "VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)",
				pv, GetLastError());
		AssertSz(0, szBuff);
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

LPVOID
WINAPI
VMReallocEx(
	LPVOID	pv,
	ULONG	cb,
	ULONG	cbCluster)
{
	LPVOID*	pvNew = 0;
	ULONG	cbCopy;

	VMValidatePvEx(pv, cbCluster);

	cbCopy = *(ULONG *)PvToVMBase(pv);

	if (cbCopy > cb)
		cbCopy = cb;

	pvNew = VMAllocEx(cb, cbCluster);

	if (pvNew)
	{
		memcpy(pvNew, pv, cbCopy);
		VMFreeEx(pv, cbCluster);
	}

	return pvNew;
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

ULONG
WINAPI
VMGetSizeEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	return (*(ULONG *)PvToVMBase(pv));
}

#ifdef	DEBUG
BOOL
__stdcall
FReloadSymbolsCallback(PSTR szModuleName, ULONG_PTR ulBaseOfDLL, ULONG cbSizeOfDLL, void *pvContext)
{
	if (SymGetModuleBase(GetCurrentProcess(), ulBaseOfDLL) == 0)
	{
		if (!SymLoadModule(GetCurrentProcess(),
						   NULL,
						   szModuleName,
						   NULL,
						   ulBaseOfDLL,
						   cbSizeOfDLL))
		{
			Trace("Error loading module %s: %d", szModuleName, GetLastError());
			return FALSE;
		}
	}
	return TRUE;
}


DWORD
WINAPI
ExchmemReloadSymbols(void)
{
	if (!EnumerateLoadedModules(GetCurrentProcess(), FReloadSymbolsCallback, NULL))
	{
		DWORD ec = GetLastError();
		Trace("SymEnumerateModules failed: %d", ec);
		return ec;
	}
	return 0;
}
#endif
#else	// !DEBUG
void
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	//
	//	Fill the stack with 0s on a retail EXCHMEM.
	//
	ZeroMemory(rgdwCaller, cFind*sizeof(DWORD));
}

void
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwCaller, char rgchSymbol[], DWORD cbSymbol)
{
	//
	//	Fill the stack with 0s on a retail EXCHMEM.
	//
	strncpy(rgchSymbol, "Unknown", cbSymbol);
}

DWORD
ExchmemReloadSymbols(void)
{
	return 0;
}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\snprflib\exprflib.cpp ===
/*==========================================================================*\

    Module:        exprflib.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the implentation for exprflib, a perf library. This
                   is the code that runs in the app exporting the counters.

\*==========================================================================*/
#include "stdlib.h"
#include "snprflib.h"
#include "dbgtrace.h"

DWORD InitializeBasicSecurityDescriptor (PSECURITY_DESCRIPTOR *ppSd);

///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of shared memory functions.
//
///////////////////////////////////////////////////////////////////////////////

BOOL FCreateFileMapping (SharedMemorySegment * pSMS,
                         LPCWSTR pcwstrInstanceName,
                         DWORD   dwIndex,
                         DWORD   cbSize);

void CloseFileMapping (SharedMemorySegment * pSMS);


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibrary class declaration. There is one perf library instance per linkee.
//
///////////////////////////////////////////////////////////////////////////////

PerfLibrary::PerfLibrary (LPCWSTR pcwstrPerfName)
{
    wcsncpy (m_wszPerfName, pcwstrPerfName, MAX_PERF_NAME);

    m_wszPerfName[MAX_PERF_NAME-1] = L'\0';     // Ensure NULL termination

    ZeroMemory (m_rgpObjDef, sizeof (m_rgpObjDef));
    m_dwObjDef = 0;
    m_hMap = 0;
    m_pbMap = 0;
}

PerfLibrary::~PerfLibrary (void)
{
    DeInit ();
}

void
PerfLibrary::DeInit (void)
{
    DWORD i;

    // Destroy the PerfObjectDefinition's we owned.
    for (i = 0; i < m_dwObjDef; i++)
    {
        delete m_rgpObjDef[i];
        m_rgpObjDef[i] = NULL;
    }

    m_dwObjDef = 0;

    // Destroy our shared memory mapping.
    if (m_pbMap)
    {
        UnmapViewOfFile ((void*) m_pbMap);
        m_pbMap = 0;
    }

    if (m_hMap)
    {
        CloseHandle (m_hMap);
        m_hMap = 0;
    }
}

PerfObjectDefinition*
PerfLibrary::AddPerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                      DWORD dwObjectNameIndex,
                                      BOOL fInstances)
{
    PerfObjectDefinition* ppod = NULL;

    if (m_dwObjDef < MAX_PERF_OBJECTS)
    {
        ppod = new PerfObjectDefinition (pcwstrObjectName,
                                         dwObjectNameIndex,
                                         fInstances);
        if (NULL == ppod)
            goto Exit;

        m_rgpObjDef[m_dwObjDef++] = ppod;
    }

Exit:
    return ppod;
}

BOOL
PerfLibrary::Init (void)
{
    DWORD i = 0;
    WCHAR wszPerformanceKey[256] = {L'\0'};
    HKEY hKey = NULL;
    LONG status = 0;
    DWORD size, type = 0;
    BOOL fRet = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;

    //
    // Get counter and help index base values from registry and
    // update static data structures by adding base to offset values
    // that are statically defined in the structure initialization
    //
    swprintf (wszPerformanceKey,
               L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance",
               m_wszPerfName );

    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            wszPerformanceKey,
                            0L,
                            KEY_READ,
                            &hKey);
    if (status != ERROR_SUCCESS)
        goto Exit;

    //
    // Get FirstCounter RegValue
    //
    size = sizeof(DWORD);
    status = RegQueryValueEx (hKey,
                              "First Counter",
                              0L,
                              &type,
                              (LPBYTE)&m_dwFirstCounter,
                              &size);
    if (status != ERROR_SUCCESS)
        goto Exit;


    //
    // Get FirstHelp RegValue
    //
    size = sizeof(DWORD);
    status = RegQueryValueEx( hKey,
                              "First Help",
                              0L,
                              &type,
                              (LPBYTE)&m_dwFirstHelp,
                              &size);
    if (status != ERROR_SUCCESS)
        goto Exit;

    //
    //  Initialize the security descriptor with completely open access
    //
    dwErr = InitializeBasicSecurityDescriptor (&pSd);
    if (dwErr) {
        fRet = FALSE;
        goto Exit;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = TRUE;
    //
    // Create the shared memory object for the list of object names.
    //  Return error if it already exists as we cannot operate if this
    //  is the second instance of the app.
    //
    m_hMap = CreateFileMappingW (INVALID_HANDLE_VALUE,
                                 &sa,
                                 PAGE_READWRITE,
                                 0,
                                 (MAX_PERF_OBJECTS * MAX_OBJECT_NAME *
                                   sizeof (WCHAR) + sizeof (DWORD)),
                                 m_wszPerfName);
    if (m_hMap == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
        goto Exit;

    //
    // Map the file into memory
    //
    m_pbMap = (BYTE*) MapViewOfFile (m_hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (!m_pbMap)
        goto Exit;

    //
    // Assign pointers into the shared memory region
    //
    m_pdwObjectNames = (DWORD*) m_pbMap;
    m_prgObjectNames = (OBJECTNAME*) (m_pbMap+sizeof(DWORD));

    //
    // Copy the object names into the shared memory
    //
    *m_pdwObjectNames = m_dwObjDef;

    for (i = 0; i < m_dwObjDef; i++)
    {
        if (m_rgpObjDef[i]->Init( this ))
            wcscpy (m_prgObjectNames[i], m_rgpObjDef[i]->m_wszObjectName);
    }

    fRet = TRUE;

Exit:
    if (hKey)
        RegCloseKey (hKey);

    if (!fRet)
    {
        if (m_pbMap)
        {
            UnmapViewOfFile ((PVOID)m_pbMap);
            m_pbMap = 0;
        }

        if (m_hMap)
        {
            CloseHandle (m_hMap);
            m_hMap = 0;
        }
    }

    if (pSd)
        delete [] (BYTE *) pSd;

    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectDefinition class implementation. There is one of these for each
//  perfmon object exported. Generally there is just one, but not neccessarily.
//
///////////////////////////////////////////////////////////////////////////////


PerfObjectDefinition::PerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                            DWORD dwObjectNameIndex,
                                            BOOL  fInstances) :
    m_dwObjectNameIndex (dwObjectNameIndex),
    m_fInstances (fInstances),
    m_dwCounters (0)
{
    wcsncpy (m_wszObjectName, pcwstrObjectName, MAX_OBJECT_NAME);
    m_wszObjectName[MAX_OBJECT_NAME-1] = L'\0';     // Ensure NULL Terminated

    ZeroMemory (m_rgpCounterDef, sizeof(m_rgpCounterDef));
    m_dwActiveInstances  = 0;
    m_pSMS               = NULL;
    m_dwShmemMappingSize = SHMEM_MAPPING_SIZE;
    m_fCSInit            = FALSE;
    m_pPoiTotal          = NULL;
    m_pPerfObjectType    = NULL;
}

PerfObjectDefinition::~PerfObjectDefinition (void)
{
    DeInit();
}

void
PerfObjectDefinition::DeInit (void)
{
    SharedMemorySegment *pSMS, *pSMSNext;
    DWORD i;

    // First destroy the _Total instance.
    if (m_pPoiTotal)
    {
        delete m_pPoiTotal;
        m_pPoiTotal = NULL;
    }

    //
    // Reset these values in the shared memory so that before we unmap the memory,
    // perfmon won't think that we still have instances & counters running.
    //
    if (m_pPerfObjectType)
    {
        m_pPerfObjectType->NumCounters  = 0;
        m_pPerfObjectType->NumInstances = 0;
    }

    // Destroy the PerfCounterDefinition's we owned.
    for (i = 0; i < m_dwCounters; i++)
    {
        delete m_rgpCounterDef[i];
        m_rgpCounterDef[i] = NULL;
    }

    pSMS = m_pSMS;
    m_pSMS = NULL;

    // Enumerate through all the memory mappings we created and destroy them.
    while (pSMS)
    {
        pSMSNext = pSMS->m_pSMSNext;
        CloseFileMapping (pSMS);
        delete (pSMS);
        pSMS = pSMSNext;
    }

    // Destroy the critical section.
    if (m_fCSInit)
    {
        m_fCSInit = FALSE;
        DeleteCriticalSection (&m_csPerfObjInst);
    }
}

PerfCounterDefinition*
PerfObjectDefinition::AddPerfCounterDefinition (
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale)
{
    PerfCounterDefinition* ppcd = NULL;

    if (m_dwCounters < MAX_OBJECT_COUNTERS)
    {
        ppcd = new PerfCounterDefinition (dwCounterNameIndex,
                                          dwCounterType,
                                          lDefaultScale);
        if (NULL == ppcd)
            goto Exit;

        m_rgpCounterDef[m_dwCounters++] = ppcd;
    }

Exit:
    return ppcd;
}

PerfCounterDefinition*
PerfObjectDefinition::AddPerfCounterDefinition (
                                    PerfCounterDefinition* pCtrRef,
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale)
{
    PerfCounterDefinition* ppcd = NULL;

    if (m_dwCounters < MAX_OBJECT_COUNTERS)
    {
        ppcd = new PerfCounterDefinition (pCtrRef,
                                          dwCounterNameIndex,
                                          dwCounterType,
                                          lDefaultScale);
        if (NULL == ppcd)
            goto Exit;

        m_rgpCounterDef[m_dwCounters++] = ppcd;
    }

Exit:
    return ppcd;
}

BOOL
PerfObjectDefinition::Init (PerfLibrary* pPerfLib)
{
    DWORD  i                 = 0;
    DWORD  dwOffset          = 0;
    DWORD  dwDefinitionLength= 0;
    BOOL   fRet              = FALSE;

    //
    // Compute the size of the shared memory for this object definition
    //

    // Start with the basics:
    //  we need a PERF_OBJECT_TYPE for the object information and
    //  we need a PERF_COUNTER_DEFINITION for each counter in the object
    dwDefinitionLength = (sizeof(PERF_OBJECT_TYPE) +
                           m_dwCounters * sizeof(PERF_COUNTER_DEFINITION));
    // We also keep a DWORD in the shared memory to give the DLL
    //   our pre-computed value for m_dwCounterData
    m_dwDefinitionLength = dwDefinitionLength + sizeof(DWORD);

    // Compute the counter data space
    m_dwCounterData = sizeof(PERF_COUNTER_BLOCK);
    for (i = 0; i < m_dwCounters; i++)
    {
        m_dwCounterData += m_rgpCounterDef[i]->m_dwCounterSize;
    }

    // Compute the per instance space
    m_dwPerInstanceData = (sizeof(INSTANCE_DATA) + m_dwCounterData);

    // Make sure our memory mapping is large enough
    while (m_dwShmemMappingSize < m_dwDefinitionLength || m_dwShmemMappingSize < m_dwPerInstanceData)
        m_dwShmemMappingSize *= 2;

    // Compute the number of instances can be stored in one shmem mapping.
    m_dwInstancesPerMapping = (DWORD)(m_dwShmemMappingSize / m_dwPerInstanceData);
    m_dwInstances1stMapping = (DWORD)((m_dwShmemMappingSize - m_dwDefinitionLength) / m_dwPerInstanceData);

    //
    // Create the shared memory object for the list of object names. If it
    //  already exists, abort!
    //
    m_pSMS = new SharedMemorySegment;
    if (!m_pSMS)
        goto Exit;

    if (!FCreateFileMapping (m_pSMS, m_wszObjectName, 0, m_dwShmemMappingSize))
        goto Exit;

    //
    // Set the pointers to the PERF API structures
    //
    m_pPerfObjectType = (PERF_OBJECT_TYPE*) m_pSMS->m_pbMap;
    m_rgPerfCounterDefinition =
        (PERF_COUNTER_DEFINITION*) (m_pPerfObjectType+1);

    //
    // Initialize the PERF API structures
    //
    m_pPerfObjectType->TotalByteLength          = dwDefinitionLength;
    m_pPerfObjectType->DefinitionLength         = dwDefinitionLength;
    m_pPerfObjectType->HeaderLength             = sizeof (PERF_OBJECT_TYPE);
    m_pPerfObjectType->ObjectNameTitleIndex     = m_dwObjectNameIndex +
                                                  pPerfLib->m_dwFirstCounter ;
    m_pPerfObjectType->ObjectNameTitle          = 0;
    m_pPerfObjectType->ObjectHelpTitleIndex     = m_dwObjectNameIndex +
                                                  pPerfLib->m_dwFirstHelp;
    m_pPerfObjectType->ObjectHelpTitle          = 0;
    m_pPerfObjectType->DetailLevel              = PERF_DETAIL_NOVICE;
    m_pPerfObjectType->NumCounters              = m_dwCounters;
    m_pPerfObjectType->CodePage                 = (DWORD) 0xffffffff;
    m_pPerfObjectType->DefaultCounter           = 0;
    if( !m_fInstances )
        m_pPerfObjectType->NumInstances         = PERF_NO_INSTANCES;
    else
        m_pPerfObjectType->NumInstances         = 0;

    //
    // Have all of the PerfCounterDefinition's in this object intialize their
    //  PERF_COUNTER_DEFINITION structures in the shared memory
    //
    dwOffset = sizeof (PERF_COUNTER_BLOCK);
    for (i = 0; i < m_dwCounters; i++)
        m_rgpCounterDef[i]->Init(pPerfLib, m_rgPerfCounterDefinition + i, &dwOffset);

    // Save value for dwCounterData in shared memory for DLL
    *((DWORD*) (m_pSMS->m_pbMap + dwDefinitionLength)) = m_dwCounterData;

    //
    // Initialzie the critical section to protects the creation/deletion of
    // perf object instances.  Use AndSpinCount variation to avoid exception
    // handling.
    //
    if (!InitializeCriticalSectionAndSpinCount(&m_csPerfObjInst, 0x80000000))
        goto Exit;

    m_fCSInit = TRUE;

    // Create the _Total instance as the 1st instance if there will be multiple instances
    if (m_fInstances)
    {
        m_pPoiTotal = AddPerfObjectInstance (L"_Total");
        if (!m_pPoiTotal)
            goto Exit;
    }

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        if (m_pPoiTotal)
        {
            delete m_pPoiTotal;
            m_pPoiTotal = NULL;
        }

        if (m_fCSInit)
        {
            DeleteCriticalSection (&m_csPerfObjInst);
            m_fCSInit = FALSE;
        }

        if (m_pSMS)
        {
            CloseFileMapping (m_pSMS);
            delete (m_pSMS);
            m_pSMS = NULL;
        }
    }

    return fRet;
}

DWORD
PerfObjectDefinition::GetCounterOffset (DWORD dwId)
{
    for (DWORD i = 0; i < m_dwCounters; i++)
        if (m_rgpCounterDef[i]->m_dwCounterNameIndex == dwId)
            return m_rgpCounterDef[i]->m_dwOffset;

    return 0;
}

PerfObjectInstance*
PerfObjectDefinition::AddPerfObjectInstance (LPCWSTR pwcstrInstanceName)
{
    PerfObjectInstance*  ppoi     = NULL;
    char* pCounterData            = NULL;
    INSTANCE_DATA* pInstData      = 0;
    LONG  lID                     = 0;
    SharedMemorySegment* pSMS     = NULL;
    SharedMemorySegment* pSMSPrev = NULL;
    SharedMemorySegment* pSMSNew  = NULL;
    DWORD dwInstances             = 0;
    DWORD dwInstIndex             = 0;
    DWORD dwSMS                   = 0;
    BOOL  fCSEntered              = FALSE;
    BOOL  fSuccess                = FALSE;

    //
    // Make sure we've been initialized
    //
    if (!m_pSMS || !m_fCSInit)
        goto Exit;

    //
    // Instances may be created in different threads. Need to protect the following code.
    //
    EnterCriticalSection (&m_csPerfObjInst);
    fCSEntered = TRUE;

    if (!m_fInstances)
    {
        // See if we have already created the single instance of this object
        if (m_dwActiveInstances != 0)
            goto Exit;

        pCounterData = (char *)(m_pSMS->m_pbMap) + m_dwDefinitionLength;
    }
    else
    {
        //
        // Find a free instance in current mapped segments.
        //
        pSMS = m_pSMS;
        lID  = 0;

        while (pSMS)
        {
            if (0 == dwSMS++)
            {
                //
                // If this is the first mapping, offset pCounterData by m_dwDefinitionLength.
                //
                pCounterData = (char *)(pSMS->m_pbMap) + m_dwDefinitionLength;
                dwInstances  = m_dwInstances1stMapping;
            }
            else
            {
                //
                // Otherwise, pCounterData starts from the 1st byte of the mapping.
                //
                pCounterData = (char *)(pSMS->m_pbMap);
                dwInstances  = m_dwInstancesPerMapping;
            }

            for (dwInstIndex = 0;
                 dwInstIndex < dwInstances;
                 pCounterData += sizeof (INSTANCE_DATA) + m_dwCounterData, dwInstIndex++)
            {
                if (!((INSTANCE_DATA*) pCounterData)->fActive)
                {
                    pInstData    = (INSTANCE_DATA*) pCounterData;
                    pCounterData = pCounterData + sizeof (INSTANCE_DATA);
                    goto Found;
                }

                lID++;
            }

            pSMSPrev = pSMS;
            pSMS     = pSMS->m_pSMSNext;
        }

        //
        // If cannot find a free instance, create a new segment.
        //
        pSMSNew = new SharedMemorySegment;
        if (!pSMSNew)
            goto Exit;

        if (!FCreateFileMapping (pSMSNew, m_wszObjectName, dwSMS, m_dwShmemMappingSize))
            goto Exit;

        pInstData    = (INSTANCE_DATA*) (pSMSNew->m_pbMap);
        pCounterData = (char*) (pSMSNew->m_pbMap) + sizeof (INSTANCE_DATA);

        //
        // Add the new segment to our segment linked list.
        //
        pSMSPrev->m_pSMSNext = pSMSNew;
    }

Found:
    //
    // We successfully found a free space for new instance.
    //
    ppoi = new PerfObjectInstance (this, pwcstrInstanceName);
    if (!ppoi)
        goto Exit;

    ppoi->Init(pCounterData, pInstData, lID);

    m_pPerfObjectType->NumInstances++;
    m_dwActiveInstances++;
    fSuccess = TRUE;

Exit:
    if (fCSEntered)
        LeaveCriticalSection (&m_csPerfObjInst);

    if (!fSuccess)
    {
        if (pSMSNew)
        {
            CloseFileMapping (pSMSNew);
            delete (pSMSNew);
        }

        if (ppoi)
        {
            delete ppoi;
            ppoi = NULL;
        }
    }

    return ppoi;
}


void PerfObjectDefinition::DeletePerfObjectInstance ()
{
    EnterCriticalSection (&m_csPerfObjInst);

    m_dwActiveInstances--;
    m_pPerfObjectType->NumInstances--;

    LeaveCriticalSection (&m_csPerfObjInst);
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfCounterDefinition class declaration. There is one of these per counter.
//
///////////////////////////////////////////////////////////////////////////////


PerfCounterDefinition::PerfCounterDefinition (DWORD dwCounterNameIndex,
                                              DWORD dwCounterType,
                                              LONG lDefaultScale) :
    m_pCtrRef (NULL),
    m_dwCounterNameIndex (dwCounterNameIndex),
    m_lDefaultScale (lDefaultScale),
    m_dwCounterType (dwCounterType)
{
    if (m_dwCounterType & PERF_SIZE_LARGE)
        m_dwCounterSize = sizeof (LARGE_INTEGER);
    else
        m_dwCounterSize = sizeof (DWORD);
}


PerfCounterDefinition::PerfCounterDefinition (PerfCounterDefinition* pCtrRef,
                                              DWORD dwCounterNameIndex,
                                              DWORD dwCounterType,
                                              LONG lDefaultScale) :
    m_pCtrRef (pCtrRef),
    m_dwCounterNameIndex (dwCounterNameIndex),
    m_lDefaultScale (lDefaultScale),
    m_dwCounterType (dwCounterType),
    m_dwCounterSize (0)
{
}

void
PerfCounterDefinition::Init (PerfLibrary* pPerfLib,
                             PERF_COUNTER_DEFINITION* pdef, PDWORD pdwOffset)
{
    pdef->ByteLength                    = sizeof (PERF_COUNTER_DEFINITION);
    pdef->CounterNameTitleIndex         = m_dwCounterNameIndex +
                                          pPerfLib->m_dwFirstCounter ;
    pdef->CounterNameTitle              = 0;
    pdef->CounterHelpTitleIndex         = m_dwCounterNameIndex +
                                          pPerfLib->m_dwFirstHelp ;
    pdef->CounterHelpTitle              = 0;
    pdef->DefaultScale                  = m_lDefaultScale;
    pdef->DetailLevel                   = PERF_DETAIL_NOVICE;
    pdef->CounterType                   = m_dwCounterType;

    if (m_pCtrRef)
    {
        //
        // This counter uses the data of another counter.
        //
        pdef->CounterSize               = m_pCtrRef->m_dwCounterSize;
        pdef->CounterOffset             = m_pCtrRef->m_dwOffset;
    }
    else
    {
        //
        // This counter has its own data.
        //
        pdef->CounterSize               = m_dwCounterSize;
        pdef->CounterOffset             = *pdwOffset;

        // Save offset
        m_dwOffset = *pdwOffset;

        // Increment offset for next counter definition
        *pdwOffset += m_dwCounterSize;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectInstance class implementation. There is one of these per instance
//  of an object. There is one if there are no instances (the global instance.)
//
///////////////////////////////////////////////////////////////////////////////
PerfObjectInstance::PerfObjectInstance (PerfObjectDefinition* pObjDef,
                                        LPCWSTR pcwstrInstanceName)
{
    m_pObjDef = pObjDef;

    if (pcwstrInstanceName)
    {
        wcsncpy (m_wszInstanceName, pcwstrInstanceName, MAX_INSTANCE_NAME);
        m_wszInstanceName[MAX_INSTANCE_NAME-1] = L'\0';     // Ensure NULL termination!
    }
    else
        *m_wszInstanceName = L'\0';

    m_fInitialized = FALSE;
}

void
PerfObjectInstance::Init (char* pCounterData, INSTANCE_DATA* pInstData, LONG lID)
{
    int cchNameLength = 0;

    m_pCounterData  = pCounterData;
    m_pInstanceData = pInstData;

    // Clear all the counter data
    ZeroMemory( m_pCounterData, m_pObjDef->m_dwCounterData );

    // Set the counter block length
    ((PERF_COUNTER_BLOCK*)m_pCounterData)->ByteLength =
        m_pObjDef->m_dwCounterData;

    if (m_pInstanceData)
    {
        m_pInstanceData->perfInstDef.ByteLength = sizeof (PERF_INSTANCE_DEFINITION);
        m_pInstanceData->perfInstDef.ParentObjectTitleIndex = 0;
        m_pInstanceData->perfInstDef.ParentObjectInstance = 0;
        m_pInstanceData->perfInstDef.UniqueID = PERF_NO_UNIQUE_ID;
        m_pInstanceData->perfInstDef.NameOffset =
            sizeof (PERF_INSTANCE_DEFINITION);

        //
        // The instance-name is copied to wszInstanceName. This is a variable
        // length NULL terminated unicode string. wszInstanceName must end on
        // a 32-bit boundary, so that the perf-data that follows this string
        // is 32-bit aligned. Therefore, if wszInstance contains an odd number
        // of WCHARS, we add an extra WCHAR to 32-bit align it. The length of
        // the instance name in bytes, including the terminating NULL and the
        // padding byte (if present) is written to perfInstDef.NameLength.
        //

        cchNameLength = wcslen(m_wszInstanceName) + 1;

        if(cchNameLength > MAX_INSTANCE_NAME)
        {
            // MAX_INSTANCE_NAME is already 32 bit aligned
            _ASSERT(0 == (MAX_INSTANCE_NAME & 1));
            cchNameLength = MAX_INSTANCE_NAME;
        }
        else if(cchNameLength & 1)
        {
            cchNameLength++;
        }

        m_pInstanceData->perfInstDef.NameLength = cchNameLength * sizeof(WCHAR);
        m_pInstanceData->perfInstDef.ByteLength += cchNameLength * sizeof(WCHAR);

        CopyMemory(m_pInstanceData->wszInstanceName, m_wszInstanceName,
            cchNameLength * sizeof(WCHAR));

        // If the name got truncated, there may not have been a terminating NULL
        m_pInstanceData->wszInstanceName[MAX_INSTANCE_NAME - 1] = L'\0';
        m_pInstanceData->fActive = TRUE;
    }

    m_fInitialized = TRUE;
}

VOID
PerfObjectInstance::DeInit (void)
{
    if (m_fInitialized)
    {
        m_fInitialized = FALSE;
        if (m_pInstanceData)
        {
            m_pInstanceData->fActive = FALSE;
            m_pInstanceData = NULL;
        }
    }

    m_pObjDef->DeletePerfObjectInstance();
}

DWORD* PerfObjectInstance::GetDwordCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (DWORD*) (m_pCounterData + dwOffset);
    }

    return 0;
}


LARGE_INTEGER* PerfObjectInstance::GetLargeIntegerCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (LARGE_INTEGER*) (m_pCounterData + dwOffset);
    }

    return 0;
}

QWORD* PerfObjectInstance::GetQwordCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (QWORD*) (m_pCounterData + dwOffset);
    }

    return 0;
}

//---------------------------------------------------------------------------
//  Description:
//      Allocates and returns a SECURITY_DESCRIPTOR structure initialized to
//      allow all users access. This security descriptor is used to set the
//      security for the shared memory objects created by snprflib.
//  Arguments:
//      OUT pSd Pass in a pointer to SECURITY_DESCRIPTOR, on success this will
//          be set to a suitably initialized SECURITY_DESCRIPTOR. Caller frees
//          memory pointed to by pSd.
//  Returns:
//      ERROR_SUCCESS on success.
//      Win32 error to indicate failure.
//---------------------------------------------------------------------------
DWORD InitializeBasicSecurityDescriptor (PSECURITY_DESCRIPTOR *ppSd)
{ 
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSidWorld = NULL;
    PSID pSidCreator = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    ACL *pAcl = NULL;
    DWORD dwAclSize = 0;

    *ppSd = NULL;
    if (!AllocateAndInitializeSid (
            &WorldAuthority,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSidWorld)){

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!AllocateAndInitializeSid (
            &CreatorAuthority,
            1,
            SECURITY_CREATOR_OWNER_RID,
            0,0,0,0,0,0,0,
            &pSidCreator)){

        dwErr = GetLastError ();
        goto Exit;
    }

    dwAclSize = sizeof (ACL) +
                (sizeof (ACCESS_ALLOWED_ACE) - sizeof (LONG)) +
                GetLengthSid (pSidWorld) +
                (sizeof (ACCESS_ALLOWED_ACE) - sizeof (LONG)) +
                GetLengthSid (pSidCreator);

    //
    //  Allocate SD and ACL with a single alloc
    //

    *ppSd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize];

    if (!*ppSd) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if (!InitializeSecurityDescriptor (*ppSd, SECURITY_DESCRIPTOR_REVISION)) {
        dwErr = GetLastError ();
        goto Exit;
    }

    pAcl = (ACL *) ((BYTE *) *ppSd + SECURITY_DESCRIPTOR_MIN_LENGTH); 

    if (!InitializeAcl (
            pAcl,
            dwAclSize,
            ACL_REVISION)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!AddAccessAllowedAce (
            pAcl,
            ACL_REVISION,
            GENERIC_WRITE,
            pSidCreator)

            ||

        !AddAccessAllowedAce (
            pAcl,
            ACL_REVISION,
            GENERIC_READ,
            pSidWorld)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl (*ppSd, TRUE, pAcl, FALSE))
        dwErr = GetLastError ();

Exit:
    if (pSidWorld)
        FreeSid (pSidWorld);

    if (pSidCreator)
        FreeSid (pSidCreator);

    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Shared memory management functions
//
///////////////////////////////////////////////////////////////////////////////

BOOL FCreateFileMapping (SharedMemorySegment * pSMS,
                         LPCWSTR pcwstrInstanceName,
                         DWORD   dwIndex,
                         DWORD   cbSize)
{
    WCHAR  pwstrShMem[MAX_PATH];
    WCHAR  pwstrIndex[MAX_PATH];
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;
    HANDLE hMap     = NULL;
    PVOID  pvMap    = NULL;
    BOOL   fSuccess = FALSE;
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Check parameter
    //
    if (!pSMS)
        goto Exit;

    pSMS->m_hMap     = NULL;
    pSMS->m_pbMap    = NULL;
    pSMS->m_pSMSNext = NULL;

    //
    // Append dwIndex to instance name.
    //
    _ultow (dwIndex, pwstrIndex, 16);

    if (wcslen (pcwstrInstanceName) + wcslen (pwstrIndex) >= MAX_PATH)
        goto Exit;

    wcscpy (pwstrShMem, pcwstrInstanceName);
    wcscat (pwstrShMem, pwstrIndex);

    dwErr = InitializeBasicSecurityDescriptor (&pSd);
    if (dwErr)
        goto Exit;

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = TRUE;

    //
    // Create the shared memory object. If it already exists, abort!
    //
    hMap = CreateFileMappingW (INVALID_HANDLE_VALUE,
                               &sa,
                               PAGE_READWRITE,
                               0,
                               cbSize,
                               pwstrShMem);

    if (hMap == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
        goto Exit;

    //
    // Map the file into memory
    //
    pvMap = MapViewOfFile (hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (!pvMap)
        goto Exit;

    ZeroMemory (pvMap, cbSize);

    //
    // Succeeds. Now store the results into pSMS.
    //
    pSMS->m_hMap = hMap;
    pSMS->m_pbMap = (BYTE *)pvMap;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        if (pvMap)
            UnmapViewOfFile (pvMap);

        if (hMap)
            CloseHandle (hMap);
    }
    if (pSd)
        delete [] (BYTE *) pSd;

    return fSuccess;
}


void CloseFileMapping (SharedMemorySegment * pSMS)
{
    if (pSMS)
    {
        if (pSMS->m_pbMap)
        {
            UnmapViewOfFile ((PVOID)pSMS->m_pbMap);
            pSMS->m_pbMap = NULL;
        }

        if (pSMS->m_hMap)
        {
            CloseHandle (pSMS->m_hMap);
            pSMS->m_hMap = NULL;
        }

        pSMS->m_pSMSNext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\snprfdll\exprfdll.cpp ===
/*==========================================================================*\

    Module:        exprfdll.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the implementation for exprfdll, a perf dll. This
                   is for the dll that runs in perfmon. It supports multiple
                   libraries (monitored services.)

\*==========================================================================*/

///////////////////////////////////////////////////////////////////////////////
//
// Includes
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <winperf.h>

#include "snprflib.h"
#include "exprfdll.h"
#include <stdlib.h>
#include "exchmem.h"

///////////////////////////////////////////////////////////////////////////////
//
// Declare Global variables
//
///////////////////////////////////////////////////////////////////////////////
LPCWSTR g_wszPrefixGlobal = L"Global\\";
WCHAR   g_rgszLibraries[MAX_PERF_LIBS][MAX_PERF_NAME];  // Names of the libraries we are monitoring
BOOL    g_rgfInitOk[MAX_PERF_LIBS] = {FALSE};           // Flags to indicate if initialization was a success

// index for g_rgszLibraries & g_rgfInitOk
enum LibIndex
{
    LIB_NTFSDRV = 0
};


///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of shared memory functions.
//
///////////////////////////////////////////////////////////////////////////////
BOOL FOpenFileMapping (SharedMemorySegment * pSMS,
                       LPCWSTR pcwstrInstanceName,
                       DWORD   dwIndex);

void CloseFileMapping (SharedMemorySegment * pSMS);


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibraryData class implementation
//
///////////////////////////////////////////////////////////////////////////////
PerfLibraryData::PerfLibraryData()
{
    m_hShMem    = 0;
    m_pbShMem   = 0;
    m_dwObjects = 0;
}

PerfLibraryData::~PerfLibraryData()
{
    Close();
}

BOOL PerfLibraryData::GetPerformanceStatistics (LPCWSTR pcwstrLibrary)
{
    BOOL  fRet = FALSE;
    DWORD i = 0;

    //
    // Open the mapping for the perf library information
    //
    m_hShMem = OpenFileMappingW (FILE_MAP_READ, FALSE, pcwstrLibrary);
    if (!m_hShMem)
        goto Exit;

    m_pbShMem = (BYTE*) MapViewOfFile (m_hShMem, FILE_MAP_READ, 0, 0, 0);
    if (!m_pbShMem)
        goto Exit;

    //
    // Get the number of objects in the shared memory
    //
    m_dwObjects = *(DWORD*) m_pbShMem;
    m_prgObjectNames = (OBJECTNAME*) (m_pbShMem + sizeof(DWORD));

    //
    // Loop through objects and get perf data for each
    //
    for (i = 0; i < m_dwObjects; i++) {
        if(!m_rgObjectData[i].GetPerformanceStatistics (m_prgObjectNames[i]))
            goto Exit;
    }

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        if (m_pbShMem)
        {
            UnmapViewOfFile ((PVOID)m_pbShMem);
            m_pbShMem = NULL;
        }

        if (m_hShMem)
        {
            CloseHandle (m_hShMem);
            m_hShMem = NULL;
        }
    }

    return fRet;
}

VOID PerfLibraryData::Close (VOID)
{
    if (m_pbShMem)
    {
        UnmapViewOfFile ((PVOID) m_pbShMem);
        m_pbShMem = 0;
    }

    if (m_hShMem)
    {
        CloseHandle (m_hShMem);
        m_hShMem = 0;
    }

    for (DWORD i = 0; i < m_dwObjects; i++)
        m_rgObjectData[i].Close();
}

DWORD PerfLibraryData::SpaceNeeded (DWORD dwQueryType, LPCWSTR lpwstrObjects)
{
    DWORD dwSpaceNeeded = 0;

    for (DWORD i = 0; i < m_dwObjects; i++)
        dwSpaceNeeded += m_rgObjectData[i].SpaceNeeded (dwQueryType, lpwstrObjects);

    return dwSpaceNeeded;
}

VOID PerfLibraryData::SavePerformanceData (PVOID* ppv, DWORD* pdwBytes, DWORD* pdwObjects )
{
    for (DWORD i = 0; i < m_dwObjects; i++)
        m_rgObjectData[i].SavePerformanceData (ppv, pdwBytes, pdwObjects);
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectData class implementation
//
///////////////////////////////////////////////////////////////////////////////
PerfObjectData::PerfObjectData()
{
    m_fObjectRequested = FALSE;
    m_dwSpaceNeeded = 0;
    m_pSMS = NULL;
    m_wszObjectName[0] = L'\0';
}

PerfObjectData::~PerfObjectData()
{
    Close();
}

BOOL PerfObjectData::GetPerformanceStatistics (LPCWSTR pcwstrObjectName)
{
    DWORD dwPerInstanceData  = 0;
    DWORD dwShmemMappingSize = SHMEM_MAPPING_SIZE;
    BOOL  fSuccess = FALSE;

    // Remember the object name
    wcsncpy (m_wszObjectName, pcwstrObjectName, MAX_OBJECT_NAME);
    m_wszObjectName[MAX_OBJECT_NAME-1] = L'\0';     // Ensure NULL Terminated

    // Open the 1st shared memory segment
    m_pSMS = new SharedMemorySegment;
    if (!m_pSMS)
        goto Exit;

    if (!FOpenFileMapping (m_pSMS, pcwstrObjectName, 0))
        goto Exit;

    // First in the shared memory is the PERF_OBJECT_TYPE
    m_pObjType = (PERF_OBJECT_TYPE*) m_pSMS->m_pbMap;

    // Then an array of PERF_COUNTER_DEFINITION
    m_prgCounterDef = (PERF_COUNTER_DEFINITION*) (m_pObjType + 1);

    // Then a DWORD that tells the size of each counter block
    m_pdwCounterData = (DWORD*) (m_pSMS->m_pbMap + sizeof(PERF_OBJECT_TYPE) +
                                (m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION)));

    if (m_pObjType->NumInstances == PERF_NO_INSTANCES)
    {
        m_pCounterBlock = (PERF_COUNTER_BLOCK*) (m_pdwCounterData+1);
        m_pbCounterBlockTotal = NULL;
    }
    else
    {
        m_pCounterBlock = NULL;
        m_pbCounterBlockTotal = (PBYTE)(m_pdwCounterData+1) + sizeof(INSTANCE_DATA);
    }

    // Compute the size of per instance data & object definition.
    dwPerInstanceData = sizeof(INSTANCE_DATA) + *m_pdwCounterData;
    m_dwDefinitionLength = sizeof(PERF_OBJECT_TYPE) +
                           m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION) + sizeof(DWORD);

    // Make sure our memory mapping is large enough.
    while (dwShmemMappingSize < dwPerInstanceData || dwShmemMappingSize < m_dwDefinitionLength)
        dwShmemMappingSize *= 2;

    // Compute the number of instances can be stored in one shmem mapping.
    m_dwInstancesPerMapping = (DWORD)(dwShmemMappingSize / dwPerInstanceData);
    m_dwInstances1stMapping = (DWORD)((dwShmemMappingSize - m_dwDefinitionLength) / dwPerInstanceData);

    fSuccess = TRUE;

Exit:
    if (!fSuccess && m_pSMS)
    {
        CloseFileMapping (m_pSMS);
        delete m_pSMS;
        m_pSMS = NULL;
    }

    return fSuccess;
}

VOID PerfObjectData::Close (VOID)
{
    SharedMemorySegment *pSMS, *pSMSNext;

    pSMS = m_pSMS;
    m_pSMS = NULL;

    while (pSMS)
    {
        pSMSNext = pSMS->m_pSMSNext;
        CloseFileMapping (pSMS);
        delete pSMS;
        pSMS = pSMSNext;
    }
}

DWORD PerfObjectData::SpaceNeeded (DWORD dwQueryType, LPCWSTR lpwstrObjects)
{
    DWORD dwSpaceNeeded = 0;

    if (dwQueryType == QUERY_GLOBAL ||
        IsNumberInUnicodeList (m_pObjType->ObjectNameTitleIndex, lpwstrObjects))
    {
        // Remember for later that this object was requested.
        m_fObjectRequested = TRUE;

        // Compute space needed... always need enough for the object def. and
        // all the counter defs
        dwSpaceNeeded = sizeof(PERF_OBJECT_TYPE) + (m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION));

        // It is a bit different depending on if there are multiple instances
        if( m_pObjType->NumInstances != PERF_NO_INSTANCES )
        {
            // If multi-instance, we have one instance def, one instance name
            // plus the counter data for each instance
            dwSpaceNeeded += m_pObjType->NumInstances * (sizeof(PERF_INSTANCE_DEFINITION) +
                sizeof(INSTANCENAME) + *m_pdwCounterData);
        }
        else
        {
            // Else we just have the counter data
            dwSpaceNeeded += *m_pdwCounterData;
        }
    }

    m_dwSpaceNeeded = dwSpaceNeeded;

    return dwSpaceNeeded;
}

void PerfObjectData::SavePerformanceData (VOID** ppv, DWORD* pdwBytes, DWORD* pdwObjects)
{
    BYTE*                pb;
    INSTANCE_DATA*       pInst;
    DWORD                dwBytes = 0;
    PERF_OBJECT_TYPE*    pobj;
    PERF_COUNTER_BLOCK*  pcb;
    PERF_COUNTER_BLOCK*  pcbTotalCounter = NULL;
    SharedMemorySegment* pSMS        = NULL;
    SharedMemorySegment* pSMSNext    = NULL;
    DWORD                dwMapping   = 0;
    DWORD                dwInstances = 0;
    DWORD                dwInstIndex = 0;
    BYTE*                pbTotal     = NULL;
    BYTE*                pbCounterData = NULL;
    INSTANCE_DATA*       pInstTotal  = NULL;
    DWORD                dwInstancesCopied = 0;
    DWORD                dwInstanceSize = 0;

    //
    // If this object wasn't requested (as determined by SpaceNeeded()), then
    // we don't do anything.
    //
    if (!m_fObjectRequested)
        return;

    // Get pointer to output buffer
    pb = (BYTE*) *ppv ;

    //
    // Copy the performance data to the output buffer
    //

    // Copy a PERF_OBJECT_TYPE structure
    CopyMemory (pb, m_pObjType, sizeof(PERF_OBJECT_TYPE));
    pobj = (PERF_OBJECT_TYPE*) pb;

    pb += sizeof(PERF_OBJECT_TYPE);
    dwBytes += sizeof(PERF_OBJECT_TYPE);

    // Copy the counter definitions
    CopyMemory (pb, m_prgCounterDef, pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION));

    pb += pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION) ;
    dwBytes += pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION) ;

    if (pobj->NumInstances == PERF_NO_INSTANCES)
    {
        // Copy the counter block
        CopyMemory (pb, m_pCounterBlock, *m_pdwCounterData);

        // Fixup the length, because when no instances have been created it
        //  will not be correct.
        pcb = (PERF_COUNTER_BLOCK*) pb;
        pcb->ByteLength = *m_pdwCounterData;

        pb += *m_pdwCounterData;
        dwBytes += *m_pdwCounterData;
    }
    else
    {
        // Enumerate through all the instances and copy them out
        pSMS = m_pSMS;
        dwInstancesCopied = 0;

        for (dwMapping = 0; ; dwMapping++)
        {
            if (0 == dwMapping)
            {
                //
                // If this is the 1st mapping, we have to offset pInst by m_dwDefinitionLength.
                //
                pInst = (INSTANCE_DATA*)((char *)(pSMS->m_pbMap) + m_dwDefinitionLength);
                dwInstances = m_dwInstances1stMapping;
            }
            else
            {
                //
                // Otherwise, open the next memory mapping and point pInst to the begging of that mapping.
                //
                pSMSNext = new SharedMemorySegment;
                if (!pSMSNext)
                    goto Exit;

                if (!FOpenFileMapping (pSMSNext, m_wszObjectName, dwMapping)) {
                    delete pSMSNext;
                    goto Exit;
                }

                pSMS->m_pSMSNext = pSMSNext;
                pSMS = pSMSNext;

                pInst = (INSTANCE_DATA*)(pSMS->m_pbMap);
                dwInstances = m_dwInstancesPerMapping;
            }

            for (dwInstIndex = 0;
                 dwInstIndex < dwInstances && dwInstancesCopied < (DWORD) (pobj->NumInstances);
                 dwInstIndex++)
            {
                if (pInst->fActive)
                {
                    //
                    // pcb is a pointer in shared-memory pointing to the start of the
                    // PERF_COUNTER_BLOCK and followed by the raw data for the counters.
                    //

                    pcb = (PERF_COUNTER_BLOCK *)((PBYTE)pInst + sizeof(INSTANCE_DATA));

                    //
                    // dwInstanceSize = Size of output data for this instance that will
                    // be copied to pb. For _Total, the data is summed (AddTotal) rather
                    // than copied.
                    //

                    dwInstanceSize =
                        sizeof(PERF_INSTANCE_DEFINITION) +
                        pInst->perfInstDef.NameLength +
                        pcb->ByteLength;

                    if (0 == dwInstancesCopied)
                    {
                        //
                        // The first instance is the _Total instance. The perf-library
                        // does not write _Total counters to shared memory. Instead, we
                        // (ther perf-dll) must calculate these counters by adding the
                        // counter data from the instance counter-data and returning that
                        // data to perfmon.
                        //

                        //
                        // The headers for the _Total instance should be written to pbTotal.
                        // This is done by CopyInstanceData which copies the
                        // PERF_INSTANCE_DEFINITION, PERF_INSTANCE_NAME and PERF_COUNTER_BLOCK
                        // for _Total.
                        //

                        pbTotal = pb;
                        pInstTotal = pInst;
                        CopyInstanceData(pbTotal, pInstTotal);

                        //
                        // pcbTotalCounter points to the area of memory to which the
                        // PERF_COUNTER_BLOCK followed by counter data for _Total should
                        // be written.  Each counter is calculated by adding up the
                        // corresponding counters for the other instances.
                        //

                        pcbTotalCounter =
                            (PERF_COUNTER_BLOCK *) (pb +
                                sizeof(PERF_INSTANCE_DEFINITION) +
                                pInst->perfInstDef.NameLength);

                        // Zero out the counter values for _Total (excluding PERF_COUNTER_BLOCK)
                        ZeroMemory(
                            (PBYTE)pcbTotalCounter + sizeof(PERF_COUNTER_BLOCK),
                            pcb->ByteLength - sizeof(PERF_COUNTER_BLOCK));

                    }
                    else
                    {
                        //
                        // Add the values for the counter data for this instance from shared
                        // memory, to the running total being maintained in the output buffer,
                        // pcbTotalCounter.
                        //

                        if(pbTotal)
                            AddToTotal (pcbTotalCounter, pcb);

                        //
                        // Copy the headers: PERF_INSTANCE_DEFINITION, PERF_INSTANCE_NAME
                        // and PERF_COUNTER_BLOCK for this instance
                        //

                        CopyInstanceData(pb, pInst);

                        //
                        // Copy the counter data from shared memory to the output buffer
                        // PERF_COUNTER_BLOCK has already been copied by CopyInstanceData
                        // so we exclude that.
                        //

                        pbCounterData = pb +
                            sizeof(PERF_INSTANCE_DEFINITION) +
                            pInst->perfInstDef.NameLength +
                            sizeof(PERF_COUNTER_BLOCK);

                        CopyMemory(
                            pbCounterData,
                            (PBYTE)pcb + sizeof(PERF_COUNTER_BLOCK),
                            pcb->ByteLength - sizeof(PERF_COUNTER_BLOCK));

                    }


                    pb += dwInstanceSize;
                    dwBytes += dwInstanceSize;

                    dwInstancesCopied++;
                }

                pInst = (INSTANCE_DATA*)(((char*)pInst) + sizeof(INSTANCE_DATA) + *m_pdwCounterData);
            }
        }
    }

Exit:
    // dwBytes must be aligned on an 8-byte boundary
    dwBytes = QWORD_MULTIPLE(dwBytes);

    // Update parameters in the output buffer
    pobj->TotalByteLength = dwBytes;

    // Update buffer pointer, count of bytes and count of objects.
    *ppv = ((PBYTE) *ppv) + dwBytes;
    *pdwBytes += dwBytes;


    (*pdwObjects)++;
}

//------------------------------------------------------------------------------
//  Description:
//      Extracts and copies the PERF_INSTANCE_DEFINITION, perf-instance-name
//      and PERF_COUNTER_BLOCK structures given the INSTANCE_DATA pointer within
//      shared memory to the output buffer to perfmon.
//  Arguments:
//      OUT PBYTE pb - Output buffer to perfmon
//      IN INSTANCE_DATA *pInst - Pointer within shared-memory segment to the
//          INSTANCE_DATA structure. This structure is immediately followed by
//          a PERF_COUNTER_BLOCK structure.
//  Returns:
//      Nothing.
//------------------------------------------------------------------------------
void PerfObjectData::CopyInstanceData(PBYTE pb, INSTANCE_DATA *pInst)
{
    PERF_COUNTER_BLOCK *pcb = NULL;
    DWORD cbInstanceName = 0;

    //
    // The first bytes in shared memory are the INSTANCE_DEFINITION
    // structure. Copy the PERF_INSTANCE_DEFINITION member of this
    // structure into the output buffer.
    //

    CopyMemory(pb, &(pInst->perfInstDef), sizeof(PERF_INSTANCE_DEFINITION));
    pb += sizeof(PERF_INSTANCE_DEFINITION);

    //
    // Next, within INSTANCE_DEFINITION, there is a buffer sized
    // MAX_INSTANCE_NAME. Copy the instance name, which is a NULL
    // terminated unicode string in this buffer. The length in bytes
    // to be copied is given by PERF_INSTANCE_DEFINITION.NameLength.
    // This includes length includes the terminating NULL and possibly
    // an extra padding-byte to 32-bit align the end of the buffer.
    //

    cbInstanceName = pInst->perfInstDef.NameLength;
    CopyMemory(pb, (char *)(pInst->wszInstanceName), cbInstanceName);
    pb += cbInstanceName;

    // Finally there is a PERF_COUNTER_BLOCK structure after the INSTANCE_DATA
    pcb = (PERF_COUNTER_BLOCK *)((PBYTE)pInst + sizeof(INSTANCE_DATA));
    CopyMemory(pb, pcb, sizeof(PERF_COUNTER_BLOCK));
}

void PerfObjectData::AddToTotal(
    PERF_COUNTER_BLOCK *pcbTotalCounters,
    PERF_COUNTER_BLOCK *pcbInstCounters)
{
    DWORD i;
    PBYTE pbTotalCounter = NULL;
    PBYTE pbInstCounter  = NULL;

    for (i = 0; i < m_pObjType->NumCounters; i++)
    {
        // Offset pointers to the first byte of the actual counter
        pbTotalCounter = (PBYTE)(pcbTotalCounters) + m_prgCounterDef[i].CounterOffset;
        pbInstCounter = (PBYTE)(pcbInstCounters) + m_prgCounterDef[i].CounterOffset;

        // If this is a 'rate' counter, it is referencing some other 'raw' counter.
        // In this case, we should not add that raw counter again.
        if ((m_prgCounterDef[i].CounterType & PERF_TYPE_COUNTER) &&
            (m_prgCounterDef[i].CounterType & PERF_COUNTER_RATE))
            continue;

        /* we only have LARGE_INTEGER and DWORD counters as of PT 3728 */
        if ((m_prgCounterDef[i].CounterType & PERF_TYPE_NUMBER) &&
            (m_prgCounterDef[i].CounterType & PERF_SIZE_LARGE))
        {
            ((LARGE_INTEGER*)pbTotalCounter)->LowPart  += ((LARGE_INTEGER*)pbInstCounter)->LowPart;
            ((LARGE_INTEGER*)pbTotalCounter)->HighPart += ((LARGE_INTEGER*)pbInstCounter)->LowPart;
        }
        else
        {
            *(DWORD*)pbTotalCounter += *(DWORD*)pbInstCounter;
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Shared Memory Functions
//
///////////////////////////////////////////////////////////////////////////////

BOOL FOpenFileMapping (SharedMemorySegment * pSMS,
                       LPCWSTR pcwstrInstanceName,
                       DWORD   dwIndex)
{
    WCHAR  pwstrShMem[MAX_PATH];
    WCHAR  pwstrIndex[MAX_PATH];
    HANDLE hMap     = NULL;
    PVOID  pvMap    = NULL;
    BOOL   fSuccess = FALSE;

    if (!pSMS)
        goto Exit;

    pSMS->m_hMap     = NULL;
    pSMS->m_pbMap    = NULL;
    pSMS->m_pSMSNext = NULL;

    _ultow (dwIndex, pwstrIndex, 16);

    if (wcslen (g_wszPrefixGlobal) + wcslen (pcwstrInstanceName) + wcslen (pwstrIndex) >= MAX_PATH)
        goto Exit;

    wcscpy (pwstrShMem, g_wszPrefixGlobal);
    wcscat (pwstrShMem, pcwstrInstanceName);
    wcscat (pwstrShMem, pwstrIndex);

    hMap = OpenFileMappingW (FILE_MAP_READ, FALSE, pwstrShMem);
    if (!hMap)
        goto Exit;

    pvMap = MapViewOfFile (hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvMap)
        goto Exit;

    pSMS->m_hMap  = hMap;
    pSMS->m_pbMap = (BYTE *)pvMap;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        if (pvMap)
            UnmapViewOfFile (pvMap);

        if (hMap)
            CloseHandle (hMap);
    }

    return fSuccess;
}


void CloseFileMapping (SharedMemorySegment * pSMS)
{
    if (pSMS)
    {
        if (pSMS->m_pbMap)
        {
            UnmapViewOfFile ((PVOID)pSMS->m_pbMap);
            pSMS->m_pbMap = NULL;
        }

        if (pSMS->m_hMap)
        {
            CloseHandle (pSMS->m_hMap);
            pSMS->m_hMap = NULL;
        }

        pSMS->m_pSMSNext = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Utility Functions
//
///////////////////////////////////////////////////////////////////////////////
//
// IsPrefix()
//      returns TRUE if s1 is a prefix of s2
//
BOOL
IsPrefix (WCHAR* s1, WCHAR* s2)
{
    while (*s1 && *s2)
    {
        if (*s1++ != *s2++)
        {
            return FALSE;
        }
    }

    return (*s1 == 0);
}



//
// GetQueryType()
//
//    returns the type of query described in the lpValue string so that
//    the appropriate processing method may be used
//
// Return Value
//
//     QUERY_GLOBAL
//         if lpValue == 0 (null pointer)
//            lpValue == pointer to Null string
//            lpValue == pointer to "Global" string
//
//     QUERY_FOREIGN
//         if lpValue == pointer to "Foreign" string
//
//     QUERY_COSTLY
//         if lpValue == pointer to "Costly" string
//
//     otherwise:
//
//     QUERY_ITEMS
//
DWORD GetQueryType (LPWSTR lpValue)
{
    if (lpValue == 0 || *lpValue == 0 || IsPrefix( L"Global", lpValue))
        return QUERY_GLOBAL;
    else if (IsPrefix (L"Foreign", lpValue))
        return QUERY_FOREIGN;
    else if (IsPrefix (L"Costly" , lpValue))
        return QUERY_COSTLY;
    else
        return QUERY_ITEMS;
}


int inline EvalThisChar (WCHAR c, WCHAR d)
{
    if (c == d || c == L'\0')
        return DELIMITER;
    else if (L'0' <= c && c <= L'9')
        return DIGIT;
    else
        return INVALID;
}


BOOL IsNumberInUnicodeList (DWORD dwNumber, LPCWSTR lpwszUnicodeList)
{
    DWORD   dwThisNumber = 0;
    const WCHAR* pwcThisChar = lpwszUnicodeList;
    BOOL    bValidNumber = FALSE;
    BOOL    bNewItem = TRUE;
    WCHAR   wcDelimiter = L' ';

    // If null pointer, number not found
    if (lpwszUnicodeList == 0)
        return FALSE;

    //
    // Loop until done...
    //
    for(;;)
    {
        switch (EvalThisChar(*pwcThisChar, wcDelimiter))
        {
        case DIGIT:
            //
            // If this is the first digit after a delimiter, then
            // set flags to start computing the new number
            //
            if (bNewItem)
            {
                bNewItem = FALSE;
                bValidNumber = TRUE;
            }
            if (bValidNumber)
            {
                dwThisNumber *= 10;
                dwThisNumber += (*pwcThisChar - L'0');
            }
            break;

        case DELIMITER:
            //
            // A delimiter is either the delimiter character or the
            // end of the string ('\0') if when the delimiter has been
            // reached a valid number was found, then compare it to the
            // number from the argument list. if this is the end of the
            // string and no match was found, then return.
            //
            if (bValidNumber)
            {
                if (dwThisNumber == dwNumber)
                    return TRUE;
                bValidNumber = FALSE;
            }

            if (*pwcThisChar == 0)
            {
                return FALSE;
            }
            else
            {
                bNewItem = TRUE;
                dwThisNumber = 0;
            }

            break;

        case INVALID:
            //
            // If an invalid character was encountered, ignore all
            // characters up to the next delimiter and then start fresh.
            // the invalid number is not compared.
            //
            bValidNumber = FALSE;
            break;

        default:
            break;
        }

        pwcThisChar++;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Utility functions called by the exported perfmon APIs
//
///////////////////////////////////////////////////////////////////////////////

DWORD Open (LibIndex iLib, LPCWSTR  pcwstrLib)
{
    HANDLE hMHeap = NULL;

    hMHeap = ExchMHeapCreate (0, 0, 100 * 1024, 0);
    if (NULL == hMHeap)
        goto Exit;

    lstrcpyW (g_rgszLibraries[iLib], g_wszPrefixGlobal);
    lstrcatW (g_rgszLibraries[iLib], pcwstrLib);
    g_rgfInitOk[iLib] = TRUE;

Exit:
    return ERROR_SUCCESS;
}

DWORD Collect (LibIndex iLib,
               LPWSTR lpwszValue,
               void** ppdata,
               DWORD* pdwBytes,
               DWORD* pdwObjectTypes)
{
    DWORD               dwQueryType;
    DWORD               dwBytesIn;
    DWORD               dwSpaceNeeded = 0;      // Space needed for counters
    DWORD               dwRet = ERROR_SUCCESS;  // Our return value
    PerfLibraryData     rgld;

    //
    // Save the number of bytes in before overwriting it
    //
    dwBytesIn = *pdwBytes;

    //
    // Set up the out parameters to indicate an error. We will change them
    //  later upon success
    //
    *pdwBytes = 0;
    *pdwObjectTypes = 0;

    if (!g_rgfInitOk[iLib])
    {
        //
        // Only acceptable error return is ERROR_MORE_DATA.  anything else
        // should return ERROR_SUCCESS, but set the out parameters to indicate
        // that no data is being returned
        //
        goto Exit;
    }

    dwQueryType = GetQueryType (lpwszValue);
    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // This routine does not service requests for data from
        // Non-NT computers.
        //
        goto Exit;
    }

    //
    // Enumerate through all the libraries we know of and get their
    //  performance statistices
    //
    if (!rgld.GetPerformanceStatistics (g_rgszLibraries[iLib]))
        goto Exit;

    //
    // Compute the space needed
    //
    dwSpaceNeeded = rgld.SpaceNeeded (dwQueryType, lpwszValue);

    // Round up to a multiple of 4.
    dwSpaceNeeded = QWORD_MULTIPLE (dwSpaceNeeded);


    //
    // See if the caller-provided buffer is large enough
    //
    if (dwBytesIn < dwSpaceNeeded)
    {
        //
        // Not enough space was provided by the caller
        //
        dwRet = ERROR_MORE_DATA;
        goto Exit;
    }

    //
    // Copy the performance data into the buffer
    //
    rgld.SavePerformanceData (ppdata, pdwBytes, pdwObjectTypes);

Exit:
    return dwRet;
}

DWORD Close (LibIndex iLib)
{
    if (g_rgfInitOk[iLib])
    {
        //
        // Release the reference to the global ExchMHeap.
        //
        ExchMHeapDestroy ();
    }

    return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// PerfMon API functions
//      the following functions are exported from this DLL as the entry points
//      for a performance monitoring application
///////////////////////////////////////////////////////////////////////////////
//
// XXXXOpen
//      Called by performance monitor to initialize performance gathering.
//      The LPWSTR parameter contains the names of monitored devices.  This
//      is for device driver performance DLL's and is not used by our DLL.
//
// XXXXXCollect
//      Called by the performance monitor to retrieve a block of performance
//      statistics.
//
// XXXXClose
//      Called by the performance monitor to terminate performance gathering
//

/* NTFSDrv */
EXTERN_C
DWORD APIENTRY NTFSDrvOpen (LPWSTR)
{
    return Open (LIB_NTFSDRV, L"NTFSDrv");
}

EXTERN_C
DWORD APIENTRY NTFSDrvCollect (LPWSTR lpwszValue,
                             void** ppdata,
                             DWORD* pdwBytes,
                             DWORD* pdwObjectTypes)
{
    return Collect (LIB_NTFSDRV, lpwszValue, ppdata, pdwBytes, pdwObjectTypes);
}

EXTERN_C
DWORD APIENTRY NTFSDrvClose (void)
{
    return Close (LIB_NTFSDRV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\staxmem\mpheap.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mpheap.c

Abstract:

    This DLL is a wrapper that sits on top of the Win32 Heap* api.  It
    provides multiple heaps and handles all the serialization itself.

    Many multithreaded applications that use the standard memory allocation
    routines (malloc/free, LocalAlloc/LocalFree, HeapAlloc/HeapFree) suffer
    a significant a significant performance penalty when running on a
    multi-processor machine.  This is due to the serialization used by the
    default heap package.  On a multiprocessor machine, more than one
    thread may simultaneously try to allocate memory.  One thread will
    block on the critical section guarding the heap.  The other thread must
    then signal the critical section when it is finished to unblock the
    waiting thread.  The additional codepath of blocking and signalling adds
    significant overhead to the frequent memory allocation path.

    By providing multiple heaps, this DLL allows simultaneous operations on
    each heap.  A thread on processor 0 can allocate memory from one heap
    at the same time that a thread on processor 1 is allocating from a
    different heap.  The additional overhead in this DLL is compensated by
    drastically reducing the number of times a thread must wait for heap
    access.

    The basic scheme is to attempt to lock each heap in turn with the new
    TryEnterCriticalSection API.  This will enter the critical section if
    it is unowned.  If the critical section is owned by a different thread,
    TryEnterCriticalSection returns failure instead of blocking until the
    other thread leaves the critical section.

    Another trick to increase performance is the use of a lookaside list to
    satisfy frequent allocations.  By using InterlockedExchange to remove
    lookaside list entries and InterlockedCompareExchange to add lookaside
    list entries, allocations and frees can be completed without needing a
    critical section lock.

    The final trick is the use of delayed frees.  If a chunk of memory is
    being freed, and the required lock is already held by a different
    thread, the free block is simply added to a delayed free list and the
    API completes immediately.  The next thread to acquire the heap lock
    will free everything on the list.

    Every application uses memory allocation routines in different ways.
    In order to allow better tuning of this package, MpHeapGetStatistics
    allows an application to monitor the amount of contention it is
    getting.  Increasing the number of heaps increases the potential
    concurrency, but also increases memory overhead.  Some experimentation
    is recommended to determine the optimal settings for a given number of
    processors.

    Some applications can benefit from additional techniques.  For example,
    per-thread lookaside lists for common allocation sizes can be very
    effective.  No locking is required for a per-thread structure, since no
    other thread will ever be accessing it.  Since each thread reuses the
    same memory, per-thread structures also improve locality of reference.

--*/
#include <windows.h>
#include "mpheap.h"

#define MPHEAP_VALID_OPTIONS  (MPHEAP_GROWABLE                 | \
                               MPHEAP_REALLOC_IN_PLACE_ONLY    | \
                               MPHEAP_TAIL_CHECKING_ENABLED    | \
                               MPHEAP_FREE_CHECKING_ENABLED    | \
                               MPHEAP_DISABLE_COALESCE_ON_FREE | \
                               MPHEAP_ZERO_MEMORY              | \
                               MPHEAP_COLLECT_STATS)

//
// Flags that are not passed on to the Win32 heap package
//
#define MPHEAP_PRIVATE_FLAGS (MPHEAP_COLLECT_STATS | MPHEAP_ZERO_MEMORY);

//
// Define the heap header that gets tacked on the front of
// every allocation. Eight bytes is a lot, but we can't make
// it any smaller or else the allocation will not be properly
// aligned for 64-bit quantities.
//
typedef struct _MP_HEADER {
    union {
        struct _MP_HEAP_ENTRY *HeapEntry;
        PSINGLE_LIST_ENTRY Next;
    };
    ULONG LookasideIndex;
} MP_HEADER, *PMP_HEADER;
//
// Definitions and structures for lookaside list
//
#define LIST_ENTRIES 128

typedef struct _MP_HEAP_LOOKASIDE {
    PMP_HEADER Entry;
} MP_HEAP_LOOKASIDE, *PMP_HEAP_LOOKASIDE;

#define NO_LOOKASIDE 0xffffffff
#define MaxLookasideSize (8*LIST_ENTRIES-7)
#define LookasideIndexFromSize(s) ((s < MaxLookasideSize) ? ((s) >> 3) : NO_LOOKASIDE)

//
// Define the structure that describes the entire MP heap.
//
// There is one MP_HEAP_ENTRY structure for each Win32 heap
// and a MP_HEAP structure that contains them all.
//
// Each MP_HEAP structure contains a lookaside list for quick
// lock-free alloc/free of various size blocks.
//

typedef struct _MP_HEAP_ENTRY {
    HANDLE Heap;
    PSINGLE_LIST_ENTRY DelayedFreeList;
    CRITICAL_SECTION Lock;
    DWORD Allocations;
    DWORD Frees;
    DWORD LookasideAllocations;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
    MP_HEAP_LOOKASIDE Lookaside[LIST_ENTRIES];
} MP_HEAP_ENTRY, *PMP_HEAP_ENTRY;


typedef struct _MP_HEAP {
    DWORD HeapCount;
    DWORD Flags;
    DWORD Hint;
    DWORD PadTo32Bytes;
    MP_HEAP_ENTRY Entry[1];     // variable size
} MP_HEAP, *PMP_HEAP;

VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    );

//
// HeapHint is a per-thread variable that offers a hint as to which heap to
// check first.  By giving each thread affinity towards a different heap,
// it is more likely that the first heap a thread picks for its allocation
// will be available.  It also improves a thread's locality of reference,
// which is very important for good MP performance
//
#define SetHeapHint(x)	TlsSetValue(tlsiHeapHint,(LPVOID)(x))
#define GetHeapHint()	(DWORD_PTR)TlsGetValue(tlsiHeapHint)

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwParallelism
    )
/*++

Routine Description:

    This routine creates an MP-enhanced heap. An MP heap consists of a
    collection of standard Win32 heaps whose serialization is controlled
    by the routines in this module to allow multiple simultaneous allocations.

Arguments:

    flOptions - Supplies the options for this heap.

        Currently valid flags are:

            MPHEAP_GROWABLE
            MPHEAP_REALLOC_IN_PLACE_ONLY
            MPHEAP_TAIL_CHECKING_ENABLED
            MPHEAP_FREE_CHECKING_ENABLED
            MPHEAP_DISABLE_COALESCE_ON_FREE
            MPHEAP_ZERO_MEMORY
            MPHEAP_COLLECT_STATS

    dwInitialSize - Supplies the initial size of the combined heaps.

    dwParallelism - Supplies the number of Win32 heaps that will make up the
        MP heap. A value of zero defaults to three + # of processors.

Return Value:

    HANDLE - Returns a handle to the MP heap that can be passed to the
             other routines in this package.

    NULL - Failure, GetLastError() specifies the exact error code.

--*/
{
    DWORD Error;
    DWORD i;
    HANDLE Heap;
    PMP_HEAP MpHeap;
    DWORD HeapSize;
    DWORD PrivateFlags;

    if (flOptions & ~MPHEAP_VALID_OPTIONS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    flOptions |= HEAP_NO_SERIALIZE;

    PrivateFlags = flOptions & MPHEAP_PRIVATE_FLAGS;

    flOptions &= ~MPHEAP_PRIVATE_FLAGS;

    if (dwParallelism == 0) {
        SYSTEM_INFO SystemInfo;

        GetSystemInfo(&SystemInfo);
        dwParallelism = 3 + SystemInfo.dwNumberOfProcessors;
    }

    HeapSize = dwInitialSize / dwParallelism;

    //
    // The first heap is special, since the MP_HEAP structure itself
    // is allocated from there.
    //
    Heap = HeapCreate(flOptions,HeapSize,0);
    if (Heap == NULL) {
        //
        // HeapCreate has already set last error appropriately.
        //
        return(NULL);
    }

    MpHeap = HeapAlloc(Heap,0,sizeof(MP_HEAP) +
                              (dwParallelism-1)*sizeof(MP_HEAP_ENTRY));
    if (MpHeap==NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        HeapDestroy(Heap);
        return(NULL);
    }

    //
    // Initialize the MP heap structure
    //
    MpHeap->HeapCount = 1;
    MpHeap->Flags = PrivateFlags;
    MpHeap->Hint = 0;

    //
    // Initialize the first heap
    //
    MpHeap->Entry[0].Heap = Heap;
    InitializeCriticalSection(&MpHeap->Entry[0].Lock);
    MpHeap->Entry[0].DelayedFreeList = NULL;
    ZeroMemory(MpHeap->Entry[0].Lookaside, sizeof(MpHeap->Entry[0].Lookaside));

    //
    // Initialize the remaining heaps. Note that the heap has been
    // sufficiently initialized to use MpHeapDestroy for cleanup
    // if something bad happens.
    //
    for (i=1; i<dwParallelism; i++) {
        MpHeap->Entry[i].Heap = HeapCreate(flOptions, HeapSize, 0);
        if (MpHeap->Entry[i].Heap == NULL) {
            Error = GetLastError();
            MpHeapDestroy((HANDLE)MpHeap);
            SetLastError(Error);
            return(NULL);
        }
        InitializeCriticalSection(&MpHeap->Entry[i].Lock);
        MpHeap->Entry[i].DelayedFreeList = NULL;
        ZeroMemory(MpHeap->Entry[i].Lookaside, sizeof(MpHeap->Entry[i].Lookaside));
        ++MpHeap->HeapCount;
    }

    return((HANDLE)MpHeap);
}

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    )
{
    DWORD i;
    DWORD HeapCount;
    PMP_HEAP MpHeap;
    BOOL Success = TRUE;

    MpHeap = (PMP_HEAP)hMpHeap;
    HeapCount = MpHeap->HeapCount;

	if (HeapCount)
	{

		//
		// Lock down all the heaps so we don't end up hosing people
		// who may be allocating things while we are deleting the heaps.
		// By setting MpHeap->HeapCount = 0 we also attempt to prevent
		// people from getting hosed as soon as we delete the critical
		// sections and heaps.
		//
		MpHeap->HeapCount = 0;
		for (i=0; i<HeapCount; i++) {
			EnterCriticalSection(&MpHeap->Entry[i].Lock);
		}

		//
		// Delete the heaps and their associated critical sections.
		// Note that the order is important here. Since the MpHeap
		// structure was allocated from MpHeap->Heap[0] we must
		// delete that last.
		//
		for (i=HeapCount-1; i>0; i--) {
			DeleteCriticalSection(&MpHeap->Entry[i].Lock);
			if (!HeapDestroy(MpHeap->Entry[i].Heap)) {
				Success = FALSE;
			}
		}

		DeleteCriticalSection(&MpHeap->Entry[0].Lock);
		Success = HeapDestroy(MpHeap->Entry[0].Heap);
	}
    return(Success);
}

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    BOOL Success;
    PMP_HEADER Header;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    if (lpMem == NULL) {

        //
        // Lock and validate each heap in turn.
        //
        for (i=0; i < MpHeap->HeapCount; i++) {
            Entry = &MpHeap->Entry[i];
            __try {
                EnterCriticalSection(&Entry->Lock);
                Success = HeapValidate(Entry->Heap, 0, NULL);
                LeaveCriticalSection(&Entry->Lock);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return(FALSE);
            }

            if (!Success) {
                return(FALSE);
            }
        }
        return(TRUE);
    } else {

        //
        // Lock and validate the given heap entry
        //
        Header = ((PMP_HEADER)lpMem) - 1;
        __try {
            EnterCriticalSection(&Header->HeapEntry->Lock);
            Success = HeapValidate(Header->HeapEntry->Heap, 0, Header);
            LeaveCriticalSection(&Header->HeapEntry->Lock);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return(FALSE);
        }
        return(Success);
    }
}

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    SIZE_T LargestFreeSize=0;
    SIZE_T FreeSize;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    //
    // Lock and compact each heap in turn.
    //
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];
        EnterCriticalSection(&Entry->Lock);
        FreeSize = HeapCompact(Entry->Heap, 0);
        LeaveCriticalSection(&Entry->Lock);

        if (FreeSize > LargestFreeSize) {
            LargestFreeSize = FreeSize;
        }
    }

    return(LargestFreeSize);

}


LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    DWORD dwBytes
    )
{
    PMP_HEADER Header;
    PMP_HEAP MpHeap;
    DWORD_PTR i;
    PMP_HEAP_ENTRY Entry;
    DWORD Index;
    DWORD Size;

    MpHeap = (PMP_HEAP)hMpHeap;

    flOptions |= MpHeap->Flags;

    Size = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);

    //Raid X5:195963 We never want to allocate/reallocate
    //less memory than what we have been requested.
    if (Size < dwBytes)
    	return(NULL);
    Index=LookasideIndexFromSize(Size);

    //
    // Iterate through the heap locks looking for one
    // that is not owned.
    //
    i=GetHeapHint();
    if (i>=MpHeap->HeapCount) {
        i=0;
        SetHeapHint(0);
    }
    Entry = &MpHeap->Entry[i];
    do {
        //
        // Check the lookaside list for a suitable allocation.
        //
        if ((Index != NO_LOOKASIDE) &&
            (Entry->Lookaside[Index].Entry != NULL)) {
            if ((Header = InterlockedExchangePointer(&Entry->Lookaside[Index].Entry,
                                                          NULL)) != NULL) {
                //
                // We have a lookaside hit, return it immediately.
                //
                ++Entry->LookasideAllocations;
                if (flOptions & MPHEAP_ZERO_MEMORY) {
                    ZeroMemory(Header + 1, dwBytes);
                }
                SetHeapHint(i);
                return(Header + 1);
            }
        }

        //
        // Attempt to lock this heap without blocking.
        //
        if (TryEnterCriticalSection(&Entry->Lock)) {
            //
            // success, go allocate immediately
            //
            goto LockAcquired;
        }

        //
        // This heap is owned by another thread, try
        // the next one.
        //
        i++;
        Entry++;
        if (i==MpHeap->HeapCount) {
            i=0;
            Entry=&MpHeap->Entry[0];
        }
    } while ( i != GetHeapHint());

    //
    // All of the critical sections were owned by someone else,
    // so we have no choice but to wait for a critical section.
    //
    EnterCriticalSection(&Entry->Lock);

LockAcquired:
    ++Entry->Allocations;
    if (Entry->DelayedFreeList != NULL) {
        ProcessDelayedFreeList(Entry);
    }
    Header = HeapAlloc(Entry->Heap, 0, Size);
    LeaveCriticalSection(&Entry->Lock);
    if (Header != NULL) {
        Header->HeapEntry = Entry;
        Header->LookasideIndex = Index;
        if (flOptions & MPHEAP_ZERO_MEMORY) {
            ZeroMemory(Header + 1, dwBytes);
        }
        SetHeapHint(i);
        return(Header + 1);
    } else {
        return(NULL);
    }
}

LPVOID
WINAPI
MpHeapReAlloc(
    HANDLE hMpHeap,
    LPVOID lpMem,
    DWORD dwBytes
    )
{
    PMP_HEADER Header;
    PCRITICAL_SECTION Lock;
    DWORD dwReallocBytes = 0;

    Header = ((PMP_HEADER)lpMem) - 1;
    Lock = &Header->HeapEntry->Lock;
    dwReallocBytes = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);
    //Raid X5:195963 We never want to allocate/reallocate
    //less memory than what we have been requested.
    if (dwReallocBytes < dwBytes)
    	return(NULL);
    dwBytes = dwReallocBytes;

    EnterCriticalSection(Lock);
    Header = HeapReAlloc(Header->HeapEntry->Heap, 0, Header, dwBytes);
    LeaveCriticalSection(Lock);

    if (Header != NULL) {
        Header->LookasideIndex = LookasideIndexFromSize(dwBytes);
        return(Header + 1);
    } else {
    	MpHeapFree(hMpHeap, lpMem);
        return(NULL);
    }
}

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEADER Header;
    PCRITICAL_SECTION Lock;
    BOOL Success;
    PMP_HEAP_ENTRY HeapEntry;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEAP MpHeap;

    Header = ((PMP_HEADER)lpMem) - 1;
    HeapEntry = Header->HeapEntry;
    MpHeap = (PMP_HEAP)hMpHeap;

    SetHeapHint(HeapEntry - &MpHeap->Entry[0]);

    if (Header->LookasideIndex != NO_LOOKASIDE) {
        //
        // Try and put this back on the lookaside list
        //
        if (InterlockedCompareExchangePointer(&HeapEntry->Lookaside[Header->LookasideIndex].Entry,
                                       Header,
                                       NULL) == NULL) {
            //
            // Successfully freed to lookaside list.
            //
            ++HeapEntry->LookasideFrees;
            return(TRUE);
        }
    }
    Lock = &HeapEntry->Lock;

    if (TryEnterCriticalSection(Lock)) {
        ++HeapEntry->Frees;
        Success = HeapFree(HeapEntry->Heap, 0, Header);
        LeaveCriticalSection(Lock);
        return(Success);
    }
    //
    // The necessary heap critical section could not be immediately
    // acquired. Post this free onto the Delayed free list and let
    // whoever has the lock process it.
    //
    do {
        Next = HeapEntry->DelayedFreeList;
        Header->Next = Next;
    } while ( InterlockedCompareExchangePointer(&HeapEntry->DelayedFreeList,
                                         &Header->Next,
                                         Next) != Next);
    return(TRUE);
}


SIZE_T
WINAPI
MpHeapSize(
		   HANDLE hMpHeap,
		   DWORD ulFlags,
		   LPVOID lpMem
		  )
{
	PMP_HEADER Header;
	PCRITICAL_SECTION Lock;
	SIZE_T dwSize;

	Header = ((PMP_HEADER)lpMem) - 1;
	Lock = &Header->HeapEntry->Lock;

	EnterCriticalSection(Lock);
	dwSize = HeapSize(Header->HeapEntry->Heap, 0, Header);
	dwSize -= sizeof(MP_HEADER);			// dbb X5 bug 51663
	LeaveCriticalSection(Lock);

	return dwSize;
}


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    )
{
    PSINGLE_LIST_ENTRY FreeList;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEADER Header;

    //
    // Capture the entire delayed free list with a single interlocked exchange.
    // Once we have removed the entire list, free each entry in turn.
    //
    FreeList = (PSINGLE_LIST_ENTRY)InterlockedExchangePointer(&HeapEntry->DelayedFreeList, NULL);
    while (FreeList != NULL) {
        Next = FreeList->Next;
        Header = CONTAINING_RECORD(FreeList, MP_HEADER, Next);
        ++HeapEntry->DelayedFrees;
        HeapFree(HeapEntry->Heap, 0, Header);
        FreeList = Next;
    }
}

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Stats[]
    )
{
    PMP_HEAP MpHeap;
    PMP_HEAP_ENTRY Entry;
    DWORD i;
    DWORD RequiredSize;

    MpHeap = (PMP_HEAP)hMpHeap;
    RequiredSize = MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS);
    if (*lpdwSize < RequiredSize) {
        *lpdwSize = RequiredSize;
        return(ERROR_MORE_DATA);
    }
    ZeroMemory(Stats, MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS));
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];

        Stats[i].Contention = Entry->Lock.DebugInfo->ContentionCount;
        Stats[i].TotalAllocates = (Entry->Allocations + Entry->LookasideAllocations);
        Stats[i].TotalFrees = (Entry->Frees + Entry->LookasideFrees + Entry->DelayedFrees);
        Stats[i].LookasideAllocates = Entry->LookasideAllocations;
        Stats[i].LookasideFrees = Entry->LookasideFrees;
        Stats[i].DelayedFrees = Entry->DelayedFrees;
    }
    *lpdwSize = RequiredSize;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\staxmem\mpheap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mpheap.h

Abstract:

    Public header file for MP heap package

Author:

    John Vert (jvert) 10-Jul-1995

Revision History:

--*/

//
// Valid heap creation options
//
#define MPHEAP_GROWABLE HEAP_GROWABLE
#define MPHEAP_REALLOC_IN_PLACE_ONLY HEAP_REALLOC_IN_PLACE_ONLY
#define MPHEAP_TAIL_CHECKING_ENABLED HEAP_TAIL_CHECKING_ENABLED
#define MPHEAP_FREE_CHECKING_ENABLED HEAP_FREE_CHECKING_ENABLED
#define MPHEAP_DISABLE_COALESCE_ON_FREE HEAP_DISABLE_COALESCE_ON_FREE
#define MPHEAP_ZERO_MEMORY HEAP_ZERO_MEMORY
#define MPHEAP_COLLECT_STATS 0x10000000

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwParallelism
    );

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    );

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    );

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    );

LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    DWORD dwBytes
    );

LPVOID
WINAPI
MpHeapReAlloc(
    HANDLE hMpHeap,
    LPVOID lpMem,
    DWORD dwBytes
    );

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    );

SIZE_T
WINAPI
MpHeapSize(
	HANDLE hMpHeap,
	DWORD ulFlags,
	LPVOID lpMem
	);
//
// Statistics structure
//
typedef struct _MPHEAP_STATISTICS {
    DWORD Contention;
    DWORD TotalAllocates;
    DWORD TotalFrees;
    DWORD LookasideAllocates;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
} MPHEAP_STATISTICS, *LPMPHEAP_STATISTICS;

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Statistics[]
    );

//
// TLS index for exchmem heap selection
//
extern DWORD tlsiHeapHint;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\staxmem\_exchmem.h ===
/*
 -	_ E X C H M E M . H
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#ifdef __cplusplus
extern "C"
{
#endif

//	Size of Multiple Heap block header

#ifdef _X86_
#define	cbMHeapHeader		sizeof(HANDLE)
//#define	cbMHeapHeader		(sizeof(HANDLE) + sizeof(LPVOID))
#else
#define	cbMHeapHeader		(2*sizeof(HANDLE))
#endif

#define HandleFromMHeapPv(pv)	(*((HANDLE *)((BYTE *)pv - cbMHeapHeader)))
#define PvFromMHeapPv(pv)		((LPVOID)((BYTE *)pv - cbMHeapHeader))
//#define PvRetFromPv(pv)		    ((LPVOID)((BYTE *)pv + (cbMHeapHeader/2)))
//#define PvRetFromMHeapPv(pv)    ((LPVOID)((BYTE *)pv - (cbMHeapHeader/2)))
#define MHeapPvFromPv(pv)		((LPVOID)((BYTE *)pv + cbMHeapHeader))

#define cHeapsDef 4

typedef struct _heaptbl
{
	ULONG	cRef;
	ULONG	cHeaps;
	HANDLE	rghheap[1];
	
} HEAPTBL, * LPHEAPTBL;


#ifdef DEBUG

//	This stuff is used for overwrite detection 
//	and block validation during free calls.

#define cbOWSection 4

#define PvFromPvHead(pv)			((LPVOID)((BYTE *)pv + cbOWSection))
#define PvHeadFromPv(pv)			((LPVOID)((BYTE *)pv - cbOWSection))
#define PvTailFromPv(pv, cb)		((LPVOID)((BYTE *)pv + cb))
#define PvTailFromPvHead(pv, cb)	((LPVOID)((BYTE *)pv + cb + cbOWSection))

#define chOWFill			((BYTE)0xAB)
#define chDefaultAllocFill	((BYTE)0xFE)
#define chDefaultFreeFill	((BYTE)0xCD)

//	Default stack frame size for tracing call stacks.

#define NSTK				128

//	Forward declarations of heap and block types

typedef struct HEAP	HEAP,	* PHEAP,	** PPHEAP;
typedef struct HBLK	HBLK,	* PHBLK,	** PPHBLK;

//	Exports from GLHMON32.DLL

typedef BOOL (APIENTRY HEAPMONPROC)(PHEAP plh, ULONG ulFlags);
typedef HEAPMONPROC FAR *LPHEAPMONPROC;
typedef BOOL (APIENTRY GETSYMNAMEPROC)(DWORD, LPSTR, LPSTR, DWORD FAR *);
typedef GETSYMNAMEPROC FAR *LPGETSYMNAMEPROC;

//	C-RunTime function pointer defs

typedef void * (__cdecl FMALLOC)(size_t);
typedef FMALLOC FAR *LPFMALLOC;
typedef void * (__cdecl FREALLOC)(void *, size_t);
typedef FREALLOC FAR *LPFREALLOC;
typedef void   (__cdecl FFREE)(void *);
typedef FFREE FAR *LPFFREE;
typedef void * (__cdecl FCALLOC)(size_t, size_t);
typedef FCALLOC FAR *LPFCALLOC;
typedef char * (__cdecl FSTRDUP)(const char *);
typedef FSTRDUP FAR *LPFSTRDUP;
typedef size_t   (__cdecl FMEMSIZE)(void *);
typedef FMEMSIZE FAR *LPFMEMSIZE;


#define HEAPMON_LOAD		((ULONG) 0x00000001)
#define HEAPMON_UNLOAD		((ULONG) 0x00000002)
#define HEAPMON_PING		((ULONG) 0x00000003)


#define HEAP_USE_VIRTUAL		((ULONG) 0x00000001)
#define HEAP_DUMP_LEAKS			((ULONG) 0x00000002)
#define HEAP_ASSERT_LEAKS		((ULONG) 0x00000004)
#define HEAP_FILL_MEM			((ULONG) 0x00000008)
#define HEAP_HEAP_MONITOR		((ULONG) 0x00000010)
#define HEAP_USE_VIRTUAL_4		((ULONG) 0x00000020)
#define HEAP_FAILURES_ENABLED	((ULONG) 0x00000040)
#define HEAP_LOCAL				((ULONG) 0x10000000)
#define HEAP_GLOBAL				((ULONG) 0x20000000)


typedef VOID (__cdecl *LPHEAPSETNAME)(LPVOID, char *, ...);

struct HBLK
{
	PHEAP		pheap;			  	// Heap this block was allocated on
	PHBLK		phblkPrev;		  	// Pointer to the prev allocation this heap
	PHBLK		phblkNext;		  	// Pointer to the next allocation this heap
	PHBLK		phblkFreeNext;		// Pointer to next free block on this heap
	char		szName[128];	  	// We can name blocks allocated on a heap
	ULONG		ulAllocNum;		  	// Allocation number (Id) for this block
	ULONG		ulSize;			  	// Number of bytes the client requested
	DWORD_PTR	rgdwCallers[NSTK];	// Call stack during this allocation
	DWORD_PTR	rgdwFree[NSTK];		// Call stack that freed this block
	LPVOID		pv;				  	// Pointer to the client data
};

struct HEAP
{
	LPHEAPSETNAME	pfnSetName;		// Pointer to HEAP_SetNameFn function
	HANDLE			hDataHeap;		// The underlying heap that we alloc data from
	HANDLE			hBlksHeap;		// The underlying heap that we alloc hblks from
	PHEAP			pNext;			// Pointer to the next heap in a list of heaps
	char			szHeapName[32];	// We can name our heaps for display purposes
	ULONG			ulAllocNum;		// Allocation number this heap since Open
	PHBLK			phblkHead;		// Link-list of allocations on this heap
	PHBLK			phblkFree;		// Link-list of freed allocations from this heap.
	ULONG			cEntriesFree;	// Number of freed allocations from the heap.
	ULONG			ulFlags;		// Combination of the HEAP_ flags above
	BYTE			chFill;			// Character to fill memory with

	HINSTANCE		hInstHeapMon;	// DLL instance of the HeapMonitor DLL
	LPHEAPMONPROC 	pfnHeapMon;		// Entry point into HeapMonitor DLL

	CRITICAL_SECTION cs;			// Critcal section to protect access to heap

	ULONG			ulFailBufSize;	// If HEAP_FAILURES_ENABLED, this is the minimum 
									// size in which failures occur.  1 means alloc's 
									// of any size fail. 0 means never fail.
	ULONG			ulFailInterval;	// If HEAP_FAILURES_ENABLED, this is the period on 
									// which the failures occur.  1 means every alloc 
									// will fail. 0 means never fail.
	ULONG			ulFailStart;	// If HEAP_FAILURES_ENABLED, this is the allocation 
									// number that the first failure will occur on.  
									// 1 means the first alloc.  0 means never 
									// start failing.	
	ULONG			iAllocationFault;

	LPGETSYMNAMEPROC pfnGetSymName;	// Resolve address to Symbol
};


PHBLK	PvToPhblk(HANDLE hlh, LPVOID pv);
#define PhblkToPv(pblk)			((LPVOID)((PHBLK)(pblk)->pv))
#define CbPhblkClient(pblk)		(((PHBLK)(pblk))->ulSize)
#define CbPvClient(hlh, pv)		(CbPhblkClient(PvToPhblk(hlh, pv)))
#define CbPvAlloc(hlh, pv)		(CbPhblkAlloc(PvToPhblk(hlh, pv)))

#define	IFHEAPNAME(x)	x

VOID __cdecl HeapSetHeapNameFn(HANDLE hlh, char *pszFormat, ...);
VOID __cdecl HeapSetNameFn(HANDLE hlh, LPVOID pv, char *pszFormat, ...);

char * HeapGetName(HANDLE hlh, LPVOID pv);


#define HeapSetHeapName(hlh,psz)					IFHEAPNAME(HeapSetHeapNameFn(hlh,psz))
#define HeapSetHeapName1(hlh,psz,a1)				IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1))
#define HeapSetHeapName2(hlh,psz,a1,a2)				IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2))
#define HeapSetHeapName3(hlh,psz,a1,a2,a3)			IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3))
#define HeapSetHeapName4(hlh,psz,a1,a2,a3,a4)		IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define HeapSetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define HeapSetName(hlh,pv,psz)						IFHEAPNAME(HeapSetNameFn(hlh,pv,psz))
#define HeapSetName1(hlh,pv,psz,a1)					IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1))
#define HeapSetName2(hlh,pv,psz,a1,a2)				IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2))
#define HeapSetName3(hlh,pv,psz,a1,a2,a3)			IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3))
#define HeapSetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define HeapSetName5(hlh,pv,psz,a1,a2,a3,a4,a5)		IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


//	Misc. debug support functions

BOOL InitDebugExchMem(HMODULE hModule);
VOID UnInitDebugExchMem(VOID);
BOOL FForceFailure(PHEAP pheap, ULONG cb);
BOOL FRegisterHeap(PHEAP pheap);
VOID UnRegisterHeap(PHEAP pheap);
VOID HeapDumpLeaks(PHEAP pheap, BOOL fNoFree);
BOOL HeapValidatePhblk(PHEAP pheap, PHBLK pheapblk, char ** pszReason);
BOOL HeapDidAlloc(PHEAP pheap, LPVOID pv);
BOOL HeapValidatePv(PHEAP pheap, LPVOID pv, char * pszFunc);
VOID PhblkEnqueue(PHBLK pheapblk);
VOID PhblkDequeue(PHBLK pheapblk);
BYTE HexByteToBin(LPSTR sz);
BOOL IsProcessRunningAsService(VOID);
VOID GetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind);
VOID RemoveExtension(LPSTR psz);
VOID GetLogFilePath(LPSTR szPath, LPSTR szExt, LPSTR szFilePath);

void __cdecl DebugTraceFn(char *pszFormat, ...);

#define	Trace	DebugTraceFn
#define DebugTrace(psz)							DebugTraceFn(psz)
#define DebugTrace1(psz, a1)					DebugTraceFn(psz, a1)
#define DebugTrace2(psz, a1, a2)				DebugTraceFn(psz, a1, a2)
#define DebugTrace3(psz, a1, a2, a3)			DebugTraceFn(psz, a1, a2, a3)
#define DebugTrace4(psz, a1, a2, a3, a4)		DebugTraceFn(psz, a1, a2, a3, a4)
#define DebugTrace5(psz, a1, a2, a3, a4, a5)	DebugTraceFn(psz, a1, a2, a3, a4, a5)


#define Assert(fCondition)			\
		((fCondition) ? (0) : AssertFn(__FILE__, __LINE__, #fCondition))
#define AssertSz(fCondition, sz)	\
		((fCondition) ? (0) : AssertFn(__FILE__, __LINE__, sz))
void AssertFn(char * szFile, int nLine, char * szMsg);


VOID GetStackSymbols(
		HANDLE hProcess, 
		CHAR * rgchBuff, 
		DWORD_PTR * rgdwStack, 
		DWORD cFrames);

VOID LogCurrentAPI(
		WORD wApi,
		DWORD_PTR *rgdwCallStack, 
		DWORD cFrames,
		DWORD_PTR *rgdwArgs, 
		DWORD cArgs);


//	Virtual Memory Support (NYI)

LPVOID
WINAPI
VMAllocEx(
	ULONG	cb, 
	ULONG	cbCluster);

VOID
WINAPI
VMFreeEx(
	LPVOID	pv, 
	ULONG	cbCluster);

LPVOID
WINAPI
VMReallocEx(
	LPVOID	pv, 
	ULONG	cb,
	ULONG	cbCluster);

ULONG 
WINAPI
VMGetSizeEx(
	LPVOID	pv, 
	ULONG	cbCluster);

BOOL 
VMValidatePvEx(
	LPVOID	pv, 
	ULONG	cbCluster);


//	Debug APIs

HANDLE
NTAPI
DebugHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);


BOOL
NTAPI
DebugHeapDestroy(
	HANDLE	hHeap);


LPVOID
NTAPI
DebugHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);


LPVOID
NTAPI
DebugHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);


BOOL
NTAPI
DebugHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);


BOOL
NTAPI
DebugHeapLock(
	HANDLE hHeap);


BOOL
NTAPI
DebugHeapUnlock(
	HANDLE hHeap);


BOOL
NTAPI
DebugHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry);


BOOL
NTAPI
DebugHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
NTAPI
DebugHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
NTAPI
DebugHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags);

//	Macros to wrapper Heap API calls (debug)

#define ExHeapCreate(a, b, c)		DebugHeapCreate(a, b, c)
#define ExHeapDestroy(a)			DebugHeapDestroy(a)
#define ExHeapAlloc(a, b, c)		DebugHeapAlloc(a, b, c)
#define ExHeapReAlloc(a, b, c, d)	DebugHeapReAlloc(a, b, c, d)
#define ExHeapFree(a, b, c)			DebugHeapFree(a, b, c)
#define ExHeapLock(a)				DebugHeapLock(a)
#define ExHeapUnlock(a)				DebugHeapUnlock(a)
#define ExHeapWalk(a, b)			DebugHeapWalk(a, b)
#define ExHeapValidate(a, b, c)		DebugHeapValidate(a, b, c)
#define ExHeapSize(a, b, c)			DebugHeapSize(a, b, c)
#define ExHeapCompact(a, b)			DebugHeapCompact(a, b)

//	API Id for TrackMem logging

#define API_HEAP_CREATE				((WORD) 0)
#define API_HEAP_DESTROY			((WORD) 1)
#define API_HEAP_ALLOC				((WORD) 2)
#define API_HEAP_REALLOC			((WORD) 3)
#define API_HEAP_FREE				((WORD) 4)

#else

//	Macros to wrapper Heap API calls (retail)

#define ExHeapCreate(a, b, c)		HeapCreate(a, b, c)
#define ExHeapDestroy(a)			HeapDestroy(a)
#define ExHeapAlloc(a, b, c)		HeapAlloc(a, b, c)
#define ExHeapReAlloc(a, b, c, d)	HeapReAlloc(a, b, c, d)
#define ExHeapFree(a, b, c)			HeapFree(a, b, c)
#define ExHeapLock(a)				HeapLock(a)
#define ExHeapUnlock(a)				HeapUnlock(a)
#define ExHeapWalk(a, b)			HeapWalk(a, b)
#define ExHeapValidate(a, b, c)		HeapValidate(a, b, c)
#define ExHeapSize(a, b, c)			HeapSize(a, b, c)
#define ExHeapCompact(a, b)			HeapCompact(a, b)

#define Assert(fCondition)
#define AssertSz(fCondition, sz)

#define DebugTrace(psz)
#define DebugTrace1(psz, a1)
#define DebugTrace2(psz, a1, a2)
#define DebugTrace3(psz, a1, a2, a3)
#define DebugTrace4(psz, a1, a2, a3, a4)
#define DebugTrace5(psz, a1, a2, a3, a4, a5)


#endif	// DEBUG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\randint.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randint.h

Abstract :

    Random failure internal include file

Author :

    Sam Neely

Revision History :

--*/

#ifdef __cplusplus
extern "C" {
#endif
static const long kDontFail = 0;
extern long nFailRate;
extern DWORD dwRandFailTlsIndex;
extern LONG g_cCallStack;
extern CHAR** g_ppchCallStack;
extern LONG g_iCallStack;
extern const DWORD g_dwMaxCallStack;
extern HANDLE g_hRandFailFile;
extern HANDLE g_hRandFailMutex;
extern CHAR g_szRandFailFile[];
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\freeq.cpp ===
//#---------------------------------------------------------------
//        
//  File:       FreeQ.cpp
//        
//  Synopsis:   interface between CPool object and asynctrc.c
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    gordm
//        
//----------------------------------------------------------------

#define	_DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include <cpool.h>
#include "randfail.h"
#include "traceint.h"

//
// global pointer to CPool to avoid pulling in the C runtime
// to call the con/destrustors
//
CPool*	g_pFreePool = NULL;


//+---------------------------------------------------------------
//
//  Function:   InitTraceBuffers
//
//  Synopsis:   external "C" function to init the CPool
//
//  Arguments:  DWORD: Maximum number of pending traces
//				DWORD: Increment size for the CPool
//
//  Returns:    BOOL: successful or not
//
//----------------------------------------------------------------
BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement )
{
	g_pFreePool = new CPool( TRACE_SIGNATURE );

	return	g_pFreePool != NULL &&
			g_pFreePool->ReserveMemory(	dwThresholdCount,
										sizeof(TRACEBUF),
										dwIncrement );
}


//+---------------------------------------------------------------
//
//  Function:   TermTraceBuffers
//
//  Synopsis:   cleanup 
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI TermTraceBuffers( void )
{
	CPool*	pPool = (CPool*)InterlockedExchangePointer((void**)&g_pFreePool, NULL );
	if ( pPool != NULL )
	{
		pPool->ReleaseMemory();
		delete	pPool;
	}
}


//+---------------------------------------------------------------
//
//  Function:   GetTraceBuffer
//
//  Synopsis:   external "C" function to get a CPool buffer 
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: allocated buffer
//
//----------------------------------------------------------------
LPTRACEBUF WINAPI GetTraceBuffer( void )
{
	LPTRACEBUF	lpBuf;

	//
	// don't let the number of traces exceed the size 
	// of the file
	//
	if ( PendQ.dwCount >= PendQ.dwThresholdCount )
	{
		INT_TRACE( "Alloc flush: %u\n", PendQ.dwCount );
		FlushAsyncTrace();
	}

	//
	// Turn off randfail for this allocation
	//
    RandFailDisable();
	lpBuf = (LPTRACEBUF)g_pFreePool->Alloc();
    RandFailEnable();
    
   	if ( lpBuf != NULL )
	{
		lpBuf->pNext = NULL;
		lpBuf->dwSignature = TRACE_SIGNATURE;
	}
	return	lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   FreeTraceBuffer
//
//  Synopsis:   external "C" function to free a CPool buffer 
//
//  Arguments:  LPTRACEBUF: the buffer to free
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf )
{
	ASSERT( lpBuf != NULL );
	ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

	g_pFreePool->Free( (void*)lpBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\asynctrc.c ===
/*----------------------------------------------------------------------
    ASYNCTRC.C
        Implementation of the async tracing library

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define _DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

//
// #define  TRACE_ENABLED
//
#include "traceint.h"
#include "randint.h"

//
// Per Process global variables
//
PENDQ   PendQ;
BOOL    fInitialized;
HANDLE  hShutdownEvent;
DWORD   dwInitializations = 0;

CHAR    mszModules[MODULES_BUFFER_SIZE] = {0};

// critical section to protect against the race condition
// where one service is starting and a second service is
// terminating.
CRITICAL_SECTION g_csInitialize;

//
// critical section to protect reentracy on Write routine
// Also used by the signal thread to ensure that no threads
// are using hFile as it dynamically opens and closes trace file.
// During Async mode the background thread will be able to grab
// this critSec each time without waiting unless we're in the
// process of shutting down.
//
CRITICAL_SECTION critSecWrite;


//
// critical section to protect reentracy on Flush routine
//
CRITICAL_SECTION critSecFlush;


//
// exported trace flag used by trace macros to determine if the trace
// statement should be executed
//
DbgTraceDLL DWORD   __dwEnabledTraces;

DWORD   dwMaxFileSize;
DWORD   dwNumTraces;
DWORD   dwTraceOutputType;
DWORD   dwAsyncTraceFlag;
int     nAsyncThreadPriority;
DWORD   dwIncrementSize;

DWORD   dwTlsIndex = 0xFFFFFFFF;

//
// pointer to the previous top level exception handler
//
LPTOP_LEVEL_EXCEPTION_FILTER    lpfnPreviousFilter = NULL;


//
// Internal Function to debugger tracing if DEBUG is defined.
// see traceint.h for the INT_TRACE macro which can be
// inserted at the appropriate point and has the same
// parameters as printf.
//

#ifdef TRACE_ENABLED

void CDECL InternalTrace( const char *s, ... )
{
    char    sz[256];
    va_list marker;

    va_start( marker, s );

    wvsprintf( sz, s, marker );
    OutputDebugString( sz );

    va_end( marker );
}

#endif


//+---------------------------------------------------------------
//
//  Function:   TopLevelExceptionFilter
//
//  Synopsis:   exception handler to flush the PendQ before hitting
//              the debugger
//
//  Arguments:  see Win32 help file
//
//  Returns:    always returns EXCEPTION_CONTINUE_SEARCH
//
//----------------------------------------------------------------
LONG WINAPI TopLevelExceptionFilter( EXCEPTION_POINTERS *lpExceptionInfo )
{
    DWORD   dwLastError = GetLastError();

    //
    // flush the background queue; ignore the ret code
    //
    FlushAsyncTrace();

    //
    // restore the overwritten last error code
    //
    SetLastError( dwLastError );

    //
    // chain the ret code if there is a previous exception handler
    // else continue the search
    //
    return  lpfnPreviousFilter != NULL ?
            (*lpfnPreviousFilter)( lpExceptionInfo ) :
            EXCEPTION_CONTINUE_SEARCH ;
}




//+---------------------------------------------------------------
//
//  Function:   SetTraceBufferInfo
//
//  Synopsis:   used to set the non-sprintf trace variables
//
//  Arguments:  LPTRACEBUF: target buffer
//              int:        line number of the exception
//              LPSTR:      source file of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void SetTraceBufferInfo(
        LPTRACEBUF  lpBuf,
        int         iLine,
        LPSTR       pszFile,
        LPSTR       pszFunction,
        DWORD       dwTraceMask,
        DWORD       dwError )
{
    LPSTR   psz;
    WORD    wVariableOffset = 0;
    PFIXEDTR    pFixed = &lpBuf->Fixed;

    lpBuf->dwLastError = dwError;

    pFixed->wSignature = 0xCAFE;
    pFixed->wLength = sizeof(FIXEDTRACE);
    pFixed->wLine = LOWORD( iLine );
    pFixed->dwTraceMask = dwTraceMask;
    pFixed->dwThreadId = GetCurrentThreadId();
    pFixed->dwProcessId = PendQ.dwProcessId;

    GetLocalTime( &pFixed->TraceTime );

    if ( pszFile )
    {
        if ( (psz = strrchr( pszFile, '\\' )) != NULL )
        {
            psz++;  // fully qualified path name - strip path
        }
        else
        {
            psz = pszFile;  // simple file name
        }

        lstrcpyn( lpBuf->Buffer, psz, MAX_FILENAME_SIZE );
        pFixed->wFileNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset = lstrlen( psz ) + 1;
    }
    else
    {
        pFixed->wFileNameOffset = 0;
    }

    if ( pszFunction != NULL )
    {
        lstrcpyn( lpBuf->Buffer + wVariableOffset, pszFunction, MAX_FUNCTNAME_SIZE );

        pFixed->wFunctNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset += lstrlen( pszFunction ) + 1;
    }
    else
    {
        pFixed->wFunctNameOffset = 0;
    }

    //
    // set the current offset into the variable buffer
    //
    pFixed->wVariableLength = wVariableOffset;
}


//+---------------------------------------------------------------
//
//  Function:   CommitTraceBuffer
//
//  Synopsis:   deal with the buffer; either sync write or async queue
//
//  Arguments:  LPTRACEBUF lpBuf: the buffer to commit
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void CommitTraceBuffer( LPTRACEBUF lpBuf )
{
    DWORD   dwError = lpBuf->dwLastError;

    if ( dwAsyncTraceFlag == 0 )
    {
        WriteTraceBuffer( lpBuf );
        FreeTraceBuffer( lpBuf );
    }
    else
    {
        QueueAsyncTraceBuffer( lpBuf );
    }

    //
    // restore last error before initial Trace call
    //
    SetLastError( dwError );
}

//+---------------------------------------------------------------
//
//  Function:   DllEntryPoint
//
//  Synopsis:   only relevence is allocating thread local storage var
//
//  Arguments:  see Win32 SDK
//
//  Returns:    see Win32 SDK
//
//----------------------------------------------------------------
DbgTraceDLL BOOL WINAPI DllEntryPoint( HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved )
{
    //
    // InitAsyncTrace and TermAsyncTrace cannot be called from this entrypoint
    // because they create and interact with background threads
    // See CreateThread in Win32 Help file for more info
    //
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&g_csInitialize);
            return  TRUE;
//          return  InitAsyncTrace();

        case DLL_THREAD_ATTACH:
            if(fInitialized) // TlsAlloc hasn't been called till fInitialized = TRUE
            {
                TlsSetValue( dwTlsIndex, (LPVOID)NULL );
                TlsSetValue( dwRandFailTlsIndex, (LPVOID)NULL );
            }
            break;

        case DLL_PROCESS_DETACH:
            if (lpReserved == NULL)
                DeleteCriticalSection(&g_csInitialize);
//          TermAsyncTrace();
            return  FALSE;
    }
    return  TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   SetAsyncTraceParams
//
//  Synopsis:   exported function to setup trace buffer with
//              required fields
//
//              This is the first call for a trace statement.
//              Second call is different for strings or binary
//
//  Arguments:  LPSTR:      source file of the exception
//              int:        line number of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    returns a BOOL 1 if successful; 0 on failure
//
//  Note:       Feb 24, 1999. This function obsoleted by SetAsyncTraceParamsEx.
//              This function is retained purely for code that linked with
//              this dll, but won't be rebuilt to call SetAsyncTraceParamsEx.
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI SetAsyncTraceParams( LPSTR pszFile,
                                            int iLine,
                                            LPSTR pszFunction,
                                            DWORD dwTraceMask )
{
    LPTRACEBUF  lpBuf;
    DWORD       dwError = GetLastError();

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( ShouldLogModule("ALL") == FALSE )
    {
        return  0;

    }

    if ( lpBuf = GetTraceBuffer() )
    {

        SetTraceBufferInfo( lpBuf, iLine, pszFile, pszFunction, dwTraceMask, dwError );
        TlsSetValue( dwTlsIndex, (LPVOID)lpBuf );

        return  1;
    }
    else    return  0;
}


//+---------------------------------------------------------------
//
//  Function:   SetAsyncTraceParamsEx
//
//  Synopsis:   exported function to setup trace buffer with
//              required fields.
//
//              This is the first call for a trace statement.
//              Second call is different for strings or binary
//
//  Arguments:  LPSTR:      module name
//              LPSTR:      source file of the exception
//              int:        line number of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    returns a BOOL 1 if successful; 0 on failure
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI SetAsyncTraceParamsEx(
                                            LPSTR pszModule,
                                            LPSTR pszFile,
                                            int iLine,
                                            LPSTR pszFunction,
                                            DWORD dwTraceMask )
{
    LPTRACEBUF  lpBuf;
    DWORD       dwError = GetLastError();

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if (ShouldLogModule(pszModule) == FALSE)
    {
        return 0;
    }

    if ( lpBuf = GetTraceBuffer() )
    {

        SetTraceBufferInfo( lpBuf, iLine, pszFile, pszFunction, dwTraceMask, dwError );
        TlsSetValue( dwTlsIndex, (LPVOID)lpBuf );

        return  1;
    }
    else    return  0;
}


//+---------------------------------------------------------------
//
//  Function:   AsyncStringTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for sprintf style traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              LPCSTR:     format string
//              va_list:    marker for vsprintf functions
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI AsyncStringTrace(LPARAM lParam,
                                        LPCSTR szFormat,
                                        va_list marker )
{
    LPTRACEBUF  lpBuf;
    PFIXEDTR    pFixed;
    int         iLength;
    int         iMaxLength;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;
        iMaxLength = MAX_VARIABLE_SIZE - pFixed->wVariableLength;
        iLength =
            _vsnprintf( lpBuf->Buffer + pFixed->wVariableLength,
                        iMaxLength,
                        szFormat,
                        marker ) + 1;

        if ( iLength == 0 || iLength == iMaxLength + 1 )
        {
            iLength = iMaxLength;
            lpBuf->Buffer[MAX_VARIABLE_SIZE-1] = '\0';
        }

        _ASSERT( iLength <= iMaxLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += LOWORD( (DWORD)iLength );
        pFixed->wBinaryType = TRACE_STRING;
        pFixed->dwParam = (DWORD)lParam; // This is a 32-bit flag so the cast is OK

        //
        // this is a specific area where the app can overwrite
        // data.  Could have used vnsprintf to avoid the overwrite
        // but this woudl have dragged in the C runtime and
        // introduced its overhead and own critical sections
        //
        ASSERT( pFixed->wVariableLength <= MAX_VARIABLE_SIZE );

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  iLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   AsyncBinaryTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for binary traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              DWORD:      type of binary data ( ie Message, User... )
//              LPBYTE:     ptr to the data
//              DWORD:      length of the data
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI AsyncBinaryTrace(LPARAM  lParam,
                                        DWORD   dwBinaryType,
                                        LPBYTE  pbData,
                                        DWORD   cbData )
{
    LPTRACEBUF  lpBuf;
    WORD        wLength;
    PFIXEDTR    pFixed;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;

        wLength = LOWORD( min( cbData, MAX_BUFFER_SIZE ) );
        CopyMemory( lpBuf->Buffer + pFixed->wVariableLength, pbData, wLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += wLength;
        pFixed->wBinaryType = LOWORD( dwBinaryType );
        pFixed->dwParam = (DWORD)lParam; // This is a 32-bit flag so the cast is OK

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  (int)wLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   FlushAsyncTrace
//
//  Synopsis:   exported function to empty the pending queue.  All
//              threads which call this function block until the
//              queue is empty
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI FlushAsyncTrace( void )
{
static long lPendingFlushs = -1;

    if ( fInitialized == FALSE )
    {
        return  FALSE;
    }
    else
    {
        EnterCriticalSection( &critSecFlush );

        if ( PendQ.dwCount > 0 )
        {
            SetEvent( PendQ.hFlushEvent );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    THREAD_PRIORITY_ABOVE_NORMAL );
            }

            WaitForSingleObject( PendQ.hFlushedEvent, INFINITE );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    nAsyncThreadPriority );
            }
            ResetEvent( PendQ.hFlushedEvent );
        }
        LeaveCriticalSection( &critSecFlush );
        return  TRUE;
    }
}




//+---------------------------------------------------------------
//
//  Function:   InitAsyncTrace
//
//  Synopsis:   exported required function to rev things up.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI InitAsyncTrace( void )
{
static BOOL bInitializing = FALSE;
    BOOL    bRC = FALSE;
    DWORD   dwThreadId;

    EnterCriticalSection(&g_csInitialize);
    if ( fInitialized )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    if ( InterlockedExchange( (LPLONG)&bInitializing, (LONG)TRUE )  )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    // to guard against race condition when the initializing thread is about to execute
    //  'InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE )', while
    //  there is another thread that passed the
    // if ( InterlockedExchange( (LPLONG)&bInitializing, (LONG)TRUE )) condition
    //
    if ( fInitialized)
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );

        InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    // will read from registry later
    //
    dwNumTraces = 0;

    PendQ.dwProcessId = GetCurrentProcessId();
    PendQ.hFile = INVALID_HANDLE_VALUE;
    PendQ.cbBufferEnd = 0;
    PendQ.dwThresholdCount = DEFAULT_MAX_FILE_SIZE / AVERAGE_TRACE_SIZE;

    __try {

        InitializeCriticalSection( &PendQ.critSecTail );
        InitializeCriticalSection( &critSecWrite );
        InitializeCriticalSection( &critSecFlush );

        if ( (dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        if ( (dwRandFailTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        if ( GetTraceFlagsFromRegistry() == FALSE )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // Initialize the pool of trace buffers
        // must happen after reading the registy
        //
        if ( InitTraceBuffers( PendQ.dwThresholdCount, dwIncrementSize ) == FALSE )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        PendQ.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // PendQ.hFlushedEvent is manual reset so multiple threads can wait
        //
        PendQ.hFlushedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( PendQ.hFlushedEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        PendQ.hFlushEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hFlushEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // hShutdownEvent is manual reset so multiple threads can be awaken
        //
        hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( hShutdownEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        ASSERT( PendQ.hRegNotifyThread == NULL );

        PendQ.hRegNotifyThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)RegNotifyThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hRegNotifyThread == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }
        else
        {
            //
            // bumping the priority onthis almost always dorminate thread
            // ensures that trace changes are applied soon after the
            // registry changes
            //
            SetThreadPriority( PendQ.hRegNotifyThread, THREAD_PRIORITY_ABOVE_NORMAL );
        }

        ASSERT( PendQ.hWriteThread == NULL );

        PendQ.hWriteThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)WriteTraceThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hWriteThread == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }
        else
        {
            //
            // setting the priority on this thread ensures that the
            // physical writing of the traces will not impact performance
            // of the main application task. Default is BELOW_NORMAL although
            // its controlled by a reg entry
            //
            SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
        }

        PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;

        //
        // set our top level exception handler
        //
        lpfnPreviousFilter = SetUnhandledExceptionFilter( TopLevelExceptionFilter );

        fInitialized = TRUE;
        InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE );

        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );

        bRC = TRUE;
    }
    __finally
    {
        if ( bRC == FALSE )
        {
            DWORD   dwLastError = GetLastError();

            AsyncTraceCleanup();

            SetLastError( dwLastError );
        }
    }

    LeaveCriticalSection(&g_csInitialize);

    return  bRC;
}



//+---------------------------------------------------------------
//
//  Function:   TermAsyncTrace
//
//  Synopsis:   exported required function to wind things down.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI TermAsyncTrace( void )
{
    EnterCriticalSection(&g_csInitialize);

    if ( fInitialized )
    {
        if ( InterlockedDecrement( &dwInitializations ) == 0 )
        {
            BOOL fRet;

            fRet = AsyncTraceCleanup();
            LeaveCriticalSection(&g_csInitialize);

            return  fRet;
        }

        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }
    else
    {
        LeaveCriticalSection(&g_csInitialize);
        return  FALSE;
    }
}



//+---------------------------------------------------------------
//
//  Function:   DebugAssert
//
//  Synopsis:   exported required function for enhanced asserts
//
//  Arguments:  DWORD dwLine:       source code line of the _ASSERT
//              LPSTR lpszFunction  source code filename of the _ASSERT
//              LPSTR lpszExpression stringized version of _ASSERT param
//
//  Returns:    void
//
//----------------------------------------------------------------
char  szAssertOutput[512];
DllExport void WINAPI DebugAssert(  DWORD dwLine,
                                    LPSTR lpszFunction,
                                    LPSTR lpszExpression )
{
    DWORD   dwError = GetLastError();

    wsprintf( szAssertOutput, "\nASSERT: %s,\n File: %s,\n Line: %d\n Error: %d\n\n",
            lpszExpression, lpszFunction, dwLine, dwError );

    OutputDebugString( szAssertOutput );

    SetLastError( dwError );

    DebugBreak();
}



//+---------------------------------------------------------------
//
//  Function:   QueueAsyncTraceBuffer
//
//  Synopsis:   Routine to implement the appending of TRACEBUF to
//              the FIFO PendQ
//
//  Arguments:  LPTRACEBUF: the buffer
//
//  Returns:    void
//
//----------------------------------------------------------------
void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf )
{
    LPTRACEBUF  pPrevTail;

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    lpBuf->pNext = NULL;

    EnterCriticalSection( &PendQ.critSecTail );

    //
    // number of buffers on the queue can only decrease while
    // in this critical section since WriteTraceThread can continue
    // to pull buffers from the queue.
    //
    // WriteAsyncThread will not write this buffer until it has
    // been appended to the queue by incrementing PendQ.dwCount
    //
    // PendQ.pTail is only modified here and in a special case on the
    // background writer thread.  The special case is when Special needs
    // to be moved from the Head of the queue to the Tail.  Only during
    // this brief special case can both the background writer and the
    // foreground appender thread be operating on the same trace buffer.
    //

    pPrevTail = PendQ.pTail;
    pPrevTail->pNext = PendQ.pTail = lpBuf;

    LeaveCriticalSection( &PendQ.critSecTail );

    InterlockedIncrement( &PendQ.dwCount );

    //
    // wake up WriteTraceThread if necessary. It may not be since
    // WriteTraceThread will always empty its queue before sleeping
    //
    SetEvent( PendQ.hEvent );
}



//+---------------------------------------------------------------
//
//  Function:   DequeueAsyncTraceBuffer
//
//  Synopsis:   Routine to dequeue the top Trace Buffer from
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: the buffer
//
//----------------------------------------------------------------
LPTRACEBUF  DequeueAsyncTraceBuffer( void )
{
    LPTRACEBUF  lpBuf;
    LPTRACEBUF  pPrevTail;

    //
    // check to see if Special is at the head of the queue. If so, move
    // it to the end of the queue
    //
    if ( PendQ.pHead == (LPTRACEBUF)&PendQ.Special )
    {
        //
        // need to NULL Special.pNext before the Exchange so the list
        // is terminated as soon as we do the exchange.  We can lazily
        // set the old Tails next pointer since we're the only thread
        // that would dereference this pointer once its not the last
        // buffer in the FIFO
        //
        PendQ.pHead = PendQ.Special.pNext;
        PendQ.Special.pNext = NULL;

        EnterCriticalSection( &PendQ.critSecTail );
        //
        // see comment in QueueAsyncTraceBuffer to describe why we
        // to grab the Tail critical section here.  If we did not
        // include this Special buffer then we would have to grab
        // the critSec each time.
        //
        pPrevTail = PendQ.pTail;
        pPrevTail->pNext = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;

        LeaveCriticalSection( &PendQ.critSecTail );
    }

    //
    // again no critical section required since we're the only thread
    // accessing these PendQ.pHead.  This needs to be remembered if we
    // were to add integratity checking to the queues at a later date
    // since this queue is effectively in a corrupt state.
    //
    lpBuf = PendQ.pHead;
    PendQ.pHead = lpBuf->pNext;
    InterlockedDecrement( &PendQ.dwCount );

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    return  lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   AsyncTraceCleanup
//
//  Synopsis:   internla routine to clean things up
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL AsyncTraceCleanup( void )
{
    HANDLE  hThreads[2];
    int     nObjects = 0;
    DWORD   dw;

    INT_TRACE( "AsyncTraceCleanup Enter\n" );

    if ( InterlockedExchange( &PendQ.fShutdown, TRUE ) == TRUE )
    {
        return  FALSE;
    }

    if ( dwTlsIndex != 0xFFFFFFFF )
    {
        TlsFree( dwTlsIndex );
    }

    if ( dwRandFailTlsIndex != 0xFFFFFFFF )
    {
        TlsFree( dwRandFailTlsIndex );
    }

    //
    // restore the initial Exception filter; NULL signifies use the default
    //
    SetUnhandledExceptionFilter( lpfnPreviousFilter );

    if ( hShutdownEvent != NULL )
    {
        INT_TRACE( "AsyncTraceCleanup Calling SetEvent( hShutdownEvent )\n" );
        SetEvent( hShutdownEvent );
        INT_TRACE( "AsyncTraceCleanup Called SetEvent: Error: 0x%X\n", GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hWriteThread;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hRegNotifyThread;
    }

    //
    // allow background threads forever to shutdown
    //
    if ( nObjects != 0 )
    {
        INT_TRACE( "AsyncTraceCleanup Calling WFMO\n" );
        dw = WaitForMultipleObjects(nObjects,
                                    hThreads,
                                    TRUE,
                                    INFINITE );
        INT_TRACE( "AsyncTraceCleanup Called WFMO: dw: 0x%X  Error: 0x%X\n",
                    dw, GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        CloseHandle( PendQ.hWriteThread );
        PendQ.hWriteThread = NULL;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        CloseHandle( PendQ.hRegNotifyThread );
        PendQ.hRegNotifyThread = NULL;
    }

    if ( PendQ.hEvent != NULL )
    {
        CloseHandle( PendQ.hEvent );
        PendQ.hEvent = NULL;
    }

    if ( PendQ.hFlushEvent != NULL )
    {
        CloseHandle( PendQ.hFlushEvent );
        PendQ.hFlushEvent = NULL;
    }

    if ( PendQ.hFlushedEvent != NULL )
    {
        CloseHandle( PendQ.hFlushedEvent );
        PendQ.hFlushedEvent = NULL;
    }

    if ( hShutdownEvent != NULL )
    {
        CloseHandle( hShutdownEvent );
        hShutdownEvent = NULL;
    }

#if FALSE

    INT_TRACE( "TailCritSec  - Contention: %d, Entry: %d\n",
                PendQ.critSecTail.DebugInfo->ContentionCount,
                PendQ.critSecTail.DebugInfo->EntryCount );

    INT_TRACE( "WriteCritSec - Contention: %d, Entry: %d\n",
                critSecWrite.DebugInfo->ContentionCount,
                critSecWrite.DebugInfo->EntryCount );

    INT_TRACE( "FlushCritSec - Contention: %d, Entry: %d\n",
                critSecFlush.DebugInfo->ContentionCount,
                critSecFlush.DebugInfo->EntryCount );
#endif

    DeleteCriticalSection( &PendQ.critSecTail );
    DeleteCriticalSection( &critSecWrite );
    DeleteCriticalSection( &critSecFlush );

    if ( PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( PendQ.hFile );
    }

    PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;
    PendQ.Special.pNext = (LPTRACEBUF)NULL;

    //
    // free up the trace buffer CPool
    //
    TermTraceBuffers();

    INT_TRACE( "Total number of traces: %d\n", dwNumTraces );

    InterlockedExchange( &PendQ.fShutdown, FALSE );
    fInitialized = FALSE;

    return TRUE;
}


//+---------------------------------------------------------------
//
//  Function:   FlushBufferedWrites
//
//  Synopsis:   internal routine to write the PendQ temporary buffer
//              to disk.  Used to avoid multiple OS calls and increase
//              the write buffers.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL FlushBufferedWrites( void )
{
    BOOL        b = TRUE;
    DWORD       dwBytes;
    BOOL        bRetry = TRUE;

    //
    // need to lock the file since multiple process on multiple machines
    // may be tracing the same file and both writes have to complete as one.
    //

    if ( PendQ.cbBufferEnd )
    {
        DWORD dwOffset;

        ASSERT( PendQ.cbBufferEnd < MAX_WRITE_BUFFER_SIZE );

        dwOffset = SetFilePointer( PendQ.hFile, 0, 0, FILE_END );

        //
        // if the file is too big then we need to truncate it
        //
        if (dwOffset > dwMaxFileSize)
        {
            SetFilePointer(PendQ.hFile, 0, 0, FILE_BEGIN);
            SetEndOfFile(PendQ.hFile);
        }
try_again:
        b = WriteFile(  PendQ.hFile,
                        PendQ.Buffer,
                        PendQ.cbBufferEnd,
                        &dwBytes,
                        NULL );

        if ( b == FALSE || dwBytes != PendQ.cbBufferEnd )
        {
            DWORD   dwError = GetLastError();

            if( dwError && bRetry )
            {
                bRetry = FALSE;
                Sleep( 100 );
                goto try_again;
            }
//          ASSERT( FALSE );
            INT_TRACE( "Error writing to file: %d, number of bytes %d:%d\n",
                        dwError,
                        PendQ.cbBufferEnd,
                        dwBytes );
        }
    }

    PendQ.cbBufferEnd = 0;

    return  b;
}


//+---------------------------------------------------------------
//
//  Function:   WriteTraceBuffer
//
//  Synopsis:   internal routine to route the trace info to the
//              appropriate trace log
//
//  Arguments:  LPTRACEBUF: the buffer to write
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WriteTraceBuffer( LPTRACEBUF lpBuf )
{
    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    InterlockedIncrement( &dwNumTraces );

    EnterCriticalSection( &critSecWrite );

    if ( IsTraceFile( dwTraceOutputType ) && PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        DWORD   dwWrite;

        //
        // assert must be handled inside critical section
        //
        ASSERT( PendQ.cbBufferEnd+MAX_TRACE_ENTRY_SIZE < MAX_WRITE_BUFFER_SIZE );

        CopyMemory( PendQ.Buffer + PendQ.cbBufferEnd,
                    (char *)&lpBuf->Fixed,
                    dwWrite = sizeof(FIXEDTRACE) + lpBuf->Fixed.wVariableLength );

        PendQ.cbBufferEnd += dwWrite;

        if ( PendQ.cbBufferEnd + MAX_TRACE_ENTRY_SIZE >= MAX_WRITE_BUFFER_SIZE ||
            dwAsyncTraceFlag == 0 )
        {
            FlushBufferedWrites();
        }

    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DEBUG )
    {
        char    szThread[16];
        LPSTR   lpsz;

        EnterCriticalSection( &critSecWrite );

        wsprintf( szThread, "0x%08X: ", lpBuf->Fixed.dwThreadId );
        OutputDebugString( szThread );

        switch( lpBuf->Fixed.wBinaryType )
        {
        case TRACE_STRING:
            //
            // lstrcat may appear wasteful here; but it is less expensive than an
            // additional call to OutputDebugString( "\r\n" ); which works by
            // raising an exception.
            //
            // although appending \r\n on already full buffer is even worse
            //
            lpsz = lpBuf->Buffer + lpBuf->Fixed.wBinaryOffset - sizeof(FIXEDTRACE);
            OutputDebugString( lpsz );
            OutputDebugString( "\r\n" );
            break;

        case TRACE_BINARY:
            OutputDebugString( "Binary Trace\r\n" );
            break;

        case TRACE_MESSAGE:
            OutputDebugString( "Message Trace\r\n" );
            break;
        }

        LeaveCriticalSection( &critSecWrite );
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DISCARD )
    {
        //
        // fastest way to remove buffers. Used to find
        // deadlocks and race conditions
        //
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_INVALID )
    {
        InterlockedDecrement( &dwNumTraces );
        //
        // unknown trace output type
        //
        ASSERT( FALSE );
    }

    LeaveCriticalSection( &critSecWrite );

    return  TRUE;
}




//+---------------------------------------------------------------
//
//  Function:   FlushAsyncPendingQueue
//
//  Synopsis:   internal routine to empty the PendQ queue from the
//              background thread
//              Assumes it is not called re-entrantly: actually the
//              FIFO queue assumes only one thread dequeues buffers
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
void FlushAsyncPendingQueue( void )
{
    LPTRACEBUF  lpBuf;

    while( PendQ.dwCount > 0 )
    {
        lpBuf = DequeueAsyncTraceBuffer();

        //
        // if we've buffered more than we'll write before
        // truncating the file then throw away the trace
        //
        if ( PendQ.dwCount < PendQ.dwThresholdCount )
        {
            WriteTraceBuffer( lpBuf );
        }
        else
        {
            INT_TRACE( "Discarding traces: %u\n", PendQ.dwCount );
        }

        FreeTraceBuffer( lpBuf );
    }
    FlushBufferedWrites();
}


#define NUM_WRITE_THREAD_OBJECTS    3

//+---------------------------------------------------------------
//
//  Function:   WriteTraceThread
//
//  Synopsis:   background thread routine for pulling and writing
//              trace buffers from PendQ FIFO queue.
//
//  Arguments:  see Win32 SDK - ignored here
//
//  Returns:    DWORD: 0 if we exitted gracefully
//
//----------------------------------------------------------------
DWORD WriteTraceThread( LPDWORD lpdw )
{
    HANDLE      Handles[NUM_WRITE_THREAD_OBJECTS];
    DWORD       dw;

    //
    // preference given to Shutdown, FlushEvent and then the
    // normal buffer event.  This ensures that provide a quick
    // response on both shutdown and to a lesser extent Flush
    // since other threads are waiting for this thread to respond.
    //
    Handles[0] = hShutdownEvent;
    Handles[1] = PendQ.hFlushEvent;
    Handles[2] = PendQ.hEvent;

    INT_TRACE( "WriteTraceThreadId 0x%X\n", GetCurrentThreadId() );

    for ( ;; )
    {
        dw = WaitForMultipleObjects(NUM_WRITE_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
        //
        // normal signalled event
        //
        case WAIT_OBJECT_0+2:
            FlushAsyncPendingQueue();
            break;

        //
        // signalled by a foreground thread to flush our Q
        //
        case WAIT_OBJECT_0+0:
        case WAIT_OBJECT_0+1:
            FlushAsyncPendingQueue();

            if ( dw == WAIT_OBJECT_0+1 )
            {
                SetEvent( PendQ.hFlushedEvent );
            }
            else
            {
                INT_TRACE( "Exiting WriteTraceThread for hShutdownEvent\n" );
                return  0;
            }
            break;

        default:
            GetLastError();
            ASSERT( FALSE );
        }
    }
    INT_TRACE( "Exiting WriteTraceThread abnormally\n" );
}



//+---------------------------------------------------------------------------
//
//  Function:   ShouldLogModule
//
//  Synopsis:   Figures out whether a particular module is on the list of
//              modules to be logged.
//
//  Arguments:  [szModule] -- Name of module to check
//
//  Returns:    TRUE if module should log, FALSE if logging is disabled for
//              MODULE
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
ShouldLogModule(
    LPCSTR szModule)
{
    LPSTR szEntry;

    //
    // If a list of modules has not been specified, then all modules are to be
    // logged
    //

    if (mszModules[0] == 0) {
         return TRUE;
    }

    //
    // Otherwise, we check to see if the name of the module is in the list
    // mszModule is expected to be a set of NULL terminated strings, with the
    // last string double-null-terminated.
    //

    szEntry = mszModules;

    while (szEntry[0] != 0) {

        if (lstrcmpi(szEntry, szModule) == 0) {
             return TRUE;
        }

        szEntry += (strlen(szEntry) + 1);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\thrdpl2\src\thrdpool.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.cpp
//
//  Contents:    implementation of thrdpool2 library
//
//	Description: See header file.
//
//  Functions:
//
//  History:     09/18/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <thrdpl2.h>
#include <dbgtrace.h>
#include <xmemwrpr.h>

CThreadPool::CThreadPool()
{
    m_lInitCount = -1 ;
    m_hCompletionPort = NULL ;
    m_hShutdownEvent = NULL ;
    m_rgThrdpool = NULL ;
    m_rgdwThreadId = NULL;
    m_dwMaxThreads = m_dwNumThreads = 0;
    m_lWorkItems = -1;
    m_hJobDone = NULL;
    m_pvContext = NULL;
    InitializeCriticalSection( &m_csCritItems );
}

CThreadPool::~CThreadPool()
{
    _ASSERT( m_lInitCount == -1 ) ;
    _ASSERT( m_hCompletionPort == NULL ) ;
    _ASSERT( m_hShutdownEvent == NULL ) ;
    _ASSERT( m_rgThrdpool == NULL );
    _ASSERT( m_dwMaxThreads == 0 );
    _ASSERT( m_dwNumThreads == 0 );
    _ASSERT( m_lWorkItems == -1 );
    _ASSERT( m_hJobDone == NULL );
    _ASSERT( m_pvContext == NULL );
    DeleteCriticalSection( &m_csCritItems );
}

BOOL
CThreadPool::Initialize( DWORD dwConcurrency, DWORD dwMaxThreads, DWORD dwInitThreads )
{
	TraceFunctEnter("CThreadPool::Initialize");

    _ASSERT( dwMaxThreads >= dwInitThreads);
	if( InterlockedIncrement( &m_lInitCount ) == 0 )
	{
        _ASSERT( m_hCompletionPort == NULL ) ;
        _ASSERT( m_hShutdownEvent == NULL ) ;
        _ASSERT( m_rgThrdpool == NULL );

		//
		//	called for the first time - go ahead with initialization
		//
		m_hCompletionPort = CreateIoCompletionPort(
											INVALID_HANDLE_VALUE,
											NULL,
											0,
											dwConcurrency
											);

		if( !m_hCompletionPort ) {
			ErrorTrace(0, "Failed to create completion port: GetLastError is %d", GetLastError());
			return FALSE ;
		}

    	//
	    //	create shutdown event
	    //
	    if( !(m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) ) {
		    ErrorTrace(0,"Failed to create shutdown event");
    	    goto err_exit;
	    }

        m_rgThrdpool = XNEW HANDLE [dwMaxThreads];
        if( m_rgThrdpool == NULL ) {
            ErrorTrace(0,"Failed to allocate %d HANDLEs", dwMaxThreads);
            goto err_exit;
        }

        m_rgdwThreadId = XNEW DWORD[dwMaxThreads];
        if ( NULL == m_rgdwThreadId ) {
            ErrorTrace(0, "Failed to allocate %d dwords", dwMaxThreads );
            goto err_exit;
        }

        m_dwMaxThreads = dwMaxThreads;
        ZeroMemory( (PVOID)m_rgThrdpool, dwMaxThreads*sizeof(HANDLE) );

        _VERIFY( GrowPool( dwInitThreads ) );

        //for( i=0; i<m_dwNumThreads; i++ ) {
	    //    _VERIFY( ResumeThread( m_rgThrdpool[i] ) != 0xFFFFFFFF );
        //}

	} else
	{
		//
		//	bogus Init or already called
		//
		InterlockedDecrement( &m_lInitCount );
		return FALSE ;
	}

	DebugTrace(0,"Created completion port 0x%x", m_hCompletionPort);
	TraceFunctLeave();

	return TRUE ;

err_exit:

    //
    //  Failed init - cleanup partial stuff
    //

    _VERIFY( Terminate( TRUE ) );
    return FALSE;
}

BOOL
CThreadPool::Terminate( BOOL fFailedInit, BOOL fShrinkPool )
{
    DWORD i;
	TraceFunctEnter("CThreadPool::Terminate");

	if( InterlockedDecrement( &m_lInitCount ) < 0 )
	{
		//
		//	Init has been called so go ahead with termination
        //
        if( !fFailedInit ) {
		    //  Signal worker threads to stop and wait for them..
    	    //	this depends on derived class completion routines
	        //	checking this event - if they dont, we will block
	        //	till the thread finishes.
	        //
    	    _VERIFY( SetEvent( m_hShutdownEvent ) );
            if ( fShrinkPool ) ShrinkPool( m_dwNumThreads );

            DWORD dwNumHandles = 0;
            for(i=0;i<m_dwMaxThreads;i++) {
                if( m_rgThrdpool[i] ) dwNumHandles++;
            }

#ifdef DEBUG
            for( i=0; i<dwNumHandles;i++) {
                _ASSERT( m_rgThrdpool[i] != NULL );
            }
            for( i=dwNumHandles;i<m_dwMaxThreads;i++) {
                _ASSERT( m_rgThrdpool[i] == NULL );
            }
#endif
            //
            // Before wait for multiple object, I should make sure that
            // I am not waiting on myself
            //
            DWORD dwThreadId = GetCurrentThreadId();
            DWORD dwTemp;
            HANDLE hTemp;
            for ( DWORD i = 0; i < dwNumHandles; i++ ) {
                if ( m_rgdwThreadId[i] == dwThreadId ) {
                    dwTemp = m_rgdwThreadId[i];
                    hTemp = m_rgThrdpool[i];
                    m_rgdwThreadId[i] = m_rgdwThreadId[dwNumHandles-1];
                    m_rgThrdpool[i] = m_rgThrdpool[dwNumHandles-1];
                    m_rgdwThreadId[dwNumHandles-1] = dwTemp;
                    m_rgThrdpool[dwNumHandles-1] = hTemp;
                    dwNumHandles--;
                    break;
                }
            }

	        //
	        //	wait for worker threads to terminate
	        //
	        if ( dwNumHandles > 0 ) {
	            DWORD dwWait = WaitForMultipleObjects( dwNumHandles, m_rgThrdpool, TRUE, INFINITE);
	            if(WAIT_FAILED == dwWait) {
		            ErrorTrace(0,"WFMO: returned %d: error is %d", dwWait, GetLastError());
		            _ASSERT( FALSE );
	            }
	        }
        }

        //
        //  Release stuff
        //
        if( m_hCompletionPort ) {
		    _VERIFY( CloseHandle( m_hCompletionPort ) );
            m_hCompletionPort = NULL;
        }

        if( m_hShutdownEvent ) {
            _VERIFY( CloseHandle( m_hShutdownEvent ) );
            m_hShutdownEvent = NULL;
        }

        if( m_hJobDone ) {
            _VERIFY( CloseHandle( m_hJobDone ) );
            m_hJobDone = NULL;
        }

        if( m_rgThrdpool ) {
            for( i=0; i<m_dwMaxThreads; i++) {
                if( m_rgThrdpool[i] ) {
	                _VERIFY( CloseHandle(m_rgThrdpool[i]) );
                    m_rgThrdpool[i] = NULL;
                }
            }

            XDELETE [] m_rgThrdpool;
            XDELETE [] m_rgdwThreadId;
            m_rgThrdpool = NULL;
            m_dwNumThreads = m_dwMaxThreads = 0;
        }

	    return TRUE ;
    }

	return FALSE ;
}

DWORD __stdcall CThreadPool::ThreadDispatcher(PVOID pvThrdPool)
{
	DWORD dwBytesTransferred;
	DWORD_PTR dwCompletionKey;
	DWORD dwWait;
	LPOVERLAPPED lpo;

	//
	//	get pointer to this CThreadPool object
	//
	CThreadPool *pThrdPool = (CThreadPool *) pvThrdPool;

	TraceFunctEnter("CThreadPool::ThreadDispatcher");

	do
	{
		//
		//	wait for work items to be queued
		//
		if( !GetQueuedCompletionStatus(
									pThrdPool->QueryCompletionPort(),
									&dwBytesTransferred,
									&dwCompletionKey,
									&lpo,
									INFINITE				// wait timeout
									) )
		{
			ErrorTrace(0,"GetQueuedCompletionStatus() failed: error: %d", GetLastError());
			_ASSERT( FALSE );
		}

		//
		//	check for termination packet
		//
		if( dwCompletionKey == NULL ) {
			DebugTrace(0,"Received termination packet - bailing");
            //
            //  reduce the thread count
            //
            pThrdPool->m_dwNumThreads--;

            //
            // If I am the last thread to be shutdown, call the auto-shutdown
            // interface.  Some users of thread pool may not care about this
            //
            if ( pThrdPool->m_dwNumThreads == 0 )
                pThrdPool->AutoShutdown();

			break;
		}

		//
		//	check for termination signal
		//
		dwWait = WaitForSingleObject( pThrdPool->QueryShutdownEvent(), 0 );

		if( WAIT_TIMEOUT == dwWait ) {
			DebugTrace(0,"Calling WorkCompletion() routine");

    		//
	    	//	call derived class method to process work completion
		    //
			pThrdPool->WorkCompletion( (PVOID)dwCompletionKey );
		}

        //  If we are done with all work items, release any threads waiting on this job
        EnterCriticalSection( &pThrdPool->m_csCritItems );
        if( InterlockedDecrement( &pThrdPool->m_lWorkItems ) < 0 ) {
            //DebugTrace(0,"Setting job event: count is %d", pThrdPool->m_lWorkItems );
            _VERIFY( SetEvent( pThrdPool->m_hJobDone ) );
        }
        LeaveCriticalSection( &pThrdPool->m_csCritItems );

	} while( TRUE );

	return 0;
}

BOOL CThreadPool::PostWork(PVOID pvWorkerContext)
{
	TraceFunctEnter("CThreadPool::PostWork");

	_ASSERT( m_rgThrdpool );
	_ASSERT( m_hCompletionPort );

    if( pvWorkerContext != NULL ) {
        //  Bump count of work items since this job began
        EnterCriticalSection( &m_csCritItems );
        if( InterlockedIncrement( (LPLONG)&m_lWorkItems ) == 0 ) {
            //DebugTrace(0,"Resetting job event: count is %d", m_lWorkItems );
            ResetEvent( m_hJobDone );
        }
        LeaveCriticalSection( &m_csCritItems );
    }

	if( !PostQueuedCompletionStatus(
								m_hCompletionPort,
								0,
								(DWORD_PTR)pvWorkerContext,
								NULL
								) )
	{
        if( pvWorkerContext != NULL ) {
            //  Compensate for the increment....
            //  Last guy out releases the thread waiting on this job.
            if( InterlockedDecrement( (LPLONG)&m_lWorkItems ) < 0 ) {
                //DebugTrace(0,"Setting job event: count is %d", m_lWorkItems );
                _VERIFY( SetEvent( m_hJobDone ) );
            }
        }

		ErrorTrace(0,"PostQCompletionStatus() failed: error: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}	

BOOL CThreadPool::ShrinkPool( DWORD dwNumThreads )
{
    TraceFunctEnter("CThreadPool::ShrinkPool");

    if( dwNumThreads >= m_dwNumThreads ) {
        dwNumThreads = m_dwNumThreads;
    }

    for( DWORD i=0; i<dwNumThreads; i++ ) {
        _VERIFY( PostWork( NULL ) );
    }

    return TRUE;
}

VOID CThreadPool::ShrinkAll()
{
    TraceFunctEnter( "CThreadPool::ShrinkAll" );
    ShrinkPool( m_dwNumThreads );
    TraceFunctLeave();
}

BOOL CThreadPool::GrowPool( DWORD dwNumThreads )
{
    TraceFunctEnter("CThreadPool::GrowPool");

    if( dwNumThreads > m_dwMaxThreads ) {
        dwNumThreads = m_dwMaxThreads;
    }

    //
    //  We will try and grow the pool by dwNumThreads.
    //  Scan the handle list and create a thread for
    //  every available slot we have.
    //

    DebugTrace(0,"Attempting to grow pool by %d threads", dwNumThreads);
    for( DWORD i=0; i<m_dwMaxThreads && dwNumThreads != 0; i++) {
        //
        //  If current slot is non-NULL, handle in slot may be
        //  signalled, so close it and grab the slot.
        //
        if( m_rgThrdpool[i] ) {
            DWORD dwWait = WaitForSingleObject( m_rgThrdpool[i], 0 );
            if( dwWait == WAIT_OBJECT_0 ) {
                DebugTrace(0,"Thread %d has terminated: closing handle", i+1);
                _VERIFY( CloseHandle(m_rgThrdpool[i]) );
                m_rgThrdpool[i] = NULL;
            }
        }

        //
        //  If current slot is NULL, it is available for a new thread
        //
        if( m_rgThrdpool[i] == NULL ) {
	        //DWORD dwThreadId;
	        if (!(m_rgThrdpool[i] = ::CreateThread(
                                                NULL,
			        					        0,
				        				        ThreadDispatcher,
					            		        this,
							        	        0, //CREATE_SUSPENDED,
								                &m_rgdwThreadId[i]))) {
		        ErrorTrace(0,"Failed to create thread: error: %d", GetLastError());
                _ASSERT( FALSE );
	        }
            dwNumThreads--;
            m_dwNumThreads++;
        }
    }

    if( dwNumThreads )
        DebugTrace(0,"Failed to create %d threads", dwNumThreads );

    return TRUE;
}

VOID
CThreadPool::BeginJob( PVOID pvContext )
{
    TraceFunctEnter("CThreadPool::BeginJob");

    if( m_hJobDone == NULL ) {
        m_hJobDone = CreateEvent( NULL, FALSE, TRUE, NULL );
        _ASSERT( m_hJobDone );
    } else {
        SetEvent( m_hJobDone );
    }

    m_lWorkItems = -1;
    m_pvContext  = pvContext;
}

DWORD
CThreadPool::WaitForJob( DWORD dwTimeout )
{
    TraceFunctEnter("CThreadPool::WaitForJob");
    DWORD dwWait = WaitForSingleObject( m_hJobDone, dwTimeout );
    if( WAIT_OBJECT_0 == dwWait ) {
        m_pvContext = NULL;
    }
    return dwWait;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\thrdpool\thrdpool.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.cpp
//
//  Contents:    implementation of thrdpool library
//
//	Description: See header file.
//
//  Functions:
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <thrdpool.h>
#include <dbgtrace.h>

LONG   CWorkerThread::m_lInitCount = -1 ;
HANDLE CWorkerThread::m_hCompletionPort = NULL ;

BOOL
CWorkerThread::InitClass( DWORD dwConcurrency )
{
	TraceFunctEnter("CWorkerThread::InitClass");

	if( InterlockedIncrement( &m_lInitCount ) == 0 )
	{
		//
		//	called for the first time - go ahead with initialization
		//
		m_hCompletionPort = CreateIoCompletionPort(
											INVALID_HANDLE_VALUE,
											NULL,
											0,
											dwConcurrency
											);

		if( !m_hCompletionPort ) {
			ErrorTrace(0, "Failed to create completion port: GetLastError is %d", GetLastError());
			return FALSE ;
		}

	} else
	{
		//
		//	bogus Init or already called
		//
		InterlockedDecrement( &m_lInitCount );
		return FALSE ;
	}

	DebugTrace(0,"Created completion port 0x%x", m_hCompletionPort);
	TraceFunctLeave();

	return TRUE ;
}

BOOL
CWorkerThread::TermClass()
{
	TraceFunctEnter("CWorkerThread::TermClass");

	if( InterlockedDecrement( &m_lInitCount ) < 0 )
	{
		//
		//	Init has been called so go ahead with termination
		//
		_ASSERT( m_hCompletionPort );
		_VERIFY( CloseHandle( m_hCompletionPort ) );
		return TRUE ;
	}

	return FALSE ;
}

CWorkerThread::CWorkerThread() : m_hThread(NULL), m_hShutdownEvent( NULL )
{
	DWORD dwThreadId;

	TraceFunctEnter("CWorkerThread::CWorkerThread");

	//
	//	create shutdown event
	//
	if( !(m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) ) {
		ErrorTrace(0,"Failed to create shutdown event");
		_ASSERT( FALSE );
		return;
	}

	//
	//	create worker thread
	//
	if (!(m_hThread = ::CreateThread(
								NULL,
								0,
								ThreadDispatcher,
								this,
								CREATE_SUSPENDED,
								&dwThreadId))) {
		ErrorTrace(0,"Failed to create thread: error: %d", GetLastError());
		_ASSERT( FALSE );
	}
	else
	{
		_VERIFY( ResumeThread( m_hThread ) != 0xFFFFFFFF );
	}

	TraceFunctLeave();
	return;
}

CWorkerThread::~CWorkerThread()
{
	TraceFunctEnter("CWorkerThread::~CWorkerThread");

	_ASSERT( m_hCompletionPort );
	_ASSERT( m_hThread );
	_ASSERT( m_hShutdownEvent );

	//
	//	signal worker thread to shutdown
	//	this depends on derived class completion routines
	//	checking this event - if they dont, we will block
	//	till the thread finishes.
	//
	_VERIFY( SetEvent( m_hShutdownEvent ) );

	//
	//	post a null termination packet
	//
	if( !PostWork( NULL ) ) {
		ErrorTrace(0,"Error terminating worker thread");
		_ASSERT( FALSE );
	}

	//
	//	wait for worker thread to terminate
	//
	DWORD dwWait = WaitForSingleObject(m_hThread, INFINITE);
	if(WAIT_OBJECT_0 != dwWait) {
		ErrorTrace(0,"WFSO: returned %d", dwWait);
		_ASSERT( FALSE );
	}

	_VERIFY( CloseHandle(m_hThread) );
	_VERIFY( CloseHandle(m_hShutdownEvent) );
	m_hThread = NULL;
	m_hShutdownEvent = NULL;
}

DWORD __stdcall CWorkerThread::ThreadDispatcher(PVOID pvWorkerThread)
{
	//
	//	get pointer to this CWorkerThread object
	//
	CWorkerThread *pWorkerThread = (CWorkerThread *) pvWorkerThread;

	//
	//	call GetQueuedCompletionStatus() to get work completion
	//
	pWorkerThread->GetWorkCompletion();

	return 0;
}

VOID CWorkerThread::GetWorkCompletion(VOID)
{
	DWORD dwBytesTransferred;
	DWORD_PTR dwCompletionKey;
	DWORD dwWait;
	LPOVERLAPPED lpo;
	LPWorkContextEnv lpWCE;
	PVOID	pvWorkContext;

	TraceFunctEnter("CWorkerThread::GetWorkCompletion");

	_ASSERT( m_hThread );
	_ASSERT( m_hCompletionPort );

	do
	{
		//
		//	wait for work items to be queued
		//
		if( !GetQueuedCompletionStatus(
									m_hCompletionPort,
									&dwBytesTransferred,
									&dwCompletionKey,
									&lpo,
									INFINITE				// wait timeout
									) )
		{
			ErrorTrace(0,"GetQueuedCompletionStatus() failed: error: %d", GetLastError());
			break ;
		}

		//
		// get a hold of the work context envelope and work context
		//
		lpWCE = (LPWorkContextEnv) lpo;
		pvWorkContext = lpWCE->pvWorkContext;

		//
		//	check for termination packet
		//
		if( pvWorkContext == NULL ) {
			DebugTrace(0,"Received termination packet - bailing");
			delete lpWCE;
			lpWCE = NULL;
			break;
		}

		//
		//	check for termination signal
		//
		dwWait = WaitForSingleObject( m_hShutdownEvent, 0 );

		//
		//	call derived class method to process work completion
		//
		if( WAIT_TIMEOUT == dwWait ) {
			DebugTrace(0,"Calling WorkCompletion() routine");
			WorkCompletion( pvWorkContext );
		}

		//
		//	destroy the WorkContextEnv object allocated before PostQueuedCompletionStatus()
		//
		delete lpWCE;
		lpWCE = NULL;

	} while( TRUE );

	return;
}

BOOL CWorkerThread::PostWork(PVOID pvWorkerContext)
{
	TraceFunctEnter("CWorkerThread::PostWork");

	_ASSERT( m_hThread );
	_ASSERT( m_hCompletionPort );

	//
	//	allocate a WorkContextEnv blob - this is destroyed after GetQueuedCompletionStatus()
	//	completes ! We may want to have a pool of such blobs instead of hitting the heap !!
	//
	LPWorkContextEnv lpWCE = new WorkContextEnv;
	if( !lpWCE ) {
		ErrorTrace(0,"Failed to allocate memory");
		return FALSE ;
	}

	ZeroMemory( lpWCE, sizeof(WorkContextEnv) );
	lpWCE->pvWorkContext = pvWorkerContext;

	if( !PostQueuedCompletionStatus(
								m_hCompletionPort,
								0,
								0,
								(LPOVERLAPPED)lpWCE
								) )
	{
		ErrorTrace(0,"PostQCompletionStatus() failed: error: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\registry.c ===
/*----------------------------------------------------------------------
    REGISTRY.C
        Async tracing Registry reading routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define _DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include "traceint.h"
#include "randint.h"


char    szTraceFileName[MAX_PATH];
char    szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";


extern DbgTraceDLL DWORD       __dwEnabledTraces;

__inline BOOL GetRegDword( HKEY hKey, LPSTR pszValue, LPDWORD pdw )
{
    DWORD   cbData = sizeof( DWORD );
    DWORD   dwType = REG_DWORD;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (LPBYTE)pdw,
                            &cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}



__inline BOOL GetRegString( HKEY hKey, LPSTR pszValue, LPBYTE buf, LPDWORD lpcbData )
{
    DWORD   dwType = REG_SZ;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            buf,
                            lpcbData ) == ERROR_SUCCESS && dwType == REG_SZ;
}


__inline BOOL GetRegMSZ( HKEY hKey, LPSTR pszValue, LPBYTE buf, LPDWORD lpcbData)
{

    DWORD   dwType = REG_MULTI_SZ;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            buf,
                            lpcbData ) == ERROR_SUCCESS && dwType == REG_MULTI_SZ;

}


BOOL GetTraceFlagsFromRegistry( void )
{
static char szNewTraceFileName[MAX_PATH];
static char mszNewModules[MODULES_BUFFER_SIZE];
    DWORD   dwNewEnabledTraces;
    DWORD   dwNewTraceOutputType;
    DWORD   dwNewAsyncTraceFlag;
    DWORD   dwNewHeapIncrementCount;
    int     nNewThreadPriority;
    long    nNewFailRate;
    LONG    cRandFailBuffer;
    HKEY    hkConfig = NULL;
    BOOL    bRC = FALSE;
    DWORD   cbData;
    DWORD   dwDisposition;


    __try
    {
        if ( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szDebugAsyncTrace,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ,
                    NULL,
                    &hkConfig,
                    &dwDisposition) == ERROR_SUCCESS )
        {
            if ( GetRegDword(   hkConfig,
                                "MaxTraceFileSize",
                                &dwMaxFileSize ) == FALSE )
            {
                dwMaxFileSize = DEFAULT_MAX_FILE_SIZE;
            }

            //
            // determine threshold count based on how we can fit in the file
            //
            PendQ.dwThresholdCount = dwMaxFileSize / AVERAGE_TRACE_SIZE;
            INT_TRACE( "PendQ.dwThresholdCount: %d\n", PendQ.dwThresholdCount );

            //
            // determine the modules to log
            //
            cbData = MODULES_BUFFER_SIZE;
            ZeroMemory(mszNewModules, sizeof(mszNewModules));
            if ( GetRegMSZ( hkConfig, "Modules", mszNewModules, &cbData ) == FALSE) {
                INT_TRACE( "GetRegMSZ: Modules failed: %d\n", GetLastError());
                INT_TRACE( "\tLogging all modules" );
                ZeroMemory(mszNewModules, MODULES_BUFFER_SIZE);
            }

            if ( GetRegDword(   hkConfig,
                                "EnabledTraces",
                                &dwNewEnabledTraces ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of __dwEnabledTraces
                //
                INT_TRACE( "GetRegDword: EnabledTraces failed: %d\n", GetLastError() );
                dwNewEnabledTraces = __dwEnabledTraces;
            }

            if ( GetRegDword(   hkConfig,
                                "OutputTraceType",
                                &dwNewTraceOutputType ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of dwTraceOutputType
                //
                INT_TRACE( "GetRegDword: OutputTraceType failed: %d\n", GetLastError() );
                dwNewTraceOutputType = dwTraceOutputType;
            }
            // If ouput is disabled, clear the EnabledTraces bitmap
            if (dwNewTraceOutputType == TRACE_OUTPUT_DISABLED )
            	dwNewEnabledTraces = 0;

            if ( GetRegDword(   hkConfig,
                                "AsyncTraceFlag",
                                &dwNewAsyncTraceFlag ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of dwAsyncTraceFlag
                //
                INT_TRACE( "GetRegDword: AsyncTraceFlag failed: %d\n", GetLastError() );
                dwNewAsyncTraceFlag = dwAsyncTraceFlag;
            }

            if (GetRegDword(hkConfig,
                            "HeapIncrementCount",
                            (LPDWORD)&dwNewHeapIncrementCount ) == FALSE ||
                dwNewHeapIncrementCount == 0 )
            {
                //
                // optional reg entry
                // default is the number buffers in 64KB
                //
                dwNewHeapIncrementCount = 0x10000 / sizeof(TRACEBUF);
            }
            InterlockedExchange( (long *)&dwIncrementSize, (long)dwNewHeapIncrementCount );


            if ( GetRegDword(   hkConfig,
                                "AsyncThreadPriority",
                                (LPDWORD)&nNewThreadPriority ) == FALSE )
            {
            //
            // optional reg entry
            //
                nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
            }
            else switch( nNewThreadPriority )
            {
            //
            // if successful verify the resulting value
            //
            case THREAD_PRIORITY_IDLE:
            case THREAD_PRIORITY_BELOW_NORMAL:
            case THREAD_PRIORITY_NORMAL:
            case THREAD_PRIORITY_ABOVE_NORMAL:
            case THREAD_PRIORITY_HIGHEST:
                break;

            default:
                ASSERT( FALSE );
                nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
            }

            if (GetRegDword(hkConfig,
                            "FailureRate",
                            (LPDWORD)&nNewFailRate ) == FALSE)
            {
                //
                // optional reg entry
                // default is to disable failure
                //
                nNewFailRate = kDontFail;

            }

            InterlockedExchange( &nFailRate, nNewFailRate );

            cbData = MAX_PATH;
            if ( !GetRegString( hkConfig,
                                "FailureFile",
                                g_szRandFailFile,
                                &cbData ) ) {
                *g_szRandFailFile = '\0';
            }

            if ( GetRegDword(   hkConfig,
                                "FailureBuffer",
                                (LPDWORD)&cRandFailBuffer ))
            {
                g_cCallStack = cRandFailBuffer;
            } else
                g_cCallStack = 1;   // default value

            cbData = sizeof(szNewTraceFileName);
            if ( GetRegString(  hkConfig,
                                "TraceFile",
                                szNewTraceFileName,
                                &cbData ) == FALSE )
            {
                //
                // Only fail if user specifies FILE based tracing
                //
                if ( dwNewTraceOutputType & TRACE_OUTPUT_FILE )
                {
                    INT_TRACE( "GetRegString: TraceFile failed: %d\n", GetLastError() );
                    return  bRC = FALSE;
                }
            }

            bRC = TRUE;

        }

    }
    __finally
    {
        //
        // preserve the original error code
        //
        DWORD   dwLastError = GetLastError();
        BOOL    fLeaveCritSec = FALSE;

        if ( bRC == TRUE )
        {
            BOOL    bNewFileName = lstrcmpi( szNewTraceFileName, szTraceFileName ) != 0;
            BOOL    bNewTraces = dwNewEnabledTraces != __dwEnabledTraces;
            BOOL    bNewFlags = dwNewAsyncTraceFlag != dwAsyncTraceFlag;
            BOOL    bNewOutput = dwNewTraceOutputType != dwTraceOutputType;
            BOOL    bNewModules = memcmp(mszModules, mszNewModules, MODULES_BUFFER_SIZE) != 0;

            INT_TRACE( "GetTraceFlags... 0x%08X, 0x%08X, 0x%08X, %s\n",
                        dwNewAsyncTraceFlag,
                        dwNewEnabledTraces,
                        dwNewTraceOutputType,
                        szNewTraceFileName );

            INT_TRACE( "bNewFileName:%d bNewTraces:%d bNewOutput:%d bNewFlags:%d bNewModules:%d\n",
                        bNewFileName,
                        bNewTraces,
                        bNewOutput,
                        bNewFlags,
                        bNewModules );

            if ( bNewFileName || bNewTraces || bNewOutput || bNewFlags || bNewModules )
            {
                if ( __dwEnabledTraces )
                {
                    //
                    // not the initial time thru
                    //

                    fLeaveCritSec = TRUE;

                    if ( dwAsyncTraceFlag )
                    {
                        FlushAsyncTrace();
                    }
                    EnterCriticalSection( &critSecWrite );
                }

                if ( PendQ.hFile != INVALID_HANDLE_VALUE )
                {
                    //
                    // if the file name changed or tracing was disabled or the
                    // file tracing disabled, then close the currently open file
                    //
                    if( bNewFileName ||
                        dwNewEnabledTraces == 0 ||
                        IsTraceFile( dwNewTraceOutputType ) == FALSE )
                    {
                        BOOL    bSuccess;

                        EnterCriticalSection( &critSecWrite );
                        bSuccess = CloseHandle( PendQ.hFile );
                        INT_TRACE( "CloseHandle: %d, GetLastError: %d\n",
                                    bSuccess, GetLastError() );
                        PendQ.hFile = INVALID_HANDLE_VALUE;
                        LeaveCriticalSection( &critSecWrite );
                    }
                }

                if ( IsTraceFile( dwNewTraceOutputType ) )
                {
                    if (bNewFileName ||
                        IsTraceFile( dwTraceOutputType ) == FALSE ||
                        dwNewEnabledTraces != 0 &&
                        PendQ.hFile == INVALID_HANDLE_VALUE )
                    {
                        PendQ.hFile = CreateFile(szNewTraceFileName,
                                                GENERIC_WRITE,
                                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                                NULL,
                                                OPEN_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL );

                        if ( PendQ.hFile != INVALID_HANDLE_VALUE )
                        {
                            lstrcpy( szTraceFileName, szNewTraceFileName );
                        }
                        else
                        {
                            INT_TRACE( "CreateFile failed for %s 0x%X\n",
                                        szNewTraceFileName,
                                        GetLastError() );
                        }
                    }
                }

                //
                // set the new priority for the writer thread
                //
                if ( nNewThreadPriority != nAsyncThreadPriority )
                {
                    nAsyncThreadPriority = nNewThreadPriority;
                    SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
                }

                //
                // set the new list of modules to log
                //
                if ( bNewModules ) {
                    memcpy(mszModules, mszNewModules, MODULES_BUFFER_SIZE);
                }

                dwTraceOutputType = dwNewTraceOutputType;
                dwAsyncTraceFlag = dwNewAsyncTraceFlag;

                InterlockedExchange( &__dwEnabledTraces, dwNewEnabledTraces );

                if ( fLeaveCritSec )
                {
                    //
                    // not the initial time thru
                    //
                    LeaveCriticalSection( &critSecWrite );
                }
            }
        }

        if ( hkConfig != NULL )
        {
            RegCloseKey( hkConfig );
        }

        SetLastError( dwLastError );

    }
    return  bRC;
}




#define NUM_REG_THREAD_OBJECTS  2

DWORD RegNotifyThread( LPDWORD lpdw )
{
    HANDLE  Handles[NUM_REG_THREAD_OBJECTS];
    HKEY       hKey;
    DWORD   dw;

    Handles[0] = hShutdownEvent;

    INT_TRACE( "RegNotifyThread 0x%X\n", GetCurrentThreadId() );

    Handles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( Handles[1] == NULL )
    {
        ASSERT( FALSE );
        INT_TRACE( "RegNotifyThread CreateEvent failed 0x%X\n", GetLastError() );
        return  1;
    }

    if ( RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        szDebugAsyncTrace,
                        0,
                        KEY_READ,
                        &hKey ) != ERROR_SUCCESS )
    {
        INT_TRACE( "RegNotifyThread RegOpenKeyEx failed 0x%X\n", GetLastError() );
        CloseHandle( Handles[1] );
        return  1;
    }

    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue(hKey,
                                    FALSE,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    Handles[1],
                                    TRUE ) != ERROR_SUCCESS )
        {
            INT_TRACE( "RegNotifyThread RegNotify... failed 0x%X\n", GetLastError() );
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }

        dw = WaitForMultipleObjects(NUM_REG_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
        //
        // normal signalled event
        //
        case WAIT_OBJECT_0:
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            INT_TRACE( "Exiting RegNotifyThread for hShutdownEvent\n" );
            return  0;

        //
        // signalled that our registry keys have changed
        //
        case WAIT_OBJECT_0+1:
            GetTraceFlagsFromRegistry();
            break;

        default:
            INT_TRACE( "RegNotifyThread WFMO: dw: 0x%X, Error: 0x%X\n", dw, GetLastError() );
            ASSERT( FALSE );
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }
    }

    INT_TRACE( "Exiting RegNotifyThread abnormally\n" );
    RegCloseKey( hKey );
    CloseHandle( Handles[1] );

    return  2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\randfail.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randfail.c

Abstract :

    This module implements the initialization function for the random
	failure library, plus the code to determine if it's time to fail.

Author :

    Sam Neely

Revision History :

--*/

#include <windows.h>
#include <stdio.h>
#include "traceint.h"
#include "randint.h"
#include "exchmem.h"

static long s_nCount = 0;
long nFailRate = kDontFail;
DWORD dwRandFailTlsIndex=0xffffffff;
const DWORD g_dwMaxCallStack = 1024;

//
// Call stack buffer array
//

CHAR    **g_ppchCallStack = NULL;

//
// Randfail call stack file and its handle
//

CHAR    g_szRandFailFile[MAX_PATH+1];
HANDLE  g_hRandFailFile = INVALID_HANDLE_VALUE;
HANDLE  g_hRandFailMutex = INVALID_HANDLE_VALUE;

//
// Number of buffers allocated for randfail call stack
//

LONG   g_cCallStack = 1;

//
// Current index in the buffer array
//

LONG   g_iCallStack = 0;

VOID
DumpCallStack(  DWORD_PTR   *rgdwCall,
                DWORD       dwCallers,
                PBYTE       pbCallstack,
                DWORD&      cbCallstack )
/*++
Routine description:

    Dump call stack into the given buffer.

Arguments:

    rgdwCall    - Array of caller's address
    dwCallers   - Number of callers
    pbCallstack - The buffer to put the call stack string into
    cbCallstack - In: How big the buffer is, Out: how much stuff I have put
                    in there

Return value:

    None.
--*/
{
	DWORD	i;
	CHAR    Buffer[g_dwMaxCallStack];
	DWORD   dwLine = 0;
	DWORD   dwBufferAvail = cbCallstack - 2*sizeof(CHAR);
	PBYTE   pbStart = pbCallstack;
	DWORD   dwBytesWritten = 0;
	BOOL    fRetry = TRUE;
	char    szModuleName[MAX_PATH];
	char*   pszFileName;
	char*   pszExtension;

	_ASSERT( pbStart );
	_ASSERT( cbCallstack > 0 );

    cbCallstack = 0;

    //
    // Get the executable's filename and point past the last slash
    // in the path, if it's present.  Also, whack off the extension
    // if it's .EXE
    //
	if (GetModuleFileName(NULL, szModuleName, MAX_PATH) == 0) {
	    strcpy (szModuleName, "Unknown");
	}

	pszFileName = strrchr(szModuleName, '\\');
	if (pszFileName == NULL) {
	    pszFileName = szModuleName;
	} else {
	    pszFileName++;
	}

	pszExtension = strrchr(pszFileName, '.');
	if (pszExtension) {
	    if (_stricmp(pszExtension+1, "exe") == 0) {
	        *pszExtension = NULL;
	    }
	}

	//
	// Format a header line
    //

    dwBytesWritten = _snprintf((char*)pbStart,
        g_dwMaxCallStack,
        "*** %s, Process: %d(%#x), Thread: %d(%#x) ***\r\n",
        pszFileName,
        GetCurrentProcessId(), GetCurrentProcessId(),
        GetCurrentThreadId(), GetCurrentThreadId());

    cbCallstack += dwBytesWritten;
    pbStart += dwBytesWritten;
    dwBufferAvail -= dwBytesWritten;

    //
	// Dump call stack
	// Note that we skip the first two entries.  These are the internal
	// calls to ExchmemGetCallStack and g_TestTrace
	for (i = 2; i < dwCallers && rgdwCall[i] != 0; i++)
	{
		ExchmemFormatSymbol(
		            GetCurrentProcess(),
		            rgdwCall[i],
		            Buffer,
		            g_dwMaxCallStack );
		dwLine = strlen( Buffer );
		if ( dwLine+2 < dwBufferAvail ) {
		    CopyMemory( pbStart, Buffer, dwLine );
		    *(pbStart+dwLine) = '\r';
		    *(pbStart+dwLine+1) = '\n';
		    dwBufferAvail -= (dwLine + 2*sizeof(CHAR));
		    pbStart += (dwLine + 2*sizeof(CHAR));
		    cbCallstack +=( dwLine + 2*sizeof(CHAR));
		} else {
		    break;
		}
	}

	//
	// Add an extra \r\n at the end
	//

	*(pbCallstack + cbCallstack) = '\r';
	*(pbCallstack + cbCallstack + 1) = '\n';
	cbCallstack += 2;

	//
	// Dump it to the log file as well, if we do have a log file
	//

	if ( INVALID_HANDLE_VALUE != g_hRandFailFile &&
	    INVALID_HANDLE_VALUE != g_hRandFailMutex ) {

	    WaitForSingleObject (g_hRandFailMutex, INFINITE);

	    DWORD dwOffset = SetFilePointer( g_hRandFailFile, 0, 0, FILE_END );

        //
        // if the file is too big then we need to truncate it
        //
        if (dwOffset > dwMaxFileSize)
        {
            SetFilePointer(g_hRandFailFile, 0, 0, FILE_BEGIN);
            SetEndOfFile(g_hRandFailFile);
        }
try_again:
        BOOL b = WriteFile(
	            g_hRandFailFile,
	            pbCallstack,
	            cbCallstack,
	            &dwBytesWritten,
	            NULL );

        if ( b == FALSE || dwBytesWritten != cbCallstack )
        {
            DWORD   dwError = GetLastError();

            if( dwError && fRetry )
            {
                fRetry = FALSE;
                Sleep( 100 );
                goto try_again;
            }
            INT_TRACE( "Error writing to file: %d, number of bytes %d:%d\n",
                        dwError,
                        cbCallstack,
                        dwBytesWritten );
        }

        ReleaseMutex(g_hRandFailMutex);

    }

}

//
// See if it's time for this API to fail
//
// Note:  This routine was renamed from fTimeToFail to g_TestTrace
// to hide the symbol from someone dumping the dll
//

extern "C" __declspec(dllexport)
int
__stdcall
g_TestTrace(void) {
/*++

Routine Description:

	Check to see if it's time for an instrumented API to fail.

	Note:  This routine was renamed from fTimeToFail to g_TestTrace
	to hide the symbol from someone dumping the dll

Arguments:

	None

Return Value:

    true if it's time for us to fail, false if not or we're disabled.

--*/
    LONG    l;

	// Never fail?
	if (nFailRate == kDontFail)
		return 0;

	// Have failures been suspended?
	if (dwRandFailTlsIndex != 0xffffffff &&
	    TlsGetValue (dwRandFailTlsIndex) != NULL)
		return 0;

	// This is good enough for now..
	l = InterlockedIncrement(&s_nCount) % nFailRate;

	if ( l == 0 ) {

	    // We are going to fail
	    if ( g_ppchCallStack ) {
	        LONG i = 0;
	        const DWORD   dwMaxCallStack = 20;
	        DWORD   dwCallStackBuffer = g_dwMaxCallStack;
	        DWORD_PTR   rgdwCaller[dwMaxCallStack];

	        i = InterlockedIncrement( &g_iCallStack );
	        if ( i <= g_cCallStack ) {
	            i--;
	            if ( g_ppchCallStack[i] ) {
                    ZeroMemory( rgdwCaller, sizeof(DWORD_PTR)*dwMaxCallStack );
                    ExchmemGetCallStack(rgdwCaller, dwMaxCallStack);
                    DumpCallStack( rgdwCaller, dwMaxCallStack, (PBYTE)g_ppchCallStack[i], dwCallStackBuffer );
                }
            } else {
                InterlockedExchange( &g_iCallStack, g_cCallStack );
            }
        }

        return TRUE;
    } else
        return FALSE;
}

extern "C" __declspec(dllexport)
void
__stdcall
g_TestTraceDisable(void) {
/*++

Routine Description:

	Function to temporarily suspend g_TestTrace's ability to return a
	failure.  This is used when you want to call one of the instrumented
	APIs that you don't want to fail.  This function is nestable up to
	128(abitrary) levels deep.

Arguments:

	None

Return Value:

	None

--*/

	if (dwRandFailTlsIndex == 0xffffffff)
		return;

	SIZE_T OldValue = (SIZE_T)TlsGetValue(dwRandFailTlsIndex);
	ASSERT (OldValue <= 128);
	TlsSetValue(dwRandFailTlsIndex, (LPVOID)(OldValue+1));
}


extern "C" __declspec(dllexport)
void
__stdcall
g_TestTraceEnable(void) {
/*++

Routine Description:

	Resume g_TestTrace's normal functionality if the nesting level has
	returned to zero.

Arguments:

	None

Return Value:

	None

--*/
	if (dwRandFailTlsIndex == 0xffffffff)
		return;

	SIZE_T OldValue = (SIZE_T)TlsGetValue(dwRandFailTlsIndex);
	ASSERT (OldValue > 0 && OldValue <= 128);
	TlsSetValue(dwRandFailTlsIndex, (LPVOID)(OldValue-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\trace\traceint.h ===
//
// TRACEINT.H
//
// Async tracing internal include file
//

#include "dbgtrace.h"
#include "dbgfile.h"

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif

#ifndef ASSERT
#define ASSERT( x )     (x) ? 1 : DebugBreak()
#endif

#define MAX_BUFFER_SIZE         200
#define MAX_FILENAME_SIZE       16
#define MAX_FUNCTNAME_SIZE      32

#define TRACE_SIGNATURE         (DWORD)'carT'

//
// +2 == potential CR+LF
//
#define MAX_VARIABLE_SIZE       (MAX_FILENAME_SIZE + MAX_FUNCTNAME_SIZE + MAX_BUFFER_SIZE)
#define MAX_TRACE_ENTRY_SIZE (sizeof(FIXEDTRACE) + MAX_VARIABLE_SIZE)

typedef struct tagSPECIALBUF
{
        DWORD   dwSignature;
        struct tagTRACEBUF *pNext;
} SPECIALBUF, * LPSPECIALBUF;


typedef struct tagTRACEBUF
{
        DWORD           dwSignature;
        struct tagTRACEBUF *pNext;
        DWORD           dwLastError;

        //
        // fixed buffer committed to permanent storage ( ie disk )
        //
#pragma pack(2)

        FIXEDTRACE      Fixed;
        char            Buffer[MAX_VARIABLE_SIZE];

#pragma pack()

} TRACEBUF, * LPTRACEBUF;

#define MAX_WRITE_BUFFER_SIZE   16*1024

typedef struct tagPENDQ
{
        LPTRACEBUF      pHead;
        LPTRACEBUF      pTail;
        SPECIALBUF      Special;
        HANDLE          hEvent;
        HANDLE          hFlushEvent;
        HANDLE          hFlushedEvent;
        DWORD           dwCount;
        DWORD           dwThresholdCount;
        DWORD           dwProcessId;
        BOOL            fShutdown;
        HANDLE          hWriteThread;
        HANDLE          hRegNotifyThread;
        HANDLE          hFile;
        CRITICAL_SECTION critSecTail;
        HANDLE          hFileMutex;
        DWORD           cbBufferEnd;
        char            Buffer[MAX_WRITE_BUFFER_SIZE];
} PENDQ, * LPPENDQ;



//
// Internal Function declarations
//

extern BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement );
extern void WINAPI TermTraceBuffers( void );
extern LPTRACEBUF WINAPI GetTraceBuffer( void );
extern void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf );

extern LPTRACEBUF DequeueAsyncTraceBuffer( void );
extern void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf );
extern DWORD WriteTraceThread( LPDWORD lpdw );
extern BOOL WriteTraceBuffer( LPTRACEBUF lpBuf );
extern BOOL AsyncTraceCleanup( void );

extern BOOL GetTraceFlagsFromRegistry( void );
extern DWORD RegNotifyThread( LPDWORD lpdw );
extern BOOL ShouldLogModule( LPCSTR szModule );



extern  PENDQ   PendQ;
extern  BOOL    fInitialized;
extern  HANDLE  hShutdownEvent;
extern  DWORD   dwNumTraces;
extern  DWORD   dwTraceOutputType;
extern  DWORD   dwAsyncTraceFlag;
extern  int     nAsyncThreadPriority;
extern  DWORD   dwMaxFileSize;
extern  DWORD   dwIncrementSize;

#define MODULES_BUFFER_SIZE     2048
extern  CHAR    mszModules[];

#define DEFAULT_MAX_FILE_SIZE 1024*1024*5      // 5 megabytes
#define AVERAGE_TRACE_SIZE      ( sizeof(FIXEDTRACE) + 64 )

extern  CRITICAL_SECTION critSecWrite;

#ifdef  TRACE_ENABLED

extern void CDECL InternalTrace( const char *s, ... );

        #define INT_TRACE               InternalTrace

#else

__inline void CDECL InternalTrace( const char *s, ... ) {}

        #define INT_TRACE       1 ? (void)0 : InternalTrace

#endif


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\vroot\src\stdinc.h ===
#ifndef __STDINC_H__
#define __STDINC_H__

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
#include <dbgtrace.h>
#include <ole2.h>
#include <coguid.h>
#include <cguid.h>

#ifdef __VRTABLE_CPP__
#include <initguid.h>
#endif

#define _ASSERTE _ASSERT
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <stdio.h>
#include <iadmw.h>
#include <listmacr.h>

#include <rw.h>
#include <vroot.h>
#include "mbchange.h"

#include <xmemwrpr.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\vroot\src\mbchange.h ===
#ifndef __MBCHANGE_H__
#define __MBCHANGE_H__

//
// Metabase change notification code.  This was borrowed from SEO.
//

typedef void (*PFNMB_CHANGE_NOTIFY)(void *pContext,
									DWORD cChangeList,
									MD_CHANGE_OBJECT_W pcoChangeList[]);

/////////////////////////////////////////////////////////////////////////////
// CChangeNotify

class CMBChangeListData {
	public:
		CMBChangeListData(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
			m_pContext = pContext;
			m_pfnNotify = pfnNotify;
			m_pNext = m_pPrev = NULL;
		}
		void *m_pContext;
		PFNMB_CHANGE_NOTIFY m_pfnNotify;
		CMBChangeListData *m_pNext;
		CMBChangeListData *m_pPrev;
};

class ATL_NO_VTABLE CChangeNotify :
	public CComObjectRoot,
	public IMSAdminBaseSinkW
{
	public:
		HRESULT FinalConstruct();
		HRESULT Initialize(IMSAdminBaseW *pMetabaseHandle);
		HRESULT AddNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify);
		HRESULT RemoveNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify);
		void Terminate(void);
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CChangeNotify);
	DECLARE_GET_CONTROLLING_UNKNOWN();
	BEGIN_COM_MAP(CChangeNotify)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_W, IMSAdminBaseSinkW)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	public:
		// IMSAdminBaseSinkW
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);
		HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

		CChangeNotify();

	private:
		CShareLockNH m_lock;
		DWORD m_dwCookie;
        IMSAdminBaseW *m_pMetabaseHandle;
		BOOL m_bConnected;
		CComPtr<IUnknown> m_pUnkMarshaler;
		TFList<CMBChangeListData> m_listNotify;
		LONG m_cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\vroot\src\vroot.cpp ===
#include "stdinc.h"
#include "iiscnfg.h"

CVRoot::~CVRoot() {
	_ASSERT(m_fInit);
	m_fInit = FALSE;
	m_cchVRootName = 0;

	_ASSERT(m_pVRootTable != NULL);
#ifdef DEBUG
	m_pVRootTable->DebugExpungeVRoot( this );
#endif
	m_pVRootTable->m_lockVRootsExist.ShareUnlock();
	m_dwSig = VROOT_BAD_SIG;
}

//
// initialize this class.
//
void CVRoot::Init(LPCSTR pszVRootName, CVRootTable *pVRootTable, LPCWSTR pwszConfigPath, BOOL fUpgrade ) {
	m_fInit = TRUE;
	m_pVRootTable = pVRootTable;
	_ASSERT(strlen(pszVRootName) < MAX_VROOT_PATH);
	lstrcpyn(m_szVRootName, pszVRootName, sizeof(m_szVRootName)/sizeof(m_szVRootName[0]) );
	m_cchVRootName = strlen(m_szVRootName);
	
	lstrcpynW(m_wszConfigPath, pwszConfigPath, sizeof(m_wszConfigPath)/sizeof(m_wszConfigPath[0]));
	// remove trailing slashes
	DWORD l = lstrlenW(m_wszConfigPath);
	if (m_wszConfigPath[l-1] == '/') m_wszConfigPath[l-1] = 0;

	m_fUpgrade = fUpgrade;

	_ASSERT(m_pVRootTable != NULL);
	m_pVRootTable->m_lockVRootsExist.ShareLock();
#ifdef DEBUG
	m_pVRootTable->DebugPushVRoot( this );
#endif
}

HRESULT CIISVRoot::GetDWord(IMSAdminBase *pMB, 
							METADATA_HANDLE hmb,
							DWORD dwId,
							DWORD *pdw) 
{
	METADATA_RECORD mdr;
	HRESULT hr;
	DWORD dwRequiredLen;

	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = DWORD_METADATA;
	mdr.dwMDDataLen = sizeof(DWORD);
	mdr.pbMDData = (BYTE *) pdw;
	mdr.dwMDDataTag = 0;

	hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
	return hr;
}

HRESULT CIISVRoot::GetString(IMSAdminBase *pMB, 
							 METADATA_HANDLE hmb,
							 DWORD dwId,
							 LPWSTR szString,
							 DWORD *pcString) 
// if success, pcString returns the number of WChars, NOT including null terminator.
{
	METADATA_RECORD mdr;
	HRESULT hr;
	DWORD dwRequiredLen;

	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = STRING_METADATA;
	mdr.dwMDDataLen = (*pcString) * sizeof(WCHAR);
	mdr.pbMDData = (BYTE *) szString;
	mdr.dwMDDataTag = 0;

	hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
	if (FAILED(hr)) *pcString = dwRequiredLen;
	else *pcString  = wcslen( szString );
	return hr;
}

//
// reads the following parameters:
//
// MD_IS_CONTENT_INDEXED -> m_fIsIndexed
// MD_ACCESS_PERM -> m_dwAccess
// MD_SSL_ACCESS_PERM -> m_dwSSL
// MD_DONT_LOG -> m_fDontLog
//
HRESULT CIISVRoot::ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb) {
	DWORD dw = 0;

	if (FAILED(GetDWord(pMB, hmb, MD_ACCESS_PERM, &m_dwAccess))) {
		m_dwAccess = 0;
	}

	if (FAILED(GetDWord(pMB, hmb, MD_SSL_ACCESS_PERM, &m_dwSSL))) {
		m_dwSSL = 0;
	}

	if (FAILED(GetDWord(pMB, hmb, MD_IS_CONTENT_INDEXED, &dw))) dw = FALSE;
	m_fIsIndexed = dw;

	if (FAILED(GetDWord(pMB, hmb, MD_DONT_LOG, &dw))) dw = FALSE;
	m_fDontLog = dw;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\api.c ===
/*
 * api.c
 *
 * Externally declared APIs
 */
#include <crtdbg.h>

#define DECLARE_DATA
#include "deflate.h"
#include "api_int.h"
#include "fasttbl.h"
#include "crc32.h"


//
// Initialise global compression 
//
HRESULT WINAPI InitCompression(VOID)
{
    deflateInit();
    return S_OK;
}


//
// De-init global compression
//
VOID WINAPI DeInitCompression(VOID)
{
}


//
// Create a compression context
//
HRESULT WINAPI CreateCompression(PVOID *context, ULONG flags)
{
    t_encoder_context *ec;

    *context = (PVOID) LocalAlloc(LMEM_FIXED, sizeof(t_encoder_context));

    if (*context == NULL)
        return E_OUTOFMEMORY;

    ec = (t_encoder_context *) (*context);

    // no encoders initialised yet
    ec->std_encoder     = NULL;
    ec->optimal_encoder = NULL;
    ec->fast_encoder    = NULL;

    if (flags & COMPRESSION_FLAG_DO_GZIP)
        ec->using_gzip      = TRUE;
    else
        ec->using_gzip      = FALSE;

    InternalResetCompression(ec);

    return S_OK;
}


//
// Destroy a compression context
//
VOID WINAPI DestroyCompression(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    _ASSERT(void_context != NULL);

    if (context->std_encoder != NULL)
        LocalFree((PVOID) context->std_encoder);

    if (context->optimal_encoder != NULL)
        LocalFree((PVOID) context->optimal_encoder);

    if (context->fast_encoder != NULL)
        LocalFree((PVOID) context->fast_encoder);

    LocalFree(void_context);
}


//
// Reset compression context
//
HRESULT WINAPI ResetCompression(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    InternalResetCompression(context);

    // This forces a realloc of the particular compressor we are using
    // each time we reset, but if we don't do this then we are stuck with one
    // compressor (fast,std,optimal) forever until we destroy the context.
    // Should create a workaround for this problem.  Luckily, IIS creates a
    // new context all the time, and doesn't call reset (so says davidtr).
    DestroyIndividualCompressors(context);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\vroot\src\mbchange.cpp ===
#include "stdinc.h"

CChangeNotify::CChangeNotify() :
	m_listNotify(&CMBChangeListData::m_pPrev, &CMBChangeListData::m_pNext)
{
}

HRESULT CChangeNotify::FinalConstruct() {
	HRESULT hr;

	m_pMetabaseHandle = NULL;
	m_bConnected = FALSE;

	hr = CoCreateFreeThreadedMarshaler(this, &m_pUnkMarshaler.p);
	_ASSERT(!SUCCEEDED(hr) || m_pUnkMarshaler);

	return hr;
}

void CChangeNotify::FinalRelease() {
	_ASSERT(m_pMetabaseHandle == NULL);
	m_pUnkMarshaler.Release();
}

HRESULT CChangeNotify::Initialize(IMSAdminBaseW *pMetabaseHandle) {
	HRESULT hr = S_OK;

	m_bConnected = FALSE;

	hr = CoCreateFreeThreadedMarshaler(this, &m_pUnkMarshaler.p);
	_ASSERT(!SUCCEEDED(hr) || m_pUnkMarshaler);

	_ASSERT(pMetabaseHandle != NULL);
	if (!pMetabaseHandle) return (E_POINTER);

	m_pMetabaseHandle = pMetabaseHandle;

	return (S_OK);
}

void CChangeNotify::Terminate(void) {
	_ASSERT(m_listNotify.IsEmpty());

	m_pMetabaseHandle = NULL;
	_ASSERT(!m_bConnected);
}

HRESULT CChangeNotify::AddNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
	HRESULT hr = S_OK;

	if (!pfnNotify) return (E_POINTER);
    if (!m_pMetabaseHandle) return (S_OK);

	CMBChangeListData *pLD = XNEW CMBChangeListData(pContext, pfnNotify);

	if (pLD == NULL) {
	    return E_OUTOFMEMORY;
	}

	m_lock.ExclusiveLock();

	m_listNotify.PushBack(pLD);

	if (!m_bConnected) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		CComQIPtr<IMSAdminBaseSinkW, &IID_IMSAdminBaseSink_W> pThis = this;

		m_bConnected = TRUE;
		_ASSERT(pThis);
        hr = m_pMetabaseHandle->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        if (SUCCEEDED(hr)) {
    		hr = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
    		_ASSERT(SUCCEEDED(hr));
    		if (SUCCEEDED(hr)) {
    			hr = pCP->Advise(this,&m_dwCookie);
    			_ASSERT(SUCCEEDED(hr));
    		}
        }
	} 

	m_lock.ExclusiveUnlock();

	return (hr);
}

HRESULT CChangeNotify::RemoveNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
	HRESULT hr;

	if (!pfnNotify) return (E_POINTER);
    if (!m_pMetabaseHandle) return (S_OK);

	m_lock.ExclusiveLock();

	for (TFList<CMBChangeListData>::Iterator it(&m_listNotify); !it.AtEnd(); it.Next()) {
		if (it.Current()->m_pContext == pContext)  {
            CMBChangeListData*  p = it.RemoveItem();
            if (p) {
                XDELETE p;
                p = NULL;
            }
        }
	}

	if (m_listNotify.IsEmpty()) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		DWORD dwCookie = m_dwCookie;

		_ASSERT(m_bConnected);
		m_bConnected = FALSE;
        hr = m_pMetabaseHandle->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        _ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
    		hr = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
    		_ASSERT(SUCCEEDED(hr));
    		if (SUCCEEDED(hr)) {
    			hr = pCP->Unadvise(dwCookie);
    			_ASSERT(SUCCEEDED(hr));
			}
		}
	} 

	m_lock.ExclusiveUnlock();

	return (S_OK);
}

HRESULT STDMETHODCALLTYPE CChangeNotify::SinkNotify(DWORD cChangeList, MD_CHANGE_OBJECT_W pcoChangeList[]) {
	_ASSERT(cChangeList && pcoChangeList);
	if (!pcoChangeList) return (E_POINTER);
	if (!cChangeList) return (S_OK);

	m_lock.ShareLock();
	if (m_listNotify.IsEmpty()) {
		m_lock.ShareUnlock();
		return (S_OK);
	}

	for (TFList<CMBChangeListData>::Iterator it(&m_listNotify); !it.AtEnd(); it.Next()) {
		PFNMB_CHANGE_NOTIFY pfnNotify = it.Current()->m_pfnNotify;
		void *pContext = it.Current()->m_pContext;

		pfnNotify(pContext, cChangeList, pcoChangeList);
	}

	m_lock.ShareUnlock();

	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::ShutdownNotify(void) {
	// tbd
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\comndata.h ===
//
// comndata.h
//
// Common to inflate and deflate
//
#ifndef _COMNDATA_H
#define _COMNDATA_H

#ifdef DECLARE_DATA

const BYTE g_CodeOrder[] = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
const BYTE g_ExtraLengthBits[] = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
const BYTE g_ExtraDistanceBits[] = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0};
const ULONG g_LengthBase[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
const ULONG g_DistanceBasePosition[] = {1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
const ULONG g_BitMask[] = {0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767};

BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a
// table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

BOOL    g_InitialisedStaticBlock = FALSE;

#else /* !DECLARE_DATA */

extern const BYTE g_CodeOrder[19];
extern const BYTE g_ExtraLengthBits[];
extern const BYTE g_ExtraDistanceBits[];
extern const ULONG g_LengthBase[];
extern const ULONG g_DistanceBasePosition[];
extern const ULONG g_BitMask[];

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BOOL     g_InitialisedStaticBlock;

#endif /* !DECLARE_DATA */

#endif /* _COMNDATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\transreg\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CMyRegKey member Members
//
//  Members:    CMyRegKey::CMyRegKey - constructor for registry key object
//              CMyRegKey::CMyRegKey - constructor for registry key object
//              CMyRegKey::CreateKey - real worker for constructors
//              CMyRegKey::~CMyRegKey - destructor for registry key object
//              CMyRegKey::Delete - delete a registry key
//              CMyRegKey::EnumValues - enumerate values of a registry key
//              CMyRegKey::EnumKeys - enumerate subkeys of a registry key
//              CMyRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//              12/09/07    Milans  Ported it over to Exchange
//
//  Notes:      see notes in registry.h
//
//----------------------------------------------------------------------------

#include    <stdlib.h>
#include    <windows.h>
#include    "registry.h"

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        HKEY hkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pszPath,
                     samDesiredAccess,
                     pszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using CMyRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CMyRegKey
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        const CMyRegKey &crkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pszPath,
                      samDesiredAccess,
                      pszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using CMyRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CMyRegKey
//              [dwErr]           -  Error code returned here.
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        const CMyRegKey  &crkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::~CMyRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CMyRegKey::~CMyRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::CreateKey (
        HKEY hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess,
        LPCSTR  pszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           (LPSTR) pszPath,    //  path to key
                           0,                  //  title index
                           (LPSTR) pszClass,   //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::OpenKey (
        HKEY    hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CMyRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR    szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               szClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        CHAR   szValueID[MAX_PATH];
        ULONG   cbValueID = sizeof(szValueID);
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        szValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CMyRegKey &)*this, szValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CMyRegKey &)*this, szValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CMyRegKey &)*this, szValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CMyRegKey &)*this, szValueID);
                break;
            }

            if (pRegVal == NULL) {
                dwRc = ERROR_OUTOFMEMORY;
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            if ((*pprvs)->aprvValue[--dwIndex]) 
                delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CMyRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR   szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;   // Error to return
    DWORD dwRc = ERROR_SUCCESS; // Error from registry APIs

    dwRc = RegQueryInfoKey(_hkThis,
                     szClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CMyRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        CHAR   szKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(szKeyName);
        CHAR   szClass[MAX_PATH];
        ULONG   cbClass = sizeof(szClass);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                szKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                szClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CMyRegKey object for the subkey
            CMyRegKey *pRegKey = (CMyRegKey *) new CMyRegKey((const CMyRegKey &)*this, szKeyName);
            if(pRegKey == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        //
        // If there was a failure in a registry API call, return that error code
        // Otherwise dwErr must have been set to a failure code (for a non-registry failure)
        //
        if(dwRc != ERROR_SUCCESS)
            dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPSTR)_cszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPSTR)_cszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CMyRegKey cregKey ( hParent,
                      lpszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                    (LPSTR) pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defctxt.h ===
/*
 * defctxt.h
 *
 * Deflate context
 */
typedef unsigned short	t_search_node;
typedef unsigned int	t_match_pos;


typedef enum
{
	STATE_NORMAL,
	STATE_OUTPUTTING_TREE_STRUCTURE,
	STATE_OUTPUTTING_BLOCK
} t_encoder_state;



struct fast_encoder;
struct optimal_encoder;
struct std_encoder;


//
// Context info common to all encoders
//
typedef struct
{
	t_encoder_state			state;

	unsigned long			outputting_block_bitbuf;
	int						outputting_block_bitcount;
	byte *					outputting_block_bufptr;
	unsigned int			outputting_block_current_literal;
	unsigned int			outputting_block_num_literals;

	long					bufpos;
	long					bufpos_end;

    // output buffer
	BYTE *					output_curpos;
	BYTE *					output_endpos;
	BYTE *					output_near_end_threshold;

	// bit buffer variables for outputting data
	unsigned long			bitbuf;
	int						bitcount;

    // varies; std/optimal encoders use the normal 32K window, while the fast
    // encoder uses a smaller window
    long                    window_size;

	struct std_encoder *	std_encoder;
	struct optimal_encoder *optimal_encoder;
    struct fast_encoder *   fast_encoder;

	BOOL					no_more_input;
	
	// have we output "bfinal=1"?
	BOOL					marked_final_block;

    // do we need to call ResetCompression() before we start compressing?
    BOOL                    fNeedToResetCompression;

    // if GZIP, have we output the GZIP header?
    BOOL                    using_gzip;
    BOOL                    gzip_fOutputGzipHeader;
    ULONG                   gzip_crc32;
    ULONG                   gzip_input_stream_size;
} t_encoder_context;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defgzip.h ===
//
// defgzip.h
//
// Gzip additions to deflate
//

// compressing
void WriteGzipHeader(t_encoder_context *context, int compression_level);
void WriteGzipFooter(t_encoder_context *context);
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count);
void EncoderInitGzipVariables(t_encoder_context *context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\vroot\src\vrtable.cpp ===
#define __VRTABLE_CPP__
#include "stdinc.h"
//#include <atlimpl.cpp>
#include "iiscnfg.h"

static CComObject<CChangeNotify> *g_pMBNotify;
static IMSAdminBase *g_pMB = NULL;				// used to access the metabase
static IMSAdminBase *g_pMBN = NULL;				// used to access the metabase
static IsValidVRoot(METADATA_HANDLE hmb, WCHAR *wszPath);

//
// helper function to do a strcpy from an ansi string to an unicode string.
//
// parameters:
//   wszUnicode - the destination unicode string
//   szAnsi - the source ansi string
//   cchMaxUnicode - the size of the wszUnicode buffer, in unicode characters
//
_inline HRESULT CopyAnsiToUnicode(LPWSTR wszUnicode,
							      LPCSTR szAnsi,
							      DWORD cchMaxUnicode = MAX_VROOT_PATH)
{
	_ASSERT(wszUnicode != NULL);
	_ASSERT(szAnsi != NULL);
	if (MultiByteToWideChar(CP_ACP,
							0,
							szAnsi,
							-1,
							wszUnicode,
							cchMaxUnicode) == 0)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	} else {
		return S_OK;
	}
}

//
// helper function to do a strcpy from an unicode string to an ansi string.
//
// parameters:
//   szAnsi - the destination ansi string
//   wszUnicode - the source unicode string
//   cchMaxUnicode - the size of the szAnsi buffer, in bytes
//
_inline HRESULT CopyUnicodeToAnsi(LPSTR szAnsi,
							      LPCWSTR wszUnicode,
							      DWORD cchMaxAnsi = MAX_VROOT_PATH)
{
	_ASSERT(wszUnicode != NULL);
	_ASSERT(szAnsi != NULL);
	if (WideCharToMultiByte(CP_ACP,
							0,
							wszUnicode,
							-1,
							szAnsi,
							cchMaxAnsi,
							NULL,
							NULL) == 0)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	} else {
		return S_OK;
	}
}

//
// initialize global variables used by the VRoot objects.  this should
// be called once by the client at startup.
//
HRESULT CVRootTable::GlobalInitialize() {
	HRESULT hr;

	// initialize COM and create the metabase object
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		return hr;
	}

	g_pMB = NULL;
	g_pMBN = NULL;
	g_pMBNotify = NULL;
	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL,
						  IID_IMSAdminBase_W, (LPVOID *) &g_pMBN);
	if (SUCCEEDED(hr)) {
		hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL,
							  IID_IMSAdminBase_W, (LPVOID *) &g_pMB);
		if (SUCCEEDED(hr)) {
			hr = CComObject<CChangeNotify>::CreateInstance(&g_pMBNotify);
			if (SUCCEEDED(hr)) {
				g_pMBNotify->AddRef();
				hr = g_pMBNotify->Initialize(g_pMBN);
			}
		}
	}
	_ASSERT(hr == S_OK);
	if (FAILED(hr)) {
		if (g_pMB) g_pMB->Release();
		if (g_pMBN) g_pMBN->Release();
		if (g_pMBNotify) g_pMBNotify->Release();
		g_pMB = NULL;
		g_pMBN = NULL;
		g_pMBNotify = NULL;
	}
	return hr;
}

//
// the opposite of GlobalInitialize.  called once by the client at shutdown.
//
void CVRootTable::GlobalShutdown() {
	// turn off MB notifications
	g_pMBNotify->Terminate();
	_ASSERT(g_pMBNotify != NULL);
	g_pMBNotify->Release();
	g_pMBNotify = NULL;

	// close the metabase
	_ASSERT(g_pMB != NULL);
	g_pMB->Release();
	g_pMB = NULL;
	_ASSERT(g_pMBN != NULL);
	g_pMBN->Release();
	g_pMBN = NULL;

	// shutdown Com
	CoUninitialize();
}

//
// our constructor.  most initialize is done by the Init method, because it
// can return error codes.
//
// parameters:
// 	pContext - the context pointer, held for the client
//  pfnCreateVRoot - a function which can create new CVRoot objects for us.
//
CVRootTable::CVRootTable(   void *pContext,
						    PFNCREATE_VROOT pfnCreateVRoot,
						    PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify) :
	m_listVRoots(&CVRoot::m_pPrev, &CVRoot::m_pNext)
{
	// pContext can be NULL if thats what the user wants
	_ASSERT(pfnCreateVRoot != NULL);
	m_pContext = pContext;
	*m_wszRootPath = 0;
	m_fInit = FALSE;
	m_fShuttingDown = FALSE;
	m_pfnCreateVRoot = pfnCreateVRoot;
	InitializeCriticalSection(&m_cs);
	m_pfnScanNotify = pfnScanNotify;
#ifdef DEBUG
    InitializeListHead( &m_DebugListHead );
#endif
}

//
// our destructor.  cleans up memory
//
CVRootTable::~CVRootTable() {
	TFList<CVRoot>::Iterator it(&m_listVRoots);
    BOOL fDidRemoveNotify = FALSE;

	// tell the world that we are shutting down
	m_fShuttingDown = TRUE;

	if (m_fInit) {
		// disable metabase notifications
		g_pMBNotify->RemoveNotify((void *)this, CVRootTable::MBChangeNotify);
        fDidRemoveNotify = TRUE;
    }

	// grab the critical section so that we can empty the list
	EnterCriticalSection(&m_cs);

	// grab the lock so that we can empty the list
	m_lock.ExclusiveLock();

	if (m_fInit) {
        if (!fDidRemoveNotify&&!g_pMBNotify) {
    		// disable metabase notifications
    		g_pMBNotify->RemoveNotify((void *)this, CVRootTable::MBChangeNotify);
            fDidRemoveNotify = TRUE;
        }

		// walk the list of vroots and remove our references to them
		it.ResetHeader( &m_listVRoots );
		while (!it.AtEnd()) {
			CVRoot *pVRoot = it.Current();
			it.RemoveItem();
			pVRoot->Release();
		}

		m_lock.ExclusiveUnlock();
	
		// wait until all of the vroots references have hit zero
		this->m_lockVRootsExist.ExclusiveLock();

#ifdef DEBUG
        _ASSERT( IsListEmpty( &m_DebugListHead ) );
#endif
		// since all of the vroot objects hold a read lock on this RW lock
		// for their lifetime, we know that they are all gone once we have
		// entered the lock.  we don't need to do anything once in this
		// lock, so we just release it.
		this->m_lockVRootsExist.ExclusiveUnlock();

		m_lock.ExclusiveLock();

		// no additional vroots should have been inserted because we still
		// held onto m_cs
		_ASSERT(m_listVRoots.IsEmpty());
	
		m_fInit = FALSE;
	}

	m_lock.ExclusiveUnlock();

	LeaveCriticalSection(&m_cs);

	DeleteCriticalSection(&m_cs);
}

//
// Initialize the VRoot objects.  This does the initial scan of the metabase
// and builds all of our CVRoot objects.  It also sets up metabase
// notifications so that we are notified of changes in the metabase.
//
// parameters:
//	pszRootPath - the metabase path where our vroot table is located
//
HRESULT CVRootTable::Initialize(LPCSTR pszRootPath, BOOL fUpgrade ) {
	HRESULT hr;

	_ASSERT(g_pMBNotify != NULL);
	if (g_pMBNotify == NULL) return E_UNEXPECTED;
	_ASSERT(g_pMB != NULL);
	if (g_pMB == NULL) return E_UNEXPECTED;
	_ASSERT(!m_fInit);
	if (m_fInit) return E_UNEXPECTED;
	_ASSERT(pszRootPath != NULL);
	if (pszRootPath == NULL) return E_POINTER;
	m_cchRootPath = strlen(pszRootPath);
	if (m_cchRootPath + 1 > MAX_VROOT_PATH || m_cchRootPath == 0) return E_INVALIDARG;

	// remember our root path
	hr = CopyAnsiToUnicode(m_wszRootPath, pszRootPath);
	if (FAILED(hr)) return hr;

	// chop off the trailing / if there is one
	if (m_wszRootPath[m_cchRootPath - 1] == '/')
		m_wszRootPath[--m_cchRootPath] = 0;

	hr = g_pMBNotify->AddNotify((void *)this,
								CVRootTable::MBChangeNotify);
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		return hr;
	}

	hr = ScanVRoots( fUpgrade );
	if (FAILED(hr)) {
		g_pMBNotify->RemoveNotify((void *)this,
								  CVRootTable::MBChangeNotify);
		_ASSERT(FALSE);
	}

	return hr;
}

//
// This function does most of the work required to build the list of
// vroots from the metabase.  It recursively walks the metabase, creating
// new vroot classes for each of the leaves found in the metabase.
//
// parameters:
//   hmbParent - the metabase handle for the parent object
//   pwszKey - the key name (relative to the parent handle) for this vroot
//   pszVRootName - the VRoot name (in group.group format) for this vroot
//   pwszConfigPath - the metabase path to the config data for this vroot
//
// Locking:
//   the critical section must be held when this is called.  it will grab
//   the exclusive lock when adding to the list of vroots.
//
HRESULT CVRootTable::ScanVRootsRecursive(METADATA_HANDLE hmbParent,
									     LPCWSTR pwszKey,
										 LPCSTR pszVRootName,
										 LPCWSTR pwszConfigPath,
										 BOOL fUpgrade )
{
	TraceFunctEnter("CVRootTable::ScanVRootsRecursive");

	_ASSERT(pwszKey != NULL);
	_ASSERT(pszVRootName != NULL);
	_ASSERT(pwszConfigPath != NULL);

	HRESULT hr;
	VROOTPTR pVRoot;

	//
	// get a metabase handle to this vroot.
	//
	METADATA_HANDLE hmbThis;
	DWORD i = 0;
	// sometimes the metabase doesn't open properly, so we'll try it multiple
	// times
	do {
		hr = g_pMB->OpenKey(hmbParent,
					 		pwszKey,
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);
	
	if (SUCCEEDED(hr)) {
		// make sure that this vroot defines the vrpath
		METADATA_RECORD mdr;
		WCHAR c;
		DWORD dwRequiredLen;
		BOOL fInsertVRoot = TRUE;

		mdr.dwMDAttributes = 0;
		mdr.dwMDIdentifier = MD_VR_PATH;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = STRING_METADATA;
		mdr.dwMDDataLen = sizeof(c);
		mdr.pbMDData = (BYTE *) &c;
		mdr.dwMDDataTag = 0;

		hr = g_pMB->GetData(hmbThis, L"", &mdr, &dwRequiredLen);

		if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
			// create and initialize a new vroot object for this vroot
			pVRoot = m_pfnCreateVRoot(m_pContext, pszVRootName, this,
									  pwszConfigPath, fUpgrade );
			if (pVRoot == NULL) {
				hr = E_OUTOFMEMORY;
			} else {
				// Insert this vroot into our list of vroots
				m_lock.ExclusiveLock();
				InsertVRoot(pVRoot);
				m_lock.ExclusiveUnlock();
				hr = S_OK;
			}
		} else {
			fInsertVRoot = FALSE;
			hr = S_OK;
		}

		if (SUCCEEDED(hr)) {
			//
			// scan across this metabase handle looking for child vroots
			//
			DWORD i;
			for (i = 0; hr == S_OK; i++) {
				WCHAR wszThisKey[ADMINDATA_MAX_NAME_LEN + 1];
		
				hr = g_pMB->EnumKeys(hmbThis, NULL, wszThisKey, i);
		
				if (hr == S_OK) {
					//
					// we found a child.
					//
					if (lstrlenW(pwszConfigPath)+1+lstrlenW(wszThisKey)+1 > MAX_VROOT_PATH) {
						//
						// the vroot path is too long, return an error.
						//
						_ASSERT(FALSE);
						hr = E_INVALIDARG;
					} else {
						WCHAR wszThisConfigPath[MAX_VROOT_PATH];
						char szThisVRootName[MAX_VROOT_PATH];
		
						// figure out the VRoot name and path to the config
						// data for this new VRoot.
						// sprintf is safe here because of the size check above
						swprintf(wszThisConfigPath, L"%s/%s",
							     pwszConfigPath, wszThisKey);
							if (*pszVRootName != 0 &&
								lstrlen(pszVRootName)+1+lstrlenW(wszThisKey)+1 <= MAX_VROOT_PATH) {
							sprintf(szThisVRootName, "%s.%S", pszVRootName,
									wszThisKey);
						} else {
							CopyUnicodeToAnsi(szThisVRootName, wszThisKey);
						}
		
						// now scan this vroot for child vroots.
						hr = ScanVRootsRecursive(hmbThis,
												 wszThisKey,
												 szThisVRootName,
												 wszThisConfigPath,
												 fUpgrade );
					}
				}
			}
			if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) hr = S_OK;
		}
		_VERIFY(SUCCEEDED(g_pMB->CloseKey(hmbThis)));
	}

	TraceFunctLeave();
	return hr;
}

//
// call the ReadParameters function on a vroot
//
HRESULT CVRootTable::InitializeVRoot(CVRoot *pVRoot) {
	HRESULT hr;
	METADATA_HANDLE hmbThis;

	DWORD i = 0;
	do {
		hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					 		pVRoot->GetConfigPath(),
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);

	if (SUCCEEDED(hr)) {
		hr = pVRoot->ReadParameters(g_pMB, hmbThis);
		_VERIFY(SUCCEEDED(g_pMB->CloseKey(hmbThis)));
	}

	return hr;
}

//
// Initialize each of the vroot objects after they have been inserted into
// the vroot table
//
HRESULT CVRootTable::InitializeVRoots() {
	TraceFunctEnter("CVRootTable::InitializeVRoots");
	
	EnterCriticalSection(&m_cs);

	TFList<CVRoot>::Iterator it(&m_listVRoots);
	HRESULT hr = S_OK;
	BOOL fInitOld = m_fInit;

	m_fInit = TRUE;

	if (m_pfnScanNotify) {
		DebugTrace((DWORD_PTR) this, "vroot table rescan, calling pfn 0x%x",
			m_pfnScanNotify);
		m_pfnScanNotify(m_pContext);
	}

	// we don't need to hold the share lock because the list can't change as
	// long as we hold the critical section.
	while (SUCCEEDED(hr) && !it.AtEnd()) {
		InitializeVRoot(it.Current());

		if (FAILED(hr)) {
			// if read parameters failed then we remove the item from the list
			// we need to grab the exclusive lock to kick any readers out of
			// the list
			m_lock.ExclusiveLock();
			it.RemoveItem();
			m_lock.ExclusiveUnlock();
		} else {
			it.Next();
		}
	}

	if (FAILED(hr)) m_fInit = fInitOld;

	LeaveCriticalSection(&m_cs);

	TraceFunctLeave();
	return hr;
}

//
// create the root vroot object, then scan the metabase for other
// vroots.
//
HRESULT CVRootTable::ScanVRoots( BOOL fUpgrade ) {
	HRESULT hr;

	EnterCriticalSection(&m_cs);

	hr = ScanVRootsRecursive(METADATA_MASTER_ROOT_HANDLE,
							 m_wszRootPath,
							 "",
							 m_wszRootPath,
							 fUpgrade );

	if (SUCCEEDED(hr)) hr = InitializeVRoots( );

	LeaveCriticalSection(&m_cs);

	return hr;
}

//
// grabs the share lock and calls FindVRootInternal
//
HRESULT CVRootTable::FindVRoot(LPCSTR pszGroup, VROOTPTR *ppVRoot) {
	HRESULT hr;

	_ASSERT(pszGroup != NULL);
	_ASSERT(ppVRoot != NULL);

	m_lock.ShareLock();
	_ASSERT(m_fInit);
	if (!m_fInit) {
		m_lock.ShareUnlock();
		return E_UNEXPECTED;
	}

	hr = FindVRootInternal(pszGroup, ppVRoot);
	m_lock.ShareUnlock();

	_ASSERT(FAILED(hr) || *ppVRoot != NULL);

	return hr;
}

//
// Find a vroot given a group name.
//
// Parameters:
//   pszGroup - the name of the group
//   ppVRoot - the vroot that best matches it
//
// The VRoot that matches is the one with these properties:
//   * strncmp(vroot, group, strlen(vroot)) == 0
//   * the vroot has the longest name that matches
//
// Locking:
//   assumes that the caller has the shared lock or exclusive lock
//
HRESULT CVRootTable::FindVRootInternal(LPCSTR pszGroup, VROOTPTR *ppVRoot) {
	_ASSERT(pszGroup != NULL);
	_ASSERT(ppVRoot != NULL);
	_ASSERT(m_fInit);
	if (!m_fInit) return E_UNEXPECTED;

	DWORD cchGroup = strlen(pszGroup);

	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
		VROOTPTR pThisVRoot(it.Current());
		DWORD cchThisVRootName;
		LPCSTR pszThisVRootName = pThisVRoot->GetVRootName(&cchThisVRootName);

		_ASSERT(pThisVRoot != NULL);

		//
		// check to see if we are at the end of the list or if we've gone
		// past the point where we can find matches.
		//
		if ((cchThisVRootName == 0) ||
		    (tolower(*pszThisVRootName) < tolower(*pszGroup)))
		{
			// everything matches the root
			*ppVRoot = m_listVRoots.GetBack();
			return S_OK;
		} else {
			//
			// this is match if this vroot has a shorter path then the group name,
			// and if the group name has a '.' at then end of the vroot name
			// (so if the group is "rec.bicycles.tech." and the vroot is "rec."
			// then this will match, but if it is "comp." then it won't), and
			// finally, if the strings match up to the length of the vroot name.
			// (so "rec." would be the vroot for "rec.bicycles.tech.", but
			// "alt." wouldn't).
			//
			if ((cchThisVRootName <= cchGroup) &&
				((pszGroup[cchThisVRootName] == '.') /*|| - Binlin - "comp" should be created under "\" instead of "\comp"
				 (pszGroup[cchThisVRootName] == 0)*/) &&
				(_strnicmp(pszThisVRootName, pszGroup, cchThisVRootName) == 0))
			{
				// we found a match
				*ppVRoot = pThisVRoot;
				return S_OK;
			}
		}
	}

	// we should always find a match
	*ppVRoot = NULL;
	return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//
// insert a new vroot into the vroot list.  this does an ordered insert.
//
// Parameters:
//   pNewVRoot - the new vroot to get inserted into the list
//
// Locking:
//   This method assumes that the caller holds the exclusive lock.
//
// Reference Counting:
//   This method assumes that the reference on the vroot was aquired by
//   the caller (presumably when the vroot was created).
//
void CVRootTable::InsertVRoot(VROOTPTR pNewVRoot) {
	_ASSERT(pNewVRoot != NULL);

	if (m_listVRoots.IsEmpty()) {
		// the first item to be pushed should be the "" vroot
		_ASSERT(*(pNewVRoot->GetVRootName()) == 0);
		m_listVRoots.PushFront(pNewVRoot);
	} else {
		if (*(pNewVRoot->GetVRootName()) == 0) {
			_ASSERT(*(m_listVRoots.GetBack()->GetVRootName()) != 0);
			m_listVRoots.PushBack(pNewVRoot);
		} else {
			for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
				VROOTPTR pVRoot(it.Current());
				
				//
				// we want records to be sorted in this order:
				// "rec.photo"
				// "rec.bicycles"
				// "rec.arts"
				// "rec"
				// "alt.binaries"
				// "alt"
				// ""
				// (ie, reverse stricmp())
				//
				int rc = _stricmp(pVRoot->GetVRootName(),
								  pNewVRoot->GetVRootName());
				if (rc < 0) {
					it.InsertBefore(pNewVRoot);
					return;
				} else if (rc > 0) {
					// keep looking
				} else {
					// we should never be inserting a vroot that we already have
					_ASSERT(FALSE);
				}
			}
			// we should always do an insert
			_ASSERT(FALSE);
		}
	}
}

//
// convert a vroot configuration path into a vroot name
//
// assumptions:
//  * pwszConfigPath is under m_wszRootPath
//  * szVRootName is at least MAX_VROOT_PATH bytes
//
void CVRootTable::ConfigPathToVRootName(LPCWSTR pwszConfigPath, LPSTR szVRootName) {
	DWORD i;

	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(szVRootName != NULL);

	_ASSERT(_wcsnicmp(pwszConfigPath, m_wszRootPath, m_cchRootPath) == 0);
	CopyUnicodeToAnsi(szVRootName, &(pwszConfigPath[m_cchRootPath + 1]));
	for (i = 0; szVRootName[i] != 0; i++) {
		if (szVRootName[i] == '/') szVRootName[i] = '.';
	}
	// remove the trailing dot if there is one
	if (i > 0) szVRootName[i - 1] = 0;
}

//
// This method is called by CChangeNotify when a metabase change occurs
//
// parameters:
//   pContext - the context we gave to CChangeNotify.  Its a this pointer for
//              a CVRootTable class.
//   cChangeList - the size of the change array
//   pcoChangeList - an array of changed items in the metabase
//
void CVRootTable::MBChangeNotify(void *pContext,
								 DWORD cChangeList,
								 MD_CHANGE_OBJECT_W pcoChangeList[])
{
	_ASSERT(pContext != NULL);


	CVRootTable *pThis = (CVRootTable *) pContext;
	DWORD i;

	if (pThis->m_fShuttingDown) return;

	for (i = 0; i < cChangeList; i++) {
		// see if anything in the change list matches our base vroot
		if (_wcsnicmp(pcoChangeList[i].pszMDPath,
					  pThis->m_wszRootPath,
					  pThis->m_cchRootPath) == 0)
		{
			// a change was found that is in our portion of the metabase.
			// figure out what type of change it is, and then call a helper
			// function to update our vroot table.

			// if the path is too long then we'll ignore it
			if (wcslen(pcoChangeList[i].pszMDPath) + 1 > MAX_VROOT_PATH) {
				_ASSERT(FALSE);
				continue;
			}

			// figure out the name for this vroot
			char szVRootName[MAX_VROOT_PATH];
			pThis->ConfigPathToVRootName(pcoChangeList[i].pszMDPath,
										 szVRootName);

			if (pThis->m_fShuttingDown) return;

			// we ignore changes to the Win32 error key because
			// they are set by the vroot
			if (pcoChangeList[i].dwMDNumDataIDs == 1 &&
			    pcoChangeList[i].pdwMDDataIDs[0] == MD_WIN32_ERROR)
            {
                return;
            }

			EnterCriticalSection(&(pThis->m_cs));

			if (pThis->m_fShuttingDown) {
				LeaveCriticalSection(&(pThis->m_cs));
				return;
			}

			switch (pcoChangeList[i].dwMDChangeType) {

//
// The current implementations of VRootAdd and VRootDelete are broken
// because they don't properly handle creating parent vroot objects or
// removing children vroot objects when entire trees are added or
// removed.  Here are explicit examples of cases that don't work.
//
// Add:
//   If there is no "alt" vroot and you create an "alt.binaries" vroot
//   then it should automatically create both the "alt.binaries" and
//   "alt" vroot objects.  The current code only creates the "alt.binaries"
//   one.
//
// Remove:
//   If there is an "alt.binaries" and an "alt" and "alt" is removed then
//   "alt.binaries" should be removed as well.  The existing code doesn't
//   automatically kill children.
//
// These operations should happen infrequently enough that doing a full
// rescan should be safe.
//
#if 0
				// a vroot was deleted
				case MD_CHANGE_TYPE_DELETE_OBJECT:
					pThis->VRootDelete(pcoChangeList[i].pszMDPath,
									   szVRootName);
					break;

				// a new vroot was added
				case MD_CHANGE_TYPE_ADD_OBJECT:
					pThis->VRootAdd(pcoChangeList[i].pszMDPath,
									szVRootName);
					break;
#endif

				// a data value was changed
				case MD_CHANGE_TYPE_SET_DATA:
				case MD_CHANGE_TYPE_DELETE_DATA:
				case MD_CHANGE_TYPE_SET_DATA | MD_CHANGE_TYPE_DELETE_DATA:
					pThis->VRootChange(pcoChangeList[i].pszMDPath,
									   szVRootName);
					break;

				// a vroot was renamed.  the pcoChangeList contains
				// the new name, but not the old, so we need to rescan
				// our entire list of vroots.
				case MD_CHANGE_TYPE_DELETE_OBJECT:
				case MD_CHANGE_TYPE_RENAME_OBJECT:
				case MD_CHANGE_TYPE_ADD_OBJECT:
				default:
					pThis->VRootRescan();
					break;
			}

			LeaveCriticalSection(&(pThis->m_cs));

		}
	}
}

//
// handles a notification that a vroot's parameters have changed.  to
// implement this we delete the vroot object and recreate it.
//
// locking: assumes critical section is held
//
void CVRootTable::VRootChange(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	TraceFunctEnter("CVRootTable::VRootChange");
	
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	// to make a change work we delete then recreate the vroot
	VRootDelete(pwszConfigPath, pszVRootName);
	VRootAdd(pwszConfigPath, pszVRootName);

	// tell the server about the change
	if (m_pfnScanNotify) {
		DebugTrace((DWORD_PTR) this, "vroot table rescan, calling pfn 0x%x",
			m_pfnScanNotify);
		m_pfnScanNotify(m_pContext);
	}

	TraceFunctLeave();
}

//
// handles a notification that there is a new vroot.
//
// locking: assumes exclusive lock is held
//
void CVRootTable::VRootAdd(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	VROOTPTR pNewVRoot;

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	//
	// get a metabase handle to this vroot.
	//
	METADATA_HANDLE hmbThis;
	HRESULT hr;
	BOOL fCloseHandle;
	DWORD i = 0;
	// sometimes the metabase doesn't open properly, so we'll try it multiple
	// times
	do {
		hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					 		pwszConfigPath,
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);

	if (SUCCEEDED(hr)) {
		fCloseHandle = TRUE;
		// make sure that this vroot defines the vrpath
		METADATA_RECORD mdr;
		WCHAR c;
		DWORD dwRequiredLen;
	
		mdr.dwMDAttributes = 0;
		mdr.dwMDIdentifier = MD_VR_PATH;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = STRING_METADATA;
		mdr.dwMDDataLen = sizeof(WCHAR);
		mdr.pbMDData = (BYTE *) &c;
		mdr.dwMDDataTag = 0;
	
		hr = g_pMB->GetData(hmbThis, L"", &mdr, &dwRequiredLen);
	}

	if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
		// create and initialize a new vroot object for this vroot
		pNewVRoot = m_pfnCreateVRoot(m_pContext, pszVRootName, this,
								     pwszConfigPath, FALSE );
	
		// insert the new vroot into the list of vroots
		_ASSERT(pNewVRoot != NULL);
		if (pNewVRoot != NULL) {
			if (SUCCEEDED(InitializeVRoot(pNewVRoot))) {
				m_lock.ExclusiveLock();
				InsertVRoot(pNewVRoot);
				m_lock.ExclusiveUnlock();
			} else {
				//_ASSERT(FALSE);
				pNewVRoot->Release();
			}
		}
	}

	if (fCloseHandle) {
		g_pMB->CloseKey(hmbThis);
	}
}
	
//
// handles a notification that a vroot has been deleted
//
// locking: assumes critical section is held
//
void CVRootTable::VRootDelete(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
		if (_stricmp(it.Current()->GetVRootName(), pszVRootName) == 0) {
			CVRoot *pVRoot = it.Current();
			m_lock.ExclusiveLock();
			it.RemoveItem();
			m_lock.ExclusiveUnlock();
			// Give derived close a chance to do any work before orphan this VRoot
			pVRoot->DispatchDropVRoot();
			pVRoot->Release();
			return;
		}
	}
}

//
// handles any other sort of notification (specifically rename).  in this
// case we aren't given all of the information necessary to just fix up
// one vroot object, so we need to recreate the entire vroot list.
//
void CVRootTable::VRootRescan(void) {
	TFList<CVRoot>::Iterator it(&m_listVRoots);
	HRESULT hr;

	m_lock.ExclusiveLock();
	// walk the list of vroots and remove our references to them
	it.ResetHeader( &m_listVRoots );
	while (!it.AtEnd()) {
		CVRoot *pVRoot = it.Current();
		it.RemoveItem();
		// Give derived close a chance to do any work before orphan this VRoot
		pVRoot->DispatchDropVRoot();
		pVRoot->Release();
	}
	m_lock.ExclusiveUnlock();

	// rescan the vroot list
	hr = ScanVRootsRecursive(METADATA_MASTER_ROOT_HANDLE,
							 m_wszRootPath,
							 "",
							 m_wszRootPath,
							 FALSE );

	_ASSERT(SUCCEEDED(hr));

	if (SUCCEEDED(hr)) hr = InitializeVRoots();

	_ASSERT(SUCCEEDED(hr));
}

//
// walk across all of the known vroots, calling a user supplied callback
// for each one.
//
// parameters:
//  pfnCallback - the function to call with the vroot
//
HRESULT CVRootTable::EnumerateVRoots(void *pEnumContext,
									 PFN_VRENUM_CALLBACK pfnCallback)
{
	if (pfnCallback == NULL) {
		_ASSERT(FALSE);
		return E_POINTER;
	}

	// lock the vroot table while we walk the list
	m_lock.ShareLock();

	if (!m_fInit) {
		m_lock.ShareUnlock();
		return E_UNEXPECTED;
	}

	// walk the list of vroots, calling the callback for each one
	
	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next())
		pfnCallback(pEnumContext, it.Current());

	// release the shared lock
	m_lock.ShareUnlock();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\api_int.h ===
/*
 * api_int.h
 *
 * Internal API function prototypes and flags
 *
 */

// flags for CreateCompression()
#define COMPRESSION_FLAG_DEFLATE    0 
#define COMPRESSION_FLAG_GZIP       1 

#define COMPRESSION_FLAG_DO_GZIP    COMPRESSION_FLAG_GZIP

// Initialise global DLL compression data
HRESULT WINAPI InitCompression(VOID);

// Free global compression data
VOID    WINAPI DeInitCompression(VOID);

// Create a new compression context
HRESULT WINAPI CreateCompression(PVOID *context, ULONG flags);

// Compress data
HRESULT WINAPI Compress(
    PVOID               context,            // compression context
    CONST BYTE *        input_buffer,       // input buffer
    LONG                input_buffer_size,  // size of input buffer
    PBYTE               output_buffer,      // output buffer
    LONG                output_buffer_size, // size of output buffer
    PLONG               input_used,         // amount of input buffer used
    PLONG               output_used,        // amount of output buffer used
    INT                 compression_level   // compression level (1...10)
);

// Reset compression state (for compressing new file)
HRESULT WINAPI ResetCompression(PVOID context);

// Destroy compression context
VOID    WINAPI DestroyCompression(PVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\common.h ===
/*
 * common.h
 *
 * Definitions common to inflate and deflate
 */
#include "types.h"

#define NUM_CHARS				256
#define MIN_MATCH				3
#define MAX_MATCH				258

// window size
#define WINDOW_SIZE				32768
#define WINDOW_MASK				32767

// ZIP block types
#define BLOCKTYPE_UNCOMPRESSED	0
#define BLOCKTYPE_FIXED			1
#define BLOCKTYPE_DYNAMIC		2

// it's 288 and not 286 because we of the two extra codes which can appear
// in a static block; same for 32 vs 30 for distances
#define MAX_LITERAL_TREE_ELEMENTS	288
#define MAX_DIST_TREE_ELEMENTS		32
	
#define END_OF_BLOCK_CODE		256
#define	NUM_PRETREE_ELEMENTS	19
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\comninit.c ===
//
// comninit.c
//
// Initialisation code common to inflate and deflate
//
#include <crtdbg.h>
#include "deflate.h"


// Called by InitCompression() (function to init global DLL data)
//
// Initialises the tree lengths of static type blocks
//
void InitStaticBlock(void)
{
    int i;

    // No real thread synchronisation problems with doing this
    if (g_InitialisedStaticBlock == FALSE)
    {
        g_InitialisedStaticBlock = TRUE;

        for (i = 0; i <= 143; i++)
            g_StaticLiteralTreeLength[i] = 8;

        for (i = 144; i <= 255; i++)
            g_StaticLiteralTreeLength[i] = 9;

        for (i = 256; i <= 279; i++)
            g_StaticLiteralTreeLength[i] = 7;

        for (i = 280; i <= 287; i++)
            g_StaticLiteralTreeLength[i] = 8;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\crc32.h ===
//
// crc32.h
//
// CRC32 table
//
#ifdef DECLARE_DATA
const ULONG g_CrcTable[256] = {
  0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
  0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
  0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
  0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
  0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
  0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
  0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
  0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
  0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
  0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
  0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
  0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
  0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
  0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
  0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
  0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
  0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
  0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
  0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
  0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
  0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
  0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
  0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
  0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
  0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
  0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
  0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
  0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
  0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
  0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
  0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
  0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
  0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
  0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
  0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
  0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
  0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
  0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
  0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
  0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
  0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
  0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
  0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
  0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
  0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
  0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
  0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
  0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
  0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
  0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
  0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
  0x2d02ef8dL
};
#else /* !DECLARE_DATA */
extern const ULONG g_CrcTable[256];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defproto.h ===
//
// defproto.h
//
// Function prototypes

// comninit.c
void InitStaticBlock(void);

// definit.c
VOID deflateInit(VOID);

VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
);

// output.c
void outputBits(t_encoder_context *context, int n, int x);
void flushOutputBitBuffer(t_encoder_context *context);
void InitBitBuffer(t_encoder_context *context);
void FlushRecordingBuffer(t_encoder_context *context);
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len);
void OutputBlock(t_encoder_context *context);

// deftree.c
void makeTree(
	int					num_elements,
	int					max_code_length,
	unsigned short *	freq,
	unsigned short *	code,
	byte *				len
);

void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code);

// optfmtch.c
int optimal_find_match(t_encoder_context *context, long BufPos);
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos);
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos);
void removeNodes(t_encoder_context *context);
void reinsertRemovedNodes(t_encoder_context *context);

// optenc.c
void OptimalEncoderDeflate(t_encoder_context *context);
void OptimalEncoderReset(t_encoder_context *context);
BOOL OptimalEncoderInit(t_encoder_context *context);
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder);

// stdenc.c
void StdEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

void StdEncoderReset(t_encoder_context *context);
BOOL StdEncoderInit(t_encoder_context *context);
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder);

// stdblock.c
BOOL StdEncoderOutputBlock(t_encoder_context *context);

// fastenc.c
BOOL FastEncoderInit(t_encoder_context *context);

void FastEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

VOID FastEncoderCreateStaticTrees(VOID);
void FastEncoderGenerateDynamicTreeEncoding(void);
void FastEncoderOutputPreamble(t_encoder_context *context);

// deflate.c
VOID DestroyIndividualCompressors(PVOID void_context);
void InternalResetCompression(t_encoder_context *context);

HRESULT WINAPI Compress(
	PVOID				void_context,
	CONST BYTE *		input_buffer,
	LONG				input_buffer_size,
	PBYTE				output_buffer,
	LONG				output_buffer_size,
	PLONG				input_used,
	PLONG				output_used,
	INT					compression_level
);

// defmisc.c
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq);

// optblock.c
BOOL OptimalEncoderOutputBlock(t_encoder_context *context);

// stddebug.c
#ifdef _DEBUG
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif

// optdebug.c
#ifdef _DEBUG
void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos);
#endif

// fstdebug.c
#ifdef _DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defdata.h ===
//
// defdata.h
//
// Data specific to deflate
//
// NOTE   Some of these USHORTs could be made into ULONGs for speed-of-access.  The disadvantage would
//        be greater memory/cache usage.  g_StaticDistanceTreeCode[] could be made into a BYTE array,
//        since the codes are 5 bits.  Changes of this nature will require various code changes elsewhere.
//
#ifdef DECLARE_DATA

// lookup tables for finding the slot number of a match length or distance
BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

// literal codes for static blocks
BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// distance codes for static blocks
// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

// cached tree structure output for fast encoder
BYTE    g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
int     g_FastEncoderTreeLength; // # bytes in g_FastEncoderTreeStructureData
ULONG   g_FastEncoderPostTreeBitbuf; // final value of bitbuf
int     g_FastEncoderPostTreeBitcount; // final value of bitcount

#else /* !DECLARE_DATA */

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BYTE     g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
extern int      g_FastEncoderTreeLength;
extern ULONG    g_FastEncoderPostTreeBitbuf;
extern int      g_FastEncoderPostTreeBitcount;

#endif /* !DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deflate.c ===
/*
 * deflate.c
 *
 * Main compression entrypoint for all three encoders
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"
#include "defgzip.h"


typedef struct config_s
{
   int good_length; /* reduce lazy search above this match length */
   int max_lazy;    /* do not perform lazy search above this match length */
   int nice_length; /* quit search above this match length */
   int max_chain;
} compression_config;


static const compression_config configuration_table[11] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0 },  /* store only */
/* 1 */ {4,    4,  8,    4 }, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8 },
/* 3 */ {4,    6, 32,   32 },

/* 4 */ {4,    4, 16,   16 },  /* lazy matches */
/* 5 */ {8,   16, 32,   32 },
/* 6 */ {8,   16, 128, 128 },
/* 7 */ {8,   32, 128, 256 },
/* 8 */ {32, 128, 258, 1024 },
/* 9 */ {32, 258, 258, 4096 },
/* 10 */ {32, 258, 258, 4096 } /* maximum compression */
};


//
// Destroy the std encoder, optimal encoder, and fast encoder, but leave the
// compressor context around
//
VOID DestroyIndividualCompressors(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    if (context->std_encoder != NULL)
    {
        LocalFree((PVOID) context->std_encoder);
        context->std_encoder = NULL;
    }

    if (context->optimal_encoder != NULL)
    {
        LocalFree((PVOID) context->optimal_encoder);
        context->optimal_encoder = NULL;
    }

    if (context->fast_encoder != NULL)
    {
        LocalFree((PVOID) context->fast_encoder);
        context->fast_encoder = NULL;
    }
}


//
// Mark the final block in the compressed data
//
// There must be one final block with bfinal=1 indicating that it is the last one.  In the case of
// the fast encoder we just need to output the end of block code, since the fast encoder just outputs
// one very long block.
//
// In the case of the standard and optimal encoders we have already finished outputting blocks,
// so we output a new block (a static/fixed block) with bfinal=1, consisting merely of the
// end of block code.
//
static void markFinalBlock(t_encoder_context *context)
{
    if (context->fast_encoder != NULL)
    {
        // The fast encoder outputs one long block, so it just needs to terminate this block
        outputBits(
            context,
            g_FastEncoderLiteralTreeLength[END_OF_BLOCK_CODE],
            g_FastEncoderLiteralTreeCode[END_OF_BLOCK_CODE]
        );
    }
    else
    {
        // To finish, output a static block consisting of a single end of block code

        // Combined these three outputBits() calls (commented out) into one call
        // The total number of bits output in one shot must be <= 16, but we're ok
        // since the the length of END_OF_BLOCK_CODE is 7 for a static (fixed) block
#if 0
        outputBits(context, 1, 1); // bfinal = 1
        outputBits(context, 2, BLOCKTYPE_FIXED);
        outputBits(context, g_StaticLiteralTreeLength[END_OF_BLOCK_CODE], g_StaticLiteralTreeCode[END_OF_BLOCK_CODE]);
#endif

        // note: g_StaticLiteralTreeCode[END_OF_BLOCK_CODE] == 0x0000
        outputBits(
            context,
            (7 + 3), // StaticLiteralTreeLength[END_OF_BLOCK_CODE]=7, + 1 bfinal bit + 2 blocktype bits
            ((0x0000) << 3) | (BLOCKTYPE_FIXED << 1) | 1
        );
    }

    // flush bits from bit buffer to output buffer
    flushOutputBitBuffer(context);

    if (context->using_gzip)
        WriteGzipFooter(context);
}


//
// Returns a pointer to the start of the window of the currently active compressor
//
// Used for memcpy'ing window data when we reach the end of the window
//
static BYTE *GetEncoderWindow(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL || context->fast_encoder != NULL);

    if (context->std_encoder != NULL)
        return context->std_encoder->window;
    else if (context->optimal_encoder != NULL)
        return context->optimal_encoder->window;
    else
        return context->fast_encoder->window;
}


//
// This function does the actual work of resetting the compression state.
// However, it does not free the std/fast/optimal encoder memory (something
// that the external ResetCompression() API currently does).
//
void InternalResetCompression(t_encoder_context *context)
{
    context->no_more_input      = FALSE;
    context->marked_final_block = FALSE;
    context->state              = STATE_NORMAL;
    context->outputting_block_num_literals = 0;

    if (context->using_gzip)
        EncoderInitGzipVariables(context);

    InitBitBuffer(context);
}


//
// The compress API
//
HRESULT WINAPI Compress(
    PVOID                void_context,
    CONST BYTE *        input_buffer,
    LONG                input_buffer_size,
    PBYTE                output_buffer,
    LONG                output_buffer_size,
    PLONG                input_used,
    PLONG                output_used,
    INT                    compression_level
)
{
    int                    lazy_match_threshold = 0;
    int                 search_depth = 0;
    int                 good_length = 0;
    int                 nice_length = 0;
    t_encoder_context * context = (t_encoder_context *) void_context;
    t_std_encoder *     std_encoder;
    t_optimal_encoder * optimal_encoder;
    t_fast_encoder *    fast_encoder;
    HRESULT             result = S_OK; // default to success

    *input_used = 0;
    *output_used = 0;

    // validate compression level
    if (compression_level < 0 || compression_level > 10)
    {
        result = E_INVALIDARG;
        goto exit;
    }

    context->output_curpos                = output_buffer;
    context->output_endpos                = output_buffer + output_buffer_size;
    context->output_near_end_threshold    = output_buffer + output_buffer_size - 16;

    //
    // Have we allocated the particular compressor we want yet?
    //
    if (context->std_encoder == NULL && context->optimal_encoder == NULL && context->fast_encoder == NULL)
    {
        // No
        if (compression_level <= 3) // fast encoder
        {
            if (FastEncoderInit(context) == FALSE)
            {
                result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else if (compression_level == 10) // optimal encoder
        {
            if (OptimalEncoderInit(context) == FALSE)
            {
                result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
            if (StdEncoderInit(context) == FALSE)
            {
                result = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    std_encoder     = context->std_encoder;
    optimal_encoder = context->optimal_encoder;
    fast_encoder    = context->fast_encoder;

    _ASSERT(std_encoder != NULL || optimal_encoder != NULL || fast_encoder != NULL);

    // set search depth
    if (fast_encoder != NULL)
    {
        search_depth = configuration_table[compression_level].max_chain;
        good_length = configuration_table[compression_level].good_length;
        nice_length = configuration_table[compression_level].nice_length;
        lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }
    else if (std_encoder != NULL)
    {
        search_depth = configuration_table[compression_level].max_chain;
        good_length = configuration_table[compression_level].good_length;
        nice_length = configuration_table[compression_level].nice_length;
        lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }

    // the output buffer must be large enough to contain an entire tree
    if (output_buffer_size < MAX_TREE_DATA_SIZE)
    {
        result = E_INVALIDARG;
        goto exit;
    }

    if (context->using_gzip && context->gzip_fOutputGzipHeader == FALSE)
    {
        // Write the GZIP header
        WriteGzipHeader(context, compression_level);
        context->gzip_fOutputGzipHeader = TRUE;
    }

    //
    // Check if previously we were in the middle of outputting a block
    //
    if (context->state != STATE_NORMAL)
    {
        // The fast encoder is a special case; it doesn't use OutputBlock()
        if (fast_encoder != NULL)
            goto start_encoding;

        // yes we were, so continue outputting it
        OutputBlock(context);

        //
        // Check if we're still outputting a block (it may be a long block that
        // has filled up the output buffer again)
        //
        // If we're coming close to the end of the buffer, and may not have enough space to
        // output a full tree structure, stop now.
        //
        if (context->state != STATE_NORMAL ||
            context->output_endpos - context->output_curpos < MAX_TREE_DATA_SIZE)
        {
            *output_used = (LONG)(context->output_curpos - output_buffer);
            goto set_output_used_then_exit; // success
        }

        //
        // We finished outputting the previous block, so time to compress some more input
        //
    }

#ifdef _DEBUG
    // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
    if (fast_encoder == NULL)
        _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

    //
    // input_buffer_size == 0 means "this is the final block"
    //
    // Of course, the client may still need to call Compress() many more times if the output
    // buffer is small and there is a big block waiting to be sent.
    //
    // We may even have some pending input data in our buffer waiting to be compressed.
    //
    if ((input_buffer_size == 0 || context->no_more_input) && context->bufpos >= context->bufpos_end)
    {
        // if we're ever passed zero bytes of input, it means that there will never be any
        // more input
        context->no_more_input = TRUE;

        // output existing block
        // this never happens for the fast encoder, since we don't record blocks
           if (context->outputting_block_num_literals != 0)
        {
            FlushRecordingBuffer(context);
            OutputBlock(context);

            //
            // Still outputting a block?
               //
            if (context->state != STATE_NORMAL)
                goto set_output_used_then_exit; // success
        }

        // for the fast encoder only, we won't have output our fast encoder preamble if the
        // file size == 0, so output it now if we haven't already.
        if (fast_encoder != NULL)
        {
            if (fast_encoder->fOutputBlockHeader == FALSE)
            {
                fast_encoder->fOutputBlockHeader = TRUE;
                FastEncoderOutputPreamble(context);
            }
        }

        // if we've already marked the final block, don't do it again
        if (context->marked_final_block)
        {
            result = S_FALSE;
            goto set_output_used_then_exit; // should be zero output used
        }

        // ensure there is enough space to output the final block (max 8 bytes)
        if (context->output_curpos + 8 >= context->output_endpos)
            goto set_output_used_then_exit; // not enough space - do it next time

        // output the final block (of length zero - we just want the bfinal=1 marker)
        markFinalBlock(context);
        context->marked_final_block = TRUE;

        result = S_FALSE;
        goto set_output_used_then_exit;
    }

    // while there is more input data (passed in as parameters) or existing data in
    // the window to compress
start_encoding:
    while ((input_buffer_size > 0) || (context->bufpos < context->bufpos_end))
    {
        long amount_to_compress;
        long window_space_available;

        _ASSERT(context->bufpos >= context->window_size && context->bufpos < (2*context->window_size));

#ifdef _DEBUG
        // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
        if (fast_encoder == NULL)
            _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

        // read more input data into the window if there is space available
        window_space_available = (2*context->window_size) - context->bufpos_end;

        amount_to_compress = (input_buffer_size < window_space_available) ? input_buffer_size : window_space_available;

        if (amount_to_compress > 0)
        {
            *input_used += amount_to_compress;

            // copy data into history window
            if (context->using_gzip)
            {
                // In addition to copying data into the history window, GZIP wants a crc32 of the input data.
                // We will do both of these things at the same time for the purposes of data locality,
                // performance etc.
                GzipCRCmemcpy(context, GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }
            else
            {
                // Copy data into history window
                memcpy(GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }

            input_buffer        += amount_to_compress;
            input_buffer_size    -= amount_to_compress;

            // last input location
            context->bufpos_end += amount_to_compress;
        }

        if (optimal_encoder != NULL)
            OptimalEncoderDeflate(context);
        else if (std_encoder != NULL)
            StdEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);
        else if (fast_encoder != NULL)
            FastEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);

        // either we reached the end of the buffer, or we had to output a block and ran out
        // of output space midway
        _ASSERT(context->bufpos == context->bufpos_end || context->state != STATE_NORMAL);

        // if we ran out of output space, break now
        if (context->state != STATE_NORMAL)
            break;

        // another check for running out of output space
        if (fast_encoder == NULL && context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE)
            break;

    } /* end ... while (input_buffer_size > 0) */

set_output_used_then_exit:
    *output_used = (LONG)(context->output_curpos - output_buffer);

exit:
    _ASSERT(*output_used < output_buffer_size); // make sure we didn't overflow the output buffer
    _ASSERT(context->bufpos >= context->window_size && context->bufpos <= 2*context->window_size); // make sure bufpos is sane

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deflate.h ===
//
// deflate.h
//

// common to inflate and deflate
#include "common.h"


// ZIP constants
#define NUM_LENGTH_BASE_CODES		29
#define NUM_DIST_BASE_CODES			30

#define NUM_PRETREE_ELEMENTS		19


//
// For std and optimal encoders, recording buffer encoding max bit lengths and
// decoding table sizes
//
#define REC_LITERALS_DECODING_TABLE_BITS 12
#define REC_DISTANCES_DECODING_TABLE_BITS 8

#define REC_LITERALS_DECODING_TABLE_SIZE (1 << REC_LITERALS_DECODING_TABLE_BITS)
#define REC_LITERALS_DECODING_TABLE_MASK (REC_LITERALS_DECODING_TABLE_SIZE-1)

#define REC_DISTANCES_DECODING_TABLE_SIZE (1 << REC_DISTANCES_DECODING_TABLE_BITS)
#define REC_DISTANCES_DECODING_TABLE_MASK (REC_DISTANCES_DECODING_TABLE_SIZE-1)

//
// The maximum code lengths to allow for recording (we don't want really large
// 15 bit codes, just in case uncommon chars suddenly become common due to a change
// in the data).
//
#define RECORDING_DIST_MAX_CODE_LEN	9
#define RECORDING_LIT_MAX_CODE_LEN	13


//
// Max size of tree output (in bytes)
//
// We require that the output buffer have at least this much data available, so that we can
// output the tree in one chunk
//
#define MAX_TREE_DATA_SIZE			512


//
// Return the position slot (0...29) of a match offset (0...32767)
//
#define POS_SLOT(pos) g_DistLookup[((pos) < 256) ? (pos) : (256 + ((pos) >> 7))]


// context structure
#include "defctxt.h"

// encoders
#include "stdenc.h"
#include "optenc.h"
#include "fastenc.h"

// prototypes
#include "defproto.h"

// variables
#include "defdata.h"
#include "comndata.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\definit.c ===
//
// definit.c
//
// Initialisation code for deflate (compression stage)
//
// Includes both some one-time init routines, as well as a per context/reset init routine
//
#include "types.h"
#include "deflate.h"
#include "defproto.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// This function is called by the standard and optimal encoders, and creates the initial tree
// used to record literals for the first block.  After the first block we use the last block's
// trees to record data.
//
// This function does not change global data, and is called one a per context creation/reset.
//
VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
)
{
    // These frequencies were taken from running on some text file, better stats could
    // be obtained from using an html page.  This barely affects compression though; bad estimates
    // will just make the recording buffer fill up a little bit sooner, making us output a block
    // a little sooner, which isn't always a bad thing anyway.
	USHORT	recording_dist_tree_freq[MAX_DIST_TREE_ELEMENTS*2] = 
	{
		2,2,3,4,3,7,16,22,42,60,100,80,149,158,223,200,380,324,537,
		477,831,752,1231,999,1369,1100,2034,1667,2599,2216,0,0
	};

	USHORT	recording_literal_tree_freq[MAX_LITERAL_TREE_ELEMENTS*2];

    int i;

	makeTree(
		MAX_DIST_TREE_ELEMENTS, 
		RECORDING_DIST_MAX_CODE_LEN, 
		recording_dist_tree_freq, 
		recording_dist_code, 
		recording_dist_len
	);

    // NOTE - Put a better estimation in here!  This assumes all literals (chars and matches)
    // are equally likely, which they aren't (although all chars might be fairly equal for a
    // binary file).
	for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
		recording_literal_tree_freq[i] = 1;

	makeTree(
		MAX_LITERAL_TREE_ELEMENTS, 
		RECORDING_LIT_MAX_CODE_LEN, 
		recording_literal_tree_freq, 
		recording_literal_code, 
		recording_literal_len
	);
}


//
// One-time init
//
// Generate the global slot tables which allow us to convert a distance
// (0..32K) to a distance slot (0..29), and a length (3..258) to
// a length slot (0...28)
//
static void GenerateSlotTables(void)
{
	int code, length, dist, n;

        /* Initialize the mapping length (0..255) -> length code (0..28) */
	length = 0;
	
	for (code = 0; code < NUM_LENGTH_BASE_CODES-1; code++)
	{
		for (n = 0; n < (1 << g_ExtraLengthBits[code]); n++) 
			g_LengthLookup[length++] = (byte) code;
	}

	g_LengthLookup[length-1] = (byte) code;
    _ASSERT((length-1) < sizeof(g_LengthLookup)/sizeof(g_LengthLookup[0]));

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	dist = 0;
    
	for (code = 0 ; code < 16; code++)
	{
		for (n = 0; n < (1 << g_ExtraDistanceBits[code]); n++)
			g_DistLookup[dist++] = (byte) code;
	}

	dist >>= 7; /* from now on, all distances are divided by 128 */
    
	for ( ; code < NUM_DIST_BASE_CODES; code++) 
	{
		for (n = 0; n < (1 << (g_ExtraDistanceBits[code]-7)); n++) 
			g_DistLookup[256 + dist++] = (byte) code;
	}

    // ensure we didn't overflow the array
    _ASSERT(256 + dist <= sizeof(g_DistLookup)/sizeof(g_DistLookup[0]));
}


//
// One-time init
//
// Generate tables for encoding static blocks
//
static void GenerateStaticEncodingTables(void)
{
    int     i;
    int     len_cnt[17];
    BYTE    StaticDistanceTreeLength[MAX_DIST_TREE_ELEMENTS];

    // ensure we have already created the StaticLiteralTreeLength array
    // if we haven't, then this value would be zero
    _ASSERT(g_StaticLiteralTreeLength[0] != 0);

    //
    // Make literal tree
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    // length count (how many length 8's, 9's, etc. there are) - needed to call makeCode()
    len_cnt[8] = 144;
    len_cnt[9] = 255-144+1;
    len_cnt[7] = 279-256+1;
    len_cnt[8] += (287-280)+1;

    makeCode(
        MAX_LITERAL_TREE_ELEMENTS, 
        len_cnt, 
        g_StaticLiteralTreeLength,
        g_StaticLiteralTreeCode
    );

    //
    // Make distance tree; there are 32 5-bit codes
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    len_cnt[5] = 32;

    // We don't store StaticDistanceTreeLength[] globally, since it's 5 for everything,
    // but we need it to call makeCode()
    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        StaticDistanceTreeLength[i] = 5;

    makeCode(
        MAX_DIST_TREE_ELEMENTS, 
        len_cnt, 
        StaticDistanceTreeLength,
        g_StaticDistanceTreeCode
    );
}


//
// Initialise global deflate data in the DLL
//
VOID deflateInit(VOID)
{
    GenerateSlotTables();
    InitStaticBlock();
    GenerateStaticEncodingTables();

    // For the fast encoder, take the hard-coded global tree we're using (which is NOT the same as
    // a static block's tree), generate the bitwise output for outputting the structure of that
    // tree, and record that globally, so that we can do a simple memcpy() to output the tree for
    // the fast encoder, instead of calling the tree output routine all the time.  This is a nifty
    // performance optimisation.
    FastEncoderGenerateDynamicTreeEncoding();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\gentable.c ===
//
// gentable.c
//
// Generates static Huffman tables to be included in the DLL
//
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//#define GENERATE_C_CODE_TABLES

#ifdef GENERATE_C_CODE_TABLES
//
// Generates outputting tables for the fast encoder.
// 
// The other encoders do things differently; they have separate arrays for
// code[], len[], and they then have to check extra_bits[] afterwards to see
// how many (if any) low order bits to output.
//
// The fast encoder, on the other hand, is lean and mean.
//
// For a set of literal codes and lengths, generate a set of DWORDs with 
// these properties:
//
// [ code ] [ code_length ] 
//  27 bits     5 bits       
//
// Where "len" is the # bits in the code, and "code" is the FULL code to output,
// including ALL necessary g_LengthExtraBits[].
//
// The bitwise outputter cannot handle codes more than 16 bits in length, so
// if this happens (quite rare) whoever is using this table must output
// the code in two instalments.  
//
void MakeFastEncoderLiteralTable(BYTE *len, USHORT *code)
{
    ULONG outcode[(NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1))];
    int elements_to_output;
    int i;
    int match_length;

    elements_to_output = (NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1));

    // literals and end of block code are output without much fanfare
    for (i = 0; i <= NUM_CHARS; i++)
    {
        outcode[i] = len[i] | (code[i] << 5);
    }

    // match lengths are more interesting
    for (match_length = 0; match_length <= (MAX_MATCH-MIN_MATCH); match_length++)
    {
        int length_slot = g_LengthLookup[match_length];
        int extra_bits = g_ExtraLengthBits[length_slot];
        ULONG orig_code;
        int orig_len;
        ULONG tbl_code;
        int tbl_len;

        orig_code = (ULONG) code[(NUM_CHARS+1)+length_slot];
        orig_len = len[(NUM_CHARS+1)+length_slot];

        if (extra_bits == 0)
        {
            // if no extra bits, it's quite simple
            tbl_code = orig_code;
            tbl_len = orig_len;
        }
        else
        {
            // get extra bits data
            int extra_bits_data = match_length & g_BitMask[extra_bits];

            // stick it in the code and increase the code length appropriately
            tbl_code = orig_code | (extra_bits_data << orig_len);
            tbl_len = orig_len + extra_bits;
        }

        _ASSERT(tbl_len <= 27);
        outcode[(NUM_CHARS+1)+match_length] = tbl_len | (tbl_code << 5);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderLiteralCodeInfo[] = {\n");

    for (i = 0; i < elements_to_output; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderLiteralCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


//
// The distance table is slightly different; obviously we cannot have an element
// for all 8192 possible distances.  Instead we merge the code[] and len[] arrays,
// and store extra_bits[] in there.
//
// [ code ]  [ # extra_bits ] [ len ]
//  24 bits      4 bits       4 bits
//
// The code part is always < 16 bits, since we aren't merging the actual extra 
// bits with it, unlike for the literals.
//
void MakeFastEncoderDistanceTable(BYTE *len, USHORT *code)
{
    ULONG outcode[MAX_DIST_TREE_ELEMENTS];
    int i;
    int pos_slot;

    for (pos_slot = 0; pos_slot < MAX_DIST_TREE_ELEMENTS; pos_slot++)
    {
        int extra_bits = g_ExtraDistanceBits[pos_slot];
        ULONG orig_code;
        int orig_len;

        orig_code = (ULONG) code[pos_slot];
        orig_len = len[pos_slot];

        outcode[pos_slot] = orig_len | (extra_bits << 4) | (orig_code << 8);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderDistanceCodeInfo[] = {\n");

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderDistanceCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


void GenerateTable(char *table_name, int elements, BYTE *len, USHORT *code)
{
    int i;

    printf("#ifdef DECLARE_DATA\n");
    printf("const BYTE %sLength[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 16) == 0)
            printf("\n");

        printf("0x%02x,", len[i]);
    }

    printf("\n};\n");

    printf("const USHORT %sCode[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 8) == 0)
            printf("\n");

        printf("0x%04x,", code[i]);
    }

    printf("\n};\n");
    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const BYTE %sLength[];\n", table_name);
    printf("extern const USHORT %sCode[];\n", table_name);
    printf("#endif /* DECLARE_DATA */\n");

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defmisc.c ===
//
// defmisc.c
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Fix the frequency data of the provided literal and distance trees such that no
// element has a zero frequency.  We must never allow the cumulative frequency of
// either tree to be >= 65536, so we divide all of the frequencies by two to make
// sure.
//
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq)
{
    int i;

    // don't allow any zero frequency items to exist
    // also make sure we don't overflow 65535 cumulative frequency
    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
    {
        // avoid overflow
        dist_tree_freq[i] >>= 1;

        if (dist_tree_freq[i] == 0)
            dist_tree_freq[i] = 1;
    }

    for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
    {
        // avoid overflow
        literal_tree_freq[i] >>= 1;

        if (literal_tree_freq[i] == 0)
            literal_tree_freq[i] = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\maketbl.h ===
//
// maketbl.h
//
BOOL makeTable(
	int		num_elements, 
	int		table_bits, 
	const byte *code_length, 
	short *	table, 
	short *	left, 
	short *	right
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fasttbl.h ===
#ifdef DECLARE_DATA
const BYTE g_FastEncoderLiteralTreeLength[] = {
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0c,0x06,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0d,0x0e,
0x06,0x0e,0x0a,0x0c,0x0e,0x0e,0x0d,0x0a,0x08,0x09,0x0b,0x0a,0x07,0x08,0x07,0x09,
0x08,0x08,0x08,0x09,0x08,0x09,0x0a,0x09,0x08,0x09,0x09,0x08,0x09,0x0a,0x08,0x0e,
0x0e,0x08,0x09,0x08,0x09,0x08,0x09,0x0a,0x0b,0x08,0x0b,0x0e,0x09,0x0a,0x09,0x0a,
0x09,0x0c,0x09,0x09,0x09,0x0a,0x0c,0x0b,0x0e,0x0e,0x0c,0x0b,0x0e,0x0b,0x0e,0x0e,
0x0e,0x06,0x07,0x07,0x07,0x06,0x08,0x08,0x07,0x06,0x0c,0x09,0x06,0x07,0x07,0x06,
0x07,0x0d,0x06,0x06,0x06,0x07,0x08,0x08,0x09,0x08,0x0b,0x0d,0x0c,0x0d,0x0d,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0d,0x0d,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0e,0x0e,0x0e,
0x0e,0x04,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x05,0x06,0x06,0x05,0x06,0x07,
0x08,0x08,0x09,0x0a,0x09,0x0a,0x0c,0x0b,0x0c,0x0e,0x0e,0x0e,0x0c,0x0b,
};
const USHORT g_FastEncoderLiteralTreeCode[] = {
0x06bf,0x26bf,0x16bf,0x36bf,0x0ebf,0x2ebf,0x1ebf,0x3ebf,
0x01bf,0x063f,0x0009,0x21bf,0x11bf,0x31bf,0x09bf,0x29bf,
0x19bf,0x39bf,0x05bf,0x25bf,0x15bf,0x35bf,0x0dbf,0x2dbf,
0x1dbf,0x3dbf,0x03bf,0x23bf,0x13bf,0x33bf,0x00bf,0x0bbf,
0x0029,0x2bbf,0x011f,0x0e3f,0x1bbf,0x3bbf,0x10bf,0x031f,
0x005b,0x0077,0x02df,0x009f,0x0023,0x00db,0x0063,0x0177,
0x003b,0x00bb,0x007b,0x00f7,0x00fb,0x01f7,0x029f,0x000f,
0x0007,0x010f,0x008f,0x0087,0x018f,0x019f,0x0047,0x07bf,
0x27bf,0x00c7,0x004f,0x0027,0x014f,0x00a7,0x00cf,0x039f,
0x06df,0x0067,0x01df,0x17bf,0x01cf,0x005f,0x002f,0x025f,
0x012f,0x013f,0x00af,0x01af,0x006f,0x015f,0x093f,0x05df,
0x37bf,0x0fbf,0x053f,0x03df,0x2fbf,0x07df,0x1fbf,0x3fbf,
0x007f,0x0019,0x0013,0x0053,0x0033,0x0039,0x00e7,0x0017,
0x0073,0x0005,0x0d3f,0x016f,0x0025,0x000b,0x004b,0x0015,
0x002b,0x08bf,0x0035,0x000d,0x002d,0x006b,0x0097,0x0057,
0x00ef,0x00d7,0x003f,0x18bf,0x033f,0x04bf,0x14bf,0x207f,
0x107f,0x307f,0x087f,0x287f,0x187f,0x387f,0x047f,0x247f,
0x147f,0x347f,0x0c7f,0x2c7f,0x1c7f,0x3c7f,0x027f,0x227f,
0x127f,0x327f,0x0a7f,0x2a7f,0x1a7f,0x3a7f,0x067f,0x267f,
0x167f,0x367f,0x0e7f,0x2e7f,0x1e7f,0x3e7f,0x017f,0x217f,
0x117f,0x317f,0x097f,0x297f,0x197f,0x397f,0x057f,0x257f,
0x157f,0x357f,0x0d7f,0x2d7f,0x1d7f,0x3d7f,0x037f,0x237f,
0x137f,0x337f,0x0b7f,0x2b7f,0x1b7f,0x3b7f,0x077f,0x277f,
0x177f,0x377f,0x0f7f,0x2f7f,0x1f7f,0x3f7f,0x00ff,0x20ff,
0x10ff,0x30ff,0x08ff,0x28ff,0x18ff,0x38ff,0x04ff,0x24ff,
0x14ff,0x34ff,0x0cff,0x2cff,0x1cff,0x3cff,0x02ff,0x22ff,
0x12ff,0x32ff,0x0aff,0x2aff,0x1aff,0x3aff,0x06ff,0x26ff,
0x16ff,0x36ff,0x0eff,0x2eff,0x1eff,0x3eff,0x01ff,0x21ff,
0x11ff,0x31ff,0x09ff,0x29ff,0x19ff,0x39ff,0x05ff,0x25ff,
0x15ff,0x35ff,0x0dff,0x2dff,0x1dff,0x3dff,0x03ff,0x23ff,
0x13ff,0x33ff,0x0bff,0x0cbf,0x1cbf,0x02bf,0x2bff,0x12bf,
0x1bff,0x0abf,0x3bff,0x1abf,0x07ff,0x27ff,0x17ff,0x37ff,
0x0fff,0x0004,0x0000,0x000c,0x0002,0x000a,0x0006,0x0016,
0x000e,0x001e,0x0001,0x001d,0x003d,0x0011,0x0003,0x001b,
0x0037,0x00b7,0x01ef,0x035f,0x001f,0x00df,0x0b3f,0x043f,
0x073f,0x2fff,0x1fff,0x3fff,0x0f3f,0x023f,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderLiteralTreeLength[];
extern const USHORT g_FastEncoderLiteralTreeCode[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const BYTE g_FastEncoderDistanceTreeLength[] = {
0x06,0x0a,0x0b,0x0b,0x09,0x08,0x08,0x08,0x07,0x07,0x05,0x06,0x04,0x05,0x04,0x05,
0x04,0x05,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x00,0x00,
};
const USHORT g_FastEncoderDistanceTreeCode[] = {
0x000f,0x01ff,0x03ff,0x07ff,0x00ff,0x003f,0x00bf,0x007f,
0x001f,0x005f,0x000d,0x002f,0x0000,0x001d,0x0008,0x0003,
0x0004,0x0013,0x000c,0x0002,0x000a,0x0006,0x000e,0x0001,
0x0009,0x000b,0x0005,0x001b,0x0007,0x0017,0x0000,0x0001,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderDistanceTreeLength[];
extern const USHORT g_FastEncoderDistanceTreeCode[];
#endif /* DECLARE_DATA */



#ifdef DECLARE_DATA
const ULONG g_FastEncoderLiteralCodeInfo[] = {

0x0000d7ee,0x0004d7ee,0x0002d7ee,0x0006d7ee,0x0001d7ee,0x0005d7ee,0x0003d7ee,
0x0007d7ee,0x000037ee,0x0000c7ec,0x00000126,0x000437ee,0x000237ee,0x000637ee,
0x000137ee,0x000537ee,0x000337ee,0x000737ee,0x0000b7ee,0x0004b7ee,0x0002b7ee,
0x0006b7ee,0x0001b7ee,0x0005b7ee,0x0003b7ee,0x0007b7ee,0x000077ee,0x000477ee,
0x000277ee,0x000677ee,0x000017ed,0x000177ee,0x00000526,0x000577ee,0x000023ea,
0x0001c7ec,0x000377ee,0x000777ee,0x000217ed,0x000063ea,0x00000b68,0x00000ee9,
0x00005beb,0x000013ea,0x00000467,0x00001b68,0x00000c67,0x00002ee9,0x00000768,
0x00001768,0x00000f68,0x00001ee9,0x00001f68,0x00003ee9,0x000053ea,0x000001e9,
0x000000e8,0x000021e9,0x000011e9,0x000010e8,0x000031e9,0x000033ea,0x000008e8,
0x0000f7ee,0x0004f7ee,0x000018e8,0x000009e9,0x000004e8,0x000029e9,0x000014e8,
0x000019e9,0x000073ea,0x0000dbeb,0x00000ce8,0x00003beb,0x0002f7ee,0x000039e9,
0x00000bea,0x000005e9,0x00004bea,0x000025e9,0x000027ec,0x000015e9,0x000035e9,
0x00000de9,0x00002bea,0x000127ec,0x0000bbeb,0x0006f7ee,0x0001f7ee,0x0000a7ec,
0x00007beb,0x0005f7ee,0x0000fbeb,0x0003f7ee,0x0007f7ee,0x00000fee,0x00000326,
0x00000267,0x00000a67,0x00000667,0x00000726,0x00001ce8,0x000002e8,0x00000e67,
0x000000a6,0x0001a7ec,0x00002de9,0x000004a6,0x00000167,0x00000967,0x000002a6,
0x00000567,0x000117ed,0x000006a6,0x000001a6,0x000005a6,0x00000d67,0x000012e8,
0x00000ae8,0x00001de9,0x00001ae8,0x000007eb,0x000317ed,0x000067ec,0x000097ed,
0x000297ed,0x00040fee,0x00020fee,0x00060fee,0x00010fee,0x00050fee,0x00030fee,
0x00070fee,0x00008fee,0x00048fee,0x00028fee,0x00068fee,0x00018fee,0x00058fee,
0x00038fee,0x00078fee,0x00004fee,0x00044fee,0x00024fee,0x00064fee,0x00014fee,
0x00054fee,0x00034fee,0x00074fee,0x0000cfee,0x0004cfee,0x0002cfee,0x0006cfee,
0x0001cfee,0x0005cfee,0x0003cfee,0x0007cfee,0x00002fee,0x00042fee,0x00022fee,
0x00062fee,0x00012fee,0x00052fee,0x00032fee,0x00072fee,0x0000afee,0x0004afee,
0x0002afee,0x0006afee,0x0001afee,0x0005afee,0x0003afee,0x0007afee,0x00006fee,
0x00046fee,0x00026fee,0x00066fee,0x00016fee,0x00056fee,0x00036fee,0x00076fee,
0x0000efee,0x0004efee,0x0002efee,0x0006efee,0x0001efee,0x0005efee,0x0003efee,
0x0007efee,0x00001fee,0x00041fee,0x00021fee,0x00061fee,0x00011fee,0x00051fee,
0x00031fee,0x00071fee,0x00009fee,0x00049fee,0x00029fee,0x00069fee,0x00019fee,
0x00059fee,0x00039fee,0x00079fee,0x00005fee,0x00045fee,0x00025fee,0x00065fee,
0x00015fee,0x00055fee,0x00035fee,0x00075fee,0x0000dfee,0x0004dfee,0x0002dfee,
0x0006dfee,0x0001dfee,0x0005dfee,0x0003dfee,0x0007dfee,0x00003fee,0x00043fee,
0x00023fee,0x00063fee,0x00013fee,0x00053fee,0x00033fee,0x00073fee,0x0000bfee,
0x0004bfee,0x0002bfee,0x0006bfee,0x0001bfee,0x0005bfee,0x0003bfee,0x0007bfee,
0x00007fee,0x00047fee,0x00027fee,0x00067fee,0x00017fee,0x000197ed,0x000397ed,
0x000057ed,0x00057fee,0x000257ed,0x00037fee,0x000157ed,0x00077fee,0x000357ed,
0x0000ffee,0x0004ffee,0x0002ffee,0x0006ffee,0x0001ffee,0x00000084,0x00000003,
0x00000184,0x00000044,0x00000144,0x000000c5,0x000002c5,0x000001c5,0x000003c6,
0x000007c6,0x00000026,0x00000426,0x000003a7,0x00000ba7,0x000007a7,0x00000fa7,
0x00000227,0x00000627,0x00000a27,0x00000e27,0x00000068,0x00000868,0x00001068,
0x00001868,0x00000369,0x00001369,0x00002369,0x00003369,0x000006ea,0x000026ea,
0x000046ea,0x000066ea,0x000016eb,0x000036eb,0x000056eb,0x000076eb,0x000096eb,
0x0000b6eb,0x0000d6eb,0x0000f6eb,0x00003dec,0x00007dec,0x0000bdec,0x0000fdec,
0x00013dec,0x00017dec,0x0001bdec,0x0001fdec,0x00006bed,0x0000ebed,0x00016bed,
0x0001ebed,0x00026bed,0x0002ebed,0x00036bed,0x0003ebed,0x000003ec,0x000043ec,
0x000083ec,0x0000c3ec,0x000103ec,0x000143ec,0x000183ec,0x0001c3ec,0x00001bee,
0x00009bee,0x00011bee,0x00019bee,0x00021bee,0x00029bee,0x00031bee,0x00039bee,
0x00041bee,0x00049bee,0x00051bee,0x00059bee,0x00061bee,0x00069bee,0x00071bee,
0x00079bee,0x000167f0,0x000367f0,0x000567f0,0x000767f0,0x000967f0,0x000b67f0,
0x000d67f0,0x000f67f0,0x001167f0,0x001367f0,0x001567f0,0x001767f0,0x001967f0,
0x001b67f0,0x001d67f0,0x001f67f0,0x000087ef,0x000187ef,0x000287ef,0x000387ef,
0x000487ef,0x000587ef,0x000687ef,0x000787ef,0x000887ef,0x000987ef,0x000a87ef,
0x000b87ef,0x000c87ef,0x000d87ef,0x000e87ef,0x000f87ef,0x0000e7f0,0x0002e7f0,
0x0004e7f0,0x0006e7f0,0x0008e7f0,0x000ae7f0,0x000ce7f0,0x000ee7f0,0x0010e7f0,
0x0012e7f0,0x0014e7f0,0x0016e7f0,0x0018e7f0,0x001ae7f0,0x001ce7f0,0x001ee7f0,
0x0005fff3,0x000dfff3,0x0015fff3,0x001dfff3,0x0025fff3,0x002dfff3,0x0035fff3,
0x003dfff3,0x0045fff3,0x004dfff3,0x0055fff3,0x005dfff3,0x0065fff3,0x006dfff3,
0x0075fff3,0x007dfff3,0x0085fff3,0x008dfff3,0x0095fff3,0x009dfff3,0x00a5fff3,
0x00adfff3,0x00b5fff3,0x00bdfff3,0x00c5fff3,0x00cdfff3,0x00d5fff3,0x00ddfff3,
0x00e5fff3,0x00edfff3,0x00f5fff3,0x00fdfff3,0x0003fff3,0x000bfff3,0x0013fff3,
0x001bfff3,0x0023fff3,0x002bfff3,0x0033fff3,0x003bfff3,0x0043fff3,0x004bfff3,
0x0053fff3,0x005bfff3,0x0063fff3,0x006bfff3,0x0073fff3,0x007bfff3,0x0083fff3,
0x008bfff3,0x0093fff3,0x009bfff3,0x00a3fff3,0x00abfff3,0x00b3fff3,0x00bbfff3,
0x00c3fff3,0x00cbfff3,0x00d3fff3,0x00dbfff3,0x00e3fff3,0x00ebfff3,0x00f3fff3,
0x00fbfff3,0x0007fff3,0x000ffff3,0x0017fff3,0x001ffff3,0x0027fff3,0x002ffff3,
0x0037fff3,0x003ffff3,0x0047fff3,0x004ffff3,0x0057fff3,0x005ffff3,0x0067fff3,
0x006ffff3,0x0077fff3,0x007ffff3,0x0087fff3,0x008ffff3,0x0097fff3,0x009ffff3,
0x00a7fff3,0x00affff3,0x00b7fff3,0x00bffff3,0x00c7fff3,0x00cffff3,0x00d7fff3,
0x00dffff3,0x00e7fff3,0x00effff3,0x00f7fff3,0x00fffff3,0x0001e7f1,0x0003e7f1,
0x0005e7f1,0x0007e7f1,0x0009e7f1,0x000be7f1,0x000de7f1,0x000fe7f1,0x0011e7f1,
0x0013e7f1,0x0015e7f1,0x0017e7f1,0x0019e7f1,0x001be7f1,0x001de7f1,0x001fe7f1,
0x0021e7f1,0x0023e7f1,0x0025e7f1,0x0027e7f1,0x0029e7f1,0x002be7f1,0x002de7f1,
0x002fe7f1,0x0031e7f1,0x0033e7f1,0x0035e7f1,0x0037e7f1,0x0039e7f1,0x003be7f1,
0x003de7f1,0x000047eb,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderLiteralCodeInfo[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const ULONG g_FastEncoderDistanceCodeInfo[] = {

0x00000f06,0x0001ff0a,0x0003ff0b,0x0007ff0b,0x0000ff19,0x00003f18,0x0000bf28,
0x00007f28,0x00001f37,0x00005f37,0x00000d45,0x00002f46,0x00000054,0x00001d55,
0x00000864,0x00000365,0x00000474,0x00001375,0x00000c84,0x00000284,0x00000a94,
0x00000694,0x00000ea4,0x000001a4,0x000009b4,0x00000bb5,0x000005c4,0x00001bc5,
0x000007d5,0x000017d5,0x00000000,0x00000100,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderDistanceCodeInfo[];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deftree.c ===
//
// deftree.c
//
// Tree creation for the compressor
//
#include "deflate.h"
#include <string.h>
#include <crtdbg.h>


//
// MAX_LITERAL_TREE elements is the largest number of elements that will ever be passed
// in to this routine
//
typedef struct 
{
    // Made left_right a single long array for performance reasons.  We always access them
    // one after the other, so there is no disadvantage.
    // left[] in lower 16 bits, right[] in upper 16 bits
//    short           left[2*MAX_LITERAL_TREE_ELEMENTS];
//    short           right[2*MAX_LITERAL_TREE_ELEMENTS];
    unsigned long   left_right[2*MAX_LITERAL_TREE_ELEMENTS];

    int             heap[MAX_LITERAL_TREE_ELEMENTS+1];

    int                num_elements;

    // Maximum allowable code length (7 for pre-tree, 15 for other trees)
    int                max_code_length;

    unsigned short *freq; // passed in as parameter
    unsigned short *code; // passed in as parameter
    
    unsigned short *sortptr;
    int                depth;
    int                heapsize;
    int             len_cnt[17];
} t_tree_context;



static void countLen(t_tree_context *context, int i)  /* call with i = root */
{
    if (i < context->num_elements)
    {
        // check for max code length allowed
        context->len_cnt[(context->depth < context->max_code_length) ? context->depth : context->max_code_length]++;
    }
    else
    {
        unsigned long lr_value;
        
        _ASSERT(i >= 0 && i < 2*context->num_elements);

        lr_value = context->left_right[i];

        context->depth++;
        countLen(context, lr_value & 65535); // formerly left[i]
        countLen(context, lr_value >> 16); // formerly right[i]
        context->depth--;
    }
}


static void makeLen(t_tree_context *context, int root, BYTE *len)
{
    int        k;
    int        cum;
    int        i;

    for (i = 0; i <= 16; i++)
        context->len_cnt[i] = 0;

    countLen(context, root);

    cum = 0;

    for (i = context->max_code_length; i > 0; i--)
        cum += (context->len_cnt[i] << (context->max_code_length - i));

    while (cum != (1 << context->max_code_length))
    {
        context->len_cnt[context->max_code_length]--;

        for (i = context->max_code_length-1; i > 0; i--)
        {
            if (context->len_cnt[i] != 0)
            {
                context->len_cnt[i]--;
                context->len_cnt[i+1] += 2;
                break;
            }
        }

        cum--;
    }

    for (i = 16; i > 0; i--)
    {
        k = context->len_cnt[i];

        while (--k >= 0)
            len[ *context->sortptr++ ] = (byte) i;
    }
}


/* priority queue; send i-th entry down heap */
static void downHeap(t_tree_context *context, int i)
{
    int j, k;

    _ASSERT(i >= 0 && i <= context->num_elements);
    k = context->heap[i];

    while ((j = (i<<1)) <= context->heapsize)
    {
        if (j < context->heapsize && 
            context->freq[context->heap[j]] > context->freq[context->heap[j + 1]])
             j++;

        if (context->freq[k] <= context->freq[context->heap[j]])
            break;

        context->heap[i] = context->heap[j];
        i = j;
    }

    _ASSERT(i >= 0 && i <= context->num_elements);
    context->heap[i] = k;
}


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
    unsigned int new_code = 0;

    do
    {
        new_code |= (code & 1);
        new_code <<= 1;
        code >>= 1;

    } while (--len > 0);

    return new_code >> 1;
}


void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code)
{
    int start[18];
    int i;
    
    start[1] = 0;

    for (i = 1; i <= 16; i++)
        start[i + 1] = (start[i] + len_cnt[i]) << 1;

    for (i = 0; i < num_elements; i++)
    {
        unsigned int unreversed_code;
        
        unreversed_code = start[len[i]]++;
        code[i] = (USHORT) bitReverse(unreversed_code, len[i]);
    }
}


void makeTree(
    int                    num_elements,
    int                    max_code_length,
    unsigned short *    freq,
    unsigned short *    code,
    byte *                len
)
{
    t_tree_context    tree;
    int                k;
    int                avail;
    int                i;

    _ASSERT(num_elements > 0 && num_elements <= MAX_LITERAL_TREE_ELEMENTS);

    // init tree context
    tree.depth    = 0;
    tree.freq    = freq;
    tree.code    = code;
    tree.num_elements = num_elements;
    tree.max_code_length = max_code_length;

    avail                = num_elements;
    tree.heapsize        = 0;
    tree.heap[1]        = 0;

    for (i = 0; i < tree.num_elements; i++)
    {
        len[i] = 0;

        if (tree.freq[i] != 0)
            tree.heap[++tree.heapsize] = i;
    }

    //
    // Less than 2 elements in the tree?
    //
    if (tree.heapsize < 2)
    {
        if (tree.heapsize == 0)
        {
            //
            // No elements in the tree?
            //
            // Then insert two fake elements and retry.
            //
            tree.freq[0] = 1;
            tree.freq[1] = 1;
        }    
        else
        {
            //
            // One element in the tree, so add a fake code
            //
            // If our only element is element #0 (heap[1] == 0), then
            // make element #1 have a frequency of 1.
            //
            // Else make element #0 have a frequency of 1.
            //
            if (tree.heap[1] == 0)
                tree.freq[1] = 1;
            else
                tree.freq[0] = 1;
        }

        //
        // Retry with these new frequencies
        //
        makeTree(num_elements, max_code_length, freq, code, len);
        return;
    }

    for (i = tree.heapsize >> 1; i >= 1; i--)
        downHeap(&tree, i);  /* make priority queue */

    tree.sortptr = tree.code;

    do
    {
        int j;

        /* while queue has at least two entries */
        i = tree.heap[1];  /* take out least-freq entry */

        if (i < tree.num_elements)
            *tree.sortptr++ = (short) i; 

        tree.heap[1] = tree.heap[tree.heapsize--];
        downHeap(&tree, 1);

        j = tree.heap[1];  /* next least-freq entry */

        if (j < tree.num_elements)
            *tree.sortptr++ = (short) j; 

        k = avail++;  /* generate new node */

        tree.freq[k] = tree.freq[i] + tree.freq[j];
        tree.heap[1] = k;
        downHeap(&tree, 1);  /* put into queue */

//        tree.left[k] = (short) i;
//        tree.right[k] = (short) j;

        _ASSERT(k >= 0 && k < 2*tree.num_elements);
        tree.left_right[k] = (j << 16) | i;

    } while (tree.heapsize > 1);

    tree.sortptr = tree.code;

    makeLen(&tree, k, len);
    makeCode(num_elements, tree.len_cnt, len, code);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fstdebug.c ===
/*
 * fstdebug.c
 *
 * Debugging stubs for fast encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
    int i;
    const t_search_node *lookup = context->fast_encoder->lookup;
    const t_search_node *prev = context->fast_encoder->prev;
    const BYTE *window = context->fast_encoder->window;

    for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
    {
        t_search_node where = lookup[i];
        t_search_node next_where;

        while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
        {
            int hash = FAST_ENCODER_RECALCULATE_HASH(where);

            _ASSERT(hash == i);

            next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

            if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
                break;

            _ASSERT(next_where < where);

            where = next_where;
        } 
    }
}


void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
    const t_search_node *lookup = context->fast_encoder->lookup;
    const t_search_node *prev = context->fast_encoder->prev;
    BYTE *window = context->fast_encoder->window;
    t_search_node where;
    t_search_node next_where;
    int print = 0;

top:
    where = lookup[chain_number];

    if (print)
        printf("Verify chain %d\n", chain_number);

    while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
    {
        int hash = FAST_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->fast_encoder->window;

        if (print)
            printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

        if (hash != chain_number && print == 0)
        {
            print = 1;
            goto top;
        }

        _ASSERT(hash == chain_number);

        next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

        if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
            break;

        if (next_where >= where && print == 0)
        {
            print = 1;
            goto top;
        }

        _ASSERT(next_where < where);

        where = next_where;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fastenc.h ===
/*
 * fastenc.h
 *
 * Defines for the fast encoder
 */

//
// Size of hash table for std encoder
//
#define FAST_ENCODER_HASH_TABLE_SIZE			2048
#define FAST_ENCODER_HASH_MASK					(FAST_ENCODER_HASH_TABLE_SIZE-1)
#define FAST_ENCODER_HASH_SHIFT					4

#define FAST_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*FAST_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << FAST_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & FAST_ENCODER_HASH_MASK)


// 
// Be very careful about increasing the window size; the code tables will have to
// be updated, since they assume that extra_distance_bits is never larger than a
// certain size.
//
#define FAST_ENCODER_WINDOW_SIZE            8192
#define FAST_ENCODER_WINDOW_MASK            (FAST_ENCODER_WINDOW_SIZE - 1)


//
// Don't take a match 3 further away than this
//
#define FAST_ENCODER_MATCH3_DIST_THRESHOLD 16384


typedef struct fast_encoder
{
	// history window
	BYTE 					window[2*FAST_ENCODER_WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[FAST_ENCODER_WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[FAST_ENCODER_HASH_TABLE_SIZE];

    // have we output our block header (the whole data file will be one big dynamic block)?
    BOOL                    fOutputBlockHeader;

} t_fast_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optenc.h ===
/*
 * optenc.h
 *
 * Defines for the optimal encoder
 */


// lookahead
#define LOOK			1024

// don't-care threshold for tree structure
#define BREAK_LENGTH	50

#define NUM_DIRECT_LOOKUP_TABLE_ELEMENTS    65536

// see stdenc.h for comments on these values
#define OPT_ENCODER_LIT_DIST_BUFFER_SIZE    65536
#define OPT_ENCODER_MAX_ITEMS				65534


//
// For the optimal parser
//
typedef unsigned long numbits_t;

typedef struct
{
	ULONG		link;
	ULONG		path;
	numbits_t	numbits;
} t_decision_node;


//
// Optimal encoder context
//
typedef struct optimal_encoder
{
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];
	t_decision_node 		decision_node[LOOK+MAX_MATCH+16];
	t_match_pos				matchpos_table[MAX_MATCH+1];
	t_search_node			search_left[2*WINDOW_SIZE];
	t_search_node			search_right[2*WINDOW_SIZE];
	t_search_node			search_tree_root[65536];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	unsigned int			next_tree_update;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    unsigned short          literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	unsigned short			literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    unsigned short          dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	unsigned short			dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];

} t_optimal_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\gzip.c ===
//
// gzip.c
//
// All of the gzip-related additions to deflate (both encoder and decoder) are in this file
//

#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "defgzip.h"
#include "crc32.h"


#define GZIP_FLG_FTEXT      1
#define GZIP_FLG_CRC        2
#define GZIP_FLG_FEXTRA     4
#define GZIP_FLG_FNAME      8
#define GZIP_FLG_FCOMMENT   16


typedef enum
{
    // GZIP header
    GZIP_HDR_STATE_READING_ID1,
    GZIP_HDR_STATE_READING_ID2,
    GZIP_HDR_STATE_READING_CM,
    GZIP_HDR_STATE_READING_FLG,
    GZIP_HDR_STATE_READING_MMTIME, // iterates 4 times
    GZIP_HDR_STATE_READING_XFL,
    GZIP_HDR_STATE_READING_OS,
    GZIP_HDR_STATE_READING_XLEN1,
    GZIP_HDR_STATE_READING_XLEN2,
    GZIP_HDR_STATE_READING_XLEN_DATA,
    GZIP_HDR_STATE_READING_FILENAME,
    GZIP_HDR_STATE_READING_COMMENT,
    GZIP_HDR_STATE_READING_CRC16_PART1,
    GZIP_HDR_STATE_READING_CRC16_PART2,
    GZIP_HDR_STATE_DONE, // done reading GZIP header

    // GZIP footer
    GZIP_FTR_STATE_READING_CRC, // iterates 4 times
    GZIP_FTR_STATE_READING_FILE_SIZE // iterates 4 times
} t_gzip_state;


void EncoderInitGzipVariables(t_encoder_context *context)
{
    context->gzip_crc32 = 0;
    context->gzip_input_stream_size = 0;
    context->gzip_fOutputGzipHeader = FALSE;
}


void WriteGzipHeader(t_encoder_context *context, int compression_level)
{
    BYTE *output_curpos = context->output_curpos;

    // only need 11 bytes
    _ASSERT(context->output_curpos + 16 <  context->output_endpos);

#ifndef TESTING
    // the proper code path
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = 0; // FLG, no text, no crc, no extra, no name, no comment

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    // XFL
    // 2 = compressor used max compression, slowest algorithm
    // 4 = compressor used fastest algorithm
    if (compression_level == 10)
        *output_curpos++ = 2; 
    else
        *output_curpos++ = 4; 

    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
#else /* TESTING */
    // this code is for code path testing only
    // it uses all of the headers to ensure that the decoder can handle them correctly
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = (GZIP_FLG_CRC|GZIP_FLG_FEXTRA|GZIP_FLG_FNAME|GZIP_FLG_FCOMMENT); // FLG

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    *output_curpos++ = 2; // XFL
    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
    
    // FEXTRA
    *output_curpos++ = 3; // LSB
    *output_curpos++ = 0; // MSB
    output_curpos += 3; // 3 bytes of data

    // FNAME, null terminated filename
    output_curpos += strlen(strcpy(output_curpos, "my filename"))+1;

    // FCOMMENT, null terminated comment
    output_curpos += strlen(strcpy(output_curpos, "my comment"))+1;

    // CRC16
    *output_curpos++ = 0x12;
    *output_curpos++ = 0x34;
#endif

    context->output_curpos = output_curpos;
}


void WriteGzipFooter(t_encoder_context *context)
{
    BYTE *output_curpos = context->output_curpos;

    *output_curpos++ = (BYTE) (context->gzip_crc32 & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 24) & 255);

    *output_curpos++ = (BYTE) (context->gzip_input_stream_size & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 24) & 255);

    context->output_curpos = output_curpos;
}


#define DO1(buf) crc = g_CrcTable[((ULONG)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

ULONG GzipCRC32(ULONG crc, const BYTE *buf, ULONG len)
{
    crc = crc ^ 0xffffffffUL;

    while (len >= 8)
    {
        DO8(buf);
        len -= 8;
    }

    if (len)
    {
        do
        {
          DO1(buf);
        } while (--len);
    }

    return crc ^ 0xffffffffUL;
}


//
// Works just like memcpy() except that we update context->crc32 and context->input_stream_size
// at the same time.
//
// Could possibly improve the perf by copying 4 or 8 bytes at a time as above
//
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count)
{
    ULONG crc = context->gzip_crc32 ^ 0xffffffffUL;

    context->gzip_input_stream_size += count;

    while (count-- > 0)
    {
        *dest++ = *src;
        DO1(src); // increments src
    }

    context->gzip_crc32 = crc ^ 0xffffffffUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fstenc.c ===
/*
 * fstenc.c
 *
 * Fast encoder
 *
 * This is a one pass encoder which uses predefined trees.  However, since these are not the same
 * trees defined for a fixed block (we use better trees than that), we output a dynamic block header.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"


//
// For debugging purposes:
//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) FastEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
    h = ((h) << FAST_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
#define INSERT_STRING(search,bufpos) \
{ \
    UPDATE_HASH(hash, window[bufpos+2]); \
\
    _ASSERT((unsigned int) FAST_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & FAST_ENCODER_HASH_MASK)); \
\
    search = lookup[hash & FAST_ENCODER_HASH_MASK]; \
    lookup[hash & FAST_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
    prev[bufpos & FAST_ENCODER_WINDOW_MASK] = (t_search_node) (search); \
}


//
// Output bits function which uses local variables for the bit buffer
//
#define LOCAL_OUTPUT_BITS(n, x) \
{ \
    bitbuf |= ((x) << bitcount); \
    bitcount += (n); \
    if (bitcount >= 16) \
    { \
        *output_curpos++ = (BYTE) bitbuf; \
        *output_curpos++ = (BYTE) (bitbuf >> 8); \
        bitcount -= 16; \
        bitbuf >>= 16; \
    } \
}


//
// Output unmatched symbol c
//
#define OUTPUT_CHAR(c) \
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralCodeInfo[c] & 31, g_FastEncoderLiteralCodeInfo[c] >> 5);


//
// Output a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
// Optimisation: unlike the other encoders, here we have an array of codes for each match
// length (not just each match length slot), complete with all the extra bits filled in, in
// a single array element.  
//
// There are many advantages to doing this:
//
// 1. A single array lookup on g_FastEncoderLiteralCodeInfo, instead of separate array lookups
//    on g_LengthLookup (to get the length slot), g_FastEncoderLiteralTreeLength, 
//    g_FastEncoderLiteralTreeCode, g_ExtraLengthBits, and g_BitMask
//
// 2. The array is an array of ULONGs, so no access penalty, unlike for accessing those USHORT
//    code arrays in the other encoders (although they could be made into ULONGs with some
//    modifications to the source).
//
// Note, if we could guarantee that code_len <= 16 always, then we could skip an if statement here.
//
// A completely different optimisation is used for the distance codes since, obviously, a table for 
// all 8192 distances combining their extra bits is not feasible.  The distance codeinfo table is 
// made up of code[], len[] and # extra_bits for this code.
//
// The advantages are similar to the above; a ULONG array instead of a USHORT and BYTE array, better
// cache locality, fewer memory operations.
//
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
    int extra_bits; \
    int code_len; \
    ULONG code_info; \
\
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
\
    code_info = g_FastEncoderLiteralCodeInfo[(NUM_CHARS+1-MIN_MATCH)+match_len]; \
    code_len = code_info & 31; \
    _ASSERT(code_len != 0); \
    if (code_len <= 16) \
    { \
        LOCAL_OUTPUT_BITS(code_len, code_info >> 5); \
    } \
    else \
    { \
        LOCAL_OUTPUT_BITS(16, (code_info >> 5) & 65535); \
        LOCAL_OUTPUT_BITS(code_len-16, code_info >> (5+16)); \
    } \
    code_info = g_FastEncoderDistanceCodeInfo[POS_SLOT(match_pos)]; \
    LOCAL_OUTPUT_BITS(code_info & 15, code_info >> 8); \
    extra_bits = (code_info >> 4) & 15; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}


//
// This commented out code is the old way of doing things, which is what the other encoders use
//
#if 0
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
    int pos_slot = POS_SLOT(match_pos); \
    int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
    int extra_bits; \
\
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
    _ASSERT(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot] != 0); \
    _ASSERT(g_FastEncoderDistanceTreeLength[pos_slot] != 0); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot], g_FastEncoderLiteralTreeCode[(NUM_CHARS+1)+len_slot]); \
    extra_bits = g_ExtraLengthBits[len_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_len-MIN_MATCH) & g_BitMask[extra_bits]); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderDistanceTreeLength[pos_slot], g_FastEncoderDistanceTreeCode[pos_slot]); \
    extra_bits = g_ExtraDistanceBits[pos_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}
#endif


//
// Local function prototypes
//
static void FastEncoderMoveWindows(t_encoder_context *context);

static int FastEncoderFindMatch(
    const BYTE *    window,
    const USHORT *  prev,
    long            bufpos, 
    long            search, 
    t_match_pos *   match_pos, 
    int             cutoff,
    int             nice_length
);


//
// Output the block type and tree structure for our hard-coded trees.
//
// Functionally equivalent to:
//
// outputBits(context, 1, 1); // "final" block flag
// outputBits(context, 2, BLOCKTYPE_DYNAMIC);
// outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
//
// However, all of the above has smartly been cached in global data, so we just memcpy().
//
void FastEncoderOutputPreamble(t_encoder_context *context)
{
#if 0
    // slow way:
    outputBits(context, 1+2, 1 | (BLOCKTYPE_DYNAMIC << 1));
    outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
#endif

    // make sure tree has been init
    _ASSERT(g_FastEncoderTreeLength > 0);

    // make sure we have enough space to output tree
    _ASSERT(context->output_curpos + g_FastEncoderTreeLength < context->output_endpos);

    // fast way:
    memcpy(context->output_curpos, g_FastEncoderTreeStructureData, g_FastEncoderTreeLength);
    context->output_curpos += g_FastEncoderTreeLength;

    // need to get final states of bitbuf and bitcount after outputting all that stuff
    context->bitbuf = g_FastEncoderPostTreeBitbuf;
    context->bitcount = g_FastEncoderPostTreeBitcount;
}


//
// Fast encoder deflate function
//
void FastEncoderDeflate(
    t_encoder_context * context, 
    int                 search_depth, // # hash links to traverse
    int                 lazy_match_threshold, // don't search @ X+1 if match length @ X is > lazy
    int                 good_length, // divide traversal depth by 4 if match length > good
    int                 nice_length // in match finder, if we find >= nice_length match, quit immediately
)
{
    long            bufpos;
    unsigned int    hash;
    unsigned long   bitbuf;
    int             bitcount;
    BYTE *          output_curpos;
    t_fast_encoder *encoder = context->fast_encoder;
    byte *          window = encoder->window; // make local copies of context variables
    t_search_node * prev = encoder->prev;
    t_search_node * lookup = encoder->lookup;

    //
    // If this is the first time in here (since last reset) then we need to output our dynamic
    // block header
    //
    if (encoder->fOutputBlockHeader == FALSE)
    {
        encoder->fOutputBlockHeader = TRUE;

        //
        // Watch out!  Calls to outputBits() and outputTreeStructure() use the bit buffer 
        // variables stored in the context, not our local cached variables.
        //
        FastEncoderOutputPreamble(context);
    }

    //
    // Copy bitbuf vars into local variables since we're now using OUTPUT_BITS macro.
    // Do not call anything that uses the context structure's bit buffer variables!
    //
    output_curpos   = context->output_curpos;
    bitbuf          = context->bitbuf;
    bitcount        = context->bitcount;

    // copy bufpos into local variable
    bufpos = context->bufpos;

    VERIFY_HASHES(bufpos); // debug mode: verify that the hash table is correct

    // initialise the value of the hash
    // no problem if locations bufpos, bufpos+1 are invalid (not enough data), since we will 
    // never insert using that hash value
    hash = 0;
    UPDATE_HASH(hash, window[bufpos]);
    UPDATE_HASH(hash, window[bufpos+1]);

    // while we haven't come to the end of the input, and we still aren't close to the end
    // of the output
    while (bufpos < context->bufpos_end && output_curpos < context->output_near_end_threshold)
    {
        int             match_len;
        t_match_pos     match_pos = 0;
        t_match_pos     search;

        VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

        if (context->bufpos_end - bufpos <= 3)
        {
            // The hash value becomes corrupt when we get within 3 characters of the end of the
            // input buffer, since the hash value is based on 3 characters.  We just stop
            // inserting into the hash table at this point, and allow no matches.
            match_len = 0;
        }
        else
        {
            // insert string into hash table and return most recent location of same hash value
            INSERT_STRING(search,bufpos);

            // did we find a recent location of this hash value?
            if (search != 0)
            {
                // yes, now find a match at what we'll call position X
                match_len = FastEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

                // truncate match if we're too close to the end of the input buffer
                if (bufpos + match_len > context->bufpos_end)
                    match_len = context->bufpos_end - bufpos;
            }
            else
            {
                // no most recent location found
                match_len = 0;
            }
        }

        if (match_len < MIN_MATCH)
        {
            // didn't find a match, so output unmatched char
            OUTPUT_CHAR(window[bufpos]);
            bufpos++;
        }
        else
        {
            // bufpos now points to X+1
            bufpos++;

            // is this match so good (long) that we should take it automatically without
            // checking X+1 ?
            if (match_len <= lazy_match_threshold)
            {
                int             next_match_len;
                t_match_pos     next_match_pos = 0;

                // sets search
                INSERT_STRING(search,bufpos);

                // no, so check for a better match at X+1
                if (search != 0)
                {
                    next_match_len = FastEncoderFindMatch(
                        window,
                        prev,
                        bufpos, 
                        search,
                        &next_match_pos,
                        match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
                    );
                
                    // truncate match if we're too close to the end of the buffer
                    // note: next_match_len could now be < MIN_MATCH
                    if (bufpos + next_match_len > context->bufpos_end)
                        next_match_len = context->bufpos_end - bufpos;
                }
                else
                {
                    next_match_len = 0;
                }

                // right now X and X+1 are both inserted into the search tree
                if (next_match_len > match_len)
                {
                    // since next_match_len > match_len, it can't be < MIN_MATCH here

                    // match at X+1 is better, so output unmatched char at X
                    OUTPUT_CHAR(window[bufpos-1]);

                    // now output match at location X+1
                    OUTPUT_MATCH(next_match_len, next_match_pos);

                    // insert remainder of second match into search tree
                    // 
                    // example: (*=inserted already)
                    //
                    // X      X+1               X+2      X+3     X+4
                    // *      *
                    //        nextmatchlen=3
                    //        bufpos
                    //
                    // If next_match_len == 3, we want to perform 2
                    // insertions (at X+2 and X+3).  However, first we must 
                    // inc bufpos.
                    //
                    bufpos++; // now points to X+2
                    match_len = next_match_len;
                    goto insert;
                }
                else
                {
                    // match at X is better, so take it
                    OUTPUT_MATCH(match_len, match_pos);

                    //
                    // Insert remainder of first match into search tree, minus the first
                    // two locations, which were inserted by the FindMatch() calls.
                    // 
                    // For example, if match_len == 3, then we've inserted at X and X+1
                    // already (and bufpos is now pointing at X+1), and now we need to insert 
                    // only at X+2.
                    //
                    match_len--;
                    bufpos++; // now bufpos points to X+2
                    goto insert;
                }
            }
            else /* match_length >= good_match */
            {
                // in assertion: bufpos points to X+1, location X inserted already
                    
                // first match is so good that we're not even going to check at X+1
                OUTPUT_MATCH(match_len, match_pos);

                // insert remainder of match at X into search tree
insert:
                if (context->bufpos_end - bufpos <= match_len)
                {
                    bufpos += (match_len-1);
                }
                else
                {
                    while (--match_len > 0)
                    {
                        t_match_pos ignore;

                        INSERT_STRING(ignore,bufpos);
                        bufpos++;
                    }
                }
            }
        }
    } /* end ... while (bufpos < bufpos_end) */

    // store local variables back in context
    context->bufpos = bufpos;
    context->bitbuf = bitbuf;
    context->bitcount = bitcount;
    context->output_curpos = output_curpos;

    VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

    if (bufpos == context->bufpos_end)
        context->state = STATE_NORMAL;
    else
        context->state = STATE_OUTPUTTING_BLOCK;

    // slide the window if bufpos has reached 2*window size
    if (context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE)
        FastEncoderMoveWindows(context);
}


static void FastEncoderMoveWindows(t_encoder_context *context)
{
    t_search_node *lookup = context->fast_encoder->lookup;
    t_search_node *prev = context->fast_encoder->prev;
    BYTE *window = context->fast_encoder->window;
    int i;

    _ASSERT(context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE);

    // verify that the hash table is correct
    VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE);

    memcpy(&window[0], &window[context->bufpos - FAST_ENCODER_WINDOW_SIZE], FAST_ENCODER_WINDOW_SIZE);

    // move all the hash pointers back
    // NOTE - We are incurring a performance penalty since lookup[] is a USHORT array.  Would be
    // nice to subtract from two locations at a time.
    for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
    {
        long val = ((long) lookup[i]) - FAST_ENCODER_WINDOW_SIZE;

        if (val <= 0) // too far away now? then set to zero
            lookup[i] = (t_search_node) 0;
        else
            lookup[i] = (t_search_node) val;
    }

    // prev[]'s are absolute pointers, not relative pointers, so we have to move them back too
    // making prev[]'s into relative pointers poses problems of its own
    for (i = 0; i < FAST_ENCODER_WINDOW_SIZE; i++)
    {
        long val = ((long) prev[i]) - FAST_ENCODER_WINDOW_SIZE;

        if (val <= 0)
            prev[i] = (t_search_node) 0;
        else
            prev[i] = (t_search_node) val;
    }

#ifdef FULL_DEBUG
    // For debugging, wipe the window clean, so that if there is a bug in our hashing,
    // the hash pointers will now point to locations which are not valid for the hash value
    // (and will be caught by our ASSERTs).
    memset(&window[FAST_ENCODER_WINDOW_SIZE], 0, FAST_ENCODER_WINDOW_SIZE);
#endif

    VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE); // debug: verify hash table is correct

    context->bufpos = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos_end = context->bufpos;
}


//
// Find match
//
// Returns match length found.  A match length < MIN_MATCH means no match was found.
//
static int FastEncoderFindMatch(
    const BYTE *    window, // window array
    const USHORT *  prev,   // prev ptr array
    long            bufpos, // current buffer position
    long            search, // where to start searching
    t_match_pos *   match_pos, // return match position here
    int             cutoff, // # links to traverse
    int             nice_length // stop immediately if we find a match >= nice_length
)
{
    // make local copies of context variables
    long            earliest;
    int             best_match = 0; // best match length found so far
    t_match_pos     l_match_pos = 0; // absolute match position of best match found
    BYTE            want_char;

    _ASSERT(bufpos >= 0 && bufpos < 2*FAST_ENCODER_WINDOW_SIZE);
    _ASSERT(search < bufpos);
    _ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

    // the earliest we can look
    earliest = bufpos - FAST_ENCODER_WINDOW_SIZE;
    _ASSERT(earliest >= 0);

    // store window[bufpos + best_match]
    want_char = window[bufpos];

    while (search > earliest)
    {
        // make sure all our hash links are valid
        _ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

        // Start by checking the character that would allow us to increase the match
        // length by one.  This improves performance quite a bit.
        if (window[search + best_match] == want_char)
        {
            int j;

            // Now make sure that all the other characters are correct
            for (j = 0; j < MAX_MATCH; j++)
            {
                if (window[bufpos+j] != window[search+j])
                    break;
            }
    
            if (j > best_match)
            {
                best_match  = j;
                l_match_pos = search; // absolute position

                if (j > nice_length)
                    break;

                want_char = window[bufpos+j];
            }
        }

        if (--cutoff == 0)
            break;

        // make sure we're always going backwards
        _ASSERT(prev[search & FAST_ENCODER_WINDOW_MASK] < search);

        search = (long) prev[search & FAST_ENCODER_WINDOW_MASK];
    }

    // doesn't necessarily mean we found a match; best_match could be > 0 and < MIN_MATCH
    *match_pos = bufpos - l_match_pos - 1; // convert absolute to relative position

    // don't allow match length 3's which are too far away to be worthwhile
    if (best_match == 3 && *match_pos >= FAST_ENCODER_MATCH3_DIST_THRESHOLD)
        return 0;

    _ASSERT(best_match < MIN_MATCH || *match_pos < FAST_ENCODER_WINDOW_SIZE);

    return best_match;
}


void FastEncoderReset(t_encoder_context *context)
{
    _ASSERT(context->fast_encoder != NULL);

    // zero hash table
    memset(context->fast_encoder->lookup, 0, sizeof(context->fast_encoder->lookup));

    context->window_size = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos_end = context->bufpos;
    context->fast_encoder->fOutputBlockHeader = FALSE;
}


BOOL FastEncoderInit(t_encoder_context *context)
{
    context->fast_encoder = (t_fast_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_fast_encoder));

    if (context->fast_encoder == NULL)
        return FALSE;

    FastEncoderReset(context);
    return TRUE;
}


//
// Pregenerate the structure of the dynamic tree header which is output for
// the fast encoder.  Also record the final states of bitcount and bitbuf
// after outputting.
//
void FastEncoderGenerateDynamicTreeEncoding(void)
{
    t_encoder_context context;

    // Create a fake context with output pointers into our global data
    memset(&context, 0, sizeof(context));
    context.output_curpos = g_FastEncoderTreeStructureData;
    context.output_endpos = g_FastEncoderTreeStructureData + sizeof(g_FastEncoderTreeStructureData);
    context.output_near_end_threshold = context.output_endpos - 16;
    InitBitBuffer(&context);

    outputBits(&context, 1, 1); // "final" block flag
    outputBits(&context, 2, BLOCKTYPE_DYNAMIC);
   
    outputTreeStructure(
        &context,
        g_FastEncoderLiteralTreeLength, 
        g_FastEncoderDistanceTreeLength
    );

    g_FastEncoderTreeLength = (int)(context.output_curpos - (BYTE *) g_FastEncoderTreeStructureData);
    g_FastEncoderPostTreeBitbuf = context.bitbuf;
    g_FastEncoderPostTreeBitcount = context.bitcount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\maketbl.c ===
//
// maketbl.c
//
// Creates Huffman decoding tables
//
#include <crtdbg.h>
#include <windows.h>
#include "common.h"
#include "maketbl.h"


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

    _ASSERT(len > 0);

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;
	} while (--len > 0);

	return new_code >> 1;
}


BOOL makeTable(
	int				num_elements, 
	int				table_bits, 
	const byte *	code_length, 
	short *			table, 
	short *			left, 
	short *			right
)
{
	int				bl_count[17];
	unsigned int	next_code[17];
	unsigned int	code[MAX_LITERAL_TREE_ELEMENTS];
	int				temp_code;
	int				avail;
	int				i, bits, ch;
	int				table_size, table_mask;

	table_size = 1 << table_bits;
	table_mask = table_size - 1;

	for (i = 0; i <= 16; i++)
		bl_count[i] = 0;

	for (i = 0; i < num_elements; i++)
		bl_count[ code_length[i] ]++;

	//
	// If there are any codes larger than table_bits in length, then
	// we will have to clear the table for our left/right spillover
    // code to work correctly.
	//
	// If there aren't any codes that large, then all table entries
	// will be written over without being read, so we don't need to
	// initialise them
	//
	for (i = table_bits; i <= 16; i++)
	{
		if (bl_count[i] > 0)
		{
			int j;

			// found a code larger than table_bits
			for (j = 0; j < table_size; j++)
				table[j] = 0;

			break;
		}
	}

	temp_code	= 0;
	bl_count[0] = 0;

	for (bits = 1; bits <= 16; bits++)
	{
		temp_code = (temp_code + bl_count[bits-1]) << 1;
		next_code[bits] = temp_code;
	}

	for (i = 0; i < num_elements; i++)
	{
		int len = code_length[i];

		if (len > 0)
		{
			code[i] = bitReverse(next_code[len], len);
			next_code[len]++;
		}
	}

	avail = num_elements;

	for (ch = 0; ch < num_elements; ch++)
	{
		int	start_at, len;

		// length of this code
		len = code_length[ch];

		// start value (bit reversed)
		start_at = code[ch];

		if (len > 0)
		{
			if (len <= table_bits)
			{
				int locs = 1 << (table_bits - len);
				int increment = 1 << len;
				int j;

				// 
				// Make sure that in the loop below, start_at is always
				// less than table_size.
				//
				// On last iteration we store at array index:
				//    initial_start_at + (locs-1)*increment
				//  = initial_start_at + locs*increment - increment
				//  = initial_start_at + (1 << table_bits) - increment
				//  = initial_start_at + table_size - increment
				//
				// Therefore we must ensure:
				//     initial_start_at + table_size - increment < table_size
				// or: initial_start_at < increment
				//
				if (start_at >= increment)
					return FALSE; // invalid table!

				for (j = 0; j < locs; j++)
				{
					table[start_at] = (short) ch;
					start_at += increment;
				}
			}
			else
			{
				int		overflow_bits;
				int		code_bit_mask;
				short *	p;

				overflow_bits = len - table_bits;
				code_bit_mask = 1 << table_bits;

				p = &table[start_at & table_mask];
                if (*p > 0)
                    return FALSE; // someone else already wrote a code here - invalid table!

				do
				{
					short value;

					value = *p;
                    _ASSERTE(value <= 0);

					if (value == 0)
					{
						left[avail]		= 0;
						right[avail]	= 0;

						*p = (short)-avail;
                        
						value = (short)-avail;
						avail++;
					}

                    _ASSERTE((-value >= 0) && (-value < table_size));

					if ((start_at & code_bit_mask) == 0)
						p = &left[-value];
					else
						p = &right[-value];

					code_bit_mask <<= 1;
					overflow_bits--;
				} while (overflow_bits != 0);

				*p = (short) ch;
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optblock.c ===
//
// optblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
    slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_literal_tree_left[slot]; \
            else \
                slot = encoder->recording_literal_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
    slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_dist_tree_left[slot]; \
            else \
                slot = encoder->recording_dist_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
    read_bitbuf >>= count; \
    read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
    if (read_bitcount <= 0) \
    { \
        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
        read_bitcount += 8; \
        if (read_bitcount <= 0) \
        { \
            read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
            read_bitcount += 8; \
        } \
    }


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
    _ASSERT(encoder->literal_tree_len[element] != 0); \
    outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
    _ASSERT(encoder->dist_tree_len[element] != 0); \
    outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL OptimalEncoderOutputDynamicBlock(t_encoder_context *context)
{
    unsigned long    read_bitbuf;
    int                read_bitcount;
    byte *            read_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

    if (context->state == STATE_NORMAL)
    {
        //
        // If we haven't started to output a block yet
        //
        read_bufptr     = encoder->lit_dist_buffer;
        read_bitbuf        = 0;
        read_bitcount    = -16;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        context->outputting_block_bitbuf        = read_bitbuf;
        context->outputting_block_bitcount        = read_bitcount;
        context->outputting_block_bufptr        = read_bufptr;

        outputBits(context, 1, 0); // "final" block flag
        outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

        context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
    }

    if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
    {
        //
        // Make sure there is enough room to output the entire tree structure at once
        //
        if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
        {
            _ASSERT(0); // not enough room to output tree structure, fatal error!
            return FALSE;
        }

        outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

        context->state = STATE_OUTPUTTING_BLOCK;
    }

    _ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

    // load state into local variables
    read_bufptr        = context->outputting_block_bufptr;
    read_bitbuf        = context->outputting_block_bitbuf;
    read_bitcount    = context->outputting_block_bitcount;

    // output literals
    while (context->outputting_block_current_literal < context->outputting_block_num_literals)
    {
        int literal;

        // break when we get near the end of our output buffer
        if (context->output_curpos >= context->output_near_end_threshold)
            break;

        DECODE_LITERAL(literal);
        DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
        CHECK_MORE_READBUF();

        if (literal < NUM_CHARS)
        {
            // it's a char
            OUTPUT_LITERAL(literal);
        }
        else
        {
            // it's a match
            int len_slot, pos_slot, extra_pos_bits;

            // literal == len_slot + (NUM_CHARS+1)
            _ASSERT(literal != END_OF_BLOCK_CODE);

            OUTPUT_LITERAL(literal);

            len_slot = literal - (NUM_CHARS+1);

            //
            // extra_length_bits[len_slot] > 0 when len_slot >= 8
            // (except when length is MAX_MATCH).
            //
            if (len_slot >= 8)
            {
                int extra_bits = g_ExtraLengthBits[len_slot];

                if (extra_bits > 0)
                {
                    unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

                    outputBits(context, extra_bits, extra_data);
                    
                    DUMP_READBUF_BITS(extra_bits);
                    CHECK_MORE_READBUF();
                }
            }

            DECODE_POS_SLOT(pos_slot);
            DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
            CHECK_MORE_READBUF();

            _ASSERT(pos_slot < 30);

            OUTPUT_DIST_SLOT(pos_slot);

            extra_pos_bits = g_ExtraDistanceBits[pos_slot];

            if (extra_pos_bits > 0)
            {
                unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

                outputBits(context, extra_pos_bits, extra_data);

                DUMP_READBUF_BITS(extra_pos_bits);
                CHECK_MORE_READBUF();
            }
        }

        context->outputting_block_current_literal++;
    }

    // did we output all of our literals without running out of output space?
    if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
    {
        // output the code signifying end-of-block
        OUTPUT_LITERAL(END_OF_BLOCK_CODE);

        // reset state
        context->state = STATE_NORMAL;
    }
    else
    {
        context->outputting_block_bitbuf    = read_bitbuf;
        context->outputting_block_bitcount    = read_bitcount;
        context->outputting_block_bufptr    = read_bufptr;
        context->state                        = STATE_OUTPUTTING_BLOCK;
    }

    return TRUE;
}



//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL OptimalEncoderOutputBlock(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

    //
    // The tree creation routines cannot >= 65536 literals.
    //
    _ASSERT(context->outputting_block_num_literals < 65536);

    if (context->state == STATE_NORMAL)
    {
        //
        // Start outputting literals and distances from the beginning
        //
        context->outputting_block_current_literal = 0;
    
        //
        // Nothing to output?  Then return
        //
        if (context->outputting_block_num_literals == 0)
            return TRUE;

        // make decoding table so that we can decode recorded items
        makeTable(
            MAX_LITERAL_TREE_ELEMENTS,
            REC_LITERALS_DECODING_TABLE_BITS,
            encoder->recording_literal_tree_len,
            encoder->recording_literal_tree_table,
            encoder->recording_literal_tree_left,
            encoder->recording_literal_tree_right
        );

        makeTable(
            MAX_DIST_TREE_ELEMENTS,
            REC_DISTANCES_DECODING_TABLE_BITS,
            encoder->recording_dist_tree_len,
            encoder->recording_dist_tree_table,
            encoder->recording_dist_tree_left,
            encoder->recording_dist_tree_right
        );

        // now make the trees used for encoding
        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            15, 
            encoder->literal_tree_freq, 
            encoder->literal_tree_code,
            encoder->literal_tree_len
        );

        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            15, 
            encoder->dist_tree_freq, 
            encoder->dist_tree_code,
            encoder->dist_tree_len
        );
    }

    //
    // Try outputting as a dynamic block
    //
    if (OptimalEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
           encoder->recording_bufptr           = context->optimal_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

        context->outputting_block_num_literals = 0;

        // make sure there are no zero frequency items
        NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

        // make tree for recording new items
        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            RECORDING_DIST_MAX_CODE_LEN,
            encoder->dist_tree_freq, 
            encoder->recording_dist_tree_code, 
            encoder->recording_dist_tree_len
        );

        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            RECORDING_LIT_MAX_CODE_LEN,
            encoder->literal_tree_freq, 
            encoder->recording_literal_tree_code, 
            encoder->recording_literal_tree_len
        );

        OptimalEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optdebug.c ===
/*
 * optdebug.c
 *
 * Optimal encoder debugging stubs
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef _DEBUG
static void OptimalEncoderVerifyTreeStructure(t_encoder_context *context, byte val1, byte val2, long where)
{
    long left, right;

    if (where == 0)
        return;

    _ASSERT(context->optimal_encoder->window[where] == val1);
    _ASSERT(context->optimal_encoder->window[where+1] == val2);

    left = context->optimal_encoder->search_left[where];
    right = context->optimal_encoder->search_right[where];

    OptimalEncoderVerifyTreeStructure(context, val1, val2, left);
    OptimalEncoderVerifyTreeStructure(context, val1, val2, right);
}


void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
    long i;

    for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
    {
        long    where = context->optimal_encoder->search_tree_root[i];
        USHORT    tree_to_use;

        if (where == 0)
            continue;

        tree_to_use = *((USHORT UNALIGNED *) &context->optimal_encoder->window[where]);

        _ASSERT(where < bufpos);
        _ASSERT(tree_to_use == i);

        OptimalEncoderVerifyTreeStructure(context, context->optimal_encoder->window[where], context->optimal_encoder->window[where+1], where);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optenc.c ===
/*
 * optenc.c
 *
 * Optimal encoder
 *
 * Can improve compression by using the "redo" method of LZX; after the first 32K bytes,
 * reset the compressor but keep the tables, and start over.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// If we get a match this good, take it automatically
//
// Note: FAST_DECISION_THRESHOLD can be set to anything; it's been set to BREAK_LENGTH
//       arbitrarily
//
#define FAST_DECISION_THRESHOLD BREAK_LENGTH


//
// After we have this many literals, create a tree to get updated statistical estimates
//
#define FIRST_TREE_UPDATE 1024


//
// Verifies that all of the hash pointers in the hash table are correct, and that
// the tree structure is valid.
//
//#define DISABLE_VERIFY_HASHES

#ifdef _DEBUG
#ifndef DISABLE_VERIFY_HASHES
#define VERIFY_HASHES(bufpos) OptimalEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif
#else
#define VERIFY_HASHES(bufpos) ;
#endif


#define CHECK_FLUSH_RECORDING_BUFFER() \
    if (recording_bitcount >= 16) \
    { \
        *recording_bufptr++ = (BYTE) recording_bitbuf; \
        *recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
        recording_bitbuf >>= 16; \
        recording_bitcount -= 16; \
    }


#define OUTPUT_RECORDING_DATA(count,data) \
    recording_bitbuf |= ((data) << recording_bitcount); \
    recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[c]++; \
    _ASSERT(encoder->recording_literal_tree_len[c] != 0); \
    OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[c], encoder->recording_literal_tree_code[c]); \
    CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
    int pos_slot = POS_SLOT(match_pos); \
    int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
    int item = (NUM_CHARS+1) + len_slot; \
    int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
    int extra_len_bits = g_ExtraLengthBits[len_slot]; \
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
    _ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < OPT_ENCODER_MAX_ITEMS); \
    _ASSERT(encoder->recording_literal_tree_len[item] != 0); \
    _ASSERT(encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    encoder->dist_tree_freq[pos_slot]++; \
    OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[item], encoder->recording_literal_tree_code[item]); \
    CHECK_FLUSH_RECORDING_BUFFER(); \
    if (extra_len_bits > 0) \
    { \
        OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
        CHECK_FLUSH_RECORDING_BUFFER(); \
    } \
    OUTPUT_RECORDING_DATA(encoder->recording_dist_tree_len[pos_slot], encoder->recording_dist_tree_code[pos_slot]); \
    CHECK_FLUSH_RECORDING_BUFFER(); \
    if (extra_dist_bits > 0) \
    { \
        OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
        CHECK_FLUSH_RECORDING_BUFFER(); \
    } \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
    *recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


static void calculateUpdatedEstimates(t_encoder_context *context);
static void OptimalEncoderMoveWindows(t_encoder_context *context);


static int match_est(t_optimal_encoder *encoder, int match_length, unsigned int match_pos)
{
    int dist_slot;
    int len_slot;

    // output match position
    len_slot = g_LengthLookup[match_length-MIN_MATCH];
    dist_slot = POS_SLOT(match_pos);

    return    encoder->literal_tree_len[NUM_CHARS + 1 + len_slot] +
            g_ExtraLengthBits[len_slot] +
            encoder->dist_tree_len[dist_slot] + 
            g_ExtraDistanceBits[dist_slot];
}


//
// Create initial estimations to output each element
//
static void initOptimalEstimates(t_encoder_context *context)
{
    int i, p;
    t_optimal_encoder *encoder = context->optimal_encoder;

    for (i = 0; i < NUM_CHARS; i++)
        encoder->literal_tree_len[i] = 8;

    p = NUM_CHARS+1;
    encoder->literal_tree_len[p] = 3;
    encoder->literal_tree_len[p+1] = 4;
    encoder->literal_tree_len[p+2] = 5;

    for (; p < MAX_LITERAL_TREE_ELEMENTS; p++)
        encoder->literal_tree_len[p] = 6;

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        encoder->dist_tree_len[i] = ((BYTE)i/2)+1;
}


//
// Fix optimal estimates; if bitlen == 0 it doesn't mean that the element takes 0
// bits to output, it means that the element didn't occur, so come up with some estimate.
//
static void fixOptimalEstimates(t_encoder_context *context)
{
    int i;
    t_optimal_encoder *encoder = context->optimal_encoder;

    for (i = 0; i < NUM_CHARS; i++)
    {
        if (encoder->literal_tree_len[i] == 0)
            encoder->literal_tree_len[i] = 13;
    }

    for (i = NUM_CHARS+1; i < MAX_LITERAL_TREE_ELEMENTS; i++)
    {
        if (encoder->literal_tree_len[i] == 0)
            encoder->literal_tree_len[i] = 12;
    }

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
    {
        if (encoder->dist_tree_len[i] == 0)
            encoder->dist_tree_len[i] = 10;
    }
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (encoder->literal_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 */
#define MATCH_EST(ml,mp,result) result = match_est(encoder, ml,mp);


//
// Returns whether the literal buffers are just about full
//
// Since we could output a large number of matches/chars in between these checks, we
// have to be careful.
//
//        should check after each item output, so we don't have to be so careful; this
//        means we will utilise more of the recording buffer
//
#define LITERAL_BUFFERS_FULL() \
    (context->outputting_block_num_literals >= OPT_ENCODER_MAX_ITEMS-4-LOOK-MAX_MATCH || \
            recording_bufptr + 3*(MAX_MATCH + LOOK) >= end_recording_bufptr)


void OptimalEncoderDeflate(t_encoder_context *context)
{
    unsigned long    bufpos_end;
    unsigned long    MatchPos;
    unsigned long    i;
    int                EncMatchLength; /* must be a signed number */
    unsigned long    bufpos;
    unsigned long    recording_bitbuf;
    int                recording_bitcount;
    byte *            recording_bufptr;
    byte *          end_recording_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);
    _ASSERT(context->state == STATE_NORMAL);

    // reinsert the up to BREAK_LENGTH nodes we removed the last time we exit this function
    VERIFY_HASHES(context->bufpos);
    reinsertRemovedNodes(context);
    VERIFY_HASHES(context->bufpos);

    // restore literal/match bitmap variables
    end_recording_bufptr = &encoder->lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE-8];
    recording_bufptr = encoder->recording_bufptr;
    recording_bitbuf = encoder->recording_bitbuf;
    recording_bitcount = encoder->recording_bitcount;

    bufpos            = context->bufpos;
    bufpos_end        = context->bufpos_end;

    _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

    /*
     * While we haven't reached the end of the data
     */
after_output_block:

    _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

    while (bufpos < bufpos_end)
    {
        // time to update our stats?
        if (context->outputting_block_num_literals >= encoder->next_tree_update)
        {
            encoder->next_tree_update += 1024;

            calculateUpdatedEstimates(context);
            fixOptimalEstimates(context);
        }

        // literal buffer or distance buffer filled up (or close to filling up)?
        if (LITERAL_BUFFERS_FULL())
            break;

        /*
         * Search for matches of all different possible lengths, at bufpos
         */
        EncMatchLength = optimal_find_match(context, bufpos); 

        if (EncMatchLength < MIN_MATCH)
        {

output_literal:
            /*
             * No match longer than 1 character exists in the history 
             * window, so output the character at bufpos as a symbol.
             */
            RECORD_CHAR(encoder->window[bufpos]);
            bufpos++;
            continue;
        }

        /*
         * Found a match.
         *
         * Make sure it cannot exceed the end of the buffer.
         */
        if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
        {
            EncMatchLength = bufpos_end - bufpos;    

            /*
             * Oops, not enough for even a small match, so we 
             * have to output a literal
             */
            if (EncMatchLength < MIN_MATCH)
                goto output_literal;
        }

        if (EncMatchLength < FAST_DECISION_THRESHOLD)
        {
            /*
             *  A match has been found that is between MIN_MATCH and 
             *  FAST_DECISION_THRESHOLD bytes in length.  The following 
             *  algorithm is the optimal encoder that will determine the 
             *  most efficient order of matches and unmatched characters 
             *  over a span area defined by LOOK.  
             *
             *  The code is essentially a shortest path determination 
             *  algorithm.  A stream of data can be encoded in a vast number 
             *  of different ways depending on the match lengths and offsets
             *  chosen.  The key to good compression ratios is to chose the 
             *  least expensive path.
             */
            unsigned long    span;
            unsigned long    epos, bpos, NextPrevPos;
            t_decision_node *decision_node_ptr;
            t_decision_node *context_decision_node = encoder->decision_node;
            t_match_pos *matchpos_table = encoder->matchpos_table;
            long        iterations;

            /*
             * Points to the end of the area covered by this match; the span
             * will continually be extended whenever we find more matches
             * later on.  It will stop being extended when we reach a spot
             * where there are no matches, which is when we decide which
             * path to take to output the matches.
             */
            span = bufpos + EncMatchLength;

            /*
             * The furthest position into which we will do our lookahead parsing 
             */
            epos = bufpos + LOOK;

            /*
             * Temporary bufpos variable
             */
            bpos = bufpos;

            /* 
             * Calculate the path to the next character if we output
             * an unmatched symbol.
             */

            /* bits required to get here */
            context_decision_node[1].numbits = CHAR_EST(encoder->window[bufpos]);
                
            /* where we came from */
            context_decision_node[1].path    = bufpos;

            /* bits required to get here */
            context_decision_node[2].numbits = CHAR_EST(encoder->window[bufpos+1]) + context_decision_node[1].numbits;
                
            /* where we came from */
            context_decision_node[2].path    = bufpos+1;

            /*
             * For the match found, estimate the cost of encoding the match
             * for each possible match length, shortest offset combination.
             *
             * The cost, path and offset is stored at bufpos + Length.  
             */
            for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
            {
                /*
                 * Get estimation of match cost given match length = i,
                 * match position = matchpos_table[i], and store
                 * the result in numbits[i]
                 */
                MATCH_EST(i, matchpos_table[i], context_decision_node[i].numbits);

                /*
                 * Where we came from 
                 */
                context_decision_node[i].path = bufpos;

                /*
                 * Associated match position with this path
                 */
                context_decision_node[i].link = matchpos_table[i];
            }

            /*
             * Set bit counter to zero at the start 
             */
            context_decision_node[0].numbits = 0;

            decision_node_ptr = &context_decision_node[-(long) bpos];

            for (;;)
            {
                numbits_t est, cum_numbits;

                bufpos++;
    
                /* 
                 *  Set the proper repeated offset locations depending on the
                 *  shortest path to the location prior to searching for a 
                 *  match.
                 */

                /*
                 * The following is one of the two possible break points from
                 * the inner encoding loop.  This break will exit the loop if 
                 * a point is reached that no match can incorporate; i.e. a
                 * character that does not match back to anything is a point 
                 * where all possible paths will converge and the longest one
                 * can be chosen.
                 */
                if (span == bufpos)
                    break;
                    
                /*
                 * Search for matches at bufpos 
                 */
                EncMatchLength = optimal_find_match(context, bufpos); 

                /* 
                 * Make sure that the match does not exceed the stop point
                 */
                if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
                {
                    EncMatchLength = bufpos_end - bufpos; 
                    
                    if (EncMatchLength < MIN_MATCH)
                        EncMatchLength = 0;
                }

                /*
                 * If the match is very long or it exceeds epos (either 
                 * surpassing the LOOK area, or exceeding past the end of the
                 * input buffer), then break the loop and output the path.
                 */
                if (EncMatchLength > FAST_DECISION_THRESHOLD || 
                    bufpos + (unsigned long) EncMatchLength >= epos)
                {
                    MatchPos = matchpos_table[EncMatchLength];

                    decision_node_ptr[bufpos+EncMatchLength].link = MatchPos;
                    decision_node_ptr[bufpos+EncMatchLength].path = bufpos;

                    /*
                     * Quickly insert data into the search tree without
                     * returning match positions/lengths
                     */
#ifndef INSERT_NEAR_LONG_MATCHES
                    if (MatchPos == 3 && EncMatchLength > 16)
                    {
                        /*
                         * If we found a match 1 character away and it's
                         * length 16 or more, it's probably a string of
                         * zeroes, so don't insert that into the search
                         * engine, since doing so can slow things down
                         * significantly!
                         */
                        optimal_insert(
                            context,
                               bufpos + 1,
                               bufpos - WINDOW_SIZE + 2
                           );
                    }
                    else
#endif
                    {
                        for (i = 1; i < (unsigned long) EncMatchLength; i++)
                            optimal_insert(
                                context,
                                   bufpos + i,
                                   bufpos + i - WINDOW_SIZE + 4
                                );
                    }

                    bufpos += EncMatchLength;
                    break;
                }


                /*
                 * The following code will extend the area spanned by the 
                 * set of matches if the current match surpasses the end of
                 * the span.  A match of length two that is far is not 
                 * accepted, since it would normally be encoded as characters,
                 * thus allowing the paths to converge.
                 */
                if (EncMatchLength >= 3)
                {
                    if (span < (unsigned long) (bufpos + EncMatchLength))
                    {
                        long end;
                        long i;

                        end = min(bufpos+EncMatchLength-bpos, LOOK-1);

                        /*
                         * These new positions are undefined for now, since we haven't
                         * gone there yet, so put in the costliest value
                         */
                        for (i = span-bpos+1; i <= end; i++)
                            context_decision_node[i].numbits = (numbits_t) -1;

                        span = bufpos + EncMatchLength;
                    }
                }

                /*
                 *  The following code will iterate through all combinations
                 *  of match lengths for the current match.  It will estimate
                 *  the cost of the path from the beginning of LOOK to 
                 *  bufpos and to every locations spanned by the current 
                 *  match.  If the path through bufpos with the found matches
                 *  is estimated to take fewer number of bits to encode than
                 *  the previously found match, then the path to the location
                 *  is altered.
                 *
                 *  The code relies on accurate estimation of the cost of 
                 *  encoding a character or a match.  Furthermore, it requires
                 *  a search engine that will store the smallest match offset
                 *  of each possible match length.
                 *
                 *  A match of length one is simply treated as an unmatched 
                 *  character.
                 */

                /* 
                 *  Get the estimated number of bits required to encode the 
                 *  path leading up to bufpos.
                 */
                cum_numbits = decision_node_ptr[bufpos].numbits;

                /*
                 *  Calculate the estimated cost of outputting the path through
                 *  bufpos and outputting the next character as an unmatched byte
                 */
                est = cum_numbits + CHAR_EST(encoder->window[bufpos]);

                /*
                 *  Check if it is more efficient to encode the next character
                 *  as an unmatched character rather than the previously found 
                 *  match.  If so, then update the cheapest path to bufpos + 1.
                 *
                 *  What happens if est == numbits[bufpos-bpos+1]; i.e. it
                 *  works out as well to output a character as to output a
                 *  match?  It's a tough call; however, we will push the
                 *  encoder to use matches where possible.
                 */
                if (est < decision_node_ptr[bufpos+1].numbits)
                {
                    decision_node_ptr[bufpos+1].numbits = est;
                    decision_node_ptr[bufpos+1].path    = bufpos;
                }

                /*
                 *    Now, iterate through the remaining match lengths and 
                 *  compare the new path to the existing.  Change the path
                 *  if it is found to be more cost effective to go through
                 *  bufpos.
                 */
                for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
                {
                    MATCH_EST(i, matchpos_table[i], est);
                    est += cum_numbits;

                    /*
                     * If est == numbits[bufpos+i] we want to leave things
                     * alone, since this will tend to force the matches
                     * to be smaller in size, which is beneficial for most
                     * data.
                     */
                    if (est < decision_node_ptr[bufpos+i].numbits)
                    {
                        decision_node_ptr[bufpos+i].numbits    = est;
                        decision_node_ptr[bufpos+i].path    = bufpos;
                        decision_node_ptr[bufpos+i].link    = matchpos_table[i];
                    }
                }
            } /* continue to loop through span of matches */

            /*
             *  Here bufpos == span, ie. a non-matchable character found.  The
             *  following code will output the path properly.
             */

            /*
             *  Unfortunately the path is stored in reverse; how to get from
             *  where we are now, to get back to where it all started.
             *
             *  Traverse the path back to the original starting position
             *  of the LOOK span.  Invert the path pointers in order to be
             *  able to traverse back to the current position from the start.
             */

            /*
             * Count the number of iterations we did, so when we go forwards
             * we'll do the same amount
             */
            iterations = 0;

            NextPrevPos = decision_node_ptr[bufpos].path;

               do
            {
                unsigned long    PrevPos;

                  PrevPos = NextPrevPos;

                   NextPrevPos = decision_node_ptr[PrevPos].path;
                   decision_node_ptr[PrevPos].path = bufpos;

                   bufpos = PrevPos;
                   iterations++;
            } while (bufpos != bpos);

            /*
             * Traverse from the beginning of the LOOK span to the end of 
             * the span along the stored path, outputting matches and 
             * characters appropriately.
             */
            do
            {
                   if (decision_node_ptr[bufpos].path > bufpos+1)
                   {
                    /*
                     * Path skips over more than 1 character; therefore it's a match
                     */
                    RECORD_MATCH(
                        decision_node_ptr[bufpos].path - bufpos,
                        decision_node_ptr[ decision_node_ptr[bufpos].path ].link
                    );

                    bufpos = decision_node_ptr[bufpos].path;
                }
                   else
                   {
                    /*
                     * Path goes to the next character; therefore it's a symbol
                     */
                    RECORD_CHAR(encoder->window[bufpos]);
                    bufpos++;
                }
            } while (--iterations != 0);
        }
        else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
        {
            /*
             *  This code reflects a speed optimization that will always take
             *  a match of length >= FAST_DECISION_THRESHOLD characters.
             */

            /*
             * The position associated with the match we found
             */
            MatchPos = encoder->matchpos_table[EncMatchLength];

            /*
             * Quickly insert match substrings into search tree
             * (don't look for new matches; just insert the strings)
             */
#ifndef INSERT_NEAR_LONG_MATCHES
            if (MatchPos == 3 && EncMatchLength > 16)
            {
                optimal_insert(
                    context,
                       bufpos + 1,
                       bufpos - WINDOW_SIZE + 2 
                   );
            }
            else
#endif
            {
                for (i = 1; i < (unsigned long) EncMatchLength; i++)
                    optimal_insert(
                        context,
                           bufpos + i,
                           bufpos + i - WINDOW_SIZE + 1
                        );
            }

            /*
             * Advance our position in the window
             */
            bufpos += EncMatchLength;

            /*
             * Output the match
             */
            RECORD_MATCH(EncMatchLength, MatchPos);

        }  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
    } /* end while ... bufpos <= bufpos_end */

    if (LITERAL_BUFFERS_FULL())
    {
        _ASSERT(context->outputting_block_num_literals <= OPT_ENCODER_MAX_ITEMS);

        // flush our recording matches bit buffer
        FLUSH_RECORDING_BITBUF();

        // Should check for failure result.  Luckily the only failure condition is
        // that the tree didn't fit into 500 bytes, which is basically impossible anyway.
        _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

        (void) OptimalEncoderOutputBlock(context);

        // fix estimates for optimal parser
        fixOptimalEstimates(context);

        encoder->next_tree_update = FIRST_TREE_UPDATE;

        // did we output the whole block?
        if (context->state == STATE_NORMAL)
        {
            // reset literal recording
            recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
            goto after_output_block;
        }
    }

    // save recording state
    encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

    context->bufpos    = bufpos;

    VERIFY_HASHES(bufpos);
    removeNodes(context);
    VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        OptimalEncoderMoveWindows(context);
}


//
// Move the search windows when bufpos reaches 2*WINDOW_SIZE
//
static void OptimalEncoderMoveWindows(t_encoder_context *context)
{
    long    delta;
    int        i;
    t_optimal_encoder *encoder = context->optimal_encoder;
    t_search_node *search_tree_root = encoder->search_tree_root;
    t_search_node *left = encoder->search_left;
    t_search_node *right = encoder->search_right;

       _ASSERT(context->bufpos == 2*WINDOW_SIZE);
 
    VERIFY_HASHES(context->bufpos);

    delta = context->bufpos - WINDOW_SIZE;

    memcpy(&encoder->window[0], &encoder->window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

    for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
    {
        long val = ((long) search_tree_root[i]) - delta;
    
        if (val <= 0)
            search_tree_root[i] = (t_search_node) 0;
        else
            search_tree_root[i] = (t_search_node) val;

        _ASSERT(search_tree_root[i] < WINDOW_SIZE);
    }

    memcpy(&left[0], &left[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);
    memcpy(&right[0], &right[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);

    for (i = 0; i < WINDOW_SIZE; i++)
    {
        long val;
            
        // left
        val = ((long) left[i]) - delta;

        if (val <= 0)
            left[i] = (t_search_node) 0;
        else
            left[i] = (t_search_node) val;

        // right
        val = ((long) right[i]) - delta;

        if (val <= 0)
            right[i] = (t_search_node) 0;
        else
            right[i] = (t_search_node) val;
    }

#ifdef _DEBUG
    // force any search table references to be invalid
    memset(&encoder->window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

    context->bufpos = WINDOW_SIZE;
    context->bufpos_end = context->bufpos;

    VERIFY_HASHES(context->bufpos);
}


//
// Calculate the frequencies of all literal and distance codes, for tree-making, then
// make the trees
//
static void calculateUpdatedEstimates(t_encoder_context *context)
{
    USHORT code[MAX_LITERAL_TREE_ELEMENTS];
    t_optimal_encoder *encoder = context->optimal_encoder;

    // create the trees, we're interested only in len[], not code[]
    // perf optimisation: make makeTree() not call MakeCode() in this situation
    makeTree(
        MAX_LITERAL_TREE_ELEMENTS, 
        15, 
        encoder->literal_tree_freq, 
        code,
        encoder->literal_tree_len
    );

    makeTree(
        MAX_DIST_TREE_ELEMENTS, 
        15, 
        encoder->dist_tree_freq, 
        code,
        encoder->dist_tree_len
    );
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder)
{
    _ASSERT(encoder != NULL);

    memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void OptimalEncoderReset(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

    encoder->recording_bitbuf        = 0;
    encoder->recording_bitcount     = 0;
    encoder->recording_bufptr       = encoder->lit_dist_buffer;

    context->window_size            = WINDOW_SIZE;
    context->bufpos                    = context->window_size;
    context->bufpos_end             = context->bufpos;

    DeflateInitRecordingTables(
        encoder->recording_literal_tree_len,
        encoder->recording_literal_tree_code, 
        encoder->recording_dist_tree_len,
        encoder->recording_dist_tree_code
    );

    // clear the search table
    memset(
        encoder->search_tree_root,
        0, 
        sizeof(encoder->search_tree_root)
    );

    encoder->next_tree_update = FIRST_TREE_UPDATE;

    initOptimalEstimates(context);
    OptimalEncoderZeroFrequencyCounts(encoder);
}


BOOL OptimalEncoderInit(t_encoder_context *context)
{
    context->optimal_encoder = (t_optimal_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_optimal_encoder));

    if (context->optimal_encoder == NULL)
        return FALSE;

    OptimalEncoderReset(context);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdblock.c ===
//
// stdblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
    slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_literal_tree_left[slot]; \
            else \
                slot = encoder->recording_literal_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
    slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_dist_tree_left[slot]; \
            else \
                slot = encoder->recording_dist_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
    read_bitbuf >>= count; \
    read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
    if (read_bitcount <= 0) \
    { \
        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
        read_bitcount += 8; \
        if (read_bitcount <= 0) \
        { \
            read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
            read_bitcount += 8; \
        } \
    }


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
    _ASSERT(encoder->literal_tree_len[element] != 0); \
    outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
    _ASSERT(encoder->dist_tree_len[element] != 0); \
    outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL StdEncoderOutputDynamicBlock(t_encoder_context *context)
{
    unsigned long    read_bitbuf;
    int                read_bitcount;
    byte *            read_bufptr;
    t_std_encoder *encoder = context->std_encoder;

    if (context->state == STATE_NORMAL)
    {
        //
        // If we haven't started to output a block yet
        //
        read_bufptr     = encoder->lit_dist_buffer;
        read_bitbuf        = 0;
        read_bitcount    = -16;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        context->outputting_block_bitbuf        = read_bitbuf;
        context->outputting_block_bitcount        = read_bitcount;
        context->outputting_block_bufptr        = read_bufptr;

        outputBits(context, 1, 0); // "final" block flag
        outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

        context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
    }

    if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
    {
        //
        // Make sure there is enough room to output the entire tree structure at once
        //
        if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
        {
            _ASSERT(0); // not enough room to output tree structure, fatal error!
            return FALSE;
        }

        outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

        context->state = STATE_OUTPUTTING_BLOCK;
    }

    _ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

    // load state into local variables
    read_bufptr        = context->outputting_block_bufptr;
    read_bitbuf        = context->outputting_block_bitbuf;
    read_bitcount    = context->outputting_block_bitcount;

    // output literals
    while (context->outputting_block_current_literal < context->outputting_block_num_literals)
    {
        int literal;

        // break when we get near the end of our output buffer
        if (context->output_curpos >= context->output_near_end_threshold)
            break;

        DECODE_LITERAL(literal);
        DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
        CHECK_MORE_READBUF();

        if (literal < NUM_CHARS)
        {
            // it's a char
            OUTPUT_LITERAL(literal);
        }
        else
        {
            // it's a match
            int len_slot, pos_slot, extra_pos_bits;

            // literal == len_slot + (NUM_CHARS+1)
            _ASSERT(literal != END_OF_BLOCK_CODE);

            OUTPUT_LITERAL(literal);

            len_slot = literal - (NUM_CHARS+1);

            //
            // extra_length_bits[len_slot] > 0 when len_slot >= 8
            // (except when length is MAX_MATCH).
            //
            if (len_slot >= 8)
            {
                int extra_bits = g_ExtraLengthBits[len_slot];

                if (extra_bits > 0)
                {
                    unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

                    outputBits(context, extra_bits, extra_data);
                    
                    DUMP_READBUF_BITS(extra_bits);
                    CHECK_MORE_READBUF();
                }
            }

            DECODE_POS_SLOT(pos_slot);
            DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
            CHECK_MORE_READBUF();

            _ASSERT(pos_slot < 30);

            OUTPUT_DIST_SLOT(pos_slot);

            extra_pos_bits = g_ExtraDistanceBits[pos_slot];

            if (extra_pos_bits > 0)
            {
                unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

                outputBits(context, extra_pos_bits, extra_data);

                DUMP_READBUF_BITS(extra_pos_bits);
                CHECK_MORE_READBUF();
            }
        }

        context->outputting_block_current_literal++;
    }

    // did we output all of our literals without running out of output space?
    if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
    {
        // output the code signifying end-of-block
        OUTPUT_LITERAL(END_OF_BLOCK_CODE);

        // reset state
        context->state = STATE_NORMAL;
    }
    else
    {
        context->outputting_block_bitbuf    = read_bitbuf;
        context->outputting_block_bitcount    = read_bitcount;
        context->outputting_block_bufptr    = read_bufptr;
        context->state                        = STATE_OUTPUTTING_BLOCK;
    }

    return TRUE;
}


//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL StdEncoderOutputBlock(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

    //
    // The tree creation routines cannot handle this overflow
    //
    _ASSERT(context->outputting_block_num_literals < 65536);

    if (context->state == STATE_NORMAL)
    {
        //
        // Start outputting literals and distances from the beginning
        //
        context->outputting_block_current_literal = 0;
    
        //
        // Nothing to output?  Then return
        //
        if (context->outputting_block_num_literals == 0)
            return TRUE;

        // make decoding table so that we can decode recorded items
        makeTable(
            MAX_LITERAL_TREE_ELEMENTS,
            REC_LITERALS_DECODING_TABLE_BITS,
            encoder->recording_literal_tree_len,
            encoder->recording_literal_tree_table,
            encoder->recording_literal_tree_left,
            encoder->recording_literal_tree_right
        );

        makeTable(
            MAX_DIST_TREE_ELEMENTS,
            REC_DISTANCES_DECODING_TABLE_BITS,
            encoder->recording_dist_tree_len,
            encoder->recording_dist_tree_table,
            encoder->recording_dist_tree_left,
            encoder->recording_dist_tree_right
        );

//        NormaliseFrequencies(context->literal_tree_freq, context->dist_tree_freq);
//context->dist_tree_freq[30] = 0;
//context->dist_tree_freq[31] = 0;

        // now make the trees used for encoding
        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            15, 
            encoder->literal_tree_freq, 
            encoder->literal_tree_code,
            encoder->literal_tree_len
        );

        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            15, 
            encoder->dist_tree_freq, 
            encoder->dist_tree_code,
            encoder->dist_tree_len
        );

//GenerateTable("g_FastEncoderLiteralTree", MAX_LITERAL_TREE_ELEMENTS, context->literal_tree_len, context->literal_tree_code);
//GenerateTable("g_FastEncoderDistanceTree", MAX_DIST_TREE_ELEMENTS, context->dist_tree_len, context->dist_tree_code);
    }

    //
    // Try outputting as a dynamic block
    //
    if (StdEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
           encoder->recording_bufptr           = context->std_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

        context->outputting_block_num_literals = 0;

        // make sure there are no zero frequency items
        NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

        // make tree for recording new items
        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            RECORDING_DIST_MAX_CODE_LEN,
            encoder->dist_tree_freq, 
            encoder->recording_dist_tree_code, 
            encoder->recording_dist_tree_len
        );

        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            RECORDING_LIT_MAX_CODE_LEN,
            encoder->literal_tree_freq, 
            encoder->recording_literal_tree_code, 
            encoder->recording_literal_tree_len
        );

        StdEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\output.c ===
/*
 * output.c
 *
 * General outputting routines
 */
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Output an element from the pre-tree
//
#define OUTPUT_PRETREE_ELEMENT(element) \
    _ASSERT(pretree_len[element] != 0); \
    outputBits(context, pretree_len[element], pretree_code[element]);


//
// Output the tree structure for a dynamic block
//
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len)
{
    int        hdist, hlit, combined_tree_elements, i, pass;
    USHORT    pretree_freq[NUM_PRETREE_ELEMENTS*2];
    USHORT    pretree_code[NUM_PRETREE_ELEMENTS];
    byte    pretree_len[NUM_PRETREE_ELEMENTS];

    //
    // combined literal + distance length code array for outputting the trees
    // in compressed form
    //
    // +3 is so we can overflow the array when performing run length encoding
    // (dummy values are inserted at the end so that run length encoding fails
    // before falling off the end of the array)
    //
    BYTE    lens[MAX_LITERAL_TREE_ELEMENTS + MAX_DIST_TREE_ELEMENTS + 3];

    //
    // Calculate HDIST
    //
    for (hdist = MAX_DIST_TREE_ELEMENTS - 1; hdist >= 1; hdist--)
    {
        if (dist_tree_len[hdist] != 0)
            break;
    }

    hdist++;

    //
    // Calculate HLIT
    //
    for (hlit = MAX_LITERAL_TREE_ELEMENTS - 1; hlit >= 257; hlit--)
    {
        if (literal_tree_len[hlit] != 0)
            break;
    }

    hlit++;

    //
    // Now initialise the array to have all of the hlit and hdist codes
    // in it
    //
    combined_tree_elements = hdist + hlit;

    memcpy(lens, literal_tree_len, hlit);
    memcpy(&lens[hlit], dist_tree_len, hdist);

    //
    // Stick in some dummy values at the end so that we don't overflow the 
    // array when comparing
    //
    for (i = combined_tree_elements; i < sizeof(lens); i++)
        lens[i] = 255;

    for (i = 0; i < NUM_PRETREE_ELEMENTS; i++)
        pretree_freq[i] = 0;

    //
    // Output the bitlengths in compressed (run length encoded) form.
    //
    // Make two passes; on the first pass count the various codes, create
    // the tree and output it, on the second pass output the codes using
    // the tree.
    //
    for (pass = 0; pass < 2; pass++)
    {
        int        cur_element;

        // are we outputting during this pass?
        BOOL    outputting = (pass == 1); 

        cur_element = 0;

        while (cur_element < combined_tree_elements)
        {
            int curlen = lens[cur_element];
            int run_length;

            //
            // See how many consecutive elements have the same value
            //
            // This won't run off the end of the array; it will hit the -1's
            // we stored there
            //
            for (run_length = cur_element+1; lens[run_length] == curlen; run_length++)
                ;

            run_length -= cur_element;

            //
            // For non-zero codes need 4 identical in a row (original code
            // plus 3 repeats).  We decrement the run_length by one if the
            // code is not zero, since we don't count the first (original)
            // code in this case.
            //
            // For zero codes, need 3 zeroes in a row.
            //
            if (curlen != 0)
                run_length--;

            if (run_length < 3)
            {
                if (outputting)
                {
                    OUTPUT_PRETREE_ELEMENT(curlen);
                }
                else
                    pretree_freq[curlen]++;

                cur_element++;
            }
            else 
            {
                //
                // Elements with zero values are encoded specially
                //
                if (curlen == 0)
                {
                    //
                    // Do we use code 17 (3-10 repeated zeroes) or 
                    // code 18 (11-138 repeated zeroes)?
                    //
                    if (run_length <= 10)
                    {
                        // code 17
                        if (outputting)
                        {
                            OUTPUT_PRETREE_ELEMENT(17);
                            outputBits(context, 3, run_length - 3);
                        }
                        else
                        {
                            pretree_freq[17]++;
                        }
                    }
                    else
                    {
                        // code 18
                        if (run_length > 138)
                            run_length = 138;

                        if (outputting)
                        {
                            OUTPUT_PRETREE_ELEMENT(18);
                            outputBits(context, 7, run_length - 11);
                        }
                        else
                        {
                            pretree_freq[18]++;
                        }
                    }  

                    cur_element += run_length;
                }
                else
                {
                    //
                    // Number of lengths actually encoded.  This may end up 
                    // being less than run_length if we have a run length of
                    // 7 (6 + 1 [which cannot be encoded with a code 16])
                    //
                    int run_length_encoded = 0;

                    // curlen != 0

                    // can output 3...6 repeats of a non-zero code, so split
                    // longer runs into short ones (if possible)

                    // remember to output the code itself first!
                    if (outputting)
                    {
                        OUTPUT_PRETREE_ELEMENT(curlen);

                        while (run_length >= 3)
                        {
                            int this_run = (run_length <= 6) ? run_length : 6;

                            OUTPUT_PRETREE_ELEMENT(16);
                            outputBits(context, 2, this_run - 3);

                            run_length_encoded += this_run;
                            run_length -= this_run;
                        }
                    }
                    else
                    {
                        pretree_freq[curlen]++;

                        while (run_length >= 3)
                        {
                            int this_run = (run_length <= 6) ? run_length : 6;

                            pretree_freq[16]++;

                            run_length_encoded += this_run;
                            run_length -= this_run;
                        }
                    }

                    // +1 for the original code itself
                    cur_element += (run_length_encoded+1);
                }
            }
        }

        //
        // If this is the first pass, create the pretree from the
        // frequency data and output it, as well as the values of
        // HLIT, HDIST, HDCLEN (# pretree codes used)
        //
        if (pass == 0)
        {
            int hclen;

            makeTree(
                NUM_PRETREE_ELEMENTS,
                7, 
                pretree_freq, 
                pretree_code,
                pretree_len
            );

            //
            // Calculate HCLEN
            //
            for (hclen = NUM_PRETREE_ELEMENTS-1; hclen >= 4; hclen--)
            {
                if (pretree_len[ g_CodeOrder[hclen] ] != 0)
                    break;
            }
            
            hclen++;

            //
            // Dynamic block header
            //
            outputBits(context, 5, hlit - 257);
            outputBits(context, 5, hdist - 1);
            outputBits(context, 4, hclen - 4);

            for (i = 0; i < hclen; i++)
            {
                outputBits(context, 3, pretree_len[g_CodeOrder[i]]);
            }
        }
    }
}


//
// bitwise i/o
//
void flushOutputBitBuffer(t_encoder_context *context)
{
    if (context->bitcount > 0)
    {
        int prev_bitcount = context->bitcount;
            
        outputBits(context, 16 - context->bitcount, 0);

        // backtrack if we have to; ZIP is byte aligned, not 16-bit word aligned
        if (prev_bitcount <= 8)
            context->output_curpos--;
    }
}


//
// Does not check for output overflow, so make sure to call checkOutputOverflow()
// often enough!
//
void outputBits(t_encoder_context *context, int n, int x)
{
    _ASSERT(context->output_curpos < context->output_endpos-1);
    _ASSERT(n > 0 && n <= 16);

    context->bitbuf |= (x << context->bitcount);
    context->bitcount += n;

    if (context->bitcount >= 16)                     
    {   
        *context->output_curpos++ = (BYTE) context->bitbuf;
        *context->output_curpos++ = (BYTE) (context->bitbuf >> 8);

        context->bitbuf >>= 16;
        context->bitcount -= 16;                         
    } 
}


// initialise the bit buffer
void InitBitBuffer(t_encoder_context *context)
{
    context->bitbuf        = 0;
    context->bitcount    = 0;
}


void OutputBlock(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    
    // we never call OutputBlock() with the fast encoder
    _ASSERT(context->fast_encoder == NULL);

    if (context->std_encoder != NULL)
        StdEncoderOutputBlock(context);
    else if (context->optimal_encoder != NULL)
        OptimalEncoderOutputBlock(context);
}


void FlushRecordingBuffer(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    _ASSERT(context->fast_encoder == NULL); // fast encoder does not record

    if (context->std_encoder != NULL)
    {
        *context->std_encoder->recording_bufptr++ = (BYTE) context->std_encoder->recording_bitbuf; 
        *context->std_encoder->recording_bufptr++ = (BYTE) (context->std_encoder->recording_bitbuf >> 8); 
    }
    else if (context->optimal_encoder != NULL)
    {
        *context->optimal_encoder->recording_bufptr++ = (BYTE) context->optimal_encoder->recording_bitbuf; 
        *context->optimal_encoder->recording_bufptr++ = (BYTE) (context->optimal_encoder->recording_bitbuf >> 8); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optfmtch.c ===
/*
 * optfmtch.c
 *
 * Match finder for the optimal parser
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#define VERIFY_SEARCH_CODE(routine_name) \
{ \
    int debug_search; \
    for (debug_search = 0; debug_search < clen; debug_search++) \
    { \
        if (window[ptr+debug_search] != window[BufPos+debug_search]) \
        { \
            _RPT2( \
                _CRT_WARN, \
                routine_name \
                " char mismatch @%3d (clen=%d)\n", \
                debug_search, clen); \
            \
            _RPT3( \
                _CRT_WARN, \
                " ptr=%8d, bufpos=%8d, end_pos=%8d\n\n", \
                ptr, BufPos, end_pos); \
            _ASSERT(0); \
        } \
    } \
}


#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
    _ASSERT(window[BufPos] == window[ptr]); \
    _ASSERT(window[BufPos+1] == window[ptr+1]);


/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */
int optimal_find_match(t_encoder_context *context, long BufPos)
{
    ULONG        ptr;
    ULONG       a, b;
    t_search_node *small_ptr, *big_ptr;
    t_search_node *left = context->optimal_encoder->search_left;
    t_search_node *right = context->optimal_encoder->search_right;
    t_match_pos *matchpos_table = context->optimal_encoder->matchpos_table;
    BYTE *window = context->optimal_encoder->window;
    ULONG       end_pos;
    int         val; /* must be signed */
    int         clen;
    int         same;
    int         match_length;
    int         small_len, big_len;
    USHORT      tree_to_use;

    /*
     * Retrieve root node of tree to search, and insert current node at
     * the root.
     */
    tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
    
    ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
    context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

    /*
     * end_pos is the furthest location back we will search for matches 
     *
     * Remember that our window size is reduced by 3 bytes because of
     * our repeated offset codes.
     *
     * Since BufPos starts at WINDOW_SIZE when compression begins,
     * end_pos will never become negative.  
     */
    end_pos = BufPos - (WINDOW_SIZE-4);

    /*
     * Root node is either NULL, or points to a really distant position.
     */
    if (ptr <= end_pos)
    {
        left[BufPos] = right[BufPos] = 0;
        return 0;
    }

    /*
     * confirmed length (no need to check the first clen chars in a search)
     *
     * note: clen is always equal to min(small_len, big_len)
     */
    clen            = 2;

    /*
     * current best match length
     */
    match_length    = 2;

    /*
     * longest match which is < our string
     */
    small_len       = 2;

    /*
     * longest match which is > our string
     */
    big_len         = 2;

#ifdef _DEBUG
    VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

    /*
     * pointers to nodes to check
     */
    small_ptr             = &left[BufPos];
    big_ptr               = &right[BufPos];

    do
    {
        /* compare bytes at current node */
        same = clen;

#ifdef _DEBUG
        VERIFY_SEARCH_CODE("optimal_findmatch()")
#endif

        /* don't need to check first clen characters */
        a    = ptr + clen;
        b    = BufPos + clen;

        while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
        {
            /* don't exceed MAX_MATCH */
            if (++same >= MAX_MATCH)
                goto long_match;
        }

        if (val < 0)
        {
            if (same > big_len)
            {
                if (same > match_length)
                {
long_match:
                    do
                    {
                        matchpos_table[++match_length] = BufPos-ptr-1;
                    } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                    {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                    }
                }

                big_len = same;
                clen = min(small_len, big_len);
            }

            *big_ptr = (t_search_node) ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
        }
        else
        {
            if (same > small_len)
            {
                if (same > match_length)
                {
                    do
                    {
                        matchpos_table[++match_length] = BufPos-ptr-1;
                    } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                    {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                    }
                }

                small_len = same;
                clen = min(small_len, big_len);
            }
        
            *small_ptr = (t_search_node) ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
        }
    } while (ptr > end_pos); /* while we don't go too far backwards */

    *small_ptr = 0;
    *big_ptr   = 0;


end_bsearch:

    /*
     * If we have multiple search trees, we are already guaranteed
     * a minimum match length of 2 when we reach here.
     *
     * If we only have one tree, then we're not guaranteed anything.
     */
    if (match_length < MIN_MATCH)
        return 0;
    else
        return (long) match_length;
}


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos)
{
    long        ptr;
    ULONG       a,b;
    t_search_node *small_ptr, *big_ptr;
    t_search_node *left = context->optimal_encoder->search_left;
    t_search_node *right = context->optimal_encoder->search_right;
    BYTE *window = context->optimal_encoder->window;
    int         val;
    int         small_len, big_len;
    int         same;
    int         clen;
    USHORT      tree_to_use;

    tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
    ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
    context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

    if (ptr <= end_pos)
    {
        left[BufPos] = right[BufPos] = 0;
        return;
    }

    clen            = 2;
    small_len       = 2;
    big_len         = 2;

#ifdef _DEBUG
    VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
#endif

    small_ptr       = &left[BufPos];
    big_ptr         = &right[BufPos];

    do
    {
        same = clen;

        a    = ptr+clen;
        b    = BufPos+clen;

#ifdef _DEBUG
        VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
#endif

        while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
        {
            /*
             * Here we break on BREAK_LENGTH, not MAX_MATCH
             */
            if (++same >= BREAK_LENGTH) 
                break;
        }

        if (val < 0)
        {
            if (same > big_len)
            {
                if (same >= BREAK_LENGTH)
                {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                }

                big_len = same;
                clen = min(small_len, big_len);
            }
            
            *big_ptr = (t_search_node) ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
        }
        else
        {
            if (same > small_len)
            {
                if (same >= BREAK_LENGTH)
                {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                }

                small_len = same;
                clen = min(small_len, big_len);
            }

            *small_ptr = (t_search_node) ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
        }
   } while (ptr > end_pos);

    *small_ptr = 0;
    *big_ptr   = 0;
}


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos)
{
    ULONG   ptr;
    ULONG   left_node_pos;
    ULONG   right_node_pos;
    USHORT  tree_to_use;
    t_search_node *link;
    t_search_node *left = context->optimal_encoder->search_left;
    t_search_node *right = context->optimal_encoder->search_right;
    BYTE *window = context->optimal_encoder->window;

    /*
     * The root node of tree_to_use should equal BufPos, since that is
     * the most recent insertion into that tree - but if we never
     * inserted this string (because it was a near match or a long
     * string of zeroes), then we can't remove it.
     */
    tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);


    /*
     * If we never inserted this string, do not attempt to remove it
     */

    if (context->optimal_encoder->search_tree_root[tree_to_use] != BufPos)
        return;

    link = &context->optimal_encoder->search_tree_root[tree_to_use];

    /*
     * If the last occurence was too far away
     */
    if (*link <= end_pos)
    {
        *link = 0;
        left[BufPos] = right[BufPos] = 0;
        return;
    }

    /*
     * Most recent location of these chars
     */
    ptr             = BufPos;

    /*
     * Most recent location of a string which is "less than" it
     */
    left_node_pos   = left[ptr];

    if (left_node_pos <= end_pos)
        left_node_pos = left[ptr] = 0;

    /*
     * Most recent location of a string which is "greater than" it
     */
    right_node_pos  = right[ptr];

    if (right_node_pos <= end_pos)
        right_node_pos = right[ptr] = 0;

    for (;;)
    {
        /*
         * If left node position is greater than right node position
         * then follow the left node, since that is the more recent
         * insertion into the tree.  Otherwise follow the right node.
         */
        if (left_node_pos > right_node_pos)
        {
            /*
             * If it's too far away, then store that it never happened
             */
            if (left_node_pos <= end_pos)
                left_node_pos = 0;

            ptr = *link = (t_search_node) left_node_pos;

            if (!ptr)
                break;

            left_node_pos   = right[ptr];
            link            = &right[ptr];
        }
        else
        {
            /*
             * If it's too far away, then store that it never happened
             */
            if (right_node_pos <= end_pos)
                right_node_pos = 0;

            ptr = *link = (t_search_node) right_node_pos;

            if (!ptr) 
                break;

            right_node_pos  = left[ptr];
            link            = &left[ptr];
        }
    }
}


void removeNodes(t_encoder_context *context)
{
    long i;

    // remove the most recent insertions into the hash table, since we had invalid data 
    // sitting at the end of the window
    for (i = 0; i <= BREAK_LENGTH; i++)
    {
        if (context->bufpos-i-1 < WINDOW_SIZE)
            break;

        optimal_remove_node(context, context->bufpos-i-1, context->bufpos-WINDOW_SIZE+BREAK_LENGTH);
    }
}


//
// Reinsert the tree nodes we removed previously
//
void reinsertRemovedNodes(t_encoder_context *context)
{
    long j;

    for (j = BREAK_LENGTH; j > 0; j--)
    {
        if (context->bufpos - j > WINDOW_SIZE)
        {
            optimal_insert(
                context,
                context->bufpos - j,
                context->bufpos - j - WINDOW_SIZE + 4
            );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stddebug.c ===
/*
 * stddebug.c
 *
 * Debugging stubs for std encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
// verify all hash chains
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
    int i;
    const t_search_node *lookup = context->std_encoder->lookup;
    const t_search_node *prev = context->std_encoder->prev;
    const BYTE *window = context->std_encoder->window;

    for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
    {
        t_search_node where = lookup[i];
        t_search_node next_where;

        while (where != 0 && bufpos - where < WINDOW_SIZE)
        {
            int hash = STD_ENCODER_RECALCULATE_HASH(where);

            _ASSERT(hash == i);

            next_where = prev[where & WINDOW_MASK];

            if (bufpos - next_where >= WINDOW_SIZE)
                break;

            _ASSERT(next_where < where);

            where = next_where;
        } 
    }
}


// verify that a particular hash chain is correct
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
    const t_search_node *lookup = context->std_encoder->lookup;
    const t_search_node *prev = context->std_encoder->prev;
    BYTE *window = context->std_encoder->window;
    t_search_node where;
    t_search_node next_where;
    int print = 0;

top:
    where = lookup[chain_number];

//    if (print)
//        printf("Verify chain %d\n", chain_number);

    while (where != 0 && bufpos - where < WINDOW_SIZE)
    {
        int hash = STD_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->std_encoder->window;

//        if (print)
//            printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

        if (hash != chain_number && print == 0)
        {
            print = 1;
            goto top;
        }

        _ASSERT(hash == chain_number);

        next_where = prev[where & WINDOW_MASK];

        if (bufpos - next_where >= WINDOW_SIZE)
            break;

        if (next_where >= where && print == 0)
        {
            print = 1;
            goto top;
        }

        _ASSERT(next_where < where);

        where = next_where;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdenc.h ===
/*
 * stdenc.h
 *
 * Defines for the standard encoder
 */

//
// Size of hash table for std encoder
//
#define STD_ENCODER_HASH_TABLE_SIZE				8192
#define STD_ENCODER_HASH_MASK					(STD_ENCODER_HASH_TABLE_SIZE-1)
#define STD_ENCODER_HASH_SHIFT					5

#define STD_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*STD_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << STD_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & STD_ENCODER_HASH_MASK)


//
// Maximum number of item we allow; this must be <= 65534, since this doesn't include
// freq[END_OF_BLOCK_CODE] = 1, which brings us to 65535; any more than this would make
// the frequency counts overflow, since they are stored in ushort's
//
// Note that this number does not affect the memory requirements in any way; that is
// determined by LIT_DIST_BUFFER_SIZE
//
// -8 for some slack (not really necessary)
//
#define STD_ENCODER_MAX_ITEMS				(65534-8)

//
// Size of the literal/distance buffer
//
#define STD_ENCODER_LIT_DIST_BUFFER_SIZE	32768

//
// Don't take a match 3 further away than this
// 4K seems a little close, but does do a marginally better job than 8K on 
// an 80K html file, so might as well leave it be
//
#define STD_ENCODER_MATCH3_DIST_THRESHOLD   4096


//
// Standard encoder context
//
typedef struct std_encoder
{
	// history window
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[STD_ENCODER_HASH_TABLE_SIZE];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    USHORT                  literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    USHORT                  dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	USHORT                  dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];
} t_std_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdenc.c ===
/*
 * stdenc.c
 *
 * Standard encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
    h = ((h) << STD_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
// Assertions check that we never attempt to insert near the end of the buffer
// (since our hash value is based on values at bufpos, bufpos+1, bufpos+2) and
// that our hash value is always valid for the bytes we are inserting.
//
#define INSERT_STRING(search,bufpos) \
{ \
    _ASSERT((bufpos + 2) < context->bufpos_end); \
    UPDATE_HASH(hash, window[bufpos+2]); \
    _ASSERT((unsigned int) STD_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & STD_ENCODER_HASH_MASK)); \
    search = lookup[hash & STD_ENCODER_HASH_MASK]; \
    lookup[hash & STD_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
    prev[bufpos & WINDOW_MASK] = (t_search_node) search; \
}


#define CHECK_FLUSH_RECORDING_BUFFER() \
    if (recording_bitcount >= 16) \
    { \
        *recording_bufptr++ = (BYTE) recording_bitbuf; \
        *recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
        recording_bitbuf >>= 16; \
        recording_bitcount -= 16; \
    }


#define OUTPUT_RECORDING_DATA(count,data) \
    recording_bitbuf |= ((data) << recording_bitcount); \
    recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[c]++; \
    _ASSERT(context->std_encoder->recording_literal_tree_len[c] != 0); \
    OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[c], context->std_encoder->recording_literal_tree_code[c]); \
    CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
    int pos_slot = POS_SLOT(match_pos); \
    int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
    int item = (NUM_CHARS+1) + len_slot; \
    int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
    int extra_len_bits = g_ExtraLengthBits[len_slot]; \
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
    _ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < STD_ENCODER_MAX_ITEMS); \
    _ASSERT(context->std_encoder->recording_literal_tree_len[item] != 0); \
    _ASSERT(context->std_encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    context->std_encoder->dist_tree_freq[pos_slot]++; \
    OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[item], context->std_encoder->recording_literal_tree_code[item]); \
    CHECK_FLUSH_RECORDING_BUFFER(); \
    if (extra_len_bits > 0) \
    { \
        OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
        CHECK_FLUSH_RECORDING_BUFFER(); \
    } \
    OUTPUT_RECORDING_DATA(context->std_encoder->recording_dist_tree_len[pos_slot], context->std_encoder->recording_dist_tree_code[pos_slot]); \
    CHECK_FLUSH_RECORDING_BUFFER(); \
    if (extra_dist_bits > 0) \
    { \
        OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
        CHECK_FLUSH_RECORDING_BUFFER(); \
    } \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
    *recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) StdEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


static void StdEncoderMoveWindows(t_encoder_context *context);

static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
);


void StdEncoderDeflate(
    t_encoder_context *    context, 
    int                 search_depth,
    int                    lazy_match_threshold,
    int                 good_length,
    int                 nice_length
)
{
    long            bufpos;
    unsigned int    hash;
    t_std_encoder * encoder = context->std_encoder;
    byte *            window = encoder->window;
    t_search_node *    prev = encoder->prev;
    t_search_node *    lookup = encoder->lookup;
    unsigned long    recording_bitbuf;
    int                recording_bitcount;
    byte *            recording_bufptr;
    byte *          end_recording_bufptr;

    // restore literal/match bitmap variables
    end_recording_bufptr    = &encoder->lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE-8];
    recording_bufptr        = encoder->recording_bufptr;
    recording_bitbuf        = encoder->recording_bitbuf;
    recording_bitcount      = encoder->recording_bitcount;
    bufpos                    = context->bufpos;

    VERIFY_HASHES(bufpos);

    //
    // Recalculate our hash
    //
    // One disadvantage of the way we do our hashing is that matches are not permitted in the last
    // few characters near bufpos_end.
    //
    hash = 0;
    UPDATE_HASH(hash, window[bufpos]);
    UPDATE_HASH(hash, window[bufpos+1]);

    while (bufpos < context->bufpos_end)
    {
        int                match_len;
        t_match_pos        match_pos = 0;
        t_match_pos        search;

        if (context->bufpos_end - bufpos <= 3)
        {
            // don't insert any strings when we get close to the end of the buffer,
            // since we will end up using corrupted hash values (the data after bufpos_end
            // is undefined, and those bytes would be swept into the hash value if we
            // calculated a hash at bufpos_end-2, for example, since our hash value is
            // build from 3 consecutive characters in the buffer).
            match_len = 0;
        }
        else
        {
            INSERT_STRING(search,bufpos);

            // find a match at what we'll call position X
            if (search != 0)
            {
                match_len = StdEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

                // truncate match if we're too close to the end of the buffer
                if (bufpos + match_len > context->bufpos_end)
                    match_len = context->bufpos_end - bufpos;
            }
            else
            {
                match_len = 0;
            }
        }

        if (match_len < MIN_MATCH)
        {
            // didn't find a match, so output unmatched char
            RECORD_CHAR(window[bufpos]);
            bufpos++;
        }
        else
        {
            // bufpos now points to X+1
            bufpos++;

            // is this match so good (long) that we should take it automatically without
            // checking X+1 ?
            if (match_len <= lazy_match_threshold)
            {
                int                next_match_len;
                t_match_pos        next_match_pos = 0;

                // sets search
                INSERT_STRING(search,bufpos);

                // no, so check for a better match at X+1
                if (search != 0)
                {
                    next_match_len = StdEncoderFindMatch(
                        window,
                        prev,
                        bufpos, 
                        search,
                        &next_match_pos,
                        match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
                    );
                
                    // truncate match if we're too close to the end of the buffer
                    // note: next_match_len could now be < MIN_MATCH
                    if (bufpos + next_match_len > context->bufpos_end)
                        next_match_len = context->bufpos_end - bufpos;
                }
                else
                {
                    next_match_len = 0;
                }

                // right now X and X+1 are both inserted into the search tree
                if (next_match_len > match_len)
                {
                    // since next_match_len > match_len, it can't be < MIN_MATCH here

                    // match at X+1 is better, so output unmatched char at X
                    RECORD_CHAR(window[bufpos-1]);

                    // now output match at location X+1
                    RECORD_MATCH(next_match_len, next_match_pos);

                    // insert remainder of second match into search tree
                    // 
                    // example: (*=inserted already)
                    //
                    // X      X+1               X+2      X+3     X+4
                    // *      *
                    //        nextmatchlen=3
                    //        bufpos
                    //
                    // If next_match_len == 3, we want to perform 2
                    // insertions (at X+2 and X+3).  However, first we must 
                    // inc bufpos.
                    //
                    bufpos++; // now points to X+2
                    match_len = next_match_len;
                    goto insert;
                }
                else
                {
                    // match at X is better, so take it
                    RECORD_MATCH(match_len, match_pos);

                    //
                    // Insert remainder of first match into search tree, minus the first
                    // two locations, which were inserted by the FindMatch() calls.
                    // 
                    // For example, if match_len == 3, then we've inserted at X and X+1
                    // already (and bufpos is now pointing at X+1), and now we need to insert 
                    // only at X+2.
                    //
                    match_len--;
                    bufpos++; // now bufpos points to X+2
                    goto insert;
                }
            }
            else /* match_length >= good_match */
            {
                // in assertion: bufpos points to X+1, location X inserted already
                    
                // first match is so good that we're not even going to check at X+1
                RECORD_MATCH(match_len, match_pos);

                // insert remainder of match at X into search tree
insert:
                if (context->bufpos_end - bufpos <= match_len)
                {
                    bufpos += (match_len-1);
                }
                else
                {
                    while (--match_len > 0)
                    {
                        t_match_pos ignore; // we're not interested in the search position

                        INSERT_STRING(ignore,bufpos);
                        bufpos++;
                    }
                }
            }
        }

        // literal buffer or distance buffer filled up (or close to filling up)?
        if (context->outputting_block_num_literals >= STD_ENCODER_MAX_ITEMS-4 ||
            recording_bufptr >= end_recording_bufptr)
        {
            // yes, then we must output a block
            _ASSERT(context->outputting_block_num_literals <= STD_ENCODER_MAX_ITEMS);

            // flush our recording matches bit buffer
            FLUSH_RECORDING_BITBUF();

            StdEncoderOutputBlock(context);

            // did we output the whole block?
            if (context->state != STATE_NORMAL)
                break;

            // we did output the whole block, so reset literal encoding
            recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
        }
    } /* end ... while (bufpos < bufpos_end) */

    _ASSERT(bufpos <= context->bufpos_end);

    // save recording state
    encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

    context->bufpos = bufpos;

    VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        StdEncoderMoveWindows(context);
}


static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
)
{
    const BYTE *    window_bufpos = &window[bufpos];
    long            earliest; // how far back we can look
    int                best_match = 0; // best match length found so far
    t_match_pos        l_match_pos = 0;

    _ASSERT(bufpos >= 0 && bufpos < 2*WINDOW_SIZE);
    _ASSERT(search < bufpos);
    _ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));

    earliest = bufpos - WINDOW_SIZE;
    _ASSERT(earliest >= 0);

    while (search > earliest)
    {
        _ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));
        _ASSERT(search < bufpos);

        if (window_bufpos[best_match] == window[search + best_match])
        {
            int j;

            for (j = 0; j < MAX_MATCH; j++)
            {
                if (window_bufpos[j] != window[search+j])
                    break;
            }
    
            if (j > best_match)
            {
                best_match    = j;
                l_match_pos    = search; // absolute position

                if (j > nice_length)
                    break;
            }
        }

        if (--cutoff == 0)
            break;

        search = (long) prev[search & WINDOW_MASK];
    }

    // turn l_match_pos into relative position
    l_match_pos = bufpos - l_match_pos - 1; 

    if (best_match == 3 && l_match_pos >= STD_ENCODER_MATCH3_DIST_THRESHOLD)
        return 0;

    _ASSERT(best_match < MIN_MATCH || l_match_pos < WINDOW_SIZE);
    *match_pos = l_match_pos;

    return best_match;
}


static void StdEncoderMoveWindows(t_encoder_context *context)
{
    if (context->bufpos >= 2*WINDOW_SIZE)
    {
        int        i;
        t_search_node *lookup = context->std_encoder->lookup;
        t_search_node *prev = context->std_encoder->prev;
        BYTE *window = context->std_encoder->window;

        VERIFY_HASHES(2*WINDOW_SIZE);

        memcpy(&window[0], &window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

        for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
        {
            long val = ((long) lookup[i]) - WINDOW_SIZE;
    
            if (val <= 0)
                lookup[i] = (t_search_node) 0;
            else
                lookup[i] = (t_search_node) val;
        }

        for (i = 0; i < WINDOW_SIZE; i++)
        {
            long val = ((long) prev[i]) - WINDOW_SIZE;
    
            if (val <= 0)
                prev[i] = (t_search_node) 0;
            else
                prev[i] = (t_search_node) val;
        }

#ifdef FULL_DEBUG
        memset(&window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

        VERIFY_HASHES(2*WINDOW_SIZE);

        
        context->bufpos = WINDOW_SIZE;
        context->bufpos_end = context->bufpos;
    }
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder)
{
    _ASSERT(encoder != NULL);

      memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void StdEncoderReset(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

    _ASSERT(encoder != NULL);
    memset(encoder->lookup, 0, sizeof(encoder->lookup));

    context->window_size        = WINDOW_SIZE;
    context->bufpos                = context->window_size;
    context->bufpos_end         = context->bufpos;

    encoder->recording_bitbuf    = 0;
    encoder->recording_bitcount = 0;
    encoder->recording_bufptr   = encoder->lit_dist_buffer;

    DeflateInitRecordingTables(
        encoder->recording_literal_tree_len,
        encoder->recording_literal_tree_code, 
        encoder->recording_dist_tree_len,
        encoder->recording_dist_tree_code
    );

    StdEncoderZeroFrequencyCounts(encoder);
}


BOOL StdEncoderInit(t_encoder_context *context)
{
    context->std_encoder = (t_std_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_std_encoder));

    if (context->std_encoder == NULL)
        return FALSE;

    StdEncoderReset(context);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\md5filt\authfilt.h ===
#ifndef _AUTHFILT_H_
#define _AUTHFILT_H_

BOOL
SubAuthGetFilterVersion(
    VOID
);

DWORD
SubAuthHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
);

BOOL
SubAuthTerminateFilter(
    DWORD                       dwFlags
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\types.h ===
//
// types.h
//
// Type definitions
//
#ifndef _DEFLATE_TYPES_H
#define _DEFLATE_TYPES_H

#include <windows.h>
#include <wtypes.h>
#include "api_int.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\md5filt\md5filt.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    md5filt.cxx

Abstract:

    Wrapper module which will call either new Digest SSP code or old
    (subauth) implementation.
    
    Except for init/cleanup; in this case both are called

--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

};

#include <iisfiltp.h>
#include "authfilt.h"
#include "sspdigest.h"

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
/*++

Routine Description:

    Get filter version (calls all initialization code)

Arguments:

    pVer - Version

Returns:

    TRUE if success, FALSE if failure

--*/
{
    if ( !SubAuthGetFilterVersion() )
    {
        return FALSE;
    } 
    
    if ( !SSPGetFilterVersion() )
    {
        //
        // The Digest SSP isn't installed on NT yet
        //
        
        // return FALSE;
    }

    //
    // Set the version of the filter
    //
    pVer->dwFilterVersion = MAKELONG(0, 2);//2.0
    
    //
    // Set the description of the filter 
    //
    strcpy( pVer->lpszFilterDesc, "Digest Authentication, version 2.0");

    //
    //set the flag of the filter
    //
    pVer->dwFlags = (SF_NOTIFY_ACCESS_DENIED        | 
                     SF_NOTIFY_END_OF_NET_SESSION   |
                     SF_NOTIFY_ORDER_HIGH           |
                     SF_NOTIFY_AUTHENTICATIONEX     |
                     SF_NOTIFY_LOG );

    return TRUE;
}

BOOL
WINAPI
TerminateFilter(
    DWORD               dwFlags
    )
/*++

Routine Description:

    Do filter cleanup

Arguments:

    None

Returns:

    TRUE if success, FALSE if failure

--*/
{
    SSPTerminateFilter( dwFlags );
    
    SubAuthTerminateFilter( dwFlags );
    
    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
)
/*++

Routine Description:

    The filters notification routine

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    BOOL                fUseSSP = FALSE;

    //
    // Joy.  We need to figure out what Digest path to execute for this
    // request.
    //
    
    if ( !pfc->ServerSupportFunction( pfc,
                                      SF_REQ_GET_PROPERTY,
                                      (LPVOID)&fUseSSP,
                                      (UINT)SF_PROPERTY_DIGEST_SSP_ENABLED,
                                      NULL ) )
    {
        return SF_STATUS_REQ_ERROR;
    }
    
    //
    // Choose the right digest support to use.
    //
    
    if ( fUseSSP )
    {
        return SSPHttpFilterProc( pfc,
                                  notificationType,
                                  pvNotification );
    }
    else
    {
        return SubAuthHttpFilterProc( pfc,
                                      notificationType,
                                      pvNotification );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\md5filt\sspdigest.h ===
#ifndef _SSPDIGEST_H_
#define _SSPDIGEST_H_

BOOL
SSPGetFilterVersion(
    VOID
);

DWORD
SSPHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
);

HRESULT
SSPOnAccessDenied(
    HTTP_FILTER_CONTEXT *       pfc,
    VOID *                      pvNotification
);

HRESULT
SSPOnAuthenticationEx(
    HTTP_FILTER_CONTEXT *       pfc,
    VOID *                      pvNotification
);

BOOL
SSPAllocateFilterContext(
    HTTP_FILTER_CONTEXT *       pfc
);

BOOL
SSPTerminateFilter(
    DWORD                       dwFlags
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\md5filt\authfilt.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    authfilt.cxx

Abstract:

    This module is an ISAPI Authentication Filter.

--*/

#ifdef __cplusplus
extern "C" {
#endif


# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
#if 1 // DBCS
# include <mbstring.h>
#endif
#include <lmcons.h>
#include <lmjoin.h>

#ifdef __cplusplus
};
#endif


# include <iis64.h>
# include <inetcom.h>
# include <inetinfo.h>

//
//  System include files.
//

# include "dbgutil.h"
#include <tcpdll.hxx>
#include <tsunami.hxx>


extern "C" {

#include <tchar.h>

//
//  Project include files.
//

#include <time.h>
#include <w3svc.h>
#include <iisfiltp.h>
#include <sspi.h>

} // extern "C"

#include <iismap.hxx>
#include <mapmsg.h>
#include <lonsi.hxx>
#include "authfilt.h"

#define RANDOM_SIZE 8 //# of random bytes at beginning of nonce
#define TIMESTAMP_SIZE 12 //size of timestamp in nonce
#define MD5_HASH_SIZE 16 //MD5 hash size
#define NONCE_SIZE (2*RANDOM_SIZE + TIMESTAMP_SIZE + 2*MD5_HASH_SIZE)

typedef struct _DIGEST_CONTEXT {
    BOOL    fStale;
    DWORD   tLastNonce;
    CHAR    achNonce[NONCE_SIZE + 1];
    CHAR    achUserName[SF_MAX_USERNAME*2+sizeof(" ( )")];
} DIGEST_CONTEXT, *PDIGEST_CONTEXT;

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAMES
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME,
    MD5_AUTH_URI,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_DIGEST,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_QOP,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_LAST,
};

#define NONCE_GRANULARITY   512

#define MAX_URL_SIZE        512

//
//  Globals
//

HCRYPTPROV g_hCryptProv;

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisMD5FiltGuid, 
0x784d8933, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAME
//

PSTR MD5_AUTH_NAMES[] = {
    "username",
    "uri",
    "realm",
    "nonce",
    "response",
    "algorithm",
    "digest",
    "opaque",
    "qop",
    "cnonce",
    "nc"
};

//
//  Private prototypes
//


VOID
LogMd5Event(
    DWORD dwId,
    WORD  wType,
    LPSTR pszUser,
    LPSTR pszRealm
    )
/*++

Routine Description:

    Log an event

Arguments:

    dwId - event ID ( from iismap\mapmsg.h )
    wType - event type
    pszUser - user name
    pszRealm - realm

Return Value:

    Nothing

--*/
{
    LPCTSTR pA[2];

    pA[0] = pszUser;
    pA[1] = pszRealm;

    ReportIisMapEvent( wType,
            dwId,
            2,
            pA );
}


VOID safe_strcpy( LPSTR pszDest,
                  LPSTR pszSource )
/*++

Routine Description:

    strcpy used to make sure that GetLanGroupDomaiName() is thread-safe

Arguments:

    pszDest - pointer to destination buffer
    pszSource - pointer to source buffer

Return Value:

    Nothing

--*/

{
    while ( *pszSource )
    {
        *pszDest++ = *pszSource++;
    }
    *pszDest = '\0';
}

VOID
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}


BOOL HashData( BYTE *pbData,
               DWORD cbData,
               BYTE *pbHash )
/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    pbData - data to hash
    cbData - size of data pointed to by pbData
    pbHash - buffer that receives hash; is assumed to be big enough to contain MD5 hash

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    HCRYPTHASH hHash = NULL;

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptCreateHash() failed : 0x%x\n", GetLastError()));
        return FALSE;
    }

    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptHashData() failed : 0x%x\n", GetLastError()));
        
        CryptDestroyHash( hHash );
        return FALSE;
    }

    DWORD cbHash = MD5_HASH_SIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHash,
                             &cbHash,
                             0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptGetHashParam() failed : 0x%x\n", GetLastError()));

        CryptDestroyHash( hHash );
        return FALSE;
    }

    CryptDestroyHash( hHash );
    return TRUE;
}


BOOL IsExpiredNonce( CHAR *pszRequestNonce,
                     CHAR *pszPresentNonce )
/*++

Routine Description:

    Checks whether nonce is expired or not by looking at the timestamp on the nonce
    that came in with the request and comparing it with the timestamp on the latest nonce

Arguments:

    pszRequestNonce - nonce that came in with request
    pszPresentNonce - latest nonce

Return Value:

    TRUE if nonce has expired, FALSE if not

--*/
{
    //
    // Timestamp is after first 2*RANDOM_SIZE bytes of nonce; also, note that
    // timestamp is time() mod NONCE_GRANULARITY, so all we have to do is simply
    // compare for equality to check that the request nonce hasn't expired
    //
    if ( memcmp( pszPresentNonce + 2*RANDOM_SIZE, 
                 pszRequestNonce + 2*RANDOM_SIZE,
                 TIMESTAMP_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Nonce is expired.\n"));
        return TRUE;
    }

    return FALSE;
}

BOOL IsWellFormedNonce( CHAR *pszNonce )
/*++

Routine Description:

    Checks whether a nonce is "well-formed" by checking hash value, length etc 
    

Arguments:

    pszNonce - nonce to be checked

Return Value:

    TRUE if nonce is well-formed, FALSE if not

--*/

{
    if ( !pszNonce || ( strlen(pszNonce) != NONCE_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Nonce is not well-formed\n"));
        return FALSE;
    }

    //
    //Format of nonce : <random bytes><time stamp><hash of (secret,random bytes,time stamp)>
    // 
    DWORD dwSecretLen = sizeof("IISMD5") - 1;
    BYTE abBuffer[2*RANDOM_SIZE + TIMESTAMP_SIZE + sizeof("IISMD5") - 1];
    BYTE abHash[MD5_HASH_SIZE];
    CHAR achAsciiHash[2*MD5_HASH_SIZE + 1];

    DWORD cbBuffer = 2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen;

    memcpy( abBuffer, "IISMD5", dwSecretLen );
    memcpy( abBuffer + dwSecretLen, pszNonce, 2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( !HashData( abBuffer, 
                    2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen,
                    abHash ) )
    {
        return FALSE;
    }
    ToHex( abHash, MD5_HASH_SIZE, achAsciiHash );

    if ( memcmp( achAsciiHash,
                 pszNonce + 2*RANDOM_SIZE + TIMESTAMP_SIZE,
                 2*MD5_HASH_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Nonce is not well-formed\n"));
        return FALSE;
    }

    return TRUE;
                    
}

BOOL 
GenerateNonce( 
    HTTP_FILTER_CONTEXT *      pfc
)
/*++

Routine Description:

    Generate nonce to be stored in user filter context. Nonce is

    <ASCII rep of Random><Time><ASCII of MD5(Secret:Random:Time)>

    Random = <8 random bytes>
    Time = <16 bytes, reverse string rep of result of time() call>
    Secret = 'IISMD5'

Arguments:

    pfc - filter context

Return Value:

    TRUE if success, FALSE if error

--*/
{
    PDIGEST_CONTEXT pC = (PDIGEST_CONTEXT)pfc->pFilterContext;
    DWORD cbNonce = 0;
    DWORD tNow = (DWORD)(time(NULL)/NONCE_GRANULARITY);

    if ( !pC )
    {
        return FALSE;
    }

    //
    // If nonce has timed out, generate a new one
    //
    if ( pC->tLastNonce < tNow )
    {
        DWORD dwSecretLen = sizeof("IISMD5")  - 1;
        BYTE abTempBuffer[ 2*RANDOM_SIZE + TIMESTAMP_SIZE + sizeof("IISMD5") - 1 ];
        DWORD cbTemp = 0;
        BYTE abDigest[MD5_HASH_SIZE];
        BYTE abRandom[RANDOM_SIZE];
        CHAR achAsciiDigest[2 * MD5_HASH_SIZE + 1];
        CHAR achAsciiRandom[2 * RANDOM_SIZE + 1];


        pC->tLastNonce = tNow;

        //
        // First, random bytes
        //
        if ( !CryptGenRandom( g_hCryptProv,
                              RANDOM_SIZE,
                              abRandom ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CryptGenRandom() failed : 0x%x\n", GetLastError()));
            return FALSE;
        }
        
        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //
        ToHex( abRandom, RANDOM_SIZE, achAsciiRandom );
        memcpy( pC->achNonce + cbNonce, achAsciiRandom, 2 * RANDOM_SIZE );

        cbNonce += 2*RANDOM_SIZE;

        //
        // Next, reverse string representation of current time; pad with zeros if necessary
        //
        while ( tNow )
        {
            pC->achNonce[cbNonce++] = (CHAR)('0' + tNow % 10);
            tNow /= 10;
        }

        DBG_ASSERT( cbNonce < 2*RANDOM_SIZE + TIMESTAMP_SIZE );

        while ( cbNonce < 2*RANDOM_SIZE + TIMESTAMP_SIZE )
        {
            pC->achNonce[cbNonce++] = '0';
        }

        //
        // Now hash everything, together with a private key that's really difficult to guess,
        // like IISMD5 ;-)
        //
        // UNDONE : make this secret key a MB setting ?
        //
        strcpy( (CHAR *) abTempBuffer, "IISMD5" );

        memcpy( abTempBuffer + dwSecretLen, 
                pC->achNonce, 
                2*RANDOM_SIZE + TIMESTAMP_SIZE );

        cbTemp = 2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen;

        if ( !HashData( abTempBuffer,
                        cbTemp,
                        abDigest ) )
        {
            return FALSE;
        }

        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //
        ToHex( abDigest, MD5_HASH_SIZE, achAsciiDigest );
        memcpy( pC->achNonce + cbNonce, achAsciiDigest, 2*MD5_HASH_SIZE );
        
        //
        // terminate the nonce
        //
        pC->achNonce[NONCE_SIZE] = '\0';

    }

    return TRUE;
}

BOOL AllocateFilterContext(
    HTTP_FILTER_CONTEXT *      pfc
)
/*++

Routine Description:

    Allocate filter user context as a DIGEST_CONTEXT if not already done

Arguments:

    pfc - Filter Context

Return Value:

    TRUE if success, FALSE if error

--*/
{
    //
    // allocate filter context
    //

    if ( !pfc->pFilterContext )
    {
        pfc->pFilterContext = pfc->AllocMem( pfc, sizeof(DIGEST_CONTEXT), 0 );

        if ( !pfc->pFilterContext )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
        memset( pfc->pFilterContext, '\0', sizeof(DIGEST_CONTEXT) );
    }

    return TRUE;
}


LPSTR
SkipWhite(
    LPSTR p
    )
/*++

Routine Description:

    Skip white space and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while ( isspace((UCHAR)(*p) ) || *p == ',' )
    {
        ++p;
    }

    return p;
}


BOOL ParseForName(
    PSTR pszStr,
    PSTR *pNameTable,
    UINT cNameTable,
    PSTR *pValueTable
    )
/*++

Routine Description:

    Parse list of name=value pairs for known names

Arguments:

    pszStr - line to parse ( '\0' delimited )
    pNameTable - table of known names
    cNameTable - number of known names
    pValueTable - updated with ptr to parsed value for corresponding name

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    PSTR pszBeginName;
    PSTR pszEndName;
    PSTR pszBeginVal;
    PSTR pszEndVal;
    UINT iN;
    int ch;


    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        pValueTable[iN] = NULL;
    }

    for ( ; *pszStr && fSt ; )
    {
        pszStr = SkipWhite( pszStr );

        pszBeginName = pszStr;

        for ( pszEndName = pszStr ; (ch=*pszEndName) && ch != '=' && ch != ' ' ; ++pszEndName )
        {
        }

        if ( *pszEndName )
        {
            *pszEndName = '\0';
            pszEndVal = NULL;

            if ( !_stricmp( pszBeginName, "NC" ) )
            {
                for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && !isxdigit((UCHAR)ch) ; ++pszBeginVal )
                {
                }
                
                if ( isxdigit((UCHAR)(*pszBeginVal)) )
                {
                    if ( strlen( pszBeginVal ) >= 8 )
                    {
                        pszEndVal = pszBeginVal + 8;
                    }
                }
            }
            else
            {   
                //
                // Actually this routine is not compatible with rfc2617 at all. It treats all 
                // values as quoted string which is not right. To fix the whole parsing problem, 
                // we will need to rewrite the routine. As for now, the following is a simple 
                // fix for whistler bug 95886. 
                //
                if( !_stricmp( pszBeginName, "qop" ) )
                {
                    BOOL fQuotedQop = FALSE;

                    for( pszBeginVal = ++pszEndName; ( ch=*pszBeginVal ) && ( ch == '=' || ch == ' ' ); ++pszBeginVal )
                    {
                    }

                    if( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        fQuotedQop = TRUE;
                    }

                    for( pszEndVal = pszBeginVal; ( ch = *pszEndVal ); ++pszEndVal )
                    {
                        if( ch == '"' || ch == ' ' || ch == ',' || ch == '\0' )
                        {
                            break;
                        }
                    }

                    if( *pszEndVal != '"' && fQuotedQop )
                    {
                        pszEndVal = NULL;
                    }
                }
                else
                {                
                    for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && ch != '"' ; ++pszBeginVal )
                    {
                    }
                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        for ( pszEndVal = pszBeginVal ; (ch=*pszEndVal) ; ++pszEndVal )
                        {
                            if ( ch == '"' )
                            {
                                break;
                            }
                        }
                        if ( *pszEndVal != '"' )
                        {
                            pszEndVal = NULL;
                        }
                    }
                }
            }
            
            if ( pszEndVal )
            {
                // find name in table
                for ( iN = 0 ; iN < cNameTable ; ++iN )
                {
                    if ( !_stricmp( pNameTable[iN], pszBeginName ) )
                    {
                        break;
                    }
                }
                if ( iN < cNameTable )
                {
                    pValueTable[iN] = pszBeginVal;
                }
                
                pszStr = pszEndVal;
                
                if ( *pszEndVal != '\0' )
                {
                    *pszEndVal = '\0';
                    pszStr++;
                }

                continue;
            }
        }
        
        fSt = FALSE;
    }

    return fSt;
}



BOOL 
GetLanGroupDomainName( 
    OUT CHAR *          pszDigestDomain,
    IN DWORD            cbDigestDomain
)
/*++

Routine Description:

    Tries to retrieve the "LAN group"/domain this machine is a member of.

Arguments:

    pszDigestDomain - string updated with the domain name on success
    cbDigestDomain - size of domain buffer

Returns:

    TRUE if success, FALSE if failure


--*/
{
    static CHAR achDomainName[IIS_DNLEN + 1];
    static BOOL fInitialized = FALSE;
    BOOL fOK = TRUE;

    if ( cbDigestDomain < IIS_DNLEN+1 )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    // Only retrieve the domain name once
    // This routine is thread-safe by virtue of not doing any operation that it'd be
    // harmful to do twice; it's ok if several threads go through the loop that initializes
    // achDomainName because the strcpy at the end can be done several times with no ill effects
    //
    if ( !fInitialized )
    {
        NET_API_STATUS dwNASStatus = 0;
        NETSETUP_JOIN_STATUS JoinStatus;
        LPWSTR pwszInfo = NULL;

        if ( NT_SUCCESS( dwNASStatus = NetGetJoinInformation( NULL,
                                                              &pwszInfo,
                                                              &JoinStatus ) ) )
        {
            switch ( JoinStatus )
            {
            case NetSetupUnknownStatus:
                DBGPRINTF((DBG_CONTEXT,
                           "UnknownStatus returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupUnjoined:
                //
                // No domain yet
                //
                DBGPRINTF((DBG_CONTEXT,
                           "UnjoinedStatus returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupWorkgroupName:
                //
                // We need a domain to authenticate against, a workgroup won't do it
                //
                DBGPRINTF((DBG_CONTEXT,
                           "WorkgroupName returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupDomainName:
                //
                // we got a domain, whee ....
                //
                if ( !pwszInfo )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Null pointer returned from NetGetJoinInformation !\n"));
                    fOK = FALSE;
                }
                else
                {
                    //
                    // If we don't have space for the name in the static buffer, we're
                    // in trouble
                    //
                    if ( wcslen( pwszInfo ) > IIS_DNLEN )
                    {
                        fOK = FALSE;
                    }
                    else
                    {
                        if ( !WideCharToMultiByte( CP_ACP,
                                                   0,
                                                   pwszInfo,
                                                   -1,
                                                   achDomainName,
                                                   IIS_DNLEN + 1,
                                                   NULL,
                                                   NULL ) )
                        {
                            fOK = FALSE;
                        }
                        else
                        {
                            //
                            // At this point, we should have a valid domain name
                            //
                            safe_strcpy( pszDigestDomain, achDomainName );
                            fInitialized = TRUE;
                        }
                    }

                    NetApiBufferFree( (LPVOID) pwszInfo );
                }
                break;

            default:
                DBGPRINTF((DBG_CONTEXT,
                           "Unknown value returned from NetGetJoinInformation !\n"));
                fOK = FALSE;
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "NetGetJoinInformation failed with status 0x%x\n",
                       dwNASStatus));
            fOK = FALSE;
        }
    } // if ( achDomainName[0] == '\0'
    else
    {
        //
        // We've already retrieved the domain, just copy it 
        //
        strcpy( pszDigestDomain, achDomainName );
    }

    return fOK;
}

BOOL
SubAuthGetFilterVersion(
    VOID
)
/*++

Routine Description:

    Filter Init entry point

Arguments:

    None

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fFirst;

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("md5filt");
#else
    CREATE_DEBUG_PRINT_OBJECT("md5filt", IisMD5FiltGuid);
#endif
    if (!VALID_DEBUG_PRINT_OBJECT()) {
        return FALSE;
    }

    //
    //  Get a handle to the CSP we'll use for all our hash functions etc
    //
    
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptAcquireContext() failed : 0x%x\n", GetLastError()));
        return FALSE;
    }

    return TRUE;
}

BOOL
SubAuthTerminateFilter(
    DWORD                       dwFlags
)
/*++

Routine Description:

    Filter cleanup code

Arguments:

    dwFlags - unused

Return Value:

    TRUE if success, FALSE if error

--*/
{
    DELETE_DEBUG_PRINT_OBJECT();
        
    if ( g_hCryptProv )
    {
        CryptReleaseContext( g_hCryptProv,
                             0 );
        g_hCryptProv = NULL;
    }
    
    return TRUE;
}

BOOL
BreakUserAndDomain(
    IN LPSTR            pAcct,
    IN LPSTR            pszConfiguredAuthDomain,
    OUT LPSTR           achDomain,
    IN DWORD            cbDomain,
    OUT LPSTR           achNtUser,
    IN DWORD            cbUser
    )
/*++

Routine Description:

    Breaks up the supplied account into a domain and username; if no domain is specified
    in the account, tries to use either domain configured in metabase or domain the computer
    is a part of.

Arguments:

    pAcct - account, of the form domain\username or just username
    pszConfiguredAuthDomain - auth domain configured in metabase 
    achDomain - buffer filled in with domain to use for authentication, on success
    cbDomain - size of domain buffer
    achNtUser - buffer filled in with username on success
    cbUser - size of user buffer

Return Value:

    TRUE/FALSE indicating success/failure

--*/

{
    LPSTR pSep;
    LPSTR pUser;
    BOOL fContainsDomain = FALSE;

    // break in domain & user name
    // copy to local storage so we can unlock mapper object

#if 1 // DBCS enabling for user name
    if ( (pSep = (PCHAR)_mbschr( (PUCHAR)pAcct, '\\' )) )
#else
    if ( (pSep = strchr( pAcct, '\\' )) )
#endif
    {
        fContainsDomain = TRUE;
        if ( DIFF(pSep - pAcct) < cbDomain )
        {
            memcpy( achDomain, pAcct, DIFF(pSep - pAcct) );
            achDomain[ DIFF( pSep - pAcct ) ] = '\0';
        }
        else
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        pUser = pSep + 1;
    }
    else
    {
        achDomain[0] = '\0';
        pUser = pAcct;
    }
    if ( strlen( pUser ) >= cbUser )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }
    strcpy( achNtUser, pUser );

    //
    // If no domain name specified, try using the metabase-configured domain name; if that
    // is non-existent, try getting the name of the domain the computer is a part of 
    //
    
    if ( !fContainsDomain && achDomain[0] == '\0' )
    {
        if ( pszConfiguredAuthDomain && *pszConfiguredAuthDomain != '\0' )
        {
            if ( strlen( pszConfiguredAuthDomain ) >= cbDomain )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                return FALSE;
            }
            strcpy( achDomain, pszConfiguredAuthDomain );
        }
        else
        {
            if ( !GetLanGroupDomainName( achDomain, cbDomain ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


DWORD
SubAuthHttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
/*++

Routine Description:

    Filter notification entry point

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    DWORD                 dwRet;
    BOOL                  fAllowed;
    CHAR                  achUser[SF_MAX_USERNAME];
    CHAR                  achMethod[256];
    CHAR                  achRealm[256];
    DWORD                 cbRealm;
    DWORD                 cbMethod;
    HTTP_FILTER_AUTHENTEX*pAuth;
    HTTP_FILTER_LOG *     pLog;
    CHAR *                pch;
    CIisMapping *         pQuery;
    CIisMapping *         pResult = NULL;
    BOOL                  fFirst;
    LPSTR                 aValueTable[ MD5_AUTH_LAST ];
    BOOL                  fStale;
    LPSTR                 pszA2;
    LPSTR                 pszH;
    LPSTR                 pAcct;
    BOOL                  fMd5;
    BOOL                  fNtDigest = FALSE;
    CHAR                  achDomain[IIS_DNLEN+1];
    CHAR                  achNtUser[64];
    CHAR                  achCookie[64];
    CHAR                  achPwd[64];
    LPSTR                 pPwd;
    LPSTR                 pNtPwd;
    CHAR                  achUrl[MAX_URL_SIZE];
    CHAR                  achDigestUri[MAX_URL_SIZE];
    DWORD                 cbUrl;
    LPSTR                 pSep;
    LPSTR                 pUser;
    BOOL                  fSt;
    BOOL                  fRetNow = FALSE;
    RefBlob*              pBlob = NULL;
    BOOL                  fQOPAuth = FALSE;

    //
    //  Handle this notification
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_ACCESS_DENIED:

        if ( pfc->ServerSupportFunction( pfc,
                                    SF_REQ_GET_PROPERTY,
                                    (LPVOID)&fMd5,
                                    (UINT)SF_PROPERTY_MD5_ENABLED,
                                    NULL ) && fMd5 )
        {
            cbRealm = sizeof(achRealm);

            if ( !AllocateFilterContext( pfc ) ||
                 !GenerateNonce( pfc ) ||
                 !pfc->GetServerVariable( pfc,
                                          "HTTP_REQ_REALM",
                                          achRealm,
                                          &cbRealm ) )
            {
                return SF_STATUS_REQ_ERROR;
            }

            fStale = ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale;

#ifdef NT_DIGEST
            wsprintf( achMethod,
                      "WWW-Authenticate: Digest realm=\"%s\", nonce=\"%s\"%s\r\n"
                      "WWW-Authenticate: NT-Digest realm=\"%s\", nonce=\"%s\"%s\r\n",
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : "" ,
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : "" );
#else
            wsprintf( achMethod,
                      "WWW-Authenticate: Digest qop=\"auth\", realm=\"%s\", nonce=\"%s\"%s\r\n",
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : ""  );
#endif //NT_DIGEST

            if ( !pfc->ServerSupportFunction( pfc,
                                              SF_REQ_ADD_HEADERS_ON_DENIAL,
                                              achMethod,
                                              NULL,
                                              NULL) )
            {
                return SF_STATUS_REQ_ERROR;
            }
        }

        break;

    case SF_NOTIFY_AUTHENTICATIONEX:

        pAuth = (HTTP_FILTER_AUTHENTEX *) pvData;

        //
        //  Ignore the anonymous user ( mapped by IIS )
        //

        if ( !*pAuth->pszPassword )
        {
            fRetNow = TRUE;
        }
        else
        {
            if ( !_stricmp( pAuth->pszAuthType, "NT-Digest" ) )
            {
                fNtDigest = TRUE;
            }
            else if ( _stricmp( pAuth->pszAuthType, "Digest" ) )
            {
                fRetNow = TRUE;
            }
        }

        if ( fRetNow )
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        // make sure filter context is allocated
        //

        if ( !AllocateFilterContext( pfc ) )
        {
            return SF_STATUS_REQ_ERROR;
        }
        ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale = FALSE;


        if ( !ParseForName( pAuth->pszPassword,
                            MD5_AUTH_NAMES,
                            MD5_AUTH_LAST,
                            aValueTable ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return SF_STATUS_REQ_ERROR;
        }
        
        if ( aValueTable[MD5_AUTH_USERNAME] == NULL ||
             aValueTable[MD5_AUTH_REALM] == NULL ||
             aValueTable[MD5_AUTH_URI] == NULL ||
             aValueTable[MD5_AUTH_NONCE] == NULL ||
             aValueTable[MD5_AUTH_RESPONSE] == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return SF_STATUS_REQ_ERROR;
        }
        
        if ( aValueTable[MD5_AUTH_QOP] != NULL )
        {
            if ( _stricmp( aValueTable[MD5_AUTH_QOP], "auth" ) )
            {
                SetLastError( ERROR_NOT_SUPPORTED );
                return SF_STATUS_REQ_ERROR;
            }
            
            if ( aValueTable[MD5_AUTH_CNONCE] == NULL ||
                 aValueTable[MD5_AUTH_NC] == NULL )
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return SF_STATUS_REQ_ERROR;
            }
            
            fQOPAuth = TRUE;
        }
        else
        {
            aValueTable[MD5_AUTH_QOP] = "none";
            aValueTable[MD5_AUTH_CNONCE] = "none";
            aValueTable[MD5_AUTH_NC] = "none";
        }

        cbMethod = sizeof(achMethod);
        if ( !pfc->GetServerVariable( pfc,
                                      "REQUEST_METHOD",
                                      achMethod,
                                      &cbMethod ))
        {
            return SF_STATUS_REQ_ERROR;
        }

        //
        // Check URI field match URL
        //

        if ( strlen(aValueTable[MD5_AUTH_URI]) > MAX_URL_SIZE )
        {
            return SF_STATUS_REQ_ERROR;
        }

        //
        // Verify that the nonce is well-formed
        //
        if ( !IsWellFormedNonce( aValueTable[MD5_AUTH_NONCE] ) )
        {
            SetLastError( ERROR_ACCESS_DENIED );

            return SF_STATUS_REQ_ERROR;
        }

        strcpy( achDigestUri, aValueTable[MD5_AUTH_URI] );
        cbUrl = sizeof( achUrl );

        if ( !pfc->ServerSupportFunction( pfc,
                                          SF_REQ_NORMALIZE_URL,
                                          achDigestUri,
                                          NULL,
                                          NULL) ||
             !pfc->GetServerVariable( pfc,
                                     "URL_PATH_INFO",
                                     achUrl,
                                     &cbUrl ) )
        {
            return SF_STATUS_REQ_ERROR;
        }

        if ( strcmp( achDigestUri, achUrl ) )
        {
            SetLastError( ERROR_ACCESS_DENIED );

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped username so we can log it later
        //

        if ( strlen(aValueTable[MD5_AUTH_USERNAME]) < pAuth->cbUserBuff )
        {
            strcpy( pAuth->pszUser, aValueTable[MD5_AUTH_USERNAME] );
        }

        if ( strlen(aValueTable[MD5_AUTH_USERNAME]) < sizeof(achUser) )
        {
            strcpy( achUser, aValueTable[MD5_AUTH_USERNAME] );
        }

        if ( 1 || fNtDigest )
        {
            DIGEST_LOGON_INFO           DigestLogonInfo;
            
            if ( !GenerateNonce( pfc ) )
            {
                return SF_STATUS_REQ_ERROR;
            }

            if ( !BreakUserAndDomain( aValueTable[MD5_AUTH_USERNAME],
                                      pAuth->pszAuthDomain,
                                      achDomain,
                                      sizeof( achDomain ),
                                      achNtUser,
                                      sizeof( achNtUser ) ) )
            {
                return SF_STATUS_REQ_ERROR;
            }
            
            if ( strlen( aValueTable[MD5_AUTH_USERNAME] )
                 < pAuth->cbLogonUserBuff )
            {
                strcpy( pAuth->pszLogonUser, aValueTable[MD5_AUTH_USERNAME] );
            }
            
            DigestLogonInfo.pszNtUser = achNtUser;
            DigestLogonInfo.pszDomain = achDomain;
            DigestLogonInfo.pszUser = aValueTable[MD5_AUTH_USERNAME];
            DigestLogonInfo.pszRealm = aValueTable[MD5_AUTH_REALM];
            DigestLogonInfo.pszURI = aValueTable[MD5_AUTH_URI];
            DigestLogonInfo.pszMethod = achMethod;
            DigestLogonInfo.pszNonce = aValueTable[MD5_AUTH_NONCE];
            DigestLogonInfo.pszCurrentNonce = ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce;
            DigestLogonInfo.pszCNonce = aValueTable[MD5_AUTH_CNONCE];
            DigestLogonInfo.pszQOP = aValueTable[MD5_AUTH_QOP];
            DigestLogonInfo.pszNC = aValueTable[MD5_AUTH_NC];
            DigestLogonInfo.pszResponse = aValueTable[MD5_AUTH_RESPONSE];

            fSt = LogonDigestUserA( &DigestLogonInfo,
                                    (fNtDigest ? IISSUBA_NT_DIGEST : IISSUBA_DIGEST ),
                                    &pAuth->hAccessTokenImpersonation );

            //
            // Response from the client was correct but the nonce has expired,
            // 
            if ( fSt && 
                 IsExpiredNonce( aValueTable[MD5_AUTH_NONCE],
                                 ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce ) )
            {
                goto stalled_nonce;
            }

            goto logged_on;
        }


stalled_nonce:
       ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale = TRUE;
       // do not log stalled authentication
       SetLastError( ERROR_ACCESS_DENIED );
       return SF_STATUS_REQ_ERROR;

logged_on:
        if ( !fSt )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Digest logon failed : 0x%x\n", GetLastError()));
            pAuth->hAccessTokenImpersonation = NULL;

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped user name so we can log it later on.  We allocate
        //  enough space for two usernames so we can use this memory block
        //  for logging.  Note we may have already allocated it from a previous
        //  request on this TCP session
        //

        strcpy( ((PDIGEST_CONTEXT)pfc->pFilterContext)->achUserName, achUser );

        return SF_STATUS_REQ_HANDLED_NOTIFICATION;

    case SF_NOTIFY_LOG:

        //
        //  The unmapped username is in pFilterContext if this filter
        //  authenticated this user
        //

        if ( pfc->pFilterContext )
        {
            pch  = ((PDIGEST_CONTEXT)pfc->pFilterContext)->achUserName;
            pLog = (HTTP_FILTER_LOG *) pvData;

            //
            //  Put both the original username and the NT mapped username
            //  into the log in the form "Original User (NT User)"
            //

            if ( strchr( pch, '(' ) == NULL )
            {
                strcat( pch, " (" );
                strcat( pch, pLog->pszClientUserName );
                strcat( pch, ")" );
            }

            pLog->pszClientUserName = pch;
        }

        return SF_STATUS_REQ_NEXT_NOTIFICATION;

    default:

        break;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\md5filt\sspdigest.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    sspdigest.cxx

Abstract:

    New digest support which uses Whistler's new server side digest SSP

Developed by:

    Andres Sanabria - AndresS@Microsoft.com
    Kevin Damour    - KDamour@Microsoft.com

Last Modification:
    6/11/00 adding DisableThreadLibraryCalls        
    6/11/00 changing the Allocate Memory after ASC  Succeed 
    6/11/00 solving when deleting a null the Context Handle on SF_NOTIFY_END_OF_NET_SESSION 
    6/11/00 adding DuplicateTocken to solve exemptions in InetInfo.exe                  
    6/11/00 moving content from the DLL_PROCESS_ATTACH to GetFilterVersion              
    6/11/00 adding CompleateAuthToken           
    6/11/00 removing the code that checks that the auth was digest
    6/13/00 changing from bStale to m_bStale
    6/13/00 removing fAreIdentical 
    6/13/00 Moving the case DLL_PROCESS_DETACH to the Terminate Filter function
    6/13/00 adding the implementation for the new secbuffer for the realm
    6/13/00 adding close handle in OnAuthenticatioEx in SEC_E_CONTEXT_EXPIRED to force Acces denied
    6/13/00 Adding g_MaxOutPutBuffSize , querying that information from the package

--*/

#ifdef __cplusplus
extern "C" {
#endif

#define SECURITY_WIN32   

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
#if 1 // DBCS
# include <mbstring.h>
#endif
#include <lmcons.h>
#include <lmjoin.h>

#ifdef __cplusplus
};
#endif


# include <iis64.h>
# include <inetcom.h>
# include <inetinfo.h>

//
//  System include files.
//

# include "dbgutil.h"
#include <tcpdll.hxx>
#include <tsunami.hxx>


extern "C" {

#include <tchar.h>

//
//  Project include files.
//

#include <time.h>
#include <w3svc.h>
#include <iisfiltp.h>
#include <sspi.h>

} // extern "C"

#include "sspdigest.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Global Variables
//////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_URL_SIZE        512
#define NTDIGEST_SP_NAME    "wdigest"

CredHandle  g_ServerCred;           // This is a global Credential handel used for authentication
TimeStamp   g_Lifetime;             // cotain the lifetime of the credenial handl
DWORD       g_cbMaxOutPutBuffSize =0;   // contains the max size of the buffer 

typedef struct _DIGEST_CONTEXT 
{
    CtxtHandle  m_CtxtHandle;
    BOOL        m_bStale;
    DWORD       m_Reserve;
} 
DIGEST_CONTEXT, *PDIGEST_CONTEXT;

BOOL 
SSPGetFilterVersion(
    VOID
)
/*++
Routine Description:

    Do SSP initialization

Arguments:

    None

Return Value:
    TRUE    your filter to remain loaded and working properly
    FALSE   IIS will not send the filter any notifications
--*/
{
    SECURITY_STATUS     secStatus       = SEC_E_OK;
    PSecPkgInfo         pPackageInfo    = NULL;

    //
    //  Get a Credential handle
    //
    secStatus = AcquireCredentialsHandle(
                    NULL,               // New principal
                    NTDIGEST_SP_NAME,   // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &g_ServerCred,
                    &g_Lifetime );

    if (FAILED(secStatus)) 
    {
        return (FALSE); 
    }
    else
    {
        // getting the package size
        secStatus = QuerySecurityPackageInfo( NTDIGEST_SP_NAME, &pPackageInfo );
        if (SUCCEEDED(secStatus))
        {
            // get the maximun tocken size from the DIGEST sspi
            //
        
            g_cbMaxOutPutBuffSize = pPackageInfo->cbMaxToken;
        
            if (0 == g_cbMaxOutPutBuffSize)
            {
                return (FALSE);
            }
            else
            {
                return (TRUE);
            }
        }
        else 
        {
            return (FALSE);
        }   
    }
}

DWORD
SSPHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType, 
    LPVOID                      pvNotification
)
/*++
Routine Description:
    Entry point function whenever a notification event for which the filter has registered occurs. 

Arguments:
   pfc                  Points to the HTTP_FILTER_CONTEXT data structure that is 
                        associated with the current, active HTTP transaction
   notificationType     Points to a bitmask that indicates the type of notification 
                        event being processed. 
   pvNotification       The notification-specific structure that contains more 
                        information about the current context of the request. 

Return Value:
    Returns one of the following values that indicate how the application handled the event.
    SF_STATUS_REQ_ERROR
    SF_STATUS_REQ_READ_NEXT

 ++*/
{
    HRESULT hrResult = S_OK;
    BOOL    fMd5     = FALSE;

    switch(notificationType)
    {
    case (SF_NOTIFY_ACCESS_DENIED): 
        if ( pfc->ServerSupportFunction( pfc,
                                         SF_REQ_GET_PROPERTY,
                                         (LPVOID)&fMd5,
                                         (UINT)SF_PROPERTY_MD5_ENABLED,
                                         NULL ) && fMd5 )
        {
            //
            // Call this function to process the authentication in order to change Usrname
            //
            hrResult = SSPOnAccessDenied (pfc, pvNotification);
        }

        break;

    case (SF_NOTIFY_AUTHENTICATIONEX):  
        //
        // Call this function to process the authentication in order to change Usrname
        //
        hrResult = SSPOnAuthenticationEx (pfc, pvNotification);
        break;

    case (SF_NOTIFY_END_OF_NET_SESSION):    
        { 
            //
            // Delete the security context
            //
            DIGEST_CONTEXT *pDigestContext;
            pDigestContext = (DIGEST_CONTEXT *)(pfc->pFilterContext);
            // check to see if there is any content in the pFilterContexet
            if (NULL != pDigestContext)
            {
                DeleteSecurityContext (&(pDigestContext->m_CtxtHandle));
            }
            break;
        }   
    }

    if (SUCCEEDED(hrResult))
    {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
    else 
    {
        return SF_STATUS_REQ_ERROR;
    }
}

HRESULT 
SSPOnAccessDenied(
    HTTP_FILTER_CONTEXT *       pfc, 
    void *                      pvNotification
)
/*++
Routine Description:
    This function is design to process the Access_Denied notification. This routined
    will set the WWW-Authenticate to set digest. this will happen in when a 401 server 
    error is sent to the client 

Arguments:
    pfc             Points to the HTTP_FILTER_CONTEXT data structure that is 
                    associated with the current, active HTTP transaction
    pAccessDenied   pointer to this structure when a user is presented 
                    with an Access Denied error message. 

Return Value:
    TRUE    if the processs sucess 
    FALSE   if the process failed
--*/
{
    BOOL                    bReturnOk           = FALSE;

    char                    achMethod       [MAX_URL_SIZE];
    char                    achUrl          [MAX_URL_SIZE];
    char                    achRealm        [MAX_URL_SIZE];
    char                    *pszOutputBuffer    = NULL;
    char                    *pszOutputHeader    = NULL; // this is the output buffer that will be return to iis

    CtxtHandle              ServerCtxtHandle;

    DIGEST_CONTEXT          *pDigestContext = 0;

    DWORD                   cbMethod    = 0;
    DWORD                   cbUrl       = 0;
    DWORD                   cbRealm     = 0;
    DWORD                   cbBuffer    = 0;
    DWORD                   cbOutputHeader = 0;


    HRESULT                 hrResult    = E_FAIL;
    
    HTTP_FILTER_ACCESS_DENIED   *pAuth;
    
    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[1];
    SecBuffer               SecBuffTokenIn[5];

    SECURITY_STATUS         secStatus           = SEC_E_OK;

    TimeStamp               Lifetime;

    ULONG                   ContextReqFlags     = 0;
    ULONG                   ContextAttributes   = 0;

    pszOutputBuffer = new char[g_cbMaxOutPutBuffSize];
    if (NULL == pszOutputBuffer)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    // we add the MAX_URL_SIZE to provide space for www-authetication into output buffer
    //
    pszOutputHeader = new char[g_cbMaxOutPutBuffSize + MAX_URL_SIZE]; 
    if (NULL == pszOutputHeader)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    //  cast the pointer 
    pAuth = (HTTP_FILTER_ACCESS_DENIED *)pvNotification;

    //  clean the memory and set it to zero
    ZeroMemory(&SecBuffDescOutput, sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenOut   , sizeof(SecBuffTokenOut));

    ZeroMemory(&SecBuffDescInput , sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenIn    , sizeof(SecBuffTokenOut));

    ///////////////////////
    //  defined the OUTPUT
    ///////////////////////
    
    //  define the buffer descriptor for the Outpt
    //
    SecBuffDescOutput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers      = 1;
    SecBuffDescOutput.pBuffers      = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer     = g_cbMaxOutPutBuffSize;  // use any space here
    SecBuffTokenOut[0].pvBuffer     = pszOutputBuffer;


    ///////////////////////
    //  defined the INPUT
    ///////////////////////

    //  define the buffer descriptor for the Input
    //
    SecBuffDescInput.ulVersion      = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers       = 5;
    SecBuffDescInput.pBuffers       = SecBuffTokenIn;

    //
    //  Get and Set the information for the challange
    //


    // set the inforamtion in the buffer . this case is Null to authenticate user
    SecBuffTokenIn[0].BufferType    = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer      = 0; 
    SecBuffTokenIn[0].pvBuffer      = NULL;

    //  
    //  Get and Set the information for the method
    //
    
    //  Get size of the string alocated for the method
    cbMethod =  sizeof(achMethod);

    //  Get method
    bReturnOk = pfc->GetServerVariable( pfc,"REQUEST_METHOD",achMethod,&cbMethod);
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    //  set the information in the buffer
    SecBuffTokenIn[1].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer      = cbMethod;
    SecBuffTokenIn[1].pvBuffer      = achMethod;

    //
    //  Get size of the string alocated for the method URL
    cbUrl = sizeof(achUrl);
    //
    //  Get the inforamtion of the URL
    bReturnOk = pfc->GetServerVariable( pfc,"URL",achUrl,&cbUrl);
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    
    //
    //  set the information in the buffer
    SecBuffTokenIn[2].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer      = cbUrl;
    SecBuffTokenIn[2].pvBuffer      = achUrl;

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer      = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer      = NULL; // this is not yet implemeted   

    //
    //Get and Set the Realm Information
    //
    cbRealm =  sizeof(achRealm);
    bReturnOk = pfc->GetServerVariable( pfc,"HTTP_REQ_REALM",achRealm,&cbRealm );
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    SecBuffTokenIn[4].BufferType    = SECBUFFER_PKG_PARAMS;
//    SecBuffTokenIn[4].cbBuffer        = cbRealm;  
//    SecBuffTokenIn[4].pvBuffer        = achRealm; 
    SecBuffTokenIn[4].cbBuffer      = 0;                    
    SecBuffTokenIn[4].pvBuffer      = "\0"; 

    //
    //  Get a Security Context
    //

    //  set the flags
    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION;

    // get the security context
    secStatus = AcceptSecurityContext(
                    &g_ServerCred,
                    NULL,
                    &SecBuffDescInput,
                    ContextReqFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerCtxtHandle,
                    &SecBuffDescOutput,
                    &ContextAttributes,
                    &Lifetime);

    // a challange has to be send back to the client
    if (SEC_I_CONTINUE_NEEDED == secStatus)
    {

        //  Format and concatenate the header for the authentication
        //
        pDigestContext =((DIGEST_CONTEXT *)(pfc->pFilterContext));
        if (NULL != pDigestContext)
        {
            if (TRUE == pDigestContext->m_bStale)
            {
                strcpy(pszOutputHeader,"WWW-Authenticate: Digest stale=TRUE ,");
            }
            else
            {
                strcpy(pszOutputHeader,"WWW-Authenticate: Digest ");
            }
        }
        else
        {
            strcpy(pszOutputHeader,"WWW-Authenticate: Digest ");
        }
        
        cbOutputHeader = strlen(pszOutputHeader);

        
        //
        //  add the challange to the OutPutHeader
        //
        if ((cbOutputHeader+cbBuffer+1) < (g_cbMaxOutPutBuffSize + MAX_URL_SIZE))   //check the size
        {
            strncat(pszOutputHeader, (char *)SecBuffDescOutput.pBuffers[0].pvBuffer, 
                    (SecBuffDescOutput.pBuffers[0].cbBuffer));  
        }

        //
        //  Add the header WWW-Authenticate to the response after a 401 server error
        //
        bReturnOk = pfc->ServerSupportFunction(pfc, SF_REQ_ADD_HEADERS_ON_DENIAL, pszOutputHeader, NULL, NULL);
        if (FALSE == bReturnOk)
        {
            hrResult = SF_STATUS_REQ_ERROR;
            goto CleanUp;
        }
    }
    
    // in case that ASC failed
    if (FAILED(secStatus)) 
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    else 
    {
        hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto CleanUp;
    }

    ////////////////////////////////////////////////
    // Clean UP
    ///////////////////////////////////////////////
CleanUp:
    if (pszOutputBuffer)
    {
        delete [] pszOutputBuffer;
        pszOutputBuffer = NULL;
    }
    if (pszOutputHeader)
    {
        delete [] pszOutputHeader;
        pszOutputHeader = NULL;
    }
    return hrResult;
}

HRESULT 
SSPOnAuthenticationEx(
    HTTP_FILTER_CONTEXT *       pfc, 
    void *                      pvNotification
)
{
    HTTP_FILTER_AUTHENTEX   *pAuth;

    BOOL                    bReturnOk       = FALSE;

    char                    achMethod       [MAX_URL_SIZE];
    char                    achUrl          [MAX_URL_SIZE];
    char                    achRealm        [MAX_URL_SIZE]; 
    char                    *pszOutputBuffer    =NULL;
    
    CtxtHandle              ServerCtxtHandle;

    DWORD                   cbMethod    = 0;
    DWORD                   cbUrl       = 0;
    DWORD                   cbRealm     = 0;

    HRESULT                 hrResult    = E_FAIL;

    DIGEST_CONTEXT          *pDigestContext = 0;
    
    
    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[1];
    SecBuffer               SecBuffTokenIn[6];

    SECURITY_STATUS         secStatus           = SEC_E_OK;

    TimeStamp               Lifetime;

    ULONG                   ContextReqFlags     = 0;
    ULONG                   ContextAttributes   = 0;

    pszOutputBuffer = new char[g_cbMaxOutPutBuffSize];
    if (NULL == pszOutputBuffer)
    {
        return SF_STATUS_REQ_ERROR;
    }

    
    pAuth = (HTTP_FILTER_AUTHENTEX *)pvNotification;

    //
    //  check that there is a username if not then is anonymous and is not authentucated
    //
    if ( !*pAuth->pszPassword ) 
    {
        hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto CleanUp;
    }

    
    //  clean the memory and set it to zero
    ZeroMemory(&SecBuffDescOutput, sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenOut   , sizeof(SecBuffTokenOut));

    ZeroMemory(&SecBuffDescInput , sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenIn    , sizeof(SecBuffTokenOut));

    ///////////////////////
    //  defined the OUTPUT
    ///////////////////////
    
    //  define the buffer descriptor for the Outpt
    //
    SecBuffDescOutput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers      = 1;
    SecBuffDescOutput.pBuffers      = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer     = g_cbMaxOutPutBuffSize;  // use any space here
    SecBuffTokenOut[0].pvBuffer     = pszOutputBuffer;


    ///////////////////////
    //  defined the INPUT
    ///////////////////////

    //  define the buffer descriptor for the Input
    //
    SecBuffDescInput.ulVersion      = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers       = 5;
    SecBuffDescInput.pBuffers       = SecBuffTokenIn;

    //
    //  Get and Set the information for the challange
    //
    
    // set the inforamtion in the buffer . this case is Null to authenticate user
    SecBuffTokenIn[0].BufferType    = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer      = (strlen(pAuth->pszPassword)+1); 
    SecBuffTokenIn[0].pvBuffer      = pAuth->pszPassword;

    //  
    //  Get and Set the information for the method
    //
    
    //  Get size of the string alocated for the method
    cbMethod =  sizeof(achMethod);

    //  Get method
    bReturnOk = pfc->GetServerVariable( pfc,"REQUEST_METHOD",achMethod,&cbMethod);
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }

    //  set the information in the buffer
    SecBuffTokenIn[1].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer      = cbMethod;
    SecBuffTokenIn[1].pvBuffer      = achMethod;

    //
    //  Get and Set the information for the URL & URI
    //

    //
    //  Get size of the string alocated for the method URL
    cbUrl = sizeof(achUrl);
    //
    //  Get the inforamtion of the URL
    bReturnOk = pfc->GetServerVariable( pfc,"URL",achUrl,&cbUrl);
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }
    
    
    //
    //  set the information in the buffer
    SecBuffTokenIn[2].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer      = cbUrl;
    SecBuffTokenIn[2].pvBuffer      = achUrl;

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer      = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer      = 0;    // this is not yet implemeted   


    //
    // Get and set the REALM
    //

    cbRealm =  sizeof(achRealm);
    bReturnOk = pfc->GetServerVariable( pfc,"HTTP_REQ_REALM",achRealm,&cbRealm );
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }
    SecBuffTokenIn[4].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[4].cbBuffer      = 0;                        
    SecBuffTokenIn[4].pvBuffer      = "\0"; //This is where you should put the realm
    
    
    //
    //  Get a Security Context
    //

    //  set the flags
    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION;


    //
    //check to see if there is an old Context Handle
    pDigestContext =((DIGEST_CONTEXT *)(pfc->pFilterContext));
    if (NULL != pDigestContext)
    {
        //defined the buffer
        SecBuffTokenIn[4].BufferType    = SECBUFFER_TOKEN;
        SecBuffTokenIn[4].cbBuffer      = g_cbMaxOutPutBuffSize;  // use any space here
        SecBuffTokenIn[4].pvBuffer      = pszOutputBuffer;


        secStatus = VerifySignature(
                            &(pDigestContext->m_CtxtHandle),
                            &SecBuffDescInput,
                            0,
                            0);

        // Check to see if the nonce has expired
        //
        if (SEC_E_CONTEXT_EXPIRED ==  secStatus)
        {
            //Delete the old Security Context
            //
            DeleteSecurityContext (&(pDigestContext->m_CtxtHandle));
        
            ZeroMemory(&(pDigestContext->m_CtxtHandle) , sizeof(CtxtHandle));

            pDigestContext->m_bStale = TRUE;

            if (NULL != pAuth->hAccessTokenImpersonation)
            {
                // close the SecToken = handle to avoid leaking of resources 
                //
                bReturnOk = CloseHandle( pAuth->hAccessTokenImpersonation); //avoid leaking
                if (TRUE == bReturnOk)
                {
                    //force and access denied to be fire
                    pAuth->hAccessTokenImpersonation = NULL;            
                    hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
                }
                else
                {
                    hrResult = SF_STATUS_REQ_ERROR;
                }
            }           
            goto CleanUp;
        }
    }

    //
    // there is no an old context handle
    // this case handle the non persistent connection 
    else
    {
        // get the security context
        secStatus = AcceptSecurityContext(
                        &g_ServerCred,
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &ServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);


        if (SUCCEEDED(secStatus))
        {
            // Allocate memory for the Digest context
            if (FALSE == SSPAllocateFilterContext(pfc))
            {
                hrResult = SF_STATUS_REQ_ERROR;
                goto CleanUp;   
            }

            //
            // set the new context handle in the struct 
            pDigestContext =((PDIGEST_CONTEXT)(pfc->pFilterContext));
            pDigestContext->m_CtxtHandle = ServerCtxtHandle;
        }

        if(SEC_I_COMPLETE_NEEDED == secStatus) //SEC_I_COMPLETE_NEEDED
        {
            //defined the buffer
            SecBuffTokenIn[4].BufferType    = SECBUFFER_TOKEN;
            SecBuffTokenIn[4].cbBuffer      = g_cbMaxOutPutBuffSize;  // use any space here
            SecBuffTokenIn[4].pvBuffer      = pszOutputBuffer;


            secStatus = CompleteAuthToken(&ServerCtxtHandle, &SecBuffDescInput);
        }

    }
    
    if (FAILED(secStatus)) 
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    else 
    {
        //
        // get the token to impersonate later
        secStatus = QuerySecurityContextToken(&(pDigestContext->m_CtxtHandle),&(pAuth->hAccessTokenImpersonation));
        if (SUCCEEDED(secStatus))
        {
            hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
            goto CleanUp;
        }
        else 
        {
            hrResult = SF_STATUS_REQ_ERROR;
            goto CleanUp;
        }
    }



CleanUp:
    if (pszOutputBuffer)
    {
        delete [] pszOutputBuffer;
        pszOutputBuffer =0;
    }
    return hrResult;
}


BOOL 
SSPAllocateFilterContext(
    HTTP_FILTER_CONTEXT *           pfc
)
/*++
Routine Description:
    Allocate filter user context as a DIGEST_CONTEXT if not already done

Arguments:
    pfc - Filter Context

Return Value:
    TRUE if success, FALSE if error

--*/
{
    //
    // allocate filter context
    //

    if ( !pfc->pFilterContext )
    {
        pfc->pFilterContext = pfc->AllocMem( pfc, sizeof(DIGEST_CONTEXT), 0 );

        if ( !pfc->pFilterContext )
        {
            return FALSE;
        }
        memset( pfc->pFilterContext, 0, sizeof(DIGEST_CONTEXT) );
        ((DIGEST_CONTEXT *)pfc->pFilterContext)->m_bStale = FALSE;
    }

    return TRUE;
}

BOOL 
SSPTerminateFilter(
    DWORD               dwFlags 
)
/*++

Routine Description:
    This routing will clean the filter for a successful unload avoiding resource leaking 

Arguments:
    dwFlags No values for dwFlags have been identified at this time. 

Return Value:
    TRUE if success

--*/
{
    SECURITY_STATUS  secStatus  = SEC_E_OK;

    //
    // releasing the local creadential handle
    //
    secStatus = FreeCredentialsHandle( &g_ServerCred);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\pwsdata\pwsadmin.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsadmin.cxx

Abstract:

    This module implements the PWS filter admin interface

Author:

    Johnson Apacible (JohnsonA)     1-15-97

Revision History:
--*/

#include <windows.h>
#include <iisfilt.h>
//#include <stdlib.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>
#include <stdio.h>

#ifndef _NO_TRACING_
#include <initguid.h>
#include "pudebug.h"
DEFINE_GUID(IisPwsDataGuid, 
0x784d891E, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

void CheckTimePeriod( PPWS_DATA pData );


VOID
ClosePwsData(
    IN PVOID PwsData
    )
{
    UnmapViewOfFile(PwsData);
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif
    return;

}  // ClosePwsData


PVOID
OpenPwsData(
    VOID
    )
{
    HANDLE hMap;
    PPWS_DATA_PRIVATE pwsData;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("pwsdata", IisPwsDataGuid);
#endif

    hMap = OpenFileMapping(
                    FILE_MAP_READ,
                    FALSE,
                    PWS_DATA_SPACE_NAME
                    );

    if ( hMap == NULL ) {
        IIS_PRINTF((buff,
            "Error %d in OpenFileMapping\n", GetLastError()));
        printf("error %d in openfile\n",GetLastError());
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        return(NULL);
    }

    pwsData = (PPWS_DATA_PRIVATE)MapViewOfFile(
                                    hMap,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMap);
    if ( pwsData == NULL ) {
        IIS_PRINTF((buff,"Error %d in MapViewOfFile\n", GetLastError()));
        printf("error %d in mvff\n",GetLastError());
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        return(NULL);
    }

    if ( (pwsData->Signature != PWS_DATA_SIGNATURE) ||
         (pwsData->dwSize != sizeof(PWS_DATA_PRIVATE)) ) {

        IIS_PRINTF((buff,
            "Signature %x[%x] Size %d[%d] do not match\n",
            pwsData->Signature, PWS_DATA_SIGNATURE,
            pwsData->dwSize, sizeof(PWS_DATA_PRIVATE)));

        printf("signature dont match\n");
        ClosePwsData(pwsData);
        pwsData = NULL;
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
    }

    return(pwsData);

} // OpenPwsData





BOOL
GetPwsData(
    IN OUT PPWS_DATA Data
    )
{

    HANDLE hMap;
    PPWS_DATA_PRIVATE pwsData;

    ZeroMemory(Data,sizeof(PWS_DATA));

    pwsData = (PPWS_DATA_PRIVATE)OpenPwsData( );

    if ( pwsData != NULL ) {
		// just block copy over all the data
		CopyMemory ( Data, &pwsData->PwsStats, sizeof( PWS_DATA ) );

		// check the data for a timing period roll-over
		CheckTimePeriod( Data );

		/*
        Data->nSessions = pwsData->PwsStats.nSessions;
        Data->nTotalSessions = pwsData->PwsStats.nTotalSessions;
        Data->nHits = pwsData->PwsStats.nHits;
        Data->nBytesSent = pwsData->PwsStats.nBytesSent;
		*/

        ClosePwsData(pwsData);
        return(TRUE);
    }

    return(FALSE);

} // GetPwsData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\pwsdata\pwsdata.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsdata.cxx

Abstract:

    This module implements the PWS filter

Author:

    Johnson Apacible (JohnsonA)     1-15-97
    Boyd Multerer (BoydM)
    Boyd Multerer (BoydM)           4-30-97
    Boyd Multerer (BoydM)           4-7-97  // added unique IP tracking

Revision History:
--*/

#include <windows.h>
#include <time.h>
#include <iisfilt.h>
#include <stdlib.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>

#include <winsock2.h>
#include <pudebug.h>

PPWS_DATA_PRIVATE   PwsData = NULL;
HANDLE              hFileMap = NULL;

#define             TRACK_IP_NUM    50
DWORD               g_rgbIPTrack[TRACK_IP_NUM];
time_t              g_rgbIPHourTrack[TRACK_IP_NUM];
time_t              g_rgbIPDayTrack[TRACK_IP_NUM];
CRITICAL_SECTION    g_ip_section;

BOOL
CreatePwsSharedMemory(
    VOID
    );

void CheckTimePeriod( PPWS_DATA pData );
BOOL FTrackIP( DWORD ip, time_t hour, time_t day );

//
//  Pseudo context for tracking individual request threads
//

DWORD ReqNumber = 1000;

//-----------------------------------------------------------------
BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
    {
    IIS_PRINTF(( buff, "Pws Filter TerminateExtension() called\n" ));

    DeleteCriticalSection( &g_ip_section );

    if ( PwsData != NULL )
        {
	    UnmapViewOfFile( PwsData );
	    CloseHandle(hFileMap);
	    PwsData = NULL;
	    hFileMap = NULL;
        }
    return TRUE;
    }

//-----------------------------------------------------------------
BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
//DebugBreak();

    IIS_PRINTF(( buff,
	    "[GetFilterVersion] PWS filter version is %d.%d\n",
	    HIWORD( pVer->dwServerFilterVersion ),
	    LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = MAKELONG( 0, 4 );   // Version 4.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
		     SF_NOTIFY_NONSECURE_PORT     |
		     SF_NOTIFY_LOG                |
		     SF_NOTIFY_END_OF_NET_SESSION |
		     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "PWS Admin Helper Filter, v1.0" );

    //
    // initialize
    //
    if ( !CreatePwsSharedMemory( ) )
        {
	    return(FALSE);
        }

    return TRUE;
}

//-----------------------------------------------------------------
DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
    {
	// see if the time period needs to roll over
	 CheckTimePeriod( &PwsData->PwsStats);

    //
    //  If we don't have a context already, create one now
    //
    if ( !pfc->pFilterContext )
        {
	    pfc->pFilterContext = (VOID *) UIntToPtr(ReqNumber);
        ReqNumber++;

#if 0
	    IIS_PRINTF(( buff,
		    "[HttpFilterProc] New request, ID = %d, fIsSecurePort = %s\n",
		    pfc->pFilterContext,
		    (pfc->fIsSecurePort ? "TRUE" : "FALSE") ));
#endif
        //
        // get the ip address of the remote client
        char   ip[80];
        DWORD   dwSize = sizeof(ip);
        if ( (pfc->GetServerVariable)(pfc, "REMOTE_ADDR", &ip, &dwSize) )
            {
            DWORD dwIP = inet_addr( ip );

            if ( FTrackIP(dwIP, 0, 0) )
	            // increment the global counters
	            PwsData->PwsStats.nTotalSessionsStart++;

            if ( FTrackIP(dwIP, PwsData->PwsStats.time_hour, 0) )
	            // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbHourData[0].nTotalSessions++;

            if ( FTrackIP(dwIP, 0, PwsData->PwsStats.time_day) )
	            // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbDayData[0].nTotalSessions++;
            }
        else
            {
            DWORD err;
            err = GetLastError();
            }

        // increment the number of currently active sessions
        //

	    PwsData->PwsStats.nSessions++;

        // increase max sessions, if necessary
	    if ( PwsData->PwsStats.nSessions > PwsData->PwsStats.nMaxSessionsStart )
	        PwsData->PwsStats.nMaxSessionsStart = PwsData->PwsStats.nSessions;
        }

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
        {
        case SF_NOTIFY_END_OF_NET_SESSION:
	        PwsData->PwsStats.nSessions--;
	        pfc->pFilterContext = 0;
	        break;

        case SF_NOTIFY_LOG:
            {
	        PHTTP_FILTER_LOG logData = (PHTTP_FILTER_LOG)pvData;

	        if ( _stricmp(logData->pszOperation,"GET") == 0 )
                {
                // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbDayData[0].nHits++;
	            PwsData->PwsStats.rgbHourData[0].nHits++;

                // increment the number of hits since server startup
	            PwsData->PwsStats.nHitsStart++;
	            }

            // increment the number of bytes sent in the current time period
	        PwsData->PwsStats.rgbDayData[0].nBytesSent += logData->dwBytesSent;
	        PwsData->PwsStats.rgbHourData[0].nBytesSent += logData->dwBytesSent;

	        // increment the number of bytes sent since server startup
	        PwsData->PwsStats.nBytesSentStart += logData->dwBytesSent;
	        }
	        break;

        default:
	    IIS_PRINTF(( buff,
		    "[HttpFilterProc] Unknown notification type, %x\n",
		    NotificationType ));
	        break;
        }

    FlushViewOfFile((LPCVOID)PwsData,0);
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

//-----------------------------------------------------------------
BOOL
CreatePwsSharedMemory(
    VOID
    )
{
//DebugBreak();
    ZeroMemory( &g_rgbIPTrack, sizeof(g_rgbIPTrack) );
    ZeroMemory( &g_rgbIPHourTrack, sizeof(g_rgbIPHourTrack) );
    ZeroMemory( &g_rgbIPDayTrack, sizeof(g_rgbIPDayTrack) );
    INITIALIZE_CRITICAL_SECTION( &g_ip_section );

    hFileMap = CreateFileMapping(
		    INVALID_HANDLE_VALUE,
		    NULL,
		    PAGE_READWRITE,
		    0,
		    sizeof(PWS_DATA_PRIVATE),
		    PWS_DATA_SPACE_NAME
		    );

    if ( hFileMap == NULL ) {
	IIS_PRINTF((buff,
	    "Error %d in CreateFileMapping\n", GetLastError()));
	return(FALSE);
    }

    PwsData = (PPWS_DATA_PRIVATE)MapViewOfFile(
				    hFileMap,
				    FILE_MAP_ALL_ACCESS,
				    0,
				    0,
				    sizeof(PWS_DATA_PRIVATE)
				    );

    if ( PwsData == NULL ) {
	IIS_PRINTF((buff,"Error %d in MapViewOfFile\n", GetLastError()));
	CloseHandle(hFileMap);
	hFileMap = NULL;
	return(FALSE);
    }

    //
    // Initialize
    //
    ZeroMemory(PwsData,sizeof(PWS_DATA_PRIVATE));
    PwsData->dwSize = sizeof(PWS_DATA_PRIVATE);
    PwsData->Signature = PWS_DATA_SIGNATURE;

    // since this is our first opportunity to do something, record the start time
    GetLocalTime( &PwsData->PwsStats.timeStart );

    return(TRUE);

} // CreatePwsSharedMemory


//-----------------------------------------------------------------
// by Boyd Multerer
// the pwsData structure contains two arrays - rgbDayData[] and rgbHourData[]
// these arrays store the statics for the previous time periods, so we can show
// a continuing chart over time. Since these are maintained by the server, the
// data will be updated regardless of whether or not the pws ui app is running.
// in both cases [0] represents the current time period. Each position after
// that goes back one time period.
void CheckTimePeriod( PPWS_DATA pData )
	{
    // stop this reentrency stuff
    static BOOL    fCheckBusy = FALSE;
    if ( fCheckBusy ) return;
        fCheckBusy = TRUE;

	// milliseconds
#define ONE_HOUR                3600000
	// hours
#define ONE_DAY                 86400000

	SYSTEMTIME      timeCurrent;

	// get the current time & ticks
	GetLocalTime( &timeCurrent );

    // convert the time - to get the day of year and hour. Disregard minutes and seconds
    time_t  time_hour, time_day;
	struct tm atm;

	atm.tm_sec = 0;
	atm.tm_min = 0;
	atm.tm_hour = timeCurrent.wHour;
	atm.tm_mday = timeCurrent.wDay;
	atm.tm_mon = timeCurrent.wMonth - 1;        // tm_mon is 0 based
	atm.tm_year = timeCurrent.wYear - 1900;     // tm_year is 1900 based
	atm.tm_isdst = -1;

    // store times based on the break of the most recent hour and day
	time_hour = mktime(&atm);
    time_day = time_hour - (atm.tm_hour * 3600);

	// if the stored structure is zeroed out, then this is the first time
	// this routine is called. Just set the date and return
	if ( pData->time_day == 0 )
		{
		pData->time_hour = time_hour;
		pData->time_day = time_day;
        fCheckBusy = FALSE;
		return;
		}

    // we only have to worry if the time has changed to a different hour
    if ( time_hour == pData->time_hour )
        {
        fCheckBusy = FALSE;
        return;
        }

    // calculate the deltas
    time_t dHour = time_hour - pData->time_hour;
        dHour /= 3600;

    time_t dDay = time_day - pData->time_day;
        dDay /= 86400;

    // lets start by saying that if they just set their clock BACK by any time
    // and it is in a different hour (don't bother with minor adjustments) then
    // we advance everything one hour. This will be most useful during dayling-savings
    // time conversions. Where did that hour of data go? Ah. it is still there.
    if ( dHour < 0 )
        dHour = 1;
    if ( dDay < 0 )
        dDay = 1;

    // if the time period has changed we need to move all the values back one.
    // do the days first
    if ( dDay > 0 )
        {
	    if ( dDay >= 7 )
		    {
		    ZeroMemory( &pData->rgbDayData, sizeof(PWS_DATA_PERIOD) * 7 );
		    }
	    else
		    {
            // move everything back by the proper amount first
            MoveMemory( &pData->rgbDayData[dDay], &pData->rgbDayData[0],
                            sizeof(PWS_DATA_PERIOD) * (7 - dDay) );
            // clear out the newly exposed periods in the front
            ZeroMemory( &pData->rgbDayData[0], sizeof(PWS_DATA_PERIOD) * dDay );
		    }
        }

    // do the hours
    if ( dHour > 0 )
        {
	    if ( dHour >= 24 )
		    {
		    ZeroMemory( &pData->rgbHourData, sizeof(PWS_DATA_PERIOD) * 24 );
		    }
	    else
		    {
            // move everything back by the proper amount first
            MoveMemory( &pData->rgbHourData[dHour], &pData->rgbHourData[0],
                            sizeof(PWS_DATA_PERIOD) * (24 - dHour) );
            // clear out the newly exposed periods in the front
            ZeroMemory( &pData->rgbHourData[0], sizeof(PWS_DATA_PERIOD) * dHour );
		    }
        }

	// update the last time
    pData->time_hour = time_hour;
    pData->time_day = time_day;
    fCheckBusy = FALSE;
	}


//-------------------------------------------------------------------------
// returns TRUE if the ip should tracked. returns FALSE if it is already there
// and should not be tracked. Note that it only watches a fixed number of IP
// addresses that is dertermined by the constant TRACK_IP_NUM
// CopyMemory version
BOOL FTrackIP( DWORD ip, time_t hour, time_t day )
    {
    DWORD   testIndex;
    BOOL    fAnswer = TRUE;

    EnterCriticalSection( &g_ip_section );

    // loop throught the tracked addresses, looking for a space
    for (testIndex = 0; testIndex < TRACK_IP_NUM; testIndex++)
        {
        if ( g_rgbIPTrack[testIndex] == ip )
		    {
            // if requested, check the hour
            if ( hour )
                fAnswer = ( hour != g_rgbIPHourTrack[testIndex] );
            else if ( day )
                fAnswer = ( day != g_rgbIPDayTrack[testIndex] );
            else
                // It has already been counted
                fAnswer = FALSE;
            goto cleanup;
		    }

        // this block only matters
        if ( g_rgbIPTrack[testIndex] == NULL )
            {
            fAnswer = TRUE;
            goto cleanup;
            }
        }

    // if we get here, then it is not one of the last TRACK_IP_NUM address.
    // Shift the array down one space and put this one in the beginning
    MoveMemory( &g_rgbIPTrack[1], &g_rgbIPTrack, sizeof(DWORD) * (TRACK_IP_NUM-1) );
    testIndex = 0;
    g_rgbIPHourTrack[testIndex] = 0;
    g_rgbIPDayTrack[testIndex] = 0;

cleanup:
    // track the values
    if ( fAnswer )
        {
        g_rgbIPTrack[testIndex] = ip;
        if ( hour )
            g_rgbIPHourTrack[testIndex] = hour;
        if ( day )
            g_rgbIPDayTrack[testIndex] = day;
        }

    // leave the section
	LeaveCriticalSection( &g_ip_section );

    // return true because we are tracking it
    return fAnswer;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\urlscan\urlscan.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name: UrlScan.cpp

Abstract:

    ISAPI filter to scan URLs and reject illegal character
    sequences

Author:

    Wade A. Hilmo, May 2001

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <mbstring.h>
#include <httpfilt.h>
#include "Utils.h"

//
// Definitions
//

#define MODULE_NAME                   "UrlScan"
#define MAX_SECTION_DATA                  65536 //  64KB
#define LOG_MAX_LINE                       1024
#define LOG_LONG_URL_LINE                131072 // 128KB
#define STRING_IP_SIZE                       16
#define INSTANCE_ID_SIZE                     16
#define SIZE_DATE_TIME                       32
#define SIZE_SMALL_HEADER_VALUE              32
#define MAX_LOG_PATH    MAX_PATH+SIZE_DATE_TIME

//
// Default options
//

#define DEFAULT_USE_ALLOW_VERBS             1
#define DEFAULT_USE_ALLOW_EXTENSIONS        0
#define DEFAULT_NORMALIZE_URL_BEFORE_SCAN   1
#define DEFAULT_VERIFY_NORMALIZATION        1
#define DEFAULT_ALLOW_HIGH_BIT_CHARACTERS   0
#define DEFAULT_ALLOW_DOT_IN_PATH           0
#define DEFAULT_REMOVE_SERVER_HEADER        0
#define DEFAULT_ENABLE_LOGGING              1
#define DEFAULT_PER_PROCESS_LOGGING         0
#define DEFAULT_ALLOW_LATE_SCANNING         0
#define DEFAULT_USE_FAST_PATH_REJECT        0
#define DEFAULT_PER_DAY_LOGGING             1
#define DEFAULT_LOG_LONG_URLS               0
#define DEFAULT_REJECT_RESPONSE_URL         "/<Rejected-By-UrlScan>"
#define LOGGING_ONLY_MODE_URL               "/~*"
#define DEFAULT_MAX_ALLOWED_CONTENT_LENGTH  "30000000"
#define DEFAULT_MAX_URL                     "260"
#define DEFAULT_MAX_QUERY_STRING            "4096"
#define DEFAULT_LOGGING_DIRECTORY           ""
#define EMBEDDED_EXE_EXTENSION              ".exe/"
#define EMBEDDED_COM_EXTENSION              ".com/"
#define EMBEDDED_DLL_EXTENSION              ".dll/"


//
// Global Option Settings and init data
//

BOOL    g_fInitSucceeded;
BOOL    g_fUseAllowVerbs;
BOOL    g_fUseAllowExtensions;
BOOL    g_fNormalizeBeforeScan;
BOOL    g_fVerifyNormalize;
BOOL    g_fAllowHighBit;
BOOL    g_fAllowDotInPath;
BOOL    g_fRemoveServerHeader;
BOOL    g_fUseAltServerName;
BOOL    g_fAllowLateScanning;
BOOL    g_fUseFastPathReject;
BOOL    g_fEnableLogging;
BOOL    g_fPerDayLogging;
BOOL    g_fLoggingOnlyMode;
BOOL    g_fLogLongUrls;

STRING_ARRAY    g_Verbs;
STRING_ARRAY    g_Extensions;
STRING_ARRAY    g_Sequences;
STRING_ARRAY    g_HeaderNames;
STRING_ARRAY    g_LimitedHeaders;

CHAR            g_szLastLogDate[SIZE_DATE_TIME] = "00-00-0000";
CHAR            g_szInitUrlScanDate[SIZE_DATE_TIME*2] = "";
CHAR            g_szRejectUrl[MAX_PATH];
CHAR            g_szConfigFile[MAX_PATH];
CHAR            g_szLoggingDirectory[MAX_PATH];
CHAR            g_szAlternateServerName[MAX_PATH] = "";
CHAR            g_szRaw400Response[] =
                    "HTTP/1.1 400 Bad Request\r\n"
                    "Content-Type: text/html\r\n"
                    "Content-Length: 87\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                    "<html><head><title>Error</title></head>"
                    "<body>The parameter is incorrect. </body>"
                    "</html>"
                    ;

DWORD           g_cbRaw400Response;
DWORD           g_dwServerMajorVersion;
DWORD           g_dwServerMinorVersion;
DWORD           g_dwMaxAllowedContentLength;
DWORD           g_dwMaxUrl;
DWORD           g_dwMaxQueryString;
DWORD *         g_pMaxHeaderLengths = NULL;

//
// Global Logging Settings 
//

HANDLE              g_hLogFile = INVALID_HANDLE_VALUE;
CRITICAL_SECTION    g_LogFileLock;

//
// Local Declarations
//

DWORD
InitFilter();

BOOL
ReadConfigData();

BOOL
InitLogFile();

BOOL
ReadIniSectionIntoArray(
    STRING_ARRAY *  pStringArray,
    LPSTR           szSectionName,
    BOOL            fStoreAsLowerCase
    );

VOID
TrimCommentAndTrailingWhitespace(
    LPSTR   szString
    );

BOOL
WriteLog(
    LPSTR   szString,
    ...
    );

DWORD
DoPreprocHeaders(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc
    );

DWORD
DoSendResponse(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_SEND_RESPONSE *     pResponse
    );

DWORD
DoSendRawData(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_RAW_DATA *          pRawData
    );

DWORD
DoEndOfRequest(
    HTTP_FILTER_CONTEXT *           pfc
    );

VOID
GetIpAddress(
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   szIp,
    DWORD                   cbIp
    );

VOID
GetInstanceId(
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   szId,
    DWORD                   cbId
    );

BOOL
NormalizeUrl(
    HTTP_FILTER_CONTEXT *   pfc,
    DATA_BUFF *             pRawUrl,
    DATA_BUFF *             pNormalizedUrl
    );

//
// ISAPI entry point implementations
//

BOOL
WINAPI
GetFilterVersion(
    PHTTP_FILTER_VERSION    pVer
    )
/*++

  Required entry point for ISAPI filters.  This function
  is called when the server initially loads this DLL.

  Arguments:

    pVer - Points to the filter version info structure

  Returns:

    TRUE on successful initialization
    FALSE on initialization failure

--*/
{
    DWORD   dwFlags;

    //
    // Initialize the logging critical section
    //

    InitializeCriticalSection( &g_LogFileLock );

    //
    // Set the filter version and descriptions
    //

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    strncpy(
        pVer->lpszFilterDesc,
        "UrlScan ISAPI Filter",
        SF_MAX_FILTER_DESC_LEN
        );

    pVer->lpszFilterDesc[SF_MAX_FILTER_DESC_LEN - 1] = '\0';

    //
    // Capture the version of the IIS server on which we're running
    //

    g_dwServerMajorVersion = pVer->dwServerFilterVersion >> 16;
    g_dwServerMinorVersion = pVer->dwServerFilterVersion & 0x0000ffff;

    //
    // The pVer->dwFlags member is the mechanism by which a filter
    // can tell IIS which notifications it's interested in, as well
    // as what priority to run at.  The InitFilter function will
    // return the appropriate set of flags, based on the configured
    // options.
    //

    dwFlags = InitFilter();

    if ( dwFlags == 0 )
    {
        //
        // Setting g_fInitSucceeded will cause UrlScan to fail
        // all requests.
        //

        g_fInitSucceeded = FALSE;

        pVer->dwFlags = SF_NOTIFY_ORDER_HIGH | SF_NOTIFY_PREPROC_HEADERS;
    }
    else
    {
        g_fInitSucceeded = TRUE;

        pVer->dwFlags = dwFlags;
    }

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT    pfc,
    DWORD                   dwNotificationType,
    LPVOID                  pvNotification
    )
/*++

  Required filter notification entry point.  This function is called
  whenever one of the events (as registered in GetFilterVersion) occurs.

  Arguments:

    pfc              - A pointer to the filter context for this notification
    NotificationType - The type of notification
    pvNotification   - A pointer to the notification data

  Returns:

    One of the following valid filter return codes:
    - SF_STATUS_REQ_FINISHED
    - SF_STATUS_REQ_FINISHED_KEEP_CONN
    - SF_STATUS_REQ_NEXT_NOTIFICATION
    - SF_STATUS_REQ_HANDLED_NOTIFICATION
    - SF_STATUS_REQ_ERROR
    - SF_STATUS_REQ_READ_NEXT

--*/
{
    switch ( dwNotificationType )
    {
    case SF_NOTIFY_PREPROC_HEADERS:

        return DoPreprocHeaders(
            pfc,
            (HTTP_FILTER_PREPROC_HEADERS *)pvNotification
            );

    case SF_NOTIFY_SEND_RESPONSE:

        return DoSendResponse(
            pfc,
            (HTTP_FILTER_SEND_RESPONSE *)pvNotification
            );
    case SF_NOTIFY_SEND_RAW_DATA:

        return DoSendRawData(
            pfc,
            (HTTP_FILTER_RAW_DATA *)pvNotification
            );

    case SF_NOTIFY_END_OF_REQUEST:

        return DoEndOfRequest(
            pfc
            );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

BOOL WINAPI TerminateFilter(
    DWORD   dwFlags
    )
/*++

  Optional filter entry point.  This function is called by the server
  before this DLL is unloaded.

  Arguments:

    dwFlags - No flags have been defined at this time

  Returns:

    Always returns TRUE;

--*/
{
    if ( g_pMaxHeaderLengths )
    {
        LocalFree( g_pMaxHeaderLengths );
        g_pMaxHeaderLengths = NULL;
    }

    if ( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        WriteLog(
            "---------------- UrlScan.dll Terminating -----------------\r\n"
            );

        
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;

    }

    DeleteCriticalSection( &g_LogFileLock );

    return TRUE;
}

DWORD
InitFilter(
    VOID
    )
/*++

  This function initializes the filter by reading the configuration
  file and setting up the data structures used at run time.

  Arguments:

    None

  Returns:

    The filter notification flags to hand off to IIS, or
    zero on failure

--*/
{
    LPSTR   pCursor;
    DWORD   dwNumEntries;
    DWORD   x;
    DWORD   dwRet = 0;

    //
    // Get the module path so that we can
    // determine the config file name and the
    // log file name.
    //

    GetModuleFileName(
        GetModuleHandle( MODULE_NAME ),
        g_szConfigFile,
        MAX_PATH
        );

    pCursor = strrchr( g_szConfigFile, '.' );

    if ( pCursor )
    {
        *(pCursor+1) = '\0';
    }

    // Config file name
    strcat( g_szConfigFile, "ini" );

    //
    // Set the size of the 400 response that we'll send
    // for malformed requests.
    //

    g_cbRaw400Response = strlen( g_szRaw400Response );

    //
    // Read the config data
    //

    if ( !ReadConfigData() )
    {
        WriteLog(
            "*** Warning *** Error %d occurred reading configuration data. "
            "UrlScan will reject all requests.\r\n",
            GetLastError()
            );

        return 0;
    }

    //
    // Report the config data to the log
    //

    if ( g_fLoggingOnlyMode )
    {
        WriteLog( "********************************************************\r\n" );
        WriteLog( "** UrlScan is in Logging-Only Mode.  Request analysis **\r\n" );
        WriteLog( "** will be logged, but no requests will be rejected.  **\r\n" );
        WriteLog( "********************************************************\r\n" );
    }
    else if ( !g_fUseFastPathReject )
    {
        {
            WriteLog(
                "UrlScan will return the following URL "
                "for rejected requests: \"%s\"\r\n",
                g_szRejectUrl
                );
        }
    }
              
    if ( g_fNormalizeBeforeScan )
    {
        WriteLog( "URLs will be normalized before analysis.\r\n" );
    }
    else
    {
        WriteLog( "Analysis will apply to raw URLs.\r\n" );
    }

    if ( g_fVerifyNormalize )
    {
        WriteLog( "URL normalization will be verified.\r\n" );
    }

    if ( g_fAllowHighBit )
    {
        WriteLog( "URLs may contain OEM, international and UTF-8 characters.\r\n" );
    }
    else
    {
        WriteLog( "URLs must contain only ANSI characters.\r\n" );
    }

    if ( !g_fAllowDotInPath )
    {
        WriteLog( "URLs must not contain any dot except for the file extension.\r\n" );
    }

    if ( g_fLogLongUrls )
    {
        WriteLog( "URLs will be logged up to 128K bytes.\r\n" );
    }

    WriteLog( "Requests with Content-Length exceeding %u will be rejected.\r\n", g_dwMaxAllowedContentLength );

    WriteLog( "Requests with URL length exceeding %u will be rejected.\r\n", g_dwMaxUrl );

    WriteLog( "Requests with Query String length exceeding %u will be rejected.\r\n", g_dwMaxQueryString );

    if ( g_fRemoveServerHeader )
    {
        //
        // IIS 4.0 or later is required to modify the response
        // server header.
        //

        if ( g_dwServerMajorVersion >= 4 )
        {
            WriteLog( "The 'Server' header will be removed on responses.\r\n" );
        }
        else
        {
            WriteLog(
                "*** Warning *** IIS 4.0 or later is required to "
                "remove the 'Server' response header.\r\n"
                );

            g_fRemoveServerHeader = 0;
        }
    }

    if ( g_fUseAltServerName )
    {
        //
        // IIS 4.0 or later is required to modify the response
        // server header.
        //

        if ( g_dwServerMajorVersion >= 4 )
        {
            WriteLog(
                "The 'Server' header will contain '%s' on responses.\r\n",
                g_szAlternateServerName
                );
        }
        else
        {
            WriteLog(
                "*** Warning *** IIS 4.0 or later is required to "
                "modify the 'Server' response header.\r\n"
                );

            g_fUseAltServerName = 0;
        }
    }

    dwNumEntries = g_Verbs.QueryNumEntries();

    if ( dwNumEntries )
    {
        if ( g_fUseAllowVerbs )
        {
            WriteLog( "Only the following verbs will be allowed (case sensitive):\r\n" );
        }
        else
        {
            WriteLog( "Requests for following verbs will be rejected:\r\n" );
        }

        for ( x = 0; x < dwNumEntries; x++ )
        {
            WriteLog( "\t'%s'\r\n", g_Verbs.QueryStringByIndex( x ) );
        }
    }
    else if ( g_fUseAllowVerbs )
    {
        WriteLog( "*** Warning *** No verbs have been allowed, so all requests will be rejected.\r\n" );
    }

    dwNumEntries = g_Extensions.QueryNumEntries();

    if ( dwNumEntries )
    {
        if ( g_fUseAllowExtensions )
        {
            WriteLog( "Only the following extensions will be allowed:\r\n" );
        }
        else
        {
            WriteLog( "Requests for following extensions will be rejected:\r\n" );
        }

        for ( x = 0; x < dwNumEntries; x++ )
        {
            //
            // If the extension appears malformed (ie. doesn't start with
            // a '.'), then warn here.
            //

            pCursor = g_Extensions.QueryStringByIndex( x );

            if ( pCursor && pCursor[0] != '.' )
            {
                WriteLog(
                    "\t'%s' *** Warning *** Invalid extension.  Must start with '.'.\r\n",
                    pCursor
                    );
            }
            else
            {
                WriteLog(
                    "\t'%s'\r\n",
                    pCursor
                    );
            }

        }
    }
    else if ( g_fUseAllowExtensions )
    {
        WriteLog( "*** Warning *** No extensions have been allowed, so all requests will be rejected.\r\n" );
    }

    dwNumEntries = g_HeaderNames.QueryNumEntries();

    if ( dwNumEntries )
    {
        WriteLog( "Requests containing the following headers will be rejected:\r\n" );

        for ( x = 0; x < dwNumEntries ; x++ )
        {
            //
            // If the header name appears malformed (ie. doesn't end in
            // ':'), then warn here.
            //

            pCursor = g_HeaderNames.QueryStringByIndex( x );

            if ( pCursor && pCursor[strlen(pCursor)-1] != ':' )
            {
                WriteLog(
                    "\t'%s' *** Warning *** Invalid header name.  Must end in ':'.\r\n",
                    pCursor
                    );
            }
            else
            {
                WriteLog(
                    "\t'%s'\r\n",
                    pCursor
                    );
            }

        }
    }

    dwNumEntries = g_Sequences.QueryNumEntries();

    if ( dwNumEntries )
    {
        WriteLog( "Requests containing the following character sequences will be rejected:\r\n" );

        for ( x = 0; x < dwNumEntries ; x++ )
        {
            WriteLog( "\t'%s'\r\n", g_Sequences.QueryStringByIndex( x ) );
        }
    }

    dwNumEntries = 0;
    
    for ( x = 0; x < g_LimitedHeaders.QueryNumEntries(); x++ )
    {
        if ( g_pMaxHeaderLengths[x] )
        {
            dwNumEntries++;
        }
    }

    if ( dwNumEntries )
    {
        WriteLog( "The following header size limits are in effect:\r\n" );

        for ( x = 0; x < dwNumEntries; x++ )
        {
            if ( g_pMaxHeaderLengths[x] )
            {
                WriteLog(
                    "\t'%s' - %u bytes.\r\n",
                    g_LimitedHeaders.QueryStringByIndex( x ),
                    g_pMaxHeaderLengths[x]
                    );
            }
        }
    }

    //
    // Determine the filter notification flags that we'll need
    //

    dwRet = g_fAllowLateScanning ? SF_NOTIFY_ORDER_LOW : SF_NOTIFY_ORDER_HIGH;

    if ( g_fVerifyNormalize ||
         g_fAllowHighBit == FALSE ||
         g_fAllowDotInPath == FALSE ||
         g_Verbs.QueryNumEntries() ||
         g_Extensions.QueryNumEntries() ||
         g_HeaderNames.QueryNumEntries() ||
         g_Sequences.QueryNumEntries() )
    {
        dwRet |= SF_NOTIFY_PREPROC_HEADERS;
    }

    if ( g_fRemoveServerHeader ||
         g_fUseAltServerName )
    {
        dwRet |= SF_NOTIFY_SEND_RESPONSE;
        dwRet |= SF_NOTIFY_SEND_RAW_DATA;
        dwRet |= SF_NOTIFY_END_OF_REQUEST;
    }

    return dwRet;
}

BOOL
ReadConfigData()
/*++

  This function reads the configuration data for the filter.

  Arguments:

    None

  Returns:

    TRUE if successful, else FALSE

--*/
{
    LPSTR           pCursor;
    LPSTR           pWhite = NULL;
    BOOL            fRet = TRUE;
    BOOL            fResult;
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           cch;
    DWORD           x;
    DWORD           dwIndex;
    CHAR            szValue[SIZE_SMALL_HEADER_VALUE];
    CHAR            szTempLoggingDirectory[MAX_PATH];
    STRING_ARRAY    RequestLimits;

    //
    // Read in the options section
    //

    g_fUseAllowVerbs = GetPrivateProfileInt(
        "Options",
        "UseAllowVerbs",
        DEFAULT_USE_ALLOW_VERBS,
        g_szConfigFile
        );

    g_fUseAllowExtensions = GetPrivateProfileInt(
        "Options",
        "UseAllowExtensions",
        DEFAULT_USE_ALLOW_EXTENSIONS,
        g_szConfigFile
        );

    g_fNormalizeBeforeScan = GetPrivateProfileInt(
        "Options",
        "NormalizeUrlBeforeScan",
        DEFAULT_NORMALIZE_URL_BEFORE_SCAN,
        g_szConfigFile
        );

    g_fVerifyNormalize = GetPrivateProfileInt(
        "Options",
        "VerifyNormalization",
        DEFAULT_VERIFY_NORMALIZATION,
        g_szConfigFile
        );

    g_fAllowHighBit = GetPrivateProfileInt(
        "Options",
        "AllowHighBitCharacters",
        DEFAULT_ALLOW_HIGH_BIT_CHARACTERS,
        g_szConfigFile
        );

    g_fAllowDotInPath = GetPrivateProfileInt(
        "Options",
        "AllowDotInPath",
        DEFAULT_ALLOW_DOT_IN_PATH,
        g_szConfigFile
        );

    g_fRemoveServerHeader = GetPrivateProfileInt(
        "Options",
        "RemoveServerHeader",
        DEFAULT_REMOVE_SERVER_HEADER,
        g_szConfigFile
        );

    g_fAllowLateScanning = GetPrivateProfileInt(
        "Options",
        "AllowLateScanning",
        DEFAULT_ALLOW_LATE_SCANNING,
        g_szConfigFile
        );

    g_fEnableLogging = GetPrivateProfileInt(
        "Options",
        "EnableLogging",
        DEFAULT_ENABLE_LOGGING,
        g_szConfigFile
        );

    g_fPerDayLogging = GetPrivateProfileInt(
        "Options",
        "PerDayLogging",
        DEFAULT_PER_DAY_LOGGING,
        g_szConfigFile
        );

    g_fLogLongUrls = GetPrivateProfileInt(
        "Options",
        "LogLongUrls",
        DEFAULT_LOG_LONG_URLS,
        g_szConfigFile
        );

    //
    // Calculate the max allowed content-length, URL and
    // query string as DWORDs
    //

    GetPrivateProfileString(
        "RequestLimits",
        "MaxAllowedContentLength",
        DEFAULT_MAX_ALLOWED_CONTENT_LENGTH,
        szValue,
        SIZE_SMALL_HEADER_VALUE,
        g_szConfigFile
        );

    g_dwMaxAllowedContentLength = strtoul(
        szValue,
        NULL,
        10
        );

    GetPrivateProfileString(
        "RequestLimits",
        "MaxUrl",
        DEFAULT_MAX_URL,
        szValue,
        SIZE_SMALL_HEADER_VALUE,
        g_szConfigFile
        );

    g_dwMaxUrl = strtoul(
        szValue,
        NULL,
        10
        );

    GetPrivateProfileString(
        "RequestLimits",
        "MaxQueryString",
        DEFAULT_MAX_QUERY_STRING,
        szValue,
        SIZE_SMALL_HEADER_VALUE,
        g_szConfigFile
        );

    g_dwMaxQueryString = strtoul(
        szValue,
        NULL,
        10
        );

    //
    // Set the logging directory
    //

    GetPrivateProfileString(
        "Options",
        "LoggingDirectory",
        DEFAULT_LOGGING_DIRECTORY,
        szTempLoggingDirectory,
        MAX_PATH,
        g_szConfigFile
        );

    TrimCommentAndTrailingWhitespace( szTempLoggingDirectory );

    if ( strcmp( szTempLoggingDirectory, DEFAULT_LOGGING_DIRECTORY ) != 0 )
    {
        //
        // Figure out if this path is absolute or relative to
        // the config directory.
        //

        if ( ( szTempLoggingDirectory[0] != '\0' &&
               szTempLoggingDirectory[1] == ':' ) ||
             ( szTempLoggingDirectory[0] == '\\' &&
               szTempLoggingDirectory[1] == '\\' ) )
        {
            //
            // szTempLoggingDirectory starts with "x:" or "\\",
            // so this is an absolute path.
            //

            strncpy( g_szLoggingDirectory, szTempLoggingDirectory, MAX_PATH );
            g_szLoggingDirectory[MAX_PATH-1] = '\0';
        }
        else if ( szTempLoggingDirectory[0] == '\\' )
        {
            //
            // szTempLoggingDirectory starts with "\", so it's
            // relative to the root of the drive where the config
            // file is located.
            //
            // Unfortunately, if the config file is on a UNC path,
            // some pretty ugly parsing would be required to build
            // the path properly.  Since that's a very corner case
            // (since it's dangerous to run a filter on a UNC path),
            // we'll punt and just pretend LoggingDirectory was
            // unspecified.
            //

            if ( g_szConfigFile[0] == '\\' &&
                 g_szConfigFile[1] == '\\' )
            {
                g_szLoggingDirectory[0] = '\0';
            }
            else
            {
                strncpy( g_szLoggingDirectory, g_szConfigFile, 2 );
                g_szLoggingDirectory[2] = '\0';

                strncpy( g_szLoggingDirectory+2, szTempLoggingDirectory, MAX_PATH-2 );
                g_szLoggingDirectory[MAX_PATH-1] = '\0';
            }
        }
        else
        {
            //
            // szTempLoggingDirectory is relative to the config
            // file path
            //

            strncpy( g_szLoggingDirectory, g_szConfigFile, MAX_PATH );
            g_szLoggingDirectory[MAX_PATH-1] = '\0';

            pCursor = strrchr( g_szLoggingDirectory, '\\' );

            if ( pCursor )
            {
                pCursor++;
                *pCursor = '\0';
            }
            else
            {
                pCursor = g_szLoggingDirectory + strlen( g_szLoggingDirectory );
            }

            strncat( g_szLoggingDirectory,
                     szTempLoggingDirectory,
                     MAX_PATH-(pCursor-g_szLoggingDirectory+1) );

            g_szLoggingDirectory[MAX_PATH-1] = '\0';
        }

        //
        // If the logging directory has a trailing '\\' after all this,
        // then strip it.
        //

        cch = strlen( g_szLoggingDirectory );

        if ( cch && g_szLoggingDirectory[cch-1] == '\\' )
        {
            g_szLoggingDirectory[cch-1] = '\0';
        }
    }

    //
    // If logging is enabled, init the log file now.
    //
    // Unfortunately, there is nothing that we can do to
    // warn of a failure to open the log file, short of
    // sending some thing to the debugger.
    //
    // Note that in the case of PerDayLogging, we should
    // not initialize the log file, as the first write
    // will do it.
    //

    if ( !g_fPerDayLogging )
    {
        InitLogFile();
    }

    WriteLog(
        "---------------- UrlScan.dll Initializing ----------------\r\n"
        );


    //
    // Use a custom server response header?
    //

    g_fUseAltServerName = FALSE;

    if ( !g_fRemoveServerHeader )
    {
        GetPrivateProfileString(
            "Options",
            "AlternateServerName",
            "",
            g_szAlternateServerName,
            MAX_PATH,
            g_szConfigFile
            );

        if ( *g_szAlternateServerName != '\0' )
        {
            TrimCommentAndTrailingWhitespace( g_szAlternateServerName );
            g_fUseAltServerName = TRUE;
        }
    }

    //
    // Logging only mode is turned off, unless configured
    // otherwise
    //

    g_fLoggingOnlyMode = FALSE;

    //
    // Use the fast path reject (ie. don't run a URL for
    // rejected requests)?
    //

    g_fUseFastPathReject = GetPrivateProfileInt(
        "Options",
        "UseFastPathReject",
        DEFAULT_USE_FAST_PATH_REJECT,
        g_szConfigFile
        );

    if ( !g_fUseFastPathReject )
    {
        //
        // What URL should we run for a rejected request?
        //

        GetPrivateProfileString(
            "Options",
            "RejectResponseUrl",
            DEFAULT_REJECT_RESPONSE_URL,
            g_szRejectUrl,
            MAX_PATH,
            g_szConfigFile
            );

        //
        // Trim comment from g_szRejectUrl
        //

        TrimCommentAndTrailingWhitespace( g_szRejectUrl );

        //
        // If trimming white space left us with no URL, then
        // restore the default one.
        //

        if ( *g_szRejectUrl == '\0' )
        {
            strncpy( g_szRejectUrl, DEFAULT_REJECT_RESPONSE_URL, MAX_PATH );
            g_szRejectUrl[MAX_PATH-1] = '\0';
        }
        
        //
        // Are we going into logging only mode?
        //

        if ( strcmp( g_szRejectUrl, LOGGING_ONLY_MODE_URL ) == 0 )
        {
            g_fLoggingOnlyMode = TRUE;
        }
    }

    //
    // Read in the other sections
    //

    fResult = ReadIniSectionIntoArray(
        &g_HeaderNames,
        "DenyHeaders",
        TRUE
        );

    if ( fResult == FALSE )
    {
        dwError = GetLastError();
        fRet = FALSE;
    }

    fResult = ReadIniSectionIntoArray(
        &g_Sequences,
        "DenyUrlSequences",
        TRUE
        );

    if ( fResult == FALSE )
    {
        dwError = GetLastError();
        fRet = FALSE;
    }

    if ( g_fUseAllowVerbs )
    {
        fResult = ReadIniSectionIntoArray(
            &g_Verbs,
            "AllowVerbs",
            FALSE
            );

        if ( fResult == FALSE )
        {
            dwError = GetLastError();
            fRet = FALSE;
        }
    }
    else
    {
        fResult = ReadIniSectionIntoArray(
            &g_Verbs,
            "DenyVerbs",
            TRUE
            );

        if ( fResult == FALSE )
        {
            dwError = GetLastError();
            fRet = FALSE;
        }
    }

    if ( g_fUseAllowExtensions )
    {
        fResult = ReadIniSectionIntoArray(
            &g_Extensions,
            "AllowExtensions",
            TRUE
            );

        if ( fResult == FALSE )
        {
            dwError = GetLastError();
            fRet = FALSE;
        }
    }
    else
    {
        fResult = ReadIniSectionIntoArray(
            &g_Extensions,
            "DenyExtensions",
            TRUE
            );

        if ( fResult == FALSE )
        {
            dwError = GetLastError();
            fRet = FALSE;
        }
    }

    //
    // Create arrays to store header names that are limited
    // by config.
    //

    fResult = ReadIniSectionIntoArray(
        &RequestLimits,
        "RequestLimits",
        FALSE
        );

    if ( fResult == FALSE )
    {
        dwError = GetLastError();
        fRet = FALSE;
    }

    g_pMaxHeaderLengths = (DWORD*)LocalAlloc( LPTR, RequestLimits.QueryNumEntries() * sizeof( DWORD ) );

    if ( !g_pMaxHeaderLengths )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        fRet = FALSE;
    }

    dwIndex = 0;

    for ( x = 0; x < RequestLimits.QueryNumEntries(); x++ )
    {
        if ( strnicmp( RequestLimits.QueryStringByIndex( x ), "max-", 4 ) == 0 )
        {
            pCursor = strchr( RequestLimits.QueryStringByIndex( x ), '=' );

            if ( pCursor )
            {
                *pCursor = '\0';

                GetPrivateProfileString(
                    "RequestLimits",
                    RequestLimits.QueryStringByIndex( x ),
                    "0",
                    szValue,
                    SIZE_SMALL_HEADER_VALUE,
                    g_szConfigFile
                    );

                g_pMaxHeaderLengths[dwIndex] = strtoul( szValue, NULL, 10 );

                *pCursor = ':';
                *(pCursor+1) = '\0';

                pCursor = RequestLimits.QueryStringByIndex( x ) + 4;

                fResult = g_LimitedHeaders.AddString( pCursor );

                if ( !fResult )
                {
                    dwError = GetLastError();
                    fRet = FALSE;
                }
            }

            dwIndex++;
        }
    }

    //
    // If a failure occured, reset the last error.  Note that this
    // mechanism only returns the error for the last failure...
    //

    if ( !fRet )
    {
        SetLastError( dwError );
    }

    return fRet;
}

BOOL
InitLogFile()
/*++

  This function initializes the log file for the filter.

  Arguments:

    None

  Returns:

    TRUE if successful, else FALSE

--*/
{
    CHAR    szLogFile[MAX_LOG_PATH];
    CHAR    szDebugOutput[1000];
    CHAR    szDate[SIZE_DATE_TIME];
    LPSTR   pCursor;

    if ( g_fEnableLogging )
    {
        //
        // Grab the logging lock
        //

        EnterCriticalSection( &g_LogFileLock );

        //
        // Derive the log file name. If specified, we'll
        // use the LoggingDirectory, else we'll derive
        // the logging directory from the path to UrlScan.dll
        //

        if ( g_szLoggingDirectory[0] != '\0' )
        {
            _snprintf(
                szLogFile,
                MAX_LOG_PATH,
                "%s\\%s.",
                g_szLoggingDirectory,
                MODULE_NAME
                );
        }
        else
        {
            strncpy( szLogFile, g_szConfigFile, MAX_LOG_PATH );
        }

        szLogFile[MAX_LOG_PATH-1] = '\0';

        pCursor = strrchr( szLogFile, '.' );

        //
        // We fully expect that the config file
        // name will contain a '.' character.  If not,
        // this is an error condition.
        //

        if ( pCursor )
        {
            //
            // If configured for per day logging, incorporate
            // the date into the filename.
            //

            if ( g_fPerDayLogging )
            {
                SYSTEMTIME  st;

                GetLocalTime( &st );

                GetDateFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    0,
                    &st,
                    "'.'MMddyy",
                    szDate,
                    SIZE_DATE_TIME
                    );
            }
            else
            {
                szDate[0] = '\0';
            }

            strncpy( pCursor, szDate, MAX_LOG_PATH-(pCursor-szLogFile+1) );
            szLogFile[MAX_LOG_PATH-1] = '\0';

            pCursor += strlen( szDate );

            //
            // If we are per process logging, incorporate
            // the current process ID into the filename.
            //

            if ( GetPrivateProfileInt(
                "Options",
                "PerProcessLogging",
                DEFAULT_PER_PROCESS_LOGGING,
                g_szConfigFile ) )
            {
                CHAR    szPid[SIZE_SMALL_HEADER_VALUE];

                _snprintf( szPid, SIZE_SMALL_HEADER_VALUE, ".%d.log", GetCurrentProcessId() );
                szPid[SIZE_SMALL_HEADER_VALUE-1] = '\0';

                strncpy( pCursor, szPid, MAX_LOG_PATH-(pCursor-szLogFile+1) );
            }
            else
            {
                strncpy( pCursor, ".log", MAX_LOG_PATH-(pCursor-szLogFile+1) );
            }

            szLogFile[MAX_LOG_PATH-1] = '\0';

            //
            // Now close any current file and open a new one
            //

            if ( g_hLogFile != INVALID_HANDLE_VALUE )
            {
                CloseHandle( g_hLogFile );
                g_hLogFile = INVALID_HANDLE_VALUE;
            }

            g_hLogFile = CreateFile(
                szLogFile,
                GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

            if ( g_hLogFile == INVALID_HANDLE_VALUE )
            {
                wsprintf(
                    szDebugOutput,
                    "[UrlScan.dll] Error %d occurred opening logfile '%s'.\r\n",
                    GetLastError(),
                    szLogFile
                    );

                OutputDebugString( szDebugOutput );
            }
            else
            {
                //
                // Report the log file initialization and make note of when
                // the filter itself initialized (so that it's easy to find
                // the date of the file that contains the filter init
                // report).
                //

                WriteLog(
                    "---------------- Initializing UrlScan.log ----------------\r\n"
                    );

                WriteLog(
                    "-- Filter initialization time: %s --\r\n",
                    g_szInitUrlScanDate
                    );
            }

            //
            // Better release that lock now
            //

            LeaveCriticalSection( &g_LogFileLock );
        }
        else
        {
            wsprintf(
                szDebugOutput,
                "[UrlScan.dll] Error deriving log file name from config file '%s'.\r\n",
                g_szConfigFile
                );

            OutputDebugString( szDebugOutput );
        }
    }

    //
    // Always return TRUE.  If this function fails, there really isn't
    // any way to report it.
    //

    return TRUE;
}


BOOL
ReadIniSectionIntoArray(
    STRING_ARRAY *  pStringArray,
    LPSTR           szSectionName,
    BOOL            fStoreAsLowerCase
    )
/*++

  This function parses a section from the config file such that
  each line is inserted into an array of strings.  Prior to
  insertion, comments and trailing whitespace are removed from
  each line.

  Arguments:

    pStringArray      - Upon return, contains the parsed strings
    szSectionName     - The section name to read
    fStoreAsLowerCase - If TRUE, the string is converted to lower
                        case prior to insertion.  This allows fast,
                        case insensitive searching.

  Returns:

    TRUE if successful, else FALSE

--*/
{
    CHAR    szSectionData[MAX_SECTION_DATA] = "";
    DWORD   cbSectionData = 0;
    LPSTR   pLine;
    LPSTR   pNextLine;
    LPSTR   pTrailingWhitespace;
    LPSTR   pCursor;
    BOOL    fRes;

    cbSectionData = GetPrivateProfileSection(
        szSectionName,
        szSectionData,
        MAX_SECTION_DATA,
        g_szConfigFile
        );

    //
    // The GetPrivateProfileSection call does not have any documented
    // failures cases.  It is noted, however, that it will return a
    // value that is exactly two less than the size of the buffer...
    //

    if ( cbSectionData >= MAX_SECTION_DATA - 2 )
    {
        //
        // Data truncation...
        //

        WriteLog(
            "*** Error processing UrlScan.ini section [%s] ***.  Section too long.\r\n",
            szSectionName
            );

        SetLastError( ERROR_INSUFFICIENT_BUFFER );

        return FALSE;
    }

    //
    // Parse the lines from the config file and insert them
    // into the pStringArray passed by the caller.
    //
    // Each line will be a null terminated string, with
    // a final null terminator after the last string.
    //
    // For each line, we need to remove any comment (denoted
    // by a ';' character) and trim trailing whitespace from
    // the resulting string.
    //

    pLine = szSectionData;

    while ( *pLine )
    {
        pNextLine = pLine + strlen( pLine ) + 1;

        //
        // Fix up the line
        //

        TrimCommentAndTrailingWhitespace( pLine );

        //
        // Need to store this as lower case?
        //

        if ( fStoreAsLowerCase )
        {
            strlwr( pLine );
        }

        //
        // Insert the resulting string into the array
        //

        fRes = pStringArray->AddString( pLine );
        
        if ( fRes == FALSE )
        {
            //
            // Error initializing section
            //
        }

        pLine = pNextLine;
    }

    return TRUE;
}

VOID
TrimCommentAndTrailingWhitespace(
    LPSTR   szString
    )
/*++

  This function trims a text line from an INI file
  such that it's truncated at the first instance of
  a ';'. Any trailing whitespace is also removed.

  Arguments:

    szString - The string to trim

  Returns:

    None

--*/
{
    LPSTR   pCursor = szString;
    LPSTR   pWhite = NULL;

    while ( *pCursor )
    {
        if ( *pCursor == ';' )
        {
            *pCursor = '\0';
            break;
        }

        if ( *pCursor == ' ' || *pCursor == '\t' )
        {
            if ( !pWhite )
            {
                pWhite = pCursor;
            }
        }
        else
        {
            pWhite = NULL;
        }

        pCursor++;
    }

    if ( pWhite )
    {
        *pWhite = '\0';
    }

    return;
}


BOOL
WriteLog(
    LPSTR   szString,
    ...
    )
/*++

  This function writes a line to the log for this filter using
  printf-style formatting.

  Arguments:

    szString - The format string
    ...      - Additional arguments

  Returns:

    TRUE on success, FALSE on failure

--*/
{
    SYSTEMTIME  st;
    CHAR        szCookedString[LOG_MAX_LINE+1];
    CHAR        szTime[SIZE_DATE_TIME];
    CHAR        szDate[SIZE_DATE_TIME];
    CHAR        szTimeStamp[SIZE_DATE_TIME*2];
    INT         cchCookedString;
    INT         cchTimeStamp;
    DWORD       cbToWrite;
    DWORD       cbCookedString = LOG_MAX_LINE+1;
    LPSTR       pCookedString = szCookedString;
    LPSTR       pNew;
    va_list     args;
    BOOL        fResult;

    //
    // If we don't have a log file handle, just return
    //

    if ( !g_fEnableLogging )
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    //
    // Generate the time stamp and put it into
    // the cooked string buffer.
    //

    GetLocalTime( &st );

    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &st,
        "HH':'mm':'ss",
        szTime,
        SIZE_DATE_TIME
        );

    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &st,
        "MM-dd-yyyy",
        szDate,
        SIZE_DATE_TIME
        );

    cchTimeStamp = wsprintf( szTimeStamp, "[%s - %s] ", szDate, szTime );

    //
    // If we haven't yet stored the filter init time stamp, we should do
    // so now.
    //

    if ( g_szInitUrlScanDate[0] == '\0' )
    {
        strncpy( g_szInitUrlScanDate, szTimeStamp, SIZE_DATE_TIME*2 );
        g_szInitUrlScanDate[SIZE_DATE_TIME*2-1] = '\0';
    }

    //
    // If we are configured to do per day logging, then we need to
    // compare the current time stamp to the last log date and
    // reinit logging if they are different.
    //

    if ( g_fPerDayLogging )
    {
        if ( strcmp( g_szLastLogDate, szDate ) != 0 )
        {
            CopyMemory( g_szLastLogDate, szDate, SIZE_DATE_TIME );
            InitLogFile();
        }
        else
        {
            CopyMemory( g_szLastLogDate, szDate, SIZE_DATE_TIME );
        }

    }


    strcpy( pCookedString, szTimeStamp );

    //
    // Apply formatting to the string.  Note
    // that if the formatted string exceeds
    // the max log line length, it will be
    // truncated.
    //

    va_start( args, szString );

    cchCookedString = _vsnprintf(
        pCookedString + cchTimeStamp,
        cbCookedString - cchTimeStamp,
        szString,
        args
        );

    if ( cchCookedString == -1 )
    {
        if ( g_fLogLongUrls )
        {
            //
            // Grow the buffer and try again.  Do this in
            // a loop until we either succeed, or reach the
            // hard limit.
            //

            while ( cchCookedString == -1 )
            {
                if ( cbCookedString == LOG_LONG_URL_LINE )
                {
                    //
                    // Can't grow any more
                    //

                    break;
                }

                cbCookedString *= 2;

                if ( cbCookedString >= LOG_LONG_URL_LINE )
                {
                    cbCookedString = LOG_LONG_URL_LINE;
                }

                pNew = (LPSTR)LocalAlloc( LPTR, cbCookedString + 1 );

                if ( !pNew )
                {
                    //
                    // Log what we've got...
                    //

                    break;
                }

                CopyMemory( pNew, pCookedString, cchTimeStamp );

                if ( pCookedString != szCookedString )
                {
                    LocalFree( pCookedString );
                }

                pCookedString = pNew;

                cchCookedString = _vsnprintf(
                    pCookedString + cchTimeStamp,
                    cbCookedString - cchTimeStamp,
                    szString,
                    args
                    );
            }

            if ( cchCookedString == -1 )
            {
                strcpy( pCookedString + cbCookedString - 2, "\r\n" );
                cchCookedString = strlen( pCookedString );
            }
            else
            {
                cchCookedString += cchTimeStamp;
            }
        }
        else
        {
            strcpy( pCookedString + LOG_MAX_LINE - 2, "\r\n" );
            cchCookedString = strlen( pCookedString );
        }
    }
    else
    {
        cchCookedString += cchTimeStamp;
    }

    va_end(args);


    //
    // Acquire the lock and write out the log entry
    //

    EnterCriticalSection( &g_LogFileLock );

    SetFilePointer( g_hLogFile, 0, NULL, FILE_END );

    cbToWrite = cchCookedString;

    fResult = WriteFile(
        g_hLogFile,
        pCookedString,
        cbToWrite,
        &cbToWrite,
        NULL
        );

    LeaveCriticalSection( &g_LogFileLock );

    //
    // Free any heap buffer that we're using
    //

    if ( pCookedString != szCookedString )
    {
        LocalFree( pCookedString );
        pCookedString = NULL;
    }
    
    return fResult;
}

DWORD
DoPreprocHeaders(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_PREPROC_HEADERS *   pPreproc
    )
/*++

  This function handles the SF_NOTIFY_PREPROC_HEADERS notification

  Arguments:

    pfc       - The HTTP_FILTER_CONTEXT associated with this request
    pResponse - The HTTP_FILTER_PREPROC_HEADERS structure associated with
                this notification

  Returns:

    TRUE if successful, else FALSE

--*/
{
    DATA_BUFF   RawUrl;
    DATA_BUFF   CaseInsensitiveUrl;
    DATA_BUFF   NormalizedUrl;
    DATA_BUFF   DoubleNormalizedUrl;
    DATA_BUFF   Extension;
    DATA_BUFF   RejectUrl;
    LPSTR       pUrlForAnalysis = NULL;
    LPSTR       pExtension = NULL;
    LPSTR       pCursor = NULL;
    LPSTR       pUrlScanStatusHeader = NULL;
    LPSTR       pRejectUrl = NULL;
    LPSTR       pRejectAction = NULL;
    LPSTR       pFirstDot = NULL;
    LPSTR       pQueryString = NULL;
    CHAR        szClient[STRING_IP_SIZE];
    CHAR        szInstance[INSTANCE_ID_SIZE];
    CHAR        szSmallBuff[SIZE_SMALL_HEADER_VALUE];
    CHAR        szVerb[256];
    CHAR        szNullExtension[] = ".";
    DWORD       cbData;
    DWORD       dwError;
    DWORD       dwNumEntries;
    DWORD       dwValue;
    DWORD       cchUrl;
    DWORD       cchQueryString;
    DWORD       cbHeader;
    DWORD       x;
    BOOL        fFailedToGetMethod = FALSE;
    BOOL        fFailedToGetUrl = FALSE;
    BOOL        fEmbeddedExecutableExtension = FALSE;
    BOOL        fFound;
    BOOL        fRes;

    //
    // Set the reject action text for logging purposes.
    //

    if ( g_fLoggingOnlyMode )
    {
        pRejectAction = "UrlScan is in Logging-Only mode - request allowed.";
    }
    else
    {
        pRejectAction = "Request will be rejected.";
    }

    //
    // Get the original method and URL for this request.  We
    // will use this data for reporting.
    //

    // Method
    cbData = sizeof( szVerb );

    fRes = pPreproc->GetHeader(
        pfc,
        "method",
        szVerb,
        &cbData
        );

    if ( !fRes )
    {
        dwError = GetLastError();

        //
        // Store the error code in the verb string.
        //

        _snprintf( szVerb, 256, "Error-%d", dwError );
        szVerb[255] = '\0';

        GetIpAddress( pfc, szClient, STRING_IP_SIZE );

        WriteLog(
            "Client at %s: Error %d occurred getting verb. "
            "%s\r\n",
            szClient,
            dwError,
            pRejectAction
            );

        fFailedToGetMethod = TRUE;
    }

    //URL
    cbData = RawUrl.QueryBuffSize();

    fRes = pPreproc->GetHeader(
        pfc,
        "url",
        RawUrl.QueryPtr(),
        &cbData
        );

    if ( !fRes )
    {
        dwError = GetLastError();

        if ( dwError == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // The buffer was too small.  Resize and try again.
            //

            fRes = RawUrl.Resize( cbData );

            if ( fRes )
            {
                fRes = pPreproc->GetHeader(
                    pfc,
                    "url",
                    RawUrl.QueryPtr(),
                    &cbData
                    );
            }

            if ( !fRes )
            {
                //
                // Failed on second attempt.  Store the error code.
                //

                dwError = GetLastError();

                cbData = RawUrl.QueryBuffSize();
                pCursor = RawUrl.QueryStr();

                _snprintf( pCursor, cbData, "Error-%d", dwError );
                pCursor[cbData-1] = '\0';

                GetIpAddress( pfc, szClient, STRING_IP_SIZE );

                WriteLog(
                    "Client at %s: Error %d occurred acquiring URL. "
                    "%s\r\n",
                    szClient,
                    dwError,
                    pRejectAction
                    );

                fFailedToGetUrl = TRUE;
            }
        }
        else
        {
            //
            // Hmmm.  Failed to acquire the URL for some reason other than
            // memory.  Store the error code
            //

            cbData = RawUrl.QueryBuffSize();
            pCursor = RawUrl.QueryStr();

            _snprintf( pCursor, cbData, "Error-%d", dwError );
            pCursor[cbData-1] = '\0';


            GetIpAddress( pfc, szClient, STRING_IP_SIZE );

            WriteLog(
                "Client at %s: Error %d occurred acquiring the URL. "
                "%s\r\n",
                szClient,
                dwError,
                pRejectAction
                );

            fFailedToGetUrl = TRUE;
        }
    }

    if ( !fFailedToGetUrl )
    {
        //
        // Trim the query string from the raw URL
        //

        pCursor = strchr( RawUrl.QueryStr(), '?' );

        if ( pCursor )
        {
            *pCursor = '\0';

            pQueryString = pCursor + 1;

            cchUrl = (DWORD)( pCursor - RawUrl.QueryStr() );
            cchQueryString = strlen( pQueryString );
        }
        else
        {
            pQueryString = NULL;

            cchUrl = strlen( RawUrl.QueryStr() );
            cchQueryString = 0;
        }
    }

    //
    // If we failed to get the method or the URL, fail the
    // request now.
    //

    if ( fFailedToGetMethod || fFailedToGetUrl )
    {
        pUrlScanStatusHeader = "Failed-to-get-request-details";
        goto RejectRequest;
    }

    //
    // If filter initialization failed, reject all requests
    //

    if ( g_fInitSucceeded == FALSE )
    {
        WriteLog(
            "*** Warning *** Filter initialization failure. "
            "%s\r\n",
            pRejectAction
            );

        pUrlScanStatusHeader = "Filter-initialization-failure";
        goto RejectRequest;
    }

    //
    // Initialize filter context to NULL for this request
    //

    pfc->pFilterContext = NULL;

    //
    // Validate request limits
    //

    // URL size
    if ( cchUrl > g_dwMaxUrl )
    {
        GetIpAddress( pfc, szClient, STRING_IP_SIZE );
        GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

        WriteLog(
            "Client at %s: URL length exceeded maximum allowed. "
            "%s Site Instance='%s', Raw URL='%s'\r\n",
            szClient,
            pRejectAction,
            szInstance,
            RawUrl.QueryPtr()
            );

        pUrlScanStatusHeader = "URL-too-long";
        goto RejectRequest;
    }

    // Query string size
    if ( cchQueryString > g_dwMaxQueryString )
    {
        GetIpAddress( pfc, szClient, STRING_IP_SIZE );
        GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

        WriteLog(
            "Client at %s: Query string length exceeded maximum allowed. "
            "%s Site Instance='%s', QueryString= '%s', Raw URL='%s'\r\n",
            szClient,
            pRejectAction,
            szInstance,
            pQueryString,
            RawUrl.QueryPtr()
            );

        pUrlScanStatusHeader = "Query-string-too-long";
        goto RejectRequest;
    }

    // Allowed content-length
    cbData = SIZE_SMALL_HEADER_VALUE;

    fRes = pPreproc->GetHeader(
        pfc,
        "content-length:",
        szSmallBuff,
        &cbData
        );

    if ( fRes  )
    {
        dwValue = strtoul(
            szSmallBuff,
            NULL,
            10
            );

        if ( dwValue > g_dwMaxAllowedContentLength )
        {
            GetIpAddress( pfc, szClient, STRING_IP_SIZE );
            GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

            WriteLog(
                "Client at %s: Content-Length %u exceeded maximum allowed. "
                "%s Site Instance='%s', Raw URL='%s'\r\n",
                szClient,
                dwValue,
                pRejectAction,
                szInstance,
                RawUrl.QueryPtr()
                );

            pUrlScanStatusHeader = "Content-length-too-long";

            //
            // Suppress the content-length so that nobody down stream
            // gets exposed to it.
            //
            // Also, convince IIS that the connection should close
            // at the conclusion of this response.
            //

            pPreproc->SetHeader(
                pfc,
                "Content-Length:",
                "0"
                );

            pPreproc->SetHeader(
                pfc,
                "Connection:",
                "close"
                );

            goto RejectRequest;
        }
    }
    else
    {
        //
        // The error had better be ERROR_INVALID_INDEX, or else
        // there is something fishy with the content-length header!
        //

        dwError = GetLastError();

        if ( dwError != ERROR_INVALID_INDEX )
        {
            GetIpAddress( pfc, szClient, STRING_IP_SIZE );
            GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

            WriteLog(
                "Client at %s: Error %d reading content-length. "
                "%s Site Instance='%s', Raw URL='%s'\r\n",
                szClient,
                dwError,
                pRejectAction,
                szInstance,
                RawUrl.QueryPtr()
                );

            pUrlScanStatusHeader = "Error-reading-content-length";
            goto RejectRequest;
        }
    }

    // Other headers
    dwNumEntries = g_LimitedHeaders.QueryNumEntries();

    for ( x = 0; x < dwNumEntries; x++ )
    {
        if ( g_pMaxHeaderLengths[x] )
        {
            cbData = 0;

            fRes = pPreproc->GetHeader(
                pfc,
                g_LimitedHeaders.QueryStringByIndex( x ),
                NULL,
                &cbData
                );

            dwError = GetLastError();

            if ( dwError == ERROR_INSUFFICIENT_BUFFER && 
                 cbData > g_pMaxHeaderLengths[x] + 1 )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: Header '%s' exceeded %u bytes. "
                    "%s Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    g_LimitedHeaders.QueryStringByIndex( x ),
                    g_pMaxHeaderLengths[x],
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "A-request-header-was-too-long";
                goto RejectRequest;
            }
        }
    }

    //
    // Validate that the verb for this request is allowed.
    //

    dwNumEntries = g_Verbs.QueryNumEntries();

    if ( g_fUseAllowVerbs )
    {
        fFound = FALSE;

        if ( dwNumEntries )
        {
            for ( x = 0; x < dwNumEntries; x++ )
            {
                if ( g_Verbs.QueryStringByIndex( x ) != NULL && 
                     strcmp( szVerb, g_Verbs.QueryStringByIndex( x ) ) == 0 )
                {
                    fFound = TRUE;
                    break;
                }
            }
        }

        if ( !fFound )
        {
            GetIpAddress( pfc, szClient, STRING_IP_SIZE );

            WriteLog(
                "Client at %s: Sent verb '%s', which is not specifically allowed. "
                "%s\r\n",
                szClient,
                szVerb,
                pRejectAction
                );

            pUrlScanStatusHeader = "Verb-not-allowed";
            goto RejectRequest;
        }
    }
    else if ( dwNumEntries )
    {
        for ( x = 0; x < dwNumEntries; x++ )
        {
            if ( g_Verbs.QueryStringByIndex( x ) != NULL &&
                 stricmp( szVerb, g_Verbs.QueryStringByIndex( x ) ) == 0 )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );

                WriteLog(
                    "Client at %s: Sent verb '%s', which is disallowed. "
                    "%s\r\n",
                    szClient,
                    szVerb,
                    pRejectAction
                    );

                pUrlScanStatusHeader = "Disallowed-verb";
                goto RejectRequest;
            }
        }
    }
    
    //
    // If we are going to analyze the raw URL, then we should
    // create a lower case one now so that we can do case-insensitive
    // analysis.
    //

    if ( g_fNormalizeBeforeScan == FALSE )
    {
        fRes = CaseInsensitiveUrl.Resize(
            strlen( RawUrl.QueryStr()  ) + 1
            );

        if ( !fRes )
        {
            GetIpAddress( pfc, szClient, STRING_IP_SIZE );

            WriteLog(
                "Client at %s: Insufficient memory to process URL. "
                "%s\r\n",
                szClient,
                pRejectAction
                );

            pUrlScanStatusHeader = "Insufficient-memory-to-process-URL";
            goto RejectRequest;
        }

        strcpy(
            CaseInsensitiveUrl.QueryStr(),
            RawUrl.QueryStr()
            );
        
        strlwr( CaseInsensitiveUrl.QueryStr() );
    }

    //
    // If needed, do URL normalization
    //

    if ( g_fNormalizeBeforeScan || g_fVerifyNormalize )
    {
        //
        // We need to normalize the URL.
        //

        fRes = NormalizeUrl(
            pfc,
            &RawUrl,
            &NormalizedUrl
            );

        if ( !fRes )
        {
            dwError = GetLastError();

            GetIpAddress( pfc, szClient, STRING_IP_SIZE );
            GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

            WriteLog(
                "Client at %s: Error %d occurred normalizing URL. "
                "%s  Site Instance='%s', Raw URL='%s'\r\n",
                szClient,
                dwError,
                pRejectAction,
                szInstance,
                RawUrl.QueryPtr()
                );

            pUrlScanStatusHeader = "Error-normalizing-URL";
            goto RejectRequest;
        }
    }

    if ( g_fVerifyNormalize )
    {
        //
        // We will verify normalization by normalizing an already
        // normalized URL (how's that for a mouthful).
        //
        // For example, if a client sends the following URL:
        //
        //    "/path.htm%252easp"
        //
        // Because "%25" resolves to '%', the first normalization
        // will result in the following:
        //
        //    "/path.htm%2easp"
        //
        // While this won't cause a problem for IIS, this normalized
        // value may be exposed to various ISAPIs and CGIs that might
        // handle the request.  If they do their own normalization
        // on this value, they could potentially see the following
        // (because "%2e" resolves to '.'):
        //
        //    "/path.htm.asp"
        //
        // This may not be a desirable thing.
        //

        fRes = NormalizeUrl(
            pfc,
            &NormalizedUrl,
            &DoubleNormalizedUrl
            );

        if ( !fRes )
        {
            dwError = GetLastError();

            GetIpAddress( pfc, szClient, STRING_IP_SIZE );
            GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

            WriteLog(
                "Client at %s: Error %d occurred normalizing URL. "
                "%s  Site Instance='%s', Raw URL='%s'\r\n",
                szClient,
                dwError,
                pRejectAction,
                szInstance,
                RawUrl.QueryPtr()
                );

            pUrlScanStatusHeader = "Error-normalizing-URL";
            goto RejectRequest;
        }

        //
        // Do the comparison
        //

        if ( strcmp( NormalizedUrl.QueryStr(), DoubleNormalizedUrl.QueryStr() ) != 0 )
        {
            GetIpAddress( pfc, szClient, STRING_IP_SIZE );
            GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

            WriteLog(
                "Client at %s: URL normalization was not complete after one pass. "
                "%s  Site Instance='%s', Raw URL='%s'\r\n",
                szClient,
                pRejectAction,
                szInstance,
                RawUrl.QueryPtr()
                );

            pUrlScanStatusHeader = "Second-pass-normalization-failure";
            goto RejectRequest;
        }
    }

    //
    // Are we going to analyze the raw or normalized URL for
    // further processing?
    //

    if ( g_fNormalizeBeforeScan )
    {
        pUrlForAnalysis = NormalizedUrl.QueryStr();
        
        //
        // Convert to lower for case insensitivity
        //

        strlwr( pUrlForAnalysis );
    }
    else
    {
        //
        // This one is already lower case...
        //

        pUrlForAnalysis = CaseInsensitiveUrl.QueryStr();
    }

    //
    // If we don't allow high bit characters in the request URL, then
    // check for it now.
    //

    if ( g_fAllowHighBit == FALSE )
    {
        pCursor = pUrlForAnalysis;

        while ( *pCursor )
        {
            if ( static_cast<BYTE>( *pCursor ) > 127 )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains high bit character. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "High-bit-character-detected";
                goto RejectRequest;
            }

            pCursor++;
        }
    }

    //
    // If needed, determine the extension of the file being requested
    //
    // For the purpose of this filter, we are defining the extension
    // to be any characters starting with the first '.' in the URL
    // continuing to the end of the URL, or a '/' character, whichever
    // is first.
    //
    // For example, if the client sends:
    //
    //   http://server/path/file.ext
    //
    // Then the extensions is ".ext".
    //
    // For another example, if the client sends:
    //
    //   http://server/path/file.htm/additional/path/info
    //
    // Then the extension is ".htm"
    //

    pFirstDot = strchr( pUrlForAnalysis, '.' );
    pCursor = strrchr( pUrlForAnalysis, '.' );

    if ( pFirstDot != pCursor )
    {
        //
        // There are at least two '.' characters in this URL.
        // If the first one looks like an executable extension
        // embedded in the URL, then we will use it, else
        // we'll use the last one.
        //

        if ( strncmp( pFirstDot, EMBEDDED_COM_EXTENSION, sizeof( EMBEDDED_COM_EXTENSION ) - 1 ) == 0 ||
             strncmp( pFirstDot, EMBEDDED_EXE_EXTENSION, sizeof( EMBEDDED_EXE_EXTENSION ) - 1 ) == 0 ||
             strncmp( pFirstDot, EMBEDDED_DLL_EXTENSION, sizeof( EMBEDDED_DLL_EXTENSION ) - 1 ) == 0 )
        {
            pCursor = pFirstDot;
            fEmbeddedExecutableExtension = TRUE;
        }
    }

    if ( g_Extensions.QueryNumEntries() || g_fUseAllowExtensions )
    {

        //
        // Now process the extension that we have.
        //

        if ( pCursor )
        {
            fRes = Extension.Resize( strlen( pCursor ) + 1 );

            if ( !fRes )
            {
                dwError = GetLastError();

                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: Error %d occurred determining extension. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    dwError,
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Failed-to-determine-extension";
                goto RejectRequest;
            }

            strcpy( Extension.QueryStr(), pCursor );

            //
            // Trim the path info
            //

            pCursor = strchr( Extension.QueryStr(), '/' );

            if ( pCursor != NULL )
            {
                *pCursor = '\0';
            }

            pExtension = Extension.QueryStr();
        }

        if ( pExtension == NULL )
        {
            pExtension = szNullExtension;
        }
    }

    //
    // If we are not allowing dots in the path, we need
    // to check for that now.
    //
    // Essentially, we are just counting dots.  If there
    // is more than one, then we would fail this request.
    //

    if ( g_fAllowDotInPath == FALSE )
    {
        DWORD   dwNumBefore = 0;
        DWORD   dwNumAfter = 0;

        //
        // If we did not detect an embedded executable extension,
        // then we need to make a guess as to whether we've got
        // a dangerous URL or not.
        //

        if ( !fEmbeddedExecutableExtension )
        {
            pCursor = pUrlForAnalysis;

            LPSTR   pLastSlash = strrchr( pCursor, '/' );

            //
            // Go through the URL and count the dots.  We will
            // distinguish between dots before the final slash
            // and dots after.
            //

            while ( *pCursor )
            {
                if ( *pCursor == '.' )
                {
                    if ( pCursor < pLastSlash )
                    {
                        dwNumBefore++;
                    }
                    else
                    {
                        dwNumAfter++;
                    }
                }

                pCursor++;
            }

            //
            // If the last character in the URL is a '/', then we'll
            // bump dwNumAfter.  This is because the trailing slash
            // is an instruction to retrieve the default page or, if
            // no default page is present, to return a directory listing.
            // Either way, there is implied content associated with
            // a trailing '/'.
            //

            if ( pLastSlash == pCursor - 1 )
            {
                dwNumAfter++;
            }

            //
            // Here's the tricky part.  We can get URLs of in the following
            // interesting forms, resulting in calculated extensions as noted
            // (resulting from the code above that sets pExtension:
            //
            //   1) /before/after           ==> ""
            //   2) /before/after.ext       ==> ".ext"
            //   3) /before/after.ext1.ext2 ==> ".ext2"
            //   4) /before.ext/after       ==> ".ext"
            //   5) /before.ext1.ext2/after ==> ".ext2"
            //   6) /before.ext1/after.ext2 ==> ".ext2"
            //
            // The only result here that is dangerous is number 6, because
            // it's not possible to tell whether "/before.ext1" is the file
            // and "/after.ext2" is additional path info, or whether
            // "/before.ext1" is a directory and "/after.ext2" is the file
            // associated with the URL.  As a result, we don't really know
            // if the extension in case 6 is ".ext1" or ".ext2".  We want
            // to reject such a request.
            //
            // Note that it's also possible in any of the cases above that
            // the actual file is "/after*", even where no '.' character is
            // present.  For the purpose of this test, that ambiguity is not
            // dangerous, as the actual action taken by an empty extension
            // is controlled by the administrator of the server via the use
            // of default pages and directory listing configurations.
            //

            if ( dwNumAfter != 0 && dwNumBefore != 0 )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains '.' in the path. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Dot-in-path-detected";
                goto RejectRequest;
            }
        }
    }

    //
    // Check for allow/deny extensions
    //

    if ( g_fUseAllowExtensions )
    {
        dwNumEntries = g_Extensions.QueryNumEntries();
        fFound = FALSE;

        if ( pExtension )
        {
            for ( x = 0; x < dwNumEntries; x++ )
            {
                if ( g_Extensions.QueryStringByIndex( x ) != NULL &&
                     strcmp( pExtension, g_Extensions.QueryStringByIndex( x ) ) == 0 )
                {
                    fFound = TRUE;
                    break;
                }
            }
        }

        if ( !fFound )
        {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains extension '%s', which is "
                    "not specifically allowed. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    pExtension,
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Extension-not-allowed";
                goto RejectRequest;
        }
    }
    else if ( pExtension )
    {
        dwNumEntries = g_Extensions.QueryNumEntries();

        for ( x = 0; x < dwNumEntries; x++ )
        {
            if ( g_Extensions.QueryStringByIndex( x ) &&
                 strcmp( pExtension, g_Extensions.QueryStringByIndex( x ) ) == 0 )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains extension '%s', "
                    "which is disallowed. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    pExtension,
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Disallowed-extension-detected";
                goto RejectRequest;
            }
        }
    }

    //
    // Check for disallowed character sequences
    //

    dwNumEntries = g_Sequences.QueryNumEntries();

    if ( dwNumEntries )
    {
        for ( x = 0; x < dwNumEntries; x++ )
        {
            if ( g_Sequences.QueryStringByIndex( x ) != NULL &&
                 strstr( pUrlForAnalysis, g_Sequences.QueryStringByIndex( x ) ) != NULL )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains sequence '%s', "
                    "which is disallowed. "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    g_Sequences.QueryStringByIndex( x ),
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Disallowed-character-sequence-detected";
                goto RejectRequest;
            }
        }
    }

    //
    // Check for disallowed headers
    //

    dwNumEntries = g_HeaderNames.QueryNumEntries();

    if ( dwNumEntries )
    {
        for ( x = 0; x < dwNumEntries; x++ )
        {
            cbData = SIZE_SMALL_HEADER_VALUE;

            fRes = pPreproc->GetHeader(
                pfc,
                g_HeaderNames.QueryStringByIndex( x ),
                szSmallBuff,
                &cbData
                );

            if ( fRes == TRUE || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                GetIpAddress( pfc, szClient, STRING_IP_SIZE );
                GetInstanceId( pfc, szInstance, INSTANCE_ID_SIZE );

                WriteLog(
                    "Client at %s: URL contains disallowed header '%s' "
                    "%s  Site Instance='%s', Raw URL='%s'\r\n",
                    szClient,
                    g_HeaderNames.QueryStringByIndex( x ),
                    pRejectAction,
                    szInstance,
                    RawUrl.QueryPtr()
                    );

                pUrlScanStatusHeader = "Disallowed-header-detected";
                goto RejectRequest;
            }
        }
    }

    //
    // Whew!  If we made it this far, then we've passed the gauntlet.
    // This URL is OK to pass along for processing.
    //

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

RejectRequest:

    //
    // If UseFastPathReject is set, then do it.
    //

    if ( g_fUseFastPathReject )
    {
        goto FastPathReject;
    }

    //
    // If we are in logging only mode, then we should let the server
    // continue to process the request.
    //

    if ( g_fLoggingOnlyMode )
    {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // Delete any DenyHeaders so that they don't reach
    // the rejected response page
    //

    dwNumEntries = g_HeaderNames.QueryNumEntries();

    if ( dwNumEntries )
    {
        for ( x = 0; x < dwNumEntries; x++ )
        {
            fRes = pPreproc->SetHeader(
                pfc,
                g_HeaderNames.QueryStringByIndex( x ),
                ""
                );
        }
    }

    //
    // Set up the custom headers for the rejected response page.
    //

    if ( pUrlScanStatusHeader )
    {
        pPreproc->SetHeader(
            pfc,
            "URLSCAN-STATUS-HEADER:",
            pUrlScanStatusHeader
            );
    }

    pPreproc->SetHeader(
        pfc,
        "URLSCAN-ORIGINAL-VERB:",
        szVerb
        );

    //
    // IIS has trouble when we start passing around really long
    // buffers into headers.  We'll truncate the original URL to
    // about 4k (actually a few bytes less, because we are going
    // to prepend "?~" to it shortly when we concatenate it with
    // the URL).  4K is the limit for what IIS will log in the
    // query field of the w3svc logs, so this is our practical
    // limit anyway.
    //

    cchQueryString = strlen( RawUrl.QueryStr() );

    if ( cchQueryString > 4095 )
    {
        RawUrl.QueryStr()[4095] = '\0';
        cchQueryString = 4095;
    }

    pPreproc->SetHeader(
        pfc,
        "URLSCAN-ORIGINAL-URL:",
        RawUrl.QueryStr()
        );

    //
    // Now repoint the current request to the reject response page.
    //
    // If we fail to do this, then set the error state such that
    // the server stops processing the request and fails immediately
    // by returning a 404 to the client.
    //

    if ( strcmp( szVerb, "GET" ) != 0 )
    {
        fRes = pPreproc->SetHeader(
            pfc,
            "method",
            "GET"
            );

        if ( !fRes )
        {
            goto FastPathReject;
        }
    }

    //
    // Create a reject URL for this request that includes the original
    // raw URL appended as a query string (so that IIS will log it).
    // We need to allocate enough space to account for "?~" to separate
    // and a NULL terminator.
    //

    cchUrl = strlen( g_szRejectUrl );

    cbData = cchUrl + cchQueryString + 3; // inserting "?~" and NULL

    fRes = RejectUrl.Resize( cbData );

    if ( !fRes )
    {
        //
        // Uh oh.  Couldn't get a buffer.  We'll
        // just rewrite the URL and skip the query string.
        //

        pRejectUrl = RawUrl.QueryStr();
    }
    else
    {
        pRejectUrl = RejectUrl.QueryStr();

        _snprintf( pRejectUrl, cbData, "%s?~%s", g_szRejectUrl, RawUrl.QueryStr() );
        pRejectUrl[cbData-1] = '\0';
    }

    fRes = pPreproc->SetHeader(
        pfc,
        "url",
        pRejectUrl
        );

    if ( !fRes )
    {
        goto FastPathReject;
    }

    //
    // At this point, the request has been redirected to the
    // rejected response page.  We should let the server continue
    // to process the request.
    //

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

FastPathReject:

    //
    // Set the error code to ERROR_FILE_NOT_FOUND and return
    // SF_STATUS_REQ_ERROR.  This will cause the server to
    // return a 404 to the client.
    //

    SetLastError( ERROR_FILE_NOT_FOUND );
    return SF_STATUS_REQ_ERROR;
}

DWORD
DoSendResponse(
    HTTP_FILTER_CONTEXT *           pfc,
    HTTP_FILTER_SEND_RESPONSE *     pResponse
    )
/*++

  This function handles the SF_NOTIFY_SEND_RESPONSE notification

  Arguments:

    pfc       - The HTTP_FILTER_CONTEXT associated with this request
    pResponse - The HTTP_FILTER_SEND_RESPONSE structure associated with
                this notification

  Returns:

    TRUE if successful, else FALSE

--*/
{
    CHAR    szClient[STRING_IP_SIZE];
    BOOL    fRes = TRUE;
    DWORD   dwError;

    //
    // Set the 'Server' response header per the configuration
    //

    if ( g_fRemoveServerHeader )
    {
        fRes = pResponse->SetHeader(
            pfc,
            "Server:",
            ""
            );
    }
    else if ( g_fUseAltServerName )
    {
        fRes = pResponse->SetHeader(
            pfc,
            "Server:",
            g_szAlternateServerName
            );
    }

    if ( !fRes )
    {
        //
        // If we were unable to set the 'Server' header, then we should
        // fail the request with our raw 400 response.
        //
        // Such a failure is generally the result of a malformed request
        // for which IIS couldn't parse the HTTP version.  As a result,
        // IIS assumes HTTP 0.9, which doesn't support response headers
        // and will result in ERROR_NOT_SUPPORTED if any attempt is made
        // to modify response headers.
        //

        dwError = GetLastError();

        //
        // A non-NULL filter context will trigger the SEND_RAW_DATA and
        // END_OF_REQUEST notification handlers to replace the outgoing
        // response with our raw 400 response.
        //

        pfc->pFilterContext = (LPVOID)(DWORD64)pResponse->HttpStatus;

        //
        // Log it
        //

        GetIpAddress( pfc, szClient, STRING_IP_SIZE );

        WriteLog(
            "Client at %s: Received a malformed request which resulted "
            "in error %d while modifying the 'Server' header. "
            "Request will be rejected with a 400 response.\r\n",
            szClient,
            dwError
            );
    }
    else
    {
        //
        // If we successfully set the server header, then we
        // can disable SEND_RAW_DATA and END_OF_REQUEST for
        // performance.
        //

        pfc->ServerSupportFunction(
            pfc,
            SF_REQ_DISABLE_NOTIFICATIONS,
            NULL,
            SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_END_OF_REQUEST,
            0
            );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
DoSendRawData(
    HTTP_FILTER_CONTEXT *   pfc,
    HTTP_FILTER_RAW_DATA *  pRawData
    )
/*++

  This function handles the SF_NOTIFY_SEND_RESPONSE notification

  Arguments:

    pfc      - The HTTP_FILTER_CONTEXT associated with this request
    pRawData - The HTTP_FILTER_RAW_DATA structure associated with
               this notification

  Returns:

    A DWORD filter return code (ie. SF_STATUS_REQ_NEXT_NOTIFICATION)

--*/
{
    //
    // If the filter context is NULL, then take no action - just
    // return
    //

    if ( pfc->pFilterContext == NULL )
    {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // Change the cbInData member to 0 on the data packet.  This
    // will effectively prevent IIS from sending the data to
    // the client.
    //

    pRawData->cbInData = 0;

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
DoEndOfRequest(
    HTTP_FILTER_CONTEXT *           pfc
    )
/*++

  This function handles the SF_NOTIFY_SEND_RESPONSE notification

  Arguments:

    pfc      - The HTTP_FILTER_CONTEXT associated with this request

  Returns:

    A DWORD filter return code (ie. SF_STATUS_REQ_NEXT_NOTIFICATION)

--*/
{
    DWORD   cbResponse;

    //
    // If the filter context is NULL, then take no action - just
    // return.  Otherwise, set the context to NULL to prevent any
    // writes from this function from being processed by our
    // implementation of SEND_RAW_DATA.
    //

    if ( pfc->pFilterContext == NULL )
    {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
    else
    {
        pfc->pFilterContext = NULL;
    }

    //
    // Write out the raw 400 response and return
    // FINISHED so that the server closes the connection.
    //

    cbResponse = g_cbRaw400Response;

    pfc->WriteClient(
        pfc,
        g_szRaw400Response,
        &cbResponse,
        0
        );

    return SF_STATUS_REQ_FINISHED;
}

VOID
GetIpAddress(
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   szIp,
    DWORD                   cbIp
    )
/*++

  This function copies the client IP address into the supplied buffer

  Arguments:

    pfc  - The HTTP_FILTER_CONTEXT associated with this request
    szIp - The buffer to receive the data
    cbIp - The size, in bytes, of szIp

  Returns:

    None

--*/
{
    BOOL    fResult;

    if ( szIp == NULL || cbIp == 0 )
    {
        return;
    }

    fResult = pfc->GetServerVariable(
        pfc,
        "REMOTE_ADDR",
        szIp,
        &cbIp
        );

    //
    // If this fails, just stuff some asterisks into it.
    //

    if ( fResult == FALSE )
    {
        strncpy( szIp, "*****", cbIp );
        szIp[cbIp-1] = '\0';
    }
}

VOID
GetInstanceId(
    HTTP_FILTER_CONTEXT *   pfc,
    LPSTR                   szId,
    DWORD                   cbId
    )
/*++

  This function copies the target site's instancd ID into the supplied buffer

  Arguments:

    pfc  - The HTTP_FILTER_CONTEXT associated with this request
    szId - The buffer to receive the data
    cbId - The size, in bytes, of szId

  Returns:

    None

--*/
{
    BOOL    fResult;

    if ( szId == NULL || cbId == 0 )
    {
        return;
    }

    fResult = pfc->GetServerVariable(
        pfc,
        "INSTANCE_ID",
        szId,
        &cbId
        );

    //
    // If this fails, just stuff some asterisks into it.
    //

    if ( fResult == FALSE )
    {
        strncpy( szId, "*****", cbId );
        szId[cbId-1] = '\0';
    }
}

BOOL
NormalizeUrl(
    HTTP_FILTER_CONTEXT *   pfc,
    DATA_BUFF *             pRawUrl,
    DATA_BUFF *             pNormalizedUrl
    )
/*++

  This function calls into IIS to normalize a URL

  Arguments:

    pfc            - The HTTP_FILTER_CONTEXT associated with this request
    pRawUrl        - The URL to normalize
    pNormalizedUrl - On successful return, contains the normalized URL

  Returns:

    TRUE if successful, else FALSE

--*/
{
    BOOL    fRes;
    DWORD   cbUrl;

    cbUrl = strlen( pRawUrl->QueryStr() ) + 1;

    fRes = pNormalizedUrl->Resize( cbUrl );

    if ( !fRes )
    {
        return FALSE;
    }

    CopyMemory(
        pNormalizedUrl->QueryPtr(),
        pRawUrl->QueryPtr(),
        cbUrl
        );

    return pfc->ServerSupportFunction(
        pfc,
        SF_REQ_NORMALIZE_URL,
        pNormalizedUrl->QueryPtr(),
        NULL,
        NULL
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\urlscan\utils.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name: Utils.cpp

Abstract:

    Miscellaneous tools for UrlScan filter

Author:

    Wade A. Hilmo, May 2001

--*/

#include "Utils.h"

BOOL
DATA_BUFF::SetData(
    LPVOID      pNewData,
    DWORD       cbNewData,
    LPVOID *    ppNewDataPointer
    )
{
    return AppendData(
        pNewData,
        cbNewData,
        ppNewDataPointer,
        0
        );
}

BOOL
DATA_BUFF::AppendData(
    LPVOID      pNewData,
    DWORD       cbNewData,
    LPVOID *    ppNewDataPointer,
    DWORD       dwOffset
    )
{
    DWORD   cbNewSize;
    BOOL    fRet;

    //
    // If dwOffset is zero, append at the end
    //

    if ( dwOffset == 0 )
    {
        dwOffset = _cbData;
    }

    //
    // Verify size
    //

    cbNewSize = cbNewData + dwOffset;

    fRet = Resize( cbNewSize, ppNewDataPointer );

    if ( fRet == FALSE )
    {
        return FALSE;
    }

    //
    // Do it
    //

    CopyMemory( (LPBYTE)_pData + dwOffset, pNewData, cbNewData );

    _cbData = cbNewSize;

    return TRUE;
}

BOOL
DATA_BUFF::SetDataSize(
    DWORD   cbData
    )
{
    if ( cbData > _cbBuff )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    _cbData = cbData;

    return TRUE;
}

BOOL
DATA_BUFF::Resize(
    DWORD       cbNewSize,
    LPVOID *    ppNewDataPointer
    )
{
    LPVOID  pNew;

    if ( cbNewSize <= _cbBuff )
    {
        if ( ppNewDataPointer != NULL )
        {
            *ppNewDataPointer = _pData;
        }

        return TRUE;
    }

    //
    // Check to ensure that we're not allocating more
    // than MAX_DATA_BUFF_SIZE
    //

    if ( cbNewSize > MAX_DATA_BUFF_SIZE )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // Avoid extraneous allocations by growing the buffer
    // in chunks equivalent to the inline size.
    //

    cbNewSize = ((cbNewSize/BUFF_INLINE_SIZE)+1) * BUFF_INLINE_SIZE;

    pNew = LocalAlloc( LPTR, cbNewSize );

    if ( pNew == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    CopyMemory( pNew, _pData, _cbBuff );

    if ( _pHeapBuff != NULL )
    {
        LocalFree( _pHeapBuff );
    }

    _pHeapBuff = pNew;
    _cbBuff = cbNewSize;
    _pData = _pHeapBuff;

    if ( ppNewDataPointer )
    {
        *ppNewDataPointer = _pData;
    }

    return TRUE;
}

VOID
DATA_BUFF::Reset()
{
    if ( _pHeapBuff != NULL )
    {
        _pData = _pInlineBuffer;

        LocalFree( _pHeapBuff );
        _pHeapBuff = NULL;
    }

    _cbData = 0;
    _cbBuff = BUFF_INLINE_SIZE;
}

STRING_ARRAY::~STRING_ARRAY()
{
    DWORD   x;
    LPSTR * ppString;

    ppString = reinterpret_cast<LPSTR*>( _Data.QueryPtr() );

    if ( _cEntries != 0 && ppString != NULL )
    {
        for ( x = 0; x < _cEntries; x++ )
        {
            if ( QueryStringByIndex( x ) != NULL )
            {
                delete [] QueryStringByIndex( x );
            }

            ppString[x] = NULL;
        }
    }
}

BOOL
STRING_ARRAY::AddString(
    LPSTR   szNewString,
    DWORD   cbNewString
    )
{
    LPSTR * ppString;
    BOOL    fRet;

    //
    // Validate input data
    //

    if ( szNewString == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Don't insert an empty string, but don't fail either
    //

    if ( szNewString[0] == '\0' )
    {
        return TRUE;
    }

    //
    // If zero was provided as the new string length, then
    // recalculate it based on the input data
    //

    if ( cbNewString == 0 )
    {
        cbNewString = strlen( szNewString ) + 1;
    }

    ppString = reinterpret_cast<LPSTR*>( _Data.QueryPtr() );

    //
    // Ensure that the array is large enough
    //

    fRet = _Data.Resize(
        ( _cEntries + 1 ) * sizeof(LPSTR),
        reinterpret_cast<LPVOID*>( &ppString )
        );

    if ( !fRet )
    {
        return FALSE;
    }

    //
    // Allocate Storage for the new string
    //

    ppString[_cEntries] = new CHAR[cbNewString];

    if ( ppString[_cEntries] == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // Insert the new data
    //

    CopyMemory( ppString[_cEntries], szNewString, cbNewString );

    _cEntries++;

    return TRUE;
}

LPSTR
STRING_ARRAY::QueryStringByIndex(
    DWORD   dwIndex
    )
{
    LPSTR * ppString;

    ppString = reinterpret_cast<LPSTR*>( _Data.QueryPtr() );

    if ( dwIndex > _cEntries )
    {
        SetLastError( ERROR_INVALID_INDEX );
        return NULL;
    }

    return ppString[dwIndex];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\filters\urlscan\utils.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name: Utils.h

Abstract:

    Miscellaneous tools for UrlScan filter

Author:

    Wade A. Hilmo, May 2001

--*/

#ifndef _UTILS_DEFINED
#define _UTILS_DEFINED

#include <stdio.h>
#include <windows.h>

#define BUFF_INLINE_SIZE           512
#define MAX_DATA_BUFF_SIZE  0x40000000 // 1GB

//
// A simple data buffer
//

class DATA_BUFF
{
public:

    DATA_BUFF()
        : _pData( _pInlineBuffer ),
          _pHeapBuff( NULL ),
          _cbData( 0 ),
          _cbBuff( BUFF_INLINE_SIZE )
    {
    }

    ~DATA_BUFF()
    {
        Reset();
    }

    BOOL
    SetData(
        LPVOID      pNewData,
        DWORD       cbNewData,
        LPVOID *    ppNewDataPointer
        );

    BOOL
    AppendData(
        LPVOID      pNewData,
        DWORD       cbNewData,
        LPVOID *    ppNewDataPointer,
        DWORD       dwOffset
        );

    BOOL
    SetDataSize(
        DWORD   cbData
        );

    BOOL
    Resize(
        DWORD       cbNewSize,
        LPVOID *    ppNewDataPointer = NULL
        );

    VOID
    Reset();

    DWORD
    QueryBuffSize()
    {
        return _cbBuff;
    }

    DWORD
    QueryDataSize()
    {
        return _cbData;
    }

    LPVOID
    QueryPtr()
    {
        return _pData;
    }

    LPSTR
    QueryStr()
    {
        //
        // Return the _pData pointer as an LPSTR
        //
        // Note that it's up to the caller of this
        // function to know that the data is safely
        // NULL terminated.
        //

        return reinterpret_cast<LPSTR>( _pData );
    }

private:

    BYTE    _pInlineBuffer[BUFF_INLINE_SIZE];
    LPVOID  _pHeapBuff;
    LPVOID  _pData;
    DWORD   _cbBuff;
    DWORD   _cbData;
};

//
// A class to manage arrays of strings
//

class STRING_ARRAY
{
public:

    STRING_ARRAY()
        : _cEntries( 0 )
    {
    }

    ~STRING_ARRAY();

    BOOL
    AddString(
        LPSTR   szNewString,
        DWORD   cbNewString = 0
        );

    LPSTR
    QueryStringByIndex(
        DWORD   dwIndex
        );

    DWORD
    QueryNumEntries()
    {
        return _cEntries;
    }

private:

    DATA_BUFF   _Data;
    DWORD       _cEntries;
};

#endif // _UTILS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\minimal\cgi.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      cgi.h

   Abstract:
      This header declares constants used by CGI implementations.

   Author:

       Murali R. Krishnan    ( MuraliK )    19-June-1995

   Environment:
       Win32 -- User Mode

   Project:
   
       CGI Implementations for W3

   Revision History:

--*/

# ifndef _MSCGI_H_
# define _MSCGI_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Constants  
 ************************************************************/

//
// Define various environment strings that may be used by CGI interfaces
//

// ANSI values

# define PSZ_AUTH_TYPE_A                  "AUTH_TYPE"
# define PSZ_COM_SPEC_A                   "ComSpec"
# define PSZ_GATEWAY_INTERFACE_A          "GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_A             "CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_A               "CONTENT_TYPE"
# define PSZ_PATH_A                       "PATH"
# define PSZ_PATH_INFO_A                  "PATH_INFO"
# define PSZ_PATH_TRANSLATED_A            "PATH_TRANSLATED"
# define PSZ_QUERY_STRING_A               "QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_A             "REMOTE_ADDR"
# define PSZ_REMOTE_HOST_A                "REMOTE_HOST"
# define PSZ_REMOTE_USER_A                "REMOTE_USER"
# define PSZ_REQUEST_METHOD_A             "REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_A                "SCRIPT_NAME"
# define PSZ_SERVER_NAME_A                "SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_A            "SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_A                "SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_A            "SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_A                "SystemRoot"
# define PSZ_WINDIR_A                     "WINDIR"


// UNICODE values

# define PSZ_AUTH_TYPE_W                  L"AUTH_TYPE"
# define PSZ_COM_SPEC_W                   L"ComSpec"
# define PSZ_GATEWAY_INTERFACE_W          L"GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_W             L"CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_W               L"CONTENT_TYPE"
# define PSZ_PATH_W                       L"PATH"
# define PSZ_PATH_INFO_W                  L"PATH_INFO"
# define PSZ_PATH_TRANSLATED_W            L"PATH_TRANSLATED"
# define PSZ_QUERY_STRING_W               L"QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_W             L"REMOTE_ADDR"
# define PSZ_REMOTE_HOST_W                L"REMOTE_HOST"
# define PSZ_REMOTE_USER_W                L"REMOTE_USER"
# define PSZ_REQUEST_METHOD_W             L"REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_W                L"SCRIPT_NAME"
# define PSZ_SERVER_NAME_W                L"SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_W            L"SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_W                L"SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_W            L"SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_W                L"SystemRoot"
# define PSZ_WINDIR_W                     L"WINDIR"



# endif // _MSCGI_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\minimal\cgimin.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cgimin.c

Abstract:

    This module demonstrates a minimal CGI executable for HTTP server
    It mimics the action of BGI program w3min.dll

Author:

    Murali R. Krishnan  (MuraliK)  19-June-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
# include <cgi.h>



# define DEFAULT_LEN       ( 256)



int __cdecl
main( int argc, char * argv[])
{
    char rgchMethod[DEFAULT_LEN];
    char rgchQuery[DEFAULT_LEN];
    char rgchPathInfo[DEFAULT_LEN];
    char rgchXlatedPathInfo[DEFAULT_LEN];
    DWORD dwLen;

    rgchMethod[0] = rgchQuery[0] = 
      rgchPathInfo[0] = rgchXlatedPathInfo[0] = '\0';

    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_REQUEST_METHOD_A, rgchMethod, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_REQUEST_METHOD_A, dwLen);
    }

    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_PATH_INFO_A, rgchPathInfo, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_PATH_INFO_A, dwLen);
    }

      
    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_QUERY_STRING_A, dwLen);
    }

      
    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_PATH_TRANSLATED_A, 
                                    rgchXlatedPathInfo, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_PATH_TRANSLATED_A, dwLen);
    }
      

    printf(
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Minimal Server Extension Example</title></head>\n"
             "<body><h1>Minimal Server Extension Example (CGI)</h1>\n"
             "<p>Method               = %s\n"
             "<p>Query String         = %s\n"
             "<p>Path Info            = %s\n"
             "<p>Translated Path Info = %s\n"
             "<p>"
             "<p>"
             "<form METHOD=\"POST\" ACTION=\"/scripts/w3min.dll/PathInfo/foo\">"
             "Enter your name: <input text name=\"Name\" size=36><br>"
             "<input type=\"submit\" value=\"Do Query\">"
             "</body>",
             rgchMethod,
             rgchQuery,
             rgchPathInfo,
             rgchXlatedPathInfo);

    return (1);
} // main()


/************************* End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\minimal\w3min.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3min.c

Abstract:

    This module demonstrates a minimal HTTP Server Extension gateway

Author:

    John Ludeman (johnl)   13-Oct-1994

Revision History:
--*/

#include <windows.h>
#include <httpext.h>


#define END_OF_DOC   "End of document"

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    char buff[2048];
    int  cb = sizeof(END_OF_DOC) - 1;

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Minimal Server Extension Example</title></head>\n"
             "<body><h1>Minimal Server Extension Example (BGI)</h1>\n"
             "<p>Method               = %s\n"
             "<p>Query String         = %s\n"
             "<p>Path Info            = %s\n"
             "<p>Translated Path Info = %s\n"
             "<p>"
             "<p>"
             "<form METHOD=\"POST\" ACTION=\"/scripts/w3min.dll/PathInfo/foo\">"
             "Enter your name: <input text name=\"Name\" size=36><br>"
             "<input type=\"submit\" value=\"Do Query\">"
             "</body>",
             pecb->lpszMethod,
             pecb->lpszQueryString,
             pecb->lpszPathInfo,
             pecb->lpszPathTranslated );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff ) ||
         !pecb->WriteClient( pecb->ConnID,
                             END_OF_DOC,
                             &cb,
                             0 ))
    {
        return HSE_STATUS_ERROR;
    }

    return HSE_STATUS_SUCCESS;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
            "Minimal Extension example" );

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\cgi.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      cgi.h

   Abstract:
      This header declares constants used by CGI implementations.

   Author:

       Murali R. Krishnan    ( MuraliK )    19-June-1995

   Environment:
       Win32 -- User Mode

   Project:
   
       CGI Implementations for W3

   Revision History:

--*/

# ifndef _MSCGI_H_
# define _MSCGI_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Constants  
 ************************************************************/

//
// Define various environment strings that may be used by CGI interfaces
//

// ANSI values

# define PSZ_AUTH_TYPE_A                  "AUTH_TYPE"
# define PSZ_COM_SPEC_A                   "ComSpec"
# define PSZ_GATEWAY_INTERFACE_A          "GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_A             "CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_A               "CONTENT_TYPE"
# define PSZ_PATH_A                       "PATH"
# define PSZ_PATH_INFO_A                  "PATH_INFO"
# define PSZ_PATH_TRANSLATED_A            "PATH_TRANSLATED"
# define PSZ_QUERY_STRING_A               "QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_A             "REMOTE_ADDR"
# define PSZ_REMOTE_HOST_A                "REMOTE_HOST"
# define PSZ_REMOTE_USER_A                "REMOTE_USER"
# define PSZ_REQUEST_METHOD_A             "REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_A                "SCRIPT_NAME"
# define PSZ_SERVER_NAME_A                "SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_A            "SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_A                "SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_A            "SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_A                "SystemRoot"
# define PSZ_WINDIR_A                     "WINDIR"


// UNICODE values

# define PSZ_AUTH_TYPE_W                  L"AUTH_TYPE"
# define PSZ_COM_SPEC_W                   L"ComSpec"
# define PSZ_GATEWAY_INTERFACE_W          L"GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_W             L"CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_W               L"CONTENT_TYPE"
# define PSZ_PATH_W                       L"PATH"
# define PSZ_PATH_INFO_W                  L"PATH_INFO"
# define PSZ_PATH_TRANSLATED_W            L"PATH_TRANSLATED"
# define PSZ_QUERY_STRING_W               L"QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_W             L"REMOTE_ADDR"
# define PSZ_REMOTE_HOST_W                L"REMOTE_HOST"
# define PSZ_REMOTE_USER_W                L"REMOTE_USER"
# define PSZ_REQUEST_METHOD_W             L"REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_W                L"SCRIPT_NAME"
# define PSZ_SERVER_NAME_W                L"SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_W            L"SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_W                L"SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_W            L"SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_W                L"SystemRoot"
# define PSZ_WINDIR_W                     L"WINDIR"



# endif // _MSCGI_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\cad\httpextp.h ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

    iisextp.h

   Abstract:

    This module contains private HTTP server extension info

   Environment:

    Win32 User Mode

--*/

#ifndef _IISEXTP_H_
#define _IISEXTP_H_

#include "iisext.h"

//  available
//  #define   ??? (HSE_REQ_END_RESERVED+4)
//  no longer supported
#define   HSE_REQ_GET_CERT_INFO                    (HSE_REQ_END_RESERVED+9)
//  will be public in IIS 5.0
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_GET_EXECUTE_FLAGS                (HSE_REQ_END_RESERVED+19)
// UNDONE: should be public after IIS 5.0 BETA 2
#define   HSE_REQ_GET_VIRTUAL_PATH_TOKEN           (HSE_REQ_END_RESERVED+21)
// This is the old vecotr send for ASP.Net's use
#define   HSE_REQ_VECTOR_SEND_DEPRECATED           (HSE_REQ_END_RESERVED+22)
#define   HSE_REQ_GET_CUSTOM_ERROR_PAGE            (HSE_REQ_END_RESERVED+29)
#define   HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN   (HSE_REQ_END_RESERVED+31)
#define   HSE_REQ_UNICODE_NORMALIZE_URL            (HSE_REQ_END_RESERVED+33)
#define   HSE_REQ_ADD_FRAGMENT_TO_CACHE            (HSE_REQ_END_RESERVED+34)
#define   HSE_REQ_READ_FRAGMENT_FROM_CACHE         (HSE_REQ_END_RESERVED+35)
#define   HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE       (HSE_REQ_END_RESERVED+36)
#define   HSE_REQ_GET_METADATA_PROPERTY            (HSE_REQ_END_RESERVED+39)
#define   HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK  (HSE_REQ_END_RESERVED+40)
//  will be public in IIS 5.0

//
// Flags for HSE_REQ_EXECUTE_CHILD function
//

# define HSE_EXEC_NO_HEADERS              0x00000001   // Don't send any
                                                       // headers of child
# define HSE_EXEC_REDIRECT_ONLY           0x00000002   // Don't send any
                                                       // headers of child
                                                       // but send redirect
                                                       // message
# define HSE_EXEC_COMMAND                 0x00000004   // Treat as shell
                                                       // command instead of
                                                       // URL
# define HSE_EXEC_NO_ISA_WILDCARDS        0x00000010   // Ignore wildcards in
                                                       // ISAPI mapping when
                                                       // executing child
# define HSE_EXEC_CUSTOM_ERROR            0x00000020   // URL being sent is a
                                                       // custom error
//
// This is the deprecated structure for ASP.Net's use
//

//
// element of the vector
//

typedef struct _HSE_VECTOR_ELEMENT_DEPRECATED
{
    PVOID pBuffer;      // The buffer to be sent

    HANDLE hFile;       // The handle to read the data from
                        // Note: both pBuffer and hFile should not be non-null

    ULONGLONG cbOffset; // Offset from the start of hFile

    ULONGLONG cbSize;   // Number of bytes to send
} HSE_VECTOR_ELEMENT_DEPRECATED, *LPHSE_VECTOR_ELEMENT_DEPRECATED;

//
// The whole vector to be passed to the ServerSupportFunction
//

typedef struct _HSE_RESPONSE_VECTOR_DEPRECATED
{
    DWORD dwFlags;                          // combination of HSE_IO_* flags

    LPSTR pszStatus;                        // Status line to send like "200 OK"
    LPSTR pszHeaders;                       // Headers to send

    DWORD nElementCount;                    // Number of HSE_VECTOR_ELEMENT_DEPRECATED's
    LPHSE_VECTOR_ELEMENT_DEPRECATED lpElementArray;    // Pointer to those elements
} HSE_RESPONSE_VECTOR_DEPRECATED, *LPHSE_RESPONSE_VECTOR_DEPRECATED;

#define HSE_VECTOR_ELEMENT_TYPE_FRAGMENT            2
#include <winsock2.h>
typedef struct _HSE_SEND_ENTIRE_RESPONSE_INFO {

    //
    // HTTP header info
    //

    HSE_SEND_HEADER_EX_INFO HeaderInfo;

    //
    // Buffers which will be passed to WSASend
    //
    // NOTE: To send an entire response whose data (body)
    // is contained in N buffers, caller must allocate N+1 buffers
    // and fill buffers 1 through N with its data buffers.
    // IIS will fill the extra buffer (buffer 0) with header info.
    //

    WSABUF *    rgWsaBuf;   // array of wsa buffers
    DWORD       cWsaBuf;    // count of wsa buffers

    //
    // Returned by WSASend
    //

    DWORD       cbWritten;

} HSE_SEND_ENTIRE_RESPONSE_INFO, * LPHSE_SEND_ENTIRE_RESPONSE_INFO;

typedef struct _HSE_CUSTOM_ERROR_PAGE_INFO {

    //
    // The Error and SubError to look up
    //

    DWORD       dwError;
    DWORD       dwSubError;

    //
    // Buffer info
    //

    DWORD       dwBufferSize;
    CHAR *      pBuffer;

    //
    // On return, this contains the size of the buffer required
    //

    DWORD *     pdwBufferRequired;

    //
    // If TRUE on return, then buffer contains a file name
    //

    BOOL *      pfIsFileError;

    //
    // If FALSE on return, then the body of the custom error
    // should not be sent.
    //

    BOOL *      pfSendErrorBody;

} HSE_CUSTOM_ERROR_PAGE_INFO, * LPHSE_CUSTOM_ERROR_PAGE_INFO;

#endif // _IISEXTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\get\httpextp.h ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

    iisextp.h

   Abstract:

    This module contains private HTTP server extension info

   Environment:

    Win32 User Mode

--*/

#ifndef _IISEXTP_H_
#define _IISEXTP_H_

#include "iisext.h"

//  available
//  #define   ??? (HSE_REQ_END_RESERVED+4)
//  no longer supported
#define   HSE_REQ_GET_CERT_INFO                    (HSE_REQ_END_RESERVED+9)
//  will be public in IIS 5.0
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_GET_EXECUTE_FLAGS                (HSE_REQ_END_RESERVED+19)
// UNDONE: should be public after IIS 5.0 BETA 2
#define   HSE_REQ_GET_VIRTUAL_PATH_TOKEN           (HSE_REQ_END_RESERVED+21)
// This is the old vecotr send for ASP.Net's use
#define   HSE_REQ_VECTOR_SEND_DEPRECATED           (HSE_REQ_END_RESERVED+22)
#define   HSE_REQ_GET_CUSTOM_ERROR_PAGE            (HSE_REQ_END_RESERVED+29)
#define   HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN   (HSE_REQ_END_RESERVED+31)
#define   HSE_REQ_UNICODE_NORMALIZE_URL            (HSE_REQ_END_RESERVED+33)
#define   HSE_REQ_ADD_FRAGMENT_TO_CACHE            (HSE_REQ_END_RESERVED+34)
#define   HSE_REQ_READ_FRAGMENT_FROM_CACHE         (HSE_REQ_END_RESERVED+35)
#define   HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE       (HSE_REQ_END_RESERVED+36)
#define   HSE_REQ_GET_METADATA_PROPERTY            (HSE_REQ_END_RESERVED+39)
#define   HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK  (HSE_REQ_END_RESERVED+40)
//  will be public in IIS 5.0

//
// Flags for HSE_REQ_EXECUTE_CHILD function
//

# define HSE_EXEC_NO_HEADERS              0x00000001   // Don't send any
                                                       // headers of child
# define HSE_EXEC_REDIRECT_ONLY           0x00000002   // Don't send any
                                                       // headers of child
                                                       // but send redirect
                                                       // message
# define HSE_EXEC_COMMAND                 0x00000004   // Treat as shell
                                                       // command instead of
                                                       // URL
# define HSE_EXEC_NO_ISA_WILDCARDS        0x00000010   // Ignore wildcards in
                                                       // ISAPI mapping when
                                                       // executing child
# define HSE_EXEC_CUSTOM_ERROR            0x00000020   // URL being sent is a
                                                       // custom error
//
// This is the deprecated structure for ASP.Net's use
//

//
// element of the vector
//

typedef struct _HSE_VECTOR_ELEMENT_DEPRECATED
{
    PVOID pBuffer;      // The buffer to be sent

    HANDLE hFile;       // The handle to read the data from
                        // Note: both pBuffer and hFile should not be non-null

    ULONGLONG cbOffset; // Offset from the start of hFile

    ULONGLONG cbSize;   // Number of bytes to send
} HSE_VECTOR_ELEMENT_DEPRECATED, *LPHSE_VECTOR_ELEMENT_DEPRECATED;

//
// The whole vector to be passed to the ServerSupportFunction
//

typedef struct _HSE_RESPONSE_VECTOR_DEPRECATED
{
    DWORD dwFlags;                          // combination of HSE_IO_* flags

    LPSTR pszStatus;                        // Status line to send like "200 OK"
    LPSTR pszHeaders;                       // Headers to send

    DWORD nElementCount;                    // Number of HSE_VECTOR_ELEMENT_DEPRECATED's
    LPHSE_VECTOR_ELEMENT_DEPRECATED lpElementArray;    // Pointer to those elements
} HSE_RESPONSE_VECTOR_DEPRECATED, *LPHSE_RESPONSE_VECTOR_DEPRECATED;

#define HSE_VECTOR_ELEMENT_TYPE_FRAGMENT            2
#include <winsock2.h>
typedef struct _HSE_SEND_ENTIRE_RESPONSE_INFO {

    //
    // HTTP header info
    //

    HSE_SEND_HEADER_EX_INFO HeaderInfo;

    //
    // Buffers which will be passed to WSASend
    //
    // NOTE: To send an entire response whose data (body)
    // is contained in N buffers, caller must allocate N+1 buffers
    // and fill buffers 1 through N with its data buffers.
    // IIS will fill the extra buffer (buffer 0) with header info.
    //

    WSABUF *    rgWsaBuf;   // array of wsa buffers
    DWORD       cWsaBuf;    // count of wsa buffers

    //
    // Returned by WSASend
    //

    DWORD       cbWritten;

} HSE_SEND_ENTIRE_RESPONSE_INFO, * LPHSE_SEND_ENTIRE_RESPONSE_INFO;

typedef struct _HSE_CUSTOM_ERROR_PAGE_INFO {

    //
    // The Error and SubError to look up
    //

    DWORD       dwError;
    DWORD       dwSubError;

    //
    // Buffer info
    //

    DWORD       dwBufferSize;
    CHAR *      pBuffer;

    //
    // On return, this contains the size of the buffer required
    //

    DWORD *     pdwBufferRequired;

    //
    // If TRUE on return, then buffer contains a file name
    //

    BOOL *      pfIsFileError;

    //
    // If FALSE on return, then the body of the custom error
    // should not be sent.
    //

    BOOL *      pfSendErrorBody;

} HSE_CUSTOM_ERROR_PAGE_INFO, * LPHSE_CUSTOM_ERROR_PAGE_INFO;

#endif // _IISEXTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\cad\specweb99-cad.cxx ===
/*********************************************************************
 *                                                                   *
 * File: specweb99-CAD.cxx                                           *
 * ----                                                              *
 *                                                                   *
 *                                                                   *
 * Overview:                                                         *
 * --------                                                          *
 *                                                                   *
 * Implementation of the dynamic GET with custom ad rotation         *
 * operation in the SPECweb99 benchmark.                             *
 *                                                                   *
 *                                                                   *
 * Revision History:                                                 *
 * ----------------                                                  *
 *                                                                   *
 * Date         Author                  Reason                       *
 * ----         ------                  ------                       *
 *                                                                   *
 * 07/28/02     Ankur Upadhyaya         Initial Creation.            *
 *                                                                   *
 *********************************************************************/


/*********************************************************************/


//
// Includes.
//


#include <windows.h>

#include <malloc.h>

#include <stdlib.h>

#include <stdio.h>

#include <time.h>

#include <math.h>

#include "httpextp.h"


/*********************************************************************/


//
// Defines.
//


#define USE_SYNC_IO 1

#define USE_ASYNC_IO 2

#define USE_ADAPTABLE_IO 3

#define INIT_ISAPI_RESPONSE_STACK_SIZE 1024

#define INIT_CLASS1_DATA_BUFFER_STACK_SIZE 1024

#define INIT_CLASS2_DATA_BUFFER_STACK_SIZE 1024

#define NUM_CUSTOM_ADS 360

#define CUSTOM_AD_SIZE 39

#define USER_PROFILE_SIZE 15

#define FREE 0

#define LOCKED -1

#define FILE_DATA_BUFFER_SIZE 8192

#define MAX_COOKIE_STRING_LENGTH 128

#define MAX_FRAGMENT_CACHE_KEY_LENGTH 1024

#define WEIGHTING_MASK 0x0000000f

#define GENDER_MASK 0x30000000

#define AGE_GROUP_MASK 0x0f000000

#define REGION_MASK 0x00f00000

#define INTEREST1_MASK 0x000ffc00

#define INTEREST2_MASK 0x000003ff


/*********************************************************************/


//
// Type definitions.
//


typedef struct class1_data_buffer
{

   SINGLE_LIST_ENTRY item_entry;

   CHAR buffer[ 10 * 1024 ];

} CLASS1_DATA_BUFFER;


typedef struct class2_data_buffer
{

   SINGLE_LIST_ENTRY item_entry;

   CHAR buffer[ 100 * 1024 ];

} CLASS2_DATA_BUFFER;


typedef struct isapi_response 
{

   SINGLE_LIST_ENTRY item_entry;

   OVERLAPPED overlapped;

   HANDLE hFile;
   
   HSE_VECTOR_ELEMENT vector_element;

   DWORD ad_id;

   DWORD class_number;

   CLASS1_DATA_BUFFER *class1_data_buffer_ptr;

   CLASS2_DATA_BUFFER *class2_data_buffer_ptr;

   EXTENSION_CONTROL_BLOCK *pECB;

   HSE_VECTOR_ELEMENT vector_element_array[ 7 ];

   BOOL use_async_vector_send;

   HSE_RESPONSE_VECTOR response_vector;

   CHAR remote_addr[ 16 ];

   CHAR pszHeaders[ 67 + MAX_COOKIE_STRING_LENGTH ];

   CHAR set_cookie_string[ MAX_COOKIE_STRING_LENGTH ];

   WCHAR unicode_fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

} ISAPI_RESPONSE;


typedef struct custom_ad 
{

   DWORD ad_id;

   DWORD ad_demographics;

   DWORD gender_wt;

   DWORD age_group_wt;

   DWORD region_wt;

   DWORD interest1_wt;

   DWORD interest2_wt;

   DWORD minimum_match_value;

   DWORD expiration_time;

} CUSTOM_AD;


typedef struct lock
{

   volatile LONG current_state;

   volatile LONG num_writers;

} LOCK;


/*********************************************************************/


//
// Global Variables.
//


DWORD g_vector_send_io_mode_config = USE_SYNC_IO;

DWORD g_vector_send_async_range_start = 0;

DWORD g_read_file_io_mode_config = USE_SYNC_IO;

DWORD g_read_file_async_range_start = 0;

CHAR g_root_dir[ MAX_PATH ];

DWORD g_root_dir_length;

CHAR g_app_pool_name[ 1024 ];

DWORD g_app_pool_name_length = 1024;

SLIST_HEADER g_isapi_response_stack;

SLIST_HEADER g_class1_data_buffer_stack;

SLIST_HEADER g_class2_data_buffer_stack;

CUSTOM_AD g_custom_ads_buffer[ NUM_CUSTOM_ADS ];

DWORD *g_user_personalities_buffer = NULL;

LOCK g_user_personalities_buffer_lock;

LOCK g_custom_ads_buffer_lock;

HANDLE g_update_buffers_thread;

CHAR g_fragment_cache_key_base[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

DWORD g_fragment_cache_key_base_length;

volatile LONG g_fragment_cache_key_base_not_initialized = 1;

DWORD g_num_users;

CHAR *g_pszStatus_200 = "200 OK";

CHAR *g_pszStatus_404 = "404 File Inaccessible";

HSE_VECTOR_ELEMENT g_vector_element_0 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          "<html>\n"
                                          "<head><title>SPECweb99 Dynamic GET & POST Test</title></head>\n"
                                          "<body>\n"
                                          "<p>SERVER_SOFTWARE = Microsoft-IIS/6.0\n"
                                          "<p>REMOTE_ADDR = ",
                                          0,
                                          132 };

HSE_VECTOR_ELEMENT g_vector_element_2 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          "\n<p>SCRIPT_NAME = /specweb99-CAD.dll\n"
                                          "<p>QUERY_STRING = ",
                                          0, 
                                          55 };

HSE_VECTOR_ELEMENT g_vector_element_4 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          "\n<pre>\n",
                                          0,
                                          7 };

HSE_VECTOR_ELEMENT g_vector_element_6 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER, 
                                          "</pre>\n"
                                          "</body>\n</html>\n",
                                          0,
                                          23 };


/*********************************************************************/


//
// Function prototypes.
//


VOID init_lock( LOCK *lock );

VOID acquire_exclusive_lock( LOCK *lock );

VOID release_exclusive_lock( LOCK *lock );

VOID acquire_shared_lock( LOCK *lock );

VOID release_shared_lock( LOCK *lock );

VOID initialize_isapi_response_stack( VOID );

ISAPI_RESPONSE *allocate_isapi_response( VOID );

VOID free_isapi_response( ISAPI_RESPONSE * isapi_response_ptr );

VOID clear_isapi_response_stack( VOID );

VOID initialize_class1_data_buffer_stack( VOID );

CLASS1_DATA_BUFFER *allocate_class1_data_buffer( VOID );

VOID free_class1_data_buffer( CLASS1_DATA_BUFFER *class1_data_buffer_ptr );

VOID clear_class1_data_buffer_stack( VOID );

VOID initialize_class2_data_buffer_stack( VOID );

CLASS2_DATA_BUFFER *allocate_class2_data_buffer( VOID );

VOID free_class2_data_buffer( CLASS2_DATA_BUFFER *class2_data_buffer_ptr );

VOID clear_class2_data_buffer_stack( VOID );

VOID initialize_isapi_response_stack( VOID );

ISAPI_RESPONSE *allocate_isapi_response( VOID );

VOID free_isapi_response( ISAPI_RESPONSE * isapi_response_ptr );

VOID clear_isapi_response_stack( VOID );

BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr,
                                EXTENSION_CONTROL_BLOCK *pECB,
                                CHAR *filename,
                                DWORD filesize,
                                CHAR *set_cookie_string,
                                BOOL use_async_vector_send,
                                DWORD query_string_length );

BOOL load_user_personality_file( VOID );

BOOL load_custom_ads_file( VOID );

DWORD WINAPI update_user_and_ad_buffers( VOID *dummy_parameter );

DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB, 
                       CHAR *error_message,
                       CHAR *status,
                       DWORD query_string_length );

VOID dword_to_string( DWORD dword,
                      CHAR *string );

VOID WINAPI vector_send_completion_callback( EXTENSION_CONTROL_BLOCK *pECB,
                                             VOID *pvContext,
                                             DWORD cbIO,
                                             DWORD dwError );

VOID CALLBACK read_file_completion_callback( DWORD dwErrorCode,
                                             DWORD dwNumberOfBytesTransferred,
                                             OVERLAPPED *overlapped );

DWORD determine_set_cookie_string( INT64 user_index, 
                                   DWORD last_ad, 
                                   CHAR *set_cookie_string );

VOID insert_custom_ad_information( CHAR *buffer, DWORD ad_id );

DWORD handle_class1_or_class2_request( EXTENSION_CONTROL_BLOCK *pECB,
                                       ISAPI_RESPONSE *isapi_response_ptr,
                                       CHAR *filename,
                                       DWORD filesize,
                                       BOOL use_async_vector_send,
                                       DWORD ad_id,
                                       DWORD query_string_length );

BOOL load_registry_data( VOID );

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer );

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB );

BOOL WINAPI TerminateExtension( DWORD dwFlags );

#define LOG_ERROR( text, error )  _LogError(__FUNCTION__, __FILE__, __LINE__, text, error )

void _LogError(const char * function, const char *file, int line, char * text, DWORD error)
{
    char buf[1024];
    sprintf(buf, "%s(%d) %s - error=0x%x (%d) - %s\n", file, line, function, error, error, text );
    OutputDebugStringA(buf);	
}



/*********************************************************************/


VOID initialize_isapi_response_stack( VOID )
/*++

Routine Description:

   Initializes the stack of free ISAPI_RESPONSE structures on 
   the heap.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Initialize the SLIST_HEADER head that will be used to implement
   // the stack of free ISAPI_RESPONSE structures on the heap.
   //

   InitializeSListHead( &g_isapi_response_stack );

}


/*********************************************************************/


ISAPI_RESPONSE *allocate_isapi_response( VOID )
/*++

Routine Description:

   Pops an element off of the stack of free ISAPI_RESPONSE structures
   on the heap.

Arguments:

   None.

Return Value:

   Returns a pointer to a free ISAPI_RESPONSE structure on the heap.

--*/
{

   ISAPI_RESPONSE *isapi_response_ptr;


   //
   // Attempt to pop a free ISAPI_RESPONSE
   // structure off of g_isapi_response_stack.
   //

   if ( !( isapi_response_ptr = 
           ( ISAPI_RESPONSE * )InterlockedPopEntrySList( &g_isapi_response_stack ) ) )
   {


      //
      // If g_isapi_response_stack was empty
      // allocate a new ISAPI_RESPONSE structure
      // off of the heap.
      //

      isapi_response_ptr = ( ISAPI_RESPONSE * )malloc( sizeof( ISAPI_RESPONSE ) );

   }


   //
   // Return a pointer to the ISAPI_RESPONSE
   // structure allocated.
   //

   return( isapi_response_ptr );

}


/*********************************************************************/


VOID free_isapi_response( ISAPI_RESPONSE *isapi_response_ptr )
/*++

Routine Description:

   Pushes an element onto the stack of free ISAPI_RESPONSE structures
   on the heap.

Arguments:

   isapi_response_ptr - A pointer to a free ISAPI_RESPONSE structure 
                        on the heap.

Return Value:

   None.

--*/
{


   //
   // Pop the input pointer to a free ISAPI_RESPONSE
   // structure on the heap onto g_isapi_response_stack.
   //

   InterlockedPushEntrySList( &g_isapi_response_stack,
                              ( SINGLE_LIST_ENTRY * )isapi_response_ptr );

}


/*********************************************************************/


VOID clear_isapi_response_stack( VOID )
/*++

Routine Description:

   Destroys the stack of free ISAPI_RESPONSE structures on the heap,
   freeing all system resources allocated for this data structure.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Flush g_isapi_response_stack of all of
   // its elements and set 'curr_struct_ptr'
   // to point to a linked list containing
   // all of these elements.
   //

   SINGLE_LIST_ENTRY *curr_struct_ptr = InterlockedFlushSList( &g_isapi_response_stack );

   SINGLE_LIST_ENTRY *kill_struct_ptr;


   //
   // Destroy all elements in the linked
   // list initially pointed to by
   // 'curr_struct_ptr'.
   //
  
   while( curr_struct_ptr )
   {

      kill_struct_ptr = curr_struct_ptr;

      curr_struct_ptr = curr_struct_ptr->Next;

      free( ( ISAPI_RESPONSE * )kill_struct_ptr );

   }

}


/*********************************************************************/


VOID initialize_class1_data_buffer_stack( VOID )
/*++

Routine Description:

   Initializes the stack of free CLASS1_DATA_BUFFER structures on 
   the heap.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Initialize the SLIST_HEADER head that will be used to implement
   // the stack of free CLASS1_DATA_BUFFER structures on the heap.
   //

   InitializeSListHead( &g_class1_data_buffer_stack );

}


/*********************************************************************/


CLASS1_DATA_BUFFER *allocate_class1_data_buffer( VOID )
/*++

Routine Description:

   Pops an element off of the stack of free CLASS1_DATA_BUFFER
   structures on the heap.

Arguments:

   None.

Return Value:

   Returns a pointer to a free CLASS1_DATA_BUFFER structure on 
   the heap.

--*/
{

   CLASS1_DATA_BUFFER *class1_data_buffer_ptr;


   //
   // Attempt to pop a free CLASS1_DATA_BUFFER
   // structure off of g_class1_data_buffer_stack.
   //

   if ( !( class1_data_buffer_ptr = 
           ( CLASS1_DATA_BUFFER * )InterlockedPopEntrySList( &g_class1_data_buffer_stack ) ) )
   {


      //
      // If g_class1_data_buffer_stack was empty
      // allocate a new CLASS1_DATA_BUFFER structure
      // off of the heap.
      //

      class1_data_buffer_ptr = ( CLASS1_DATA_BUFFER * )malloc( sizeof( CLASS1_DATA_BUFFER ) );

   }


   //
   // Return a pointer to the CLASS1_DATA_BUFFER
   // structure allocated.
   //

   return( class1_data_buffer_ptr );   

}


/*********************************************************************/


VOID free_class1_data_buffer( CLASS1_DATA_BUFFER *class1_data_buffer_ptr )
/*++

Routine Description:

   Pushes an element onto the stack of free CLASS1_DATA_BUFFER
   structures on the heap.

Arguments:

   A pointer to a free CLASS1_DATA_BUFFER structure on the heap.

Return Value:

   None.

--*/
{


   //
   // Pop the input pointer to a free CLASS1_DATA_BUFFER
   // structure on the heap onto g_class1_data_buffer_stack.
   //

   InterlockedPushEntrySList( &g_class1_data_buffer_stack,
                              ( SINGLE_LIST_ENTRY * )class1_data_buffer_ptr );   

}


/*********************************************************************/


VOID clear_class1_data_buffer_stack( VOID )
/*++

Routine Description:

   Destroys the stack of free CLASS1_DATA_BUFFER structures on the heap,
   freeing all system resources allocated for this data structure.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Flush g_class1_data_buffer_stack of all
   // of its elements and set 'curr_struct_ptr'
   // to point to a linked list containing
   // all of these elements.
   //

   SINGLE_LIST_ENTRY *curr_struct_ptr = InterlockedFlushSList( &g_class1_data_buffer_stack );

   SINGLE_LIST_ENTRY *kill_struct_ptr;


   //
   // Destroy all elements in the linked
   // list initially pointed to by
   // 'curr_struct_ptr'
   //
  
   while( curr_struct_ptr )
   {

      kill_struct_ptr = curr_struct_ptr;

      curr_struct_ptr = curr_struct_ptr->Next;

      free( ( CLASS1_DATA_BUFFER * )kill_struct_ptr );

   }

}


/*********************************************************************/


VOID initialize_class2_data_buffer_stack( VOID )
/*++

Routine Description:

   Initializes the stack of free CLASS2_DATA_BUFFER structures on 
   the heap.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Initialize the SLIST_HEADER head that will be used to implement
   // the stack of free CLASS2_DATA_BUFFER structures on the heap.
   //

   InitializeSListHead( &g_class2_data_buffer_stack );

}


/*********************************************************************/


CLASS2_DATA_BUFFER *allocate_class2_data_buffer( VOID )
/*++

Routine Description:

   Pops an element off of the stack of free CLASS2_DATA_BUFFER
   structures on the heap.

Arguments:

   None.

Return Value:

   Returns a pointer to a free CLASS2_DATA_BUFFER structure on 
   the heap.

--*/
{

   CLASS2_DATA_BUFFER *class2_data_buffer_ptr;


   //
   // Attempt to pop a free CLASS2_DATA_BUFFER
   // structure off of g_class2_data_buffer_stack.
   //

   if ( !( class2_data_buffer_ptr = 
           ( CLASS2_DATA_BUFFER * )InterlockedPopEntrySList( &g_class2_data_buffer_stack ) ) )
   {


      //
      // If g_class2_data_buffer_stack was empty
      // allocate a new CLASS2_DATA_BUFFER structure
      // off of the heap.
      //

      class2_data_buffer_ptr = ( CLASS2_DATA_BUFFER * )malloc( sizeof( CLASS2_DATA_BUFFER ) );

   }


   //
   // Return a pointer to the CLASS2_DATA_BUFFER
   // structure allocated.
   //

   return( class2_data_buffer_ptr );   

}


/*********************************************************************/


VOID free_class2_data_buffer( CLASS2_DATA_BUFFER *class2_data_buffer_ptr )
/*++

Routine Description:

   Pushes an element onto the stack of free CLASS2_DATA_BUFFER
   structures on the heap.

Arguments:

   A pointer to a free CLASS2_DATA_BUFFER structure on the heap.

Return Value:

   None.

--*/
{


   //
   // Push the input pointer to a free CLASS2_DATA_BUFFER
   // structure on the heap onto g_class2_data_buffer_stack.
   //

   InterlockedPushEntrySList( &g_class2_data_buffer_stack,
                              ( SINGLE_LIST_ENTRY * )class2_data_buffer_ptr );   

}


/*********************************************************************/


VOID clear_class2_data_buffer_stack( VOID )
/*++

Routine Description:

   Destroys the stack of free CLASS2_DATA_BUFFER structures on the heap,
   freeing all system resources allocated for this data structure.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Flush g_class2_data_buffer_stack of all
   // of its elements and set 'curr_struct_ptr'
   // to point to a linked list containing
   // all of these elements.
   //

   SINGLE_LIST_ENTRY *curr_struct_ptr = InterlockedFlushSList( &g_class2_data_buffer_stack );

   SINGLE_LIST_ENTRY *kill_struct_ptr;


   //
   // Destroy all elements in the linked
   // list initially pointed to by
   // 'curr_struct_ptr'
   //
  
   while( curr_struct_ptr )
   {

      kill_struct_ptr = curr_struct_ptr;

      curr_struct_ptr = curr_struct_ptr->Next;

      free( ( CLASS2_DATA_BUFFER * )kill_struct_ptr );

   }

}


/*********************************************************************/


BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr,
                                EXTENSION_CONTROL_BLOCK *pECB,
                                CHAR *filename,
                                DWORD filesize,
                                CHAR *set_cookie_string,
                                BOOL use_async_vector_send,
                                DWORD query_string_length )
/*++

Routine Description:

   Initialize an ISAPI response structure by populating it with the
   appropriate data.

Arguments:

   isapi_response_ptr - Pointer to the ISAPI response structure to be
                        initialized.

   pECB - Pointer to the relevant extension control block.

   filename - Optional field indicating the absolute name of the file 
              requested.

   filesize - Optional field indicating the size of the file requested.

   set_cookie_string - String to use for Set-Cookie HTTP header field.

   use_async_vector_send - Flag indicating whether VectorSend is to be
                           used in asynchronous or synchronous mode.

Return Value:

   Returns TRUE on success and FALSE otherwise.

--*/
{

   DWORD remote_addr_size = 16; // 16 == sizeof( isapi_response_ptr->remote_addr )

   CHAR fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length = 16; // 16 == sizeof( content_length_string )

   DWORD set_cookie_string_length;

   DWORD ii;


   //
   // Set the fragment cache key.
   //

   strcpy( fragment_cache_key, g_fragment_cache_key_base );

   memcpy( fragment_cache_key + g_fragment_cache_key_base_length, 
           pECB->lpszQueryString, 
           query_string_length + 1 );

   for ( ii = 0; 
         isapi_response_ptr->unicode_fragment_cache_key[ ii ] = ( WCHAR )fragment_cache_key[ ii ];
         ii++ );


   //
   // Obtain the IP address of the client.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "REMOTE_ADDR",
                                  isapi_response_ptr->remote_addr,
                                  &remote_addr_size ) )
   {

      return( FALSE );

   }


   //
   // Obtain the cookie string.
   //

   strncpy( isapi_response_ptr->set_cookie_string, set_cookie_string, MAX_COOKIE_STRING_LENGTH );


   //
   // Populate the vector_element_array data structure.
   //

   isapi_response_ptr->vector_element_array[ 0 ] = g_vector_element_0;


   isapi_response_ptr->vector_element_array[ 1 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 1 ].pvContext = isapi_response_ptr->remote_addr;

   isapi_response_ptr->vector_element_array[ 1 ].cbSize = remote_addr_size - 1;


   isapi_response_ptr->vector_element_array[ 2 ] = g_vector_element_2;


   isapi_response_ptr->vector_element_array[ 3 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 3 ].pvContext = pECB->lpszQueryString;

   isapi_response_ptr->vector_element_array[ 3 ].cbSize = query_string_length;


   isapi_response_ptr->vector_element_array[ 4 ] = g_vector_element_4;


   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_FRAGMENT;

   isapi_response_ptr->vector_element_array[ 5 ].pvContext = ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key;


   isapi_response_ptr->vector_element_array[ 6 ] = g_vector_element_6;


   //
   // Populate the HSE_RESPONSE_VECTOR structure.  
   // To do this, use the following steps...
   //


   //
   // First, compute the string of HTTP headers to be sent with the
   // response.  To avoid a costly sprintf call, we will use memcpy
   // instead.
   //


   //
   // Copy the initial "hardcoded" component of the HTTP header string.
   //

   strcpy( isapi_response_ptr->pszHeaders, 
           
           "Content-type: text/html\r\n"
           "Content-Length: " );


   //
   // Construct a string representing the value of the HTTP Content-Length
   // header field.  Determine and store the length of this string.  Note
   // that 16 is the size of the buffer to which the content_length_string
   // is written.
   //

   dword_to_string( ( DWORD )( filesize +
                               isapi_response_ptr->vector_element_array[ 0 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 1 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 2 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 3 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 4 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 6 ].cbSize ),
                    
                    content_length_string );
   

   //
   // Concatenate the content length string to the header
   // string.  Note that prior to this operation the length
   // of the header string is 41.
   //

   memcpy( isapi_response_ptr->pszHeaders + 41, 
           content_length_string,
           content_length_string_length = strlen( content_length_string ) );


   //
   // Concatenate the 14 character hardcoded string "\r\nSet-Cookie: "
   // to the header string.  Note that just prior to this operation
   // the length of the header string is given by the variable 'ii'.
   //

   ii = 41 + content_length_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii,
           "\r\nSet-Cookie: ",
           14 );


   //
   // Concatenate the Set-Cookie string to the header string.  Note
   // that just prior to this operation the length of the header
   // string is given by the variable ii.
   //

   ii += 14;

   memcpy( isapi_response_ptr->pszHeaders + ii,
           set_cookie_string,
           set_cookie_string_length = strlen( set_cookie_string ) );


   //
   // Concatenate the 5 character hardcoded string "\r\n\r\n\0"
   // to the header string, indicating its termination.
   //

   ii += set_cookie_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii, "\r\n\r\n\0", 5 );


   //
   // Set the 'pszHeaders' field of the HSE_RESPONSE_VECTOR structure
   // to point to the HTTP header string just computed.
   //

   isapi_response_ptr->response_vector.pszHeaders = isapi_response_ptr->pszHeaders;


   //
   // Set the 'lpElementArray' field of the HSE_RESPONSE_VECTOR structure
   // to point to the array of HSE_VECTOR_ELEMENT structures populated
   // above.
   //

   isapi_response_ptr->response_vector.lpElementArray = isapi_response_ptr->vector_element_array;


   //
   // Indicate that the HSE_RESPONSE_VECTOR structure
   // has seven entries.
   //

   isapi_response_ptr->response_vector.nElementCount = 7;


   //
   // Set the HTTP status to "200 OK".
   //

   isapi_response_ptr->response_vector.pszStatus = g_pszStatus_200;


   //
   // Set the 'dwFlags' field of the HSE_RESPONSE_VECTOR structure
   // based on whether or not asynchronous VectorSend is to be
   // used.
   //

   if ( use_async_vector_send )
   {

     isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                   HSE_IO_SEND_HEADERS |
                                                   HSE_IO_ASYNC;
     
   }
   else
   {

     isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                   HSE_IO_SEND_HEADERS |
                                                   HSE_IO_SYNC;

   }


   //
   // Set the following additional fields if the ISAPI
   // response is to be sent to the client using
   // asynchronous VectorSend.
   //

   if ( use_async_vector_send )
     {


       //
       // By setting an 'hFile' HANDLE field we can check, in the
       // VectorSend completion callback routine, whether the
       // asynchronous VectorSend operation just completed made
       // use of a file handle.  If so, we must close the handle
       // in this callback.
       //
       
       isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

     }


   //
   // If you have not yet returned indicating failure, return
   // indicating success.
   //

   return( TRUE );

}               


/*********************************************************************/


VOID init_lock( LOCK *lock )
/*++

Routine Description:

   Initializes a LOCK object.

   NOTE: This locking mechanism is directly based on the dual spin
         lock implemented by Neel Jain (njain) for use in the original
         SPECweb99 ISAPI.  Its reliability remains to be determined.

Arguments:

   A pointer to the LOCK object to be initialized.

Return Value:

   None.

--*/
{


   //
   // Indicate that shared ownership is not currently held.
   //

   lock->current_state = FREE;


   //
   // Indicate that exclusive ownership is not currently held or being
   // waited for.
   //

   lock->num_writers = 0;

}


/*********************************************************************/


VOID acquire_exclusive_lock( LOCK *lock )
/*++

Routine Description:

   Attempts to acquire exclusive ownership of a LOCK object.

   NOTE: This locking mechanism is directly based on the dual spin
         lock implemented by Neel Jain (njain) for use in the original
         SPECweb99 ISAPI.  Its reliability remains to be determined.

Arguments:

   A pointer to the LOCK object to be acquired.

Return Value:

   None.

--*/
{


   //
   // Indicate that exclusive ownership has been requested.
   //

   InterlockedIncrement( &( lock->num_writers ) );

   while( TRUE )
   {


      //
      // If no other shared or exclusive ownership is held, do
      // the following...
      //

      if ( lock->current_state == FREE )
      {

         //
         // If no other shared or exclusive ownership is held,
         // attempt to gain exclusive ownership.
         //

         if ( FREE == InterlockedCompareExchange( &( lock->current_state ), LOCKED, FREE ) )
         {


            //
            // If exclusive ownership was gained, return.
            //

            return;

         }
         else
         {


            //
            // If exclusive ownership could not be gained, go to the
            // top of the loop.
            //

            continue;

         }

      }


      //
      // Otherwise, if shared or exclusive ownership is held,
      // essentially block this thread and switch to another that
      // is ready.
      //

      else
      {

         SwitchToThread();

      }

   }

}


/*********************************************************************/


VOID release_exclusive_lock( LOCK *lock )
/*++

Routine Description:

   Relinquishes exclusive ownership of a LOCK object.

   NOTE: This locking mechanism is directly based on the dual spin
         lock implemented by Neel Jain (njain) for use in the original
         SPECweb99 ISAPI.  Its reliability remains to be determined.

Arguments:

   A pointer to the LOCK object to be released.

Return Value:

   None.

--*/
{


   //
   // Indicate that neither shared nor exclusive ownership is now
   // held.
   //

   lock->current_state = FREE;


   //
   // Indicate that no exclusive ownership is now held or being
   // waited for.
   //

   InterlockedDecrement( &( lock->num_writers ) );

}


/*********************************************************************/


VOID acquire_shared_lock( LOCK *lock )
/*++

Routine Description:

   Attempts to acquire shared ownership of a LOCK object.

   NOTE: This locking mechanism is directly based on the dual spin
         lock implemented by Neel Jain (njain) for use in the original
         SPECweb99 ISAPI.  Its reliability remains to be determined.

Arguments:

   A pointer to the LOCK object to be acquired.

Return Value:

   None.

--*/
{

   LONG current_state;

   LONG writers_waiting;

   while( TRUE )
   {

      current_state = lock->current_state;

      writers_waiting = lock->num_writers;


      //
      // If no exclusive ownership of the lock is currently
      // held or being waited for, do the following...
      //

      if ( ( current_state != LOCKED ) && ( !writers_waiting ) )
      {


         //
         // Attempt to acquire a new instance of shared ownership
         // of the lock.
         //

         if ( current_state == InterlockedCompareExchange( &( lock->current_state ), 
                                                           current_state + 1, 
                                                           current_state ) )
         {


            //
            // If shared ownership was gained, return.
            //

            return;

         }
         else
         {


            //
            // If shared ownership could not be gained, go to the
            // top of the loop.
            //

            continue;

         }

      }


      //
      // Otherwise, if shared or exclusive ownership is held,
      // essentially block this thread and switch to another that
      // is ready.
      //

      else
      {

         SwitchToThread();

      }

   }

}


/*********************************************************************/


VOID release_shared_lock( LOCK *lock )
/*++

Routine Description:

   Relinquishes shared ownership of a LOCK object.

   NOTE: This locking mechanism is directly based on the dual spin
         lock implemented by Neel Jain (njain) for use in the original
         SPECweb99 ISAPI.  Its reliability remains to be determined.

Arguments:

   A pointer to the LOCK object to be released.

Return Value:

   None.

--*/
{


   //
   // Indicate that one fewer instance of shared ownership is 
   // now held.
   //

   InterlockedDecrement( &( lock->current_state ) );

}


/*********************************************************************/


BOOL load_user_personality_file( VOID )
/*++

Routine Description:

   Loads the User.Personality file data into an easily accessible
   in-memory data structure.

Arguments:

   None.

Return Value:

   Returns TRUE if the User.Personality file data is successfully
   loaded into the in-memory data structure and FALSE otherwise.

--*/
{

   CHAR user_personality_filename[ MAX_PATH ];

   HANDLE hFile;

   DWORD user_personality_filesize;

   CHAR *user_personality_file_data_buffer = NULL;

   DWORD bytes_read;

   DWORD user_id;

   DWORD ii;


   //
   // Read the User.Personality file into memory.  To do this, first
   // obtain a handle on this file.
   //

   strcpy( user_personality_filename, g_root_dir );

   strcat( user_personality_filename,  "/User.Personality" ); 

   if ( ( hFile = CreateFile( user_personality_filename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {

      return( FALSE );

   }


   //
   // Determine the size of the User.Personality file.
   //

   user_personality_filesize = GetFileSize( hFile, NULL );


   //
   // Allocate a new memory buffer to hold the raw data of the 
   // latest version of the User.Personality file.
   //

   if ( !( user_personality_file_data_buffer = ( CHAR * )malloc( user_personality_filesize ) ) )
   {

     CloseHandle( hFile );

     return( FALSE );

   }


   //
   // Load the raw User.Personality file data into the allocated
   // buffer and close the handle to this file.
   //

   if ( !ReadFile( hFile,
                   user_personality_file_data_buffer,
                   user_personality_filesize,
                   &bytes_read,
                   NULL ) )
   {

      CloseHandle( hFile );

      return( FALSE );

   }

   CloseHandle( hFile );


   //
   // Store the User.Personality file data in a DWORD array that is
   // indexed by user ID and whose entries consist of user demographics
   // data.  This structure makes it easier to access this data than
   // if it were read from the raw User.Personality file data.
   //


   //
   // If a DWORD array containing the data for a previous version of the
   // User.Personality file exists, free it.
   //

   if ( g_user_personalities_buffer )
   {

      free( g_user_personalities_buffer );

      g_user_personalities_buffer = NULL;

   }


   //
   // Allocate a new DWORD array.
   //

   g_num_users = user_personality_filesize / USER_PROFILE_SIZE;

   if ( !( g_user_personalities_buffer = ( DWORD * )malloc( g_num_users * sizeof( DWORD ) ) ) )
   {

     return( FALSE );

   }


   //
   // Fill the DWORD array using the raw User.Personality file data.
   //

   for ( ii = 0; ii < g_num_users; ii++ )
   {
       
      sscanf( user_personality_file_data_buffer + ( ii * USER_PROFILE_SIZE ),
               
              "%5d %8X",
              
              &user_id,
              &( g_user_personalities_buffer[ ii ] )
              
            );
      
}
   

   //
   // Free the buffer containing the raw User.Personality file data.
   //

   free( user_personality_file_data_buffer );


   //
   // If we have not yet returned indicating failure, return indicating
   // success.
   //

   return( TRUE );

}


/*********************************************************************/


BOOL load_custom_ads_file( VOID )
/*++

Routine Description:

   Loads the Custom.Ads file data into an easily accessible in-memory
   data structure.

Arguments:

   None.

Return Value:

   Returns TRUE is the Custom.Ads file data is successfully
   loaded into the in-memory data structure and false otherwise.

--*/
{

   CHAR custom_ads_filename[ MAX_PATH ];

   DWORD custom_ad_filesize = NUM_CUSTOM_ADS * CUSTOM_AD_SIZE;

   CHAR custom_ads_file_data_buffer[ NUM_CUSTOM_ADS * CUSTOM_AD_SIZE ];

   HANDLE hFile;

   DWORD bytes_read;

   DWORD weightings;

   DWORD ii;


   //
   // Read the Custom.Ads file into memory.  To do this, first
   // obtain a handle on this file.
   //

   strcpy( custom_ads_filename, g_root_dir );

   strcat( custom_ads_filename, "/Custom.Ads" );

   if ( ( hFile = CreateFile( custom_ads_filename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {

      return( FALSE );

   }


   //
   // Load the raw Custom.Ads file data into an in-memory buffer
   // and close the handle to this file.
   //

   if ( !ReadFile( hFile,
                   custom_ads_file_data_buffer,
                   custom_ad_filesize,
                   &bytes_read,
                   NULL ) )
   {

      CloseHandle( hFile );

      return( FALSE );

   }    
    
   CloseHandle( hFile );


   //
   // Store the Custom.Ads file data in an array (indexed by ad ID)
   // of structs whose fields represent the individual data items that
   // comprise a custom ad.  This structure makes it easier to access 
   // this data than if it were read from the raw Custom.Ads file.
   //

   for ( ii = 0; ii < NUM_CUSTOM_ADS; ii++ )
   {

     sscanf( custom_ads_file_data_buffer + ( ii * CUSTOM_AD_SIZE ),

             "%5d %8X %8X %3d %10d",

             &( g_custom_ads_buffer[ ii ].ad_id ),
             &( g_custom_ads_buffer[ ii ].ad_demographics ),
             &weightings,
             &( g_custom_ads_buffer[ ii ].minimum_match_value ),
             &( g_custom_ads_buffer[ ii ].expiration_time ) );

     g_custom_ads_buffer[ ii ].gender_wt = ( weightings >> 16 ) & WEIGHTING_MASK;

     g_custom_ads_buffer[ ii ].age_group_wt = ( weightings >> 12 ) & WEIGHTING_MASK;

     g_custom_ads_buffer[ ii ].region_wt = ( weightings >> 8 ) & WEIGHTING_MASK;

     g_custom_ads_buffer[ ii ].interest1_wt = ( weightings >> 4 ) & WEIGHTING_MASK;

     g_custom_ads_buffer[ ii ].interest2_wt = weightings & WEIGHTING_MASK;

   }


   //
   // If we have made it this far without returning indicating failure,
   // return indicating success.
   //

   return( TRUE );

}


/*********************************************************************/


DWORD WINAPI update_user_and_ad_buffers( VOID *dummy_parameter )
/*++

Routine Description:

   This function defines a persistent thread that waits on a change
   notification event that is signaled whenever a file in the webserver
   document root is changed (i.e. User.Personality or Custom.Ads) and
   refreshes the in-memory data structures holding the User.Personality
   and Custom.Ads file data with data from the latest versions of these
   files on disk.

Arguments:

   dummy_parameter - An unused parameter passed through the call to the
                     Win32 CreateThread function that invokes the routine
                     in a new thread.  This parameter added for compatibility 
                     the CreateThread interface.

Return Values:

   None.  This routine implements a persistent thread that cannot fail
   and so, never returns.

--*/
{


   //
   // Create a change notification event that is put in its signalled
   // state whenever a file in the webserver document root directory is
   // modified.  Note that the only such files that could possible be
   // changes are the User.Personality and Custom.Ads files.
   //

   HANDLE hEvent = FindFirstChangeNotification( g_root_dir,
                                                FALSE,
                                                FILE_NOTIFY_CHANGE_LAST_WRITE );


   //
   // Repeat the following steps indefinitely.
   //

   while( TRUE )
   {

      FindNextChangeNotification( hEvent );

      //
      // Wait for a file under the webserver document root to be
      // written to.
      //

      WaitForSingleObject( hEvent, INFINITE );


      //
      // Refresh the User.Preferences file data in memory.
      //

      acquire_exclusive_lock( &g_user_personalities_buffer_lock );

      load_user_personality_file();

      release_exclusive_lock( &g_user_personalities_buffer_lock );

      
      //
      // Refresh the Custom.Ads file data in memory.
      //

      acquire_exclusive_lock( &g_custom_ads_buffer_lock );

      load_custom_ads_file();

      release_exclusive_lock( &g_custom_ads_buffer_lock );

   }   

}


/*********************************************************************/


DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB, 
                       CHAR *error_message,
                       CHAR *status,
                       DWORD query_string_length )
/*++

Routine Description:

   Sends an HTML error page with a message and status specified by the
   caller.

Arguments:

   pECB - Pointer to the relevant extension control block.

   error_msg - Error message to send.

   status - Status to send (e.g. "200 OK").

Return Value:

   Returns HSE_STATUS_SUCCESS if the error page was successfully
   written to the client and HSE_STATUS_ERROR otherwise.

--*/
{

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;

   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length;

   DWORD ii;


   //
   // Initialize the ISAPI response structure to be associated 
   // with the error page.
   //

   if ( !initialize_isapi_response( isapi_response_ptr,
                                    pECB,
                                    "",
                                    0,
                                    "",
                                    FALSE,
                                    query_string_length ) )
   {
      LOG_ERROR("initialize_isapi_response failed", 0 );

      return( HSE_STATUS_ERROR );

   }


   //
   // Change the response_vector and vector_element_array in the
   // ISAPI response structure to specify and error message (to be
   // transmitted using synchronous I/O).  To do this use the
   // following steps...
   //


   //
   // Change the fifth element of the vector_element_array in the
   // ISAPI_RESPONSE structure (i.e. the "meat" of the message) to contain 
   // the error message.
   //

   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 5 ].pvContext = error_message;

   isapi_response_ptr->vector_element_array[ 5 ].cbSize = strlen( error_message );

   isapi_response_ptr->vector_element_array[ 5 ].cbOffset = 0;


   //
   // Construct the headers of the HTTP response.  Instead of using
   // a slow sprintf call, do the following...
   //


   //
   // Construct the first part of the header string.
   //

   strcat( isapi_response_ptr->pszHeaders, 

           "Content-Type: text/html\r\n"
           "Content-Length: " );


   //
   // Construct a string containing the value of the 'Content-Length'
   // header field and use memcpy to concatenate it onto the existing
   // header string (which, incidentally is 41 characters long at this
   // point).
   //

   dword_to_string( ( DWORD )( isapi_response_ptr->vector_element_array[ 0 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 1 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 2 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 3 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 4 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 5 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 6 ].cbSize ),
                     
                               content_length_string );
              
   memcpy( isapi_response_ptr->pszHeaders + 41, 
           content_length_string,    
           content_length_string_length = strlen( content_length_string ) );


   //
   // Now, use memcpy to concatenate the trailing new-line, carriage
   // return and null terminator characters that denote the end of
   // HTTP headers (incidentally, the header string is 41 + content_
   // length_string_length characters long before this concatenation.
   //

   ii = 41 + content_length_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii,
           "\r\n\r\n\0",
           5 );

   isapi_response_ptr->response_vector.pszStatus = status;


   //
   // Finally, send out the error page.
   //

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {
    
       LOG_ERROR("VectorSend() for error page failed", GetLastError() );
       return( HSE_STATUS_ERROR );

   }

   
   //
   // If you have made it this far without returning indicating an
   // error, return indicating success.
   //

   return( HSE_STATUS_SUCCESS );

}


/*********************************************************************/


VOID dword_to_string( DWORD dword, CHAR *string )
/*++

Routine Description:

   Generates a character string that captures the decimal representation
   of a DWORD.

Arguments:

   dword - The DWORD whose decimal representation is to be captured in
           a character string.

   string - A pointer to the buffer in which the character string generated
            is to be stored.

   string_buffer_size - A pointer to a DWORD which contains the size of
                        the output buffer provided.  On completion, the
                        size of the string generated is written to the
                        DWORD pointed to by this parameter.
  
Return Value:

   None.

--*/
{


   DWORD num_digits;

   INT ii;


   //
   // Determine the number of digits in the decimal 
   // representation of the input DWORD by taking the
   // integer part of its base 10 representation.
   //

   num_digits = ( DWORD )log10( dword ) + 1;


   //
   // Scroll through and fill the output buffer from the
   // lowest order to the highest order digit.  On each 
   // iteration the lowest order decimal digit is obtained
   // by using a modulo 10 (i.e. % 10) operation and then
   // dropped by performing an integer division by 10.
   //

   for ( ii = num_digits - 1; ii >= 0; ii-- )
   {

      string[ ii ] = '0' + ( CHAR )( dword % 10 );

      dword /= 10;

   }


   //
   // Set the '\0' terminating character of the
   // output string after the lowest order digit.
   //

   string[ num_digits ] = '\0';

}


/*********************************************************************/


VOID WINAPI vector_send_completion_callback( EXTENSION_CONTROL_BLOCK *pECB,
                                             VOID *pvContext,
                                             DWORD cbIO,
                                             DWORD dwError )
/*++

Routine Description:

   Callback invoked after completion of an asynchronous VectorSend.

Arguments:

   pECB - Pointer to the relevant extension control block.

   pContext - Pointer to the relevant ISAPI response structure.

   cbIO - Number of bytes sent.

   dwError - Error code for the VectorSend.

Return Value:

   None.

--*/
{

   ISAPI_RESPONSE *isapi_response_ptr = ( ISAPI_RESPONSE * )pvContext;

   DWORD status = HSE_STATUS_SUCCESS;


   //
   // If the file was sent using a file handle, close that
   // handle.
   //

   if ( isapi_response_ptr->hFile != INVALID_HANDLE_VALUE )
   {

      CloseHandle( isapi_response_ptr->hFile );
     
      isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   }


   //
   // Free any class 1 or class 2 data buffer structs used
   // by pushing them back onto the stack of free CLASS1_
   // DATA_BUFFER or the stack of free CLASS2_DATA_BUFFER
   // structures on the heap, respectively.
   //

   if ( isapi_response_ptr->class_number == 1 )
   {

      free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

   }
   else if ( isapi_response_ptr->class_number == 2 )
   {

      free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

   }


   //
   // Free the ISAPI response structure used by pushing
   // it back on the stack of free ISAPI_RESPONSE
   // structures.
   //

   free_isapi_response( ( ISAPI_RESPONSE * )pvContext );


   //
   // Indicate successful completion or failed completion of
   //  client request servicing by calling the HSE_REQ_DONE_
   // WITH_SESSION ServerSupportFunction with the appropriate
   // status code.
   //

   if ( dwError != ERROR_SUCCESS )
   {
      LOG_ERROR("Completion returned error", dwError );
      status = HSE_STATUS_ERROR;
   }

   pECB->ServerSupportFunction( pECB->ConnID,
                                HSE_REQ_DONE_WITH_SESSION,
                                &status,
                                NULL,
                                NULL );

}


/*********************************************************************/


VOID CALLBACK read_file_completion_callback( DWORD dwErrorCode,
                                             DWORD dwNumberOfBytesTransferred,
                                             OVERLAPPED *overlapped )
/*++

Routine Description:

   Callback routine invoked after completion of the asynchronous call
   to ReadFile in handle_class1_or_class2_request.  Continues handling
   of a SPECweb99 dynamic GET with custom ad rotation operation in
   which a class 1 or class 2 file is requested.
   
Arguments:

   dwErrorCode - Error code returned for the asynchronous ReadFile
                 operation.

   dwNumberOfBytesTransferred - Number of bytes transferred in the
                                asynchronous ReadFile operation.

   overlapped - A pointer to the OVERLAPPED structure used in the
                asynchronous ReadFile operation.  Note that this
                OVERLAPPED structure is the second field of the
                relevant ISAPI_RESPONSE structure, coming immediately
                after a SINGLE_LIST_ENTRY field.

Return Values:

   None.

--*/
{

   ISAPI_RESPONSE *isapi_response_ptr = 
     ( ISAPI_RESPONSE * )( ( ( BYTE * )overlapped ) - sizeof( SINGLE_LIST_ENTRY ) );

   CHAR *buffer;

   DWORD status = HSE_STATUS_SUCCESS;

   HCONN connection_id;


   //
   // Now that the asynchronous ReadFile has been is past us,
   // we are done with the copy of the file requested on disk and
   // so, can close the handle to it.
   //

   CloseHandle( isapi_response_ptr->hFile );

   isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;


   //
   // Check if the asynchronous ReadFile operation completed
   // successfully.  If not, bomb out.
   //

   if ( dwErrorCode != ERROR_SUCCESS )
   {


      //
      // Cache away the connection ID stored "in" the ISAPI_RESPONSE
      // structure used as we will need it to call the HSE_REQ_DONE_
      // WITH_SESSION ServerSupportFunction even after we have
      // deallocated the ISAPI_RESPONSE structure.
      //

      connection_id = isapi_response_ptr->pECB->ConnID;


      //
      // In the error case free any ISAPI_RESPONSE
      // or CLASS?_DATA_BUFFER structures allocated.
      //

      if ( isapi_response_ptr->class_number == 1 )
      {

         free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

      }
      else
      {

         free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

      }

      free_isapi_response( isapi_response_ptr );


      //
      // Indicate to IIS that you are finished servicing
      // the client request due to an error, by calling
      // the HSE_REQ_DONE_WITH_SESSION ServerSupportFunction
      // with an HSE_STATUS_ERROR status code.
      //

      status = HSE_STATUS_ERROR;

      isapi_response_ptr->pECB->ServerSupportFunction( connection_id,
                                                       HSE_REQ_DONE_WITH_SESSION,
                                                       &status,
                                                       NULL,
                                                       NULL );

      return;

   }

   if ( isapi_response_ptr->class_number == 1 )
   {

       buffer = isapi_response_ptr->class1_data_buffer_ptr->buffer;

   }
   else
   {

       buffer = isapi_response_ptr->class2_data_buffer_ptr->buffer;

   }


   //
   // Process the raw file data read into memory
   // to ensure that the appropriate custom ad
   // information is inserted.
   //

   insert_custom_ad_information( buffer, isapi_response_ptr->ad_id );


   //
   // Now that the processing of the file data in the buffer
   // is complete, we are ready to send it off to the client.
   // To do this, set the sixth item in the response vector
   // (i.e. the meat of the ISAPI response) to be the data
   // buffer containing the processed file data.
   //
   // Note that the size of the file data to be sent was
   // not changed in the processing applied and so, the
   // HTTP headers or other fields dependent on content
   // length do not need to be changed.
   //
 
   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   
   isapi_response_ptr->vector_element_array[ 5 ].pvContext = buffer;

   isapi_response_ptr->vector_element_array[ 5 ].cbSize = dwNumberOfBytesTransferred;

   isapi_response_ptr->vector_element_array[ 5 ].cbOffset = 0;


   //
   // Perform the synchronous or asynchronous VectorSend
   // operation.
   //

   if ( !isapi_response_ptr->pECB->ServerSupportFunction( isapi_response_ptr->pECB->ConnID,
                                                          HSE_REQ_VECTOR_SEND,
                                                          &( isapi_response_ptr->response_vector ),
                                                          NULL,
                                                          NULL ) )
   {


      //
      // Cache away the connection ID stored "in" the ISAPI_RESPONSE
      // structure used as we will need it to call the HSE_REQ_DONE_
      // WITH_SESSION ServerSupportFunction even after we have
      // deallocated the ISAPI_RESPONSE structure.
      //

      connection_id = isapi_response_ptr->pECB->ConnID;


      //
      // In the error case, free any ISAPI_RESPONSE
      // or CLASS?_DATA_BUFFER structures allocated.
      //

      if ( isapi_response_ptr->class_number == 1 )
      {

         free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

      }
      else
      {

         free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

      }

      free_isapi_response( isapi_response_ptr );


      //
      // Indicate to IIS that you are finished servicing
      // the client request due to an error, by calling
      // the HSE_REQ_DONE_WITH_SESSION ServerSupportFunction
      // with an HSE_STATUS_ERROR status code.
      //

      status = HSE_STATUS_ERROR;

      isapi_response_ptr->pECB->ServerSupportFunction( connection_id,
                                                       HSE_REQ_DONE_WITH_SESSION,
                                                       &status,
                                                       NULL,
                                                       NULL );

      return;

   }


   //
   // If you requested a synchronous VectorSend, you are
   // done at this point, so call the HSE_REQ_DONE_WITH_SESSION
   // ServerSupportFunction with an HSE_STATUS_SUCCESS status
   // code and decallocate any ISAPI_RESPONSE or CLASS?_DATA_BUFFER
   // structures used.
   //
   // If you requested an asynchronous VectorSend, just exit;
   // the status code is still the HSE_STATUS_PENDING returned
   // in handle_class1_or_class2_request.
   //

   if ( !isapi_response_ptr->use_async_vector_send )
   {

      connection_id = isapi_response_ptr->pECB->ConnID;

      if ( isapi_response_ptr->class_number == 1 )
      {

         free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

      }
      else
      {

         free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

      }

      free_isapi_response( isapi_response_ptr );

      isapi_response_ptr->pECB->ServerSupportFunction( connection_id,
                                                       HSE_REQ_DONE_WITH_SESSION,
                                                       &status,
                                                       NULL,
                                                       NULL );

   }

}


/*********************************************************************/


DWORD determine_set_cookie_string( INT64 user_index,
                                   DWORD last_ad, 
                                   CHAR *set_cookie_string )
/*++

Routine Description:

   Computes the Set-Cookie string and the ID of the ad to be sent in a
   based on the index (i.e. ID - 10000) of the user who made the request
   being serviced and the ID of the last ad seen by that user.

Arguments:

   user_index - The user index of the user whose request is being
                serviced.  Note that a user index is defined as the
                pertinent user ID minus 10000.  These indices are
                used as user ID's start from 10000.

   last_ad - The ID of the last ad seen by the user whose request is
             being serviced.  last_ad is -1 if the user has not
             previously seen an ad.

   set_cookie_string - A pointer to a buffer, of size MAX_COOKIE_STRING_
                       LENGTH, that will be used to store the Set-Cookie
                       string computed.

Return Values:

   Returns the ID of the ad to be sent or -1 if an out of range user index
   is provided.  Computes the Set-Cookie string and stores it in the buffer
   indicated by the parameter 'set_cookie_string'.

--*/
{

   DWORD current_time;

   DWORD ad_index;

   DWORD combined_demographics;

   DWORD ad_weight;

   DWORD expired;

   CHAR ad_index_string[ 4 ];

   CHAR ad_weight_string[ 11 ];

   DWORD ad_index_string_size;

   DWORD ad_weight_string_size;

   DWORD ad_index_string_length;

   DWORD ad_weight_string_length;

   DWORD ii;

   DWORD user_demographics;


   //
   // Check if the user_index is out of range.  If it is, use the
   // default Set-Cookie string and return the invalid ad ID of -1.
   //

   if ( user_index < 0 || user_index >= g_num_users )
   {
      
      strcpy( set_cookie_string, "found_cookie=Ad_id=-1&Ad_weight=00&Expired=1" );              
     
      return( -1 );
 
   }


   //
   // Obtain the current time.
   //

   time( ( time_t * )&( current_time ) );


   //
   // Obtain the demographic data for the specified user.
   //

   acquire_shared_lock( &g_user_personalities_buffer_lock );

   user_demographics = g_user_personalities_buffer[ user_index ];

   release_shared_lock( &g_user_personalities_buffer_lock );


   //
   // Scroll through custom ads in the in-memory data structure holding
   // the Custom.Ads file data and select an appropriate ad.  Note that
   // as this in-memory buffer is a shared resourse, shared ownership of
   // the lock protecting it, 'g_custom_ads_buffer_lock', must first
   // be obtained.
   //

   ad_index = last_ad;

   acquire_shared_lock( &g_custom_ads_buffer_lock );

   do
   {


      //
      // Increment ad_index (initially set to the ad ID of
      // the last ad seen by the user).  If you go past the
      // maximum ad ID of 359, go back to the ad with ID 0.
      //

      ad_index = ( ( ad_index + 1 ) % 360 );


      //
      // Determine the combined demographics information of the
      // user and the current ad that you are on.
      //

      combined_demographics = g_custom_ads_buffer[ ad_index ].ad_demographics &
                              user_demographics;


      //
      // Using the combined demographics information, calculate
      // the weight of the current ad using the following steps.
      //

      ad_weight = 0;

      if ( combined_demographics & GENDER_MASK )
      {

         ad_weight += g_custom_ads_buffer[ ad_index ].gender_wt;

      }

      if ( combined_demographics & AGE_GROUP_MASK )
      {

         ad_weight += g_custom_ads_buffer[ ad_index ].age_group_wt;

      }

      if ( combined_demographics & REGION_MASK )
      {

         ad_weight += g_custom_ads_buffer[ ad_index ].region_wt;

      }

      if ( combined_demographics & INTEREST1_MASK )
      {

         ad_weight += g_custom_ads_buffer[ ad_index ].interest1_wt;

      }

      if ( combined_demographics & INTEREST2_MASK )
      {

         ad_weight += g_custom_ads_buffer[ ad_index ].interest2_wt;

      }


      //
      // If the weight of the current ad meets a certain minimum
      // threshold, we have a match.  In this case, determine whether
      // or not the selected ad has expired and break from the loop.
      //

      if ( ad_weight >= g_custom_ads_buffer[ ad_index ].minimum_match_value )
      {

         if ( current_time >= g_custom_ads_buffer[ ad_index ].expiration_time )
         {

            expired = 1;

         }
         else
         {

           expired = 0;

         }

         break;

      }


      //
      // If the current ad was not acceptable, move on to the next.
      // Continue looping in this fashion until an acceptable ad is
      // found (which may turn out to be the last ad seen).  Note that
      // SPECweb99 is clearly ensuring that the custom ads buffer
      // will contain at least one matching record.
      //

   } while( ad_index != last_ad );


   //
   // Once we have found a matching ad, we are done with the
   // custom ads buffer.  Release the shared lock held on it.
   //

   release_shared_lock( &g_custom_ads_buffer_lock );


   //
   // Construct the Set-Cookie string to write in the buffer
   // 'set_cookie_string'.  To avoid making a costly sprintf
   // call or effectively repeating strlen calls, memcpy will
   // be used.
   //  
   // Note that the Set-Cookie string returned will have the format:
   // "found_cookie=Ad_id=<ad_id>&Ad_weight=<ad_weight>&Expired=<expired>" 
   //


   //
   // Copy the "hardcoded" base of the Set-Cookie string.
   //

   strcpy( set_cookie_string, "found_cookie=Ad_id=" );


   //
   // Construct a string representing the ID of the ad
   // to be returned.  Determine and store the length
   // of this string.
   //

   dword_to_string( ad_index, ad_index_string );

   ad_index_string_length = strlen( ad_index_string );


   //
   // Construct a string representing the weight of the
   // ad selected.  Determine and store the length of this
   // string.
   //
   // Note that we do not check to failure of dword_to_string
   // as the buffer 'ad_weight_string' is sufficiently large
   // and so this function is guaranteed to succeed.
   //

   dword_to_string( ad_weight, ad_weight_string );

   ad_weight_string_length = strlen( ad_weight_string );


   //
   // Concatenate the ad ID string onto the Set-Cookie string.
   // Note that 19 is the length of the Set-Cookie string before
   // this operation.
   //

   memcpy( set_cookie_string + 19, ad_index_string, ad_index_string_length );


   //
   // Concatenate the hardcoded, 11 character string "&Ad_weight",
   // onto the Set-Cookie string.  Note that ii contains the length
   // of the Set-Cookie string just prior to this operation.
   //
    
   ii = 19 + ad_index_string_length;

   memcpy( set_cookie_string + ii, "&Ad_weight=", 11 );


   //
   // Concatenate the ad weigth string onto the Set-Cookie string.
   // Note that ii contains the length of the Set-Cookie string
   // just prior to this operation.
   //

   ii += 11;

   memcpy( set_cookie_string + ii, ad_weight_string, ad_weight_string_length );


   //
   // Concatenate either of the hardcoded, 11 character strings
   // "&Expired=1\0" or "&Expired=0\0" onto the Set-Cookie string,
   // depending on the value of the variable 'expired'.  Note that
   // ii contains the length of the Set-Cookie string just prior
   // to this operation.
   //

   ii += ad_weight_string_length;

   memcpy( set_cookie_string + ii, 
           ( expired ) ? "&Expired=1\0" : "&Expired=0\0",
           11 );


   //
   // Return the ID of the ad selected.
   //

   return( ad_index );

}


/*********************************************************************/


VOID insert_custom_ad_information( CHAR *buffer, DWORD ad_id )
/*++

Routine Description:

Arguments:

   buffer - Pointer to a buffer, containing the raw data of a class
            1 or class 2 file, into which custom ad information is to
            be inserted.

   ad_id - The ID of the custom ad to be inserted into the raw file
           data.

Return Value:

   None

--*/
{

   CHAR substitute_directory_string[ 5 ];

   CHAR substitute_class_char;

   CHAR substitute_file_char;

   CHAR *tag_start_ptr;

   DWORD ii;

   DWORD jj;


   //
   // We must now go through the file data buffer process it in
   // the following manner.
   //
   // (1) Find each tag of the form "<!WEB99CAD><IMG SRC=/file_set/
   //     dirNNNNN/classX_Y><!/WEB99CAD>" using the minimum required
   //     search string "<!WEB99CAD><IMG SRC=/file_set/dir".
   //
   // (2) For each tag found in (1), in turn, do the following:
   //
   //     (a) Replace NNNNN with ( ad_id / 36 ) padded to five
   //         digits.
   //
   //     (b) Replace X with ( ( ad_id / 36 ) / 9 ).
   //
   //     (c) Replace Y with ( ad_id % 9 ).
   //  


   //
   // Compute the directory number characters.  That is, compute the
   // charasters that will be used to replace NNNNN in the tags
   // described.
   //

   substitute_directory_string[ 0 ] = '0';

   substitute_directory_string[ 1 ] = '0';

   substitute_directory_string[ 2 ] = '0';

   substitute_directory_string[ 3 ] = '0' + ( CHAR )( ( ad_id / 36 ) / 10 );

   substitute_directory_string[ 4 ] = '0' + ( CHAR )( ( ad_id / 36 ) % 10 );
   

   //
   // Compute the class number.  That is, compute the character
   // that will be used to replace X in the tags described.
   //

   substitute_class_char = '0' + ( CHAR )( ( ad_id % 36 ) / 9 );


   //
   // Compute the file number.  That is, compute the character
   // that will be used to replace Y in the tags described.
   //

   substitute_file_char = '0' + ( CHAR )( ad_id % 9 );   


   //
   // Now, actually scroll through the file data buffer, find the
   // tags described and make the specified subsitutions for each.
   //

   for ( tag_start_ptr = strstr( buffer, "<!WEB99CAD><IMG SRC=\"/file_set/dir" );
         tag_start_ptr;
         tag_start_ptr = strstr( tag_start_ptr + 1, "<!WEB99CAD><IMG SRC=\"/file_set/dir" ) )
   {


      //
      // Note that characters 34 through 39 in the tags
      // specified (where the first character is numbered 0)
      // correspond to the NNNNN to be replaced with the 
      // substitute directory number.
      //

      for ( ii = 0, jj = 34; ii < 5; ii++, jj++ )
      {
         
         tag_start_ptr[ jj ] = substitute_directory_string[ ii ];
         
      }


      //
      // Note that character 45 in the tags specified
      // (where the first character is numbered 0) corresponds
      // to the X to replace with the substitute class character.
      //
      
      tag_start_ptr[ 45 ] = substitute_class_char;
      

      //
      // Note that character 47 in the tags specified
      // (where the first character is numbered 0) corresponsds
      // to the Y to replace with the substitute file character.
      //

      tag_start_ptr[ 47 ] = substitute_file_char;
    
   }   

}


/*********************************************************************/


DWORD handle_class1_or_class2_request( EXTENSION_CONTROL_BLOCK *pECB,
                                       ISAPI_RESPONSE *isapi_response_ptr,
                                       CHAR *filename,
                                       DWORD filesize,
                                       BOOL use_async_vector_send,
                                       DWORD ad_id,
                                       DWORD query_string_length )
/*++

Routine Description:

   This routine, called from HttpExtensionProc completes the handling
   of a SPECweb99 dynamic GET with custom ad rotation operation in
   which a class 1 or class 2 file is requested.

Arguments:

   pECB - Pointer to the relevant extension control block.

   isapi_response_ptr - Pointer to the relevant ISAPI_RESPONSE structure.

   filename - Pointer to a string specifying the absolute name of 
              the file requested.

   filesize - Size of the file requested.

   use_async_vector_send - Flag indicating whether VectorSend is to be
                           used in asynchronous or synchronous mode.

   ad_id - The ID of the custom ad selected.

   query_string_length - The length of the query string provided.

Return Values:

   Returns HSE_STATUS_ERROR if any failures occur in the routine.

   Otherwise, if either asynchronous VectorSend or ReadFile is
   used, HSE_STATUS_PENDING is returned.  Alternatively, if neither
   asynchronous VectorSend nor ReadFile is used, HSE_STATUS_SUCCESS
   is returned.

--*/
{

   BOOL use_async_read_file;

   ISAPI_RESPONSE *heap_isapi_response_ptr;

   DWORD bytes_read;

   CHAR *buffer;

   CLASS2_DATA_BUFFER stack_class2_data_buffer;

   DWORD size = sizeof( stack_class2_data_buffer.buffer );

   DWORD ii;

   OVERLAPPED *overlapped_ptr;

   DWORD dwFlagsAndAttributes;


   //
   // We need to obtain the raw file data of the class1 or
   // class 2 file requested.  Before we do this, however,
   // we need a buffer in which to hold this data.  Allocate
   // such a buffer from the heap if we know, at this point,
   // that will be carrying out an asynchronous I/O operation
   // (i.e. is use_async_vector_send true) and from the stack
   // otherwise.
   //

   if ( use_async_vector_send )
   {

      if ( isapi_response_ptr->class_number == 1 )
      {

         if ( !( isapi_response_ptr->class1_data_buffer_ptr = allocate_class1_data_buffer() ) )
         {

            free_isapi_response( isapi_response_ptr );
            LOG_ERROR( "allocation failed", 0 );

            return( HSE_STATUS_ERROR );

         }

         buffer = isapi_response_ptr->class1_data_buffer_ptr->buffer;

      }
      else
      {

         if ( !( isapi_response_ptr->class2_data_buffer_ptr = allocate_class2_data_buffer() ) )
         {

            free_isapi_response( isapi_response_ptr );
            LOG_ERROR("Allocation failed",0 );

            return( HSE_STATUS_ERROR );

         }

         buffer = isapi_response_ptr->class2_data_buffer_ptr->buffer;

      }

   }

   else
   {


      //
      // Note that if we are not using asynchronous VectorSend
      // it is safe, for now at least, to use a buffer on the stack
      // to store our file data.  This may change if we find that
      // we will have to use asynchronous ReadFile later on./
      //
      // Also, we are simply using a CLASS2_DATA_BUFFER buffer
      // field here as it is sufficiently large to hold both
      // class 1 and 2 files and thus, to store an additional
      // CLASS1_DATA_BUFFER on the stack would have been wasteful.
      //

      isapi_response_ptr->class2_data_buffer_ptr = &( stack_class2_data_buffer );

      buffer = isapi_response_ptr->class2_data_buffer_ptr->buffer;

   }


   //
   // Now, attempt to read the data of the file requested
   // into the allocated buffer from the HTTP.SYS fragment
   // cache.
   //

   if ( pECB->ServerSupportFunction( pECB->ConnID,
                                     HSE_REQ_READ_FRAGMENT_FROM_CACHE,
                                     buffer,
                                     &size,
                                     ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key ) )
   {


      //
      // Now, if you had a cache hit, apply the necessary
      // processing to the file data.
      //

      insert_custom_ad_information( buffer, ad_id );


      //
      // Now that the processing of the file data in the buffer
      // is complete, we are ready to send it off to the client.
      // To do this, set the sixth item in the response vector
      // (i.e. the meat of the ISAPI response) to be the data
      // buffer containing the processed file data.
      //
      // Note that the size of the file data to be sent was
      // not changed in the processing applied and so, the
      // HTTP headers or other fields dependent on content
      // length do not need to be changed.
      //
 
      isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
      
      isapi_response_ptr->vector_element_array[ 5 ].pvContext = buffer;
      
      isapi_response_ptr->vector_element_array[ 5 ].cbSize = filesize;
      

      //
      // Carry out the actual synchronous or
      // asynchronous VectorSend operation.
      //

      if ( pECB->ServerSupportFunction( pECB->ConnID,
                                        HSE_REQ_VECTOR_SEND,
                                        &( isapi_response_ptr->response_vector ),
                                        NULL,
                                        NULL ) )
      {


         //
         // If the VectorSend operation returned
         // indicating success return HSE_STATUS_PENDING
         // or HSE_STATUS_SUCCESS depending on whether
         // or not asynchronous or synchronous I/O was
         // used, respectively.
         //

         if ( use_async_vector_send )
         {

            return( HSE_STATUS_PENDING );

         }
         else
         {

            return( HSE_STATUS_SUCCESS );

         }

      }    

      else
      {

         DWORD dwError = GetLastError();
         LOG_ERROR(" VectorSend() failed", GetLastError() );

         //
         // Otherwise, if the VectorSend operation
         // returned indicating failure return
         // HSE_STATUS_ERROR.
         //
         // Note that if it was the initiation of an
         // asynchronous VectorSend that failed,
         // the ISAPI_RESPONSE and CLASS1_DATA_BUFFER
         // or CLASS2_DATA_BUFFER structures used
         // must be deallocated before returning.
         //

         if ( use_async_vector_send )
         {

            if ( isapi_response_ptr->class_number == 1 )
            {

               free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

            }
            else
            {

               free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

            }

            free_isapi_response( isapi_response_ptr );

         }

         return( HSE_STATUS_ERROR );

      }

   }


   //
   // Alternatively, if you had a cache miss, you must
   // read the data of the file requested into memory
   // using either a synchronous or asynchronous ReadFile
   // operation.
   //


   //
   // First, determine the I/O mode to use with ReadFile.
   //

   switch( g_read_file_io_mode_config )
   {
      
      case USE_ASYNC_IO:
      {
        
         use_async_read_file = TRUE;
        
         break;
        
      }
      
      case USE_SYNC_IO:
      {
        
         use_async_read_file = FALSE;
        
         break;
         
      }
      
      case USE_ADAPTABLE_IO:
      {
        
         use_async_read_file = ( filesize >= g_read_file_async_range_start );

         break;
        
      }
      
   };


   //
   // Now, if we are using an ISAPI_RESPONSE structure or file data
   // buffer on the stack and find that we must do an asynchronous 
   // ReadFile, we must switch to using an ISAPI_RESPONSE struct and
   // file data buffer allocated from the heap.
   //
   // The condition ( !use_async_vector_send && use_async_read_file )
   // can be explained as follows:
   //
   // (1) We only need to worry about switching to a file data
   //     buffer and ISAPI_RESPONSE structure on the heap at this 
   //     point if we are using synchronous VectorSend, as if we are
   //     using asynchronous VectorSend we would have known this earlier
   //     and already the heap.
   //
   // (2) Also, if we are using synchronous VectorSend we only need
   //     to worry about using an ISAPI_RESPONSE structure and file
   //     data buffer on the heap if we are going to use asynchronous
   //     ReadFile.  Otherwise, all of our I/O is synchronous and stack
   //     memory will suffice.
   //

   if ( !use_async_vector_send && use_async_read_file )
   {


      //
      // First, switch from using an ISAPI_RESPONSE structure
      // on the stack to using an ISAPI_RESPONSE structure on
      // the heap.
      //


      //
      // Try to allocate a free ISAPI_RESPONSE
      // structure on the heap.
      // 
 
      if ( !( heap_isapi_response_ptr = allocate_isapi_response() ) )
      {
         LOG_ERROR("Allocation failed", 0 );
         return( HSE_STATUS_ERROR );

      }
            
      
      //
      // Now copy all relevant data in the ISAPI_RESPONSE
      // structure on the stack to the newly allocated one 
      // on the heap.
      //
      // Note that the vector_element_array member of
      // the ISAPI_RESPONSE structure has seven elements. 
      //

      memcpy( heap_isapi_response_ptr, isapi_response_ptr, sizeof( ISAPI_RESPONSE ) );

      heap_isapi_response_ptr->response_vector.lpElementArray = heap_isapi_response_ptr->vector_element_array;

      heap_isapi_response_ptr->response_vector.pszHeaders = heap_isapi_response_ptr->pszHeaders;


      //
      // After copying all of the data from the stack
      // to the heap ISAPI_RESPONSE struct, set
      // 'isapi_response_ptr' to point to the latter.
      //

      isapi_response_ptr = heap_isapi_response_ptr;
        

      //
      // Now, switch to using a file data buffer on
      // the heap instead of one on the stack.
      //


      //
      // If the file class number is 1, do the following...
      //

      if ( isapi_response_ptr->class_number == 1 )
      {


         //
         // Attempt to allocate a CLASS1_DATA_BUFFER structure
         // off of the stack of free CLASS1_DATA_BUFFER
         // structures on the heap.
         //

         if ( !( isapi_response_ptr->class1_data_buffer_ptr = allocate_class1_data_buffer() ) )
         {


            //
            // In the error case, free the ISAPI_RESPONSE
            // structure allocated from the heap.
            //

            free_isapi_response( isapi_response_ptr );
            LOG_ERROR( "Allocation failed", 0 );

            return( HSE_STATUS_ERROR );

         }

         buffer = isapi_response_ptr->class1_data_buffer_ptr->buffer;

      }


      //
      // Otherwise, if the file class number is 2, do the following...
      // Note that this is essentially a mirror of the case for
      // class 1 directly above.
      //

      else
      {


         //
         // Attempt to allocate a CLASS2_DATA_BUFFER 
         // structure off of the stack of free CLASS2_
         // DATA_BUFFER structures on the heap.
         //

         if ( !( isapi_response_ptr->class2_data_buffer_ptr = allocate_class2_data_buffer() ) )
         {


            //
            // In the error case, free the ISAPI_RESPONSE
            // structure allocated from the heap.
            //

            free_isapi_response( isapi_response_ptr );
            LOG_ERROR("Allocation failed", 0 );

            return( HSE_STATUS_ERROR );    

         }

         buffer = isapi_response_ptr->class2_data_buffer_ptr->buffer;

      }

   }


   //
   // Now, we must read the contents of the requested file into
   // memory before we can perform the necessary processing on
   // its data. To do this we must first open a handle to the 
   // file using CreateFile.
   //
   // Note that we specify an OVERLAPPED structure as we may
   // want to use asynchronous ReadFile.
   //

   if ( use_async_read_file )
   {

      dwFlagsAndAttributes = FILE_FLAG_OVERLAPPED;

      isapi_response_ptr->overlapped.Offset = 0;

      isapi_response_ptr->overlapped.OffsetHigh = 0;

      isapi_response_ptr->overlapped.hEvent = 0;

      overlapped_ptr = &( isapi_response_ptr->overlapped );

   }
   else
   {

      dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;

      overlapped_ptr = NULL;

   }

   if ( ( isapi_response_ptr->hFile = CreateFile( filename,
                                                  GENERIC_READ,
                                                  FILE_SHARE_READ,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  dwFlagsAndAttributes,
                                                  NULL ) ) == INVALID_HANDLE_VALUE )
   {


      //
      // In the failure case, free any ISAPI_RESPONSE
      // and CLASS1_DATA_BUFFER or CLASS2_DATA_BUFFER
      // structures allocated and send an HTML error
      // page to the client.
      //

      if ( use_async_vector_send )
      {

         if ( isapi_response_ptr->class_number == 1 )
         {

            free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

         }
         else
         {

            free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

         }

         free_isapi_response( isapi_response_ptr );
         
      }

      return( send_error_page( pECB,
                               "File inaccessible.",
                               g_pszStatus_404,
                               query_string_length ) );

   }


   //
   // If asynchonous ReadFile is to be used, the following
   // steps must be carried out...
   //

   if ( use_async_read_file )
   {


      //
      // Specify the completion callback routine to invoke
      // after the asynchronous ReadFile operation has
      // completed.
      //
 
      BindIoCompletionCallback( isapi_response_ptr->hFile,
                                read_file_completion_callback,
                                0 );


      //
      // Copy the following additional data items, that will be
      // needed in the asynchronous ReadFile completion callback 
      // routine, to the ISAPI_RESPONSE struct
      //   

      isapi_response_ptr->ad_id = ad_id;
      
      isapi_response_ptr->pECB = pECB;


      //
      // Initiate the asynchronous ReadFile operation
      // and return HSE_STATUS_PENDING.
      //   

      if ( !ReadFile( isapi_response_ptr->hFile,
                      buffer,
                      filesize,
                      &bytes_read,
                      overlapped_ptr ) )
      {

         LOG_ERROR( "ReadFile failed()", GetLastError() );
          
         //
         // In the error case, first close the file
         // handle that has been opened.
         //

         CloseHandle( isapi_response_ptr->hFile );

         isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;


         //
         // Also, free any ISAPI_RESPONSE or CLASS1_DATA_
         // BUFFER structures allocated.
         //

         if ( isapi_response_ptr->class_number == 1 )
         {

            free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );
           
         }
         else
         {

            free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

         }

         free_isapi_response( isapi_response_ptr );
         return( HSE_STATUS_ERROR );

      }


      //
      // Free the current thread by returning
      // HSE_STATUS_PENDING.
      //

      return( HSE_STATUS_PENDING );

   }


   //
   // Perform the appropriate synchronous ReadFile 
   // operation depending on the class number of the
   // file requested.
   //

   if ( !ReadFile( isapi_response_ptr->hFile,
                   buffer,
                   filesize,
                   &bytes_read,
                   NULL ) )
   {

      LOG_ERROR( "ReadFile failed()", GetLastError() );

      //
      // In the error case, first free the file
      // handle opened.
      //

      CloseHandle( isapi_response_ptr->hFile );

      isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

     
      //
      // Also, free any ISAPI_RESPONSE or CLASS1_
      // DATA_BUFFER structures allocated.
      //

      if ( use_async_vector_send )
      {

         if ( isapi_response_ptr->class_number == 1 )
         {
         
            free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

         }
         else
         {

            free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

         }

         free_isapi_response( isapi_response_ptr );

      }
      return( HSE_STATUS_ERROR );

   }


   //
   // We are now done with the copy of the requested file on disk
   // and so, the handle to it can be closed.
   //

   CloseHandle( isapi_response_ptr->hFile );

   isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   
   //
   // Process the raw file data read into memory
   // to ensure that the appropriate custom ad
   // information is inserted.
   //

   insert_custom_ad_information( buffer, ad_id );


   //
   // Now that the processing of the file data in the buffer
   // is complete, we are ready to send it off to the client.
   // To do this, set the sixth item in the response vector
   // (i.e. the meat of the ISAPI response) to be the data
   // buffer containing the processed file data.
   //
   // Note that the size of the file data to be sent was
   // not changed in the processing applied and so, the
   // HTTP headers or other fields dependent on content
   // length do not need to be changed.
   //
 
   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   
   isapi_response_ptr->vector_element_array[ 5 ].pvContext = buffer;
   
   isapi_response_ptr->vector_element_array[ 5 ].cbSize = filesize;
   
   isapi_response_ptr->vector_element_array[ 5 ].cbOffset = 0;


   //
   // Carry out the actual synchronous or
   // asynchronous VectorSend operation.
   //
   
   if ( pECB->ServerSupportFunction( pECB->ConnID,
                                     HSE_REQ_VECTOR_SEND,
                                     &( isapi_response_ptr->response_vector ),
                                     NULL,
                                     NULL ) )
   {


     //
     // If the VectorSend operation returned
     // indicating success return HSE_STATUS_PENDING
     // or HSE_STATUS_SUCCESS depending on whether
     // or not asynchronous or synchronous I/O was
     // used, respectively.
     //

     if ( use_async_vector_send )
     {

        return( HSE_STATUS_PENDING );

     }
     else
     {

       return( HSE_STATUS_SUCCESS );

     }

   }    

   else
   {
      LOG_ERROR("VectorSend() failed",GetLastError());  

      //
      // Otherwise, if the VectorSend operation
      // returned indicating failure return
      // HSE_STATUS_ERROR.
      //
      // Note that if it was the initiation of an
      // asynchronous VectorSend that failed,
      // the ISAPI_RESPONSE and CLASS1_DATA_BUFFER
      // or CLASS2_DATA_BUFFER structures used
      // must be deallocated before returning.
      //

      if ( use_async_vector_send )
      {

         if ( isapi_response_ptr->class_number == 1 )
         {

            free_class1_data_buffer( isapi_response_ptr->class1_data_buffer_ptr );

         }
         else
         {

            free_class2_data_buffer( isapi_response_ptr->class2_data_buffer_ptr );

         }

         free_isapi_response( isapi_response_ptr );

      }

      return( HSE_STATUS_ERROR );

   }

}   


/*********************************************************************/


BOOL load_registry_data( VOID )
/*++

Routine Description:

   Loads registry values used for configuration of specweb99-CAD.dll.

Arguments:

   None.

Return Value:

   Returns TRUE if all registry values are successfully loaded and
   FALSE otherwise.

--*/
{

   HKEY hKey;

   DWORD value_type;
   
   DWORD value_size;
   
   DWORD sizeof_value;
   
   BYTE value[ 4 ];


   //
   // Open the registry key containing all values used for
   // specweb99-CAD.dll configuration.
   //

   if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "Software\\Microsoft\\SPECweb99 ISAPI",
                      0,
                      KEY_QUERY_VALUE,
                      &hKey ) )
   {

      return( FALSE );

   }
       

   //
   // Load the value VECTOR_SEND_IO_MODE_CONFIG into the variable
   // g_vector_send_io_mode_config.
   //

   value_size = sizeof_value = sizeof( value );

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_IO_MODE_CONFIG",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_io_mode_config = *( ( DWORD* )value );
   }


   //
   // Load the value VECTOR_SEND_ASYNC_RANGE_START into the
   // variable g_vector_send_async_range_start.
   //

   value_size = sizeof_value;

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_ASYNC_RANGE_START",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_async_range_start = *( ( DWORD * )value );
   }


   //
   // Load the value READ_FILE_IO_MODE_CONFIG into the variable
   // g_read_file_io_mode_config.
   //

   value_size = sizeof_value;

   if ( RegQueryValueEx( hKey,
                         "READ_FILE_IO_MODE_CONFIG",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_read_file_io_mode_config = *( ( DWORD * )value );
   }


   //
   // Load the value READ_FILE_ASYNC_RANGE_START into the variable
   // g_read_file_async_range_start.
   //

   value_size = sizeof_value;

   if ( RegQueryValueEx( hKey,
                         "READ_FILE_ASYNC_RANGE_START",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_read_file_async_range_start = *( ( DWORD * )value );
   }


   //
   // Load the value ROOT_DIR into the variable g_root_dir.
   // Store the length of this string in g_root_dir_length.
   //

   value_size = sizeof( g_root_dir );

   if ( RegQueryValueEx( hKey,
                         "ROOT_DIR",
                         NULL,
                         &value_type,
                         ( BYTE * )g_root_dir,
                         &value_size ) == NO_ERROR )
   {
      g_root_dir_length = value_size - 1;
   }
   else
   {
      return( FALSE );
   }


   //
   // If you have made it this far without returning indicating
   // failure, return indicating success.
   //

   return( TRUE );

}


/*********************************************************************/


BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
/*++

Routine Description:

   Implementation of the GetExtensionVersion ISAPI entry point.
   Carries out general initialization tasks and provides IIS with
   version information.

Arguments:

   pVer - Pointer to the version information structure to be
          populated.

Return Value:

   Returns TRUE if all initialization steps are successfully completed
   and FALSE otherwise.

--*/
{


   //
   // Load configuration data from the registry.
   //

   if ( !load_registry_data() )
   {

     return( FALSE );

   }


   //
   // Load the User.Personality file data from disk into an
   // easy to access in-memory data structure.
   //

   if ( !load_user_personality_file() )
   {

      return( FALSE );

   }


   //
   // Load the Custom.Ads file data from disk into an
   // easy to access in-memory data structure.
   //

   if ( !load_custom_ads_file() )
   {

      return( FALSE );

   }


   //
   // Initialize the shared/exclusive mode locks used to guary
   // the in memory data structures containing data from the
   // User.Personality and Custom.Ads files.
   //

   init_lock( &g_user_personalities_buffer_lock );

   init_lock( &g_custom_ads_buffer_lock );


   //
   // Create a persistent thread that will ensure that the
   // data in the User.Personality and Custom.Ads in-memory
   // structures always reflects the most recent versions of
   // these files on disk.
   //

   if ( !( g_update_buffers_thread = CreateThread( NULL,
                                                   0,
                                                   update_user_and_ad_buffers,
                                                   NULL,
                                                   0,
                                                   NULL ) ) )
   {

      return( FALSE );

   }


   //
   // Initialize all stacks from which particular structures
   // (e.g. ISAPI_RESPONSE, CLASS1_DATA_BUFFER and CLASS2_DATA_BUFFER
   // structs) on the heap are to be allocated from.
   //

   initialize_isapi_response_stack();

   initialize_class1_data_buffer_stack();

   initialize_class2_data_buffer_stack();


   //
   // Populate the ISAPI version information structure to
   // be used by IIS.
   //

   pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, 
                                        HSE_VERSION_MAJOR );

   strcpy( pVer->lpszExtensionDesc, 
           "SPECweb99-CAD ISAPI Extension");


   //
   // If you have made it this far without returning indicating
   // failure, return indicating success.
   //

   return( TRUE );

}


/*********************************************************************/


DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Implementation of the HttpExtensionProc ISAPI entry point.
   Handles a SPECweb99 dynamic GET with custom ad rotation request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   Returns HSE_STATUS_ERROR if any failures occur in the routine.

   Otherwise, if either asynchronous VectorSend or ReadFile is
   used, HSE_STATUS_PENDING is returned.  Alternatively, if neither
   asynchronous VectorSend nor ReadFile is used, HSE_STATUS_SUCCESS
   is returned.

--*/
{

   CHAR server_name[ 32 ];

   CHAR server_port[ 32 ];

   DWORD server_name_size = 32;

   DWORD server_port_size = 32;

   DWORD server_name_length;

   DWORD server_port_length;

   DWORD app_pool_name_size = 1024; // 1024 == sizeof( g_app_pool_name )

   WIN32_FILE_ATTRIBUTE_DATA fileinfo;

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;

   CHAR filename[ MAX_PATH ];

   CHAR cookie_string[ MAX_COOKIE_STRING_LENGTH ];

   DWORD cookie_string_size = MAX_COOKIE_STRING_LENGTH;

   CHAR user_id_string[ 10 ];

   CHAR last_ad_string[ 10 ];

   DWORD ii;

   DWORD jj;

   INT64 user_index;

   DWORD last_ad;

   DWORD ad_index;

   BOOL return_value = HSE_STATUS_SUCCESS;

   DWORD combined_demographics;
   
   DWORD bytes_read;

   BOOL use_async_vector_send;

   HANDLE hFile;

   CHAR file_data_buffer[ FILE_DATA_BUFFER_SIZE ];

   DWORD query_string_length;


   //
   // Initialize the common "prefix" of the HTTP.SYS
   // fragment cache strings to be used.
   //

   if ( InterlockedExchange( &g_fragment_cache_key_base_not_initialized, 0 ) )
   {


      //
      // Obtain the server name.
      //

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_NAME",
                                     server_name,
                                     &server_name_size ) )
      {
         LOG_ERROR( "GetServerVariable(SERVER_NAME) failed", GetLastError() );

         return( HSE_STATUS_ERROR );

      }

      server_name_length = server_name_size - 1;


      //
      // Obtain the server port number used.
      //

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_PORT",
                                     server_port,
                                     &server_port_size ) )
      {
         LOG_ERROR( "GetServerVariable(SERVER_PORT) failed", GetLastError() );
         return( HSE_STATUS_ERROR );

      }

      server_port_length = server_port_size - 1;


      //
      // Obtain the name of the application pool used.
      //

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "APP_POOL_ID",
                                     g_app_pool_name,
                                     &app_pool_name_size ) )
      {
         LOG_ERROR( "GetServerVariable(APP_POOL_ID) failed", GetLastError() );
         return( HSE_STATUS_ERROR );

      }

      g_app_pool_name_length = app_pool_name_size - 1;


      //
      // Construct the base part of the fragment cache key in the
      // buffer g_fragment_cache_key_base; this will have the form
      // "<app_pool_name>/http://<server_name>:<port_number>".
      //
      // Rather than using unnecessary strcat calls, make use of
      // memcpy to do this.
      //


      //
      // Copy the application pool name to the beginning of the
      // key prefix.
      //

      strcpy( g_fragment_cache_key_base, g_app_pool_name );


      //
      // Concatenate the eight character string literal "/http://'
      // onto the key prefix, which has a length of g_app_pool_
      // name_length before the concatenation.
      //

      memcpy( g_fragment_cache_key_base + g_app_pool_name_length, "/http://", 8 );


      //
      // Concatenate the server name onto the key prefix, which has
      // a length of g_app_pool_name_length + 8 before the
      // concatenation.
      //

      ii = g_app_pool_name_length + 8;

      memcpy( g_fragment_cache_key_base + ii, server_name, server_name_length );


      //
      // Concatenate a ':' character, to separate the server name
      // and port number, onto the key prefix.  In the memcpy call
      // that does this, the variable 'ii' contains the length of
      // the key prefix before the concatenation.
      //

      ii += server_name_length;

      g_fragment_cache_key_base[ ii ] = ':';


      //
      // Concatenate the server port onto the key prefix.  In the
      // memcpy call that does this, the variable 'ii' contains
      // the length of the key prefix before the concatenation.
      //

      ii += 1;

      memcpy( g_fragment_cache_key_base + ii, server_port, server_port_length );

      ii += server_port_length;


      //
      // Terminate the key prefix string.
      //

      g_fragment_cache_key_base[ ii ] = '\0';


      //
      // Determine and cache in g_fragment_cache_key_base_length,
      // the length of the key prefix.
      //

      g_fragment_cache_key_base_length = strlen( g_fragment_cache_key_base );

   }


   //
   // Construct the absolute name of the file requested.
   // Take the following steps to do this.
   //


   //
   // First copy the webserver root directory path (e.g.
   // "D:/inetpub/wwwroot" to the start of the filename
   // buffer.
   //

   strcpy( filename, g_root_dir );


   //
   // Next concatenate the query string (e.g. "/file_set/
   // dir00001/class0_1") onto the filename string.  Here
   // we use memcpy as we need to store the length of the
   // query string for later use and want to avoid repeated
   // strlen operations.
   //

   query_string_length = strlen( pECB->lpszQueryString );

   memcpy( filename + g_root_dir_length, 
           pECB->lpszQueryString,
           query_string_length + 1 );


   //
   // Determine the size of the file requested.
   //

   if ( !GetFileAttributesEx( filename,
                              GetFileExInfoStandard,
                              &fileinfo ) )
   {

     return( send_error_page( pECB, 
                              "File inaccessible.",
                              g_pszStatus_404,
                              query_string_length ) );
     
   }


   //
   // Determine the I/O mode to use with VectorSend.
   //

   switch( g_vector_send_io_mode_config )
   {

      case USE_ASYNC_IO:
      {
   
         use_async_vector_send = TRUE;

         break;
  
      }

      case USE_SYNC_IO:
      {

         use_async_vector_send = FALSE;

         break;

      }

      case USE_ADAPTABLE_IO:
      {

         use_async_vector_send = ( fileinfo.nFileSizeLow >= g_vector_send_async_range_start );

         break;

      }

   };


   //
   // Set isapi_response_ptr to point to an ISAPI response 
   // structure on the heap if using asynchronous VectorSend.  
   // Also set the VectorSend completion callback and return
   // value.
   //

   if ( use_async_vector_send )
   {


      //
      // Try to allocate a free ISAPI_RESPONSE
      // structure on the heap.
      //

      if ( !( isapi_response_ptr = allocate_isapi_response() ) )
      {
         LOG_ERROR( "Allocation failed", 0 );

         return( HSE_STATUS_ERROR );

      }


      //
      // Set the completion callback routine to invoke after completion
      // of the asynchronous VectorSend operation.
      //

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_IO_COMPLETION,
                                         vector_send_completion_callback,
                                         NULL,
                                         ( DWORD * )isapi_response_ptr ) )
      {


         //
         // In the error case, free any ISAPI_RESPONSE
         // structure allocated.
         //
         LOG_ERROR( " REQ_IO_COMPLETION failed", GetLastError() );
         free_isapi_response( isapi_response_ptr );
         return( HSE_STATUS_ERROR );

      }


      //
      // Set the return value to use after the asynchronous
      // VectorSend is initiated to HSE_STATUS_PENDING.
      //

      return_value = HSE_STATUS_PENDING;

   }


   //
   // Parse the cookie string provided by the client.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "HTTP_COOKIE",
                                  cookie_string,
                                  &cookie_string_size ) )
   {


      LOG_ERROR( "GetServerVariable(HTTP_COOKIE) failed", GetLastError() );    
      //
      // If there was an error in retrieving the cookie string, free 
      // the ISAPI_RESPONSE structure allocated in the asynchronous
      // VectorSend case by placing it on the stack of free 
      // ISAPI_RESPONSE structures on the heap.
      //

      if ( use_async_vector_send )
      {

         free_isapi_response( isapi_response_ptr );

      }

      return( HSE_STATUS_ERROR );

   }
        

   //
   // The cookie string provided is of the form "my_cookie=user_id=<user_id>&
   // last_ad=<last_ad>".  Here we copy <user_id> and <last_ad> into 
   // user_id_string and last_ad_string.
   //
   // Note that the index at which <user_id> starts in the buffer 'cookie_string'
   // is 18 and the index at which <last_id> starts in the buffer 'cookie_string'
   // is 9 greater than index of the '&' character that terminates <user_id>.
   //

   for ( ii = 0, jj = 18; ( user_id_string[ ii ] = cookie_string[ jj ] ) != '&'; ii++, jj++ );

   user_id_string[ ii ] = '\0';

   for ( ii = 0, jj += 9; ( last_ad_string[ ii ] = cookie_string[ jj ] ); ii++, jj++ );


   //
   // Compute the cookie string and the ID of the ad to send back in
   // the ISAPI response.  Store the cookie string in 'cookie_string'
   // and the ad ID in 'ad_index'.
   //
   // Note that the user_index = user_id - 10000, as user_id numbers
   // start at 10000.
   //

   ad_index = determine_set_cookie_string( atoi( user_id_string ) - 10000, 
                                           atoi( last_ad_string ), 
                                           cookie_string );


   //
   // Initialize the ISAPI response using the cookie string computed.
   //

   if ( !initialize_isapi_response( isapi_response_ptr,
                                    pECB,
                                    filename,
                                    fileinfo.nFileSizeLow,
                                    cookie_string,
                                    use_async_vector_send,
                                    query_string_length ) )
   {

      LOG_ERROR("initialize_isapi_response failed", 0);
      //
      // In the error case, free any ISAPI_RESPONSE
      // structure allocated.
      //

      if ( use_async_vector_send )
      {

         free_isapi_response( isapi_response_ptr );

      }

      return( HSE_STATUS_ERROR );

   }


   //
   // Handle the special cases in which a class 1 or 2 file is requested.
   //


   //
   // If the class number of the file requested is either 1 or 2,
   // then the request must be handled differently (i.e. specific
   // substitutions have to be made in tags contained in the file
   // data).  In this case, simply return the value resulting from
   // the appropriate call to handle_class1_or_class2_request; this
   // routine handles these special cases.
   //
   // To determine the class number of the file, note that as the
   // query string contains the path of the filename relative to the
   // webserver document root directory (e.g. /file_set/dir00001/class0_1)
   // and class numbers are always one digit, the third last character
   // in the query string will always denote the class number (this
   // explains the use of "query_string_length - 3" below).
   // 

   isapi_response_ptr->class_number = pECB->lpszQueryString[ query_string_length - 3 ] - '0';

   if ( isapi_response_ptr->class_number == 1 )
   {

      return( handle_class1_or_class2_request( pECB,
                                               isapi_response_ptr,
                                               filename,
                                               fileinfo.nFileSizeLow,
                                               use_async_vector_send,
                                               ad_index,
                                               query_string_length ) );

   }
   else if ( isapi_response_ptr->class_number == 2 )
   {

      return( handle_class1_or_class2_request( pECB,
                                               isapi_response_ptr,
                                               filename,
                                               fileinfo.nFileSizeLow,
                                               use_async_vector_send,
                                               ad_index,
                                               query_string_length ) );

   } 


   //
   // Execute the VectorSend operation.  If ServerSupportFunction
   // returns TRUE, handle the cache hit case.  Otherwise, assume
   // a cache miss and handle it.
   //

   if ( pECB->ServerSupportFunction( pECB->ConnID,
                                     HSE_REQ_VECTOR_SEND,
                                     &( isapi_response_ptr->response_vector ),
                                     NULL,
                                     NULL ) )
   {

      return( return_value );

   }


   //
   // Now that a cache miss occurred, we will try to add the requested
   // file to the HTTP.SYS fragment cache using a handle to it and then
   // reattempt the VectorSend.  To do this, first obtain a handle to
   // the file using CreateFile.
   //

   if ( ( hFile = CreateFile( filename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {


      //
      // Again, in the error case free the ISAPI_RESPONSE struct
      // allocated, if any.
      //
     
      if ( use_async_vector_send )
      {

        free_isapi_response( isapi_response_ptr );

      }

      return( send_error_page( pECB, 
                               "File inaccessible.", 
                               g_pszStatus_404,
                               query_string_length ) );

   }


   //
   // Add the file to the HTTP.SYS fragment cache using the file
   // handle.
   //

   isapi_response_ptr->vector_element.ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;

   isapi_response_ptr->vector_element.pvContext = hFile;

   isapi_response_ptr->vector_element.cbSize = fileinfo.nFileSizeLow;

   isapi_response_ptr->vector_element.cbOffset = 0;

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_ADD_FRAGMENT_TO_CACHE,
                                      &isapi_response_ptr->vector_element,
                                      ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key,
                                      NULL ) )
   {


      //
      // If the add HSE_REQ_ADD_FRAGMENT_TO_CACHE operation failed,
      // (e.g. more than one thread attempted this at once), simply
      // try the VectorSend using the file handle.
      //

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;


      //
      // You need to store the file handle on the 
      // heap to be able to close it in the VectorSend
      // completion callback, if necessary.
      //

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {


         //
         // Clearly, you will not be going to the
         // VectorSend completion callback now.
         //
         LOG_ERROR( "VectorSend() failed", GetLastError() );
         CloseHandle( hFile );

         if ( use_async_vector_send )
         {

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

         }


         //
         // Again, in the failure case, free any ISAPI_RESPONSE
         // structure allocated.
         //

         if ( use_async_vector_send )
         {

            free_isapi_response( isapi_response_ptr );

         }

         return( HSE_STATUS_ERROR );

      }

      if ( !use_async_vector_send )
      {
         CloseHandle( hFile );
      }

      return( return_value );

   }


   //
   // Retry the VectorSend after successfully adding the requested
   // file to the HTTP.SYS fragment cache.
   //

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {


      //
      // If the VectorSend operation fails now (e.g. it was flushed
      // from the cache after it was added) simply try the VectorSend
      // using the file handle.
      //

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;


      //
      // You need to store the file handle on the 
      // heap to be able to close it in the VectorSend
      // completion callback, if necessary.
      //

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {


         //
         // Clearly, you will not be going to the
         // VectorSend completion callback now.
         //

         CloseHandle( hFile );

         if ( use_async_vector_send )
         {

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

         }


         //
         // Again, in the failure case, free the ISAPI_RESPONSE
         // structure allocated, if any.
         //

         if ( use_async_vector_send )
         {

           free_isapi_response( isapi_response_ptr );

         }

         return( HSE_STATUS_ERROR );

      }

   }

   if ( !use_async_vector_send )
   {
       CloseHandle( hFile );
   }

   return( return_value );

}


/*********************************************************************/


BOOL WINAPI TerminateExtension( DWORD dwFlags )
/*++

Routine Description:

   Implementation of the TerminateExtension ISAPI entry point.
   Carries out all cleanup tasks needed when SPECweb99-CAD.dll
   is unloaded.

Arguments:

   dwFlags - A DWORD that specifies whether IIS should shut down
             the extension.

Return Value:

   Returns TRUE if all cleanup tasks are successfully completed
   and FALSE otherwise.

--*/
{


   //
   // Destroy all entries in the stack of free
   // ISAPI_RESPONSE structures on the heap.
   //
 
   clear_isapi_response_stack();


   //
   // Destroy all entries in the stack of free
   // CLASS1_DATA_BUFFER structures on the heap.
   //

   clear_class1_data_buffer_stack();


   //
   // Destroy all elements in the stack of free
   // CLASS2_DATA_BUFFER structures on the heap.
   // 

   clear_class2_data_buffer_stack();


   //
   // Terminate the thread responsible for updating the in-memory
   // data structures holding the User.Personality and Custom.Ads
   // file data and close the handle to it. 
   //

   if ( !TerminateThread( g_update_buffers_thread, STILL_ACTIVE ) )
   {

      return( FALSE );

   }             

   CloseHandle( g_update_buffers_thread );


   //
   // Destroy the in-heap memory data structure holding
   // the data from the User.Personality file.
   //

   free( g_user_personalities_buffer );


   //
   // If you have made it this far without returning indicating
   // failure, return indicating success.
   //

   return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\post_and_cmd\httpextp.h ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

    iisextp.h

   Abstract:

    This module contains private HTTP server extension info

   Environment:

    Win32 User Mode

--*/

#ifndef _IISEXTP_H_
#define _IISEXTP_H_

#include "iisext.h"

//  available
//  #define   ??? (HSE_REQ_END_RESERVED+4)
//  no longer supported
#define   HSE_REQ_GET_CERT_INFO                    (HSE_REQ_END_RESERVED+9)
//  will be public in IIS 5.0
#define   HSE_REQ_EXECUTE_CHILD                    (HSE_REQ_END_RESERVED+13)
#define   HSE_REQ_GET_EXECUTE_FLAGS                (HSE_REQ_END_RESERVED+19)
// UNDONE: should be public after IIS 5.0 BETA 2
#define   HSE_REQ_GET_VIRTUAL_PATH_TOKEN           (HSE_REQ_END_RESERVED+21)
// This is the old vecotr send for ASP.Net's use
#define   HSE_REQ_VECTOR_SEND_DEPRECATED           (HSE_REQ_END_RESERVED+22)
#define   HSE_REQ_GET_CUSTOM_ERROR_PAGE            (HSE_REQ_END_RESERVED+29)
#define   HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN   (HSE_REQ_END_RESERVED+31)
#define   HSE_REQ_UNICODE_NORMALIZE_URL            (HSE_REQ_END_RESERVED+33)
#define   HSE_REQ_ADD_FRAGMENT_TO_CACHE            (HSE_REQ_END_RESERVED+34)
#define   HSE_REQ_READ_FRAGMENT_FROM_CACHE         (HSE_REQ_END_RESERVED+35)
#define   HSE_REQ_REMOVE_FRAGMENT_FROM_CACHE       (HSE_REQ_END_RESERVED+36)
#define   HSE_REQ_GET_METADATA_PROPERTY            (HSE_REQ_END_RESERVED+39)
#define   HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK  (HSE_REQ_END_RESERVED+40)
//  will be public in IIS 5.0

//
// Flags for HSE_REQ_EXECUTE_CHILD function
//

# define HSE_EXEC_NO_HEADERS              0x00000001   // Don't send any
                                                       // headers of child
# define HSE_EXEC_REDIRECT_ONLY           0x00000002   // Don't send any
                                                       // headers of child
                                                       // but send redirect
                                                       // message
# define HSE_EXEC_COMMAND                 0x00000004   // Treat as shell
                                                       // command instead of
                                                       // URL
# define HSE_EXEC_NO_ISA_WILDCARDS        0x00000010   // Ignore wildcards in
                                                       // ISAPI mapping when
                                                       // executing child
# define HSE_EXEC_CUSTOM_ERROR            0x00000020   // URL being sent is a
                                                       // custom error
//
// This is the deprecated structure for ASP.Net's use
//

//
// element of the vector
//

typedef struct _HSE_VECTOR_ELEMENT_DEPRECATED
{
    PVOID pBuffer;      // The buffer to be sent

    HANDLE hFile;       // The handle to read the data from
                        // Note: both pBuffer and hFile should not be non-null

    ULONGLONG cbOffset; // Offset from the start of hFile

    ULONGLONG cbSize;   // Number of bytes to send
} HSE_VECTOR_ELEMENT_DEPRECATED, *LPHSE_VECTOR_ELEMENT_DEPRECATED;

//
// The whole vector to be passed to the ServerSupportFunction
//

typedef struct _HSE_RESPONSE_VECTOR_DEPRECATED
{
    DWORD dwFlags;                          // combination of HSE_IO_* flags

    LPSTR pszStatus;                        // Status line to send like "200 OK"
    LPSTR pszHeaders;                       // Headers to send

    DWORD nElementCount;                    // Number of HSE_VECTOR_ELEMENT_DEPRECATED's
    LPHSE_VECTOR_ELEMENT_DEPRECATED lpElementArray;    // Pointer to those elements
} HSE_RESPONSE_VECTOR_DEPRECATED, *LPHSE_RESPONSE_VECTOR_DEPRECATED;

#define HSE_VECTOR_ELEMENT_TYPE_FRAGMENT            2
#include <winsock2.h>
typedef struct _HSE_SEND_ENTIRE_RESPONSE_INFO {

    //
    // HTTP header info
    //

    HSE_SEND_HEADER_EX_INFO HeaderInfo;

    //
    // Buffers which will be passed to WSASend
    //
    // NOTE: To send an entire response whose data (body)
    // is contained in N buffers, caller must allocate N+1 buffers
    // and fill buffers 1 through N with its data buffers.
    // IIS will fill the extra buffer (buffer 0) with header info.
    //

    WSABUF *    rgWsaBuf;   // array of wsa buffers
    DWORD       cWsaBuf;    // count of wsa buffers

    //
    // Returned by WSASend
    //

    DWORD       cbWritten;

} HSE_SEND_ENTIRE_RESPONSE_INFO, * LPHSE_SEND_ENTIRE_RESPONSE_INFO;

typedef struct _HSE_CUSTOM_ERROR_PAGE_INFO {

    //
    // The Error and SubError to look up
    //

    DWORD       dwError;
    DWORD       dwSubError;

    //
    // Buffer info
    //

    DWORD       dwBufferSize;
    CHAR *      pBuffer;

    //
    // On return, this contains the size of the buffer required
    //

    DWORD *     pdwBufferRequired;

    //
    // If TRUE on return, then buffer contains a file name
    //

    BOOL *      pfIsFileError;

    //
    // If FALSE on return, then the body of the custom error
    // should not be sent.
    //

    BOOL *      pfSendErrorBody;

} HSE_CUSTOM_ERROR_PAGE_INFO, * LPHSE_CUSTOM_ERROR_PAGE_INFO;

#endif // _IISEXTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\test\w3test.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3test.c

Abstract:

    This module tests the web server's server extension interface

Author:

    John Ludeman (johnl)   13-Oct-1994

Revision History:

    Tony Godfrey (tonygod) 15-Sep-1997 - fixed TerminateExtension

--*/

#include <windows.h>
//#include <httpext.h>
#include <iisext.h>

// Global variable used to track outstanding threads
DWORD g_dwThreadCount;

#define BUFFER_LENGTH 4096

// Debug macro
CHAR g_szDebug[256];
#define DEBUG(DebugString, Param)\
{\
    wsprintf( g_szDebug, DebugString, Param );\
    OutputDebugString( g_szDebug );\
}

// Prototypes
DWORD WINAPI SimulatePendIOThread( LPDWORD lpParams );
BOOL WINAPI DllMain( HANDLE hInst, ULONG Reason, LPVOID Reserved );

BOOL WINAPI DoAction(
    EXTENSION_CONTROL_BLOCK * pecb,
    char * pszAction,
    BOOL * pfKeepConn
    );

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK * pecb )
{
    BOOL fKeepConn = FALSE;
    DWORD dwThreadId;
    HANDLE hThread;

    if ( !_strnicmp( pecb->lpszQueryString,
                    "SimulatePendingIO",
                    17))
    {
        InterlockedIncrement( &g_dwThreadCount );
        hThread = CreateThread( 
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) SimulatePendIOThread,
            pecb,
            0,
            &dwThreadId 
            );
        if ( hThread == NULL ) {
            InterlockedDecrement( &g_dwThreadCount );
        } else {
            CloseHandle( hThread );
        }

        return HSE_STATUS_PENDING;
    }
    else
    {
        if ( !DoAction( pecb,
                        pecb->lpszQueryString,
                        &fKeepConn ))
        {
            return HSE_STATUS_ERROR;
        }
    }

    return fKeepConn ? HSE_STATUS_SUCCESS_AND_KEEP_CONN :
                       HSE_STATUS_SUCCESS;
}

BOOL WINAPI DoAction(
    EXTENSION_CONTROL_BLOCK * pecb,
    char * pszAction,
    BOOL * pfKeepConn
    )
{
    char *buff;
    int  ret;
    int  i;
    int  cb;

    buff = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, BUFFER_LENGTH + 1 );
    if ( buff == NULL ) {
        return FALSE;
    }
    //
    // Log the request here
    //

    strcpy( pecb->lpszLogData, ", ISAPI Data->" );
    strcat( pecb->lpszLogData, pszAction );

    if ( !_stricmp( pszAction,
                  "HSE_REQ_SEND_URL_REDIRECT_RESP" ))
    {
        //
        //  pecb->pszPathInfo is the URL to redirect to
        //

        HeapFree( GetProcessHeap(), 0, buff );
        return pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_URL_REDIRECT_RESP,
                                  pecb->lpszPathInfo,
                                  NULL,
                                  NULL );
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_SEND_URL" ))
    {
        //
        //  pecbb->lpszPathInfo is the URL to send
        //

        HeapFree( GetProcessHeap(), 0, buff );
        return pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_URL,
                                  pecb->lpszPathInfo,
                                  0,
                                  0 );
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_SEND_RESPONSE_HEADER" ))
    {
        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>Response header test</title></head>\n"
                  "<body><h1>HTTP status code supplied in the path info was \"%s\"</h1></body>\n",
                  pecb->lpszPathInfo );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  pecb->lpszPathInfo,     // HTTP status code
                                  NULL,
                                  (LPDWORD) buff );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        cb = wsprintf( buff,
                       "Content-Type: text/html\r\n"
                       "\r\n"
                       "<head><title>Response header test</title></head>\n"
                       "<body><h1>Specified status code was %s</h1></body>\n",
                       pecb->lpszPathInfo );

        ret = pecb->WriteClient( pecb->ConnID,
                                 buff,
                                 &cb,
                                 0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_strnicmp( pszAction,
                          "GET_VAR",
                          7 ))
    {
        CHAR * pch;

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) "Content-Type: text/html\r\n"
                                            "\r\n" );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        cb = BUFFER_LENGTH;

        if ( !(pch = strchr( pszAction, '&' )) )
        {
            pch = "ALL_HTTP";
        }
        else
        {
            pch++;
        }

        ret = pecb->GetServerVariable( pecb->ConnID,
                                       pch,
                                       buff,
                                       &cb );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        strcat( buff, "\r\n" );

        cb = strlen( buff );

        ret = pecb->WriteClient( pecb->ConnID,
                                 buff,
                                 &cb,
                                 0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_MAP_URL_TO_PATH" ))
    {
        char Path[MAX_PATH + 1];
        DWORD cbPath = sizeof( Path );

        strcpy( Path, pecb->lpszPathInfo );

        ret = pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_MAP_URL_TO_PATH,
                                           Path,
                                           &cbPath,
                                           NULL );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>URL map test</title></head>\n"
                  "<body><h1>URL \"%s\" maps to \"%s\""
                  "cbPath is %d</h1></body>\n",
                  pecb->lpszPathInfo,
                  Path,
                  cbPath );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_MAP_URL_TO_PATH_EX" ))
    {
        HSE_URL_MAPEX_INFO  mapinfo;

        ret = pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_MAP_URL_TO_PATH_EX,
                                           pecb->lpszPathInfo,
                                           NULL,
                                           (DWORD *) &mapinfo );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>URL map_ex test</title></head>\n"
                  "<body><h1>URL \"%s\" maps to \"%s\""
                  "dwFlags = 0x%08x\n"
                  "cchMatchingPath = %d\n"
                  "cchMatchingURL  = %d\n</h1></body>",
                  pecb->lpszPathInfo,
                  mapinfo.lpszPath,
                  mapinfo.dwFlags,
                  mapinfo.cchMatchingPath,
                  mapinfo.cchMatchingURL );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "Keep_Alive" ))
    {
        DWORD cbBuff = BUFFER_LENGTH;
        DWORD cbDoc;
        CHAR  achDoc[4096];
        BOOL  fKeepAlive = FALSE;

        if ( !pecb->GetServerVariable( pecb->ConnID,
                                       "HTTP_CONNECTION",
                                       buff,
                                       &cbBuff ))
        {
            *buff = '\0';
        }

        cbDoc = wsprintf( achDoc,
                          "<head><title>Keep alive test</title></head>\n"
                          "This document is being kept alive."
                        );

        //
        //  This assumes keep-alive comes first in the list
        //

        if ( !_strnicmp( buff, "keep-alive", 10 ))
        {
            fKeepAlive = TRUE;
            wsprintf( buff,
                      "Content-type: text/html\r\n"
                      "Connection: keep-alive\r\n"
                      "Content-Length: %d\r\n"
                      "\r\n",
                      cbDoc );
        }
        else
        {
            wsprintf( buff,
                      "Content-type: text/html\r\n"
                      "\r\n"
                      "<head><title>Keep alive test</title></head>\n"
                      "Client did not specify keep alive!"
                      );
        }

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff ) &&
              pecb->WriteClient( pecb->ConnID,
                                 achDoc,
                                 &cbDoc,
                                 0 );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        if ( fKeepAlive ) {
            *pfKeepConn = TRUE;
        }

        HeapFree( GetProcessHeap(), 0, buff );
        return TRUE;
    }
    else if ( !strncmp( pszAction,
                        "Open_Reg",
                        7 ))
    {
        CHAR * pch;
        DWORD  err;
        HKEY   hKey;
        HKEY   hSubKey;
        HANDLE hFile;

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) "Content-Type: text/html\r\n"
                                            "\r\n" );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        //
        //  The path info begins with the portion of the registry to open
        //

        if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_CLASSES_ROOT",
                        17 ))
        {
            pch = pecb->lpszPathInfo + 19;
            hKey = HKEY_CLASSES_ROOT;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_CURRENT_USER",
                        17 ))
        {
            pch = pecb->lpszPathInfo + 19;
            hKey = HKEY_CURRENT_USER;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                             "HKEY_LOCAL_MACHINE",
                             18 ))
        {
            pch = pecb->lpszPathInfo + 20;
            hKey = HKEY_LOCAL_MACHINE;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_USERS",
                        10 ))
        {
            pch = pecb->lpszPathInfo + 12;
            hKey = HKEY_USERS;
        }

        err = RegOpenKey( hKey,
                          pch,
                          &hSubKey );

        if ( err )
        {
            cb = wsprintf( buff,
                           "Failed to open registry key %s, error %d\n",
                           pecb->lpszPathInfo,
                           err );
        }
        else
        {
            cb = wsprintf( buff,
                           "Successfully opened registry key %s\n",
                           pecb->lpszPathInfo );

            RegCloseKey( hSubKey );
        }

        pecb->WriteClient( pecb->ConnID,
                           buff,
                           &cb,
                           0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return TRUE;
    }

    else if ( !_stricmp( pszAction,
                       "Open_File" ))
    {
        CHAR  *pch;
        DWORD  err;
        HKEY   hKey;
        HKEY   hSubKey;
        HANDLE hFile;
        DWORD dwBytesRead;
        DWORD dwFileSize = 0;
        DWORD dwError;

        //
        //  The path translated is the filename to open
        //

        hFile = CreateFile(
            pecb->lpszPathTranslated,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            dwError = GetLastError();
            wsprintf(
                buff,
                "Content-Type: text/html\r\n\r\n"
                );
            ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
            if ( !ret ) {
                HeapFree( GetProcessHeap(), 0, buff );
                return FALSE;
            }
            cb = wsprintf(
                buff,
                "<head><title>Unable to open file</title></head>\r\n"
                "<body><h1>Unable to open file</h1>\r\n"
                "CreateFile failed: %ld\r\n<p>"
                "Filename: %s<p></body>",
                dwError,
                pecb->lpszPathTranslated
                );
            pecb->WriteClient(
                pecb->ConnID,
                buff,
                &cb,
                0
                );
                
            HeapFree( GetProcessHeap(), 0, buff );
            return TRUE;
        }
        dwFileSize = GetFileSize( hFile, NULL );
        pch = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize + 1 );
        ret = ReadFile(
            hFile,
            pch,
            dwFileSize,
            &dwBytesRead,
            NULL
            );
        if ( !ret ) {
            dwError = GetLastError();
        }
        pch[dwBytesRead] = 0;
        CloseHandle( hFile );
        if ( !ret ) {
            wsprintf(
                buff,
                "Content-Type: text/html\r\n\r\n"
                );
            ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
            if ( !ret ) {
                HeapFree( GetProcessHeap(), 0, buff );
                return FALSE;
            }
            cb = wsprintf(
                buff,
                "<head><title>Unable to Read File</title></head>\r\n"
                "<body><h1>Unable to Read File</h1>\r\n"
                "ReadFile failed: %ld<p>\r\n"
                "Filename: %s</body>",
                dwError,
                pecb->lpszPathTranslated
                );
            pecb->WriteClient(
                pecb->ConnID,
                buff,
                &cb,
                0
                );
                
            HeapFree( GetProcessHeap(), 0, buff );
            return TRUE;
        }

        wsprintf(
            buff,
            "Content-Type: text/html\r\n\r\n"
            );
        ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        pecb->WriteClient(
            pecb->ConnID,
            pch,
            &dwBytesRead,
            0
            );

        HeapFree( GetProcessHeap(), 0, buff );
        HeapFree( GetProcessHeap(), 0, pch );

        return TRUE;
    }
        
    else if ( !_stricmp( pszAction,
                       "SimulateFault" ))
    {
        *((CHAR *)0xffffffff) = 'a';
        HeapFree( GetProcessHeap(), 0, buff );
        return FALSE;
    }

    wsprintf( buff,
              "Content-Type: text/html\r\n\r\n"
              "<head><title>Unknown Test command</title></head>\n"
              "<body><h1>Unknown Test Command</h1>\n"
              "<p>Usage:"
              "<p>Query string contains one of the following:"
              "<p>"
              "<p> HSE_REQ_SEND_URL_REDIRECT_RESP"
              "<p> HSE_REQ_SEND_URL"
              "<p> HSE_REQ_SEND_RESPONSE_HEADER"
              "<p> HSE_REQ_MAP_URL_TO_PATH"
              "<p> GET_VAR&var_to_get"
              "<p> SimulateFault"
              "<p> Keep_Alive"
              "<p> Open_Reg"
              "<p> Open_File"
              "<p>"
              "<p> For example:"
              "<p>"
              "<p>   http://computer/scripts/w3test.dll?CGI_VAR"
              "<p>"
              "<p> or SimulatePendingIO with one of the above action strings"
              "<p>"
              "<p> such as:"
              "<p>"
              "<p> http://computer/scripts/w3test.dll?SimulatePendingIO&HSE_REQ_SEND_URL"
              "<p>"
              "<p> The Path info generally contains the URL or response to use"
              "</body>\n");

    ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );

    cb = wsprintf( buff,
                   "<p>cbTotalBytes = %d<p> cbAvailable = %d<p>"
                   "lpszContentType = %s<p> lpszPathInfo = %s<p>"
                   "lpszPathTranslated = %s",
                   pecb->cbTotalBytes,
                   pecb->cbAvailable,
                   pecb->lpszContentType,
                   pecb->lpszPathInfo,
                   pecb->lpszPathTranslated );

    pecb->WriteClient( pecb->ConnID,
                       buff,
                       &cb,
                       0 );

    cb = pecb->cbAvailable;

    pecb->WriteClient( pecb->ConnID,
                       pecb->lpbData,
                       &cb,
                       0 );


    while ( pecb->cbAvailable < pecb->cbTotalBytes )
    {
        cb = min( pecb->cbTotalBytes - pecb->cbAvailable, BUFFER_LENGTH );

        if ( !pecb->ReadClient( pecb->ConnID,
                                buff,
                                &cb ) ||
             !cb )
        {
            break;
        }

        pecb->cbAvailable += cb;

        pecb->WriteClient( pecb->ConnID,
                           buff,
                           &cb,
                           0 );

    }

    HeapFree( GetProcessHeap(), 0, buff );
    return TRUE;
}

DWORD WINAPI SimulatePendIOThread( LPDWORD lpParams )
{
    EXTENSION_CONTROL_BLOCK * pecb = (EXTENSION_CONTROL_BLOCK *) lpParams;
    char *psz;
    DWORD dwStatus;
    BOOL fKeepConn = FALSE;

    Sleep( 5000 );

    psz = strchr( pecb->lpszQueryString, '&' );

    if ( psz )
        psz++;
    else
        psz = "No action string specified";

    DoAction( pecb,
              psz,
              &fKeepConn );

    dwStatus = fKeepConn ? HSE_STATUS_SUCCESS_AND_KEEP_CONN :
               HSE_STATUS_SUCCESS;

    pecb->ServerSupportFunction( pecb,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 &dwStatus,
                                 0,
                                 0 );
    InterlockedDecrement( &g_dwThreadCount );
    return 0;
}


BOOL GetExtensionVersion( HSE_VERSION_INFO * pver )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strcpy( pver->lpszExtensionDesc, "Extension test example" );

    return TRUE;
}

BOOL TerminateExtension( DWORD dwFlags )
{
    DEBUG( "[W3Test.TerminateExtension] Extension terminating!\r\n", 0 );
    while ( g_dwThreadCount > 0 ) {
        DEBUG( "[W3Test.TerminateExtension] Thread Count: %ld\r\n", g_dwThreadCount );
        SleepEx( 1000, FALSE );
    }
    SleepEx( 1000, FALSE );
    return TRUE;
}


BOOL WINAPI DllMain( HANDLE hInst, ULONG Reason, LPVOID Reserved )
{
    switch( Reason ) {

       case DLL_PROCESS_ATTACH:
           g_dwThreadCount = 0;
           break;

       case DLL_PROCESS_DETACH:
           break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\post_and_cmd\specweb99-post_and_cmd.cxx ===
/*********************************************************************
 *                                                                   *
 * File: specweb99-POST_AND_CMD.cxx                                  *
 * ----                                                              *
 *                                                                   *
 *                                                                   *
 * Overview:                                                         *
 * --------                                                          *
 *                                                                   *
 * Implementation of the dynamic POST operation and Fetch and Reset  *
 * housekeeping functions used in the SPECweb99 benchmark.           *
 *                                                                   *
 *                                                                   *
 * Revision History:                                                 *
 * ----------------                                                  *
 *                                                                   *
 * Date         Author                  Reason                       *
 * ----         ------                  ------                       *
 *                                                                   *
 * 07/23/02     Ankur Upadhyaya         Initial Creation.            *
 *                                                                   *
 *********************************************************************/


/*********************************************************************/


//
// Includes.
//


#include <windows.h>

#include <malloc.h>

#include <stdlib.h>

#include <stdio.h>

#include <string.h>

#include <time.h>

#include <math.h>

#include "httpextp.h"


/*********************************************************************/


//
// Defines.
//


#define USE_SYNC_IO 1

#define USE_ASYNC_IO 2

#define USE_ADAPTABLE_IO 3

#define MAX_FRAGMENT_CACHE_KEY_LENGTH 1024

#define MAX_APP_POOL_NAME_LENGTH 1024

#define MAX_RECORDS_IN_POSTLOG_BUFFER 6000000

#define POST_DATA_BUFFER_SIZE 1024

#define MAX_COOKIE_STRING_LENGTH 128

#define MAX_QUERY_STRING_LENGTH 128

#define MAX_RESET_ARG_LENGTH 512

#define POSTLOG_RECORD_SIZE 139

#define NUM_RECORDS_PER_BURST 117

#define MAX_POST_REQUEST_DATA  256


/*********************************************************************/


//
// Type definitions.
//


typedef struct isapi_response
{

   SINGLE_LIST_ENTRY item_entry;

   HSE_RESPONSE_VECTOR response_vector;

   HSE_VECTOR_ELEMENT vector_element_array[ 7 ];

   CHAR remote_addr[ 16 ];

   CHAR pszHeaders[ 195 ];

   CHAR set_cookie_string[ MAX_COOKIE_STRING_LENGTH ];

   CHAR  achRequestData[ MAX_POST_REQUEST_DATA ];
   DWORD cbRequestData;

   WCHAR unicode_fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

   HANDLE hFile;
   HSE_VECTOR_ELEMENT vector_element;

  

} ISAPI_RESPONSE;


typedef struct postlog_record
{

   DWORD record_number;

   DWORD time_stamp;

   DWORD thread_id;

   CHAR dir_num[ 6 ];

   CHAR class_num;

   CHAR file_num;

   CHAR client_num[ 6 ];

   CHAR filename[ 60 ];

   CHAR my_cookie[ 10 ];

} POSTLOG_RECORD;


/*********************************************************************/


//
// Global Variables.
//


DWORD g_vector_send_io_mode_config = USE_SYNC_IO;

DWORD g_vector_send_async_range_start = 0;

static char g_element_0[] =               "<html>\n"
                                          "<head><title>SPECweb99 Dynamic GET & POST Test</title></head>\n"
                                          "<body>\n"
                                          "<p>SERVER_SOFTWARE = Microsoft-IIS/6.0\n"
                                          "<p>REMOTE_ADDR = ";
HSE_VECTOR_ELEMENT g_vector_element_0 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          g_element_0,
                                          0,
                                          sizeof(g_element_0) - 1 };

static char g_element_2[] =               "\n<p>SCRIPT_NAME = /specweb99-CMD_AND_POST.dll\n"
                                          "<p>QUERY_STRING = ";
HSE_VECTOR_ELEMENT g_vector_element_2 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          g_element_2,
                                          0, 
                                          sizeof(g_element_2) - 1 };

static char g_element_4[] =               "\n<pre>\n";
HSE_VECTOR_ELEMENT g_vector_element_4 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          g_element_4,
                                          0, 
                                          sizeof(g_element_4) - 1 };

static char g_element_6[] =               "</pre>\n"
                                          "</body>\n</html>\n";
HSE_VECTOR_ELEMENT g_vector_element_6 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER, 
                                          g_element_6,
                                          0,
                                          sizeof(g_element_6) - 1 };

CHAR *g_pszStatus200 = "200 OK";

CHAR *g_pszStatus400 = "400 Bad Request";

CHAR *g_pszStatus404 = "404 File Inaccessible";

CHAR *g_pszStatus500 = "500 Internal Server Error";

SLIST_HEADER g_isapi_response_stack;

POSTLOG_RECORD *g_postlog_buffer = NULL;

volatile LONG g_postlog_record_count = 0;

CHAR g_postlog_filename[ MAX_PATH ];

CHAR g_fragment_cache_key_base[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

DWORD g_fragment_cache_key_base_length;

volatile LONG g_fragment_cache_key_base_not_initialized = 1;

CHAR g_root_dir[ MAX_PATH ];

CHAR g_app_pool_name[ MAX_APP_POOL_NAME_LENGTH ];

DWORD g_root_dir_length;

DWORD g_app_pool_name_length;


/*********************************************************************/


//
// Function prototypes.
//


VOID initialize_isapi_response_stack( VOID );

ISAPI_RESPONSE *allocate_isapi_response( VOID );

VOID free_isapi_response( ISAPI_RESPONSE *isapi_response_ptr );

VOID clear_isapi_response_stack( VOID );

BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr,
                                EXTENSION_CONTROL_BLOCK *pECB,
                                CHAR *filename,
                                DWORD filesize,
                                CHAR *set_cookie_string,
                                BOOL use_async_vector_send );

DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB, 
                       CHAR *error_message,
                       CHAR *status );

VOID dword_to_string( DWORD dword, CHAR *string );

VOID WINAPI vector_send_completion_callback( EXTENSION_CONTROL_BLOCK *pECB,
                                             VOID *pvContext,
                                             DWORD cbIO,
                                             DWORD dwError );

BOOL parse_post_data( PBYTE pbRequestData,
                      DWORD cbRequestData,
                      CHAR **urlroot,
                      CHAR **dir_num,
                      CHAR **class_num,
                      CHAR **file_num,
                      CHAR **client_num );

DWORD handle_post( EXTENSION_CONTROL_BLOCK *pECB );

DWORD handle_reset( EXTENSION_CONTROL_BLOCK *pECB );

DWORD handle_fetch( EXTENSION_CONTROL_BLOCK *pECB );

BOOL load_registry_data( VOID );

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer );

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB );

BOOL WINAPI TerminateExtension( DWORD dwFlags );

#define LOG_ERROR( text, error )  _LogError(__FUNCTION__, __FILE__, __LINE__, text, error )

void _LogError(const char * function, const char *file, int line, char * text, DWORD error)
{
    char buf[1024];
    sprintf(buf, "%s(%d) %s - error=0x%x (%d) - %s\n", file, line, function, error, error, text );
    OutputDebugStringA(buf);	
}


/*********************************************************************/


VOID initialize_isapi_response_stack( VOID )
/*++

Routine Description:

   Initializes the stack of free ISAPI_RESPONSE structures on
   the heap.

Arguments:

   None. 

Return Value:

   None.

--*/
{


  //
  // Initialize the SLIST_HEADER structure that will be used to
  // implement the stack of free ISAPI_RESPONSE structures on the
  // heap.
  //

  InitializeSListHead( &g_isapi_response_stack );

}


/*********************************************************************/


ISAPI_RESPONSE *allocate_isapi_response( VOID )
/*++

Routine Description:

   Pop an element off of the stack of free ISAPI_RESPONSE structures
   on the heap.

Arguments:

   None.

Return Value:

   Returns a pointer to a free ISAPI_RESPONSE structure on the heap.

--*/
{

   ISAPI_RESPONSE *isapi_response_ptr;

 
   //
   // Attempt to pop a free ISAPI_RESPONSE
   // structure off of g_isapi_response_stack.
   //

   if ( !( isapi_response_ptr =
           ( ISAPI_RESPONSE * )InterlockedPopEntrySList( &g_isapi_response_stack ) ) )
   {


     //
     // If g_isapi_response_stack was empty
     // allocate a new ISAPI_RESPONSE structure
     // off of the heap.
     //

     isapi_response_ptr = ( ISAPI_RESPONSE * )malloc( sizeof( ISAPI_RESPONSE ) );

   }


   //
   // Return a pointer to the ISAPI_RESPONSE
   // structure allocated.
   //

   return( isapi_response_ptr );

}


/*********************************************************************/


VOID free_isapi_response( ISAPI_RESPONSE *isapi_response_ptr )
/*++

Routine Description:

   Pushes an element onto the stack of free ISAPI_RESPONSE structures
   on the heap.

Arguments:

   isapi_response_ptr - A pointer to a free ISAPI_RESPONSE structure
                        on the heap.

Return Value:

   None.

--*/
{


  //
  // Pop the input pointer to a free ISAPI_RESPONSE
  // structure on the heap onto g_isapi_response_stack.
  //

  InterlockedPushEntrySList( &g_isapi_response_stack,
                             ( SINGLE_LIST_ENTRY * )isapi_response_ptr );

}


/*********************************************************************/


VOID clear_isapi_response_stack( VOID )
/*++

Routine Description:

   Destroys the stack of free ISAPI_RESPONSE structures on the heap,
   freeing all system resources allocated for this data structure.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Flush g_isapi_response_stack of all of
   // its elements and set 'curr_struct_ptr'
   // to point to a linked list containing
   // all of these elements.
   //

   SINGLE_LIST_ENTRY *current_struct = InterlockedFlushSList( &g_isapi_response_stack );

   SINGLE_LIST_ENTRY *struct_to_kill;


   //
   // Destroy all elements in the linked
   // list initially pointed to by
   // 'curr_struct_ptr'.
   //

   while( current_struct )
   {

      struct_to_kill = current_struct;

      current_struct = current_struct->Next;

      free( ( ISAPI_RESPONSE * )struct_to_kill );

   }

}


/*********************************************************************/


BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr,
                                EXTENSION_CONTROL_BLOCK *pECB,
                                CHAR *filename,
                                DWORD filesize,
                                CHAR *set_cookie_string,
                                BOOL use_async_vector_send )
/*++

Routine Description:

   Initialize an ISAPI response struct by populating it with the
   appropriate data.

Arguments:

   isapi_response_ptr - Pointer to the ISAPI response struct to be
                        initialized.

   pECB - Pointer to the relevant extension control block.

   filename - Optional field indicating the absolute name of the file 
              requested.

   filesize - Optional field indicating the size of the file requested.

   set_cookie_string - String to use for Set-Cookie HTTP header field.

   use_async_vector_send - Flag indicating whether VectorSend is to be
                           used in asynchronous or synchronous mode.

Return Value:

   None.

--*/
{

   DWORD remote_addr_size = sizeof( isapi_response_ptr->remote_addr );

   CHAR fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

   DWORD ii;

   DWORD set_cookie_string_length;

   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length;

   CHAR *buffer;


   //
   // Set the fragment cache key.
   //

   memcpy( fragment_cache_key, g_fragment_cache_key_base, g_fragment_cache_key_base_length );

   memcpy( fragment_cache_key + g_fragment_cache_key_base_length, filename, strlen( filename ) + 1 );

   for ( ii = 0;
         isapi_response_ptr->unicode_fragment_cache_key[ ii ] = ( WCHAR )fragment_cache_key[ ii ];
         ii++ );


   //
   // Obtain the IP address of the client.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "REMOTE_ADDR",
                                  isapi_response_ptr->remote_addr,
                                  &remote_addr_size ) )
   {

      return( FALSE );

   }

   if ( pECB->cbAvailable ==0 )
   {
        LOG_ERROR( "Empty POST data", 0 );
        return( send_error_page( pECB, "Empty POST data.", g_pszStatus400 ) );
   }

   if ( pECB->cbAvailable >= sizeof( isapi_response_ptr->achRequestData ) )
   {
        LOG_ERROR( "Too big POST data", 0 );
        return( send_error_page( pECB, "Too big POST data.", g_pszStatus400 ) );
   }

   memcpy( isapi_response_ptr->achRequestData, pECB->lpbData, pECB->cbAvailable );
   isapi_response_ptr->cbRequestData = pECB->cbAvailable;


   //
   // Obtain the cookie string.
   //

   set_cookie_string_length = strlen( set_cookie_string );

   strncpy( isapi_response_ptr->set_cookie_string, set_cookie_string, MAX_COOKIE_STRING_LENGTH );


   //
   // Populate the vector_element_array data structure.
   //

   isapi_response_ptr->vector_element_array[ 0 ] = g_vector_element_0;


   isapi_response_ptr->vector_element_array[ 1 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   isapi_response_ptr->vector_element_array[ 1 ].pvContext = isapi_response_ptr->remote_addr;
   isapi_response_ptr->vector_element_array[ 1 ].cbSize = remote_addr_size - 1;


   isapi_response_ptr->vector_element_array[ 2 ] = g_vector_element_2;

   isapi_response_ptr->vector_element_array[ 3 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   isapi_response_ptr->vector_element_array[ 3 ].pvContext = isapi_response_ptr->achRequestData;
   isapi_response_ptr->vector_element_array[ 3 ].cbSize = isapi_response_ptr->cbRequestData;

   isapi_response_ptr->vector_element_array[ 4 ] = g_vector_element_4;


   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_FRAGMENT;
   isapi_response_ptr->vector_element_array[ 5 ].pvContext = ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key;


   isapi_response_ptr->vector_element_array[ 6 ] = g_vector_element_6;


   //
   // Populate the HSE_RESPONSE_VECTOR structure.
   // To do this, use the following steps...
   //


   //
   // First, compute the string of HTTP headers to be sent with the
   // response.  To avoid a costly sprintf call, we will use memcpy
   // instead.
   //


   //
   // Copy the initial "heardcoded" component of the HTTP header string.
   //

   static CHAR s_szInitialHeaders[] = "Content-Type: text/html\r\n"
                                      "Content-Length: ";

   strcpy( isapi_response_ptr->pszHeaders, 
           s_szInitialHeaders
           );


   //
   // Construct a string representing the value of the HTTP Content-Length
   // header field.  Determine and stor the length of this string.  Note
   // that 16 is the size of the buffer to which the content_length_string
   // is written.
   //

   dword_to_string( ( DWORD )( filesize +
                               isapi_response_ptr->vector_element_array[ 0 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 1 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 2 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 3 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 4 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 6 ].cbSize),
                               content_length_string );
   

   //
   // Concatenate the content length string to the header
   // string.  
   //

   memcpy( isapi_response_ptr->pszHeaders + sizeof( s_szInitialHeaders ) - 1, 
           content_length_string, 
           content_length_string_length = strlen( content_length_string ) );


   //
   // Concatenate the 14 character hardcoded string "\r\nSet-Cookie: "
   // to the header string.  Note that just prior to this operation
   // the lnegth of the header string is given by the variable 'ii'.
   //

   ii = sizeof( s_szInitialHeaders ) - 1 + content_length_string_length;

   static CHAR s_szCookieHeader[] = "\r\nSet-Cookie: my_cookie=";
   memcpy( isapi_response_ptr->pszHeaders + ii, 
           s_szCookieHeader, 
           sizeof( s_szCookieHeader ) - 1 );

   //
   // Concatenate the Set-Cookie string to the header string.  Note
   // that just prior to this operation the length of the header
   // string is given by the variable 'ii'.
   //

   ii += sizeof( s_szCookieHeader ) - 1;

   memcpy( isapi_response_ptr->pszHeaders + ii, 
           isapi_response_ptr->set_cookie_string, 
           set_cookie_string_length );


   //
   // Concatenate the 5 character hardcoded string "\r\n\r\n\0"
   // to the header string, indicating its termination.
   //

   ii += set_cookie_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii, "\r\n\r\n\0", 5 );


   //
   // Set the 'pszHeaders' field of the HSE_RESPONSE_VECTOR structure
   // to point to the HTTP header string just computed.
   //

   isapi_response_ptr->response_vector.pszHeaders = isapi_response_ptr->pszHeaders;


   //
   // Set the 'lpElementArray' field of the HSE_RESPONSE_VECTOR structure
   // to point to the array of HSE_VECTOR_ELEMENT structures populated
   // above.
   //

   isapi_response_ptr->response_vector.lpElementArray = isapi_response_ptr->vector_element_array;


   //
   // Indicate that the HSE_RESPONSE_VECTOR structure
   // has five entries.
   //

   isapi_response_ptr->response_vector.nElementCount = 
                    sizeof(isapi_response_ptr->vector_element_array) /
                    sizeof(isapi_response_ptr->vector_element_array[0]);


   //
   // Set the HTTP status to "200 OK".
   //

   isapi_response_ptr->response_vector.pszStatus = g_pszStatus200;


   //
   // Set the 'dwFlags' field of the HSE_RESPONSE_VECTOR structure
   // based on whether or not asynchronous VectorSend is to be
   // used.
   //

   if ( use_async_vector_send )
   {

     isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                   HSE_IO_SEND_HEADERS |
                                                   HSE_IO_ASYNC;

   }
   else
   {

     isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                   HSE_IO_SEND_HEADERS |
                                                   HSE_IO_SYNC;

   }


   //
   // Set the following additional fields is the ISAPI
   // response if to be sent to the client using
   // asynchronous VectorSend.
   //

   if ( use_async_vector_send )
   {


      //
      // By setting an 'hFile' HANDLE field we can check, in the
      // VectorSend completion callback routine, whether the
      // asynchronous VectorSend operation just completed made
      // use of a file handle.  If so, we must close the handle
      // in this callback.
      //  

      isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   }


   //
   // If you have not yet returned indicating failure, return
   // indicating success.
   //

   return( TRUE );
   
}


/*********************************************************************/


DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB, 
                       CHAR *error_message,
                       CHAR *status )
/*++
    
Routine Description:

   Sends an HTML error page with a message and status specified by the
   caller.

Arguments:

   pECB - Pointer to the relevant extension control block.

   error_msg - Error message to send.

   status - Status to send (e.g. "200 OK").

Return Value:

   Returns HSE_STATUS_SUCCESS if the error page was successfully
   written to the client and HSE_STATUS_ERROR otherwise.

--*/
{

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;

   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length;

   DWORD ii;


   //
   // Initialize the ISAPI response struct to be associated with
   // the error page.
   //

   if ( !initialize_isapi_response( isapi_response_ptr,
                                    pECB,
                                    "",
                                    0,
                                    "",
                                    FALSE ) )
   {
     LOG_ERROR("initialize_isapi_response failed", 0);

     return( HSE_STATUS_ERROR );

   }


   //
   // Change the response_vector and vector_element array in the
   // ISAPI response structure to specify an error message (to be
   // transmitted using synchronous I/O).  To do this, use the
   // following steps...
   //


   //
   // Change the response_vector and vector_element_array in the
   // ISAPI response struct to specify and error message (to be
   // transmitted using synchronous I/O).
   //

   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 5 ].pvContext = error_message;

   isapi_response_ptr->vector_element_array[ 5 ].cbSize = strlen( error_message );

   memcpy( isapi_response_ptr->pszHeaders, "Content-Type : text/html\r\nContent-Length: ", 41 );



   //
   // Construct the headers of the HTTP response.  Instead of using
   // a slow sprintf call, do the following...
   //


   //
   // Construct the first part of the header string.
   //

   strcat( isapi_response_ptr->pszHeaders, 

           "Content-Type: text/html\r\n"
           "Content-Length: " );


   //
   // Construct a string containing the value of the 'Content-Length'
   // header field and use memcpy to concatentate it onto the existing
   // header string (which, incidentally is 41 characters long at this
   // point).

   dword_to_string( ( DWORD )( isapi_response_ptr->vector_element_array[ 0 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 1 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 2 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 3 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 4 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 5 ].cbSize +
                               isapi_response_ptr->vector_element_array[ 6 ].cbSize ),
                    
                    content_length_string );

   memcpy( isapi_response_ptr->pszHeaders + 41, 
           content_length_string, 
           content_length_string_length = strlen( content_length_string ) );


   //
   // Now, use memcpy to concatenate the trailing new-line, carriage
   // return and null terminator characters that denote the end of
   // HTTP headers (incidentally, the header string is 41 + content_
   // length_string_length characters long before this concatenation.
   //

   ii = 41 + content_length_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii, "\r\n\r\n\0", 5 );

   isapi_response_ptr->response_vector.pszStatus = status;


   //
   // Finally, send out the error page.
   //

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {
      LOG_ERROR("HSE_REQ_VECTOR_SEND failed", GetLastError());
      return( HSE_STATUS_ERROR );

   }


   //
   // If you have made it this far without returning indicating an
   // error, return indicating success.
   //

   return( HSE_STATUS_SUCCESS );

}


/*********************************************************************/


VOID dword_to_string( DWORD dword, CHAR *string )
/*++

Routine Description:

   Generates a character string that captures the decimal 
   representation of a DWORD.

Arguments:

   dword - The DWORD whose decimal representation is to be captured in
           a character string.

   string - A pointer to the buffer in which the character string
            generated is to be stor

   string_buffer_size - A pointer to a DWORD which contains the size of
                        the output buffer provided.  On completion, the
                        size of the string generated is written to the
                        DWORD pointed to by this parameter.

Return Value:

   None.

--*/
{

   DWORD num_digits;

   INT ii;


   //
   // Determine the number of digits in the decimal
   // representation of the input DWORD by taking the
   // integer part of its base 10 representation.
   //

   num_digits = ( DWORD )log10( dword ) + 1;


   //
   // Scroll through and fill the output buffer from the
   // lowest order to the highest order digit.  One each
   // iteration the lowest order decimal digit is obtained
   // by using a modulo 10 (i.e. % 10) operation and then
   // dropped by performing an integer division by 10.
   //

   for ( ii = num_digits - 1; ii >= 0; ii-- )
   {

     string[ ii ] = '0' + ( CHAR )( dword % 10 );

     dword /= 10;

   }


   //
   // Set the '\0' terminating character of the
   // output string after the lowest order digit.
   //

   string[ num_digits ] = '\0';

}


/*********************************************************************/


VOID WINAPI vector_send_completion_callback( EXTENSION_CONTROL_BLOCK *pECB,
                                             VOID *pvContext,
                                             DWORD cbIO,
                                             DWORD dwError )
/*++

Routine Description:

   Callback invoked after completion of an asynchronous VectorSend.

Arguments:

   pECB - Pointer to the relevant extension control block.

   pContext - Pointer to the relevant ISAPI response struct.

   cbIO - Number of bytes sent.

   dwError - Error code for the VectorSend.

Return Value:

   None.

--*/
{

   ISAPI_RESPONSE *isapi_response_ptr = ( ISAPI_RESPONSE * )pvContext;

   DWORD status = HSE_STATUS_SUCCESS;

   //
   // If the file was sent using a file handle, close that
   // handle.
   //

   if ( isapi_response_ptr->hFile != INVALID_HANDLE_VALUE )
   {

      CloseHandle( isapi_response_ptr->hFile );

      isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   }


   //
   // Free the ISAPI response structure used by pushing
   // it back on the stack of free ISAPI_RESPONSE
   // structures.
   //

   free_isapi_response( ( ISAPI_RESPONSE * )pvContext );


   //
   // Indicate successful completion or failed completion of
   // client request servicing by calling the HSE_REQ_DONE_
   // WITH_SESSION ServerSupportFunction with the appropriate
   // status code.
   //

   if ( dwError != ERROR_SUCCESS )
   {

      LOG_ERROR("completion returned error", dwError);

      status = HSE_STATUS_ERROR;

   }

   pECB->ServerSupportFunction( pECB->ConnID,
                                HSE_REQ_DONE_WITH_SESSION,
                                &status,
                                NULL,
                                NULL );

}


/*********************************************************************/


BOOL parse_post_data( PBYTE pbRequestData,
                      DWORD cbRequestData,
                      CHAR **urlroot,
                      CHAR **dir_num,
                      CHAR **class_num,
                      CHAR **file_num,
                      CHAR **client_num )
/*++

Routine Description:

   Parse the POST data sent in a SPECweb99 dynamic POST request.

Arguments:

   PBYTE pbRequestData -
   DWORD cbRequestData -

   urlroot - Location to which the value of the 'urlroot' POST data
             parameter is written.

   dir_num - Location to which the value of the 'dir' POST data
             parameter is written.

   class_num - Location to which the value of the 'class' POST data
               parameter is written.

   file_num - Location to which the value of the 'num' POST data
              parameter is written.

   client_num - Location to which the value of the 'client' POST data
                parameter is written.
   
Return Value:

   Returns TRUE if POST data has correct format, FALSE otherwise.

--*/
{

   CHAR *token;

   DWORD ii = 0;

   static CHAR urlroot_label[] =  "urlroot=";
   static CHAR dir_label[] =      "dir=";
   static CHAR class_label[] =    "class=";
   static CHAR file_num_label[] = "num=";
   static CHAR client_label[] =   "client=";

   BOOL urlroot_received = FALSE;

   BOOL dir_num_received = FALSE;

   BOOL class_num_received = FALSE;

   BOOL file_num_received = FALSE;

   BOOL client_num_received = FALSE;


   //
   // Use the following loop to parse the POST data.
   //
   if ( pbRequestData == NULL )
   {
       LOG_ERROR( "pbRequestData == NULL", ERROR_INVALID_PARAMETER );
       return FALSE;
   }
   
   token = strtok( ( CHAR * )pbRequestData, "&" );

   while( token )
   {   

      if ( ++ii > 5 )
      {

         return( FALSE );

      }

      switch( token[ 0 ] )
      {


         //
         // Parse 'urlroot'.
         //

         case 'u':
         {

            if ( memcmp( token, urlroot_label, sizeof( urlroot_label ) - 1 ) )
            {
                
               return( FALSE );
                
            }
            
            *urlroot = token + sizeof( urlroot_label ) - 1 ;
            
            urlroot_received = TRUE;

            break;
            
         }


         //
         // Parse 'dir'.
         //
         
         case 'd':
         {
          
            if ( memcmp( token, dir_label, sizeof( dir_label ) - 1  ) )
            {
              
               return( FALSE );

            }

            *dir_num = token + sizeof( dir_label ) - 1;

            dir_num_received = TRUE;

            break;

         }


         //
         // Parse 'client' or 'class'.
         //

         case 'c':
         {

            if ( !memcmp( token, client_label, sizeof( client_label ) - 1 ) )
            {
 
               *client_num = token + sizeof( client_label ) - 1;

               client_num_received = TRUE;

               break;

            }
            else if ( !memcmp( token, class_label, sizeof( class_label ) - 1 ) )
            {

               *class_num = token + sizeof( class_label ) - 1;

               class_num_received = TRUE;

               break;

            }

            return( FALSE );

         }


         //
         // Parse 'num'.
         //

         case 'n':
         {

            if ( memcmp( token, file_num_label, sizeof( file_num_label ) - 1 ) )
            {

               return( FALSE );

            }

            *file_num = token + sizeof( file_num_label ) - 1;

            file_num_received = TRUE;

            break;

         }

         default:
         {


            //
            // Unexpected POST data was encountered.  Return FALSE.
            // 
	    LOG_ERROR( "Unexpected POST data was encountered", ERROR_INVALID_PARAMETER );
            return( FALSE );

         }

      }


      //
      // Get the next piece of POST data to parse.
      //

      token = strtok( NULL, "&" );

   }


   //
   // Return TRUE if all POST data was received, FALSE otherwise.
   //

#if DBG
   if( !(     urlroot_received && 
           dir_num_received &&
           class_num_received &&
           file_num_received &&
           client_num_received ) )
    {
        LOG_ERROR( "Not all post data was received", ERROR_INVALID_PARAMETER );
    }
#endif
   
    return( urlroot_received && 
           dir_num_received &&
           class_num_received &&
           file_num_received &&
           client_num_received );

}


/*********************************************************************/


DWORD handle_post( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Handles a SPECweb99 dynamic POST request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   Returns HSE_STATUS_SUCCESS.

--*/
{

   BOOL use_async_vector_send;

   WIN32_FILE_ATTRIBUTE_DATA fileinfo;

   CHAR *urlroot = NULL;

   CHAR *dir_num = NULL;

   CHAR *class_num = NULL;

   CHAR *file_num = NULL;

   CHAR *client_num = NULL;

   CHAR cookie_string[ MAX_COOKIE_STRING_LENGTH ];

   DWORD cookie_string_size = MAX_COOKIE_STRING_LENGTH;

   DWORD urlroot_length;

   CHAR my_cookie[ 11 ];

   DWORD ii;

   DWORD thread_id;

   DWORD postlog_buffer_index;   

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;

   BOOL return_value = HSE_STATUS_SUCCESS;

   DWORD bytes_read;

   CHAR absolute_filename[ MAX_PATH ];

   CHAR *filename;

   HANDLE hFile;

   CHAR server_name[ 32 ];
   
   CHAR server_port[ 32 ];
     
   DWORD server_name_size = 32;
     
   DWORD server_port_size = 32;

   DWORD app_pool_name_size = 1024; // 1024 == sizeof( g_app_pool_name_length )

   DWORD server_name_length;

   DWORD server_port_length;

   BYTE  request_data[256];


   if ( InterlockedExchange( &g_fragment_cache_key_base_not_initialized, 0 ) )
   {
    
      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_NAME",
                                     server_name,
                                     &server_name_size ) )
      {
         LOG_ERROR("GetServerVariable(SERVER_NAME) failed", 0);
         return( HSE_STATUS_ERROR );

      }

      server_name_length = server_name_size - 1;

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "SERVER_PORT",
                                     server_port,
                                     &server_port_size ) )
      {
         LOG_ERROR("GetServerVariable(SERVER_PORT) failed", 0);
         return( HSE_STATUS_ERROR );

      }

      server_port_length = server_port_size - 1;

      if ( !pECB->GetServerVariable( pECB->ConnID,
                                     "APP_POOL_ID",
                                     g_app_pool_name,
                                     &app_pool_name_size ) )
      {
         LOG_ERROR("GetServerVariable(APP_POOL_ID) failed", 0);
         return( HSE_STATUS_ERROR );
      }

      g_app_pool_name_length = app_pool_name_size - 1;

      strcpy( g_fragment_cache_key_base, g_app_pool_name );

      memcpy( g_fragment_cache_key_base + g_app_pool_name_length, "/http://", 8 );

      ii = g_app_pool_name_length + 8;

      memcpy( g_fragment_cache_key_base + ii, server_name, server_name_length );

      ii += server_name_size - 1;

      g_fragment_cache_key_base[ ii ] = ':';

      ii++;

      memcpy( g_fragment_cache_key_base + ii, server_port, server_port_length );

      ii += server_port_size - 1;

      g_fragment_cache_key_base[ ii ] = '\0';

      g_fragment_cache_key_base_length = strlen( g_fragment_cache_key_base );

   }


   //
   // Parse POST data.
   //

   if ( pECB->cbAvailable == 0)
   {
        //
        // empty body is unexpected with POST
        //
        LOG_ERROR( "Empty POST request", 0 );
        return( send_error_page( pECB, "Empty POST data.", g_pszStatus400 ) );
   }

   if ( pECB->cbAvailable >= sizeof( request_data ) )
   {
        LOG_ERROR( "Too big POST data", 0 );
        return( send_error_page( pECB, "Too big POST data.", g_pszStatus400 ) );
   }
   
   memcpy( request_data, pECB->lpbData, pECB->cbAvailable );

   //
   // parse_post_data currently assumes null terminated string
   //
   request_data[ pECB->cbAvailable ] = '\0';

   if ( !parse_post_data( request_data, pECB->cbAvailable, &urlroot, &dir_num, &class_num, &file_num, &client_num ) )
   {

      return( send_error_page( pECB, "Malformed POST data.", g_pszStatus400 ) );

   }


   //
   // Parse cookie string.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "HTTP_COOKIE",
                                  cookie_string,
                                  &cookie_string_size ) )
   {
      LOG_ERROR("GetServerVariable(HTTP_COOKIE) failed", 0);
      return( HSE_STATUS_ERROR );

   }
   //
   // Parse the cookie string - only the user_id value is the interesting piece
   // Example:   "my_cookie=user_id=10001&last_ad=20"
   //
   static CHAR s_szCookiePrefix[] = "my_cookie=user_id=";
   my_cookie[0] = '\0';
   if ( strncmp( cookie_string,  
                 s_szCookiePrefix, 
                 sizeof( s_szCookiePrefix ) - 1 ) == 0 )
   {
      ii = 0;
      while ( cookie_string[ sizeof( s_szCookiePrefix ) - 1 + ii ] != '\0' &&
              cookie_string[ sizeof( s_szCookiePrefix ) - 1 + ii ] != '&'  &&
              ii < sizeof( my_cookie ) )
      {
         my_cookie[ ii ] = cookie_string[ sizeof( s_szCookiePrefix ) - 1 + ii ];
         ii++;
      }
      my_cookie[ ii ] = '\0';
   }
                 

   //
   // Construct the absolute name of the file requested. 
   //

   memcpy( absolute_filename, g_root_dir, g_root_dir_length );

   urlroot_length = strlen( urlroot );

   memcpy( absolute_filename + g_root_dir_length, urlroot, urlroot_length );

   ii = g_root_dir_length + urlroot_length;

   memcpy( absolute_filename + ii, "dir", sizeof( "dir" ) - 1 );

   ii += sizeof("dir") - 1;

   memcpy( absolute_filename + ii, dir_num, 5 );

   ii += 5;

   memcpy( absolute_filename + ii, "/class", sizeof("/class") - 1  );

   ii += sizeof("/class") - 1;

   absolute_filename[ ii ] = class_num[ 0 ];

   ii++;

   absolute_filename[ ii ] = '_';

   ii++;

   memcpy( absolute_filename + ii, file_num, 2 );

   filename = absolute_filename + g_root_dir_length;


   //
   // Write the appropriate record to the post log buffer.
   //

   postlog_buffer_index = InterlockedIncrement( &g_postlog_record_count ) - 1;

   g_postlog_buffer[ postlog_buffer_index ].record_number = postlog_buffer_index + 1;

   time( ( time_t * )&( g_postlog_buffer[ postlog_buffer_index ].time_stamp ) );

   g_postlog_buffer[ postlog_buffer_index ].thread_id = GetCurrentThreadId();

   strncpy( g_postlog_buffer[ postlog_buffer_index ].dir_num , dir_num, 6 );

   g_postlog_buffer[ postlog_buffer_index ].class_num = class_num[ 0 ];

   g_postlog_buffer[ postlog_buffer_index ].file_num = file_num[ 0 ];

   // bugbug - the following strncpy may end up not NULL terminated
   strncpy( g_postlog_buffer[ postlog_buffer_index ].client_num, client_num, 6 );

   strncpy( g_postlog_buffer[ postlog_buffer_index ].filename, filename, 60 );

   strncpy( g_postlog_buffer[ postlog_buffer_index ].my_cookie, my_cookie, 10 );


   //
   // Return the requested file.  To do this, first determine the size
   // of the file requested.
   //

   if ( !GetFileAttributesEx( absolute_filename,
                              GetFileExInfoStandard,
                              &fileinfo ) )
   {

      return( send_error_page( pECB, "File inaccessible.", g_pszStatus404 ) );

   }


   //
   // Determine the I/O mode to use with VectorSend.
   //

   switch( g_vector_send_io_mode_config )
   {

      case USE_ASYNC_IO:
      {

         use_async_vector_send = TRUE;

         break;

      }

      case USE_SYNC_IO:
      {

         use_async_vector_send = FALSE;

         break;

      }

      case USE_ADAPTABLE_IO:
      {

         use_async_vector_send = ( fileinfo.nFileSizeLow >= g_vector_send_async_range_start );

         break;

      }

   }


   //
   // Set isapi_response_ptr to point to an ISAPI response struct on
   // the heap if using asynchronous I/O.  Also set the VectorSend
   // completion callback and return value.
   //

   if ( use_async_vector_send )   
   {

      if ( !( isapi_response_ptr = allocate_isapi_response() ) )
      {
         LOG_ERROR("allocate_isapi_response failed", 0);
         return( HSE_STATUS_ERROR );

      }

      pECB->ServerSupportFunction( pECB->ConnID,
                                   HSE_REQ_IO_COMPLETION,
                                   vector_send_completion_callback,
                                   NULL,
                                   ( DWORD * )isapi_response_ptr
                                   );

      return_value = HSE_STATUS_PENDING;      

   }


   //
   // Initialize the ISAPI response struct.
   //

   if ( !initialize_isapi_response( isapi_response_ptr,
                                    pECB,
                                    filename,
                                    fileinfo.nFileSizeLow,
                                    my_cookie,
                                    use_async_vector_send ) )
   {

      if ( use_async_vector_send )
      {

         free_isapi_response( isapi_response_ptr );

      }
      LOG_ERROR("initialize_isapi_response failed", 0);

      return( HSE_STATUS_ERROR );

   }


   //
   // Execute the VectorSend operation.  If ServerSupportFunction
   // returns TRUE, handle the cache hit case.  Otherwise, assume
   // a cache miss and handle it.
   //

   if ( pECB->ServerSupportFunction( pECB->ConnID,
                                     HSE_REQ_VECTOR_SEND,
                                     &( isapi_response_ptr->response_vector ),
                                     NULL,
                                     NULL ) )
   {

      return( return_value );
     
   }


   //
   // Get a handle on the file.
   //

   if ( ( hFile = CreateFile( absolute_filename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {

      if ( use_async_vector_send )
      {

         free_isapi_response( isapi_response_ptr );

      }
       
      return( send_error_page( pECB, "File inaccessible.", g_pszStatus404 ) );
       
   }


   //
   // Add the file data to the HTTP.SYS fragment cache.
   //

   isapi_response_ptr->vector_element.ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;

   isapi_response_ptr->vector_element.pvContext = hFile;

   isapi_response_ptr->vector_element.cbSize = fileinfo.nFileSizeLow;

   isapi_response_ptr->vector_element.cbOffset = 0;
   
   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_ADD_FRAGMENT_TO_CACHE,
                                      &isapi_response_ptr->vector_element,
                                      ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key,
                                      NULL ) )
   {

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {
         
         LOG_ERROR("HSE_REQ_VECTOR_SEND failed", GetLastError() );
         
         if ( use_async_vector_send )
         {   

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;   

            free_isapi_response( isapi_response_ptr );

         }

         CloseHandle( hFile );
         return( HSE_STATUS_ERROR );

      }

      if ( !use_async_vector_send )
      {
          CloseHandle( hFile );
      }

      return( return_value );

   }


   //
   // Retry the VectorSend.
   //

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {

      isapi_response_ptr->vector_element_array[ 5 ] = isapi_response_ptr->vector_element;

      if ( use_async_vector_send )
      {

         isapi_response_ptr->hFile = hFile;

      }

      if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_VECTOR_SEND,
                                         &( isapi_response_ptr->response_vector ),
                                         NULL,
                                         NULL ) )
      {
         DWORD error = GetLastError();
         LOG_ERROR("HSE_REQ_VECTOR_SEND failed", error);


         if ( use_async_vector_send )
         {

            isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

            free_isapi_response( isapi_response_ptr );

         }

         CloseHandle( hFile );

         return( HSE_STATUS_ERROR );

      }

   }

   if ( !use_async_vector_send )
   {
       CloseHandle( hFile );
   }

   return( return_value );

}


/*********************************************************************/


DWORD handle_reset( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Handles a SPECweb99 Reset request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   Returns HSE_STATUS_SUCCESS on success and HSE_STATUS_ERROR on
   failure.

--*/
{

   HANDLE hFile;

   CHAR command_line[ 4 * MAX_RESET_ARG_LENGTH + MAX_PATH + 21 ];

   CHAR max_load[ MAX_RESET_ARG_LENGTH ];

   CHAR point_time[ MAX_RESET_ARG_LENGTH ];

   CHAR max_threads[ MAX_RESET_ARG_LENGTH ];

   CHAR expired_list[ MAX_RESET_ARG_LENGTH ];

   DWORD max_load_length;

   DWORD max_threads_length;

   DWORD point_time_length;

   DWORD expired_list_length;

   STARTUPINFO startup_information;

   PROCESS_INFORMATION process_information;

   CHAR executable_filename[ MAX_PATH ];

   DWORD bytes_written;

   DWORD ii;

   DWORD jj;


   //
   // Parse the input arguments.
   //

   for ( ii = 0, jj = sizeof( "command/Reset&maxload=" ) - 1;
         ( max_load[ ii ] = pECB->lpszQueryString[ jj ] ) != '&';
         ii++, jj++ );

   max_load[ max_load_length = ii ] = '\0';

   for ( ii = 0, jj += sizeof( "pttime=" );
         ( point_time[ ii ] = pECB->lpszQueryString[ jj ] ) != '&';
         ii++, jj++ );

   point_time[ point_time_length = ii ] = '\0';

   for ( ii = 0, jj += sizeof( "maxthread=" );
         ( max_threads[ ii ] = pECB->lpszQueryString[ jj ] ) != '&';
         ii++, jj++ );

   max_threads[ max_threads_length = ii ] ='\0';

   ii = 0;
   jj += sizeof( "exp=" );

   while( pECB->lpszQueryString[ jj ] != '&' && pECB->lpszQueryString[ jj ] != '\0')
   {
     if ( pECB->lpszQueryString[ jj ]  == ',' )
     {
        expired_list[ ii ] = ' ';
     }
     else
     {
        expired_list[ ii ] = pECB->lpszQueryString[ jj ];
     }
     ii++;
     jj++;
   }

   expired_list[ expired_list_length = ii ] = '\0';


   //
   // Construct and invoke the appropriate command line for 'upfgen99'.
   //

   memcpy( command_line, g_root_dir, g_root_dir_length );

   memcpy( command_line + g_root_dir_length, "\\upfgen99 -n ", 13 );

   ii = g_root_dir_length + 13;

   memcpy( command_line + ii, max_load, max_load_length );

   ii += max_load_length;

   memcpy( command_line + ii, " -t ", 4 );

   ii += 4;

   memcpy( command_line + ii, max_threads, max_threads_length );

   ii += max_threads_length;

   memcpy( command_line + ii, " -C ", 4 );

   ii += 4;

   memcpy( command_line + ii, g_root_dir, g_root_dir_length + 1 );

   memcpy( executable_filename, g_root_dir, g_root_dir_length );

   memcpy( executable_filename + g_root_dir_length, "\\upfgen99.exe\0", 14 );

   startup_information.cb = sizeof( startup_information );

   startup_information.lpReserved = NULL;

   startup_information.lpDesktop = NULL;

   startup_information.lpTitle = NULL;

   startup_information.dwFlags = 0;

   startup_information.cbReserved2 = 0;

   startup_information.lpReserved2 = NULL;

   CreateProcess( executable_filename,
                  command_line,
                  NULL,
                  NULL,
                  FALSE,
                  0,
                  NULL,
                  NULL,
                  &startup_information,
                  &process_information );

   CloseHandle( process_information.hProcess );

   CloseHandle( process_information.hThread );


   //
   // Construct and invoke the appropriate command line for 'cadgen99'.
   //

   memcpy( command_line + g_root_dir_length, "\\cadgen99 -C ", 13 );

   ii = g_root_dir_length + 13;

   memcpy( command_line + ii, g_root_dir, g_root_dir_length );

   ii += g_root_dir_length;

   memcpy( command_line + ii, " -e ", 4 );

   ii += 4;

   memcpy( command_line + ii, point_time, point_time_length );

   ii += point_time_length;

   memcpy( command_line + ii, " -t ", 4 );

   ii += 4;

   memcpy( command_line + ii, max_threads, max_threads_length );

   ii += max_threads_length;

   memcpy( command_line + ii, " ", 1 );

   ii++;

   memcpy( command_line + ii, expired_list, expired_list_length );

   ii += expired_list_length;

   command_line[ ii ] = '\0';

   memcpy( executable_filename + g_root_dir_length, "\\cadgen99.exe\0", 14 );

   CreateProcess( executable_filename,
                  command_line,
                  NULL,
                  NULL,
                  FALSE,
                  0,
                  NULL,
                  NULL,
                  &startup_information,
                  &process_information );

   CloseHandle( process_information.hProcess );

   CloseHandle( process_information.hThread );


   //
   // Reset the PostLog file to its initial state.
   //

   if ( ( hFile = CreateFile( g_postlog_filename,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL ) ) == INVALID_HANDLE_VALUE )
   {

      LOG_ERROR( "PostLog file creation failed", GetLastError() );

      return( HSE_STATUS_ERROR );

   }

   g_postlog_record_count = 0;

   if ( !WriteFile( hFile,
                    "         0\n",
                    11,
                    &bytes_written,
                    NULL ) )
   {
      LOG_ERROR( "WriteFile failed", GetLastError() );
      return( HSE_STATUS_ERROR );

   }

   CloseHandle( hFile );

   pECB->ServerSupportFunction( pECB->ConnID,
                                HSE_REQ_SEND_RESPONSE_HEADER,
                                "200 OK",
                                NULL,
                                (LPDWORD) "\r\n\r\n" ); 

   return( HSE_STATUS_SUCCESS );

}


/*********************************************************************/


DWORD handle_fetch( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Handles a SPECweb99 Fetch request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   Returns HSE_STATUS_SUCCESS on success and HSE_STATUS_ERROR
   on failure.

--*/
{

   CHAR record_count_string[ 12 ];

   HANDLE hFile;

   DWORD bytes_written;

   CHAR content_length_string[ 64 ];

   DWORD content_length_string_length;

   CHAR buffer[ NUM_RECORDS_PER_BURST * POSTLOG_RECORD_SIZE ];

   DWORD total_records_processed = 0;

   DWORD ii;

   CHAR pszHeaders[ 53 ];

   CHAR remote_addr[ 16 ];

   DWORD remote_addr_size = 16; // 16 == sizeof( remote_addr )

   HSE_VECTOR_ELEMENT vector_element_array[ 7 ];

   HSE_RESPONSE_VECTOR response_vector;


   //
   // Flush the PostLog buffer data to disk.
   // To do this, use the following steps...
   //    


   //
   // Open a handle that allows read and write
   // access to the PostLog.txt file in the 
   // webserver document root directory.
   //

   if ( ( hFile = CreateFile( g_postlog_filename,
                              GENERIC_WRITE | GENERIC_READ,
                              0,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL ) ) == INVALID_HANDLE_VALUE )
   {

      return( send_error_page( pECB, 
                               "Error creating PostLog.", 
                               g_pszStatus500 ) );

   }


   //
   // Construct the first line of the PostLog
   // to be flushed.  This is the line, right
   // justified and padded to 10 characters, that
   // contains the number of PostLog records.
   //

   sprintf( record_count_string, "%10d\n", g_postlog_record_count );


   //
   // Write out the first line of the PostLog,
   // which was just constructed, to the PostLog.txt
   // file.
   //

   if ( !WriteFile( hFile,
                    record_count_string,
                    11,
                    &bytes_written,
                    NULL ) )
   {


      //
      // In the event that the write operation
      // fails, close the handle to the PostLog.txt
      // file and return an error page.
      //

      CloseHandle( hFile );

      return( send_error_page( pECB, 
                               "Error accessing PostLog.", 
                               g_pszStatus500 ) );

   }


   //
   // 
   //

   while( total_records_processed < ( DWORD )g_postlog_record_count )
   {

      for ( ii = 0; 
            ii < NUM_RECORDS_PER_BURST && total_records_processed < ( DWORD )g_postlog_record_count; 
            ii++, total_records_processed++ )
      {   

         sprintf(  buffer + ( ii * POSTLOG_RECORD_SIZE ),

                   "%10d %10d %10d %5s %2c %2c %10s %-60.60s %10d %10s\n",
                      
                   g_postlog_buffer[ total_records_processed ].record_number,
                   g_postlog_buffer[ total_records_processed ].time_stamp,
                   g_postlog_buffer[ total_records_processed ].thread_id,
                   g_postlog_buffer[ total_records_processed ].dir_num,
                   g_postlog_buffer[ total_records_processed ].class_num,
                   g_postlog_buffer[ total_records_processed ].file_num,
                   g_postlog_buffer[ total_records_processed ].client_num,
                   g_postlog_buffer[ total_records_processed ].filename,
                   g_postlog_buffer[ total_records_processed ].thread_id,
                   g_postlog_buffer[ total_records_processed ].my_cookie  );

      }

      if ( !WriteFile( hFile,
                       buffer,
                       ii * POSTLOG_RECORD_SIZE,
                       &bytes_written,
                       NULL ) )
      {


        //
        // In the event that a write operation fails,
        // close the handle to the PostLog.txt file
        // and send an error page.
        //

        CloseHandle( hFile );

        return( send_error_page( pECB, 
                                 "Error accessing PostLog.", 
                                 g_pszStatus500 ) );

      }

   }


   //
   // Send the PostLog.txt file to the client,
   // using the same HTML response format as in
   // the SPECweb99 standard dynamic GET case.
   // To do this, use the following steps...
   //


   //
   // Populate the HSE_VECTOR_ELEMENT struct array.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "REMOTE_ADDR",
                                  remote_addr,
                                  &remote_addr_size ) )
   {

      CloseHandle( hFile );
      LOG_ERROR( "GetServerVatiable(REMOTE_ADDR) failed", GetLastError() );
      return( HSE_STATUS_ERROR );

   }

   vector_element_array[ 0 ] = g_vector_element_0;


   vector_element_array[ 1 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   vector_element_array[ 1 ].pvContext = remote_addr;
   vector_element_array[ 1 ].cbSize = remote_addr_size - 1;


   vector_element_array[ 2 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   static char vector_element_2[] =  "\n<p>SCRIPT_NAME = /specweb99-CMD_AND_POST.dll\n"
                                     "<p>QUERY_STRING = ";
   vector_element_array[ 2 ].pvContext = vector_element_2;
   vector_element_array[ 2 ].cbSize = sizeof( vector_element_2 ) - 1;


   vector_element_array[ 3 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;   
   static char vector_element_3[] = "command/Fetch";
   vector_element_array[ 3 ].pvContext = vector_element_3;
   vector_element_array[ 3 ].cbSize = sizeof( vector_element_3 ) - 1;


   vector_element_array[ 4 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
   static char vector_element_4[] =  "\n<pre>\n";
   vector_element_array[ 4 ].pvContext = vector_element_4;
   vector_element_array[ 4 ].cbSize = sizeof( vector_element_4 ) - 1;


   vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;

   vector_element_array[ 5 ].pvContext = hFile;

   vector_element_array[ 5 ].cbSize = 11 + g_postlog_record_count * POSTLOG_RECORD_SIZE;

   vector_element_array[ 5 ].cbOffset = 0;


   vector_element_array[ 6 ] = g_vector_element_6;


   //
   // Populate the HSE_RESPONSE_VECTOR struct.
   // 

   strcpy( pszHeaders, "Content-Type: text/plain\r\nContent-Length: " );

   _ui64toa( vector_element_array[ 0 ].cbSize +
             vector_element_array[ 1 ].cbSize +
             vector_element_array[ 2 ].cbSize +
             vector_element_array[ 3 ].cbSize +
             vector_element_array[ 4 ].cbSize +
             vector_element_array[ 5 ].cbSize +
             vector_element_array[ 6 ].cbSize,
             
             content_length_string,
             
             10 );

   content_length_string_length = strlen( content_length_string );

   memcpy( pszHeaders + 42, content_length_string, content_length_string_length );

   memcpy( pszHeaders + 42 + content_length_string_length, "\r\n\r\n\0", 5 );

   response_vector.pszHeaders = pszHeaders;
 
   response_vector.lpElementArray = vector_element_array;

   response_vector.nElementCount = 7;

   response_vector.pszStatus = g_pszStatus200;

   response_vector.dwFlags = HSE_IO_FINAL_SEND | HSE_IO_SEND_HEADERS | HSE_IO_SYNC;

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &response_vector,
                                      NULL,
                                      NULL ) )
   {

      LOG_ERROR( "HSE_REQ_VECTOR_SEND failed", GetLastError() );

      CloseHandle( hFile );

      return( HSE_STATUS_ERROR );

   }

   CloseHandle( hFile );

    

   return( HSE_STATUS_SUCCESS );

}


/*********************************************************************/


BOOL load_registry_data( VOID )
/*++

Routine Description:

   Loads registry values used for configuration of specweb99-CAD.dll.

Arguments:

   None.

Return Value:

   Returns TRUE if all registry values are successfully loaded and
   FALSE otherwise.

--*/
{

   HKEY hKey;

   DWORD value_type;
   
   DWORD value_size;
   
   DWORD sizeof_value;

   BYTE value[ 4 ];
   

   //
   // Open the registry key containing all values used for
   // specweb99-CAD.dll configuration.
   //

   if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "Software\\Microsoft\\SPECweb99 ISAPI",
                      0,
                      KEY_QUERY_VALUE,
                      &hKey ) )
   {

      return( FALSE );

   }


   //
   // Load the value VECTOR_SEND_IO_MODE_CONFIG into the variable
   // g_vector_send_io_mode_config.
   //

   value_size = sizeof_value = sizeof( value );

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_IO_MODE_CONFIG",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_io_mode_config = *( ( DWORD* )value );
   }


   //
   // Load the value VECTOR_SEND_ASYNC_RANGE_START into the
   // variable g_vector_send_async_range_start.
   //

   value_size = sizeof_value;

   if ( RegQueryValueEx( hKey,
                         "VECTOR_SEND_ASYNC_RANGE_START",
                         NULL,
                         &value_type,
                         value,
                         &value_size ) == NO_ERROR )
   {
      g_vector_send_async_range_start = *( ( DWORD * )value );
   }


   //
   // Load the value ROOT_DIR into the variable g_root_dir.
   // Store the length of this string in g_root_dir_length.
   //

   value_size = sizeof( g_root_dir );

   if ( RegQueryValueEx( hKey,
                         "ROOT_DIR",
                         NULL,
                         &value_type,
                         ( BYTE * )g_root_dir,
                         &value_size ) == NO_ERROR )
   {
      g_root_dir_length = value_size - 1;
   }
   else
   {
      return( FALSE );
   }


   //
   // If you have made it this far without returned indicating
   // failure, return indicating success.
   //

   return( TRUE );

}


/*********************************************************************/


BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
/*++

Routine Description:

   Implementation of the GetExtensionVersion ISAPI entry point.
   Carries out general initialization tasks and provides IIS with
   version information.

Arguments:

   pECB - Pointer to the version information structure to be populated.

Return Value:

   Returns TRUE if all initialization steps are successfully completed
   and FALSE otherwise.

--*/ 
{


   //
   // Load configuration data from the registry.
   //

   if ( !load_registry_data() )
   {

      load_registry_data();

   }


   //
   // Initialize the stack of free ISAPI_RESPONSE
   // structures on the heap.
   //

   initialize_isapi_response_stack();


   //
   // Allocate a buffer to hold the PostLog data.
   //
   // *** IMPORTANT NOTE ***
   //
   // An assumption made is that this buffer will be sufficiently 
   // large to hold all PostLog data during a SPECweb99 test.  This
   // assumption may prove false as if performance of the ISAPI
   // increases, the size of the PostLog data increases.  Should 
   // the stated assumption fail, code changes will be necessary 
   // to prevent failure of the ISAPI.  At present, we can accomodate
   // a PostLog file of around 790MB.  This should be more than
   // enough for now.
   //xs

   if ( !( g_postlog_buffer = ( POSTLOG_RECORD * )malloc( MAX_RECORDS_IN_POSTLOG_BUFFER * sizeof( POSTLOG_RECORD ) ) ) )
   {

      return( FALSE );

   }


   //
   // Initialize the global variable containing
   // the absolute name of the PostLog.txt file.
   // To do this, first copy absolute path of 
   // the webserver root (i.e. "D:/inetpub/wwwroot")
   // and then concatenate on the hardcoded 13
   // character string "/PostLog.txt".
   //

   memcpy( g_postlog_filename, g_root_dir, g_root_dir_length );

   memcpy( g_postlog_filename + g_root_dir_length, "\\PostLog.txt\0", 13 );


   //
   // Populate the ISAPI version information structure to
   // be used by IIS.
   //

   pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, 
                                        HSE_VERSION_MAJOR );

   strcpy( pVer->lpszExtensionDesc, 
           "SPECweb99-POST_AND_CMD ISAPI Extension");


   //
   // If you have made it this far without returning indicating
   // failure, then return indicating success.
   //

   return( TRUE );

}


/*********************************************************************/


DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

   Implementation of the HttpExtensionProc ISAPI entry point.
   Handles a SPECweb99 dynamic POST, Reset or Fetch request.

Arguments:

   pECB - Pointer to the relevant extension control block.

Return Value:

   DWORD - If synchronous VectorSend is used or an error page is to
           be sent, HSE_STATUS_SUCCESS is returned.  Otherwise, if
           asynchronous VectorSend is used, HSE_STATUS_PENDING is 
           returned.

--*/
{


   //
   // Here, we use the input query string to determine the request
   // type (i.e. is the request a dynamic POST, a Fetch command, 
   // or a Reset command) and then invoke the appropriate function
   // to handle it.  To do this note that the query string formats
   // for each of these requests are as follows:
   //
   // (1) Fetch Command ---> "command/Fetch" ('/' has index 8)
   //
   // (2) Reset Command ---> "command/Reset" ('/' has index 8)
   //
   // (3) Dynamic POST  ---> "
   //

   if ( pECB->lpszQueryString[ 0 ] == 'c' )
   {

      if ( pECB->lpszQueryString[ 8 ] == 'F' )
      {

         return( handle_fetch( pECB ) );

      }

      return( handle_reset( pECB ) );

   }

   return( handle_post( pECB ) );
            
}


/*********************************************************************/


BOOL WINAPI TerminateExtension( DWORD dwFlags )
/*++

Routine Description:

   Carries out all cleanup tasks.

Arguments:

   dwFlags - A DWORD that specifies whether IIS should shut down the
             extension.

Return Value:

   Returns TRUE on success and FALSE on failure.

--*/
{


  //
  // Destroy all entries in the satck of free
  // ISAPI_RESPONSE structures on the heap.
  //

   clear_isapi_response_stack();


   //
   // Destroy the buffer on the heap used to
   // store PostLog data.
   //

   free( g_postlog_buffer );


   //
   // If you have made it this far without returning indicating
   // failure, return indicating success.
   //

   return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\tools\common\dynodbc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC 
       functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
# include "dynodbc.h"
# include "html.h"
#include "resource.h"

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;

pfnSQLConfigDataSource    pSQLConfigDataSource ;

#define LOAD_ENTRY( Name )     (p##Name = (pfn##Name) GetProcAddress( hMod, #Name ))

static char szErrMsg[_MAX_PATH];
static char szODBCErrMsg[_MAX_PATH];

BOOL  fODBCLoaded = FALSE;

BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if ( fODBCLoaded )
        return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( "odbc32.dll" ))) {

        if ( LOAD_ENTRY( SQLAllocConnect   )  &&
         LOAD_ENTRY( SQLAllocEnv       )  &&
         LOAD_ENTRY( SQLAllocStmt      )  &&
         LOAD_ENTRY( SQLBindCol        )  &&
         LOAD_ENTRY( SQLCancel         )  &&
         LOAD_ENTRY( SQLColAttributes  )  &&
         LOAD_ENTRY( SQLConnect        )  &&
         LOAD_ENTRY( SQLDescribeCol    )  &&
         LOAD_ENTRY( SQLDisconnect     )  &&
         LOAD_ENTRY( SQLError          )  &&
         LOAD_ENTRY( SQLExecDirect     )  &&
         LOAD_ENTRY( SQLExecute        )  &&
         LOAD_ENTRY( SQLFetch          )  &&
         LOAD_ENTRY( SQLFreeConnect    )  &&
         LOAD_ENTRY( SQLFreeEnv        )  &&
         LOAD_ENTRY( SQLFreeStmt       )  &&
         LOAD_ENTRY( SQLNumResultCols  )  &&
         LOAD_ENTRY( SQLPrepare        )  &&
         LOAD_ENTRY( SQLRowCount       )  &&
         LOAD_ENTRY( SQLTransact       )  &&
         LOAD_ENTRY( SQLSetConnectOption )  &&
         LOAD_ENTRY( SQLDrivers          )  &&
         LOAD_ENTRY( SQLDataSources      )  &&
         LOAD_ENTRY( SQLBindParameter    ))    {
			fODBCLoaded = TRUE;
            return TRUE;
        }
	}
     else {
		 HINSTANCE hInst = GetModuleHandle(NULL);

		 LoadString(hInst, IDS_ERRORMSG, szErrMsg, sizeof(szErrMsg));
		 LoadString(hInst, IDS_ODBCERRMSG, szODBCErrMsg, sizeof(szODBCErrMsg));
		 StartHTML(szODBCErrMsg, FALSE);
		 printf(szErrMsg);
		 EndHTML();
	 }
    return FALSE;
} // DynLoadODBC()


BOOL  fODBCInstallerLoaded = FALSE;

BOOL
DynLoadODBCInstaller(
    VOID
    )
{
    HMODULE hMod;

    if ( fODBCInstallerLoaded )
        return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( "odbccp32.dll" ))) {
		if ( LOAD_ENTRY( SQLConfigDataSource)) {
			fODBCInstallerLoaded = TRUE;
            return TRUE;
        }
	}
     else {
		 HINSTANCE hInst = GetModuleHandle(NULL);

		 LoadString(hInst, IDS_ERRORMSG, szErrMsg, sizeof(szErrMsg));
		 LoadString(hInst, IDS_ODBCERRMSG, szODBCErrMsg, sizeof(szODBCErrMsg));
		 StartHTML(szODBCErrMsg, FALSE);
		 printf(szErrMsg);
		 EndHTML();
	 }
               
    return FALSE;
} // DynLoadODBCInstaller()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\w3\gateways\specweb99\get\specweb99-get.cxx ===
/*********************************************************************
 *                                                                   *
 * File: specweb99-GET.cxx                                           *
 * ----                                                              *
 *                                                                   *
 *                                                                   *
 * Overview:                                                         *
 * --------                                                          *
 *                                                                   *
 * Implementation of the standard dynamic GET operation in the       *
 * SPECweb99 benchmark.                                              *
 *                                                                   *
 *                                                                   *
 * Revision History:                                                 *
 * ----------------                                                  *
 *                                                                   *
 * Date         Author                  Reason                       *
 * ----         ------                  ------                       *
 *                                                                   *
 * 07/03/02     Ankur Upadhyaya         Initial Creation.            *
 *                                                                   *
 *********************************************************************/


/*********************************************************************/


//
// Includes.
//


#include <windows.h>

#include <stdlib.h>

#include <malloc.h>

#include <stdio.h>

#include "httpextp.h"


/*********************************************************************/


//
// Defines.
//


#define USE_SYNC_IO 1

#define USE_ASYNC_IO 2

#define USE_ADAPTABLE_IO 3

#define MAX_FRAGMENT_CACHE_KEY_LENGTH 1024

#define MAX_APP_POOL_NAME_LENGTH 1024


/*********************************************************************/


//
// Type definitions.
//


typedef struct isapi_response 
{

   SINGLE_LIST_ENTRY item_entry;

   HSE_RESPONSE_VECTOR response_vector;

   HSE_VECTOR_ELEMENT vector_element_array[ 7 ];

   CHAR remote_addr[ 16 ];

   CHAR pszHeaders[ 53 ];

   WCHAR unicode_fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

   HANDLE hFile;
   HSE_VECTOR_ELEMENT vector_element;

} ISAPI_RESPONSE;


/*********************************************************************/


//
// Global Variables.
//


DWORD g_vector_send_io_mode_config = USE_SYNC_IO;

DWORD g_vector_send_async_range_start = 0;

CHAR *g_pszStatus_200 = "200 OK";

CHAR *g_pszStatus_404 = "404 File Inaccessible";

CHAR g_fragment_cache_key_base[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

DWORD g_fragment_cache_key_base_length;

volatile LONG g_fragment_cache_key_base_not_initialized = 1;

static CHAR s_szElement1[] =              "<html>\n"
                                          "<head><title>SPECweb99 Dynamic GET & POST Test</title></head>\n"
                                          "<body>\n"
                                          "<p>SERVER_SOFTWARE = Microsoft-IIS/6.0\n"
                                          "<p>REMOTE_ADDR = ";
HSE_VECTOR_ELEMENT g_vector_element_0 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          s_szElement1,
                                          0,
                                          sizeof(s_szElement1) - 1 };

static CHAR s_szElement2[] =              "\n<p>SCRIPT_NAME = /specweb99-GET.dll\n"
                                          "<p>QUERY_STRING = ";
HSE_VECTOR_ELEMENT g_vector_element_2 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          s_szElement2,
                                          0,
                                          sizeof(s_szElement2) - 1 };

static char s_szElement4[] =              "\n<pre>\n";
HSE_VECTOR_ELEMENT g_vector_element_4 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER,
                                          s_szElement4,
                                          0,
                                          sizeof(s_szElement4) - 1 };

static char s_szElement6[] =              "</pre>\n"
                                          "</body>\n</html>\n";
HSE_VECTOR_ELEMENT g_vector_element_6 = { HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER, 
                                          s_szElement6,
                                          0,
                                          sizeof(s_szElement6) - 1 };

SLIST_HEADER g_isapi_response_stack;

CHAR g_root_dir[ MAX_PATH ];

CHAR g_app_pool_name[ MAX_APP_POOL_NAME_LENGTH ];

DWORD g_root_dir_length;

DWORD g_app_pool_name_length;


/*********************************************************************/


//
// Function prototypes.
//


VOID initialize_isapi_response_stack( VOID );

ISAPI_RESPONSE *allocate_isapi_response( VOID );

VOID free_isapi_response( ISAPI_RESPONSE *isapi_response_ptr );

VOID clear_isapi_response_stack( VOID );

BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr, 
                                EXTENSION_CONTROL_BLOCK *pECB,
                                DWORD filesize, 
                                BOOL use_async_vector_send,
                                DWORD query_string_length );

DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB,
                       CHAR *error_message,
                       CHAR *pszStatus,
                       DWORD query_string_length );

VOID WINAPI vector_send_completion_callback( LPEXTENSION_CONTROL_BLOCK pECB,
                                            VOID *pContext,
                                            DWORD cbIO,
                                            DWORD dwError );

BOOL load_registry_data( VOID );

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer );

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB );

BOOL WINAPI TerminateExtension( DWORD dwFlags );


/*********************************************************************/


VOID initialize_isapi_response_stack( VOID )
/*++

Routine Description:

   Initialize the stack of ISAPI response structs on the heap.

Arguments:

   None. 

Return Value:

   None.

--*/
{


   //
   // Create the ISAPI response stack as a linked list.
   //

  InitializeSListHead( &g_isapi_response_stack );

}


/*********************************************************************/


ISAPI_RESPONSE *allocate_isapi_response( VOID )
/*++

Routine Description:

   Allocates a free ISAPI response struct on the ISAPI response stack.

Arguments:

   None.

Return Value:

   Returns a pointer to the ISAPI response struct allocated or NULL
   if no such struct was available.

--*/
{


   //
   // If the stack is non-empty, pop an ISAPI response struct from it
   // and return a pointer to it.  Otherwise, allocate a new ISAPI
   // response struct and return a pointer to it.
   //

   ISAPI_RESPONSE *isapi_response_ptr;

   if ( !( isapi_response_ptr = 
           ( ISAPI_RESPONSE * )InterlockedPopEntrySList( &g_isapi_response_stack ) ) )
   {

      isapi_response_ptr = ( ISAPI_RESPONSE * )malloc( sizeof( ISAPI_RESPONSE ) );

   }
   
   return( isapi_response_ptr );

}


/*********************************************************************/


VOID free_isapi_response( ISAPI_RESPONSE *isapi_response_ptr )
/*++

Routine Description:

   Free a previously allocated ISAPI response struct by placing it
   back on the ISAPI response stack.

Arguments:

   isapi_response_ptr - A pointer to the struct to be freed.

Return Value:

   None.

--*/
{


   //
   // Push the given ISAPI response struct onto the stack.
   //

  InterlockedPushEntrySList( &g_isapi_response_stack,
                             ( SINGLE_LIST_ENTRY * )isapi_response_ptr );

}


/*********************************************************************/


VOID clear_isapi_response_stack( VOID )
/*++

Routine Description:

   Free all memory on the heap used by the ISAPI response stack.

Arguments:

   None.

Return Value:

   None.

--*/
{


   //
   // Free all structs in the ISAPI response stack.
   //

   SINGLE_LIST_ENTRY *current_struct = InterlockedFlushSList( &g_isapi_response_stack );

   SINGLE_LIST_ENTRY *struct_to_kill;

   while( current_struct )
   {

      struct_to_kill = current_struct;

      current_struct = current_struct->Next;

      free( ( ISAPI_RESPONSE * )struct_to_kill );

   }

}


/*********************************************************************/


BOOL initialize_isapi_response( ISAPI_RESPONSE *isapi_response_ptr, 
                                EXTENSION_CONTROL_BLOCK *pECB,
                                DWORD filesize, 
                                BOOL use_async_vector_send,
                                DWORD query_string_length )
/*++

Routine Description:

   Initialize an ISAPI response struct by populating it with the
   appropriate data.

Arguments:

   isapi_response_ptr - Pointer to the ISAPI response struct to be
                        initialized.

   pECB - Pointer to the relevant extension control block.

   filesize - Size of the file requested.

   use_async_vector_send - Flag indicating whether VectorSend is to be
                           used in asynchronous or synchronous mode.

Return Value:

   None.

--*/
{

   DWORD remote_addr_size = 16; // 16 == sizeof( isapi_response_ptr->remote_addr )

   CHAR fragment_cache_key[ MAX_FRAGMENT_CACHE_KEY_LENGTH ];

   DWORD ii;

   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length;


   //
   // Set the fragment cache key.
   //

   memcpy( fragment_cache_key, g_fragment_cache_key_base, g_fragment_cache_key_base_length );

   memcpy( fragment_cache_key + g_fragment_cache_key_base_length, 
           pECB->lpszQueryString, 
           query_string_length + 1 );

   for ( ii = 0; 
         isapi_response_ptr->unicode_fragment_cache_key[ ii ] = ( WCHAR )fragment_cache_key[ ii ]; 
         ii++ );


   //
   // Obtain the IP address of the client.
   //

   if ( !pECB->GetServerVariable( pECB->ConnID,
                                  "REMOTE_ADDR",
                                  isapi_response_ptr->remote_addr,
                                  &remote_addr_size ) )
   {

      return( FALSE );

   }


   //
   // Populate the vector_element_array data structure.
   //

   isapi_response_ptr->vector_element_array[ 0 ] = g_vector_element_0;


   isapi_response_ptr->vector_element_array[ 1 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 1 ].pvContext = isapi_response_ptr->remote_addr;

   isapi_response_ptr->vector_element_array[ 1 ].cbSize = remote_addr_size - 1;


   isapi_response_ptr->vector_element_array[ 2 ] = g_vector_element_2;


   isapi_response_ptr->vector_element_array[ 3 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 3 ].pvContext = pECB->lpszQueryString;

   isapi_response_ptr->vector_element_array[ 3 ].cbSize = query_string_length;


   isapi_response_ptr->vector_element_array[ 4 ] = g_vector_element_4;


   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_FRAGMENT;

   isapi_response_ptr->vector_element_array[ 5 ].pvContext = ( DWORD * )isapi_response_ptr->unicode_fragment_cache_key;


   isapi_response_ptr->vector_element_array[ 6 ] = g_vector_element_6;


   //
   // Populate the response_vector struct.
   //

   memcpy( isapi_response_ptr->pszHeaders, "Content-Type: text/html\r\nContent-Length: ", 41 );
 
   // Construct content length string...

   _ui64toa( filesize + 
             isapi_response_ptr->vector_element_array[ 0 ].cbSize +
             isapi_response_ptr->vector_element_array[ 1 ].cbSize +
             isapi_response_ptr->vector_element_array[ 2 ].cbSize +
             isapi_response_ptr->vector_element_array[ 3 ].cbSize +
             isapi_response_ptr->vector_element_array[ 4 ].cbSize +
             isapi_response_ptr->vector_element_array[ 6 ].cbSize,
             
             content_length_string,

             10 );
   
   content_length_string_length = strlen( content_length_string );

   memcpy( isapi_response_ptr->pszHeaders + 41, content_length_string, content_length_string_length );

   ii = 41 + content_length_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii, "\r\n\r\n\0", 5 );

   isapi_response_ptr->response_vector.pszHeaders = isapi_response_ptr->pszHeaders;
 
   isapi_response_ptr->response_vector.lpElementArray = isapi_response_ptr->vector_element_array;

   isapi_response_ptr->response_vector.nElementCount = 7;

   isapi_response_ptr->response_vector.pszStatus = g_pszStatus_200;

   if ( use_async_vector_send )
   {

      isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                    HSE_IO_SEND_HEADERS |
                                                    HSE_IO_ASYNC;

   }
   else
   {

      isapi_response_ptr->response_vector.dwFlags = //HSE_IO_FINAL_SEND |
                                                    HSE_IO_SEND_HEADERS |
                                                    HSE_IO_SYNC;

   }
   
   //
   // Set the following additional fields is the ISAPI
   // response if to be sent to the client using
   // asynchronous VectorSend.
   //

   if ( use_async_vector_send )
   {


      //
      // By setting an 'hFile' HANDLE field we can check, in the
      // VectorSend completion callback routine, whether the
      // asynchronous VectorSend operation just completed made
      // use of a file handle.  If so, we must close the handle
      // in this callback.
      //  

      isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   }
   
   return( TRUE );

}


/*********************************************************************/


DWORD send_error_page( EXTENSION_CONTROL_BLOCK *pECB,
                       CHAR *error_msg,
                       CHAR *status,
                       DWORD query_string_length )
/*++

Routine Description:

   Sends an HTML error page to the client indicating that the file 
   requested could not be accessed.

Arguments:

   pECB - Pointer to the relevant extension control block.

   error_msg - Error message to send.

   status - Status to send (e.g. "200 OK").

Return Value:

   None.

--*/
{

   ISAPI_RESPONSE local_isapi_response;

   ISAPI_RESPONSE *isapi_response_ptr = &local_isapi_response;
 
   CHAR content_length_string[ 16 ];

   DWORD content_length_string_length;

   DWORD ii;


   //
   // Initialize the ISAPI response struct to be associated with 
   // the error page.
   //

   initialize_isapi_response( isapi_response_ptr,
                              pECB,
                              0, 
                              FALSE,
                              query_string_length );


   //
   // Change the response_vector and vector_element_array in the
   // ISAPI response struct to specify an error message (to be 
   // transmitted using synchronous I/O).
   //

   isapi_response_ptr->vector_element_array[ 5 ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;

   isapi_response_ptr->vector_element_array[ 5 ].pvContext = error_msg;

   isapi_response_ptr->vector_element_array[ 5 ].cbSize = strlen( error_msg );

   isapi_response_ptr->vector_element_array[ 5 ].cbOffset = 0;

   memcpy( isapi_response_ptr->pszHeaders, "Content-Type: text/html\r\nContent-Length: ", 41 );

   _ui64toa( isapi_response_ptr->vector_element_array[ 0 ].cbSize +
             isapi_response_ptr->vector_element_array[ 1 ].cbSize +
             isapi_response_ptr->vector_element_array[ 2 ].cbSize +
             isapi_response_ptr->vector_element_array[ 3 ].cbSize +
             isapi_response_ptr->vector_element_array[ 4 ].cbSize +
             isapi_response_ptr->vector_element_array[ 5 ].cbSize +
             isapi_response_ptr->vector_element_array[ 6 ].cbSize,
             
             content_length_string,

             10 );
 
   content_length_string_length = strlen( content_length_string );

   memcpy( isapi_response_ptr->pszHeaders + 41, content_length_string, content_length_string_length );

   ii = 41 + content_length_string_length;

   memcpy( isapi_response_ptr->pszHeaders + ii, "\r\n\r\n\0", 5 );

   isapi_response_ptr->response_vector.pszStatus = status;


   //
   // Send out the error page.
   // 

   if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                      HSE_REQ_VECTOR_SEND,
                                      &( isapi_response_ptr->response_vector ),
                                      NULL,
                                      NULL ) )
   {

     return( HSE_STATUS_ERROR );

   }

   return( HSE_STATUS_SUCCESS );
   
}


/*********************************************************************/


VOID WINAPI vector_send_completion_callback( LPEXTENSION_CONTROL_BLOCK pECB,
                                            VOID *pContext,
                                            DWORD cbIO,
                                            DWORD dwError )
/*++

Routine Description:

   Callback invoked after completion of an asynchronous VectorSend.

Arguments:

   pECB - Pointer to the relevant extension control block.

   pContext - Pointer to the relevant ISAPI response struct.

   cbIO - Number of bytes of sent.

   dwError - Error code for the VectorSend.

Return Value:

   Returns HSE_STATUS_SUCCESS.

--*/
{

   DWORD status = HSE_STATUS_SUCCESS;

   ISAPI_RESPONSE *isapi_response_ptr = ( ISAPI_RESPONSE * )pContext;

   if ( isapi_response_ptr->hFile != INVALID_HANDLE_VALUE )
   {

     CloseHandle( isapi_response_ptr->hFile );

     isapi_response_ptr->hFile = INVALID_HANDLE_VALUE;

   }


   //
   // Free the ISAPI response struct used.
   //

   free_isapi_response( ( ISAPI_RESPONSE * )pContext );


   //
   // Indicate successful completion of client request servicing.
   //

   pECB->ServerSupportFunction( pECB->ConnID,
                                HSE_REQ_DONE_WITH_SESSION,
                                &status,
                               