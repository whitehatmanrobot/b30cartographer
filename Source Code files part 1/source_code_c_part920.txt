eCollectionMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionMgr_EnumCollections(This,ppEnum)	\
    (This)->lpVtbl -> EnumCollections(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionMgr_EnumCollections_Proxy( 
    ITfDisplayAttributeCollectionMgr * This,
    /* [out] */ IEnumTfCollection **ppEnum);


void __RPC_STUB ITfDisplayAttributeCollectionMgr_EnumCollections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3977526d-1a0a-435a-8d06-ecc9516b484f")
    ITfDisplayAttributeCollectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCollectionCount( 
            /* [out] */ ULONG *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollectionCount )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [out] */ ULONG *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionProviderVtbl;

    interface ITfDisplayAttributeCollectionProvider
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionProvider_GetCollectionCount(This,puCount)	\
    (This)->lpVtbl -> GetCollectionCount(This,puCount)

#define ITfDisplayAttributeCollectionProvider_GetCollection(This,uCount,prgProperty,pcGUIDsOut)	\
    (This)->lpVtbl -> GetCollection(This,uCount,prgProperty,pcGUIDsOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollectionCount_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollectionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollection_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
    /* [out] */ ULONG *pcGUIDsOut);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0228 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0228_0001
    {
    ITfRange *pRange;
    TF_DISPLAYATTRIBUTE tfDisplayAttr;
    } 	TF_RENDERINGMARKUP;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0228_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0228_v0_0_s_ifspec;

#ifndef __IEnumTfRenderingMarkup_INTERFACE_DEFINED__
#define __IEnumTfRenderingMarkup_INTERFACE_DEFINED__

/* interface IEnumTfRenderingMarkup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c03d21b-95a7-4ba0-ae1b-7fce12a72930")
    IEnumTfRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRenderingMarkup **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRenderingMarkup * This,
            /* [out] */ IEnumTfRenderingMarkup **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRenderingMarkupVtbl;

    interface IEnumTfRenderingMarkup
    {
        CONST_VTBL struct IEnumTfRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRenderingMarkup_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfRenderingMarkup_Next(This,ulCount,rgMarkup,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgMarkup,pcFetched)

#define IEnumTfRenderingMarkup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRenderingMarkup_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Clone_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [out] */ IEnumTfRenderingMarkup **ppClone);


void __RPC_STUB IEnumTfRenderingMarkup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Next_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRenderingMarkup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Reset_Proxy( 
    IEnumTfRenderingMarkup * This);


void __RPC_STUB IEnumTfRenderingMarkup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Skip_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfRenderingMarkup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_INTERFACE_DEFINED__
#define __ITfContextRenderingMarkup_INTERFACE_DEFINED__

/* interface ITfContextRenderingMarkup */
/* [unique][uuid][object] */ 

#define	TF_GRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_BACKWARD	( 0x2 )

#define	TF_FRM_NO_CONTAINED	( 0x4 )

#define	TF_FRM_NO_RANGE	( 0x8 )


EXTERN_C const IID IID_ITfContextRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a305b1c0-c776-4523-bda0-7c5a2e0fef10")
    ITfContextRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);
        
        END_INTERFACE
    } ITfContextRenderingMarkupVtbl;

    interface ITfContextRenderingMarkup
    {
        CONST_VTBL struct ITfContextRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextRenderingMarkup_GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)	\
    (This)->lpVtbl -> GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)

#define ITfContextRenderingMarkup_FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)	\
    (This)->lpVtbl -> FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_GetRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeCover,
    /* [out] */ IEnumTfRenderingMarkup **ppEnum);


void __RPC_STUB ITfContextRenderingMarkup_GetRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_FindNextRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [out] */ ITfRange **ppRangeFound,
    /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);


void __RPC_STUB ITfContextRenderingMarkup_FindNextRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_INTERFACE_DEFINED__
#define __ITfBackgroundThreadMgr_INTERFACE_DEFINED__

/* interface ITfBackgroundThreadMgr */
/* [unique][uuid][local][object] */ 

typedef BOOL ( *TfBackgroundThreadCallback )( 
    /* [in] */ BOOL fCleanup,
    /* [in] */ void *pvPrivate);

typedef BOOL ( *TfWakeAppBackgroundThreadProc )( void);


EXTERN_C const IID IID_ITfBackgroundThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38462b47-6127-4464-bd2f-46957c31ad0e")
    ITfBackgroundThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppInitBackgroundThread( 
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppUninitBackgroundThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseBackgroundCallback( 
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseBackgroundCallback( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WakeBackgroundThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfBackgroundThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfBackgroundThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppInitBackgroundThread )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *AppUninitBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *WakeBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        END_INTERFACE
    } ITfBackgroundThreadMgrVtbl;

    interface ITfBackgroundThreadMgr
    {
        CONST_VTBL struct ITfBackgroundThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfBackgroundThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfBackgroundThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfBackgroundThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfBackgroundThreadMgr_AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)	\
    (This)->lpVtbl -> AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)

#define ITfBackgroundThreadMgr_AppUninitBackgroundThread(This)	\
    (This)->lpVtbl -> AppUninitBackgroundThread(This)

#define ITfBackgroundThreadMgr_AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)	\
    (This)->lpVtbl -> AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)

#define ITfBackgroundThreadMgr_UnadviseBackgroundCallback(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseBackgroundCallback(This,dwCookie)

#define ITfBackgroundThreadMgr_WakeBackgroundThread(This)	\
    (This)->lpVtbl -> WakeBackgroundThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppInitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
    /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
    /* [out] */ void **ppvPrivate);


void __RPC_STUB ITfBackgroundThreadMgr_AppInitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppUninitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_AppUninitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AdviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfBackgroundThreadCallback pfnCallback,
    /* [in] */ void *pvPrivate,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_AdviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_WakeBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_WakeBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfBackgroundThreadMgr_INTERFACE_DEFINED__ */


#ifndef __ITfEnableService_INTERFACE_DEFINED__
#define __ITfEnableService_INTERFACE_DEFINED__

/* interface ITfEnableService */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfEnableService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3035d250-43b4-4253-81e6-ea87fd3eed43")
    ITfEnableService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [in] */ REFGUID rguidServiceCategory,
            /* [in] */ CLSID clsidService,
            /* [in] */ IUnknown *punkService,
            /* [out] */ BOOL *pfOkToRun) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ GUID *pguidId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEnableServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEnableService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEnableService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEnableService * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            ITfEnableService * This,
            /* [in] */ REFGUID rguidServiceCategory,
            /* [in] */ CLSID clsidService,
            /* [in] */ IUnknown *punkService,
            /* [out] */ BOOL *pfOkToRun);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            ITfEnableService * This,
            /* [out] */ GUID *pguidId);
        
        END_INTERFACE
    } ITfEnableServiceVtbl;

    interface ITfEnableService
    {
        CONST_VTBL struct ITfEnableServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEnableService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEnableService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEnableService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEnableService_IsEnabled(This,rguidServiceCategory,clsidService,punkService,pfOkToRun)	\
    (This)->lpVtbl -> IsEnabled(This,rguidServiceCategory,clsidService,punkService,pfOkToRun)

#define ITfEnableService_GetId(This,pguidId)	\
    (This)->lpVtbl -> GetId(This,pguidId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEnableService_IsEnabled_Proxy( 
    ITfEnableService * This,
    /* [in] */ REFGUID rguidServiceCategory,
    /* [in] */ CLSID clsidService,
    /* [in] */ IUnknown *punkService,
    /* [out] */ BOOL *pfOkToRun);


void __RPC_STUB ITfEnableService_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEnableService_GetId_Proxy( 
    ITfEnableService * This,
    /* [out] */ GUID *pguidId);


void __RPC_STUB ITfEnableService_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEnableService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0232 */
/* [local] */ 

EXTERN_C const GUID GUID_COMPARTMENT_ENABLESTATE;
#endif // MSCTFP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\msctf.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctf_h__
#define __msctf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_FWD_DEFINED__
#define __ITfThreadMgr_FWD_DEFINED__
typedef interface ITfThreadMgr ITfThreadMgr;
#endif 	/* __ITfThreadMgr_FWD_DEFINED__ */


#ifndef __ITfThreadMgrEventSink_FWD_DEFINED__
#define __ITfThreadMgrEventSink_FWD_DEFINED__
typedef interface ITfThreadMgrEventSink ITfThreadMgrEventSink;
#endif 	/* __ITfThreadMgrEventSink_FWD_DEFINED__ */


#ifndef __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__
#define __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__
typedef interface ITfConfigureSystemKeystrokeFeed ITfConfigureSystemKeystrokeFeed;
#endif 	/* __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__ */


#ifndef __IEnumTfDocumentMgrs_FWD_DEFINED__
#define __IEnumTfDocumentMgrs_FWD_DEFINED__
typedef interface IEnumTfDocumentMgrs IEnumTfDocumentMgrs;
#endif 	/* __IEnumTfDocumentMgrs_FWD_DEFINED__ */


#ifndef __ITfDocumentMgr_FWD_DEFINED__
#define __ITfDocumentMgr_FWD_DEFINED__
typedef interface ITfDocumentMgr ITfDocumentMgr;
#endif 	/* __ITfDocumentMgr_FWD_DEFINED__ */


#ifndef __IEnumTfContexts_FWD_DEFINED__
#define __IEnumTfContexts_FWD_DEFINED__
typedef interface IEnumTfContexts IEnumTfContexts;
#endif 	/* __IEnumTfContexts_FWD_DEFINED__ */


#ifndef __ITfCompositionView_FWD_DEFINED__
#define __ITfCompositionView_FWD_DEFINED__
typedef interface ITfCompositionView ITfCompositionView;
#endif 	/* __ITfCompositionView_FWD_DEFINED__ */


#ifndef __IEnumITfCompositionView_FWD_DEFINED__
#define __IEnumITfCompositionView_FWD_DEFINED__
typedef interface IEnumITfCompositionView IEnumITfCompositionView;
#endif 	/* __IEnumITfCompositionView_FWD_DEFINED__ */


#ifndef __ITfComposition_FWD_DEFINED__
#define __ITfComposition_FWD_DEFINED__
typedef interface ITfComposition ITfComposition;
#endif 	/* __ITfComposition_FWD_DEFINED__ */


#ifndef __ITfCompositionSink_FWD_DEFINED__
#define __ITfCompositionSink_FWD_DEFINED__
typedef interface ITfCompositionSink ITfCompositionSink;
#endif 	/* __ITfCompositionSink_FWD_DEFINED__ */


#ifndef __ITfContextComposition_FWD_DEFINED__
#define __ITfContextComposition_FWD_DEFINED__
typedef interface ITfContextComposition ITfContextComposition;
#endif 	/* __ITfContextComposition_FWD_DEFINED__ */


#ifndef __ITfContextOwnerCompositionServices_FWD_DEFINED__
#define __ITfContextOwnerCompositionServices_FWD_DEFINED__
typedef interface ITfContextOwnerCompositionServices ITfContextOwnerCompositionServices;
#endif 	/* __ITfContextOwnerCompositionServices_FWD_DEFINED__ */


#ifndef __ITfContextOwnerCompositionSink_FWD_DEFINED__
#define __ITfContextOwnerCompositionSink_FWD_DEFINED__
typedef interface ITfContextOwnerCompositionSink ITfContextOwnerCompositionSink;
#endif 	/* __ITfContextOwnerCompositionSink_FWD_DEFINED__ */


#ifndef __ITfContextView_FWD_DEFINED__
#define __ITfContextView_FWD_DEFINED__
typedef interface ITfContextView ITfContextView;
#endif 	/* __ITfContextView_FWD_DEFINED__ */


#ifndef __IEnumTfContextViews_FWD_DEFINED__
#define __IEnumTfContextViews_FWD_DEFINED__
typedef interface IEnumTfContextViews IEnumTfContextViews;
#endif 	/* __IEnumTfContextViews_FWD_DEFINED__ */


#ifndef __ITfContext_FWD_DEFINED__
#define __ITfContext_FWD_DEFINED__
typedef interface ITfContext ITfContext;
#endif 	/* __ITfContext_FWD_DEFINED__ */


#ifndef __ITfQueryEmbedded_FWD_DEFINED__
#define __ITfQueryEmbedded_FWD_DEFINED__
typedef interface ITfQueryEmbedded ITfQueryEmbedded;
#endif 	/* __ITfQueryEmbedded_FWD_DEFINED__ */


#ifndef __ITfInsertAtSelection_FWD_DEFINED__
#define __ITfInsertAtSelection_FWD_DEFINED__
typedef interface ITfInsertAtSelection ITfInsertAtSelection;
#endif 	/* __ITfInsertAtSelection_FWD_DEFINED__ */


#ifndef __ITfCleanupContextSink_FWD_DEFINED__
#define __ITfCleanupContextSink_FWD_DEFINED__
typedef interface ITfCleanupContextSink ITfCleanupContextSink;
#endif 	/* __ITfCleanupContextSink_FWD_DEFINED__ */


#ifndef __ITfCleanupContextDurationSink_FWD_DEFINED__
#define __ITfCleanupContextDurationSink_FWD_DEFINED__
typedef interface ITfCleanupContextDurationSink ITfCleanupContextDurationSink;
#endif 	/* __ITfCleanupContextDurationSink_FWD_DEFINED__ */


#ifndef __ITfReadOnlyProperty_FWD_DEFINED__
#define __ITfReadOnlyProperty_FWD_DEFINED__
typedef interface ITfReadOnlyProperty ITfReadOnlyProperty;
#endif 	/* __ITfReadOnlyProperty_FWD_DEFINED__ */


#ifndef __IEnumTfPropertyValue_FWD_DEFINED__
#define __IEnumTfPropertyValue_FWD_DEFINED__
typedef interface IEnumTfPropertyValue IEnumTfPropertyValue;
#endif 	/* __IEnumTfPropertyValue_FWD_DEFINED__ */


#ifndef __ITfMouseTracker_FWD_DEFINED__
#define __ITfMouseTracker_FWD_DEFINED__
typedef interface ITfMouseTracker ITfMouseTracker;
#endif 	/* __ITfMouseTracker_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerACP_FWD_DEFINED__
#define __ITfMouseTrackerACP_FWD_DEFINED__
typedef interface ITfMouseTrackerACP ITfMouseTrackerACP;
#endif 	/* __ITfMouseTrackerACP_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfMouseSink_FWD_DEFINED__
#define __ITfMouseSink_FWD_DEFINED__
typedef interface ITfMouseSink ITfMouseSink;
#endif 	/* __ITfMouseSink_FWD_DEFINED__ */


#ifndef __ITfEditRecord_FWD_DEFINED__
#define __ITfEditRecord_FWD_DEFINED__
typedef interface ITfEditRecord ITfEditRecord;
#endif 	/* __ITfEditRecord_FWD_DEFINED__ */


#ifndef __ITfTextEditSink_FWD_DEFINED__
#define __ITfTextEditSink_FWD_DEFINED__
typedef interface ITfTextEditSink ITfTextEditSink;
#endif 	/* __ITfTextEditSink_FWD_DEFINED__ */


#ifndef __ITfTextLayoutSink_FWD_DEFINED__
#define __ITfTextLayoutSink_FWD_DEFINED__
typedef interface ITfTextLayoutSink ITfTextLayoutSink;
#endif 	/* __ITfTextLayoutSink_FWD_DEFINED__ */


#ifndef __ITfStatusSink_FWD_DEFINED__
#define __ITfStatusSink_FWD_DEFINED__
typedef interface ITfStatusSink ITfStatusSink;
#endif 	/* __ITfStatusSink_FWD_DEFINED__ */


#ifndef __ITfEditTransactionSink_FWD_DEFINED__
#define __ITfEditTransactionSink_FWD_DEFINED__
typedef interface ITfEditTransactionSink ITfEditTransactionSink;
#endif 	/* __ITfEditTransactionSink_FWD_DEFINED__ */


#ifndef __ITfContextOwner_FWD_DEFINED__
#define __ITfContextOwner_FWD_DEFINED__
typedef interface ITfContextOwner ITfContextOwner;
#endif 	/* __ITfContextOwner_FWD_DEFINED__ */


#ifndef __ITfContextOwnerServices_FWD_DEFINED__
#define __ITfContextOwnerServices_FWD_DEFINED__
typedef interface ITfContextOwnerServices ITfContextOwnerServices;
#endif 	/* __ITfContextOwnerServices_FWD_DEFINED__ */


#ifndef __ITfContextKeyEventSink_FWD_DEFINED__
#define __ITfContextKeyEventSink_FWD_DEFINED__
typedef interface ITfContextKeyEventSink ITfContextKeyEventSink;
#endif 	/* __ITfContextKeyEventSink_FWD_DEFINED__ */


#ifndef __ITfEditSession_FWD_DEFINED__
#define __ITfEditSession_FWD_DEFINED__
typedef interface ITfEditSession ITfEditSession;
#endif 	/* __ITfEditSession_FWD_DEFINED__ */


#ifndef __IEnumTfTextDeltas_FWD_DEFINED__
#define __IEnumTfTextDeltas_FWD_DEFINED__
typedef interface IEnumTfTextDeltas IEnumTfTextDeltas;
#endif 	/* __IEnumTfTextDeltas_FWD_DEFINED__ */


#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */


#ifndef __ITfRangeACP_FWD_DEFINED__
#define __ITfRangeACP_FWD_DEFINED__
typedef interface ITfRangeACP ITfRangeACP;
#endif 	/* __ITfRangeACP_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreACPServices_FWD_DEFINED__
#define __ITextStoreACPServices_FWD_DEFINED__
typedef interface ITextStoreACPServices ITextStoreACPServices;
#endif 	/* __ITextStoreACPServices_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfRangeBackup_FWD_DEFINED__
#define __ITfRangeBackup_FWD_DEFINED__
typedef interface ITfRangeBackup ITfRangeBackup;
#endif 	/* __ITfRangeBackup_FWD_DEFINED__ */


#ifndef __ITfPropertyStore_FWD_DEFINED__
#define __ITfPropertyStore_FWD_DEFINED__
typedef interface ITfPropertyStore ITfPropertyStore;
#endif 	/* __ITfPropertyStore_FWD_DEFINED__ */


#ifndef __IEnumTfRanges_FWD_DEFINED__
#define __IEnumTfRanges_FWD_DEFINED__
typedef interface IEnumTfRanges IEnumTfRanges;
#endif 	/* __IEnumTfRanges_FWD_DEFINED__ */


#ifndef __ITfCreatePropertyStore_FWD_DEFINED__
#define __ITfCreatePropertyStore_FWD_DEFINED__
typedef interface ITfCreatePropertyStore ITfCreatePropertyStore;
#endif 	/* __ITfCreatePropertyStore_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderACP_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderACP_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderACP ITfPersistentPropertyLoaderACP;
#endif 	/* __ITfPersistentPropertyLoaderACP_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITfProperty_FWD_DEFINED__
#define __ITfProperty_FWD_DEFINED__
typedef interface ITfProperty ITfProperty;
#endif 	/* __ITfProperty_FWD_DEFINED__ */


#ifndef __IEnumTfProperties_FWD_DEFINED__
#define __IEnumTfProperties_FWD_DEFINED__
typedef interface IEnumTfProperties IEnumTfProperties;
#endif 	/* __IEnumTfProperties_FWD_DEFINED__ */


#ifndef __ITfCompartment_FWD_DEFINED__
#define __ITfCompartment_FWD_DEFINED__
typedef interface ITfCompartment ITfCompartment;
#endif 	/* __ITfCompartment_FWD_DEFINED__ */


#ifndef __ITfCompartmentEventSink_FWD_DEFINED__
#define __ITfCompartmentEventSink_FWD_DEFINED__
typedef interface ITfCompartmentEventSink ITfCompartmentEventSink;
#endif 	/* __ITfCompartmentEventSink_FWD_DEFINED__ */


#ifndef __ITfCompartmentMgr_FWD_DEFINED__
#define __ITfCompartmentMgr_FWD_DEFINED__
typedef interface ITfCompartmentMgr ITfCompartmentMgr;
#endif 	/* __ITfCompartmentMgr_FWD_DEFINED__ */


#ifndef __ITfFunction_FWD_DEFINED__
#define __ITfFunction_FWD_DEFINED__
typedef interface ITfFunction ITfFunction;
#endif 	/* __ITfFunction_FWD_DEFINED__ */


#ifndef __ITfFunctionProvider_FWD_DEFINED__
#define __ITfFunctionProvider_FWD_DEFINED__
typedef interface ITfFunctionProvider ITfFunctionProvider;
#endif 	/* __ITfFunctionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfFunctionProviders_FWD_DEFINED__
#define __IEnumTfFunctionProviders_FWD_DEFINED__
typedef interface IEnumTfFunctionProviders IEnumTfFunctionProviders;
#endif 	/* __IEnumTfFunctionProviders_FWD_DEFINED__ */


#ifndef __ITfInputProcessorProfiles_FWD_DEFINED__
#define __ITfInputProcessorProfiles_FWD_DEFINED__
typedef interface ITfInputProcessorProfiles ITfInputProcessorProfiles;
#endif 	/* __ITfInputProcessorProfiles_FWD_DEFINED__ */


#ifndef __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__
#define __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__
typedef interface ITfActiveLanguageProfileNotifySink ITfActiveLanguageProfileNotifySink;
#endif 	/* __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__ */


#ifndef __IEnumTfLanguageProfiles_FWD_DEFINED__
#define __IEnumTfLanguageProfiles_FWD_DEFINED__
typedef interface IEnumTfLanguageProfiles IEnumTfLanguageProfiles;
#endif 	/* __IEnumTfLanguageProfiles_FWD_DEFINED__ */


#ifndef __ITfLanguageProfileNotifySink_FWD_DEFINED__
#define __ITfLanguageProfileNotifySink_FWD_DEFINED__
typedef interface ITfLanguageProfileNotifySink ITfLanguageProfileNotifySink;
#endif 	/* __ITfLanguageProfileNotifySink_FWD_DEFINED__ */


#ifndef __ITfKeystrokeMgr_FWD_DEFINED__
#define __ITfKeystrokeMgr_FWD_DEFINED__
typedef interface ITfKeystrokeMgr ITfKeystrokeMgr;
#endif 	/* __ITfKeystrokeMgr_FWD_DEFINED__ */


#ifndef __ITfKeyEventSink_FWD_DEFINED__
#define __ITfKeyEventSink_FWD_DEFINED__
typedef interface ITfKeyEventSink ITfKeyEventSink;
#endif 	/* __ITfKeyEventSink_FWD_DEFINED__ */


#ifndef __ITfKeyTraceEventSink_FWD_DEFINED__
#define __ITfKeyTraceEventSink_FWD_DEFINED__
typedef interface ITfKeyTraceEventSink ITfKeyTraceEventSink;
#endif 	/* __ITfKeyTraceEventSink_FWD_DEFINED__ */


#ifndef __ITfPreservedKeyNotifySink_FWD_DEFINED__
#define __ITfPreservedKeyNotifySink_FWD_DEFINED__
typedef interface ITfPreservedKeyNotifySink ITfPreservedKeyNotifySink;
#endif 	/* __ITfPreservedKeyNotifySink_FWD_DEFINED__ */


#ifndef __ITfMessagePump_FWD_DEFINED__
#define __ITfMessagePump_FWD_DEFINED__
typedef interface ITfMessagePump ITfMessagePump;
#endif 	/* __ITfMessagePump_FWD_DEFINED__ */


#ifndef __ITfThreadFocusSink_FWD_DEFINED__
#define __ITfThreadFocusSink_FWD_DEFINED__
typedef interface ITfThreadFocusSink ITfThreadFocusSink;
#endif 	/* __ITfThreadFocusSink_FWD_DEFINED__ */


#ifndef __ITfTextInputProcessor_FWD_DEFINED__
#define __ITfTextInputProcessor_FWD_DEFINED__
typedef interface ITfTextInputProcessor ITfTextInputProcessor;
#endif 	/* __ITfTextInputProcessor_FWD_DEFINED__ */


#ifndef __ITfClientId_FWD_DEFINED__
#define __ITfClientId_FWD_DEFINED__
typedef interface ITfClientId ITfClientId;
#endif 	/* __ITfClientId_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeInfo_FWD_DEFINED__
#define __ITfDisplayAttributeInfo_FWD_DEFINED__
typedef interface ITfDisplayAttributeInfo ITfDisplayAttributeInfo;
#endif 	/* __ITfDisplayAttributeInfo_FWD_DEFINED__ */


#ifndef __IEnumTfDisplayAttributeInfo_FWD_DEFINED__
#define __IEnumTfDisplayAttributeInfo_FWD_DEFINED__
typedef interface IEnumTfDisplayAttributeInfo IEnumTfDisplayAttributeInfo;
#endif 	/* __IEnumTfDisplayAttributeInfo_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeProvider_FWD_DEFINED__
#define __ITfDisplayAttributeProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeProvider ITfDisplayAttributeProvider;
#endif 	/* __ITfDisplayAttributeProvider_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeMgr_FWD_DEFINED__
#define __ITfDisplayAttributeMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeMgr ITfDisplayAttributeMgr;
#endif 	/* __ITfDisplayAttributeMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeNotifySink_FWD_DEFINED__
#define __ITfDisplayAttributeNotifySink_FWD_DEFINED__
typedef interface ITfDisplayAttributeNotifySink ITfDisplayAttributeNotifySink;
#endif 	/* __ITfDisplayAttributeNotifySink_FWD_DEFINED__ */


#ifndef __ITfCategoryMgr_FWD_DEFINED__
#define __ITfCategoryMgr_FWD_DEFINED__
typedef interface ITfCategoryMgr ITfCategoryMgr;
#endif 	/* __ITfCategoryMgr_FWD_DEFINED__ */


#ifndef __ITfSource_FWD_DEFINED__
#define __ITfSource_FWD_DEFINED__
typedef interface ITfSource ITfSource;
#endif 	/* __ITfSource_FWD_DEFINED__ */


#ifndef __ITfSourceSingle_FWD_DEFINED__
#define __ITfSourceSingle_FWD_DEFINED__
typedef interface ITfSourceSingle ITfSourceSingle;
#endif 	/* __ITfSourceSingle_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "comcat.h"
#include "textstor.h"
#include "ctfutb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctf_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctf.h


// CTF declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef MSCTF_DEFINED
#define MSCTF_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define TF_E_LOCKED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0500)
#define TF_E_STACKFULL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0501)
#define TF_E_NOTOWNEDRANGE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0502)
#define TF_E_NOPROVIDER      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0503)
#define TF_E_DISCONNECTED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0504)
#define TF_E_INVALIDVIEW     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0505)
#define TF_E_ALREADY_EXISTS  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0506)
#define TF_E_RANGE_NOT_COVERED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0507)
#define TF_E_COMPOSITION_REJECTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0508)
#define TF_E_INVALIDPOS      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define TF_E_NOLOCK          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define TF_E_NOOBJECT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define TF_E_NOSERVICE       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define TF_E_NOINTERFACE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define TF_E_NOSELECTION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define TF_E_NOLAYOUT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define TF_E_INVALIDPOINT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define TF_E_SYNCHRONOUS     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define TF_E_READONLY        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define TF_E_FORMAT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020a)
#define TF_E_EMPTYCONTEXT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020a)
#define TF_S_ASYNC           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0300)

HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim);
HRESULT WINAPI TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles **ppipr);
HRESULT WINAPI TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr **ppdam);
HRESULT WINAPI TF_CreateLangBarMgr(ITfLangBarMgr **pppbm);
HRESULT WINAPI TF_CreateLangBarItemMgr(ITfLangBarItemMgr **pplbim);

EXTERN_C const GUID GUID_PROP_TEXTOWNER;
EXTERN_C const GUID GUID_PROP_ATTRIBUTE;
EXTERN_C const GUID GUID_PROP_LANGID;
EXTERN_C const GUID GUID_PROP_READING;
EXTERN_C const GUID GUID_PROP_COMPOSING;

EXTERN_C const CLSID CLSID_TF_ThreadMgr;
EXTERN_C const CLSID CLSID_TF_InputProcessorProfiles;
EXTERN_C const CLSID CLSID_TF_LangBarMgr;
EXTERN_C const CLSID CLSID_TF_DisplayAttributeMgr;
EXTERN_C const CLSID CLSID_TF_CategoryMgr;
EXTERN_C const CLSID CLSID_TF_LangBarItemMgr;
EXTERN_C const GUID GUID_SYSTEM_FUNCTIONPROVIDER;
EXTERN_C const GUID GUID_APP_FUNCTIONPROVIDER;

EXTERN_C const GUID GUID_SERVICE_CTF;

EXTERN_C const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED;
EXTERN_C const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_DISABLED;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_PERSISTMENUENABLED;
EXTERN_C const GUID GUID_COMPARTMENT_EMPTYCONTEXT;
EXTERN_C const GUID GUID_COMPARTMENT_TIPUISTATUS;

EXTERN_C const GUID GUID_PROP_MODEBIAS;

EXTERN_C const GUID GUID_MODEBIAS_NONE;
EXTERN_C const GUID GUID_MODEBIAS_FILENAME;
EXTERN_C const GUID GUID_MODEBIAS_READING;
EXTERN_C const GUID GUID_MODEBIAS_DATETIME;
EXTERN_C const GUID GUID_MODEBIAS_NAME;
EXTERN_C const GUID GUID_MODEBIAS_CONVERSATION;
EXTERN_C const GUID GUID_MODEBIAS_NUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_HIRAGANA;
EXTERN_C const GUID GUID_MODEBIAS_KATAKANA;
EXTERN_C const GUID GUID_MODEBIAS_HANGUL;
EXTERN_C const GUID GUID_MODEBIAS_CHINESE;
EXTERN_C const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA;
EXTERN_C const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_FULLWIDTHHANGUL;
EXTERN_C const GUID GUID_TFCAT_CATEGORY_OF_TIP;
EXTERN_C const GUID GUID_TFCAT_TIP_KEYBOARD;
EXTERN_C const GUID GUID_TFCAT_TIP_SPEECH;
EXTERN_C const GUID GUID_TFCAT_TIP_HANDWRITING;
EXTERN_C const GUID GUID_TFCAT_TIP_LOOKUP;
EXTERN_C const GUID GUID_TFCAT_PROP_AUDIODATA;
EXTERN_C const GUID GUID_TFCAT_PROP_INKDATA;

EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_STATIC;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT;

EXTERN_C const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER;
EXTERN_C const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY;

#define TF_INVALID_GUIDATOM ((TfGuidAtom)0)
#define TF_CLIENTID_NULL    ((TfClientId)0)

#define TF_MOD_ALT                         0x0001
#define TF_MOD_CONTROL                     0x0002
#define TF_MOD_SHIFT                       0x0004
#define TF_MOD_RALT                        0x0008
#define TF_MOD_RCONTROL                    0x0010
#define TF_MOD_RSHIFT                      0x0020
#define TF_MOD_LALT                        0x0040
#define TF_MOD_LCONTROL                    0x0080
#define TF_MOD_LSHIFT                      0x0100
#define TF_MOD_ON_KEYUP                    0x0200
#define TF_MOD_IGNORE_ALL_MODIFIER         0x0400

#define TF_US_HIDETIPUI         0x00000001

#define TF_DISABLE_SPEECH         0x00000001
#define TF_DISABLE_DICTATION      0x00000002
#define TF_DISABLE_COMMANDING     0x00000004

#define CTF_PROCESS_ATOM             TEXT("_CTF_PROCESS_ATOM_")
#define CTF_ENABLE_PROCESS_ATOM      TEXT("_CTF_ENABLE_PROCESS_ATOM_")
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if 0
typedef /* [uuid] */  DECLSPEC_UUID("4f5d560f-5ab5-4dde-8c4d-404592857ab0") UINT_PTR HKL;

#endif



























typedef /* [uuid] */  DECLSPEC_UUID("7213778c-7bb0-4270-b050-6189ee594e97") DWORD TfEditCookie;

#define	TF_INVALID_EDIT_COOKIE	( 0 )

typedef /* [uuid] */  DECLSPEC_UUID("88a9c478-f3ec-4763-8345-cd9250443f8d") DWORD TfGuidAtom;

typedef /* [uuid] */  DECLSPEC_UUID("de403c21-89fd-4f85-8b87-64584d063fbc") DWORD TfClientId;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("01f46108-9d8a-4aef-94dd-1c4df6acd4eb") 
enum __MIDL___MIDL_itf_msctf_0000_0001
    {	TF_PT_NONE	= 0,
	TF_PT_UNKNOWN	= 1,
	TF_PT_DWORD	= 2,
	TF_PT_GUID	= 3,
	TF_PT_BSTR	= 4
    } 	TfPropertyType;

typedef /* [uuid] */  DECLSPEC_UUID("e26d9e1d-691e-4f29-90d7-338dcf1f8cef") struct TF_PERSISTENT_PROPERTY_HEADER_ACP
    {
    GUID guidType;
    LONG ichStart;
    LONG cch;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ACP;

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;

typedef /* [uuid] */  DECLSPEC_UUID("e1b5808d-1e46-4c19-84dc-68c5f5978cc8") struct TF_LANGUAGEPROFILE
    {
    CLSID clsid;
    LANGID langid;
    GUID catid;
    BOOL fActive;
    GUID guidProfile;
    } 	TF_LANGUAGEPROFILE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("5a886226-ae9a-489b-b991-2b1e25ee59a9") 
enum __MIDL___MIDL_itf_msctf_0000_0002
    {	TF_ANCHOR_START	= 0,
	TF_ANCHOR_END	= 1
    } 	TfAnchor;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_INTERFACE_DEFINED__
#define __ITfThreadMgr_INTERFACE_DEFINED__

/* interface ITfThreadMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e801-2021-11d2-93e0-0060b067b86e")
    ITfThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [out] */ TfClientId *ptid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentMgr( 
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDocumentMgrs( 
            /* [out] */ IEnumTfDocumentMgrs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocus( 
            /* [out] */ ITfDocumentMgr **ppdimFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ ITfDocumentMgr *pdimFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateFocus( 
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsThreadFocus( 
            /* [out] */ BOOL *pfThreadFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionProvider( 
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFunctionProviders( 
            /* [out] */ IEnumTfFunctionProviders **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalCompartment( 
            /* [out] */ ITfCompartmentMgr **ppCompMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        END_INTERFACE
    } ITfThreadMgrVtbl;

    interface ITfThreadMgr
    {
        CONST_VTBL struct ITfThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_Activate_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ TfClientId *ptid);


void __RPC_STUB ITfThreadMgr_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_Deactivate_Proxy( 
    ITfThreadMgr * This);


void __RPC_STUB ITfThreadMgr_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_CreateDocumentMgr_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_CreateDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_EnumDocumentMgrs_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ IEnumTfDocumentMgrs **ppEnum);


void __RPC_STUB ITfThreadMgr_EnumDocumentMgrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetFocus_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfDocumentMgr **ppdimFocus);


void __RPC_STUB ITfThreadMgr_GetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_SetFocus_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ ITfDocumentMgr *pdimFocus);


void __RPC_STUB ITfThreadMgr_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_AssociateFocus_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ HWND hwnd,
    /* [unique][in] */ ITfDocumentMgr *pdimNew,
    /* [out] */ ITfDocumentMgr **ppdimPrev);


void __RPC_STUB ITfThreadMgr_AssociateFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_IsThreadFocus_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ BOOL *pfThreadFocus);


void __RPC_STUB ITfThreadMgr_IsThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetFunctionProvider_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ REFCLSID clsid,
    /* [out] */ ITfFunctionProvider **ppFuncProv);


void __RPC_STUB ITfThreadMgr_GetFunctionProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_EnumFunctionProviders_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ IEnumTfFunctionProviders **ppEnum);


void __RPC_STUB ITfThreadMgr_EnumFunctionProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetGlobalCompartment_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfCompartmentMgr **ppCompMgr);


void __RPC_STUB ITfThreadMgr_GetGlobalCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_INTERFACE_DEFINED__ */


#ifndef __ITfThreadMgrEventSink_INTERFACE_DEFINED__
#define __ITfThreadMgrEventSink_INTERFACE_DEFINED__

/* interface ITfThreadMgrEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgrEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e80e-2021-11d2-93e0-0060b067b86e")
    ITfThreadMgrEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnInitDocumentMgr( 
            /* [in] */ ITfDocumentMgr *pdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUninitDocumentMgr( 
            /* [in] */ ITfDocumentMgr *pdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ ITfDocumentMgr *pdimFocus,
            /* [in] */ ITfDocumentMgr *pdimPrevFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPushContext( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPopContext( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgrEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgrEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgrEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnInitDocumentMgr )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdim);
        
        HRESULT ( STDMETHODCALLTYPE *OnUninitDocumentMgr )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdim);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdimFocus,
            /* [in] */ ITfDocumentMgr *pdimPrevFocus);
        
        HRESULT ( STDMETHODCALLTYPE *OnPushContext )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *OnPopContext )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfThreadMgrEventSinkVtbl;

    interface ITfThreadMgrEventSink
    {
        CONST_VTBL struct ITfThreadMgrEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgrEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgrEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgrEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgrEventSink_OnInitDocumentMgr(This,pdim)	\
    (This)->lpVtbl -> OnInitDocumentMgr(This,pdim)

#define ITfThreadMgrEventSink_OnUninitDocumentMgr(This,pdim)	\
    (This)->lpVtbl -> OnUninitDocumentMgr(This,pdim)

#define ITfThreadMgrEventSink_OnSetFocus(This,pdimFocus,pdimPrevFocus)	\
    (This)->lpVtbl -> OnSetFocus(This,pdimFocus,pdimPrevFocus)

#define ITfThreadMgrEventSink_OnPushContext(This,pic)	\
    (This)->lpVtbl -> OnPushContext(This,pic)

#define ITfThreadMgrEventSink_OnPopContext(This,pic)	\
    (This)->lpVtbl -> OnPopContext(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnInitDocumentMgr_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdim);


void __RPC_STUB ITfThreadMgrEventSink_OnInitDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnUninitDocumentMgr_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdim);


void __RPC_STUB ITfThreadMgrEventSink_OnUninitDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnSetFocus_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdimFocus,
    /* [in] */ ITfDocumentMgr *pdimPrevFocus);


void __RPC_STUB ITfThreadMgrEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnPushContext_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgrEventSink_OnPushContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnPopContext_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgrEventSink_OnPopContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgrEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__
#define __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__

/* interface ITfConfigureSystemKeystrokeFeed */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfConfigureSystemKeystrokeFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d2c969a-bc9c-437c-84ee-951c49b1a764")
    ITfConfigureSystemKeystrokeFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisableSystemKeystrokeFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableSystemKeystrokeFeed( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfConfigureSystemKeystrokeFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfConfigureSystemKeystrokeFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisableSystemKeystrokeFeed )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableSystemKeystrokeFeed )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        END_INTERFACE
    } ITfConfigureSystemKeystrokeFeedVtbl;

    interface ITfConfigureSystemKeystrokeFeed
    {
        CONST_VTBL struct ITfConfigureSystemKeystrokeFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfConfigureSystemKeystrokeFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfConfigureSystemKeystrokeFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfConfigureSystemKeystrokeFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed(This)	\
    (This)->lpVtbl -> DisableSystemKeystrokeFeed(This)

#define ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed(This)	\
    (This)->lpVtbl -> EnableSystemKeystrokeFeed(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed_Proxy( 
    ITfConfigureSystemKeystrokeFeed * This);


void __RPC_STUB ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed_Proxy( 
    ITfConfigureSystemKeystrokeFeed * This);


void __RPC_STUB ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__ */


#ifndef __IEnumTfDocumentMgrs_INTERFACE_DEFINED__
#define __IEnumTfDocumentMgrs_INTERFACE_DEFINED__

/* interface IEnumTfDocumentMgrs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfDocumentMgrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e808-2021-11d2-93e0-0060b067b86e")
    IEnumTfDocumentMgrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfDocumentMgrs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfDocumentMgrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfDocumentMgrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfDocumentMgrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfDocumentMgrs * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfDocumentMgrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfDocumentMgrsVtbl;

    interface IEnumTfDocumentMgrs
    {
        CONST_VTBL struct IEnumTfDocumentMgrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfDocumentMgrs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfDocumentMgrs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfDocumentMgrs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfDocumentMgrs_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfDocumentMgrs_Next(This,ulCount,rgDocumentMgr,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgDocumentMgr,pcFetched)

#define IEnumTfDocumentMgrs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfDocumentMgrs_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Clone_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [out] */ IEnumTfDocumentMgrs **ppEnum);


void __RPC_STUB IEnumTfDocumentMgrs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Next_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfDocumentMgrs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Reset_Proxy( 
    IEnumTfDocumentMgrs * This);


void __RPC_STUB IEnumTfDocumentMgrs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Skip_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfDocumentMgrs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfDocumentMgrs_INTERFACE_DEFINED__ */


#ifndef __ITfDocumentMgr_INTERFACE_DEFINED__
#define __ITfDocumentMgr_INTERFACE_DEFINED__

/* interface ITfDocumentMgr */
/* [unique][uuid][object] */ 

#define	TF_PLAINTEXTTSI	( 0x1 )

#define	TF_POPF_ALL	( 0x1 )


EXTERN_C const IID IID_ITfDocumentMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f4-2021-11d2-93e0-0060b067b86e")
    ITfDocumentMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [in] */ TfClientId tidOwner,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ IUnknown *punk,
            /* [out] */ ITfContext **ppic,
            /* [out] */ TfEditCookie *pecTextStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Push( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pop( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTop( 
            /* [out] */ ITfContext **ppic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBase( 
            /* [out] */ ITfContext **ppic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContexts( 
            /* [out] */ IEnumTfContexts **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDocumentMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDocumentMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDocumentMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDocumentMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            ITfDocumentMgr * This,
            /* [in] */ TfClientId tidOwner,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ IUnknown *punk,
            /* [out] */ ITfContext **ppic,
            /* [out] */ TfEditCookie *pecTextStore);
        
        HRESULT ( STDMETHODCALLTYPE *Push )( 
            ITfDocumentMgr * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *Pop )( 
            ITfDocumentMgr * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetTop )( 
            ITfDocumentMgr * This,
            /* [out] */ ITfContext **ppic);
        
        HRESULT ( STDMETHODCALLTYPE *GetBase )( 
            ITfDocumentMgr * This,
            /* [out] */ ITfContext **ppic);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContexts )( 
            ITfDocumentMgr * This,
            /* [out] */ IEnumTfContexts **ppEnum);
        
        END_INTERFACE
    } ITfDocumentMgrVtbl;

    interface ITfDocumentMgr
    {
        CONST_VTBL struct ITfDocumentMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDocumentMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDocumentMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDocumentMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDocumentMgr_CreateContext(This,tidOwner,dwFlags,punk,ppic,pecTextStore)	\
    (This)->lpVtbl -> CreateContext(This,tidOwner,dwFlags,punk,ppic,pecTextStore)

#define ITfDocumentMgr_Push(This,pic)	\
    (This)->lpVtbl -> Push(This,pic)

#define ITfDocumentMgr_Pop(This,dwFlags)	\
    (This)->lpVtbl -> Pop(This,dwFlags)

#define ITfDocumentMgr_GetTop(This,ppic)	\
    (This)->lpVtbl -> GetTop(This,ppic)

#define ITfDocumentMgr_GetBase(This,ppic)	\
    (This)->lpVtbl -> GetBase(This,ppic)

#define ITfDocumentMgr_EnumContexts(This,ppEnum)	\
    (This)->lpVtbl -> EnumContexts(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDocumentMgr_CreateContext_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ TfClientId tidOwner,
    /* [in] */ DWORD dwFlags,
    /* [unique][in] */ IUnknown *punk,
    /* [out] */ ITfContext **ppic,
    /* [out] */ TfEditCookie *pecTextStore);


void __RPC_STUB ITfDocumentMgr_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_Push_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfDocumentMgr_Push_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_Pop_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfDocumentMgr_Pop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_GetTop_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ ITfContext **ppic);


void __RPC_STUB ITfDocumentMgr_GetTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_GetBase_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ ITfContext **ppic);


void __RPC_STUB ITfDocumentMgr_GetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_EnumContexts_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ IEnumTfContexts **ppEnum);


void __RPC_STUB ITfDocumentMgr_EnumContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDocumentMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumTfContexts_INTERFACE_DEFINED__
#define __IEnumTfContexts_INTERFACE_DEFINED__

/* interface IEnumTfContexts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f1a7ea6-1654-4502-a86e-b2902344d507")
    IEnumTfContexts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfContexts **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContext **rgContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfContexts * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfContexts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfContexts * This,
            /* [out] */ IEnumTfContexts **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfContexts * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContext **rgContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfContexts * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfContextsVtbl;

    interface IEnumTfContexts
    {
        CONST_VTBL struct IEnumTfContextsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfContexts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfContexts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfContexts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfContexts_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfContexts_Next(This,ulCount,rgContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgContext,pcFetched)

#define IEnumTfContexts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfContexts_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfContexts_Clone_Proxy( 
    IEnumTfContexts * This,
    /* [out] */ IEnumTfContexts **ppEnum);


void __RPC_STUB IEnumTfContexts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Next_Proxy( 
    IEnumTfContexts * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfContext **rgContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfContexts_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Reset_Proxy( 
    IEnumTfContexts * This);


void __RPC_STUB IEnumTfContexts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Skip_Proxy( 
    IEnumTfContexts * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfContexts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfContexts_INTERFACE_DEFINED__ */


#ifndef __ITfCompositionView_INTERFACE_DEFINED__
#define __ITfCompositionView_INTERFACE_DEFINED__

/* interface ITfCompositionView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompositionView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7540241-F9A1-4364-BEFC-DBCD2C4395B7")
    ITfCompositionView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwnerClsid( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [out] */ ITfRange **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompositionView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompositionView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerClsid )( 
            ITfCompositionView * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            ITfCompositionView * This,
            /* [out] */ ITfRange **ppRange);
        
        END_INTERFACE
    } ITfCompositionViewVtbl;

    interface ITfCompositionView
    {
        CONST_VTBL struct ITfCompositionViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompositionView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompositionView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompositionView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompositionView_GetOwnerClsid(This,pclsid)	\
    (This)->lpVtbl -> GetOwnerClsid(This,pclsid)

#define ITfCompositionView_GetRange(This,ppRange)	\
    (This)->lpVtbl -> GetRange(This,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompositionView_GetOwnerClsid_Proxy( 
    ITfCompositionView * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfCompositionView_GetOwnerClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompositionView_GetRange_Proxy( 
    ITfCompositionView * This,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfCompositionView_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompositionView_INTERFACE_DEFINED__ */


#ifndef __IEnumITfCompositionView_INTERFACE_DEFINED__
#define __IEnumITfCompositionView_INTERFACE_DEFINED__

/* interface IEnumITfCompositionView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumITfCompositionView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5EFD22BA-7838-46CB-88E2-CADB14124F8F")
    IEnumITfCompositionView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumITfCompositionViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumITfCompositionView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumITfCompositionView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumITfCompositionView * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumITfCompositionView * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumITfCompositionView * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumITfCompositionViewVtbl;

    interface IEnumITfCompositionView
    {
        CONST_VTBL struct IEnumITfCompositionViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumITfCompositionView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumITfCompositionView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumITfCompositionView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumITfCompositionView_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumITfCompositionView_Next(This,ulCount,rgCompositionView,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCompositionView,pcFetched)

#define IEnumITfCompositionView_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumITfCompositionView_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Clone_Proxy( 
    IEnumITfCompositionView * This,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB IEnumITfCompositionView_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Next_Proxy( 
    IEnumITfCompositionView * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumITfCompositionView_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Reset_Proxy( 
    IEnumITfCompositionView * This);


void __RPC_STUB IEnumITfCompositionView_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Skip_Proxy( 
    IEnumITfCompositionView * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumITfCompositionView_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumITfCompositionView_INTERFACE_DEFINED__ */


#ifndef __ITfComposition_INTERFACE_DEFINED__
#define __ITfComposition_INTERFACE_DEFINED__

/* interface ITfComposition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfComposition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20168D64-5A8F-4A5A-B7BD-CFA29F4D0FD9")
    ITfComposition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStart( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEnd( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndComposition( 
            /* [in] */ TfEditCookie ecWrite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfComposition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfComposition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfComposition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            ITfComposition * This,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewStart);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewEnd);
        
        HRESULT ( STDMETHODCALLTYPE *EndComposition )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite);
        
        END_INTERFACE
    } ITfCompositionVtbl;

    interface ITfComposition
    {
        CONST_VTBL struct ITfCompositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfComposition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfComposition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfComposition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfComposition_GetRange(This,ppRange)	\
    (This)->lpVtbl -> GetRange(This,ppRange)

#define ITfComposition_ShiftStart(This,ecWrite,pNewStart)	\
    (This)->lpVtbl -> ShiftStart(This,ecWrite,pNewStart)

#define ITfComposition_ShiftEnd(This,ecWrite,pNewEnd)	\
    (This)->lpVtbl -> ShiftEnd(This,ecWrite,pNewEnd)

#define ITfComposition_EndComposition(This,ecWrite)	\
    (This)->lpVtbl -> EndComposition(This,ecWrite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfComposition_GetRange_Proxy( 
    ITfComposition * This,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfComposition_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_ShiftStart_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pNewStart);


void __RPC_STUB ITfComposition_ShiftStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_ShiftEnd_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pNewEnd);


void __RPC_STUB ITfComposition_ShiftEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_EndComposition_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite);


void __RPC_STUB ITfComposition_EndComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfComposition_INTERFACE_DEFINED__ */


#ifndef __ITfCompositionSink_INTERFACE_DEFINED__
#define __ITfCompositionSink_INTERFACE_DEFINED__

/* interface ITfCompositionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompositionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A781718C-579A-4B15-A280-32B8577ACC5E")
    ITfCompositionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCompositionTerminated( 
            /* [in] */ TfEditCookie ecWrite,
            ITfComposition *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompositionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompositionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompositionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCompositionTerminated )( 
            ITfCompositionSink * This,
            /* [in] */ TfEditCookie ecWrite,
            ITfComposition *pComposition);
        
        END_INTERFACE
    } ITfCompositionSinkVtbl;

    interface ITfCompositionSink
    {
        CONST_VTBL struct ITfCompositionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompositionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompositionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompositionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompositionSink_OnCompositionTerminated(This,ecWrite,pComposition)	\
    (This)->lpVtbl -> OnCompositionTerminated(This,ecWrite,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompositionSink_OnCompositionTerminated_Proxy( 
    ITfCompositionSink * This,
    /* [in] */ TfEditCookie ecWrite,
    ITfComposition *pComposition);


void __RPC_STUB ITfCompositionSink_OnCompositionTerminated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompositionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextComposition_INTERFACE_DEFINED__
#define __ITfContextComposition_INTERFACE_DEFINED__

/* interface ITfContextComposition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextComposition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D40C8AAE-AC92-4FC7-9A11-0EE0E23AA39B")
    ITfContextComposition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartComposition( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCompositions( 
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindComposition( 
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TakeOwnerShip( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextCompositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextComposition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextComposition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextComposition * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartComposition )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompositions )( 
            ITfContextComposition * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindComposition )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnerShip )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        END_INTERFACE
    } ITfContextCompositionVtbl;

    interface ITfContextComposition
    {
        CONST_VTBL struct ITfContextCompositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextComposition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextComposition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextComposition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextComposition_StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)	\
    (This)->lpVtbl -> StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)

#define ITfContextComposition_EnumCompositions(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompositions(This,ppEnum)

#define ITfContextComposition_FindComposition(This,ecRead,pTestRange,ppEnum)	\
    (This)->lpVtbl -> FindComposition(This,ecRead,pTestRange,ppEnum)

#define ITfContextComposition_TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)	\
    (This)->lpVtbl -> TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextComposition_StartComposition_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pCompositionRange,
    /* [in] */ ITfCompositionSink *pSink,
    /* [out] */ ITfComposition **ppComposition);


void __RPC_STUB ITfContextComposition_StartComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_EnumCompositions_Proxy( 
    ITfContextComposition * This,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB ITfContextComposition_EnumCompositions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_FindComposition_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecRead,
    /* [in] */ ITfRange *pTestRange,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB ITfContextComposition_FindComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_TakeOwnerShip_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfCompositionView *pComposition,
    /* [in] */ ITfCompositionSink *pSink,
    /* [out] */ ITfComposition **ppComposition);


void __RPC_STUB ITfContextComposition_TakeOwnerShip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextComposition_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__
#define __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__

/* interface ITfContextOwnerCompositionServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerCompositionServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86462810-593B-4916-9764-19C08E9CE110")
    ITfContextOwnerCompositionServices : public ITfContextComposition
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TerminateComposition( 
            /* [in] */ ITfCompositionView *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerCompositionServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerCompositionServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerCompositionServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompositions )( 
            ITfContextOwnerCompositionServices * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnerShip )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ ITfCompositionView *pComposition);
        
        END_INTERFACE
    } ITfContextOwnerCompositionServicesVtbl;

    interface ITfContextOwnerCompositionServices
    {
        CONST_VTBL struct ITfContextOwnerCompositionServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerCompositionServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerCompositionServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerCompositionServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerCompositionServices_StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)	\
    (This)->lpVtbl -> StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)

#define ITfContextOwnerCompositionServices_EnumCompositions(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompositions(This,ppEnum)

#define ITfContextOwnerCompositionServices_FindComposition(This,ecRead,pTestRange,ppEnum)	\
    (This)->lpVtbl -> FindComposition(This,ecRead,pTestRange,ppEnum)

#define ITfContextOwnerCompositionServices_TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)	\
    (This)->lpVtbl -> TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)


#define ITfContextOwnerCompositionServices_TerminateComposition(This,pComposition)	\
    (This)->lpVtbl -> TerminateComposition(This,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionServices_TerminateComposition_Proxy( 
    ITfContextOwnerCompositionServices * This,
    /* [in] */ ITfCompositionView *pComposition);


void __RPC_STUB ITfContextOwnerCompositionServices_TerminateComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__
#define __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__

/* interface ITfContextOwnerCompositionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerCompositionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F20AA40-B57A-4F34-96AB-3576F377CC79")
    ITfContextOwnerCompositionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartComposition( 
            /* [in] */ ITfCompositionView *pComposition,
            /* [out] */ BOOL *pfOk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateComposition( 
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfRange *pRangeNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndComposition( 
            /* [in] */ ITfCompositionView *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerCompositionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerCompositionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerCompositionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition,
            /* [out] */ BOOL *pfOk);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfRange *pRangeNew);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition);
        
        END_INTERFACE
    } ITfContextOwnerCompositionSinkVtbl;

    interface ITfContextOwnerCompositionSink
    {
        CONST_VTBL struct ITfContextOwnerCompositionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerCompositionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerCompositionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerCompositionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerCompositionSink_OnStartComposition(This,pComposition,pfOk)	\
    (This)->lpVtbl -> OnStartComposition(This,pComposition,pfOk)

#define ITfContextOwnerCompositionSink_OnUpdateComposition(This,pComposition,pRangeNew)	\
    (This)->lpVtbl -> OnUpdateComposition(This,pComposition,pRangeNew)

#define ITfContextOwnerCompositionSink_OnEndComposition(This,pComposition)	\
    (This)->lpVtbl -> OnEndComposition(This,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnStartComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition,
    /* [out] */ BOOL *pfOk);


void __RPC_STUB ITfContextOwnerCompositionSink_OnStartComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnUpdateComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition,
    /* [in] */ ITfRange *pRangeNew);


void __RPC_STUB ITfContextOwnerCompositionSink_OnUpdateComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnEndComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition);


void __RPC_STUB ITfContextOwnerCompositionSink_OnEndComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextView_INTERFACE_DEFINED__
#define __ITfContextView_INTERFACE_DEFINED__

/* interface ITfContextView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2433bf8e-0f9b-435c-ba2c-180611978c30")
    ITfContextView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRangeFromPoint( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ const POINT *ppt,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeFromPoint )( 
            ITfContextView * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ const POINT *ppt,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITfContextView * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITfContextView * This,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITfContextView * This,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } ITfContextViewVtbl;

    interface ITfContextView
    {
        CONST_VTBL struct ITfContextViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextView_GetRangeFromPoint(This,ec,ppt,dwFlags,ppRange)	\
    (This)->lpVtbl -> GetRangeFromPoint(This,ec,ppt,dwFlags,ppRange)

#define ITfContextView_GetTextExt(This,ec,pRange,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,ec,pRange,prc,pfClipped)

#define ITfContextView_GetScreenExt(This,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,prc)

#define ITfContextView_GetWnd(This,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextView_GetRangeFromPoint_Proxy( 
    ITfContextView * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ const POINT *ppt,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfContextView_GetRangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetTextExt_Proxy( 
    ITfContextView * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITfContextView_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetScreenExt_Proxy( 
    ITfContextView * This,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfContextView_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetWnd_Proxy( 
    ITfContextView * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITfContextView_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextView_INTERFACE_DEFINED__ */


#ifndef __IEnumTfContextViews_INTERFACE_DEFINED__
#define __IEnumTfContextViews_INTERFACE_DEFINED__

/* interface IEnumTfContextViews */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfContextViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0C0F8DD-CF38-44E1-BB0F-68CF0D551C78")
    IEnumTfContextViews : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfContextViews **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContextView **rgViews,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfContextViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfContextViews * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfContextViews * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfContextViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfContextViews * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfContextViews * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContextView **rgViews,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfContextViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfContextViews * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfContextViewsVtbl;

    interface IEnumTfContextViews
    {
        CONST_VTBL struct IEnumTfContextViewsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfContextViews_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfContextViews_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfContextViews_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfContextViews_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfContextViews_Next(This,ulCount,rgViews,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgViews,pcFetched)

#define IEnumTfContextViews_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfContextViews_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Clone_Proxy( 
    IEnumTfContextViews * This,
    /* [out] */ IEnumTfContextViews **ppEnum);


void __RPC_STUB IEnumTfContextViews_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Next_Proxy( 
    IEnumTfContextViews * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfContextView **rgViews,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfContextViews_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Reset_Proxy( 
    IEnumTfContextViews * This);


void __RPC_STUB IEnumTfContextViews_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Skip_Proxy( 
    IEnumTfContextViews * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfContextViews_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfContextViews_INTERFACE_DEFINED__ */


#ifndef __ITfContext_INTERFACE_DEFINED__
#define __ITfContext_INTERFACE_DEFINED__

/* interface ITfContext */
/* [unique][uuid][object] */ 

#define	TF_ES_ASYNCDONTCARE	( 0 )

#define	TF_ES_SYNC	( 0x1 )

#define	TF_ES_READ	( 0x2 )

#define	TF_ES_READWRITE	( 0x6 )

#define	TF_ES_ASYNC	( 0x8 )

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("1690be9b-d3e9-49f6-8d8b-51b905af4c43") 
enum __MIDL_ITfContext_0001
    {	TF_AE_NONE	= 0,
	TF_AE_START	= 1,
	TF_AE_END	= 2
    } 	TfActiveSelEnd;

typedef /* [uuid] */  DECLSPEC_UUID("36ae42a4-6989-4bdc-b48a-6137b7bf2e42") struct TF_SELECTIONSTYLE
    {
    TfActiveSelEnd ase;
    BOOL fInterimChar;
    } 	TF_SELECTIONSTYLE;

typedef /* [uuid] */  DECLSPEC_UUID("75eb22f2-b0bf-46a8-8006-975a3b6efcf1") struct TF_SELECTION
    {
    ITfRange *range;
    TF_SELECTIONSTYLE style;
    } 	TF_SELECTION;

#define	TF_DEFAULT_SELECTION	( TS_DEFAULT_SELECTION )

#define	TF_SD_READONLY	( TS_SD_READONLY )

#define	TF_SD_LOADING	( TS_SD_LOADING )

#define	TF_SS_DISJOINTSEL	( TS_SS_DISJOINTSEL )

#define	TF_SS_REGIONS	( TS_SS_REGIONS )

#define	TF_SS_TRANSITORY	( TS_SS_TRANSITORY )

typedef /* [uuid] */  DECLSPEC_UUID("bc7d979a-846a-444d-afef-0a9bfa82b961") TS_STATUS TF_STATUS;


EXTERN_C const IID IID_ITfContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7fd-2021-11d2-93e0-0060b067b86e")
    ITfContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EditSession( 
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InWriteSession( 
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [in] */ const TF_SELECTION *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStart( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnd( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveView( 
            /* [out] */ ITfContextView **ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ IEnumTfContextViews **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TF_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppProperty( 
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackProperties( 
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [out] */ IEnumTfProperties **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentMgr( 
            /* [out] */ ITfDocumentMgr **ppDm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRangeBackup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *EditSession )( 
            ITfContext * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        END_INTERFACE
    } ITfContextVtbl;

    interface ITfContext
    {
        CONST_VTBL struct ITfContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_EditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> EditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_EditSession_Proxy( 
    ITfContext * This,
    /* [in] */ TfClientId tid,
    /* [in] */ ITfEditSession *pes,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HRESULT *phrSession);


void __RPC_STUB ITfContext_EditSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_InWriteSession_Proxy( 
    ITfContext * This,
    /* [in] */ TfClientId tid,
    /* [out] */ BOOL *pfWriteSession);


void __RPC_STUB ITfContext_InWriteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetSelection_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG ulIndex,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITfContext_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_SetSelection_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG ulCount,
    /* [in] */ const TF_SELECTION *pSelection);


void __RPC_STUB ITfContext_SetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetStart_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ ITfRange **ppStart);


void __RPC_STUB ITfContext_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetEnd_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ ITfRange **ppEnd);


void __RPC_STUB ITfContext_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetActiveView_Proxy( 
    ITfContext * This,
    /* [out] */ ITfContextView **ppView);


void __RPC_STUB ITfContext_GetActiveView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_EnumViews_Proxy( 
    ITfContext * This,
    /* [out] */ IEnumTfContextViews **ppEnum);


void __RPC_STUB ITfContext_EnumViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetStatus_Proxy( 
    ITfContext * This,
    /* [out] */ TF_STATUS *pdcs);


void __RPC_STUB ITfContext_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetProperty_Proxy( 
    ITfContext * This,
    /* [in] */ REFGUID guidProp,
    /* [out] */ ITfProperty **ppProp);


void __RPC_STUB ITfContext_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetAppProperty_Proxy( 
    ITfContext * This,
    /* [in] */ REFGUID guidProp,
    /* [out] */ ITfReadOnlyProperty **ppProp);


void __RPC_STUB ITfContext_GetAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_TrackProperties_Proxy( 
    ITfContext * This,
    /* [size_is][in] */ const GUID **prgProp,
    /* [in] */ ULONG cProp,
    /* [size_is][in] */ const GUID **prgAppProp,
    /* [in] */ ULONG cAppProp,
    /* [out] */ ITfReadOnlyProperty **ppProperty);


void __RPC_STUB ITfContext_TrackProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_EnumProperties_Proxy( 
    ITfContext * This,
    /* [out] */ IEnumTfProperties **ppEnum);


void __RPC_STUB ITfContext_EnumProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetDocumentMgr_Proxy( 
    ITfContext * This,
    /* [out] */ ITfDocumentMgr **ppDm);


void __RPC_STUB ITfContext_GetDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_CreateRangeBackup_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRangeBackup **ppBackup);


void __RPC_STUB ITfContext_CreateRangeBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_INTERFACE_DEFINED__ */


#ifndef __ITfQueryEmbedded_INTERFACE_DEFINED__
#define __ITfQueryEmbedded_INTERFACE_DEFINED__

/* interface ITfQueryEmbedded */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfQueryEmbedded;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fab9bdb-d250-4169-84e5-6be118fdd7a8")
    ITfQueryEmbedded : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryInsertEmbedded( 
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfQueryEmbeddedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfQueryEmbedded * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfQueryEmbedded * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfQueryEmbedded * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsertEmbedded )( 
            ITfQueryEmbedded * This,
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable);
        
        END_INTERFACE
    } ITfQueryEmbeddedVtbl;

    interface ITfQueryEmbedded
    {
        CONST_VTBL struct ITfQueryEmbeddedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfQueryEmbedded_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfQueryEmbedded_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfQueryEmbedded_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfQueryEmbedded_QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)	\
    (This)->lpVtbl -> QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfQueryEmbedded_QueryInsertEmbedded_Proxy( 
    ITfQueryEmbedded * This,
    /* [in] */ const GUID *pguidService,
    /* [in] */ const FORMATETC *pFormatEtc,
    /* [out] */ BOOL *pfInsertable);


void __RPC_STUB ITfQueryEmbedded_QueryInsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfQueryEmbedded_INTERFACE_DEFINED__ */


#ifndef __ITfInsertAtSelection_INTERFACE_DEFINED__
#define __ITfInsertAtSelection_INTERFACE_DEFINED__

/* interface ITfInsertAtSelection */
/* [unique][uuid][object] */ 

#define	TF_IAS_NOQUERY	( 0x1 )

#define	TF_IAS_QUERYONLY	( 0x2 )

#define	TF_IAS_NO_DEFAULT_COMPOSITION	( 0x80000000 )


EXTERN_C const IID IID_ITfInsertAtSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55ce16ba-3014-41c1-9ceb-fade1446ac6c")
    ITfInsertAtSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertTextAtSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch,
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbeddedAtSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ ITfRange **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInsertAtSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfInsertAtSelection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfInsertAtSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfInsertAtSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertTextAtSelection )( 
            ITfInsertAtSelection * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbeddedAtSelection )( 
            ITfInsertAtSelection * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ ITfRange **ppRange);
        
        END_INTERFACE
    } ITfInsertAtSelectionVtbl;

    interface ITfInsertAtSelection
    {
        CONST_VTBL struct ITfInsertAtSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInsertAtSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfInsertAtSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfInsertAtSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfInsertAtSelection_InsertTextAtSelection(This,ec,dwFlags,pchText,cch,ppRange)	\
    (This)->lpVtbl -> InsertTextAtSelection(This,ec,dwFlags,pchText,cch,ppRange)

#define ITfInsertAtSelection_InsertEmbeddedAtSelection(This,ec,dwFlags,pDataObject,ppRange)	\
    (This)->lpVtbl -> InsertEmbeddedAtSelection(This,ec,dwFlags,pDataObject,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfInsertAtSelection_InsertTextAtSelection_Proxy( 
    ITfInsertAtSelection * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfInsertAtSelection_InsertTextAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInsertAtSelection_InsertEmbeddedAtSelection_Proxy( 
    ITfInsertAtSelection * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfInsertAtSelection_InsertEmbeddedAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfInsertAtSelection_INTERFACE_DEFINED__ */


#ifndef __ITfCleanupContextSink_INTERFACE_DEFINED__
#define __ITfCleanupContextSink_INTERFACE_DEFINED__

/* interface ITfCleanupContextSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCleanupContextSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01689689-7acb-4e9b-ab7c-7ea46b12b522")
    ITfCleanupContextSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCleanupContext( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCleanupContextSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCleanupContextSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCleanupContextSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCleanupContextSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCleanupContext )( 
            ITfCleanupContextSink * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfCleanupContextSinkVtbl;

    interface ITfCleanupContextSink
    {
        CONST_VTBL struct ITfCleanupContextSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCleanupContextSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCleanupContextSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCleanupContextSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCleanupContextSink_OnCleanupContext(This,ecWrite,pic)	\
    (This)->lpVtbl -> OnCleanupContext(This,ecWrite,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCleanupContextSink_OnCleanupContext_Proxy( 
    ITfCleanupContextSink * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfCleanupContextSink_OnCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCleanupContextSink_INTERFACE_DEFINED__ */


#ifndef __ITfCleanupContextDurationSink_INTERFACE_DEFINED__
#define __ITfCleanupContextDurationSink_INTERFACE_DEFINED__

/* interface ITfCleanupContextDurationSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCleanupContextDurationSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45c35144-154e-4797-bed8-d33ae7bf8794")
    ITfCleanupContextDurationSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartCleanupContext( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndCleanupContext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCleanupContextDurationSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCleanupContextDurationSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCleanupContextDurationSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCleanupContextDurationSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartCleanupContext )( 
            ITfCleanupContextDurationSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndCleanupContext )( 
            ITfCleanupContextDurationSink * This);
        
        END_INTERFACE
    } ITfCleanupContextDurationSinkVtbl;

    interface ITfCleanupContextDurationSink
    {
        CONST_VTBL struct ITfCleanupContextDurationSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCleanupContextDurationSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCleanupContextDurationSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCleanupContextDurationSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCleanupContextDurationSink_OnStartCleanupContext(This)	\
    (This)->lpVtbl -> OnStartCleanupContext(This)

#define ITfCleanupContextDurationSink_OnEndCleanupContext(This)	\
    (This)->lpVtbl -> OnEndCleanupContext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCleanupContextDurationSink_OnStartCleanupContext_Proxy( 
    ITfCleanupContextDurationSink * This);


void __RPC_STUB ITfCleanupContextDurationSink_OnStartCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCleanupContextDurationSink_OnEndCleanupContext_Proxy( 
    ITfCleanupContextDurationSink * This);


void __RPC_STUB ITfCleanupContextDurationSink_OnEndCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCleanupContextDurationSink_INTERFACE_DEFINED__ */


#ifndef __ITfReadOnlyProperty_INTERFACE_DEFINED__
#define __ITfReadOnlyProperty_INTERFACE_DEFINED__

/* interface ITfReadOnlyProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfReadOnlyProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17d49a3d-f8b8-4b2f-b254-52319dd64c53")
    ITfReadOnlyProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRanges( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ITfContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfReadOnlyPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfReadOnlyProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfReadOnlyProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfReadOnlyProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfReadOnlyProperty * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfReadOnlyProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfReadOnlyProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfReadOnlyProperty * This,
            /* [out] */ ITfContext **ppContext);
        
        END_INTERFACE
    } ITfReadOnlyPropertyVtbl;

    interface ITfReadOnlyProperty
    {
        CONST_VTBL struct ITfReadOnlyPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfReadOnlyProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfReadOnlyProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfReadOnlyProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfReadOnlyProperty_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfReadOnlyProperty_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfReadOnlyProperty_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfReadOnlyProperty_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetType_Proxy( 
    ITfReadOnlyProperty * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfReadOnlyProperty_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_EnumRanges_Proxy( 
    ITfReadOnlyProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ IEnumTfRanges **ppEnum,
    /* [in] */ ITfRange *pTargetRange);


void __RPC_STUB ITfReadOnlyProperty_EnumRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetValue_Proxy( 
    ITfReadOnlyProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfReadOnlyProperty_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetContext_Proxy( 
    ITfReadOnlyProperty * This,
    /* [out] */ ITfContext **ppContext);


void __RPC_STUB ITfReadOnlyProperty_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfReadOnlyProperty_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0158 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("d678c645-eb6a-45c9-b4ee-0f3e3a991348") struct TF_PROPERTYVAL
    {
    GUID guidId;
    VARIANT varValue;
    } 	TF_PROPERTYVAL;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0158_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0158_v0_0_s_ifspec;

#ifndef __IEnumTfPropertyValue_INTERFACE_DEFINED__
#define __IEnumTfPropertyValue_INTERFACE_DEFINED__

/* interface IEnumTfPropertyValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfPropertyValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ed8981b-7c10-4d7d-9fb3-ab72e9c75f72")
    IEnumTfPropertyValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfPropertyValue **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfPropertyValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfPropertyValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfPropertyValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfPropertyValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfPropertyValue * This,
            /* [out] */ IEnumTfPropertyValue **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfPropertyValue * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfPropertyValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfPropertyValue * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfPropertyValueVtbl;

    interface IEnumTfPropertyValue
    {
        CONST_VTBL struct IEnumTfPropertyValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfPropertyValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfPropertyValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfPropertyValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfPropertyValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfPropertyValue_Next(This,ulCount,rgValues,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgValues,pcFetched)

#define IEnumTfPropertyValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfPropertyValue_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Clone_Proxy( 
    IEnumTfPropertyValue * This,
    /* [out] */ IEnumTfPropertyValue **ppEnum);


void __RPC_STUB IEnumTfPropertyValue_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Next_Proxy( 
    IEnumTfPropertyValue * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfPropertyValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Reset_Proxy( 
    IEnumTfPropertyValue * This);


void __RPC_STUB IEnumTfPropertyValue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Skip_Proxy( 
    IEnumTfPropertyValue * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfPropertyValue_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfPropertyValue_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTracker_INTERFACE_DEFINED__
#define __ITfMouseTracker_INTERFACE_DEFINED__

/* interface ITfMouseTracker */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTracker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09d146cd-a544-4132-925b-7afa8ef322d0")
    ITfMouseTracker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ ITfRange *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTracker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTracker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTracker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTracker * This,
            /* [in] */ ITfRange *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTracker * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerVtbl;

    interface ITfMouseTracker
    {
        CONST_VTBL struct ITfMouseTrackerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTracker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTracker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTracker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTracker_AdviseMouseSink(This,range,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,range,pSink,pdwCookie)

#define ITfMouseTracker_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTracker_AdviseMouseSink_Proxy( 
    ITfMouseTracker * This,
    /* [in] */ ITfRange *range,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTracker_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTracker_UnadviseMouseSink_Proxy( 
    ITfMouseTracker * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTracker_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTracker_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerACP_INTERFACE_DEFINED__
#define __ITfMouseTrackerACP_INTERFACE_DEFINED__

/* interface ITfMouseTrackerACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3bdd78e2-c16e-47fd-b883-ce6facc1a208")
    ITfMouseTrackerACP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ ITfRangeACP *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerACP * This,
            /* [in] */ ITfRangeACP *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerACP * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerACPVtbl;

    interface ITfMouseTrackerACP
    {
        CONST_VTBL struct ITfMouseTrackerACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerACP_AdviseMouseSink(This,range,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,range,pSink,pdwCookie)

#define ITfMouseTrackerACP_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerACP_AdviseMouseSink_Proxy( 
    ITfMouseTrackerACP * This,
    /* [in] */ ITfRangeACP *range,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerACP_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerACP_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerACP * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerACP_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerACP_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfMouseSink_INTERFACE_DEFINED__
#define __ITfMouseSink_INTERFACE_DEFINED__

/* interface ITfMouseSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfMouseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a1adaaa2-3a24-449d-ac96-5183e7f5c217")
    ITfMouseSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMouseEvent( 
            /* [in] */ ULONG uEdge,
            /* [in] */ ULONG uQuadrant,
            /* [in] */ DWORD dwBtnStatus,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMouseEvent )( 
            ITfMouseSink * This,
            /* [in] */ ULONG uEdge,
            /* [in] */ ULONG uQuadrant,
            /* [in] */ DWORD dwBtnStatus,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfMouseSinkVtbl;

    interface ITfMouseSink
    {
        CONST_VTBL struct ITfMouseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseSink_OnMouseEvent(This,uEdge,uQuadrant,dwBtnStatus,pfEaten)	\
    (This)->lpVtbl -> OnMouseEvent(This,uEdge,uQuadrant,dwBtnStatus,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseSink_OnMouseEvent_Proxy( 
    ITfMouseSink * This,
    /* [in] */ ULONG uEdge,
    /* [in] */ ULONG uQuadrant,
    /* [in] */ DWORD dwBtnStatus,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfMouseSink_OnMouseEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditRecord_INTERFACE_DEFINED__
#define __ITfEditRecord_INTERFACE_DEFINED__

/* interface ITfEditRecord */
/* [unique][uuid][object] */ 

#define	TF_GTP_INCL_TEXT	( 0x1 )


EXTERN_C const IID IID_ITfEditRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("42d4d099-7c1a-4a89-b836-6c6f22160df0")
    ITfEditRecord : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelectionStatus( 
            /* [out] */ BOOL *pfChanged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextAndPropertyUpdates( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const GUID **prgProperties,
            /* [in] */ ULONG cProperties,
            /* [out] */ IEnumTfRanges **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditRecord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditRecord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionStatus )( 
            ITfEditRecord * This,
            /* [out] */ BOOL *pfChanged);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextAndPropertyUpdates )( 
            ITfEditRecord * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const GUID **prgProperties,
            /* [in] */ ULONG cProperties,
            /* [out] */ IEnumTfRanges **ppEnum);
        
        END_INTERFACE
    } ITfEditRecordVtbl;

    interface ITfEditRecord
    {
        CONST_VTBL struct ITfEditRecordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditRecord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditRecord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditRecord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditRecord_GetSelectionStatus(This,pfChanged)	\
    (This)->lpVtbl -> GetSelectionStatus(This,pfChanged)

#define ITfEditRecord_GetTextAndPropertyUpdates(This,dwFlags,prgProperties,cProperties,ppEnum)	\
    (This)->lpVtbl -> GetTextAndPropertyUpdates(This,dwFlags,prgProperties,cProperties,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditRecord_GetSelectionStatus_Proxy( 
    ITfEditRecord * This,
    /* [out] */ BOOL *pfChanged);


void __RPC_STUB ITfEditRecord_GetSelectionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEditRecord_GetTextAndPropertyUpdates_Proxy( 
    ITfEditRecord * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const GUID **prgProperties,
    /* [in] */ ULONG cProperties,
    /* [out] */ IEnumTfRanges **ppEnum);


void __RPC_STUB ITfEditRecord_GetTextAndPropertyUpdates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditRecord_INTERFACE_DEFINED__ */


#ifndef __ITfTextEditSink_INTERFACE_DEFINED__
#define __ITfTextEditSink_INTERFACE_DEFINED__

/* interface ITfTextEditSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfTextEditSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8127d409-ccd3-4683-967a-b43d5b482bf7")
    ITfTextEditSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEndEdit( 
            /* [in] */ ITfContext *pic,
            /* [in] */ TfEditCookie ecReadOnly,
            /* [in] */ ITfEditRecord *pEditRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextEditSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextEditSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextEditSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextEditSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEdit )( 
            ITfTextEditSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ TfEditCookie ecReadOnly,
            /* [in] */ ITfEditRecord *pEditRecord);
        
        END_INTERFACE
    } ITfTextEditSinkVtbl;

    interface ITfTextEditSink
    {
        CONST_VTBL struct ITfTextEditSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextEditSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextEditSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextEditSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextEditSink_OnEndEdit(This,pic,ecReadOnly,pEditRecord)	\
    (This)->lpVtbl -> OnEndEdit(This,pic,ecReadOnly,pEditRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextEditSink_OnEndEdit_Proxy( 
    ITfTextEditSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ TfEditCookie ecReadOnly,
    /* [in] */ ITfEditRecord *pEditRecord);


void __RPC_STUB ITfTextEditSink_OnEndEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextEditSink_INTERFACE_DEFINED__ */


#ifndef __ITfTextLayoutSink_INTERFACE_DEFINED__
#define __ITfTextLayoutSink_INTERFACE_DEFINED__

/* interface ITfTextLayoutSink */
/* [unique][uuid][object] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("603553cf-9edd-4cc1-9ecc-069e4a427734") 
enum __MIDL_ITfTextLayoutSink_0001
    {	TF_LC_CREATE	= 0,
	TF_LC_CHANGE	= 1,
	TF_LC_DESTROY	= 2
    } 	TfLayoutCode;


EXTERN_C const IID IID_ITfTextLayoutSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2af2d06a-dd5b-4927-a0b4-54f19c91fade")
    ITfTextLayoutSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( 
            /* [in] */ ITfContext *pic,
            /* [in] */ TfLayoutCode lcode,
            /* [in] */ ITfContextView *pView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextLayoutSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextLayoutSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextLayoutSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextLayoutSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITfTextLayoutSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ TfLayoutCode lcode,
            /* [in] */ ITfContextView *pView);
        
        END_INTERFACE
    } ITfTextLayoutSinkVtbl;

    interface ITfTextLayoutSink
    {
        CONST_VTBL struct ITfTextLayoutSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextLayoutSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextLayoutSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextLayoutSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextLayoutSink_OnLayoutChange(This,pic,lcode,pView)	\
    (This)->lpVtbl -> OnLayoutChange(This,pic,lcode,pView)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextLayoutSink_OnLayoutChange_Proxy( 
    ITfTextLayoutSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ TfLayoutCode lcode,
    /* [in] */ ITfContextView *pView);


void __RPC_STUB ITfTextLayoutSink_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextLayoutSink_INTERFACE_DEFINED__ */


#ifndef __ITfStatusSink_INTERFACE_DEFINED__
#define __ITfStatusSink_INTERFACE_DEFINED__

/* interface ITfStatusSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStatusSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6b7d8d73-b267-4f69-b32e-1ca321ce4f45")
    ITfStatusSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ ITfContext *pic,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStatusSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStatusSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStatusSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStatusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITfStatusSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ITfStatusSinkVtbl;

    interface ITfStatusSink
    {
        CONST_VTBL struct ITfStatusSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStatusSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStatusSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStatusSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStatusSink_OnStatusChange(This,pic,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,pic,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStatusSink_OnStatusChange_Proxy( 
    ITfStatusSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfStatusSink_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStatusSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditTransactionSink_INTERFACE_DEFINED__
#define __ITfEditTransactionSink_INTERFACE_DEFINED__

/* interface ITfEditTransactionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfEditTransactionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("708fbf70-b520-416b-b06c-2c41ab44f8ba")
    ITfEditTransactionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartEditTransaction( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndEditTransaction( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditTransactionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditTransactionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditTransactionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditTransactionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartEditTransaction )( 
            ITfEditTransactionSink * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEditTransaction )( 
            ITfEditTransactionSink * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfEditTransactionSinkVtbl;

    interface ITfEditTransactionSink
    {
        CONST_VTBL struct ITfEditTransactionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditTransactionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditTransactionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditTransactionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditTransactionSink_OnStartEditTransaction(This,pic)	\
    (This)->lpVtbl -> OnStartEditTransaction(This,pic)

#define ITfEditTransactionSink_OnEndEditTransaction(This,pic)	\
    (This)->lpVtbl -> OnEndEditTransaction(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditTransactionSink_OnStartEditTransaction_Proxy( 
    ITfEditTransactionSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfEditTransactionSink_OnStartEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEditTransactionSink_OnEndEditTransaction_Proxy( 
    ITfEditTransactionSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfEditTransactionSink_OnEndEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditTransactionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwner_INTERFACE_DEFINED__
#define __ITfContextOwner_INTERFACE_DEFINED__

/* interface ITfContextOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e80c-2021-11d2-93e0-0060b067b86e")
    ITfContextOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetACPFromPoint( 
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TF_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ REFGUID rguidAttribute,
            /* [out] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetACPFromPoint )( 
            ITfContextOwner * This,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITfContextOwner * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITfContextOwner * This,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContextOwner * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITfContextOwner * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            ITfContextOwner * This,
            /* [in] */ REFGUID rguidAttribute,
            /* [out] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ITfContextOwnerVtbl;

    interface ITfContextOwner
    {
        CONST_VTBL struct ITfContextOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwner_GetACPFromPoint(This,ptScreen,dwFlags,pacp)	\
    (This)->lpVtbl -> GetACPFromPoint(This,ptScreen,dwFlags,pacp)

#define ITfContextOwner_GetTextExt(This,acpStart,acpEnd,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,acpStart,acpEnd,prc,pfClipped)

#define ITfContextOwner_GetScreenExt(This,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,prc)

#define ITfContextOwner_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContextOwner_GetWnd(This,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,phwnd)

#define ITfContextOwner_GetAttribute(This,rguidAttribute,pvarValue)	\
    (This)->lpVtbl -> GetAttribute(This,rguidAttribute,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwner_GetACPFromPoint_Proxy( 
    ITfContextOwner * This,
    /* [in] */ const POINT *ptScreen,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LONG *pacp);


void __RPC_STUB ITfContextOwner_GetACPFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetTextExt_Proxy( 
    ITfContextOwner * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITfContextOwner_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetScreenExt_Proxy( 
    ITfContextOwner * This,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfContextOwner_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetStatus_Proxy( 
    ITfContextOwner * This,
    /* [out] */ TF_STATUS *pdcs);


void __RPC_STUB ITfContextOwner_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetWnd_Proxy( 
    ITfContextOwner * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITfContextOwner_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetAttribute_Proxy( 
    ITfContextOwner * This,
    /* [in] */ REFGUID rguidAttribute,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfContextOwner_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwner_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerServices_INTERFACE_DEFINED__
#define __ITfContextOwnerServices_INTERFACE_DEFINED__

/* interface ITfContextOwnerServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b23eb630-3e1c-11d3-a745-0050040ab407")
    ITfContextOwnerServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAttributeChange( 
            /* [in] */ REFGUID rguidAttribute) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITfContextOwnerServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITfContextOwnerServices * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnAttributeChange )( 
            ITfContextOwnerServices * This,
            /* [in] */ REFGUID rguidAttribute);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITfContextOwnerServices * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange);
        
        END_INTERFACE
    } ITfContextOwnerServicesVtbl;

    interface ITfContextOwnerServices
    {
        CONST_VTBL struct ITfContextOwnerServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerServices_OnLayoutChange(This)	\
    (This)->lpVtbl -> OnLayoutChange(This)

#define ITfContextOwnerServices_OnStatusChange(This,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,dwFlags)

#define ITfContextOwnerServices_OnAttributeChange(This,rguidAttribute)	\
    (This)->lpVtbl -> OnAttributeChange(This,rguidAttribute)

#define ITfContextOwnerServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITfContextOwnerServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITfContextOwnerServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITfContextOwnerServices_CreateRange(This,acpStart,acpEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,acpStart,acpEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnLayoutChange_Proxy( 
    ITfContextOwnerServices * This);


void __RPC_STUB ITfContextOwnerServices_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnStatusChange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfContextOwnerServices_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnAttributeChange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ REFGUID rguidAttribute);


void __RPC_STUB ITfContextOwnerServices_OnAttributeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_Serialize_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITfContextOwnerServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_Unserialize_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);


void __RPC_STUB ITfContextOwnerServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_ForceLoadProperty_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITfContextOwnerServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_CreateRange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ ITfRangeACP **ppRange);


void __RPC_STUB ITfContextOwnerServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerServices_INTERFACE_DEFINED__ */


#ifndef __ITfContextKeyEventSink_INTERFACE_DEFINED__
#define __ITfContextKeyEventSink_INTERFACE_DEFINED__

/* interface ITfContextKeyEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfContextKeyEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0552ba5d-c835-4934-bf50-846aaa67432f")
    ITfContextKeyEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextKeyEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextKeyEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextKeyEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextKeyEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyUp )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyDown )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyUp )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfContextKeyEventSinkVtbl;

    interface ITfContextKeyEventSink
    {
        CONST_VTBL struct ITfContextKeyEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextKeyEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextKeyEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextKeyEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextKeyEventSink_OnKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyDown(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyUp(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnTestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyDown(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnTestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyUp(This,wParam,lParam,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnKeyDown_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnKeyUp_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnTestKeyDown_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnTestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnTestKeyUp_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnTestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextKeyEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditSession_INTERFACE_DEFINED__
#define __ITfEditSession_INTERFACE_DEFINED__

/* interface ITfEditSession */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfEditSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e803-2021-11d2-93e0-0060b067b86e")
    ITfEditSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EditSession( 
            /* [in] */ TfEditCookie ec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *EditSession )( 
            ITfEditSession * This,
            /* [in] */ TfEditCookie ec);
        
        END_INTERFACE
    } ITfEditSessionVtbl;

    interface ITfEditSession
    {
        CONST_VTBL struct ITfEditSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditSession_EditSession(This,ec)	\
    (This)->lpVtbl -> EditSession(This,ec)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditSession_EditSession_Proxy( 
    ITfEditSession * This,
    /* [in] */ TfEditCookie ec);


void __RPC_STUB ITfEditSession_EditSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0172 */
/* [local] */ 

#define	TF_TD_CORRECTION	( 1 )

typedef /* [uuid] */  DECLSPEC_UUID("2b9f8421-ea29-4904-8668-2eca2083ca61") struct TF_TEXTDELTA
    {
    ITfRange *pRange;
    DWORD dwFlags;
    LONG lOldLen;
    } 	TF_TEXTDELTA;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0172_v0_0_s_ifspec;

#ifndef __IEnumTfTextDeltas_INTERFACE_DEFINED__
#define __IEnumTfTextDeltas_INTERFACE_DEFINED__

/* interface IEnumTfTextDeltas */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfTextDeltas;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e807-2021-11d2-93e0-0060b067b86e")
    IEnumTfTextDeltas : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfTextDeltas **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfTextDeltasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfTextDeltas * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfTextDeltas * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfTextDeltas * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfTextDeltas * This,
            /* [out] */ IEnumTfTextDeltas **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfTextDeltas * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfTextDeltas * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfTextDeltas * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfTextDeltasVtbl;

    interface IEnumTfTextDeltas
    {
        CONST_VTBL struct IEnumTfTextDeltasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfTextDeltas_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfTextDeltas_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfTextDeltas_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfTextDeltas_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfTextDeltas_Next(This,ulCount,rgTextDelta,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgTextDelta,pcFetched)

#define IEnumTfTextDeltas_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfTextDeltas_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Clone_Proxy( 
    IEnumTfTextDeltas * This,
    /* [out] */ IEnumTfTextDeltas **ppEnum);


void __RPC_STUB IEnumTfTextDeltas_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Next_Proxy( 
    IEnumTfTextDeltas * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfTextDeltas_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Reset_Proxy( 
    IEnumTfTextDeltas * This);


void __RPC_STUB IEnumTfTextDeltas_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Skip_Proxy( 
    IEnumTfTextDeltas * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfTextDeltas_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfTextDeltas_INTERFACE_DEFINED__ */


#ifndef __ITfRange_INTERFACE_DEFINED__
#define __ITfRange_INTERFACE_DEFINED__

/* interface ITfRange */
/* [unique][uuid][object] */ 

#define	TF_CHAR_EMBEDDED	( TS_CHAR_EMBEDDED )

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("cf610f06-2882-46f6-abe5-298568b664c4") 
enum __MIDL_ITfRange_0001
    {	TF_GRAVITY_BACKWARD	= 0,
	TF_GRAVITY_FORWARD	= 1
    } 	TfGravity;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("1e512533-bbdc-4530-9a8e-a1dc0af67468") 
enum __MIDL_ITfRange_0002
    {	TF_SD_BACKWARD	= 0,
	TF_SD_FORWARD	= 1
    } 	TfShiftDir;

#define	TF_HF_OBJECT	( 1 )

#define	TF_TF_MOVESTART	( 1 )

#define	TF_TF_IGNOREEND	( 2 )

#define	TF_ST_CORRECTION	( 1 )

#define	TF_IE_CORRECTION	( 1 )

typedef /* [uuid] */  DECLSPEC_UUID("49930d51-7d93-448c-a48c-fea5dac192b1") struct TF_HALTCOND
    {
    ITfRange *pHaltRange;
    TfAnchor aHaltPos;
    DWORD dwFlags;
    } 	TF_HALTCOND;


EXTERN_C const IID IID_ITfRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7ff-2021-11d2-93e0-0060b067b86e")
    ITfRange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedded( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbedded( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStartToRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEndToRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStartRegion( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEndRegion( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEmpty( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collapse( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdjustForInsert( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGravity( 
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGravity( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ITfRange **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ITfContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRange * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRange * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRange * This,
            /* [out] */ ITfContext **ppContext);
        
        END_INTERFACE
    } ITfRangeVtbl;

    interface ITfRange
    {
        CONST_VTBL struct ITfRangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRange_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRange_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRange_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRange_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRange_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRange_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRange_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRange_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRange_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRange_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRange_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRange_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRange_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRange_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRange_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRange_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRange_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRange_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRange_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRange_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRange_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRange_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRange_GetText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [length_is][size_is][out] */ WCHAR *pchText,
    /* [in] */ ULONG cchMax,
    /* [out] */ ULONG *pcch);


void __RPC_STUB ITfRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_SetText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [unique][size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch);


void __RPC_STUB ITfRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetFormattedText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ IDataObject **ppDataObject);


void __RPC_STUB ITfRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetEmbedded_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ REFGUID rguidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfRange_GetEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_InsertEmbedded_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject);


void __RPC_STUB ITfRange_InsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ LONG cchReq,
    /* [out] */ LONG *pcch,
    /* [unique][in] */ const TF_HALTCOND *pHalt);


void __RPC_STUB ITfRange_ShiftStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ LONG cchReq,
    /* [out] */ LONG *pcch,
    /* [unique][in] */ const TF_HALTCOND *pHalt);


void __RPC_STUB ITfRange_ShiftEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStartToRange_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_ShiftStartToRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEndToRange_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_ShiftEndToRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStartRegion_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfShiftDir dir,
    /* [out] */ BOOL *pfNoRegion);


void __RPC_STUB ITfRange_ShiftStartRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEndRegion_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfShiftDir dir,
    /* [out] */ BOOL *pfNoRegion);


void __RPC_STUB ITfRange_ShiftEndRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEmpty_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ BOOL *pfEmpty);


void __RPC_STUB ITfRange_IsEmpty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_Collapse_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEqualStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfRange_IsEqualStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEqualEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfRange_IsEqualEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_CompareStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ LONG *plResult);


void __RPC_STUB ITfRange_CompareStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_CompareEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ LONG *plResult);


void __RPC_STUB ITfRange_CompareEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_AdjustForInsert_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG cchInsert,
    /* [out] */ BOOL *pfInsertOk);


void __RPC_STUB ITfRange_AdjustForInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetGravity_Proxy( 
    ITfRange * This,
    /* [out] */ TfGravity *pgStart,
    /* [out] */ TfGravity *pgEnd);


void __RPC_STUB ITfRange_GetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_SetGravity_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfGravity gStart,
    /* [in] */ TfGravity gEnd);


void __RPC_STUB ITfRange_SetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_Clone_Proxy( 
    ITfRange * This,
    /* [out] */ ITfRange **ppClone);


void __RPC_STUB ITfRange_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetContext_Proxy( 
    ITfRange * This,
    /* [out] */ ITfContext **ppContext);


void __RPC_STUB ITfRange_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRange_INTERFACE_DEFINED__ */


#ifndef __ITfRangeACP_INTERFACE_DEFINED__
#define __ITfRangeACP_INTERFACE_DEFINED__

/* interface ITfRangeACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("057a6296-029b-4154-b79a-0d461d4ea94c")
    ITfRangeACP : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ LONG *pacpAnchor,
            /* [out] */ LONG *pcch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ LONG acpAnchor,
            /* [in] */ LONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeACP * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeACP * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeACP * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeACP * This,
            /* [out] */ LONG *pacpAnchor,
            /* [out] */ LONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeACP * This,
            /* [in] */ LONG acpAnchor,
            /* [in] */ LONG cch);
        
        END_INTERFACE
    } ITfRangeACPVtbl;

    interface ITfRangeACP
    {
        CONST_VTBL struct ITfRangeACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeACP_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeACP_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeACP_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeACP_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeACP_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeACP_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeACP_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeACP_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeACP_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeACP_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeACP_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeACP_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeACP_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeACP_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeACP_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeACP_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeACP_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeACP_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeACP_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeACP_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeACP_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeACP_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeACP_GetExtent(This,pacpAnchor,pcch)	\
    (This)->lpVtbl -> GetExtent(This,pacpAnchor,pcch)

#define ITfRangeACP_SetExtent(This,acpAnchor,cch)	\
    (This)->lpVtbl -> SetExtent(This,acpAnchor,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeACP_GetExtent_Proxy( 
    ITfRangeACP * This,
    /* [out] */ LONG *pacpAnchor,
    /* [out] */ LONG *pcch);


void __RPC_STUB ITfRangeACP_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeACP_SetExtent_Proxy( 
    ITfRangeACP * This,
    /* [in] */ LONG acpAnchor,
    /* [in] */ LONG cch);


void __RPC_STUB ITfRangeACP_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeACP_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreACPServices_INTERFACE_DEFINED__
#define __ITextStoreACPServices_INTERFACE_DEFINED__

/* interface ITextStoreACPServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreACPServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e901-2021-11d2-93e0-0060b067b86e")
    ITextStoreACPServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreACPServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreACPServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreACPServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreACPServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreACPServices * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange);
        
        END_INTERFACE
    } ITextStoreACPServicesVtbl;

    interface ITextStoreACPServices
    {
        CONST_VTBL struct ITextStoreACPServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreACPServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreACPServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreACPServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreACPServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreACPServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreACPServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreACPServices_CreateRange(This,acpStart,acpEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,acpStart,acpEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreACPServices_Serialize_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreACPServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_Unserialize_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);


void __RPC_STUB ITextStoreACPServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_ForceLoadProperty_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreACPServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_CreateRange_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ ITfRangeACP **ppRange);


void __RPC_STUB ITextStoreACPServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreACPServices_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfRangeBackup_INTERFACE_DEFINED__
#define __ITfRangeBackup_INTERFACE_DEFINED__

/* interface ITfRangeBackup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("463a506d-6992-49d2-9b88-93d55e70bb16")
    ITfRangeBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            ITfRangeBackup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeBackupVtbl;

    interface ITfRangeBackup
    {
        CONST_VTBL struct ITfRangeBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeBackup_Restore(This,ec,pRange)	\
    (This)->lpVtbl -> Restore(This,ec,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeBackup_Restore_Proxy( 
    ITfRangeBackup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeBackup_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeBackup_INTERFACE_DEFINED__ */


#ifndef __ITfPropertyStore_INTERFACE_DEFINED__
#define __ITfPropertyStore_INTERFACE_DEFINED__

/* interface ITfPropertyStore */
/* [unique][uuid][object] */ 

#define	TF_TU_CORRECTION	( 0x1 )


EXTERN_C const IID IID_ITfPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6834b120-88cb-11d2-bf45-00105a2799b5")
    ITfPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataType( 
            /* [out] */ TfPropertyType *ptype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTextUpdated( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfFree) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Divide( 
            /* [in] */ ITfRange *pRangeThis,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ ITfPropertyStore **ppPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ITfPropertyStore **pPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyRangeCreator( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ IStream *pStream,
            /* [out] */ ULONG *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPropertyStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfPropertyStore * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataType )( 
            ITfPropertyStore * This,
            /* [out] */ TfPropertyType *ptype);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ITfPropertyStore * This,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextUpdated )( 
            ITfPropertyStore * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfAccept);
        
        HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            ITfPropertyStore * This,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfFree);
        
        HRESULT ( STDMETHODCALLTYPE *Divide )( 
            ITfPropertyStore * This,
            /* [in] */ ITfRange *pRangeThis,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ ITfPropertyStore **ppPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfPropertyStore * This,
            /* [out] */ ITfPropertyStore **pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRangeCreator )( 
            ITfPropertyStore * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITfPropertyStore * This,
            /* [in] */ IStream *pStream,
            /* [out] */ ULONG *pcb);
        
        END_INTERFACE
    } ITfPropertyStoreVtbl;

    interface ITfPropertyStore
    {
        CONST_VTBL struct ITfPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPropertyStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPropertyStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPropertyStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPropertyStore_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfPropertyStore_GetDataType(This,ptype)	\
    (This)->lpVtbl -> GetDataType(This,ptype)

#define ITfPropertyStore_GetData(This,pvarValue)	\
    (This)->lpVtbl -> GetData(This,pvarValue)

#define ITfPropertyStore_OnTextUpdated(This,dwFlags,pRangeNew,pfAccept)	\
    (This)->lpVtbl -> OnTextUpdated(This,dwFlags,pRangeNew,pfAccept)

#define ITfPropertyStore_Shrink(This,pRangeNew,pfFree)	\
    (This)->lpVtbl -> Shrink(This,pRangeNew,pfFree)

#define ITfPropertyStore_Divide(This,pRangeThis,pRangeNew,ppPropStore)	\
    (This)->lpVtbl -> Divide(This,pRangeThis,pRangeNew,ppPropStore)

#define ITfPropertyStore_Clone(This,pPropStore)	\
    (This)->lpVtbl -> Clone(This,pPropStore)

#define ITfPropertyStore_GetPropertyRangeCreator(This,pclsid)	\
    (This)->lpVtbl -> GetPropertyRangeCreator(This,pclsid)

#define ITfPropertyStore_Serialize(This,pStream,pcb)	\
    (This)->lpVtbl -> Serialize(This,pStream,pcb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetType_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfPropertyStore_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetDataType_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ TfPropertyType *ptype);


void __RPC_STUB ITfPropertyStore_GetDataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetData_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfPropertyStore_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_OnTextUpdated_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ BOOL *pfAccept);


void __RPC_STUB ITfPropertyStore_OnTextUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Shrink_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ BOOL *pfFree);


void __RPC_STUB ITfPropertyStore_Shrink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Divide_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ ITfRange *pRangeThis,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ ITfPropertyStore **ppPropStore);


void __RPC_STUB ITfPropertyStore_Divide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Clone_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ ITfPropertyStore **pPropStore);


void __RPC_STUB ITfPropertyStore_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetPropertyRangeCreator_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfPropertyStore_GetPropertyRangeCreator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Serialize_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ IStream *pStream,
    /* [out] */ ULONG *pcb);


void __RPC_STUB ITfPropertyStore_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPropertyStore_INTERFACE_DEFINED__ */


#ifndef __IEnumTfRanges_INTERFACE_DEFINED__
#define __IEnumTfRanges_INTERFACE_DEFINED__

/* interface IEnumTfRanges */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f99d3f40-8e32-11d2-bf46-00105a2799b5")
    IEnumTfRanges : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRanges **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfRange **ppRange,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRanges * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRanges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRanges * This,
            /* [out] */ IEnumTfRanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRanges * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfRange **ppRange,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRanges * This,
            ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRangesVtbl;

    interface IEnumTfRanges
    {
        CONST_VTBL struct IEnumTfRangesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRanges_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfRanges_Next(This,ulCount,ppRange,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppRange,pcFetched)

#define IEnumTfRanges_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRanges_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRanges_Clone_Proxy( 
    IEnumTfRanges * This,
    /* [out] */ IEnumTfRanges **ppEnum);


void __RPC_STUB IEnumTfRanges_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Next_Proxy( 
    IEnumTfRanges * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfRange **ppRange,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRanges_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Reset_Proxy( 
    IEnumTfRanges * This);


void __RPC_STUB IEnumTfRanges_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Skip_Proxy( 
    IEnumTfRanges * This,
    ULONG ulCount);


void __RPC_STUB IEnumTfRanges_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRanges_INTERFACE_DEFINED__ */


#ifndef __ITfCreatePropertyStore_INTERFACE_DEFINED__
#define __ITfCreatePropertyStore_INTERFACE_DEFINED__

/* interface ITfCreatePropertyStore */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCreatePropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2463fbf0-b0af-11d2-afc5-00105a2799b5")
    ITfCreatePropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsStoreSerializable( 
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore,
            /* [out] */ BOOL *pfSerializable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyStore( 
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ULONG cb,
            /* [in] */ IStream *pStream,
            /* [out] */ ITfPropertyStore **ppStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCreatePropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCreatePropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCreatePropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsStoreSerializable )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore,
            /* [out] */ BOOL *pfSerializable);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyStore )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ULONG cb,
            /* [in] */ IStream *pStream,
            /* [out] */ ITfPropertyStore **ppStore);
        
        END_INTERFACE
    } ITfCreatePropertyStoreVtbl;

    interface ITfCreatePropertyStore
    {
        CONST_VTBL struct ITfCreatePropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCreatePropertyStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCreatePropertyStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCreatePropertyStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCreatePropertyStore_IsStoreSerializable(This,guidProp,pRange,pPropStore,pfSerializable)	\
    (This)->lpVtbl -> IsStoreSerializable(This,guidProp,pRange,pPropStore,pfSerializable)

#define ITfCreatePropertyStore_CreatePropertyStore(This,guidProp,pRange,cb,pStream,ppStore)	\
    (This)->lpVtbl -> CreatePropertyStore(This,guidProp,pRange,cb,pStream,ppStore)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCreatePropertyStore_IsStoreSerializable_Proxy( 
    ITfCreatePropertyStore * This,
    /* [in] */ REFGUID guidProp,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfPropertyStore *pPropStore,
    /* [out] */ BOOL *pfSerializable);


void __RPC_STUB ITfCreatePropertyStore_IsStoreSerializable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCreatePropertyStore_CreatePropertyStore_Proxy( 
    ITfCreatePropertyStore * This,
    /* [in] */ REFGUID guidProp,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ULONG cb,
    /* [in] */ IStream *pStream,
    /* [out] */ ITfPropertyStore **ppStore);


void __RPC_STUB ITfCreatePropertyStore_CreatePropertyStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCreatePropertyStore_INTERFACE_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ef89150-0807-11d3-8df0-00105a2799b5")
    ITfPersistentPropertyLoaderACP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderACP * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderACPVtbl;

    interface ITfPersistentPropertyLoaderACP
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderACP_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderACP_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderACP * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderACP_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfProperty_INTERFACE_DEFINED__
#define __ITfProperty_INTERFACE_DEFINED__

/* interface ITfProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e2449660-9542-11d2-bf46-00105a2799b5")
    ITfProperty : public ITfReadOnlyProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueStore( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfPropertyVtbl;

    interface ITfProperty
    {
        CONST_VTBL struct ITfPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty_FindRange_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfProperty_FindRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_SetValueStore_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfPropertyStore *pPropStore);


void __RPC_STUB ITfProperty_SetValueStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_SetValue_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ITfProperty_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_Clear_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfProperty_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumTfProperties_INTERFACE_DEFINED__
#define __IEnumTfProperties_INTERFACE_DEFINED__

/* interface IEnumTfProperties */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19188cb0-aca9-11d2-afc5-00105a2799b5")
    IEnumTfProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfProperties **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfProperty **ppProp,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfProperties * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfProperties * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfProperty **ppProp,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfProperties * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfPropertiesVtbl;

    interface IEnumTfProperties
    {
        CONST_VTBL struct IEnumTfPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfProperties_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfProperties_Next(This,ulCount,ppProp,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppProp,pcFetched)

#define IEnumTfProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfProperties_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfProperties_Clone_Proxy( 
    IEnumTfProperties * This,
    /* [out] */ IEnumTfProperties **ppEnum);


void __RPC_STUB IEnumTfProperties_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Next_Proxy( 
    IEnumTfProperties * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfProperty **ppProp,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfProperties_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Reset_Proxy( 
    IEnumTfProperties * This);


void __RPC_STUB IEnumTfProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Skip_Proxy( 
    IEnumTfProperties * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfProperties_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfProperties_INTERFACE_DEFINED__ */


#ifndef __ITfCompartment_INTERFACE_DEFINED__
#define __ITfCompartment_INTERFACE_DEFINED__

/* interface ITfCompartment */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb08f7a9-607a-4384-8623-056892b64371")
    ITfCompartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ TfClientId tid,
            /* [in] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfCompartment * This,
            /* [in] */ TfClientId tid,
            /* [in] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfCompartment * This,
            /* [out] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ITfCompartmentVtbl;

    interface ITfCompartment
    {
        CONST_VTBL struct ITfCompartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartment_SetValue(This,tid,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,tid,pvarValue)

#define ITfCompartment_GetValue(This,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartment_SetValue_Proxy( 
    ITfCompartment * This,
    /* [in] */ TfClientId tid,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ITfCompartment_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartment_GetValue_Proxy( 
    ITfCompartment * This,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfCompartment_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartment_INTERFACE_DEFINED__ */


#ifndef __ITfCompartmentEventSink_INTERFACE_DEFINED__
#define __ITfCompartmentEventSink_INTERFACE_DEFINED__

/* interface ITfCompartmentEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartmentEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("743abd5f-f26d-48df-8cc5-238492419b64")
    ITfCompartmentEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ REFGUID rguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartmentEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartmentEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartmentEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfCompartmentEventSink * This,
            /* [in] */ REFGUID rguid);
        
        END_INTERFACE
    } ITfCompartmentEventSinkVtbl;

    interface ITfCompartmentEventSink
    {
        CONST_VTBL struct ITfCompartmentEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartmentEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartmentEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartmentEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartmentEventSink_OnChange(This,rguid)	\
    (This)->lpVtbl -> OnChange(This,rguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartmentEventSink_OnChange_Proxy( 
    ITfCompartmentEventSink * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCompartmentEventSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartmentEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfCompartmentMgr_INTERFACE_DEFINED__
#define __ITfCompartmentMgr_INTERFACE_DEFINED__

/* interface ITfCompartmentMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartmentMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7dcf57ac-18ad-438b-824d-979bffb74b7c")
    ITfCompartmentMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCompartment( 
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfCompartment **ppcomp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCompartment( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCompartments( 
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartmentMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartmentMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartmentMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompartment )( 
            ITfCompartmentMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfCompartment **ppcomp);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCompartment )( 
            ITfCompartmentMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompartments )( 
            ITfCompartmentMgr * This,
            /* [out] */ IEnumGUID **ppEnum);
        
        END_INTERFACE
    } ITfCompartmentMgrVtbl;

    interface ITfCompartmentMgr
    {
        CONST_VTBL struct ITfCompartmentMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartmentMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartmentMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartmentMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartmentMgr_GetCompartment(This,rguid,ppcomp)	\
    (This)->lpVtbl -> GetCompartment(This,rguid,ppcomp)

#define ITfCompartmentMgr_ClearCompartment(This,tid,rguid)	\
    (This)->lpVtbl -> ClearCompartment(This,tid,rguid)

#define ITfCompartmentMgr_EnumCompartments(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompartments(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_GetCompartment_Proxy( 
    ITfCompartmentMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ ITfCompartment **ppcomp);


void __RPC_STUB ITfCompartmentMgr_GetCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_ClearCompartment_Proxy( 
    ITfCompartmentMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCompartmentMgr_ClearCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_EnumCompartments_Proxy( 
    ITfCompartmentMgr * This,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCompartmentMgr_EnumCompartments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartmentMgr_INTERFACE_DEFINED__ */


#ifndef __ITfFunction_INTERFACE_DEFINED__
#define __ITfFunction_INTERFACE_DEFINED__

/* interface ITfFunction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFunction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db593490-098f-11d3-8df0-00105a2799b5")
    ITfFunction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFunctionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFunction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFunction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFunction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFunction * This,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } ITfFunctionVtbl;

    interface ITfFunction
    {
        CONST_VTBL struct ITfFunctionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFunction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFunction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFunction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFunction_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFunction_GetDisplayName_Proxy( 
    ITfFunction * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB ITfFunction_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFunction_INTERFACE_DEFINED__ */


#ifndef __ITfFunctionProvider_INTERFACE_DEFINED__
#define __ITfFunctionProvider_INTERFACE_DEFINED__

/* interface ITfFunctionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFunctionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("101d6610-0990-11d3-8df0-00105a2799b5")
    ITfFunctionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFunctionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFunctionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFunctionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFunctionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfFunctionProvider * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ITfFunctionProvider * This,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ITfFunctionProvider * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ITfFunctionProviderVtbl;

    interface ITfFunctionProvider
    {
        CONST_VTBL struct ITfFunctionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFunctionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFunctionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFunctionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFunctionProvider_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfFunctionProvider_GetDescription(This,pbstrDesc)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDesc)

#define ITfFunctionProvider_GetFunction(This,rguid,riid,ppunk)	\
    (This)->lpVtbl -> GetFunction(This,rguid,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetType_Proxy( 
    ITfFunctionProvider * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfFunctionProvider_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetDescription_Proxy( 
    ITfFunctionProvider * This,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfFunctionProvider_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetFunction_Proxy( 
    ITfFunctionProvider * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfFunctionProvider_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFunctionProvider_INTERFACE_DEFINED__ */


#ifndef __IEnumTfFunctionProviders_INTERFACE_DEFINED__
#define __IEnumTfFunctionProviders_INTERFACE_DEFINED__

/* interface IEnumTfFunctionProviders */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfFunctionProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e4b24db0-0990-11d3-8df0-00105a2799b5")
    IEnumTfFunctionProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfFunctionProviders **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
            /* [out] */ ULONG *pcFetch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfFunctionProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfFunctionProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfFunctionProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfFunctionProviders * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
            /* [out] */ ULONG *pcFetch);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfFunctionProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfFunctionProvidersVtbl;

    interface IEnumTfFunctionProviders
    {
        CONST_VTBL struct IEnumTfFunctionProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfFunctionProviders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfFunctionProviders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfFunctionProviders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfFunctionProviders_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfFunctionProviders_Next(This,ulCount,ppCmdobj,pcFetch)	\
    (This)->lpVtbl -> Next(This,ulCount,ppCmdobj,pcFetch)

#define IEnumTfFunctionProviders_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfFunctionProviders_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Clone_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [out] */ IEnumTfFunctionProviders **ppEnum);


void __RPC_STUB IEnumTfFunctionProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Next_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
    /* [out] */ ULONG *pcFetch);


void __RPC_STUB IEnumTfFunctionProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Reset_Proxy( 
    IEnumTfFunctionProviders * This);


void __RPC_STUB IEnumTfFunctionProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Skip_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfFunctionProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfFunctionProviders_INTERFACE_DEFINED__ */


#ifndef __ITfInputProcessorProfiles_INTERFACE_DEFINED__
#define __ITfInputProcessorProfiles_INTERFACE_DEFINED__

/* interface ITfInputProcessorProfiles */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfInputProcessorProfiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F02B6C5-7842-4EE6-8A0B-9A24183A95CA")
    ITfInputProcessorProfiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [size_is][in] */ const WCHAR *pchIconFile,
            /* [in] */ ULONG cchFile,
            /* [in] */ ULONG uIconIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputProcessorInfo( 
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultLanguageProfile( 
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID catid,
            /* [out] */ CLSID *pclsid,
            /* [out] */ GUID *pguidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultLanguageProfile( 
            /* [in] */ LANGID langid,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID guidProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ LANGID *plangid,
            /* [out] */ GUID *pguidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageProfileDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BSTR *pbstrProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLanguage( 
            /* [out] */ LANGID *plangid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeCurrentLanguage( 
            /* [in] */ LANGID langid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageList( 
            /* [out] */ LANGID **ppLangId,
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumLanguageProfiles( 
            /* [in] */ LANGID langid,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabledLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BOOL *pfEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLanguageProfileByDefault( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubstituteKeyboardLayout( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ HKL hKL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInputProcessorProfilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfInputProcessorProfiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfInputProcessorProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *AddLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [size_is][in] */ const WCHAR *pchIconFile,
            /* [in] */ ULONG cchFile,
            /* [in] */ ULONG uIconIndex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputProcessorInfo )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID catid,
            /* [out] */ CLSID *pclsid,
            /* [out] */ GUID *pguidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID guidProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ LANGID *plangid,
            /* [out] */ GUID *pguidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageProfileDescription )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BSTR *pbstrProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLanguage )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ LANGID *plangid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeCurrentLanguage )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageList )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ LANGID **ppLangId,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *EnumLanguageProfiles )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabledLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BOOL *pfEnable);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLanguageProfileByDefault )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteKeyboardLayout )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ HKL hKL);
        
        END_INTERFACE
    } ITfInputProcessorProfilesVtbl;

    interface ITfInputProcessorProfiles
    {
        CONST_VTBL struct ITfInputProcessorProfilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInputProcessorProfiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfInputProcessorProfiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfInputProcessorProfiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfInputProcessorProfiles_Register(This,rclsid)	\
    (This)->lpVtbl -> Register(This,rclsid)

#define ITfInputProcessorProfiles_Unregister(This,rclsid)	\
    (This)->lpVtbl -> Unregister(This,rclsid)

#define ITfInputProcessorProfiles_AddLanguageProfile(This,rclsid,langid,guidProfile,pchDesc,cchDesc,pchIconFile,cchFile,uIconIndex)	\
    (This)->lpVtbl -> AddLanguageProfile(This,rclsid,langid,guidProfile,pchDesc,cchDesc,pchIconFile,cchFile,uIconIndex)

#define ITfInputProcessorProfiles_RemoveLanguageProfile(This,rclsid,langid,guidProfile)	\
    (This)->lpVtbl -> RemoveLanguageProfile(This,rclsid,langid,guidProfile)

#define ITfInputProcessorProfiles_EnumInputProcessorInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumInputProcessorInfo(This,ppEnum)

#define ITfInputProcessorProfiles_GetDefaultLanguageProfile(This,langid,catid,pclsid,pguidProfile)	\
    (This)->lpVtbl -> GetDefaultLanguageProfile(This,langid,catid,pclsid,pguidProfile)

#define ITfInputProcessorProfiles_SetDefaultLanguageProfile(This,langid,rclsid,guidProfiles)	\
    (This)->lpVtbl -> SetDefaultLanguageProfile(This,langid,rclsid,guidProfiles)

#define ITfInputProcessorProfiles_ActivateLanguageProfile(This,rclsid,langid,guidProfiles)	\
    (This)->lpVtbl -> ActivateLanguageProfile(This,rclsid,langid,guidProfiles)

#define ITfInputProcessorProfiles_GetActiveLanguageProfile(This,rclsid,plangid,pguidProfile)	\
    (This)->lpVtbl -> GetActiveLanguageProfile(This,rclsid,plangid,pguidProfile)

#define ITfInputProcessorProfiles_GetLanguageProfileDescription(This,rclsid,langid,guidProfile,pbstrProfile)	\
    (This)->lpVtbl -> GetLanguageProfileDescription(This,rclsid,langid,guidProfile,pbstrProfile)

#define ITfInputProcessorProfiles_GetCurrentLanguage(This,plangid)	\
    (This)->lpVtbl -> GetCurrentLanguage(This,plangid)

#define ITfInputProcessorProfiles_ChangeCurrentLanguage(This,langid)	\
    (This)->lpVtbl -> ChangeCurrentLanguage(This,langid)

#define ITfInputProcessorProfiles_GetLanguageList(This,ppLangId,pulCount)	\
    (This)->lpVtbl -> GetLanguageList(This,ppLangId,pulCount)

#define ITfInputProcessorProfiles_EnumLanguageProfiles(This,langid,ppEnum)	\
    (This)->lpVtbl -> EnumLanguageProfiles(This,langid,ppEnum)

#define ITfInputProcessorProfiles_EnableLanguageProfile(This,rclsid,langid,guidProfile,fEnable)	\
    (This)->lpVtbl -> EnableLanguageProfile(This,rclsid,langid,guidProfile,fEnable)

#define ITfInputProcessorProfiles_IsEnabledLanguageProfile(This,rclsid,langid,guidProfile,pfEnable)	\
    (This)->lpVtbl -> IsEnabledLanguageProfile(This,rclsid,langid,guidProfile,pfEnable)

#define ITfInputProcessorProfiles_EnableLanguageProfileByDefault(This,rclsid,langid,guidProfile,fEnable)	\
    (This)->lpVtbl -> EnableLanguageProfileByDefault(This,rclsid,langid,guidProfile,fEnable)

#define ITfInputProcessorProfiles_SubstituteKeyboardLayout(This,rclsid,langid,guidProfile,hKL)	\
    (This)->lpVtbl -> SubstituteKeyboardLayout(This,rclsid,langid,guidProfile,hKL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_Register_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ITfInputProcessorProfiles_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_Unregister_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ITfInputProcessorProfiles_Unregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_AddLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc,
    /* [size_is][in] */ const WCHAR *pchIconFile,
    /* [in] */ ULONG cchFile,
    /* [in] */ ULONG uIconIndex);


void __RPC_STUB ITfInputProcessorProfiles_AddLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_RemoveLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB ITfInputProcessorProfiles_RemoveLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnumInputProcessorInfo_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfInputProcessorProfiles_EnumInputProcessorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetDefaultLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID catid,
    /* [out] */ CLSID *pclsid,
    /* [out] */ GUID *pguidProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetDefaultLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_SetDefaultLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID guidProfiles);


void __RPC_STUB ITfInputProcessorProfiles_SetDefaultLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_ActivateLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfiles);


void __RPC_STUB ITfInputProcessorProfiles_ActivateLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetActiveLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ LANGID *plangid,
    /* [out] */ GUID *pguidProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetActiveLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetLanguageProfileDescription_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ BSTR *pbstrProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetLanguageProfileDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetCurrentLanguage_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ LANGID *plangid);


void __RPC_STUB ITfInputProcessorProfiles_GetCurrentLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_ChangeCurrentLanguage_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid);


void __RPC_STUB ITfInputProcessorProfiles_ChangeCurrentLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetLanguageList_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ LANGID **ppLangId,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB ITfInputProcessorProfiles_GetLanguageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnumLanguageProfiles_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [out] */ IEnumTfLanguageProfiles **ppEnum);


void __RPC_STUB ITfInputProcessorProfiles_EnumLanguageProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnableLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfInputProcessorProfiles_EnableLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_IsEnabledLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ BOOL *pfEnable);


void __RPC_STUB ITfInputProcessorProfiles_IsEnabledLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnableLanguageProfileByDefault_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfInputProcessorProfiles_EnableLanguageProfileByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_SubstituteKeyboardLayout_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ HKL hKL);


void __RPC_STUB ITfInputProcessorProfiles_SubstituteKeyboardLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfInputProcessorProfiles_INTERFACE_DEFINED__ */


#ifndef __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__
#define __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__

/* interface ITfActiveLanguageProfileNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfActiveLanguageProfileNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b246cb75-a93e-4652-bf8c-b3fe0cfd7e57")
    ITfActiveLanguageProfileNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnActivated( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fActivated) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfActiveLanguageProfileNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfActiveLanguageProfileNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfActiveLanguageProfileNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfActiveLanguageProfileNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivated )( 
            ITfActiveLanguageProfileNotifySink * This,
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fActivated);
        
        END_INTERFACE
    } ITfActiveLanguageProfileNotifySinkVtbl;

    interface ITfActiveLanguageProfileNotifySink
    {
        CONST_VTBL struct ITfActiveLanguageProfileNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfActiveLanguageProfileNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfActiveLanguageProfileNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfActiveLanguageProfileNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfActiveLanguageProfileNotifySink_OnActivated(This,clsid,guidProfile,fActivated)	\
    (This)->lpVtbl -> OnActivated(This,clsid,guidProfile,fActivated)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfActiveLanguageProfileNotifySink_OnActivated_Proxy( 
    ITfActiveLanguageProfileNotifySink * This,
    /* [in] */ REFCLSID clsid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fActivated);


void __RPC_STUB ITfActiveLanguageProfileNotifySink_OnActivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__ */


#ifndef __IEnumTfLanguageProfiles_INTERFACE_DEFINED__
#define __IEnumTfLanguageProfiles_INTERFACE_DEFINED__

/* interface IEnumTfLanguageProfiles */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLanguageProfiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d61bf11-ac5f-42c8-a4cb-931bcc28c744")
    IEnumTfLanguageProfiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLanguageProfiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
            /* [out] */ ULONG *pcFetch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLanguageProfilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLanguageProfiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLanguageProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLanguageProfiles * This,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
            /* [out] */ ULONG *pcFetch);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLanguageProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLanguageProfilesVtbl;

    interface IEnumTfLanguageProfiles
    {
        CONST_VTBL struct IEnumTfLanguageProfilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLanguageProfiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLanguageProfiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLanguageProfiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLanguageProfiles_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLanguageProfiles_Next(This,ulCount,pProfile,pcFetch)	\
    (This)->lpVtbl -> Next(This,ulCount,pProfile,pcFetch)

#define IEnumTfLanguageProfiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLanguageProfiles_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Clone_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [out] */ IEnumTfLanguageProfiles **ppEnum);


void __RPC_STUB IEnumTfLanguageProfiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Next_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
    /* [out] */ ULONG *pcFetch);


void __RPC_STUB IEnumTfLanguageProfiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Reset_Proxy( 
    IEnumTfLanguageProfiles * This);


void __RPC_STUB IEnumTfLanguageProfiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Skip_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLanguageProfiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLanguageProfiles_INTERFACE_DEFINED__ */


#ifndef __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__
#define __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__

/* interface ITfLanguageProfileNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLanguageProfileNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43c9fe15-f494-4c17-9de2-b8a4ac350aa8")
    ITfLanguageProfileNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLanguageChange( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLanguageChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLanguageProfileNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLanguageProfileNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLanguageProfileNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLanguageProfileNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLanguageChange )( 
            ITfLanguageProfileNotifySink * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccept);
        
        HRESULT ( STDMETHODCALLTYPE *OnLanguageChanged )( 
            ITfLanguageProfileNotifySink * This);
        
        END_INTERFACE
    } ITfLanguageProfileNotifySinkVtbl;

    interface ITfLanguageProfileNotifySink
    {
        CONST_VTBL struct ITfLanguageProfileNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLanguageProfileNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLanguageProfileNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLanguageProfileNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLanguageProfileNotifySink_OnLanguageChange(This,langid,pfAccept)	\
    (This)->lpVtbl -> OnLanguageChange(This,langid,pfAccept)

#define ITfLanguageProfileNotifySink_OnLanguageChanged(This)	\
    (This)->lpVtbl -> OnLanguageChanged(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLanguageProfileNotifySink_OnLanguageChange_Proxy( 
    ITfLanguageProfileNotifySink * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAccept);


void __RPC_STUB ITfLanguageProfileNotifySink_OnLanguageChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLanguageProfileNotifySink_OnLanguageChanged_Proxy( 
    ITfLanguageProfileNotifySink * This);


void __RPC_STUB ITfLanguageProfileNotifySink_OnLanguageChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0196 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("77c12f95-b783-450d-879f-1cd2362c6521") struct TF_PRESERVEDKEY
    {
    UINT uVKey;
    UINT uModifiers;
    } 	TF_PRESERVEDKEY;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0196_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0196_v0_0_s_ifspec;

#ifndef __ITfKeystrokeMgr_INTERFACE_DEFINED__
#define __ITfKeystrokeMgr_INTERFACE_DEFINED__

/* interface ITfKeystrokeMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeystrokeMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f0-2021-11d2-93e0-0060b067b86e")
    ITfKeystrokeMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseKeyEventSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseKeyEventSink( 
            /* [in] */ TfClientId tid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreservedKey( 
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreserveKey( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnpreserveKey( 
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreservedKeyDescription( 
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreservedKeyDescription( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulatePreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeystrokeMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeystrokeMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeystrokeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseKeyEventSink )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseKeyEventSink )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *GetForeground )( 
            ITfKeystrokeMgr * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyDown )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyUp )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnpreserveKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreservedKeyDescription )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKeyDescription )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SimulatePreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeystrokeMgrVtbl;

    interface ITfKeystrokeMgr
    {
        CONST_VTBL struct ITfKeystrokeMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeystrokeMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeystrokeMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeystrokeMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeystrokeMgr_AdviseKeyEventSink(This,tid,pSink,fForeground)	\
    (This)->lpVtbl -> AdviseKeyEventSink(This,tid,pSink,fForeground)

#define ITfKeystrokeMgr_UnadviseKeyEventSink(This,tid)	\
    (This)->lpVtbl -> UnadviseKeyEventSink(This,tid)

#define ITfKeystrokeMgr_GetForeground(This,pclsid)	\
    (This)->lpVtbl -> GetForeground(This,pclsid)

#define ITfKeystrokeMgr_TestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_TestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_KeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_KeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_GetPreservedKey(This,pic,pprekey,pguid)	\
    (This)->lpVtbl -> GetPreservedKey(This,pic,pprekey,pguid)

#define ITfKeystrokeMgr_IsPreservedKey(This,rguid,pprekey,pfRegistered)	\
    (This)->lpVtbl -> IsPreservedKey(This,rguid,pprekey,pfRegistered)

#define ITfKeystrokeMgr_PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)	\
    (This)->lpVtbl -> PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)

#define ITfKeystrokeMgr_UnpreserveKey(This,rguid,pprekey)	\
    (This)->lpVtbl -> UnpreserveKey(This,rguid,pprekey)

#define ITfKeystrokeMgr_SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)	\
    (This)->lpVtbl -> SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)

#define ITfKeystrokeMgr_GetPreservedKeyDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetPreservedKeyDescription(This,rguid,pbstrDesc)

#define ITfKeystrokeMgr_SimulatePreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> SimulatePreservedKey(This,pic,rguid,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_AdviseKeyEventSink_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ ITfKeyEventSink *pSink,
    /* [in] */ BOOL fForeground);


void __RPC_STUB ITfKeystrokeMgr_AdviseKeyEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_UnadviseKeyEventSink_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid);


void __RPC_STUB ITfKeystrokeMgr_UnadviseKeyEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetForeground_Proxy( 
    ITfKeystrokeMgr * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfKeystrokeMgr_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_TestKeyDown_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_TestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_TestKeyUp_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_TestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_KeyDown_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_KeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_KeyUp_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_KeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetPreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ const TF_PRESERVEDKEY *pprekey,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfKeystrokeMgr_GetPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_IsPreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *pprekey,
    /* [out] */ BOOL *pfRegistered);


void __RPC_STUB ITfKeystrokeMgr_IsPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_PreserveKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *prekey,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc);


void __RPC_STUB ITfKeystrokeMgr_PreserveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_UnpreserveKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *pprekey);


void __RPC_STUB ITfKeystrokeMgr_UnpreserveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_SetPreservedKeyDescription_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc);


void __RPC_STUB ITfKeystrokeMgr_SetPreservedKeyDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetPreservedKeyDescription_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfKeystrokeMgr_GetPreservedKeyDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_SimulatePreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_SimulatePreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeystrokeMgr_INTERFACE_DEFINED__ */


#ifndef __ITfKeyEventSink_INTERFACE_DEFINED__
#define __ITfKeyEventSink_INTERFACE_DEFINED__

/* interface ITfKeyEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeyEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f5-2021-11d2-93e0-0060b067b86e")
    ITfKeyEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ BOOL fForeground) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyDown( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyUp( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyUp( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeyEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeyEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeyEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeyEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfKeyEventSink * This,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyDown )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyUp )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyUp )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreservedKey )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeyEventSinkVtbl;

    interface ITfKeyEventSink
    {
        CONST_VTBL struct ITfKeyEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeyEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeyEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeyEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeyEventSink_OnSetFocus(This,fForeground)	\
    (This)->lpVtbl -> OnSetFocus(This,fForeground)

#define ITfKeyEventSink_OnTestKeyDown(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyDown(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnTestKeyUp(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyUp(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnKeyDown(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyDown(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnKeyUp(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyUp(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnPreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> OnPreservedKey(This,pic,rguid,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnSetFocus_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ BOOL fForeground);


void __RPC_STUB ITfKeyEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnTestKeyDown_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnTestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnTestKeyUp_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnTestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnKeyDown_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnKeyUp_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnPreservedKey_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeyEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfKeyTraceEventSink_INTERFACE_DEFINED__
#define __ITfKeyTraceEventSink_INTERFACE_DEFINED__

/* interface ITfKeyTraceEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeyTraceEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cd4c13b-1c36-4191-a70a-7f3e611f367d")
    ITfKeyTraceEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnKeyTraceDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyTraceUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeyTraceEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeyTraceEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeyTraceEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyTraceDown )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyTraceUp )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfKeyTraceEventSinkVtbl;

    interface ITfKeyTraceEventSink
    {
        CONST_VTBL struct ITfKeyTraceEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeyTraceEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeyTraceEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeyTraceEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeyTraceEventSink_OnKeyTraceDown(This,wParam,lParam)	\
    (This)->lpVtbl -> OnKeyTraceDown(This,wParam,lParam)

#define ITfKeyTraceEventSink_OnKeyTraceUp(This,wParam,lParam)	\
    (This)->lpVtbl -> OnKeyTraceUp(This,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeyTraceEventSink_OnKeyTraceDown_Proxy( 
    ITfKeyTraceEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfKeyTraceEventSink_OnKeyTraceDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyTraceEventSink_OnKeyTraceUp_Proxy( 
    ITfKeyTraceEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfKeyTraceEventSink_OnKeyTraceUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeyTraceEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__
#define __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__

/* interface ITfPreservedKeyNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPreservedKeyNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f77c993-d2b1-446e-853e-5912efc8a286")
    ITfPreservedKeyNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdated( 
            /* [in] */ const TF_PRESERVEDKEY *pprekey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPreservedKeyNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPreservedKeyNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPreservedKeyNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPreservedKeyNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdated )( 
            ITfPreservedKeyNotifySink * This,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        END_INTERFACE
    } ITfPreservedKeyNotifySinkVtbl;

    interface ITfPreservedKeyNotifySink
    {
        CONST_VTBL struct ITfPreservedKeyNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPreservedKeyNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPreservedKeyNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPreservedKeyNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPreservedKeyNotifySink_OnUpdated(This,pprekey)	\
    (This)->lpVtbl -> OnUpdated(This,pprekey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPreservedKeyNotifySink_OnUpdated_Proxy( 
    ITfPreservedKeyNotifySink * This,
    /* [in] */ const TF_PRESERVEDKEY *pprekey);


void __RPC_STUB ITfPreservedKeyNotifySink_OnUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfMessagePump_INTERFACE_DEFINED__
#define __ITfMessagePump_INTERFACE_DEFINED__

/* interface ITfMessagePump */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfMessagePump;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f1b8ad8-0b6b-4874-90c5-bd76011e8f7c")
    ITfMessagePump : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PeekMessageA( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageA( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PeekMessageW( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageW( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMessagePumpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMessagePump * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMessagePump * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMessagePump * This);
        
        HRESULT ( STDMETHODCALLTYPE *PeekMessageA )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageA )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *PeekMessageW )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageW )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult);
        
        END_INTERFACE
    } ITfMessagePumpVtbl;

    interface ITfMessagePump
    {
        CONST_VTBL struct ITfMessagePumpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMessagePump_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMessagePump_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMessagePump_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMessagePump_PeekMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)	\
    (This)->lpVtbl -> PeekMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)

#define ITfMessagePump_GetMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)	\
    (This)->lpVtbl -> GetMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)

#define ITfMessagePump_PeekMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)	\
    (This)->lpVtbl -> PeekMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)

#define ITfMessagePump_GetMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)	\
    (This)->lpVtbl -> GetMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMessagePump_PeekMessageA_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [in] */ UINT wRemoveMsg,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_PeekMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_GetMessageA_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_GetMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_PeekMessageW_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [in] */ UINT wRemoveMsg,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_PeekMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_GetMessageW_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_GetMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMessagePump_INTERFACE_DEFINED__ */


#ifndef __ITfThreadFocusSink_INTERFACE_DEFINED__
#define __ITfThreadFocusSink_INTERFACE_DEFINED__

/* interface ITfThreadFocusSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfThreadFocusSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0f1db0c-3a20-405c-a303-96b6010a885f")
    ITfThreadFocusSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetThreadFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKillThreadFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadFocusSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadFocusSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadFocusSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadFocusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetThreadFocus )( 
            ITfThreadFocusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKillThreadFocus )( 
            ITfThreadFocusSink * This);
        
        END_INTERFACE
    } ITfThreadFocusSinkVtbl;

    interface ITfThreadFocusSink
    {
        CONST_VTBL struct ITfThreadFocusSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadFocusSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadFocusSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadFocusSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadFocusSink_OnSetThreadFocus(This)	\
    (This)->lpVtbl -> OnSetThreadFocus(This)

#define ITfThreadFocusSink_OnKillThreadFocus(This)	\
    (This)->lpVtbl -> OnKillThreadFocus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadFocusSink_OnSetThreadFocus_Proxy( 
    ITfThreadFocusSink * This);


void __RPC_STUB ITfThreadFocusSink_OnSetThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadFocusSink_OnKillThreadFocus_Proxy( 
    ITfThreadFocusSink * This);


void __RPC_STUB ITfThreadFocusSink_OnKillThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadFocusSink_INTERFACE_DEFINED__ */


#ifndef __ITfTextInputProcessor_INTERFACE_DEFINED__
#define __ITfTextInputProcessor_INTERFACE_DEFINED__

/* interface ITfTextInputProcessor */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfTextInputProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f7-2021-11d2-93e0-0060b067b86e")
    ITfTextInputProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ITfThreadMgr *ptim,
            /* [in] */ TfClientId tid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextInputProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextInputProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextInputProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextInputProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfTextInputProcessor * This,
            /* [in] */ ITfThreadMgr *ptim,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfTextInputProcessor * This);
        
        END_INTERFACE
    } ITfTextInputProcessorVtbl;

    interface ITfTextInputProcessor
    {
        CONST_VTBL struct ITfTextInputProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextInputProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextInputProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextInputProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextInputProcessor_Activate(This,ptim,tid)	\
    (This)->lpVtbl -> Activate(This,ptim,tid)

#define ITfTextInputProcessor_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextInputProcessor_Activate_Proxy( 
    ITfTextInputProcessor * This,
    /* [in] */ ITfThreadMgr *ptim,
    /* [in] */ TfClientId tid);


void __RPC_STUB ITfTextInputProcessor_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfTextInputProcessor_Deactivate_Proxy( 
    ITfTextInputProcessor * This);


void __RPC_STUB ITfTextInputProcessor_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextInputProcessor_INTERFACE_DEFINED__ */


#ifndef __ITfClientId_INTERFACE_DEFINED__
#define __ITfClientId_INTERFACE_DEFINED__

/* interface ITfClientId */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfClientId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d60a7b49-1b9f-4be2-b702-47e9dc05dec3")
    ITfClientId : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientId( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ TfClientId *ptid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfClientIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfClientId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfClientId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfClientId * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientId )( 
            ITfClientId * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ TfClientId *ptid);
        
        END_INTERFACE
    } ITfClientIdVtbl;

    interface ITfClientId
    {
        CONST_VTBL struct ITfClientIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfClientId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfClientId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfClientId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfClientId_GetClientId(This,rclsid,ptid)	\
    (This)->lpVtbl -> GetClientId(This,rclsid,ptid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfClientId_GetClientId_Proxy( 
    ITfClientId * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ TfClientId *ptid);


void __RPC_STUB ITfClientId_GetClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfClientId_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0204 */
/* [local] */ 

typedef /* [public][public][public][public][uuid] */  DECLSPEC_UUID("c4cc07f1-80cc-4a7b-bc54-98512782cbe3") 
enum __MIDL___MIDL_itf_msctf_0204_0001
    {	TF_LS_NONE	= 0,
	TF_LS_SOLID	= 1,
	TF_LS_DOT	= 2,
	TF_LS_DASH	= 3,
	TF_LS_SQUIGGLE	= 4
    } 	TF_DA_LINESTYLE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("d9b92e21-084a-401b-9c64-1e6dad91a1ab") 
enum __MIDL___MIDL_itf_msctf_0204_0002
    {	TF_CT_NONE	= 0,
	TF_CT_SYSCOLOR	= 1,
	TF_CT_COLORREF	= 2
    } 	TF_DA_COLORTYPE;

typedef /* [uuid] */  DECLSPEC_UUID("90d0cb5e-6520-4a0f-b47c-c39bd955f0d6") struct TF_DA_COLOR
    {
    TF_DA_COLORTYPE type;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ int nIndex;
        /* [case()] */ COLORREF cr;
        } 	;
    } 	TF_DA_COLOR;

typedef /* [public][public][public][public][uuid] */  DECLSPEC_UUID("33d2fe4b-6c24-4f67-8d75-3bc1819e4126") 
enum __MIDL___MIDL_itf_msctf_0204_0004
    {	TF_ATTR_INPUT	= 0,
	TF_ATTR_TARGET_CONVERTED	= 1,
	TF_ATTR_CONVERTED	= 2,
	TF_ATTR_TARGET_NOTCONVERTED	= 3,
	TF_ATTR_INPUT_ERROR	= 4,
	TF_ATTR_FIXEDCONVERTED	= 5,
	TF_ATTR_OTHER	= -1
    } 	TF_DA_ATTR_INFO;

typedef /* [uuid] */  DECLSPEC_UUID("1bf1c305-419b-4182-a4d2-9bfadc3f021f") struct TF_DISPLAYATTRIBUTE
    {
    TF_DA_COLOR crText;
    TF_DA_COLOR crBk;
    TF_DA_LINESTYLE lsStyle;
    BOOL fBoldLine;
    TF_DA_COLOR crLine;
    TF_DA_ATTR_INFO bAttr;
    } 	TF_DISPLAYATTRIBUTE;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0204_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0204_v0_0_s_ifspec;

#ifndef __ITfDisplayAttributeInfo_INTERFACE_DEFINED__
#define __ITfDisplayAttributeInfo_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70528852-2f26-4aea-8c96-215150578932")
    ITfDisplayAttributeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeInfo( 
            /* [out] */ TF_DISPLAYATTRIBUTE *pda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributeInfo( 
            /* [in] */ TF_DISPLAYATTRIBUTE *pda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeInfo )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ TF_DISPLAYATTRIBUTE *pda);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttributeInfo )( 
            ITfDisplayAttributeInfo * This,
            /* [in] */ TF_DISPLAYATTRIBUTE *pda);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ITfDisplayAttributeInfo * This);
        
        END_INTERFACE
    } ITfDisplayAttributeInfoVtbl;

    interface ITfDisplayAttributeInfo
    {
        CONST_VTBL struct ITfDisplayAttributeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeInfo_GetGUID(This,pguid)	\
    (This)->lpVtbl -> GetGUID(This,pguid)

#define ITfDisplayAttributeInfo_GetDescription(This,pbstrDesc)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDesc)

#define ITfDisplayAttributeInfo_GetAttributeInfo(This,pda)	\
    (This)->lpVtbl -> GetAttributeInfo(This,pda)

#define ITfDisplayAttributeInfo_SetAttributeInfo(This,pda)	\
    (This)->lpVtbl -> SetAttributeInfo(This,pda)

#define ITfDisplayAttributeInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetGUID_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfDisplayAttributeInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetDescription_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfDisplayAttributeInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetAttributeInfo_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ TF_DISPLAYATTRIBUTE *pda);


void __RPC_STUB ITfDisplayAttributeInfo_GetAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_SetAttributeInfo_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [in] */ TF_DISPLAYATTRIBUTE *pda);


void __RPC_STUB ITfDisplayAttributeInfo_SetAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_Reset_Proxy( 
    ITfDisplayAttributeInfo * This);


void __RPC_STUB ITfDisplayAttributeInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__
#define __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__

/* interface IEnumTfDisplayAttributeInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfDisplayAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7cef04d7-cb75-4e80-a7ab-5f5bc7d332de")
    IEnumTfDisplayAttributeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfDisplayAttributeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfDisplayAttributeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfDisplayAttributeInfoVtbl;

    interface IEnumTfDisplayAttributeInfo
    {
        CONST_VTBL struct IEnumTfDisplayAttributeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfDisplayAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfDisplayAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfDisplayAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfDisplayAttributeInfo_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfDisplayAttributeInfo_Next(This,ulCount,rgInfo,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInfo,pcFetched)

#define IEnumTfDisplayAttributeInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfDisplayAttributeInfo_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Clone_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Next_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Reset_Proxy( 
    IEnumTfDisplayAttributeInfo * This);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Skip_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fee47777-163c-4769-996a-6e9c50ad8f54")
    ITfDisplayAttributeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumDisplayAttributeInfo( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayAttributeInfo( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDisplayAttributeInfo )( 
            ITfDisplayAttributeProvider * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayAttributeInfo )( 
            ITfDisplayAttributeProvider * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo);
        
        END_INTERFACE
    } ITfDisplayAttributeProviderVtbl;

    interface ITfDisplayAttributeProvider
    {
        CONST_VTBL struct ITfDisplayAttributeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeProvider_EnumDisplayAttributeInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumDisplayAttributeInfo(This,ppEnum)

#define ITfDisplayAttributeProvider_GetDisplayAttributeInfo(This,guid,ppInfo)	\
    (This)->lpVtbl -> GetDisplayAttributeInfo(This,guid,ppInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeProvider_EnumDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeProvider * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB ITfDisplayAttributeProvider_EnumDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeProvider_GetDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeProvider * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITfDisplayAttributeInfo **ppInfo);


void __RPC_STUB ITfDisplayAttributeProvider_GetDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeProvider_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ded7393-5db1-475c-9e71-a39111b0ff67")
    ITfDisplayAttributeMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateInfo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDisplayAttributeInfo( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayAttributeInfo( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo,
            /* [out] */ CLSID *pclsidOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateInfo )( 
            ITfDisplayAttributeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDisplayAttributeInfo )( 
            ITfDisplayAttributeMgr * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayAttributeInfo )( 
            ITfDisplayAttributeMgr * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo,
            /* [out] */ CLSID *pclsidOwner);
        
        END_INTERFACE
    } ITfDisplayAttributeMgrVtbl;

    interface ITfDisplayAttributeMgr
    {
        CONST_VTBL struct ITfDisplayAttributeMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeMgr_OnUpdateInfo(This)	\
    (This)->lpVtbl -> OnUpdateInfo(This)

#define ITfDisplayAttributeMgr_EnumDisplayAttributeInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumDisplayAttributeInfo(This,ppEnum)

#define ITfDisplayAttributeMgr_GetDisplayAttributeInfo(This,guid,ppInfo,pclsidOwner)	\
    (This)->lpVtbl -> GetDisplayAttributeInfo(This,guid,ppInfo,pclsidOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_OnUpdateInfo_Proxy( 
    ITfDisplayAttributeMgr * This);


void __RPC_STUB ITfDisplayAttributeMgr_OnUpdateInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_EnumDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeMgr * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB ITfDisplayAttributeMgr_EnumDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_GetDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeMgr * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITfDisplayAttributeInfo **ppInfo,
    /* [out] */ CLSID *pclsidOwner);


void __RPC_STUB ITfDisplayAttributeMgr_GetDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__
#define __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad56f402-e162-4f25-908f-7d577cf9bda9")
    ITfDisplayAttributeNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateInfo )( 
            ITfDisplayAttributeNotifySink * This);
        
        END_INTERFACE
    } ITfDisplayAttributeNotifySinkVtbl;

    interface ITfDisplayAttributeNotifySink
    {
        CONST_VTBL struct ITfDisplayAttributeNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeNotifySink_OnUpdateInfo(This)	\
    (This)->lpVtbl -> OnUpdateInfo(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeNotifySink_OnUpdateInfo_Proxy( 
    ITfDisplayAttributeNotifySink * This);


void __RPC_STUB ITfDisplayAttributeNotifySink_OnUpdateInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfCategoryMgr_INTERFACE_DEFINED__
#define __ITfCategoryMgr_INTERFACE_DEFINED__

/* interface ITfCategoryMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfCategoryMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c3acefb5-f69d-4905-938f-fcadcf4be830")
    ITfCategoryMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategory( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterCategory( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCategoriesInItem( 
            /* [in] */ REFGUID rguid,
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItemsInCategory( 
            /* [in] */ REFGUID rcatid,
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestCategory( 
            /* [in] */ REFGUID rguid,
            /* [out] */ GUID *pcatid,
            /* [size_is][in] */ const GUID **ppcatidList,
            /* [in] */ ULONG ulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUIDDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterGUIDDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUIDDescription( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUIDDWORD( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterGUIDDWORD( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUIDDWORD( 
            /* [in] */ REFGUID rguid,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUID( 
            /* [in] */ REFGUID rguid,
            /* [out] */ TfGuidAtom *pguidatom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [in] */ TfGuidAtom guidatom,
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualTfGuidAtom( 
            /* [in] */ TfGuidAtom guidatom,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCategoryMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCategoryMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCategoryMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCategoryMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCategoriesInItem )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItemsInCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rcatid,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ GUID *pcatid,
            /* [size_is][in] */ const GUID **ppcatidList,
            /* [in] */ ULONG ulCount);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUID )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ TfGuidAtom *pguidatom);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            ITfCategoryMgr * This,
            /* [in] */ TfGuidAtom guidatom,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualTfGuidAtom )( 
            ITfCategoryMgr * This,
            /* [in] */ TfGuidAtom guidatom,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEqual);
        
        END_INTERFACE
    } ITfCategoryMgrVtbl;

    interface ITfCategoryMgr
    {
        CONST_VTBL struct ITfCategoryMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCategoryMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCategoryMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCategoryMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCategoryMgr_RegisterCategory(This,rclsid,rcatid,rguid)	\
    (This)->lpVtbl -> RegisterCategory(This,rclsid,rcatid,rguid)

#define ITfCategoryMgr_UnregisterCategory(This,rclsid,rcatid,rguid)	\
    (This)->lpVtbl -> UnregisterCategory(This,rclsid,rcatid,rguid)

#define ITfCategoryMgr_EnumCategoriesInItem(This,rguid,ppEnum)	\
    (This)->lpVtbl -> EnumCategoriesInItem(This,rguid,ppEnum)

#define ITfCategoryMgr_EnumItemsInCategory(This,rcatid,ppEnum)	\
    (This)->lpVtbl -> EnumItemsInCategory(This,rcatid,ppEnum)

#define ITfCategoryMgr_FindClosestCategory(This,rguid,pcatid,ppcatidList,ulCount)	\
    (This)->lpVtbl -> FindClosestCategory(This,rguid,pcatid,ppcatidList,ulCount)

#define ITfCategoryMgr_RegisterGUIDDescription(This,rclsid,rguid,pchDesc,cch)	\
    (This)->lpVtbl -> RegisterGUIDDescription(This,rclsid,rguid,pchDesc,cch)

#define ITfCategoryMgr_UnregisterGUIDDescription(This,rclsid,rguid)	\
    (This)->lpVtbl -> UnregisterGUIDDescription(This,rclsid,rguid)

#define ITfCategoryMgr_GetGUIDDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetGUIDDescription(This,rguid,pbstrDesc)

#define ITfCategoryMgr_RegisterGUIDDWORD(This,rclsid,rguid,dw)	\
    (This)->lpVtbl -> RegisterGUIDDWORD(This,rclsid,rguid,dw)

#define ITfCategoryMgr_UnregisterGUIDDWORD(This,rclsid,rguid)	\
    (This)->lpVtbl -> UnregisterGUIDDWORD(This,rclsid,rguid)

#define ITfCategoryMgr_GetGUIDDWORD(This,rguid,pdw)	\
    (This)->lpVtbl -> GetGUIDDWORD(This,rguid,pdw)

#define ITfCategoryMgr_RegisterGUID(This,rguid,pguidatom)	\
    (This)->lpVtbl -> RegisterGUID(This,rguid,pguidatom)

#define ITfCategoryMgr_GetGUID(This,guidatom,pguid)	\
    (This)->lpVtbl -> GetGUID(This,guidatom,pguid)

#define ITfCategoryMgr_IsEqualTfGuidAtom(This,guidatom,rguid,pfEqual)	\
    (This)->lpVtbl -> IsEqualTfGuidAtom(This,guidatom,rguid,pfEqual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rcatid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_RegisterCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rcatid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_EnumCategoriesInItem_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCategoryMgr_EnumCategoriesInItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_EnumItemsInCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rcatid,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCategoryMgr_EnumItemsInCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_FindClosestCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ GUID *pcatid,
    /* [size_is][in] */ const GUID **ppcatidList,
    /* [in] */ ULONG ulCount);


void __RPC_STUB ITfCategoryMgr_FindClosestCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfCategoryMgr_RegisterGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfCategoryMgr_GetGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid,
    /* [in] */ DWORD dw);


void __RPC_STUB ITfCategoryMgr_RegisterGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ DWORD *pdw);


void __RPC_STUB ITfCategoryMgr_GetGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUID_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ TfGuidAtom *pguidatom);


void __RPC_STUB ITfCategoryMgr_RegisterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUID_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ TfGuidAtom guidatom,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfCategoryMgr_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_IsEqualTfGuidAtom_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ TfGuidAtom guidatom,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfCategoryMgr_IsEqualTfGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCategoryMgr_INTERFACE_DEFINED__ */


#ifndef __ITfSource_INTERFACE_DEFINED__
#define __ITfSource_INTERFACE_DEFINED__

/* interface ITfSource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ea48a35-60ae-446f-8fd6-e6a8d82459f7")
    ITfSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSink( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSink )( 
            ITfSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSink )( 
            ITfSource * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfSourceVtbl;

    interface ITfSource
    {
        CONST_VTBL struct ITfSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSource_AdviseSink(This,riid,punk,pdwCookie)	\
    (This)->lpVtbl -> AdviseSink(This,riid,punk,pdwCookie)

#define ITfSource_UnadviseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSource_AdviseSink_Proxy( 
    ITfSource * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfSource_AdviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSource_UnadviseSink_Proxy( 
    ITfSource * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfSource_UnadviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSource_INTERFACE_DEFINED__ */


#ifndef __ITfSourceSingle_INTERFACE_DEFINED__
#define __ITfSourceSingle_INTERFACE_DEFINED__

/* interface ITfSourceSingle */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSourceSingle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73131f9c-56a9-49dd-b0ee-d046633f7528")
    ITfSourceSingle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSingleSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSingleSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSourceSingleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSourceSingle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSourceSingle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSourceSingle * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSingleSink )( 
            ITfSourceSingle * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSingleSink )( 
            ITfSourceSingle * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid);
        
        END_INTERFACE
    } ITfSourceSingleVtbl;

    interface ITfSourceSingle
    {
        CONST_VTBL struct ITfSourceSingleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSourceSingle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSourceSingle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSourceSingle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSourceSingle_AdviseSingleSink(This,tid,riid,punk)	\
    (This)->lpVtbl -> AdviseSingleSink(This,tid,riid,punk)

#define ITfSourceSingle_UnadviseSingleSink(This,tid,riid)	\
    (This)->lpVtbl -> UnadviseSingleSink(This,tid,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSourceSingle_AdviseSingleSink_Proxy( 
    ITfSourceSingle * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk);


void __RPC_STUB ITfSourceSingle_AdviseSingleSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSourceSingle_UnadviseSingleSink_Proxy( 
    ITfSourceSingle * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFIID riid);


void __RPC_STUB ITfSourceSingle_UnadviseSingleSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSourceSingle_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0212 */
/* [local] */ 

#endif // MSCTF_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctf_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0212_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  CLIPFORMAT_UserSize(     unsigned long *, unsigned long            , CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal(  unsigned long *, unsigned char *, CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal(unsigned long *, unsigned char *, CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree(     unsigned long *, CLIPFORMAT * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\msctf_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#include "cicclsid.c"

/* f1e2d520-0969-11d3-8df0-00105a2799b5 */
const GUID GUID_PROP_TEXTOWNER = { 
    0xf1e2d520,
    0x0969,
    0x11d3,
    {0x8d, 0xf0, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 34b45670-7526-11d2-a147-00105a2799b5 */
const GUID GUID_PROP_ATTRIBUTE = { 
    0x34b45670,
    0x7526,
    0x11d2,
    {0xa1, 0x47, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


/* 3280ce20-8032-11d2-b603-00105a2799b5 */
const GUID GUID_PROP_LANGID = { 
    0x3280ce20,
    0x8032,
    0x11d2,
    {0xb6, 0x03, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 5463f7c0-8e31-11d2-bf46-00105a2799b5 */
const GUID GUID_PROP_READING = { 
    0x5463f7c0,
    0x8e31,
    0x11d2,
    {0xbf, 0x46, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* e12ac060-af15-11d2-afc5-00105a2799b5 */
const GUID GUID_PROP_COMPOSING = {
    0xe12ac060,
    0xaf15,
    0x11d2,
    {0xaf, 0xc5, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 9a698bb0-0f21-11d3-8df1-00105a2799b5 */
const GUID GUID_SYSTEM_FUNCTIONPROVIDER = { 
    0x9a698bb0,
    0x0f21,
    0x11d3,
    {0x8d, 0xf1, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 4caef01e-12af-4b0e-9db1-a6ec5b881208 */
const GUID GUID_APP_FUNCTIONPROVIDER = { 
    0x4caef01e,
    0x12af,
    0x4b0e,
    {0x9d, 0xb1, 0xa6, 0xec, 0x5b, 0x88, 0x12, 0x08}
  };


/* 534c48c1-0607-4098-a521-4fc899c73e90 */
const GUID GUID_TFCAT_CATEGORY_OF_TIP = { 
    0x534c48c1,
    0x0607,
    0x4098,
    {0xa5, 0x21, 0x4f, 0xc8, 0x99, 0xc7, 0x3e, 0x90}
  };

/* 34745c63-b2f0-4784-8b67-5e12c8701a31 */
const GUID GUID_TFCAT_TIP_KEYBOARD = { 
    0x34745c63,
    0xb2f0,
    0x4784,
    {0x8b, 0x67, 0x5e, 0x12, 0xc8, 0x70, 0x1a, 0x31}
  };

/* b5a73cd1-8355-426b-a161-259808f26b14 */
const GUID GUID_TFCAT_TIP_SPEECH = { 
    0xb5a73cd1,
    0x8355,
    0x426b,
    {0xa1, 0x61, 0x25, 0x98, 0x08, 0xf2, 0x6b, 0x14}
  };

/* 246ecb87-c2f2-4abe-905b-c8b38add2c43 */
const GUID GUID_TFCAT_TIP_HANDWRITING = { 
    0x246ecb87,
    0xc2f2,
    0x4abe,
    {0x90, 0x5b, 0xc8, 0xb3, 0x8a, 0xdd, 0x2c, 0x43}
  };

/* c6debc0a-f2b2-4f17-930e-ca9faff4cd04 */
const GUID GUID_TFCAT_TIP_LOOKUP = { 
    0xc6debc0a,
    0xf2b2,
    0x4f17,
    {0x93, 0x0e, 0xca, 0x9f, 0xaf, 0xf4, 0xcd, 0x04}
  };

/* 9b7be3a9-e8ab-4d47-a8fe-254fa423436d */
const GUID GUID_TFCAT_PROP_AUDIODATA = { 
    0x9b7be3a9,
    0xe8ab,
    0x4d47,
    {0xa8, 0xfe, 0x25, 0x4f, 0xa4, 0x23, 0x43, 0x6d}
  };

/* 7c6a82ae-b0d7-4f14-a745-14f28b009d61 */
const GUID GUID_TFCAT_PROP_INKDATA = { 
    0x7c6a82ae,
    0xb0d7,
    0x4f14,
    {0xa7, 0x45, 0x14, 0xf2, 0x8b, 0x00, 0x9d, 0x61}
  };

/* 51af2086-cc6b-457d-b5aa-8b19dc290ab4 */
const GUID GUID_COMPARTMENT_SAPI_AUDIO= {
    0x51af2086,
    0xcc6b,
    0x457d,
    {0xb5, 0xaa, 0x8b, 0x19, 0xdc, 0x29, 0x0a, 0xb4}
};

/* 71a5b253-1951-466b-9fbc-9c8808fa84f2 */
const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED = { 
    0x71a5b253,
    0x1951,
    0x466b,
    {0x9f, 0xbc, 0x9c, 0x88, 0x08, 0xfa, 0x84, 0xf2}
  };

/* 58273aad-01bb-4164-95c6-755ba0b5162d */
const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = { 
    0x58273aad,
    0x01bb,
    0x4164,
    {0x95, 0xc6, 0x75, 0x5b, 0xa0, 0xb5, 0x16, 0x2d}
  };

/* f9ae2c6b-1866-4361-af72-7aa30948890e */
const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = { 
    0xf9ae2c6b,
    0x1866,
    0x4361,
    {0xaf, 0x72, 0x7a, 0xa3, 0x09, 0x48, 0x89, 0x0e}
  };

/* 56c5c607-0703-4e59-8e52-cbc84e8bbe35 */
const GUID GUID_COMPARTMENT_SPEECH_DISABLED = { 
    0x56c5c607,
    0x0703,
    0x4e59,
    {0x8e, 0x52, 0xcb, 0xc8, 0x4e, 0x8b, 0xbe, 0x35}
  };

/* 544d6a63-e2e8-4752-bbd1-000960bca083 */
const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE = { 
    0x544d6a63,
    0xe2e8,
    0x4752,
    {0xbb, 0xd1, 0x00, 0x09, 0x60, 0xbc, 0xa0, 0x83}
  };

/* 5497f516-ee91-436e-b946-aa2c05f1ac5b */
const GUID GUID_COMPARTMENT_CONVERSIONMODEBIAS = {
    0x5497f516,
    0xee91,
    0x436e,
    {0xb9, 0x46, 0xaa, 0x2c, 0x05, 0xf1, 0xac, 0x5b}
  };

/* 372E0716-974F-40AC-A088-08CDC92EBFBC */
const GUID GUID_PROP_MODEBIAS = {
    0x372E0716,
    0x974F,
    0x40AC,
    {0xA0, 0x88, 0x08, 0xCD, 0xC9, 0x2E, 0xBF, 0xBC}
  };

/* b6592511-bcee-4122-a7c4-09f4b3fa4396 */
const GUID GUID_COMPARTMENT_KEYBOARD_INPUTMODE = {
    0xb6592511,
    0xbcee,
    0x4122,
    {0xa7, 0xc4, 0x09, 0xf4, 0xb3, 0xfa, 0x43, 0x96}
  };


/* GUID_NULL */
const GUID GUID_MODEBIAS_NONE = {
    0x00000000,
    0x0000,
    0x0000,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  };

/* d7f707fe-44c6-4fca-8e76-86ab50c7931b */
const GUID GUID_MODEBIAS_FILENAME = {
    0xd7f707fe,
    0x44c6,
    0x4fca,
    {0x8e, 0x76, 0x86, 0xab, 0x50, 0xc7, 0x93, 0x1b}
  };


/* e31643a3-6466-4cbf-8d8b-0bd4d8545461 */
const GUID GUID_MODEBIAS_READING = {
    0xe31643a3,
    0x6466,
    0x4cbf,
    {0x8d, 0x8b, 0x0b, 0xd4, 0xd8, 0x54, 0x54, 0x61}
  };


/* f2bdb372-7f61-4039-92ef-1c35599f0222 */
const GUID GUID_MODEBIAS_DATETIME = {
    0xf2bdb372,
    0x7f61,
    0x4039,
    {0x92, 0xef, 0x1c, 0x35, 0x59, 0x9f, 0x02, 0x22}
  };

/* fddc10f0-d239-49bf-b8fc-5410caaa427e */
const GUID GUID_MODEBIAS_NAME = {
    0xfddc10f0,
    0xd239,
    0x49bf,
    {0xb8, 0xfc, 0x54, 0x10, 0xca, 0xaa, 0x42, 0x7e}
  };

/* 0f4ec104-1790-443b-95f1-e10f939d6546 */
const GUID GUID_MODEBIAS_CONVERSATION = {
    0x0f4ec104,
    0x1790,
    0x443b,
    {0x95, 0xf1, 0xe1, 0x0f, 0x93, 0x9d, 0x65, 0x46}
  };

/* 4021766c-e872-48fd-9cee-4ec5c75e16c3 */
const GUID GUID_MODEBIAS_NUMERIC = {
    0x4021766c,
    0xe872,
    0x48fd,
    {0x9c, 0xee, 0x4e, 0xc5, 0xc7, 0x5e, 0x16, 0xc3}
  };

/* d73d316e-9b91-46f1-a280-31597f52c694 */
const GUID GUID_MODEBIAS_HIRAGANA = {
    0xd73d316e,
    0x9b91,
    0x46f1,
    {0xa2, 0x80, 0x31, 0x59, 0x7f, 0x52, 0xc6, 0x94}
  };

/* 2e0eeddd-3a1a-499e-8543-3c7ee7949811 */
const GUID GUID_MODEBIAS_KATAKANA = {
    0x2e0eeddd,
    0x3a1a,
    0x499e,
    {0x85, 0x43, 0x3c, 0x7e, 0xe7, 0x94, 0x98, 0x11}
  };


/* 76ef0541-23b3-4d77-a074-691801ccea17 */
const GUID GUID_MODEBIAS_HANGUL = {
    0x76ef0541,
    0x23b3,
    0x4d77,
    {0xa0, 0x74, 0x69, 0x18, 0x01, 0xcc, 0xea, 0x17}
  };

/* 7add26de-4328-489b-83ae-6493750cad5c */
const GUID GUID_MODEBIAS_CHINESE = { 
    0x7add26de,
    0x4328,
    0x489b,
    {0x83, 0xae, 0x64, 0x93, 0x75, 0x0c, 0xad, 0x5c}
  };

/* 005f6b63-78d4-41cc-8859-485ca821a795 */
const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA = {
    0x005f6b63,
    0x78d4,
    0x41cc,
    {0x88, 0x59, 0x48, 0x5c, 0xa8, 0x21, 0xa7, 0x95}
  };

/* 81489fb8-b36a-473d-8146-e4a2258b24ae */
const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = {
    0x81489fb8,
    0xb36a,
    0x473d,
    {0x81, 0x46, 0xe4, 0xa2, 0x25, 0x8b, 0x24, 0xae}
  };

/* c6f24fc0-4479-46ed-938a-6052b1653d3b */
const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC = {
    0xc6f24fc0,
    0x4479,
    0x46ed,
    {0x93, 0x8a, 0x60, 0x52, 0xb1, 0x65, 0x3d, 0x3b}
  };

/* c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea */
const GUID GUID_MODEBIAS_FULLWIDTHHANGUL = { 
    0xc01ae6c9,
    0x45b5,
    0x4fd0,
    {0x9c, 0xb1, 0x9f, 0x4c, 0xeb, 0xc3, 0x9f, 0xea}
  };


/* 24af3031-852d-40a2-bc09-8992898ce722 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM = { 
    0x24af3031,
    0x852d,
    0x40a2,
    {0xbc, 0x09, 0x89, 0x92, 0x89, 0x8c, 0xe7, 0x22}
  };

/* 565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96 */
const GUID GUID_TFCAT_PROPSTYLE_STATIC = { 
    0x565fb8d8,
    0x6bd4,
    0x4ca1,
    {0xb2, 0x23, 0x0f, 0x2c, 0xcb, 0x8f, 0x4f, 0x96}
  };

/* 85f9794b-4d19-40d8-8864-4e747371a66d */
const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT = { 
    0x85f9794b,
    0x4d19,
    0x40d8,
    {0x88, 0x64, 0x4e, 0x74, 0x73, 0x71, 0xa6, 0x6d}
  };


/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_CTF = { 
    0xaabf7f9a,
    0x4487,
    0x4b2e,
    {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04}
  };

/* 046b8c80-1647-40f7-9b21-b93b81aabc1b */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = { 
    0x046b8c80,
    0x1647,
    0x40f7,
    {0x9b, 0x21, 0xb9, 0x3b, 0x81, 0xaa, 0xbc, 0x1b}
  };

/* b95f181b-ea4c-4af1-8056-7c321abbb091 */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = { 
    0xb95f181b,
    0xea4c,
    0x4af1,
    {0x80, 0x56, 0x7c, 0x32, 0x1a, 0xbb, 0xb0, 0x91}
  };

/* 1edb55cc-58f0-4592-aae1-fe51f43b95c5 */
const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT = {
    0x1edb55cc,
    0x58f0,
    0x4592,
    {0xaa, 0xe1, 0xfe, 0x51, 0xf4, 0x3b, 0x95, 0xc5 }
  };
/* 575F3783-70C8-47C8-AE5D-91A01A1F7592 */
const GUID GUID_COMPARTMENT_PERSISTMENUENABLED = {
    0x575F3783,
    0x70C8,
    0x47C8,
    {0xAE, 0x5D, 0x91, 0xA0, 0x1A, 0x1F, 0x75, 0x92 }
  };

/* D92016F0-9367-4FE7-9ABF-BC59DACBE0E3 */
const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS = {
    0xD92016F0,
    0x9367,
    0x4FE7,
    {0x9A, 0xBF, 0xBC, 0x59, 0xDA, 0xCB, 0xE0, 0xE3 }
  };

/* d7487dbf-804e-41c5-894d-ad96fd4eea13 */
const GUID GUID_COMPARTMENT_EMPTYCONTEXT = { 
    0xd7487dbf,
    0x804e,
    0x41c5,
    {0x89, 0x4d, 0xad, 0x96, 0xfd, 0x4e, 0xea, 0x13}
  };

/* 148ca3ec-0366-401c-8d75-ed978d85fbc9 */
const GUID GUID_COMPARTMENT_TIPUISTATUS = {
    0x148ca3ec,
    0x0366,
    0x401c,
    {0x8d, 0x75, 0xed, 0x97, 0x8d, 0x85, 0xfb, 0xc9}
  };

/* fb6c5c2d-4e83-4bb6-91a2-e019bff6762d */
const GUID GUID_COMPARTMENT_SPEECH_CFGMENU = { 
    0xfb6c5c2d,
    0x4e83,
    0x4bb6,
    {0x91, 0xa2, 0xe0, 0x19, 0xbf, 0xf6, 0x76, 0x2d}
  };

/* D02F24A1-942D-422E-8D99-B4F2ADDEE999 */
const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON = {
    0xD02F24A1,
    0x942D,
    0x422E,
    {0x8D, 0x99, 0xB4, 0xF2, 0xAD, 0xDE, 0xE9, 0x99}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\msctf_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfThreadMgr,0xaa80e801,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfThreadMgrEventSink,0xaa80e80e,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfConfigureSystemKeystrokeFeed,0x0d2c969a,0xbc9c,0x437c,0x84,0xee,0x95,0x1c,0x49,0xb1,0xa7,0x64);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDocumentMgrs,0xaa80e808,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfDocumentMgr,0xaa80e7f4,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContexts,0x8f1a7ea6,0x1654,0x4502,0xa8,0x6e,0xb2,0x90,0x23,0x44,0xd5,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionView,0xD7540241,0xF9A1,0x4364,0xBE,0xFC,0xDB,0xCD,0x2C,0x43,0x95,0xB7);


MIDL_DEFINE_GUID(IID, IID_IEnumITfCompositionView,0x5EFD22BA,0x7838,0x46CB,0x88,0xE2,0xCA,0xDB,0x14,0x12,0x4F,0x8F);


MIDL_DEFINE_GUID(IID, IID_ITfComposition,0x20168D64,0x5A8F,0x4A5A,0xB7,0xBD,0xCF,0xA2,0x9F,0x4D,0x0F,0xD9);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionSink,0xA781718C,0x579A,0x4B15,0xA2,0x80,0x32,0xB8,0x57,0x7A,0xCC,0x5E);


MIDL_DEFINE_GUID(IID, IID_ITfContextComposition,0xD40C8AAE,0xAC92,0x4FC7,0x9A,0x11,0x0E,0xE0,0xE2,0x3A,0xA3,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionServices,0x86462810,0x593B,0x4916,0x97,0x64,0x19,0xC0,0x8E,0x9C,0xE1,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionSink,0x5F20AA40,0xB57A,0x4F34,0x96,0xAB,0x35,0x76,0xF3,0x77,0xCC,0x79);


MIDL_DEFINE_GUID(IID, IID_ITfContextView,0x2433bf8e,0x0f9b,0x435c,0xba,0x2c,0x18,0x06,0x11,0x97,0x8c,0x30);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContextViews,0xF0C0F8DD,0xCF38,0x44E1,0xBB,0x0F,0x68,0xCF,0x0D,0x55,0x1C,0x78);


MIDL_DEFINE_GUID(IID, IID_ITfContext,0xaa80e7fd,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfQueryEmbedded,0x0fab9bdb,0xd250,0x4169,0x84,0xe5,0x6b,0xe1,0x18,0xfd,0xd7,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfInsertAtSelection,0x55ce16ba,0x3014,0x41c1,0x9c,0xeb,0xfa,0xde,0x14,0x46,0xac,0x6c);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextSink,0x01689689,0x7acb,0x4e9b,0xab,0x7c,0x7e,0xa4,0x6b,0x12,0xb5,0x22);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextDurationSink,0x45c35144,0x154e,0x4797,0xbe,0xd8,0xd3,0x3a,0xe7,0xbf,0x87,0x94);


MIDL_DEFINE_GUID(IID, IID_ITfReadOnlyProperty,0x17d49a3d,0xf8b8,0x4b2f,0xb2,0x54,0x52,0x31,0x9d,0xd6,0x4c,0x53);


MIDL_DEFINE_GUID(IID, IID_IEnumTfPropertyValue,0x8ed8981b,0x7c10,0x4d7d,0x9f,0xb3,0xab,0x72,0xe9,0xc7,0x5f,0x72);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTracker,0x09d146cd,0xa544,0x4132,0x92,0x5b,0x7a,0xfa,0x8e,0xf3,0x22,0xd0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerACP,0x3bdd78e2,0xc16e,0x47fd,0xb8,0x83,0xce,0x6f,0xac,0xc1,0xa2,0x08);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerAnchor,0xf9f4e0f2,0xd600,0x4a4c,0xb1,0x44,0x77,0xe2,0x01,0xeb,0xd1,0xb0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseSink,0xa1adaaa2,0x3a24,0x449d,0xac,0x96,0x51,0x83,0xe7,0xf5,0xc2,0x17);


MIDL_DEFINE_GUID(IID, IID_ITfEditRecord,0x42d4d099,0x7c1a,0x4a89,0xb8,0x36,0x6c,0x6f,0x22,0x16,0x0d,0xf0);


MIDL_DEFINE_GUID(IID, IID_ITfTextEditSink,0x8127d409,0xccd3,0x4683,0x96,0x7a,0xb4,0x3d,0x5b,0x48,0x2b,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfTextLayoutSink,0x2af2d06a,0xdd5b,0x4927,0xa0,0xb4,0x54,0xf1,0x9c,0x91,0xfa,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfStatusSink,0x6b7d8d73,0xb267,0x4f69,0xb3,0x2e,0x1c,0xa3,0x21,0xce,0x4f,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfEditTransactionSink,0x708fbf70,0xb520,0x416b,0xb0,0x6c,0x2c,0x41,0xab,0x44,0xf8,0xba);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwner,0xaa80e80c,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerServices,0xb23eb630,0x3e1c,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfContextKeyEventSink,0x0552ba5d,0xc835,0x4934,0xbf,0x50,0x84,0x6a,0xaa,0x67,0x43,0x2f);


MIDL_DEFINE_GUID(IID, IID_ITfEditSession,0xaa80e803,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfTextDeltas,0xaa80e807,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRange,0xaa80e7ff,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeACP,0x057a6296,0x029b,0x4154,0xb7,0x9a,0x0d,0x46,0x1d,0x4e,0xa9,0x4c);


MIDL_DEFINE_GUID(IID, IID_ITfRangeAnchor,0x8b99712b,0x5815,0x4bcc,0xb9,0xa9,0x53,0xdb,0x1c,0x8d,0x67,0x55);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPServices,0xaa80e901,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorServices,0xaa80e9fe,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeBackup,0x463a506d,0x6992,0x49d2,0x9b,0x88,0x93,0xd5,0x5e,0x70,0xbb,0x16);


MIDL_DEFINE_GUID(IID, IID_ITfPropertyStore,0x6834b120,0x88cb,0x11d2,0xbf,0x45,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfRanges,0xf99d3f40,0x8e32,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCreatePropertyStore,0x2463fbf0,0xb0af,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderACP,0x4ef89150,0x0807,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderAnchor,0x2133f790,0x34c2,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfProperty,0xe2449660,0x9542,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfProperties,0x19188cb0,0xaca9,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCompartment,0xbb08f7a9,0x607a,0x4384,0x86,0x23,0x05,0x68,0x92,0xb6,0x43,0x71);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentEventSink,0x743abd5f,0xf26d,0x48df,0x8c,0xc5,0x23,0x84,0x92,0x41,0x9b,0x64);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentMgr,0x7dcf57ac,0x18ad,0x438b,0x82,0x4d,0x97,0x9b,0xff,0xb7,0x4b,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfFunction,0xdb593490,0x098f,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFunctionProvider,0x101d6610,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfFunctionProviders,0xe4b24db0,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfInputProcessorProfiles,0x1F02B6C5,0x7842,0x4EE6,0x8A,0x0B,0x9A,0x24,0x18,0x3A,0x95,0xCA);


MIDL_DEFINE_GUID(IID, IID_ITfActiveLanguageProfileNotifySink,0xb246cb75,0xa93e,0x4652,0xbf,0x8c,0xb3,0xfe,0x0c,0xfd,0x7e,0x57);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLanguageProfiles,0x3d61bf11,0xac5f,0x42c8,0xa4,0xcb,0x93,0x1b,0xcc,0x28,0xc7,0x44);


MIDL_DEFINE_GUID(IID, IID_ITfLanguageProfileNotifySink,0x43c9fe15,0xf494,0x4c17,0x9d,0xe2,0xb8,0xa4,0xac,0x35,0x0a,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfKeystrokeMgr,0xaa80e7f0,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyEventSink,0xaa80e7f5,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyTraceEventSink,0x1cd4c13b,0x1c36,0x4191,0xa7,0x0a,0x7f,0x3e,0x61,0x1f,0x36,0x7d);


MIDL_DEFINE_GUID(IID, IID_ITfPreservedKeyNotifySink,0x6f77c993,0xd2b1,0x446e,0x85,0x3e,0x59,0x12,0xef,0xc8,0xa2,0x86);


MIDL_DEFINE_GUID(IID, IID_ITfMessagePump,0x8f1b8ad8,0x0b6b,0x4874,0x90,0xc5,0xbd,0x76,0x01,0x1e,0x8f,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfThreadFocusSink,0xc0f1db0c,0x3a20,0x405c,0xa3,0x03,0x96,0xb6,0x01,0x0a,0x88,0x5f);


MIDL_DEFINE_GUID(IID, IID_ITfTextInputProcessor,0xaa80e7f7,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfClientId,0xd60a7b49,0x1b9f,0x4be2,0xb7,0x02,0x47,0xe9,0xdc,0x05,0xde,0xc3);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeInfo,0x70528852,0x2f26,0x4aea,0x8c,0x96,0x21,0x51,0x50,0x57,0x89,0x32);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDisplayAttributeInfo,0x7cef04d7,0xcb75,0x4e80,0xa7,0xab,0x5f,0x5b,0xc7,0xd3,0x32,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeProvider,0xfee47777,0x163c,0x4769,0x99,0x6a,0x6e,0x9c,0x50,0xad,0x8f,0x54);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeMgr,0x8ded7393,0x5db1,0x475c,0x9e,0x71,0xa3,0x91,0x11,0xb0,0xff,0x67);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeNotifySink,0xad56f402,0xe162,0x4f25,0x90,0x8f,0x7d,0x57,0x7c,0xf9,0xbd,0xa9);


MIDL_DEFINE_GUID(IID, IID_ITfCategoryMgr,0xc3acefb5,0xf69d,0x4905,0x93,0x8f,0xfc,0xad,0xcf,0x4b,0xe8,0x30);


MIDL_DEFINE_GUID(IID, IID_ITfSource,0x4ea48a35,0x60ae,0x446f,0x8f,0xd6,0xe6,0xa8,0xd8,0x24,0x59,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfSourceSingle,0x73131f9c,0x56a9,0x49dd,0xb0,0xee,0xd0,0x46,0x63,0x3f,0x75,0x28);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfThreadMgr,0xaa80e801,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfThreadMgrEventSink,0xaa80e80e,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfConfigureSystemKeystrokeFeed,0x0d2c969a,0xbc9c,0x437c,0x84,0xee,0x95,0x1c,0x49,0xb1,0xa7,0x64);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDocumentMgrs,0xaa80e808,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfDocumentMgr,0xaa80e7f4,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContexts,0x8f1a7ea6,0x1654,0x4502,0xa8,0x6e,0xb2,0x90,0x23,0x44,0xd5,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionView,0xD7540241,0xF9A1,0x4364,0xBE,0xFC,0xDB,0xCD,0x2C,0x43,0x95,0xB7);


MIDL_DEFINE_GUID(IID, IID_IEnumITfCompositionView,0x5EFD22BA,0x7838,0x46CB,0x88,0xE2,0xCA,0xDB,0x14,0x12,0x4F,0x8F);


MIDL_DEFINE_GUID(IID, IID_ITfComposition,0x20168D64,0x5A8F,0x4A5A,0xB7,0xBD,0xCF,0xA2,0x9F,0x4D,0x0F,0xD9);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionSink,0xA781718C,0x579A,0x4B15,0xA2,0x80,0x32,0xB8,0x57,0x7A,0xCC,0x5E);


MIDL_DEFINE_GUID(IID, IID_ITfContextComposition,0xD40C8AAE,0xAC92,0x4FC7,0x9A,0x11,0x0E,0xE0,0xE2,0x3A,0xA3,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionServices,0x86462810,0x593B,0x4916,0x97,0x64,0x19,0xC0,0x8E,0x9C,0xE1,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionSink,0x5F20AA40,0xB57A,0x4F34,0x96,0xAB,0x35,0x76,0xF3,0x77,0xCC,0x79);


MIDL_DEFINE_GUID(IID, IID_ITfContextView,0x2433bf8e,0x0f9b,0x435c,0xba,0x2c,0x18,0x06,0x11,0x97,0x8c,0x30);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContextViews,0xF0C0F8DD,0xCF38,0x44E1,0xBB,0x0F,0x68,0xCF,0x0D,0x55,0x1C,0x78);


MIDL_DEFINE_GUID(IID, IID_ITfContext,0xaa80e7fd,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfQueryEmbedded,0x0fab9bdb,0xd250,0x4169,0x84,0xe5,0x6b,0xe1,0x18,0xfd,0xd7,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfInsertAtSelection,0x55ce16ba,0x3014,0x41c1,0x9c,0xeb,0xfa,0xde,0x14,0x46,0xac,0x6c);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextSink,0x01689689,0x7acb,0x4e9b,0xab,0x7c,0x7e,0xa4,0x6b,0x12,0xb5,0x22);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextDurationSink,0x45c35144,0x154e,0x4797,0xbe,0xd8,0xd3,0x3a,0xe7,0xbf,0x87,0x94);


MIDL_DEFINE_GUID(IID, IID_ITfReadOnlyProperty,0x17d49a3d,0xf8b8,0x4b2f,0xb2,0x54,0x52,0x31,0x9d,0xd6,0x4c,0x53);


MIDL_DEFINE_GUID(IID, IID_IEnumTfPropertyValue,0x8ed8981b,0x7c10,0x4d7d,0x9f,0xb3,0xab,0x72,0xe9,0xc7,0x5f,0x72);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTracker,0x09d146cd,0xa544,0x4132,0x92,0x5b,0x7a,0xfa,0x8e,0xf3,0x22,0xd0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerACP,0x3bdd78e2,0xc16e,0x47fd,0xb8,0x83,0xce,0x6f,0xac,0xc1,0xa2,0x08);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerAnchor,0xf9f4e0f2,0xd600,0x4a4c,0xb1,0x44,0x77,0xe2,0x01,0xeb,0xd1,0xb0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseSink,0xa1adaaa2,0x3a24,0x449d,0xac,0x96,0x51,0x83,0xe7,0xf5,0xc2,0x17);


MIDL_DEFINE_GUID(IID, IID_ITfEditRecord,0x42d4d099,0x7c1a,0x4a89,0xb8,0x36,0x6c,0x6f,0x22,0x16,0x0d,0xf0);


MIDL_DEFINE_GUID(IID, IID_ITfTextEditSink,0x8127d409,0xccd3,0x4683,0x96,0x7a,0xb4,0x3d,0x5b,0x48,0x2b,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfTextLayoutSink,0x2af2d06a,0xdd5b,0x4927,0xa0,0xb4,0x54,0xf1,0x9c,0x91,0xfa,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfStatusSink,0x6b7d8d73,0xb267,0x4f69,0xb3,0x2e,0x1c,0xa3,0x21,0xce,0x4f,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfEditTransactionSink,0x708fbf70,0xb520,0x416b,0xb0,0x6c,0x2c,0x41,0xab,0x44,0xf8,0xba);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwner,0xaa80e80c,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerServices,0xb23eb630,0x3e1c,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfContextKeyEventSink,0x0552ba5d,0xc835,0x4934,0xbf,0x50,0x84,0x6a,0xaa,0x67,0x43,0x2f);


MIDL_DEFINE_GUID(IID, IID_ITfEditSession,0xaa80e803,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfTextDeltas,0xaa80e807,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRange,0xaa80e7ff,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeACP,0x057a6296,0x029b,0x4154,0xb7,0x9a,0x0d,0x46,0x1d,0x4e,0xa9,0x4c);


MIDL_DEFINE_GUID(IID, IID_ITfRangeAnchor,0x8b99712b,0x5815,0x4bcc,0xb9,0xa9,0x53,0xdb,0x1c,0x8d,0x67,0x55);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPServices,0xaa80e901,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorServices,0xaa80e9fe,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeBackup,0x463a506d,0x6992,0x49d2,0x9b,0x88,0x93,0xd5,0x5e,0x70,0xbb,0x16);


MIDL_DEFINE_GUID(IID, IID_ITfPropertyStore,0x6834b120,0x88cb,0x11d2,0xbf,0x45,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfRanges,0xf99d3f40,0x8e32,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCreatePropertyStore,0x2463fbf0,0xb0af,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderACP,0x4ef89150,0x0807,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderAnchor,0x2133f790,0x34c2,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfProperty,0xe2449660,0x9542,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfProperties,0x19188cb0,0xaca9,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCompartment,0xbb08f7a9,0x607a,0x4384,0x86,0x23,0x05,0x68,0x92,0xb6,0x43,0x71);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentEventSink,0x743abd5f,0xf26d,0x48df,0x8c,0xc5,0x23,0x84,0x92,0x41,0x9b,0x64);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentMgr,0x7dcf57ac,0x18ad,0x438b,0x82,0x4d,0x97,0x9b,0xff,0xb7,0x4b,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfFunction,0xdb593490,0x098f,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFunctionProvider,0x101d6610,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfFunctionProviders,0xe4b24db0,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfInputProcessorProfiles,0x1F02B6C5,0x7842,0x4EE6,0x8A,0x0B,0x9A,0x24,0x18,0x3A,0x95,0xCA);


MIDL_DEFINE_GUID(IID, IID_ITfActiveLanguageProfileNotifySink,0xb246cb75,0xa93e,0x4652,0xbf,0x8c,0xb3,0xfe,0x0c,0xfd,0x7e,0x57);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLanguageProfiles,0x3d61bf11,0xac5f,0x42c8,0xa4,0xcb,0x93,0x1b,0xcc,0x28,0xc7,0x44);


MIDL_DEFINE_GUID(IID, IID_ITfLanguageProfileNotifySink,0x43c9fe15,0xf494,0x4c17,0x9d,0xe2,0xb8,0xa4,0xac,0x35,0x0a,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfKeystrokeMgr,0xaa80e7f0,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyEventSink,0xaa80e7f5,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyTraceEventSink,0x1cd4c13b,0x1c36,0x4191,0xa7,0x0a,0x7f,0x3e,0x61,0x1f,0x36,0x7d);


MIDL_DEFINE_GUID(IID, IID_ITfPreservedKeyNotifySink,0x6f77c993,0xd2b1,0x446e,0x85,0x3e,0x59,0x12,0xef,0xc8,0xa2,0x86);


MIDL_DEFINE_GUID(IID, IID_ITfMessagePump,0x8f1b8ad8,0x0b6b,0x4874,0x90,0xc5,0xbd,0x76,0x01,0x1e,0x8f,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfThreadFocusSink,0xc0f1db0c,0x3a20,0x405c,0xa3,0x03,0x96,0xb6,0x01,0x0a,0x88,0x5f);


MIDL_DEFINE_GUID(IID, IID_ITfTextInputProcessor,0xaa80e7f7,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfClientId,0xd60a7b49,0x1b9f,0x4be2,0xb7,0x02,0x47,0xe9,0xdc,0x05,0xde,0xc3);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeInfo,0x70528852,0x2f26,0x4aea,0x8c,0x96,0x21,0x51,0x50,0x57,0x89,0x32);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDisplayAttributeInfo,0x7cef04d7,0xcb75,0x4e80,0xa7,0xab,0x5f,0x5b,0xc7,0xd3,0x32,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeProvider,0xfee47777,0x163c,0x4769,0x99,0x6a,0x6e,0x9c,0x50,0xad,0x8f,0x54);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeMgr,0x8ded7393,0x5db1,0x475c,0x9e,0x71,0xa3,0x91,0x11,0xb0,0xff,0x67);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeNotifySink,0xad56f402,0xe162,0x4f25,0x90,0x8f,0x7d,0x57,0x7c,0xf9,0xbd,0xa9);


MIDL_DEFINE_GUID(IID, IID_ITfCategoryMgr,0xc3acefb5,0xf69d,0x4905,0x93,0x8f,0xfc,0xad,0xcf,0x4b,0xe8,0x30);


MIDL_DEFINE_GUID(IID, IID_ITfSource,0x4ea48a35,0x60ae,0x446f,0x8f,0xd6,0xe6,0xa8,0xd8,0x24,0x59,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfSourceSingle,0x73131f9c,0x56a9,0x49dd,0xb0,0xee,0xd0,0x46,0x63,0x3f,0x75,0x28);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\measure.cpp ===
/*
 *	@doc
 *
 *	@module - MEASURE.CPP
 *	
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Rick Sailor
 *
 *		History: <nl>
 *		KeithCu: Fixed zoom, restructured WYSIWYG, performance/cleanup
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_measure.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_layout.h"
#include "_uspi.h"

ASSERTDATA

void CMeasurer::Init(const CDisplay *pdp)
{
	CTxtEdit *	ped = GetPed();

	_pdp = pdp;
	_pddReference = pdp;
	_pccs = NULL;
	_pPF = NULL;
	_plo = NULL;
	_dxBorderWidths = 0;
	_chPassword = ped->TxGetPasswordChar();
	_wNumber = 0;
	_cchLine = 0;
	_ihyphPrev = 0;
	_fRenderer = FALSE;
	_fGlyphing = _fFallback = _fTarget = FALSE;
	_fMeasure = FALSE;

	_dvpWrapLeftRemaining = _dvpWrapRightRemaining = -1;

	if(pdp->GetWordWrap())
	{
		const CDevDesc *pddTarget = pdp->GetTargetDev();
		if(pddTarget)
			_pddReference = pddTarget;
	}

	_dvpInch = pdp->GetDypInch();
	_dupInch = pdp->GetDxpInch();

	if (pdp->IsMain())
	{
		_dvpInch = MulDiv(_dvpInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
		_dupInch = MulDiv(_dupInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	}
	if (pdp->SameDevice(_pddReference))
	{
		_dvrInch = _dvpInch;
		_durInch = _dupInch;
	}
	else
	{
		_dvrInch = _pddReference->GetDypInch();
		_durInch = _pddReference->GetDxpInch();
	}

	//Set _dulLayout by default to be width for measuring;
	//In the table scenario, it will be set elsewhere.
	if(!_pdp->GetWordWrap())
		_dulLayout = duMax;
	else if (_pdp->GetDulForTargetWrap())
		_dulLayout = _pdp->GetDulForTargetWrap();
	else
		_dulLayout = DUtoLU(_pdp->GetDupView());
}

CMeasurer::CMeasurer (const CDisplay* const pdp) : CRchTxtPtr (pdp->GetPed())	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &tp) : CRchTxtPtr (tp)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::~CMeasurer()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::~CMeasurer");

	if(_pccs)
		_pccs->Release();
}

/*
 *	CMeasurer::SetGlyphing(fGlyphing)
 *
 *	@mfunc
 *		A state flag inside the measurer to record whether or not you
 *		are in the process of doing glyphing. If we are in a situation
 *		where the _pddReference and the _pdp have different DCs, then we
 *		need to throw away the pccs.
 */
void CMeasurer::SetGlyphing(
	BOOL fGlyphing)		//@parm Currently doing glyphing
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetGlyphing");
	Assert(fGlyphing == TRUE || fGlyphing == FALSE);

	if (fGlyphing != _fGlyphing)
	{
		if (_pddReference->_hdc != _pdp->_hdc)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fGlyphing = fGlyphing;
	}
}

/*
 *	CMeasurer::SetUseTargetDevice(fUseTargetDevice)
 *
 *	@mfunc
 *		Sets whether you want to use the target device or not
 *		for getting metrics
 *		FUTURE (keithcu) Make this a parameter
 */
void CMeasurer::SetUseTargetDevice(
	BOOL fUseTargetDevice)		//@parm Use target device metrics?
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetUseTargetDevice");
	Assert(fUseTargetDevice == TRUE || fUseTargetDevice == FALSE);

	if (fUseTargetDevice != _fTarget)
	{
		if (_dvpInch != _dvrInch || _dupInch != _durInch)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fTarget = fUseTargetDevice;
	}
}

/*
 *	CMeasurer::NewLine (fFirstInPara)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a new line
 */
void CMeasurer::NewLine(
	BOOL fFirstInPara)		//@parm Flag for setting up _fFirstInPara
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li.Init();							// Zero all members
	if(fFirstInPara)
		_li._fFirstInPara = TRUE;		// Need to know if first in para
	_cchLine = 0;
}

/*
 *	CMeasurer::NewLine(&li)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a given line
 */
void CMeasurer::NewLine(
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li				= li;
	_li._cch		= 0;
	_li._dup		= 0;

	// Can't calculate upStart till we get an HDC
	_li._upStart	= 0;
	_wNumber	= _li._bNumber;
	_cchLine = li._cch;
}

/*
 *	CMeasurer::MeasureText (cch)
 *
 *	@mfunc
 *		Measure a stretch of text from current running position.
 *
 *		If the user requests us to measure n characters, we measure n + 1.
 *		and then subtract off the width of the last character. This gives
 *		us proper value in _dupAddLast.

 *		REVIEW (keithcu) This looks ugly. Think about it some more.
 *
 *	@rdesc
 *		width of text (in device units), < 0 if failed
 */
LONG CMeasurer::MeasureText(
	LONG cch)		//@parm Number of characters to measure
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureText");

	if(Measure(duMax, min(cch + 1, _cchLine), 0) == MRET_FAILED)
		return -1;

	if (cch < _cchLine)
	{
		_li._dup -= _dupAddLast;
		_li._cch--;
	}

	return _li._dup;
}

/*
 *	CMeasurer::MeasureLine (dulMax, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Measure a line of text from current cp and determine line break.
 *		On return *this contains line metrics for _pddReference device.
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL CMeasurer::MeasureLine(
	UINT uiFlags,  		//@parm Flags controlling the process (see Measure())
	CLine *pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLine");

	// This state must be preserved across the two possible line width
	// calculations so we save it here.
	BYTE bNumberSave = _li._bNumber;

	const CDevDesc *pddTarget = NULL;

	if(_pdp->GetWordWrap())
	{
		// Target devices are only interesting if word wrap is on because the 
		// only really interesting thing a target device can tell us is where
		// the word breaks will occur.
		pddTarget = _pdp->GetTargetDev();
		if(pddTarget)
			SetUseTargetDevice(TRUE);
	}

	// Compute line break
	LONG lRet = Measure(-1, -1, uiFlags);

	// Stop here if failed
	if(lRet == MRET_FAILED)
		return FALSE;

	// Return target metrics if requested
	if(pliTarget)
		*pliTarget = _li;

	SetUseTargetDevice(FALSE);

	// Recompute to get metrics on rendering device
	if(pddTarget || lRet == MRET_NOWIDTH)
	{
		long cch = _li._cch;
		Move(-cch);				// move back to BOL
		NewLine(uiFlags & MEASURE_FIRSTINPARA);

		// Restore the line number 
		_li._bNumber = bNumberSave;
	
		lRet = Measure(duMax, cch, uiFlags);
		if(lRet)
		{
			Assert(lRet != MRET_NOWIDTH);
			return FALSE;
		}
	}
	
	// Now that we know the line width, compute line shift due
	// to alignment, and add it to the left position 
	_li._upStart += MeasureLineShift();

	return TRUE;
}

/*
 *	CMeasurer::RecalcLineHeight (pccs, pCF)
 *
 *	@mfunc
 *		Reset height of line we are measuring if new run of text is taller
 *		than current maximum in line.
 */
void CMeasurer::RecalcLineHeight(
	CCcs *pccs,
	const CCharFormat * const pCF)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::RecalcLineHeight");

	// Compute line height
	LONG vpOffset, vpAdjust;
	pccs->GetOffset(pCF, _fTarget ? _dvrInch : _dvpInch, &vpOffset, &vpAdjust);

	if (GetPF()->_bLineSpacingRule == tomLineSpaceExactly)
		vpOffset = 0;

	LONG vpHeight = pccs->_yHeight;
	LONG vpDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(FAdjustFELineHt());
	
	if (yFEAdjust)
	{
		vpHeight += (yFEAdjust << 1);
		vpDescent += yFEAdjust;
	}

	LONG vpAscent = vpHeight - vpDescent;

	LONG vpAboveBase = max(vpAscent,  vpAscent + vpOffset);
	LONG vpBelowBase = max(vpDescent, vpDescent - vpOffset);

	_li._dvpHeight  = (SHORT)(max(vpAboveBase, _li._dvpHeight - _li._dvpDescent) +
					   max(vpBelowBase, _li._dvpDescent));
	_li._dvpDescent = (SHORT)max(vpBelowBase, _li._dvpDescent);
}

/*
 *	CMeasurer::Measure (dulMax, cchMax, uiFlags)
 *
 *	@mfunc
 *		Measure given amount of text, start at current running position
 *		and storing # chars measured in _cch. 
 *		Can optionally determine line break based on a dulMax and 
 *		break out at that point.
 *
 *	@rdesc
 *		0 success
 *		MRET_FAILED	 if failed 
 *		MRET_NOWIDTH if second pass is needed to compute correct width
 *
 *	@devnote
 *		The uiFlags parameter has the following meanings:
 *			MEASURE_FIRSTINPARA			this is first line of paragraph
 *			MEASURE_BREAKATWORD			break out on a word break
 *			MEASURE_BREAKBEFOREWIDTH	break before dulMax
 *
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
LONG CMeasurer::Measure(
	LONG dulMax,			//@parm Max width of line in logical units (-1 uses CDisplay width)
	LONG cchMax,			//@parm Max chars to process (-1 if no limit)
	UINT uiFlags)			//@parm Flags controlling the process (see above)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::Measure");

	LONG		cch;				// cchChunk count down
	LONG		cchChunk;			// cch of cst-format contiguous run
	LONG		cchNonWhite;		// cch of last nonwhite char in line
	LONG		cchText = GetTextLength();
	WCHAR		ch;					// Temporary char
	BOOL		fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL        fLastChObj = FALSE;
	LONG		lRet = 0;
	const WCHAR*pch;
	CTxtEdit *	ped = GetPed();
	COleObject *pobj;
	LONG		dupMax;
	LONG		uAdd = 0;			// Character width
	LONG		dupSoftHyphen = 0;	// Most recent soft hyphen width
	LONG		dupNonWhite;		// dup for last nonwhite char in line

	// This variable is used to keep track of whether there is a height change
	// so that we know whether we need to recalc the line in certain line break cases.
	BOOL		fHeightChange = FALSE;

	const INT	MAX_SAVED_WIDTHS = 31;	// power of 2 - 1
	INT			i, index, iSavedWidths = 0;
	struct {
		SHORT	width;
		SHORT	vpHeight;
		SHORT	vpDescent;
	} savedWidths[MAX_SAVED_WIDTHS+1];

	_pPF = GetPF();							// Be sure current CParaFormat
											// ptr is up to date
	Assert(_li._cch == 0);

	// Init fliFirstInPara flag for new line
	if(fFirstInPara)
	{
		_li._fFirstInPara = TRUE;

		if(IsInOutlineView() && IsHeadingStyle(_pPF->_sStyle))
			_li._dvpHeight = (short)max(_li._dvpHeight, BITMAP_HEIGHT_HEADING + 1);
	}

	AssertSz(!_pPF->IsListNumbered() && !_wNumber ||
			 (uiFlags & MEASURE_BREAKBEFOREWIDTH) || !_pdp->IsMultiLine() ||
			 _wNumber > 20 || _wNumber == (i = GetParaNumber()),
		"CMeasurer::Measure: incorrect list number");

	_li._upStart = MeasureLeftIndent();		// Set left indent

	// Compute width to break out at
	if(dulMax < 0)
		dupMax = LUtoDU(_dulLayout);
	else if (dulMax != duMax)
		dupMax = LUtoDU(dulMax);
	else
		dupMax = duMax;

	//If we are told to measure a fixed width (as in CchFromUp) then ignore 
	//affect of left and right indent.
	if (dulMax < 0)
	{
		LONG uCaretT = (_pdp->IsMain() && !GetPed()->TxGetReadOnly()) ? 
							ped->GetCaretWidth() : 0;
		dupMax -= (MeasureRightIndent() + _li._upStart + uCaretT);
	}

	dupMax = max(dupMax, 0);

	// Compute max count of characters to process
	cch = cchText - GetCp();
	if(cchMax < 0 || cchMax > cch)
		cchMax = cch;

	cchNonWhite		= _li._cch;						// Default nonwhite parms
	dupNonWhite	= _li._dup;

	for( ; cchMax > 0;							// Measure up to cchMax
		cchMax -= cchChunk, Move(cchChunk))		//  chars
	{
		pch = GetPch(cch);
		cch = min(cch, cchMax);					// Compute constant-format
		cchChunk = GetCchLeftRunCF();
		cch = min(cch, cchChunk);				// Counter for next while
		cchChunk = cch;							// Save chunk size

		const CCharFormat *pCF = GetCF();

		DWORD dwEffects = pCF->_dwEffects;

		if(dwEffects & CFE_HIDDEN)				// Ignore hidden text
		{
			uAdd = 0;
			_li._cch += cchChunk;
			continue;
		}

		if(!Check_pccs())						// Be sure _pccs is current
			return MRET_FAILED;

		// Adjust line height for new format run
		if(cch > 0 && *pch && (IsRich() || ped->HasObjects()))
		{
			// Note: the EOP only contributes to the height calculation for the
			// line if there are no non-white space characters on the line or 
			// the paragraph is a bullet paragraph. The bullet paragraph 
			// contribution to the line height is done in AdjustLineHeight.

			// REVIEW (Victork) 
			// Another, similar topic is height of spaces.
			// They don't (normally) influence line height in LS, 
			// they do in CMeasurer::Measure code. 
			// Proposed ways to solve it:
			//		- have fSpacesOnly flag in run
			//		- move current (line height) logic down after next character-scanning loop


			if(!cchNonWhite || *pch != CR && *pch != LF)
			{
				// Determine if the current run is the tallest text on this
				// line and if so, increase the height of the line.
				LONG vpHeightOld = _li._dvpHeight;
				RecalcLineHeight(_pccs, pCF);

				// Test for a change in line height. This only happens when
				// this is not the first character in the line and (surprise)
				// the height changes.
				if (vpHeightOld && vpHeightOld != _li._dvpHeight)
					fHeightChange = TRUE;
			}
		}

		while(cch > 0)
		{											// Process next char
			uAdd = 0;								// Default zero width
			ch = *pch;
			if(_chPassword && !IN_RANGE(LF, ch, CR))
				ch = _chPassword;

			if(dwEffects & CFE_ALLCAPS)
				CharUpperBuff(&ch, 1);

			if(ch == WCH_EMBEDDING)
			{
				_li._fHasSpecialChars = TRUE;
				pobj = GetObjectFromCp(GetCp() + cchChunk - cch);
				if(pobj)
				{
					LONG vpAscent, vpDescent;
					pobj->MeasureObj(_fTarget ? _dvrInch : _dvpInch, 
									 _fTarget ? _durInch : _dupInch,
									 uAdd, vpAscent, vpDescent, _li._dvpDescent, GetTflow());

					// Only update height for line if the object is going
					// to be on this line.
					if(!_li._cch || _li._dup + uAdd <= dupMax)
					{
						if (vpAscent > _li._dvpHeight - _li._dvpDescent)
							_li._dvpHeight = vpAscent + _li._dvpDescent;
					}
				}
				if(_li._dup + uAdd > dupMax)
					fLastChObj = TRUE;
			}
			// The following if succeeds if ch isn't a CELL, BS, TAB, LF,
			// VT, FF, or CR
			else if(!IN_RANGE(CELL, ch, CR))		// Not TAB or EOP
			{
				// Get char width
				if (!_pccs->Include(ch, uAdd))
				{
					AssertSz(FALSE, "CMeasurer::Measure char not in font");
					return MRET_FAILED;
				}
				if(IN_RANGE(NBSPACE, ch, EURO))		// Rules out ASCII, CJK
				{
					switch(ch)						//  char for NBSPACE &
					{								//  special hyphens
					case EURO:
					case NBHYPHEN:
					case SOFTHYPHEN:
					case NBSPACE:
					case EMSPACE:
					case ENSPACE:
						_li._fHasSpecialChars = TRUE;

						if (ch == SOFTHYPHEN && (_li._dup + uAdd < dupMax || !_li._cch))
						{
							dupSoftHyphen = uAdd;	// Save soft hyphen width
							uAdd = 0;				// Use 0 unless at EOL
						}
						break;
					}
				}
				else if(_chPassword && IN_RANGE(0xDC00, *pch, 0xDFFF))
					uAdd = 0;
			}

			else if(ch == TAB)
			{
				_li._fHasSpecialChars = TRUE;
				uAdd = MeasureTab(ch);
			}
			else if(ch == FF && ped->Get10Mode())	// RichEdit 1.0 treats
				_pccs->Include(ch, uAdd);			//  FFs as normal chars
			else									// Done with line
				goto eop;							// Go process EOP chars

			index = iSavedWidths++ & MAX_SAVED_WIDTHS;
			savedWidths[index].width		 = (SHORT)uAdd;
			savedWidths[index].vpHeight		 = _li._dvpHeight;
			savedWidths[index].vpDescent	 = _li._dvpDescent;
			_li._dup += uAdd;

			if(_li._dup > dupMax &&
				(uiFlags & MEASURE_BREAKBEFOREWIDTH || _li._cch > 0))
				goto overflow;

			_li._cch++;
			pch++;
			cch--;
			if(ch != ' ')							// If not whitespace char,
			{
				cchNonWhite	= _li._cch;				//  update nonwhitespace
				dupNonWhite	= _li._dup;				//  count and width
			}
		}											// while(cch > 0)
	}												// for(;cchMax > 0;...)
	goto eol;										// All text exhausted 


// End Of Paragraph	char encountered (CR, LF, VT, or FF, but mostly CR)
eop:
	Move(cchChunk - cch);					// Position tp at EOP
	cch = AdvanceCRLF();					// Bypass possibly multibyte EOP
	_li._cchEOP = (BYTE)cch;				// Store EOP cch
	_li._cch   += cch;						// Increment line count
	if(ch == CR || ped->fUseCRLF() && ch == LF || ch == CELL)
		_li._fHasEOP = TRUE;
	
	AssertSz(ped->fUseCRLF() || cch == 1,
		"CMeasurer::Measure: EOP isn't a single char");
	AssertSz(_pdp->IsMultiLine() || GetCp() == cchText,
		"CMeasurer::Measure: EOP in single-line control");

eol:										// End of current line
	if(uiFlags & MEASURE_BREAKATWORD)		// Compute count of whitespace
		_li._dup = dupNonWhite;				//  chars at EOL

	goto done;

overflow:									// Went past max width for line
	_li._dup -= uAdd;
	--iSavedWidths;
	Move(cchChunk - cch);					// Position *this at overflow
											//  position
	if(uiFlags & MEASURE_BREAKATWORD)		// If required, adjust break on
	{										//  word boundary
		// We should not have the EOP flag set here.  The case to watch out
		// for is when we reuse a line that used to have an EOP.  It is the
		// responsibility of the measurer to clear this flag as appropriate.
	
		Assert(_li._cchEOP == 0);
		_li._cchEOP = 0;					// Just in case

		if(ch == TAB)
		{
			// If the last character measured is a tab,	leave it on the
			// next line to allow tabbing off the end of line as in Word
			goto done;
		}

		LONG cpStop = GetCp();					// Remember current cp

		cch = -FindWordBreak(WB_LEFTBREAK, _li._cch+1);

		if(cch == 0 && fLastChObj)				// If preceding char is an
			goto done;							//  object,	put current char
												//  on next line
		Assert(cch >= 0);
		if(cch + 1 < _li._cch)					// Break char not at BOL
		{
			ch = _rpTX.GetPrevChar();
			if (ch == TAB)						// If break char is a TAB,
			{									//  put it on the next line
				cch++;							//  as in Word
				Move(-1);					
			}
			else if(ch == SOFTHYPHEN)
				_li._dup += dupSoftHyphen;
			_li._cch -= cch;
		}
		else if(cch == _li._cch && cch > 1 &&
			_rpTX.GetChar() == ' ')				// Blanks all the way back to
		{										//  BOL. Bypass first blank
			Move(1);
			cch--;
			_li._cch = 1;
		}
		else									// Advance forward to end of
			SetCp(cpStop);						//  measurement

		Assert(_li._cch > 0);

		// Now search at start of word to figure how many white chars at EOL
		LONG cchWhite = 0;
		if(GetCp() < cchText)
		{
			pch = GetPch(cch);
			cch = 0;

			if(ped->TxWordBreakProc((WCHAR *)pch, 0, sizeof(WCHAR), WB_ISDELIMITER, GetCp()))
			{
				cch = FindWordBreak(WB_RIGHT);
				Assert(cch >= 0);
			}

			cchWhite = cch;
			_li._cch += cch;

			ch = GetChar();
			if(IN_RANGE(CELL, ch, CR) && !IN_RANGE(8, ch, TAB))	// skip *only* 1 EOP -jOn
			{
				if(ch == CR || ch == CELL)
					_li._fHasEOP = TRUE;
				_li._cchEOP = (BYTE)AdvanceCRLF();
				_li._cch += _li._cchEOP;
				goto done;
			}
		}

		i = cpStop - GetCp();
		if(i)
		{
			if(i > 0)
				i += cchWhite;
			if(i > 0 && i < iSavedWidths && i < MAX_SAVED_WIDTHS)
			{
				while (i-- > 0)
				{
					iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
					_li._dup -= savedWidths[iSavedWidths].width;
				}
				iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
				_li._dvpHeight	   = savedWidths[iSavedWidths].vpHeight;
				_li._dvpDescent	   = savedWidths[iSavedWidths].vpDescent;
			}
			else
			{
				// Need to recompute width from scratch.
				lRet = MRET_NOWIDTH;
			}
		}
		else
		{
			// i == 0 means that we are breaking on the first letter in a word.
			// Therefore, we want to set the width to the total non-white space
			// calculated so far because that does not include the size of the
			// character that caused the break nor any of the white space 
			// preceeding the character that caused the break.
			if(!fHeightChange)
				_li._dup = dupNonWhite;
			else
			{
				// Need to recompute from scratch so that we can get the 
				// correct height for the control
				lRet = MRET_NOWIDTH;
			}
		}
	}

done:
	_dupAddLast = uAdd;
	if(!_li._dvpHeight)						// If no height yet, use
		CheckLineHeight();					//  default height

	AdjustLineHeight();
	return lRet;
}

/*
 *	CMeasurer::UpdateWrapState(dvpLine, dvpDescent, fLeft)
 *
 *	@mfunc
 *		After formatting a line, update the current state of wrapped objects
 */
void CMeasurer::UpdateWrapState(
	USHORT &dvpLine, 
	USHORT &dvpDescent, 
	BOOL	fLeft)
{
	if (fLeft && _li._cObjectWrapLeft || !fLeft && _li._cObjectWrapRight)
	{
		COleObject *pobj = FindFirstWrapObj(fLeft);

		LONG & dvpWrapRemaining = fLeft ? _dvpWrapLeftRemaining : _dvpWrapRightRemaining;

		if (dvpWrapRemaining == -1)
		{
			if (fLeft)
				_li._fFirstWrapLeft = 1;
			else
				_li._fFirstWrapRight = 1;

			LONG dup, dvpAscent, dvpDescent;
			pobj->MeasureObj(_dvpInch, _dupInch, dup, dvpAscent, dvpDescent, 0, GetTflow());

			dvpWrapRemaining = dvpAscent + dvpDescent;
		}

		if (_li._fHasEOP && (_pPF->_wEffects & PFE_TEXTWRAPPINGBREAK))
		{
			LONG dvpRemaining = dvpWrapRemaining - dvpLine;
			if (dvpRemaining > 0)
			{
				dvpLine += dvpRemaining;
				dvpDescent += dvpRemaining;
			}
		}

		dvpWrapRemaining -= dvpLine;

		if (dvpWrapRemaining <= 0)
		{
			dvpWrapRemaining = -1;
			RemoveFirstWrap(fLeft);
		}
	}
}

/*
 *	CMeasurer::UpdateWrapState (&dvpLine, &dvpDescent)
 *
 *	@mfunc
 *		Update object wrap state
 */
void CMeasurer::UpdateWrapState(
	USHORT &dvpLine, 
	USHORT &dvpDescent)
{
	//If we are wrapping around an object, update dvpWrapUsed values
	//and remove objects from queue if they have been used up.
	if (IsMeasure() && _rgpobjWrap.Count())
	{
		UpdateWrapState(dvpLine, dvpDescent, TRUE);
		UpdateWrapState(dvpLine, dvpDescent, FALSE);
	}
}

/*
 *	CMeasurer::GetCcsFontFallback (pCF)
 *
 *	@mfunc
 *		Create the fallback font cache for given CF
 *
 *	@rdesc
 *		CCcs corresponding to font fallback given by pCF
 */
CCcs* CMeasurer::GetCcsFontFallback (
	const CCharFormat *pCF,
	WORD wScript)
{
	CCharFormat	CF = *pCF;
	CCcs*		pccs = NULL;
	SHORT		iDefHeight;
	CTxtEdit*	ped = GetPed();
	BYTE		bCharRep = CF._iCharRep;

#ifndef NOCOMPLEXSCRIPTS
	CUniscribe *pusp = ped->Getusp();
	if (pusp && wScript != 0)
	{
		pusp->GetComplexCharRep(pusp->GeteProp(wScript),
			ped->GetCharFormat(-1)->_iCharRep, bCharRep);
	}
#endif

	bool	fr = W32->GetPreferredFontInfo(bCharRep, 
									ped->fUseUIFont() ? true : false, CF._iFont, 
									(BYTE&)iDefHeight, CF._bPitchAndFamily);
	if (fr)
	{
		CF._iCharRep = bCharRep;
		pccs = GetCcs(&CF);				// Create fallback font cache entry
	}

	return pccs;
}

/*
 * 	CMeasurer::ApplyFontCache (fFallback, wScript)
 *
 *	@mfunc
 *		Apply a new font cache on the fly (leave backing store intact)
 *
 *	@rdesc
 *		CCcs corresponding to font fallback if fFallback; else to GetCF()
 */
CCcs* CMeasurer::ApplyFontCache (
	BOOL	fFallback,
	WORD	wScript)
{
	if (_fFallback ^ fFallback)
	{
		CCcs*	pccs = fFallback ? GetCcsFontFallback(GetCF(), wScript) : GetCcs(GetCF());
		
		if (pccs)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = pccs;
	
			_fFallback = fFallback;
		}
	}
	return _pccs;
}

/*
 *	CMeasurer::GetCcs (pCF)
 *
 *	@mfunc
 *		Wrapper around font cache's GetCCcs function
 *		We use a NULL DC unless the device is a printer.
 *
 *	@rdesc
 *		CCcs corresponding to pCF
 */
CCcs* CMeasurer::GetCcs(
	const CCharFormat *pCF)
{
	HDC hdc = NULL;

	if (_fTarget)
	{
		if (_pddReference->_hdc && GetDeviceCaps(_pddReference->_hdc, TECHNOLOGY) == DT_RASPRINTER)
			hdc = _pddReference->_hdc;
	}
	else if (_pdp->_hdc && GetDeviceCaps(_pdp->_hdc, TECHNOLOGY) == DT_RASPRINTER)
		hdc = _pdp->_hdc;

	DWORD dwFlags = GetTflow();
	if (_fGlyphing && _pdp->_hdc != _pddReference->_hdc)
		dwFlags |= FGCCSUSETRUETYPE;

	if(GetPasswordChar())
		pCF = GetPed()->GetCharFormat(-1);
	return GetPed()->GetCcs(pCF, _fTarget ? _dvrInch : _dvpInch, dwFlags, hdc);
}

/*
 *	CMeasurer::CheckLineHeight()
 *
 *	@mfunc
 *		If no height yet, use default height
 */
void CMeasurer::CheckLineHeight()
{
	CCcs *pccs = GetCcs(GetPed()->GetCharFormat(-1));
	_li._dvpHeight  = pccs->_yHeight;
	_li._dvpDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(FAdjustFELineHt());

	if (yFEAdjust)
	{
		_li._dvpHeight += (yFEAdjust << 1);
		_li._dvpDescent += yFEAdjust;
	}
	pccs->Release();
}

/*
 *	CMeasurer::Check_pccs(fBullet)
 *
 *	@mfunc
 *		Check if new character format run or whether we don't yet have a font
 *
 *	@rdesc
 *		Current CCcs *
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs *CMeasurer::Check_pccs(
	BOOL fBullet)
{
	if(fBullet)
	{
		if(_pccs)							// Release old Format cache
			_pccs->Release();

		_pccs = GetCcsBullet(NULL);
		_iFormat = -10;						// Be sure to reset font next time
		return _pccs;
	}

	const CCharFormat *pCF = GetCF();

	if(FormatIsChanged())
	{
		// New CF run or format for this line not yet initialized
		ResetCachediFormat();
		if(_pccs)							// Release old Format cache
			_pccs->Release();
			
		_pccs = GetCcs(pCF);
		_fFallback = 0;

		if(!_pccs)
		{
			//FUTURE (keithcu) If this fails, just dig up the first pccs you can find
			AssertSz(FALSE, "CMeasurer::Measure could not get _pccs");
			return NULL;
		}
	}

	return _pccs;
}

/*
 *	CMeasurer::AdjustLineHeight()
 *
 *	@mfunc
 *		Adjust for space before/after and line spacing rules.
 *		No effect for plain text.
 *
 *	@future
 *		Base multiple line height calculations on largest font height rather
 *		than on line height (_vpHeight), since the latter may be unduly large
 *		due to embedded objects.  Word does this correctly.
 */
void CMeasurer::AdjustLineHeight()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::AdjustLineHeight");

	if(!IsRich() || IsInOutlineView())			// Plain text and outline mode
		return;									//  don't use special line
												//  spacings
	const CParaFormat * pPF = _pPF;
	DWORD	dwRule	  = pPF->_bLineSpacingRule;
	LONG	dvpAfter	  = 0;						// Default no space after
	LONG	dvpBefore  = 0;						// Default no space before
	LONG	dvpSpacing = pPF->_dyLineSpacing;
	LONG	vpHeight  = LVtoDV(dvpSpacing);
	LONG	vpAscent = _li._dvpHeight - _li._dvpDescent;

	if(_li._fFirstInPara)
		dvpBefore = LVtoDV(pPF->_dySpaceBefore);	// Space before paragraph

	AssertSz(dvpBefore >= 0, "CMeasurer::AdjustLineHeight - bogus value for dvpBefore");

	if(vpHeight < 0)								// Negative heights mean use
		_li._dvpHeight = (SHORT)(-vpHeight);		//  the magnitude exactly

	else if(dwRule)								// Line spacing rule is active
	{
		switch (dwRule)
		{
		case tomLineSpace1pt5:
			dvpAfter = _li._dvpHeight >> 1;		// Half-line space after
			break;								//  (per line)
	
		case tomLineSpaceDouble:
			dvpAfter = _li._dvpHeight;			// Full-line space after
			break;								//  (per line)
	
		case tomLineSpaceAtLeast:
			if(_li._dvpHeight >= vpHeight)
				break;
												// Fall thru to space exactly
		case tomLineSpaceExactly:
			_li._dvpHeight = (SHORT)max(vpHeight, 1);
			break;
	
		case tomLineSpaceMultiple:				// Multiple-line space after
			// Prevent dvpAfter from being negative because dvpSpacing is small - a-rsail
			if (dvpSpacing < 20)
				dvpSpacing = 20;

			dvpAfter = (_li._dvpHeight*dvpSpacing)/20 // (20 units per line)
						- _li._dvpHeight;
		}
	}

	if(_li._fHasEOP)	
		dvpAfter += LVtoDV(pPF->_dySpaceAfter);	// Space after paragraph end
												// Add in space before/after
	if (dvpAfter < 0)
	{
		// Overflow - since we forced dvpSpacing to 20 above, the
		// only reason for a negative is overflow. In case of overflow,
		// we simply force the value to the max and then fix the
		// other resulting overflows.
		dvpAfter = LONG_MAX;
	}

	AssertSz((dvpBefore >= 0), "CMeasurer::AdjustLineHeight - invalid before");

	_li._dvpHeight  = (SHORT)(_li._dvpHeight + dvpBefore + dvpAfter);	

	if (_li._dvpHeight < 0)
	{
		// Overflow!
		// The reason for the -2 is then we don't have to worry about
		// overflow in the table check.
		_li._dvpHeight = SHRT_MAX - 2;
	}

	_li._dvpDescent = (SHORT)(_li._dvpDescent + dvpAfter);

	if (_li._dvpDescent < 0)
	{
		// Overflow in descent
		AssertSz(_li._dvpHeight == SHRT_MAX - 2, "Descent overflowed when height didn't");

		// Allow old ascent
		_li._dvpDescent = SHRT_MAX - 2 - vpAscent;

		AssertSz(_li._dvpDescent >= 0, "descent adjustment < 0");		
	}

	AssertSz((_li._dvpHeight >= 0) && (_li._dvpDescent >= 0),
		"CMeasurer::AdjustLineHeight - invalid line heights");
}

/*
 *	CMeasurer::GetPBorderWidth (dxlLine)
 *
 *	@mfunc
 *		Convert logical width to device width and ensure that
 *		device width is at least 1 pixel if logical width is nonzero.
 *	
 *	@rdesc
 *		Device width of border
 */
LONG CMeasurer::GetPBorderWidth(
	LONG dxlLine) 		//@parm Logical border width
{
	dxlLine &= 0xFF;
	LONG dxpLine = LUtoDU(dxlLine);
	if(dxlLine)
		dxpLine = max(dxpLine, 1);
	return dxpLine;
}

/*
 *	CMeasurer::MeasureLeftIndent()
 *
 *	@mfunc
 *		Compute and return left indent of line in device units
 *
 *	@rdesc
 *		Left indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLeftIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLeftIndent");

	AssertSz(_pPF != NULL, "CMeasurer::MeasureLeftIndent _pPF not set!");

	LONG ulLeft = _pPF->_dxStartIndent;				// Use logical units
													//  up to return
	if(IsRich())
	{
		LONG dulOffset = _pPF->_dxOffset;
		BOOL fFirstInPara = _li._fFirstInPara;

		if(IsInOutlineView())
		{
			ulLeft = lDefaultTab/2 * (_pPF->_bOutlineLevel + 1);
			if(!fFirstInPara)
				dulOffset = 0;
		}
		if(fFirstInPara)
		{
			if(_pPF->_wNumbering && !_pPF->IsNumberSuppressed())
			{
				// Add offset to text on first line	 
				if(_pPF->_wNumberingTab)			// If _wNumberingTab != 0,
					dulOffset = _pPF->_wNumberingTab;//  use it
				LONG Alignment = _pPF->_wNumberingStyle & 3;
				if(Alignment != tomAlignRight)
				{
					LONG du = DUtoLU(MeasureBullet());
					if(Alignment == tomAlignCenter)
						du /= 2;
					dulOffset = max(du, dulOffset);	// Use max of bullet and
				}
			}										//  offset
			else
				dulOffset = 0;
		}
		ulLeft += dulOffset;								
	}

	return (ulLeft <= 0) ? 0 : LUtoDU(ulLeft);
}

/*
 *	CMeasurer::HitTest(x)
 *
 *	@mfunc
 *		Return HITTEST for displacement x in this line. Can't be specific
 *		about text area (_upStart to _upStart + _dupLineMax), since need to measure
 *		to get appropriate cp (done elsewhere)
 *
 *	@rdesc
 *		HITTEST for a displacement x in this line
 */
HITTEST CMeasurer::HitTest(
	LONG x)			//@parm Displacement to test hit
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::HitTest");

	UpdatePF();
	LONG u = UFromX(x);
	if(u < 0)
		return HT_LeftOfText;

	// For RightOfText, allow for a little "hit space" of _li.GetHeight() to
	// allow user to select EOP at end of line
	if (u > _li._upStart + _li._dup + _li.GetHeight() &&
		GetPed()->GetSelMin() == GetCp() + _li._cch - _li._cchEOP)
	{
		return HT_RightOfText;
	}

	if(u >= _li._upStart)						// Caller can refine this
		return HT_Text;							//  with CLine::CchFromUp()

	if(IsRich() && _li._fFirstInPara)
	{
		LONG dup;
	
		if(_pPF->_wNumbering)
		{
			// Doesn't handle case where Bullet is wider than following dx
			dup = LUtoDU(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
			if(u >= _li._upStart - dup)
				return HT_BulletArea;
		}
		if(IsInOutlineView())
		{
			dup = LUtoDU(lDefaultTab/2 * _pPF->_bOutlineLevel);
			if(u >= dup && u < dup + (_pPF->_bOutlineLevel & 1
				? LUtoDU(lDefaultTab/2) : _pdp->Zoom(BITMAP_WIDTH_HEADING)))
			{
				return HT_OutlineSymbol;
			}
		}
	}
	return HT_LeftOfText;
}

/*
 *	CMeasurer::MeasureRightIndent()
 *
 *	@mfunc
 *		Compute and return right indent of line in device units
 *
 *	@rdesc
 *		Right indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureRightIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureRightIndent");

	LONG dulRight = _pPF->_dxRightIndent;

	_upRight = LUtoDU(max(dulRight, 0));
	return _upRight;
}

/*
 *	CMeasurer::MeasureTab()
 *
 *	@mfunc
 *		Computes and returns the width from the current position to the
 *		next tab stop (in device units).
 *
 *	@rdesc
 *		Width from current position to next tab stop
 */
LONG CMeasurer::MeasureTab(
	unsigned ch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureTab");

	LONG			uCur = _li._dup + MeasureLeftIndent();
	const CParaFormat *	pPF = _pPF;
 	LONG			cTab = pPF->_bTabCount;
	LONG			duDefaultTab = lDefaultTab;
	LONG			duIndent = LUtoDU(pPF->_dxStartIndent + pPF->_dxOffset);
	LONG			duOffset = pPF->_dxOffset;
	LONG			duOutline = 0;
	LONG			h = 0;
	LONG			uT;
	LONG			uTab;

	AssertSz(cTab >= 0 || cTab <= MAX_TAB_STOPS, "Illegal tab count");

	if(IsInOutlineView())
		duOutline = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);

	if(cTab)
	{										
		const LONG *pl = pPF->GetTabs();
		for(uTab = 0; cTab--; pl++)				// Try explicit tab stops 1st
		{
			uT = GetTabPos(*pl) + duOutline;	// (2 most significant nibbles
			if(uT > _dulLayout)					// Ignore tabs wider than layout area
				break;

			//REVIEW (keithcu) This is not proper hungarian
			uT = LUtoDU(uT);					//  are for type/style)

			if(uT + h > uCur)					// Allow text in table cell to
			{									//  move into cell gap (h > 0)									
				if(duOffset > 0 && uT < duIndent)// Explicit tab in a hanging
					return uT - uCur;			//  indent takes precedence
				uTab = uT;
				break;
			}
		}
		if(duOffset > 0 && uCur < duIndent)		// If no tab before hanging
			return duIndent - uCur;				//  indent, tab to indent

		if(uTab)								// Else use tab position
			return uTab - uCur;
	}

	duDefaultTab = GetTabPos(GetPed()->GetDefaultTab());
	AssertSz(duDefaultTab > 0, "CMeasurer::MeasureTab: Default tab is bad");

	duDefaultTab = LUtoDU(duDefaultTab);
	duDefaultTab = max(duDefaultTab, 1);		// Don't ever divide by 0
	return duDefaultTab - uCur%duDefaultTab;	// Round up to nearest
}

/*
 *	CMeasurer::MeasureLineShift ()
 *
 *	@mfunc
 *		Computes and returns the line u shift due to alignment
 *
 *	@rdesc
 *		Line u shift due to alignment
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLineShift()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLineShift");

	WORD wAlignment = _pPF->_bAlignment;
	LONG uShift;
	LONG dup;
	CTxtEdit *	ped = GetPed();

	if(IsInOutlineView() || !IN_RANGE(PFA_RIGHT, wAlignment, PFA_CENTER))
		return 0;

	if(!_pdp->GetWordWrap())
		dup = _pdp->GetDupView();
	else
		dup = LUtoDU(_dulLayout);

	// Normal view with center or flush-right para. Move right accordingly
	uShift = dup - _li._upStart - MeasureRightIndent() - _li._dup;

	uShift -= ped->GetCaretWidth();

	uShift = max(uShift, 0);			// Don't allow alignment to go < 0
										// Can happen with a target device
	if(wAlignment == PFA_CENTER)
		uShift /= 2;

	return uShift;
}

/*
 *	CMeasurer::MeasureBullet()
 *
 *	@mfunc
 *		Computes bullet/numbering dimensions
 *
 *	@rdesc
 *		Return bullet/numbering string width
 */
LONG CMeasurer::MeasureBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureBullet");

	CCharFormat CF;
	CCcs *pccs = GetCcsBullet(&CF);
	LONG dup = 0;

	if(pccs)
	{										
		WCHAR szBullet[CCHMAXNUMTOSTR];
		GetBullet(szBullet, pccs, &dup);
		RecalcLineHeight(pccs, &CF);
		pccs->Release();
	}
	return dup;
}

/*
 *	CMeasurer::GetBullet(pch, pccs, pdup)
 *
 *	@mfunc
 *		Computes bullet/numbering string, string length, and width
 *
 *	@rdesc
 *		Return bullet/numbering string length
 */
LONG CMeasurer::GetBullet(
	WCHAR *pch,			//@parm Bullet string to receive bullet text
	CCcs  *pccs,		//@parm CCcs to use
	LONG  *pdup)		//@parm Out parm for bullet width
{
	Assert(pccs && pch);

	LONG cch = _pPF->NumToStr(pch, _li._bNumber);
	LONG dupChar;
	LONG i;
	LONG dup = 0;

	pch[cch++] = ' ';					// Ensure a little extra space
	for(i = cch; i--; dup += dupChar)
	{
		if(!pccs->Include(*pch++, dupChar))
		{
			TRACEERRSZSC("CMeasurer::GetBullet(): Error filling CCcs", E_FAIL);
		}
	}

	if(pdup)
		*pdup = dup;

	return cch;
}

/*
 *	CMeasurer::GetCcsBullet(pCFRet)
 *
 *	@mfunc
 *		Get CCcs for numbering/bullet font. If bullet is suppressed because
 *		this isn't the beginning of a paragraph (e.g., previous character is
 *		VT or if GetCcs() fails, it returns NULL.
 *
 *	@rdesc
 *		ptr to bullet CCcs, or NULL (GetCcs() failed or not start of para)
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs * CMeasurer::GetCcsBullet(
	CCharFormat *pCFRet)	//@parm option character format to return
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::GetCcsBullet");

	if(!_li._fFirstInPara)
		return NULL;					// Number/bullet suppressed

	CCharFormat			CF;
	CCcs *			    pccs;
	const CCharFormat *	pCF;
	CCharFormat *		pCFUsed = pCFRet ? pCFRet : &CF;

	// Bullet CF is given by that for EOP in bullet's paragraph.

	CTxtPtr		  tp(_rpTX);
	CFormatRunPtr rpCF(_rpCF);
	rpCF.Move(tp.FindEOP(tomForward));
	rpCF.AdjustBackward();
	pCF = GetPed()->GetCharFormat(rpCF.GetFormat());

	// Construct bullet (or numbering) CCharFormat
	*pCFUsed = *pCF;
	if(_pPF->_wNumbering == PFN_BULLET)			// Traditional bullet uses
	{											//  Symbol font bullet, but...
		pCFUsed->_iCharRep		  = SYMBOL_INDEX,
		pCFUsed->_bPitchAndFamily = FF_DONTCARE;
		pCFUsed->_iFont			  = IFONT_SYMBOL;
	}

	// Since we always cook up bullet character format, no need to cache it
	pccs = GetCcs(pCFUsed);

#if DEBUG
	if(!pccs)
	{
		TRACEERRSZSC("CMeasurer::GetCcsBullet(): no CCcs", E_FAIL);
	}
#endif // DEBUG

	return pccs;
}

/*
 *	CMeasurer::SetNumber(wNumber)
 *
 *	@mfunc
 *		Store number if numbered paragraph
 */
void CMeasurer::SetNumber(
	WORD wNumber)
{
	_pPF = GetPF();
	if(!_pPF->IsListNumbered())
		wNumber = 0;

	else if (!wNumber && !_pPF->IsNumberSuppressed())
		wNumber = 1;

	_wNumber = wNumber;
}

/*
 *	CMeasurer::FindCpDraw(cpStart, cobjectPrev, fLeft)
 *
 *	@mfunc
 *		Find the cp corresponding to the nth previous object to be placed.
 *		(If a line stores a 2 in the _cObjectWrapLeft for example, it means
 *		you need to walk backwards 2 objects to find the object to be drawn
 *		on this line.)
 *
 *	@rdesc	
 *		cp corresponding to the nth previous object 
 */
LONG CMeasurer::FindCpDraw(
	LONG cpStart, 
	int  cobjectPrev, 
	BOOL fLeft)
{
	LONG cch = 0;
	LONG cObjects = -1;

	while (cobjectPrev > 0)
	{
		// BUGBUG: this test should really be after the CountObjects() call,
		//  but we are making a change with minimal impact just before
		//  a major release.
		if (!cObjects)
		    return tomForward;

		cch += GetPed()->GetObjectMgr()->CountObjects(cObjects, cpStart + cch);
		COleObject *pobj = GetObjectFromCp(cpStart + cch);
		if (!pobj)
			return tomForward;
		if (pobj->FWrapTextAround() && pobj->FAlignToRight() == !fLeft)
			cobjectPrev--;
	}
	
	return cpStart + cch;
}

/*
 *	CMeasurer::AddObjectToQueue(pobjAdd)
 *
 *	@mfunc
 *		After formatting a line, update the current state of wrapped objects
 */
void CMeasurer::AddObjectToQueue(
	COleObject *pobjAdd)
{
	if (!IsMeasure())
		return;

	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (pobj == pobjAdd)
			return;
	}

	COleObject **ppobj = _rgpobjWrap.Add(1, 0);
	*ppobj = pobjAdd;
}

/*
 *	CMeasurer::CountQueueEntries(fLeft)
 *
 *	@mfunc
 *		Return count of objects queued up
 *
 *	@rdesc
 *		Count of objects queued up
 */
int CMeasurer::CountQueueEntries(
	BOOL fLeft)
{
	int cEntries = 0;
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
			cEntries++;
	}
	return cEntries;
}

/*
 *	CMeasurer::RemoveFirstWrap(fLeft)
 *
 *	@mfunc
 *		Remove the object from the queue--after it
 *		has been been placed.
 */
void CMeasurer::RemoveFirstWrap(
	BOOL fLeft)
{
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
		{
			_rgpobjWrap.Remove(iobj, 1);
			return;
		}
	}
}

/*
 *	CMeasurer::FindFirstWrapObj(fLeft)
 *
 *	@mfunc
 *		Find the first object queued up to be wrapped.
 *
 *	@rdesc
 *		First object queued up to be wrapped.
 */
COleObject* CMeasurer::FindFirstWrapObj(
	BOOL fLeft)
{
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
			return pobj;
	}
	return 0;
}

/*
 *	CMeasurer::XFromU(u)
 *
 *	@mfunc
 *		Given a U position on a line, convert it to X. In
 *		RTL paragraphs, the U position of 0 on a line is
 *		on the right edge of the control.
 *
 *	@rdesc
 *		x coordinate corresponding to u in current rotation
 */
LONG CMeasurer::XFromU(LONG u)
{
	if (_pPF->IsRtlPara())
	{
		CTxtEdit *	ped = GetPed();
		LONG uCaret = _pdp->IsMain() ? ped->GetCaretWidth() : 0;
		LONG dupLayout = LUtoDU(_dulLayout);

		if (_plo && _plo->IsNestedLayout())
			;
		else if(!_pdp->GetWordWrap())
			dupLayout = max(_pdp->GetDupLineMax(), _pdp->GetDupView());

		return dupLayout - u - uCaret;
	}
	return u;
}

LONG CMeasurer::UFromX(LONG x)
{
	if (_pPF->IsRtlPara())
		return XFromU(x);
	return x;
}

#ifndef NOLINESERVICES
extern BOOL g_fNoLS;
extern BOOL g_OLSBusy;

/*
 *	CMeasurer::GetPols()
 *
 *	@mfunc
 *		Get ptr to LineServices object. If LineServices not enabled,
 *		return NULL.
 *
 *	@rdesc
 *		POLS
 */
COls *CMeasurer::GetPols()
{
	CTxtEdit *ped = GetPed();

	if(g_fNoLS || !ped->fUseLineServices())			// Not using LineServices
		return NULL;

	if(!g_pols)								// Starting up LS:
		g_pols = new COls();				//  create new COls

	if(g_pols)								// Have the COls
	{
		if(g_pols->Init(this) != NOERROR)	// Switch to new one
		{
			delete g_pols;
			g_pols = NULL;
		}
		g_OLSBusy = TRUE;
		UpdatePF();
	}
	return g_pols;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\m_undo.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	M_UNDO.C	|
 *
 *	Purpose:
 *		Implementation of the global mutli-undo stack
 *
 * 	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_disp.h"
#include "_urlsup.h"
#include "_antievt.h"

ASSERTDATA

//
// PUBLIC METHODS
//

/*
 *	CUndoStack::CUndoStack (ped, cUndoLim, flags)
 *
 *	@mfunc	Constructor
 */
CUndoStack::CUndoStack(
	CTxtEdit *ped,		//@parm	CTxtEdit parent
	LONG &	  cUndoLim,	//@parm Initial limit
	USFlags	  flags)	//@parm Flags for this undo stack
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CUndoStack");

	_ped = ped;
	_prgActions = NULL;
	_index = 0;
	_cUndoLim = 0;

	// We should be creating an undo stack if there's nothing to put in it!
	Assert(cUndoLim);
	SetUndoLimit(cUndoLim);

	if(flags & US_REDO)
		_fRedo = TRUE;
}

/*
 *	CUndoStack::~CUndoStack()
 *
 *	@mfunc Destructor
 *
 *	@comm
 *		Deletes any remaining antievents.  The antievent dispenser
 *		should *not* clean up because of this!!
 */
CUndoStack::~CUndoStack()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::~CUndoStack");

	// Clear out any remaining antievents
	ClearAll();

	delete _prgActions;
}

/*
 *	CUndoStack::Destroy ()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CUndoStack::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Destroy");

	delete this;
}

/*
 * 	CUndoStack::SetUndoLimit (cUndoLim)
 *
 *	@mfunc
 *		Allows the undo stack to be enlarged or reduced
 *
 *	@rdesc
 *		Size to which the stack is actually set.
 *
 *	@comm
 *		The algorithm we use is the following:	 <nl>
 *
 *		Try to allocate space for the requested size.
 *		If there's insufficient memory, try to recover
 *		with the largest block possible.
 *
 *		If the requested size is bigger than the default,
 *		and the current size is less than the default, go 
 *		ahead and try to allocate the default.
 *
 *		If that fails then just stick with the existing stack
 */
LONG CUndoStack::SetUndoLimit(
	LONG cUndoLim)			//@parm	New undo limit.  May not be zero
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::SetUndoLimit");

	// If the undo limit is zero, we should get rid of the entire
	// undo stack instead.
	Assert(cUndoLim);

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		if(cUndoLim != 1)
		{
			TRACEERRORSZ("Trying to grow/shrink the undo buffer while in"
				"single level mode");
			
			cUndoLim = 1;
		}
	}

	UndoAction *prgnew = new UndoAction[cUndoLim];
	if(prgnew)
		TransferToNewBuffer(prgnew, cUndoLim);

	else if(cUndoLim > DEFAULT_UNDO_SIZE && _cUndoLim < DEFAULT_UNDO_SIZE)
	{
		// We are trying to grow past the default but failed.  So
		// try to allocate the default
		prgnew = new UndoAction[DEFAULT_UNDO_SIZE];

		if(prgnew)
			TransferToNewBuffer(prgnew, DEFAULT_UNDO_SIZE);
	}
	
	// In either success or failure, _cUndoLim will be set correctly.	
	return _cUndoLim;
}

/*
 *	CUndoStack::GetUndoLimit() 
 *
 *	@mfunc
 *		Get current limit size
 *
 *	@rdesc	
 *		Current undo limit
 */
LONG CUndoStack::GetUndoLimit()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetUndoLimit");

	return _cUndoLim;
}

/*
 *	CUndoStack::PushAntiEvent (idName, pae)
 *
 *	@mfunc
 *		Adds an undoable event to the event stack
 *
 *	@rdesc	HRESULT
 *
 *	@comm
 *		Algorithm: if merging is set, then we merge the given antievent
 *		list *into* the current list (assuming it's a typing undo action).
 */
HRESULT CUndoStack::PushAntiEvent(
	UNDONAMEID idName,		//@parm	Name for this AE collection
	IAntiEvent *pae)		//@parm AE collection
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PushAntiEvent");

	// _index should be at next available position
	if(!_fMerge)
	{
		// clear out any existing event	
		if(_prgActions[_index].pae != NULL)
		{
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}

		if(_fRedo)
			_ped->GetCallMgr()->SetNewRedo();
		else
			_ped->GetCallMgr()->SetNewUndo();
	}

	if(_fMerge)
	{
		IAntiEvent *paetemp = pae, *paeNext;
		DWORD i = GetPrev();

		// If these asserts fail, then somebody did not call 
		// StopGroupTyping
		Assert(_prgActions[i].id == idName);
		Assert(idName == UID_TYPING);

		// Put existing antievent chain onto *end* of current one
		while((paeNext = paetemp->GetNext()) != NULL)
			paetemp = paeNext;

		paetemp->SetNext(_prgActions[i].pae);
		_index = i;
	}
	else if(_fGroupTyping)
	{
		// In this case, we are *starting* a group typing session.
		// Any subsequent push'es of anti events should be merged
		_fMerge = TRUE;
	}

	_prgActions[_index].pae = pae;
	_prgActions[_index].id = idName;
	
	Next();
	return NOERROR;
}

/*
 *	CUndoStack::PopAndExecuteAntiEvent(pAE)
 *
 *	@mfunc
 *		Undo!  Takes the most recent antievent and executes it
 *
 *	@rdesc
 *		HRESULT from invoking the antievents (AEs)
 */
HRESULT CUndoStack::PopAndExecuteAntiEvent(
	void *pAE)		//@parm If non-NULL, undo up to this point.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PopAndExecuteAntiEvent");

	HRESULT		hresult = NOERROR;
	IAntiEvent *pae, *paeDoTo;
	LONG		i, j;
	CCallMgr *	pcallmgr = _ped->GetCallMgr();

	// We need to check to see if there are any non-empty undo builders
	// higher on the stack.  In this case, we have been reentered
	if(pcallmgr->IsReEntered())
	{
		// There are two cases to handle: we are invoking redo or we
		// are invoking undo.  If we are invoking undo and there are 
		// existing undo actions in the undo builder, then simply commit
		// those actions and undo them.  We can assert in this case
		// that the redo stack is empty.
		//
		// In the second case if we are invoking redo while there are
		// undo actions in progress, simply cancel the call.  When the
		// undo actions are added, they will clear the redo stack.
		// 
		// We never need to check for a redo builder as that _only_
		// gets created in this routine and it's use is carefully guarded.
		
		// Commit the antievents to this undo stack, so that we will simply
		// undo them first.
		IUndoBuilder *publdr = (CGenUndoBuilder *)pcallmgr->GetComponent(COMP_UNDOBUILDER);
		if(publdr)
		{			
			TRACEWARNSZ("Undo/Redo Invoked with uncommitted antievents");
			TRACEWARNSZ("		Recovering....");

			if(_fRedo)
			{
				// If we are the redo stack, simply fail the redo call
				return NOERROR;
			}
			// Just commit the antievents; the routine below takes care of the rest
			publdr->Done();
		}
	}

	// If we are in single level mode, check to see if our current buffer is
	// empty.  If so, simply delegate to the redo stack if it exists.  We only
	// support this mode for dwDoToCookies being NULL.  Note that we can't call
	// CanUndo here as it will consider the redo stack as well
	if(_fSingleLevelMode && !_prgActions[GetPrev()].pae)
	{
		Assert(_fRedo == FALSE);
		Assert(pAE == 0);

		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->PopAndExecuteAntiEvent(0);

		// Nothing to redo && nothing to do here; don't bother continuing	
		return NOERROR;
	}

	// This next bit of logic is tricky.  What is says is create
	// an undo builder for the stack *opposite* of the current one
	// (namely, undo actions go on the redo stack and vice versa).
	// Also, if we are the redo stack, then we don't want to flush
	// the redo stack as antievents are added to the undo stack.
	CGenUndoBuilder undobldr(_ped, 
					(!_fRedo ? UB_REDO : UB_DONTFLUSHREDO) | UB_AUTOCOMMIT);
					
	// Obviously, we can't be grouping typing if we're undoing!
	StopGroupTyping();

	// _index by default points to the next available slot
	// so we need to back up to the previous one.
	Prev();

	// Do some verification on the cookie--make sure it's one of ours
	paeDoTo = (IAntiEvent *)pAE;
	if(paeDoTo)
	{
		for(i = 0, j = _index; i < _cUndoLim; i++)
		{
			if(IsCookieInList(_prgActions[j].pae, (IAntiEvent *)paeDoTo))
			{
				paeDoTo = _prgActions[j].pae;
				break;
			}
			// Go backwards through ring buffer; typically
			// paeDoTo will be "close" to the top
			j--;
			if(j < 0)
				j = _cUndoLim - 1;
		}
		
		if(i == _cUndoLim)
		{
			TRACEERRORSZ("Invalid Cookie passed into Undo; cookie ignored");
			hresult = E_INVALIDARG;
			paeDoTo = NULL;
		}
	}
	else
		paeDoTo = _prgActions[_index].pae;

	undobldr.SetNameID(_prgActions[_index].id);

	while(paeDoTo)
	{
		CUndoStackGuard guard(_ped);

		pae = _prgActions[_index].pae;
		Assert(pae);

		// Fixup our state _before_ calling Undo, so 
		// that we can handle being reentered.
		_prgActions[_index].pae = NULL;

		hresult = guard.SafeUndo(pae, &undobldr);

		DestroyAEList(pae);

		if(pae == paeDoTo || guard.WasReEntered())
			paeDoTo = NULL;
		Prev();
	}

	// Put _index at the next unused slot
	Next();
	return hresult;
}

/* 
 *	CUndoStack::GetNameIDFromTopAE(pAE)
 *
 *	@mfunc
 *		Retrieve the name of the most recent undo-able operation
 *
 *	@rdesc	the name ID of the most recent collection of antievents
 */
UNDONAMEID CUndoStack::GetNameIDFromAE(
	void *pAE)		//@parm Antievent whose name is desired;
					//		0 for the top
{
	IAntiEvent *pae = (IAntiEvent *)pAE;
	LONG	i, j = GetPrev();	// _index by default points to next 
								// available slot

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetNameIDFromTopAE");

	if(pae == NULL)
		pae = _prgActions[j].pae;

	if(_fSingleLevelMode && !pae)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If pae is NULL, our answer may be on the redo stack.  Note that
		// if somebody tries to pass in a cookie while in SingleLevelMode,
		// they won't be able to get actions off the redo stack.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->GetNameIDFromAE(0);
	}		

	for(i = 0; i < _cUndoLim; i++)
	{
		if(_prgActions[j].pae == pae)
			return _prgActions[j].id;
		j--;
		if(j < 0)
			j = _cUndoLim - 1;
	}
	return UID_UNKNOWN;
}

/*
 *	CUndoStack::GetMergeAntiEvent ()
 *
 *	@mfunc	If we are in merge typing mode, then return the topmost
 *			antievent
 *
 *	@rdesc	NULL or the current antievent if in merge mode
 */
IAntiEvent *CUndoStack::GetMergeAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetMergeAntiEvent");

	if(_fMerge)
	{
		LONG i = GetPrev();				// _index by default points to
										//  next available slot
		Assert(_prgActions[i].pae);		// Can't be in merge-antievent mode
		return _prgActions[i].pae;		//  if no antievent to merge with!!
	}
	return NULL;
}

/*
 *	CUndoStack::GetTopAECookie()
 *
 *	@mfunc	Returns a cookie to the topmost antievent.
 *
 *	@rdesc	A cookie value. Note that this cookie is just the antievent
 *			pointer, but clients shouldn't really know that.
 */		
void* CUndoStack::GetTopAECookie()
{
 	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetTopAECookie");

	return _prgActions[GetPrev()].pae;
}

/*
 *	CUndoStack::ClearAll ()
 *
 *	@mfunc
 *		Removes any antievents that are currently in the undo stack
 */
void CUndoStack::ClearAll()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::ClearAll");

 	for(LONG i = 0; i < _cUndoLim; i++)
	{
		if(_prgActions[i].pae)
		{
			DestroyAEList(_prgActions[i].pae);
			_prgActions[i].pae = NULL;
		}
	}

	// Just in case we've been grouping typing; clear the state.
	StopGroupTyping();
}

/*
 *	CUndoStack::CanUndo()
 *
 *	@mfunc
 *		Indicates whether or not can undo operation can be performed
 *		(in other words, are there any antievents in our buffer)
 *
 *	@rdesc
 *		TRUE	-- antievents exist 	<nl>
 *		FALSE 	-- no antievents		<nl>
 */
BOOL CUndoStack::CanUndo()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CanUndo");

	if(_prgActions[GetPrev()].pae)		// _index by default points
		return TRUE;					//  to next available slot

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If we are in single level mode, we are the undo stack.
		// Check to see if the redo stack can do something here.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->CanUndo();
	}
	return FALSE;
}

/*
 *	CUndoStack::StartGroupTyping ()
 *
 *	@mfunc
 *		TOGGLES the group typing flag on.  If fGroupTyping is set, then
 *		all *typing* events will be merged together
 *
 *	@comm
 *	Algorithm:
 *
 *		There are three interesting states:	<nl>
 *			-no group merge; every action just gets pushed onto the stack <nl>
 *			-group merge started; the first action is pushed onto the stack<nl>
 *			-group merge in progress; every action (as long as it's "typing")
 *			is merged into the prior state	<nl>
 *
 *		See the state diagram in the implemenation doc for more details
 */
void CUndoStack::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StartGroupTyping");

	if(_fGroupTyping)
		_fMerge = TRUE;
	else
	{
		Assert(_fMerge == FALSE);
		_fGroupTyping = TRUE;
	}
}

/*
 *	CUndoStack::StopGroupTyping	()
 *
 *	@mfunc
 *		TOGGLES the group typing flag off.  If fGroupTyping is not set,
 *		then no merging of typing antievents will be done
 */
void CUndoStack::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StopGroupTyping");

	_fGroupTyping = FALSE;
	_fMerge = FALSE;
}

/*
 *	CUndoStack::EnableSingleLevelMode()
 *
 *	@mfunc	Turns on single level undo mode; in this mode, we behave just like
 *			RichEdit 1.0 w.r.t. to Undo.
 *
 *	@rdesc
 *			HRESULT
 *
 *	@comm	This special mode means that undo is 1 level deep and everything 
 *			is accessed via UNDO messages.  Thus, instead of redo to undo an 
 *			undo action, you simply use another undo message. 
 *
 *	@devnote	This call is _ONLY_ allowed for the UndoStack; the redo 
 *			stack simply tags along.  Note that caller is responsible for
 *			ensuring that we are in an empty state.
 */
HRESULT CUndoStack::EnableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE && _fRedo == FALSE);

	_fSingleLevelMode = TRUE;

	// For single level undo mode, it is very important to get
	// just 1 entry in the undo stack.  If we can't do that,
	// then we better just fail.
	if(SetUndoLimit(1) != 1)
	{
		_fSingleLevelMode = FALSE;
		return E_OUTOFMEMORY;
	}
	if(_ped->GetRedoMgr())
	{
		// Doesn't matter if the redo manager fails to reset
		_ped->GetRedoMgr()->SetUndoLimit(1);
	}
	return NOERROR;
}

/*
 *	CUndoStack::DisableSingleLevelMode()
 *
 *	@mfunc	This turns off the 1.0 undo compatibility mode and restores us 
 *			to the RichEdit 2.0 default undo state
 */
void CUndoStack::DisableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE && _fRedo == FALSE);

	// We don't care about failures here; multi-level undo mode
	// can handle any sized undo stack
	_fSingleLevelMode = FALSE;
	SetUndoLimit(DEFAULT_UNDO_SIZE);

	if(_ped->GetRedoMgr())
	{
		// Doesn't matter if the redo manager can't grow back in
		// size; it just means that we won't have full redo capability.
		_ped->GetRedoMgr()->SetUndoLimit(DEFAULT_UNDO_SIZE);
	}
}

//
// PRIVATE METHODS
//

/*
 *	CUndoStack::Next()
 *
 *	@mfunc
 *		Sets _index to the next available slot
 */
void CUndoStack::Next()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Next");

	_index++;
	if(_index == _cUndoLim)
		_index = 0;
}

/*
 *	CUndoStack::Prev()
 *
 *	@mfunc
 *		Sets _index to the previous slot
 */
void CUndoStack::Prev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Prev");

	_index = GetPrev();
}

/*
 *	CUndoStack::GetPrev()
 *
 *	@mfunc
 *		Figures out what the index to the previous slot
 *		*should* be (but does not set it)
 *
 *	@rdesc
 *		Index of what the previous slot would be
 */
LONG CUndoStack::GetPrev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetPrev");

	LONG i = _index - 1;

	if(i < 0)
		i = _cUndoLim - 1;

	return i;
}

/*
 *	CUndoStack::IsCookieInList (pae, paeCookie)
 *
 *	@mfunc	
 *		Determines whether or not the given DoTo cookie is in
 *		the list of antievents.
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CUndoStack::IsCookieInList(
	IAntiEvent *pae,		//@parm	List to check
	IAntiEvent *paeCookie)	//@parm Cookie to check
{
	while(pae)
	{
		if(pae == paeCookie)
			return TRUE;

		pae = pae->GetNext();
	}
	return FALSE;
}

/*
 *	CUndoStack::TransferToNewBuffer	(prgnew, cUndoLim)
 *
 *	@mfunc	
 *		Transfers existing antievents to the given buffer and
 *		swaps this undo stack to use the new buffer
 *
 *	@comm
 *		The algorithm is very straightforward; go backwards in
 *		the ring buffer copying antievents over until either there
 *		are no more antievents or the new buffer is full.  Discard
 *		any remaining antievents.
 */
void CUndoStack::TransferToNewBuffer(
	UndoAction *prgnew,
	LONG		cUndoLim)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::TransferToNewBuffer");

	LONG 	iOld = 0, 
			iNew = 0,
			iCopyStart = 0;

	// First clear new buffer.
	FillMemory(prgnew, 0, cUndoLim * sizeof(UndoAction));

	// If there is nothing to copy, don't bother
	if(!_prgActions || !_prgActions[GetPrev()].pae)
		goto SetState;

	// This is a bit counter-intuitive, but since the stack is really
	// a ring buffer, go *forwards* until you hit a non-NULL slot.
	// This will be the _end_ of the existing antievents.
	//
	// However, we need to make sure that if cUndoLim is 
	// _smaller_ than _cUndoLim we only copy the final cUndoLim
	// antievents.  We'll set iCopyStart to indicate when
	// we can start copying stuff.
	if(cUndoLim < _cUndoLim)
		iCopyStart = _cUndoLim - cUndoLim;

	for(; iOld < _cUndoLim; iOld++, Next())
	{
		if(!_prgActions[_index].pae)
			continue;

		if(iOld >= iCopyStart)
		{
			Assert(iNew < cUndoLim);

			prgnew[iNew] = _prgActions[_index]; // Copy over antievents
			iNew++;
		}
		else
		{
			// Otherwise, get rid of them
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}
	}

SetState:
	// Start at index iNew
	_index = (iNew == cUndoLim) ? 0 : iNew;
	Assert(iNew <= cUndoLim);

	_cUndoLim = cUndoLim;
	
	if(_prgActions)
		delete _prgActions;

	_prgActions = prgnew;
}	

//
//	CGenUndoBuilder implementation
//

//
//	Public methods
//

/*
 *	CGenUndoBuilder::CGenUndoBuilder (ped, flags, ppubldr)
 *
 *	@mfunc	Constructor
 *
 *	@comm
 *		This is a *PUBLIC* constructor
 */
CGenUndoBuilder::CGenUndoBuilder(
	CTxtEdit *		ped,		//@parm	Edit context
	DWORD			flags,		//@parm flags (usually UB_AUTOCOMMIT)
	IUndoBuilder **	ppubldr)	//@parm Ptr to undobldr interface
{
	// Set everthing to NULL because instances can go on the stack.
	// _pundo is set below
	_publdrPrev			= NULL;
	_idName				= UID_UNKNOWN;
	_pfirstae			= NULL;
	_fAutoCommit		= (flags & UB_AUTOCOMMIT) != 0;
	_fStartGroupTyping	= FALSE;
	_fDontFlushRedo		= FALSE;
	_fInactive			= FALSE;
	_ped				= ped;

	CompName name;
	if(flags & UB_REDO)
	{
		_fRedo = TRUE;
		name   = COMP_REDOBUILDER;
		_pundo = ped->GetRedoMgr();
	}
	else
	{
		_fRedo = FALSE;
		name   = COMP_UNDOBUILDER;
		_pundo = ped->GetUndoMgr();
	}

	// If undo is on, set *ppubldr to be this undo builder; else NULL
	// TODO: do we need to link in inactive undo builders?
	if(ppubldr)
	{
		if(!ped->_fUseUndo)				// Undo is disabled or suspended
		{								// Still have undobldrs since stack
			*ppubldr = NULL;			//  alloc is efficient. Flag this
			_fInactive = TRUE;			//  one as inactive
			return;
		}
		*ppubldr = this;
	}

	if(flags & UB_DONTFLUSHREDO)
		_fDontFlushRedo = TRUE;

	// Now link ourselves to any undobuilders that are higher up on
	// the stack.  Note that is is legal for multiple undo builders
	// to live within the same call context.
	_publdrPrev = (CGenUndoBuilder *)_ped->GetCallMgr()->GetComponent(name);

	// If we are in the middle of an undo, then we'll have two undo stacks
	// active, the undo stack and the redo stack.  Don't like the two
	// together.
	if(_fDontFlushRedo)
		_publdrPrev = NULL;

	_ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
							name);
}

/*
 *	CGenUndoBuilder::~CGenUndoBuilder()
 *
 *	@mfunc	Destructor
 *
 *	@comm
 *		This is a *PUBLIC* destructor
 *
 *	Algorithm:
 *		If this builder hasn't been committed to an undo stack
 *		via ::Done, then we must be sure to free up any resources
 *		(antievents) we may be hanging onto
 */
CGenUndoBuilder::~CGenUndoBuilder()
{
	if(!_fInactive)
		_ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);

	if(_fAutoCommit)
	{
		Done();
		return;
	}

	// Free resources
	if(_pfirstae)
		DestroyAEList(_pfirstae);
}

/*
 *	CGenUndoBuilder::SetNameID (idName)
 *
 *	@mfunc
 *		Allows a name to be assigned to this antievent collection.
 *		The ID should be an index that can be used to retrieve a
 *		language specific string (like "Paste").  This string is
 *		typically composed into undo menu items (i.e. "Undo Paste").
 */
void CGenUndoBuilder::SetNameID(
	UNDONAMEID idName)			//@parm	the name ID for this undo operation
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::SetNameID");

	// Don't delegate to the higher undobuilder, even if it exists. The
	// original name should win in reentrancy cases.
	_idName = idName;
}

/*
 *	CGenUndoBuilder::AddAntiEvent (pae)
 *
 *	@mfunc
 *		Adds an antievent to the end of the list
 *
 *	@rdesc 	NOERROR
 */
HRESULT CGenUndoBuilder::AddAntiEvent(
	IAntiEvent *pae)		//@parm	Antievent to add
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::AddAntiEvent");

	if(_publdrPrev)
		return _publdrPrev->AddAntiEvent(pae);

	pae->SetNext(_pfirstae);
	_pfirstae = pae;

	return NOERROR;
}

/*
 *	CGenUndoBuilder::GetTopAntiEvent()
 *
 *	@mfunc	Gets the top antievent for this context.
 *
 *	@comm	The current context can be either the current
 *			operation *or* to a previous operation if we are in
 *			merge typing mode.
 *
 *	@rdesc	top antievent
 */
IAntiEvent *CGenUndoBuilder::GetTopAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::GetTopAntiEvent");

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return _publdrPrev->GetTopAntiEvent();
	}

	if(!_pfirstae && _pundo)
		return _pundo->GetMergeAntiEvent();

	return _pfirstae;
}

/*
 *	CGenUndoBuilder::Done ()
 *
 *	@mfunc
 *		Puts the combined antievents (if any) into the undo stack
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CGenUndoBuilder::Done()
{
	HRESULT		hr = NOERROR;

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return NOERROR;
	}

	// If nothing changed, discard any selection antievents
	// or other no-op actions.
	if(!_ped->GetCallMgr()->GetChangeEvent())
	{
		Discard();
		return NOERROR;
	}

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(_pundo && _ped->_fUseUndo ? this : NULL);

	if(_pfirstae)
	{
		if(!_pundo)
		{
			// Yikes!  There's no undo stack; better create one.
			// If we are a redo guy, we should create a redo
			// stack the size of the undo stack
			LONG cUndoLim = DEFAULT_UNDO_SIZE;
			if(_fRedo)
			{
				Assert(_ped->GetUndoMgr());

				cUndoLim = _ped->GetUndoMgr()->GetUndoLimit();
			}

			// FUTURE:  A NULL ptr returned from CreateUndoMgr means either
			// 	we are out of memory, or the undo limit is set to 0.  For the
			// 	latter case, we have collected AE's to push onto a non-existent
			// 	undo stack.  It may be more efficient to not generate
			// 	the AE's at all when the undo limit is 0.
			_pundo = _ped->CreateUndoMgr(cUndoLim,	_fRedo ? US_REDO : US_UNDO);
			if(!_pundo)
				goto CleanUp;
		}

		// We may need to flush the redo stack if we are adding
		// more antievents to the undo stack *AND* we haven't been
		// told not to flush the redo stack.  The only time we won't
		// flush the redo stack is if it's the redo stack itself
		// adding antievents to undo.
		if(!_fRedo)
		{
			// If our destination is the undo stack, then check
			// to see if we should flush
			if(!_fDontFlushRedo)
			{
				IUndoMgr *predo = _ped->GetRedoMgr();
				if(predo)
					predo->ClearAll();
			}
		}
		else
			Assert(!_fDontFlushRedo);

		// If we should enter into the group typing state, inform
		// the undo manager.  Note that we only do this *iff* 
		// there is actually some antievent to put in the undo
		// manager.  This makes the undo manager easier to implement.
		if(_fStartGroupTyping)
			_pundo->StartGroupTyping();
		
		hr = _pundo->PushAntiEvent(_idName, _pfirstae);

		// The change event flag should be set if we're adding
		// undo items!  If this test is true, it probably means
		// the somebody earlier in the call stack sent change
		// notifications, e.g., via SendAllNotifications _before_
		// this undo context was committed _or_ it means that we
		// were reentered in some way that was not handled properly.
		// Needless to say, this is not an ideal state.

CleanUp:
		Assert(_ped->GetCallMgr()->GetChangeEvent());

		IAntiEvent *paetemp = _pfirstae;
		_pfirstae = NULL;
		CommitAEList(_ped, paetemp);

		if(!_pundo || hr != NOERROR)
		{
			// Either we failed to add the AE's to the undo stack
			// or the undo limit is 0 in which case there won't be
			// an undo stack to push the AE's onto.
			DestroyAEList(paetemp);
		}
	}
	return hr;
}

/*
 *	CGenUndoBuilder::Discard ()
 *
 *	@mfunc
 *		Gets rid of any antievents that we may be hanging onto without
 *		executing or committing them.  Typically used for recovering
 *		from certain failure or reentrancy scenarios.  Note that
 *		an _entire_ antievent chain will be removed in this fashion.
 */
void CGenUndoBuilder::Discard()
{
	if(_pfirstae)
	{
		DestroyAEList(_pfirstae);
		_pfirstae = NULL;
	}
	else if(_publdrPrev)
		_publdrPrev->Discard();
}

/*
 *	CGenUndoBuilder::StartGroupTyping ()
 *
 *	@mfunc
 *		Hangs onto the the fact that group typing should start.
 *		We'll forward the the state transition to the undo manager
 *		only if an antievent is actually added to the undo manager.
 *
 *	@devnote
 *		Group typing is disabled for redo stacks.
 */
void CGenUndoBuilder::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StartGroupTyping");

	_fStartGroupTyping = TRUE;
}

/*
 *	CGenUndoBuilder::StopGroupTyping ()
 *
 *	@mfunc
 *		Forwards a stop grouped typing to the undo manager
 */
void CGenUndoBuilder::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StopGroupTyping");

	if(_pundo)
		_pundo->StopGroupTyping();
}

//
//	CUndoStackGuard IMPLEMENTATION
//

/*
 *	CUndoStackGuard::CUndoStackGuard(ped)
 *
 *	@mfunc	Constructor.  Registers this object with the call manager
 */
CUndoStackGuard::CUndoStackGuard(
	CTxtEdit *ped)			//@parm the edit context
{
	_ped = ped;
	_fReEntered = FALSE;
	_hr = NOERROR;
	ped->GetCallMgr()->RegisterComponent(this, COMP_UNDOGUARD);
}

/*
 *	CUndoStackGuard::~CUndoStackGuard()
 *
 *	@mfunc	Destructor.  Revokes the registration of this object
 *			with the call manager
 */
CUndoStackGuard::~CUndoStackGuard()
{
	_ped->GetCallMgr()->RevokeComponent(this);
}

/*
 *	CUndoStackGuard::SafeUndo (pae, publdr)
 *
 *	@mfunc	Loops through the given list of antievents, invoking
 *			undo on each.  
 *
 *	@rdesc	HRESULT, from the undo actions
 *
 *	@devnote	This routine is coded so that OnEnterContext can pick up
 *			and continue the undo operation should we become reentered
 */
HRESULT CUndoStackGuard::SafeUndo(
	IAntiEvent *  pae,		//@parm Start of antievent list
	IUndoBuilder *publdr)	//@parm Undo builder to use
{
	_publdr = publdr;
	while(pae)
	{
		_paeNext = pae->GetNext();
		HRESULT hr = pae->Undo(_ped, publdr);

		// Save first returned error
		if(hr != NOERROR && _hr == NOERROR)
			_hr = hr;

		pae = (IAntiEvent *)_paeNext;
	}
	return _hr;
}

/*
 *	CUndoStackGuard::OnEnterContext
 *
 *	@mfunc	Handle reentrancy during undo operations.
 *
 *	@devnote If this method is called, it's pretty serious.  In general,
 *			we shoud never be reentered while processing undo stuff.
 *			However, to ensure that, block the incoming call and process
 *			the remaining actions.
 */
void CUndoStackGuard::OnEnterContext()
{
	TRACEWARNSZ("ReEntered while processing undo.  Blocking call and");
	TRACEWARNSZ("	attempting to recover.");

	_fReEntered = TRUE;
	SafeUndo((IAntiEvent *)_paeNext, _publdr);
}	

//
//	PUBLIC helper functions
//

/*
 *	DestroyAEList(pae)
 *
 *	@func
 *		Destroys a list of antievents
 */
void DestroyAEList(
	IAntiEvent *pae)	//@parm Antievent from which to start
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->Destroy();
		pae = pnext;
	}
}

/*
 *	CommitAEList(ped, pae)
 *
 *	@func 
 *		Calls OnCommit to commit the given list of antievents
 */
void CommitAEList(
	CTxtEdit *	ped,	//@parm Edit context
	IAntiEvent *pae)	//@parm Antievent from which to start
{
	IAntiEvent *pnext;
	while(pae)
	{
		pnext = pae->GetNext();
		pae->OnCommit(ped);
		pae = pnext;
	}
}

/*
 *	HandleSelectionAEInfo(ped, publdr, cp, cch, cpNext, cchNext, flags)
 *
 *	@func	HandleSelectionAEInfo | Tries to merge the given info with 
 *			the existing undo context; if that fails, then it allocates 
 *			a new selection antievent to handle the info
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT HandleSelectionAEInfo(
	CTxtEdit *	  ped,		//@parm Edit context
	IUndoBuilder *publdr,	//@parm Undo context
	LONG		  cp,		//@parm cp to use for the sel ae
	LONG		  cch,		//@parm Signed selection extension
	LONG		  cpNext,	//@parm cp to use for the AE of the AE
	LONG		  cchNext,	//@parm cch to use for the AE of the AE
	SELAE		  flags)	//@parm Controls how to interpret the info
{
	Assert(publdr);

	// First see if we can merge the selection info into any existing
	// antievents.  Note that the selection antievent may be anywhere
	// in the list, so go through them all
	IAntiEvent *pae = publdr->GetTopAntiEvent();
	if(pae)
	{
		SelRange sr;

		sr.cp		= cp;
		sr.cch		= cch;
		sr.cpNext	= cpNext;
		sr.cchNext	= cchNext;
		sr.flags	= flags;

		while(pae)
		{
			if(pae->MergeData(MD_SELECTIONRANGE, (void *)&sr) == NOERROR)
				break;
			pae = pae->GetNext();
		}
		if(pae)
			return NOERROR;
	}

	// Oops; can't do a merge.  Go ahead and create a new antievent.
	Assert(!pae);
	pae = gAEDispenser.CreateSelectionAE(ped, cp, cch, cpNext, cchNext);
	if(pae)
	{
		publdr->AddAntiEvent(pae);
		return NOERROR;
	}
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\object.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	object.cpp	IRichEditOle implementation |
 *
 *	Author: alexgo 8/15/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_rtext.h"
#include "_select.h"
#include "_m_undo.h"
#include "_disp.h"


// 	IUnknown is implemented elsewhere

/*
 *	CTxtEdit::GetClientSite (lplpolesite)
 *
 *	@mfunc	returns the client site 
 */
STDMETHODIMP CTxtEdit::GetClientSite(
	LPOLECLIENTSITE FAR * lplpolesite)		//@parm where to return 
											//the client site
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClientSite");

	if(!lplpolesite)
		return E_INVALIDARG;

	COleObject *pobj = new COleObject(this);
	// should start with a ref count of 1.
	if(pobj)
	{
		*lplpolesite = (IOleClientSite *)pobj;
		return NOERROR;
	}
	*lplpolesite = NULL;
	return E_OUTOFMEMORY;
}

/* 
 *	CTxtEdit::GetObjectCount
 *
 *	@mfunc	return the number of objects in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObjectCount");
	
	return _pobjmgr ? _pobjmgr->GetObjectCount() : 0;
}

/*
 *	CTxtEdit::GetLinkCount
 *
 *	@mfunc	return the number of likns in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetLinkCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetLinkCount");

	CObjectMgr *pobjmgr = GetObjectMgr();
	return pobjmgr ? pobjmgr->GetLinkCount() : 0;
}

/*
 *	CTxtEdit::GetObject(iob, preobj, dwFlags)
 *
 *	@mfunc	returns an object structure for the indicated object
 */
STDMETHODIMP CTxtEdit::GetObject(
	LONG iob, 					//@parm index of the object
	REOBJECT * preobj,			//@parm where to put object info
	DWORD dwFlags)				//@parm flags
{
	COleObject *pobj = NULL;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObject");
	if(!preobj || preobj->cbStruct != sizeof(REOBJECT))
		return E_INVALIDARG;

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// There are three cases of intestest; get the object at
	// an index, at a given cp, or at the selection.

	if(iob == REO_IOB_USE_CP || iob == REO_IOB_SELECTION)
	{
		if((Get10Mode() && preobj->cp == REO_CP_SELECTION) || iob == REO_IOB_SELECTION)
		{
			// Use selection cp
			CTxtSelection *psel = GetSel();
			if(psel)
				pobj = pobjmgr->GetObjectFromCp(psel->GetCpMin());
		}
		else
			pobj = pobjmgr->GetObjectFromCp(Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp);
	}
	else if (iob >= 0)
		pobj = pobjmgr->GetObjectFromIndex(iob);

	if(pobj)
	{
		HRESULT hResult = pobj->GetObjectData(preobj, dwFlags);

		if (Get10Mode())
			preobj->cp = GetAcpFromCp(preobj->cp);

		return hResult;
	}

	// This return code is a bit of stretch, but basially 
	return E_INVALIDARG;
}

/*
 *	CTxtEdit::InsertObject (preobj)
 *
 *	@mfunc	inserts a new object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::InsertObject(
	REOBJECT * preobj)		//@parm object info
{
	CCallMgr		callmgr(this);
	CTxtRange		rg(this, 0);
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InsertObject");

	// Do some boundary case checking

	if(!preobj)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();
	if(!psel)
		return E_OUTOFMEMORY;

	// The following code gives Outlook major fits if you click on a name in
	// the To:, Cc:, or Bcc: fields, so I've commented it out. In principle,
	// Outlook's EN_PROTECTION handler should say it's OK to insert in this case.
	//
	//	if(!IsntProtectedOrReadOnly(0, 0, 0))
	//		return E_ACCESSDENIED;

	// If the insertion of this character would cause
	// us to exceed the text limit, fail
	if((DWORD)(GetAdjustedTextLength() + 1) > TxGetMaxLength())
	{
		// If we're not replacing a selection (or the
		// selection is degenerate, then we will have  exceeded
		// our limit
		if(preobj->cp != REO_CP_SELECTION || psel->GetCch() == 0)
		{
			GetCallMgr()->SetMaxText();
			return E_OUTOFMEMORY;
		}
	}
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		LONG cch = 0;
		LONG cp;

		undobldr.StopGroupTyping();

		if(preobj->cp == REO_CP_SELECTION)
		{
			LONG cpFormat;
			LONG cpMost;
			psel->AdjustEndEOP(NEWCHARS);
			cch = psel->GetRange(cp, cpMost);

			// Get cp of active end of selection from which we
			// will obtain CF for object.
			cpFormat = psel->GetCp();
			if(publdr)
				HandleSelectionAEInfo(this, publdr, cpFormat, cch, 
						cp + 1, 0, SELAE_FORCEREPLACE);

			// Get format for ReplaceRange: for cp semantics, use format
			// at the cp; for selection semantics, use the format at the
			// active end of the selection.
			rg.SetCp(cpFormat, FALSE);
			LONG iFormat = rg.Get_iCF();
			rg.Set(cp, -cch);
			rg.Set_iCF(iFormat);		// Use _iFormat at sel active end
			rg.SetUseiFormat(TRUE);
			ReleaseFormats(iFormat, -1);
		}
		else
		{
			cp = Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp;
			rg.SetCp(cp, FALSE);			// Updates rg._iFormat
		}

		if(preobj->dwFlags & REO_USEASBACKGROUND)
		{
			CDocInfo *pDocInfo = GetDocInfo();
			if(pDocInfo)
				pDocInfo->InitBackground();
		}
		HRESULT		hr = pobjmgr->InsertObject(&rg, preobj, publdr);
		CNotifyMgr *pnm = GetNotifyMgr();	// Get notification mgr
		if(pnm)								// Notify interested parties
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, cp, cp + 1);

		// Don't want object selected
		psel->SetSelection(cp + 1, cp + 1);
		if(preobj->dwFlags & REO_USEASBACKGROUND)
			_pdp->UpdateView();

		TxUpdateWindow();
		return hr;
	}
	return E_OUTOFMEMORY;		
}

/*
 *	CTxtEdit::ConvertObject(iob, rclsidNew, lpstrUserTypeNew)
 *
 *	@mfunc	Converts the specified object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ConvertObject(
	LONG iob, 					//@parm index of the object
	REFCLSID rclsidNew,			//@parm the destination clsid
	LPCSTR lpstrUserTypeNew)	//@parm the new user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ConvertObject");
	CCallMgr callmgr(this);

	// If iob was invalid return
	COleObject * pobj = ObjectFromIOB(iob);
	if(!pobj)
		return E_INVALIDARG;

	//Delegate to the object.
	return pobj->Convert(rclsidNew, lpstrUserTypeNew);
}

/*
 *	CTxtEdit::ActivateAs(rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a
 *		particular class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ActivateAs(
	REFCLSID rclsid, 			//@parm clsid which we're going to change
	REFCLSID rclsidAs)			//@parm clsid to activate as
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ActivateAs");
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	return pobjmgr->ActivateObjectsAs(rclsid, rclsidAs);
}

/* 
 *	CTxtEdit::SetHostNames(lpstrContainerApp, lpstrContainerDoc)
 *
 *	@mfunc	Sets the host names for this instance
 */
STDMETHODIMP CTxtEdit::SetHostNames(
	LPCSTR lpstrContainerApp, 	//@parm App name
	LPCSTR lpstrContainerDoc)	//@parm	Container Object (doc) name
{
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetHostNames");
	
 	WCHAR *pwsContainerApp = W32->ConvertToWideChar(lpstrContainerApp);
	WCHAR *pwsContainerDoc = W32->ConvertToWideChar(lpstrContainerDoc);

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr && pwsContainerApp && pwsContainerDoc)
	{
		HRESULT hr = pobjmgr->SetHostNames(pwsContainerApp, pwsContainerDoc);
		delete pwsContainerApp;
		delete pwsContainerDoc;
		return hr;
	}
	return E_OUTOFMEMORY;
}

/*
 *	CTxtEdit::SetLinkAvailable(iob, fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 */
STDMETHODIMP CTxtEdit::SetLinkAvailable(
	LONG iob, 					//@parm index of the object
	BOOL fAvailable)			//@parm if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetLinkAvailable");

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	return pobj->SetLinkAvailable(fAvailable);
}

/*
 *	CTxtEdit::SetDvaspect(iob, dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SetDvaspect(
	LONG iob, 					//@parm index of the object
	DWORD dvaspect)				//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetDvaspect");
	CCallMgr callmgr(this);
	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SetDvaspect(dvaspect);
	return NOERROR;
}

/*
 *	CTxtEdit::HandsOffStorage(iob)
 *
 *	@mfunc	see IPersistStorage::HandsOffStorage
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::HandsOffStorage(
	LONG iob)					//@parm index of the object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::HandsOffStorage");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->HandsOffStorage();
	return NOERROR;
}

/*
 *	CTxtEdit::SaveCompleted(iob, lpstg)
 *
 *	@mfunc	see IPersistStorage::SaveCompleted
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SaveCompleted(
	LONG iob, 					//@parm index of the object
	LPSTORAGE lpstg)			//@parm new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SaveCompleted");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SaveCompleted(lpstg);
	return NOERROR;
}

/*
 *	CTxtEdit::InPlaceDeactivate()
 *
 *	@mfunc	Deactivate 
 */
STDMETHODIMP CTxtEdit::InPlaceDeactivate()
{
	COleObject *pobj;
	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InPlaceDeactivate");
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
			hr = pobj->DeActivateObj();
	}

	return hr;
}

/*
 *	CTxtEdit::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc enter/leave ContextSensitiveHelp mode
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ContextSensitiveHelp(
	BOOL fEnterMode)			//@parm enter/exit mode
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ContextSensitiveHelp");

	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);
		COleObject * pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleWindow *pow;
			hr = pobj->GetIUnknown()->QueryInterface(IID_IOleWindow,
				(void **)&pow);
			if(hr == NOERROR)
			{
				hr = pow->ContextSensitiveHelp(fEnterMode);
				pow->Release();
			}
		}
	}
	return hr;
}

/*
 *	CTxtEdit::GetClipboardData(lpchrg, reco, lplpdataobj)
 *
 *	@mfunc	return an data transfer object for the indicated
 *	range
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::GetClipboardData(
	CHARRANGE *lpchrg, 			//@parm the range of text to use
	DWORD reco,					//@parm operation the data is for
	LPDATAOBJECT *lplpdataobj)	//@parm where to put the data object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClipboardData");

	CCallMgr callmgr(this);
	HRESULT hr;
	LONG cpMin, cpMost;
	CLightDTEngine * pldte = GetDTE();

	//Make sure cpMin and cpMost are within the current text limits.
	//Interpret neg. value for cpMin as the beginning of the text,
	//and neg. value for cpMax as the end of the text.  If a char range
	//is not given use the current selection.
	if(lpchrg)
	{
		LONG cchText = GetTextLength();
		cpMin = max(0, lpchrg->cpMin);
		cpMin = min(cchText, lpchrg->cpMin);
		cpMost = lpchrg->cpMost;
		if(lpchrg->cpMost < 0 || lpchrg->cpMost > cchText)
			cpMost = cchText;
	}
	else
	{
		CTxtSelection * psel = GetSel();
		psel->GetRange(cpMin, cpMost);
	}

	//Make sure this is a valid range.
	if(cpMin >= cpMost)
	{
		*lplpdataobj = NULL;
		return cpMin == cpMost
					? NOERROR
					: ResultFromScode(E_INVALIDARG);
	}

	CTxtRange rg(this, cpMin, cpMin-cpMost);

	//We don't use reco for anything.
	hr = pldte->RangeToDataObject(&rg, SF_RTF, lplpdataobj);

#if !defined(NOFULLDEBUG) && defined(DEBUG)
	if(hr != NOERROR)
		TRACEERRSZSC("GetClipboardData", E_OUTOFMEMORY);
#endif

	return hr;
}

/*
 *	CTxtEdit::ImportDataObject(lpdataobj, cf, hMetaPict)
 *
 *	@mfunc	morally equivalent to paste, but with a data object
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ImportDataObject(
	LPDATAOBJECT lpdataobj,		//@parm Data object to use
	CLIPFORMAT	 cf, 			//@parm Clibpoard format to use
	HGLOBAL		 hMetaPict)		//@parm Metafile to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ImportDataObject");

	CCallMgr		callmgr(this);
	IUndoBuilder *	publdr;
	REPASTESPECIAL	rps = {DVASPECT_CONTENT, NULL};
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	if(hMetaPict)
	{
		rps.dwAspect = DVASPECT_ICON;
		rps.dwParam = (DWORD_PTR) hMetaPict;
	}

	return PasteDataObjectToRange(lpdataobj, GetSel(), cf,
								  &rps, publdr, PDOR_NOQUERY);
}

/*
 *	CTxtEdit::ObjectFromIOB(iob)
 *
 *	@mfunc	Gets an object based on an IOB type index.
 *
 *	@rdesc:
 *		pointer to COleObject or NULL if none.
 */
COleObject * CTxtEdit::ObjectFromIOB(
	LONG iob)
{
	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return NULL;

	COleObject * pobj = NULL;

	// Figure out the index of the selection
	if (iob == REO_IOB_SELECTION)
	{
		CTxtSelection * psel = GetSel();

		pobj = pobjmgr->GetFirstObjectInRange(psel->GetCpMin(),
			psel->GetCpMost());
	}
	else
	{
		// Make sure the IOB is in range
		if(0 <= iob && iob < GetObjectCount())
			pobj = pobjmgr->GetObjectFromIndex(iob);
	}
	return pobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\notmgr.cpp ===
/*
 *	NOTMGR.C
 *
 *	Purpose:
 *		Notification Manager implemenation
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_notmgr.h"

ASSERTDATA

/*
 *	CNotifyMgr::CNotifyMgr ()
 */
CNotifyMgr::CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::CNotifyMgr");

	_pitnlist = NULL;
}

/*
 *	CNotifyMgr::~CNotifyMgr ()
 *
 */
CNotifyMgr::~CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::~CNotifyMgr");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		plist->Zombie();
	}

	TRACEERRSZSC("CNotifyMgr::~CNotifyMgr(): zombie(s) exist", _pitnlist != 0);
}

/*
 *	CNotifyMgr::Add (pITN)
 *
 *	@mfunc
 *		Adds a notification sink to the list
 *
 *	Algorithm:
 *		puts the entry at the *front* of the notification list, so
 *		that high frequency entries (like ranges and text pointers
 *		existing on the stack) can be added and removed efficiently
 */
void CNotifyMgr::Add(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Add");

		pITN->_pnext = _pitnlist;
		_pitnlist = pITN;
}

/*
 *	CNotifyMgr::Remove (pITN)
 *
 *	@mfunc
 *		removes a notification sink from the list
 */
void CNotifyMgr::Remove(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Remove");

	ITxNotify *plist = _pitnlist;
	ITxNotify **ppprev = &_pitnlist;

	while(plist)
	{
		if( plist == pITN )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	}
}

/*
 *	CNotifyMgr::NotifyPreReplaceRange (pITNignore, cp, cchDel, cchNew, cpFormatMin, cpFormatMax, dwFlags)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 */
void CNotifyMgr::NotifyPreReplaceRange(
	ITxNotify *	pITNignore,		//@parm Notification sink to ignore
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPreReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPreReplaceRange( cp, cchDel, cchNew, cpFormatMin, 
				cpFormatMax, pNotifyData );
		}
	}
}

/*
 *	CNotifyMgr::NotifyPostReplaceRange (pITNignore, cp, cchDel, cchNew, cpFormatMin, cpFormatMax, dwFlags)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 *
 *	@comm
 *		pITNignore typically is the TxtPtr/etc that is actually making the
 *		ReplaceRange modification
 */
void CNotifyMgr::NotifyPostReplaceRange(
	ITxNotify *	pITNignore,		//@parm Notification sink to ignore
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPostReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPostReplaceRange( cp, cchDel, cchNew, cpFormatMin,
				cpFormatMax, pNotifyData );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\propchg.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	PROPCHG.CPP	-- Property Change Notification Routines |
 *	
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		9/5/95  ricksa  Created and documented
 *
 *	Documentation is generated straight from the code.  The following
 *	date/time stamp indicates the version of code from which the
 *	the documentation was generated.
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_urlsup.h"

ASSERTDATA

CTxtEdit::FNPPROPCHG CTxtEdit::_fnpPropChg[MAX_PROPERTY_BITS];

/* 
 *	CTxtEdit::UpdateAccelerator()
 *
 *	@mfunc
 *		Get accelerator cp from host
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote:
 *		The point of this is to leave the accelerator offset unchanged
 *		in the face of an error from the host.
 */
HRESULT CTxtEdit::UpdateAccelerator()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::UpdateAccelerator");
	LONG	cpAccel;
	HRESULT hr = _phost->TxGetAcceleratorPos(&cpAccel);

	if(SUCCEEDED(hr))
	{
		// It worked so reset our value
		AssertSz(cpAccel < 32768,
			"CTxtEdit::UpdateAccelerator: cp too large");
		_cpAccelerator = cpAccel;
	}
	return hr;
}

/* 
 *	CTxtEdit::HandleRichToPlainConversion()
 *
 *	@mfunc
 *		Convert a rich text object to a plain text object
 */
void CTxtEdit::HandleRichToPlainConversion()
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::HandleRichToPlainConversion");

	// Notify every interested party that they should dump their formatting
	_nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

	// Set _fRich to false so we can delete the final CRLF.
	_fRich = 0;
	_fSelChangeCharFormat = 0;

	_fPageView = 0;

//	if(_pdetecturl)
//	{
//		delete _pdetecturl;
//		_pdetecturl = NULL;
//	}

	// Tell document to dump its format runs
	_story.DeleteFormatRuns();

	// Clear out the ending CRLF
	CRchTxtPtr rtp(this, 0);
	rtp.ReplaceRange(GetTextLength(), 0, NULL, NULL, -1);

}

/* 
 *	CTxtEdit::OnRichEditChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that rich-text property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT CTxtEdit::OnRichEditChange(
	BOOL fPropertyFlag)		//@parm New state of richedit flag
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnRichEditChange");

	// Calculate length of empty document. Remember that multiline rich text
	// controls always have and end of paragraph marker.
	LONG cchEmptyDoc = cchCR;
	CFreezeDisplay	fd(_pdp);	// defer screen update until we finish the change.

	if(!_fRich)
		cchEmptyDoc = 0;
	else if(_f10Mode)
		cchEmptyDoc = cchCRLF;

	// This can only be changed if there is no text and nothing to undo.
	// It makes no sense to change when there is already text. This is
	// particularly true of going from rich to plain. Further, what would
	// you do with the undo state?
	if(GetTextLength() == cchEmptyDoc && (!_pundo || !_pundo->CanUndo()))
	{
#ifdef DEBUG
		// Make sure that document is in a sensible state.
		if(_fRich)
		{
			CTxtPtr	tp(this, 0);
			WCHAR	szBuf[cchCRLF];

			tp.GetText(cchCRLF, &szBuf[0]);
			AssertSz(szBuf[0] == CR && (!_f10Mode || szBuf[1] == LF),
				"CTxtEdit::OnRichEditChange: invalid document terminator");
		}
#endif // DEBUG

		if(_fRich && !fPropertyFlag)
		{
			// Going from rich text to plain text. Need to dump
			// format runs.
			HandleRichToPlainConversion();
			_fAutoFontSizeAdjust = TRUE;
		}
		else if (!_fRich && fPropertyFlag)
		{
			// Going from plain text to rich text. Need to add the 
			// appropriate EOP at the end of the document.
			SetRichDocEndEOP(0);
			_fAutoFontSizeAdjust = FALSE;
		}
		_fRich = fPropertyFlag;		
		return S_OK;
	}
	return E_FAIL;						// Flag was not updated
}

/* 
 *	CTxtEdit::OnTxMultiLineChange (fMultiline)
 *
 *	@mfunc
 *		Notify text services that the display changed.
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxMultiLineChange(
	BOOL fMultiLine)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxMultiLineChange");

	BOOL fHadSelection = (_psel != NULL);
	CDisplay * pSavedDisplay;
	BOOL fOldShowSelection = FALSE;

	// Remember the old value for show selection
	if (fHadSelection)
		fOldShowSelection = _psel->GetShowSelection();

	// Save the current display away and null it out

	pSavedDisplay = _pdp;
	_pdp = NULL;

	// Attempt to create the new display
	if (fMultiLine)
		_pdp = new CDisplayML(this);
	else
		_pdp = new CDisplaySL(this);
	Assert(_pdp);

	if(!_pdp)
	{
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_OUTOFMEMORY;
	}

	// Attempt to init the new display

	if(pSavedDisplay)
		_pdp->InitFromDisplay(pSavedDisplay);

	if(!_pdp->Init())
	{
		delete _pdp;
		Assert(pSavedDisplay);
		_pdp = pSavedDisplay;
		return E_FAIL;
	}

	// Ok to now kill the old display
	delete pSavedDisplay;

	// Is there are selection?
	if(_psel)
	{
		// Need to tell it there is a new display to talk to.
		_psel->SetDisplay(_pdp);
	}

	// Is this a switch to Single Line? If this is we need to
	// make sure we truncate the text to the first EOP. We wait 
	// till this point to do this check to make sure that everything 
	// is in sync before doing something which potentially affects
	// the display and the selection.
	if(!fMultiLine)
	{
		// Set up for finding an EOP
		CTxtPtr tp(this, 0);

		tp.FindEOP(tomForward);

		// Is there any EOP and text beyond?
		if (tp.GetCp() < GetAdjustedTextLength())
		{
			// FindEOP places the text after the EOP if there
			// is one. Since we want to delete the EOP as well
			// we need to back up to the EOP. 
			tp.BackupCRLF();

			// Sync up the cp's of all the ranges before deleting
			// the text.
			CRchTxtPtr rtp(this, tp.GetCp());

			// Truncate from the EOP to the end of the document
			rtp.ReplaceRange(GetAdjustedTextLength() - tp.GetCp(), 0, NULL, NULL, -1);
		}
	}
	_pdp->UpdateView();
	if(fHadSelection && _fFocus && fOldShowSelection)
		_psel->ShowSelection(TRUE);

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxReadOnlyChange (fReadOnly)
 *
 *	@mfunc
 *		Notify text services that read-only property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxReadOnlyChange(
	BOOL fReadOnly)		//@parm TRUE = read only, FALSE = not read only
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxReadOnlyChange");

	if (fReadOnly)
		_ldte.ReleaseDropTarget();

	_fReadOnly = fReadOnly;					// Cache bit
	return S_OK;
}
		

/* 
 *	CTxtEdit::OnShowAccelerator (fPropertyFlag)
 *
 *	@mfunc
 *		Update accelerator based on change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnShowAccelerator(
	BOOL fPropertyFlag)		//@parm TRUE = show accelerator		
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnShowAccelerator");

	// Get the new accelerator character
	HRESULT hr = UpdateAccelerator();

	// Update the view - we update even in the face of an error return.
	// The point is that errors will be rare (non-existent?) and the update
	// will work even in the face of the error so why bother conditionalizing
	// the execution.
	NeedViewUpdate(TRUE);

	return hr;
}

/* 
 *	CTxtEdit::OnUsePassword (fPropertyFlag)
 *
 *	@mfunc
 *		Update use-password property
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnUsePassword(
	BOOL fPropertyFlag)		//@parm TRUE = use password character
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnUsePassword");

	Assert((DWORD)fPropertyFlag <= 1);			// Be sure it's C boolean

	_fUsePassword = fPropertyFlag;
	_pdp->UpdateView();					// State changed so update view
	
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Notify text services that hide-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxHideSelectionChange");

	// update internal flag if selection is to be hidden
	_fHideSelection = fHideSelection;

	if (!_fFocus)
		OnHideSelectionChange(fHideSelection);
		
	return S_OK;
}

/* 
 *	CTxtEdit::OnHideSelectionChange (fHideSelection)
 *
 *	@mfunc
 *		Performs the actual hide selection.  Helper to OnTxHideSelectionChange
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnHideSelectionChange(
	BOOL fHideSelection)		//@parm TRUE = hide selection
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnHideSelectionChange");

	_fHideSelection = fHideSelection;
	
	CTxtSelection * psel = GetSel();
		 
	if(psel)
	{
		psel->ShowSelection(!fHideSelection);
		// In the case where we don't have focus we don't want to allow the user to display the caret but it's okay
		// to hide the caret.
		if (_fFocus || fHideSelection)
			psel->ShowCaret(!fHideSelection);
	}

	if(!_fInPlaceActive)
	{
		TxInvalidate();				// Since _fInPlaceActive = FALSE,
		TxUpdateWindow();					//  this only tells user.exe to
	}										//  send a WM_PAINT message
	return S_OK;
}


/* 
 *	CTxtEdit::OnSaveSelection (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that save-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnSaveSelection(
	BOOL fPropertyFlag)		//@parm TRUE = save selection when inactive
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnSaveSelection");

	return S_OK;
}	

/* 
 *	CTxtEdit::OnAutoWordSel (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that auto-word-selection property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAutoWordSel(
	BOOL fPropertyFlag)		//@parm TRUE = auto word selection on
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAutoWordSel");

	// We call back to the host when we need to know, so we don't bother doing
	// anything in response to this notification.

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxVerticalChange (fVertical)
 *
 *	@mfunc
 *		Notify text services that vertical property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxVerticalChange(
	BOOL fVertical)			//@parm TRUE - text vertically oriented.
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxVerticalChange");

	_fUseAtFont = fVertical;
	
	HandleSetTextFlow(fVertical ? tflowSW : tflowES);
	
	return S_OK;
}

/* 
 *	CTxtEdit::OnClientRectChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that client rectangle changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnClientRectChange(
	BOOL fPropertyFlag)		//@parm Ignored for this property	
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnClientRectChange");

	// It is unclear whether we need to actually do anything for this 
	// notification. Logically, the change of this property is followed
	// closely by some kind of operation which will cause the display
	// cache to be updated anyway. The old code is left here as an 
	// example of what might be done if it turns out we need to do
	// anything. For now, we will simply return S_OK to this notification.
#if 0
	if (_fInPlaceActive)
	{
		RECT rc;

		if(_phost->TxGetClientRect(&rc) == NOERROR)
			_pdp->OnClientRectChange(rc);

		return S_OK;
	}

	return NeedViewUpdate(fPropertyFlag);
#endif // 0

	if(IsInPageView())
		_pdp->Paginate(0, TRUE);

	// With a client rect change we do need to update the caret when
	// we get redrawn even if the basic information did not change.
	_pdp->SetUpdateCaret();

	if (_fInPlaceActive && _pMsgFilter && _pMsgCallBack)
		_pMsgCallBack->NotifyEvents(NE_LAYOUTCHANGE);

	return S_OK;
}

/* 
 *	CTxtEdit::OnCharFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CCharFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed.
 */
HRESULT CTxtEdit::OnCharFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnCharFormatChange");

	CCharFormat CF;
	DWORD		dwMask;

	HRESULT hr = TxGetDefaultCharFormat(&CF, dwMask);
	if(hr == NOERROR)
	{
		DWORD dwMask2 = CFM2_CHARFORMAT;
		WPARAM wparam = SCF_ALL;

		if(!GetAdjustedTextLength())
		{
			dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
			wparam = 0;
		}

		// OnSetCharFormat handles updating the view.
		hr = OnSetCharFormat(wparam, &CF, NULL, dwMask, dwMask2) ? NOERROR : E_FAIL;
	}
	return hr;
}

/* 
 *	CTxtEdit::OnParaFormatChange (fPropertyFlag)
 *
 *	@mfunc
 *		Update default CParaFormat
 *
 *	@rdesc
 *		S_OK - update successfully processed
 */
HRESULT CTxtEdit::OnParaFormatChange(
	BOOL fPropertyFlag)		//@parm Not used
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnParaFormatChange");

	CParaFormat PF;

	HRESULT hr = TxGetDefaultParaFormat(&PF);
	if(hr == NOERROR)
	{
		// OnSetParaFormat handles updating the view.
		hr = OnSetParaFormat(SPF_SETDEFAULT, &PF, NULL, PFM_ALL2, 0)
				? NOERROR : E_FAIL;
	}
#ifdef TABS
	GetTabsCache()->Release(PF._iTabs);
#endif
	return hr;
}

/* 
 *	CTxtEdit::NeedViewUpdate (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that view of data changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::NeedViewUpdate(
	BOOL fPropertyFlag)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::NeedViewUpdate");

	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxBackStyleChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that background style changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnTxBackStyleChange(
	BOOL fPropertyFlag)	//@parm Ignored for this property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnTxBackStyleChange");

	_fTransparent = (TxGetBackStyle() == TXTBACK_TRANSPARENT);
	TxInvalidate();
	return S_OK;
}

/* 
 *	CTxtEdit::OnAllowBeep (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that beep property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnAllowBeep(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnAllowBeep");

	_fAllowBeep = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnMaxLengthChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that max-length property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnMaxLengthChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnMaxLengthChange");

	// Query host for max text length
	DWORD length = CP_INFINITE;
	_phost->TxGetMaxLength(&length);
	_cchTextMost = length;

	return S_OK;
}

/* 
 *	CTxtEdit::OnWordWrapChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that word-wrap property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnWordWrapChange(
	BOOL fPropertyFlag)	//@parm TRUE = do word wrap
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnWordWrapChange");

	_pdp->SetWordWrap(fPropertyFlag);

	// Update was successful so we need the screen updated at some point
	_pdp->UpdateView();
	return S_OK;
}

/* 
 *	CTxtEdit::OnDisableDrag (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services that disable drag property changed
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnDisableDrag(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnDisableDrag");

	_fDisableDrag = fPropertyFlag;
	return S_OK;
}

/* 
 *	CTxtEdit::OnScrollChange (fPropertyFlag)
 *
 *	@mfunc
 *		Notify text services scroll property change
 *
 *	@rdesc
 *		S_OK - Notification successfully processed.
 */
HRESULT	CTxtEdit::OnScrollChange(
	BOOL fPropertyFlag)	//@parm New state of property 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::OnScrollChange");

	// Tell the display that scroll bars for sure need to be updated
	_pdp->SetViewChanged();

	// Tell the display to update itself.
	_pdp->UpdateView();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\objmgr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module objmgr.cpp.  Object manager implementation | manages a
 *          collection of OLE embedded objects 
 *
 *  Author: alexgo 11/5/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_objmgr.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_rtext.h"

ASSERTDATA

//
//	PUBLIC methods
//

/*
 *	CObjectMgr::GetObjectCount
 *
 *	@mfunc	returns the number of embedded objects currently in
 *			the document.
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectCount");

	return _objarray.Count();
}

/*
 *	CObjectMgr::GetLinkCount()
 *
 *	@mfunc	returns the number of embedded objects which are links
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetLinkCount()
{
	LONG count = 0;
	COleObject *pobj;
	LONG i;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetLinkCount");
		
	for(i = 0; i < _objarray.Count(); i++)
	{
		pobj = *_objarray.Elem(i);
		if(pobj && pobj->IsLink())
			count++;
	}
	return count;
}

/*
 *	CObjectMgr::GetObjectFromCp(cp)
 *
 *	@mfunc	fetches an object corresponding to the given cp
 *
 *	@rdesc	the object @ a cp; NULL if nothing found
 *
 *	@comm	the algorithm is a modified binary search.  Since the
 *			"typical" access pattern will be to linearly access the
 *			objects, we used the cached index to guess first.  If
 *			that doesn't work, we resort to a binary search.
 */
COleObject *CObjectMgr::GetObjectFromCp(
	LONG cp)		//@parm cp for the object
{
	COleObject *pobj = NULL;
	LONG i = 0;
	
	// No tracing on this method as it's too noisy.
		
	if(_objarray.Count() > 0)
	{
		if(_lastindex < _objarray.Count())
		{
			pobj = *_objarray.Elem(_lastindex);
			if(pobj && pobj->GetCp() == cp)
				return pobj;
		}
		
		// The quick lookup failed; try a binary search.
		i = FindIndexForCp(cp);

		// Because of the insert at end case, i may be equal 
		// to the count of objects().
		pobj = NULL;
		if(i < _objarray.Count())
			pobj = *_objarray.Elem(i);
	}

	// FindIndex will return a matching or _near_ index.
	// In this case, we only want a matching index
	if(pobj)
	{
		if(pobj->GetCp() != cp)
			pobj = NULL;
		else
		{
			// Set the cached index to be the next one,
			// so that somebody walking through objects in
			// cp order will always get immediate hits.
			_lastindex = i + 1;
		}
	}
	
#ifdef DEBUG
	// Make sure the binary search found the right thing

	for( i = 0 ; i < _objarray.Count();  i++ )
	{
		COleObject *pobj2 = *_objarray.Elem(i);
		if( pobj2 )
		{
			if(*_objarray.Elem(i) == pobj)
			{
				Assert((*_objarray.Elem(i))->GetCp() == cp);
			}
			else
				Assert((*_objarray.Elem(i))->GetCp() != cp);
		}
	}
#endif //DEBUG

	return pobj;
}

/*
 *	CObjectMgr::CountObjects (&cObjects, cp)
 *
 *	@mfunc	Count char counts upto <p cObjects> objects away The direction of
 *			counting is determined by the sign of <p cObjects>. 
 *
 *	@rdesc	Return the signed cch counted and set <p cObjects> to count of
 *			objects actually counted.  If <p cobject> <gt> 0 and cp is at
 *			the last object, no change is made and 0 is returned.
 *
 *	@devnote This is called from TOM, which uses LONGs for cp's (because VB
 *			can't use unsigned quantities)
 */
LONG CObjectMgr::CountObjects (
	LONG&	cObjects,		//@parm Count of objects to get cch for
	LONG	cp)				//@parm cp to start counting from
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjects");

	LONG		iStart, iEnd;
	LONG		iMaxEnd = (LONG)_objarray.Count() - 1;

	if(!cObjects || !_objarray.Count())
	{
		cObjects = 0;
		return 0;
	}

	iStart = (LONG)FindIndexForCp(cp);

	// if we are looking past either end, return 0

	if (iStart > iMaxEnd && cObjects > 0 ||
		iStart == 0 && cObjects < 0 )
	{
		cObjects = 0;
		return 0;
	}

	// If the index that we found is on an object and
	// we are looking forward, it should be skipped.

	if( iStart < (LONG)_objarray.Count() && 
		(LONG)(*_objarray.Elem(iStart))->GetCp() == cp &&
		cObjects > 0)
	{
		iStart++;
	}

	if(cObjects < 0)
	{
		if(-cObjects > iStart)	// Going past the beginning
		{
			iEnd = 0;
			cObjects = -iStart;
		}
		else
			iEnd = iStart + cObjects;
	}
	else
	{
		if(cObjects > iMaxEnd - iStart) //Going past the end
		{
			iEnd = iMaxEnd;
			cObjects = iMaxEnd - iStart + 1;
		}
		else
			iEnd = iStart + cObjects - 1;
	}

	Assert(iEnd >= 0 && iEnd < (LONG)_objarray.Count() );

	return (*_objarray.Elem(iEnd))->GetCp() - cp;
}

/*
 *	CObjectMgr::CountObjectsInRange (cpMin, cpMost)
 *
 *	@mfunc	Count the number of objects in the given range.
 *
 *	@rdesc	Return the number of objects.
 */
LONG CObjectMgr::CountObjectsInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjectsInRange");

	//Get the indexes for the objects at or after cpMin and cpMost
	//respectively.

	return FindIndexForCp(cpMost) - FindIndexForCp(cpMin);
}

/*
 *	CObjectMgr::GetFirstObjectInRange (cpMin, cpMost)
 *
 *	@mfunc	Get the first object in the given range. 
 *
 *	@rdesc	Pointer to first object in range, or NULL if none.
 */
COleObject * CObjectMgr::GetFirstObjectInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetFirstObjectInRange");

	if (cpMin == cpMost)
		// degenerate range no object selected
		return NULL;

	LONG	iLast = (LONG)_objarray.Count() - 1;	// Index for next object
	LONG	iObj = FindIndexForCp(cpMin);			//  at or after cpMin

	//Make sure this is an existing object.
	if(iObj <= iLast)
	{
		//Make sure it is within the range
		COleObject * pObj = *_objarray.Elem(iObj);

		if(pObj && pObj->GetCp() <= cpMost)
			return pObj;
	}
	return NULL;
}

/*
 *	CObjectMgr::GetObjectFromIndex(index)
 *
 *	@mfunc	retrieves the object at the indicated index
 *
 *	@rdesc	a pointer to the object, if found, NULL otherwise
 */
COleObject *CObjectMgr::GetObjectFromIndex(
	LONG index)		//@parm	Index to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectFromIndex");

	if( index < _objarray.Count() )
		return *_objarray.Elem(index);

	return NULL;
}

/*
 *	CObjectMgr::InsertObject(prg, preobj, publdr)
 *
 *	@mfunc	inserts an object at the indicated index.  It is the
 *			caller's responsibility to handle inserting any data
 *			(such as WCH_EMBEDDING) into the text stream.
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::InsertObject(
	CTxtRange *   prg,		//@parm Where object is inserted
	REOBJECT *	  preobj,	//@parm Object to insert
	IUndoBuilder *publdr)	//@parm Undo context
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::InsertObject");

	WCHAR       ch = WCH_EMBEDDING;
	LONG		cp = prg->GetCp();
	HRESULT		hr;
	COleObject *pobj = (COleObject *)(preobj->polesite);

	if(preobj->dwFlags & REO_USEASBACKGROUND)
		publdr = NULL;

	if (prg->ReplaceRange(1, &ch, publdr, SELRR_IGNORE) != 1)	// Insert WCH_EMBEDDING
		return E_FAIL;
	
	// Let the client know what we're up to
	if (_precall)
	{
		hr = _precall->QueryInsertObject(&preobj->clsid, preobj->pstg,
			REO_CP_SELECTION);

		if( hr != NOERROR )
			return hr;
	}

	// Set some stuff up first; since we may make outgoing calls, don't
	// change our internal state yet.
	hr = pobj->InitFromREOBJECT(cp, preobj);
	if( hr != NOERROR )
		return hr;

	hr = RestoreObject(pobj);

	if(preobj->dwFlags & REO_USEASBACKGROUND)
	{
		CTxtEdit *ped = prg->GetPed();
		CDocInfo *pDocInfo = ped->GetDocInfo();
		HDC hdcBitmap = CreateCompatibleDC(W32->GetScreenDC());
		if(hdcBitmap)
		{
			if(pDocInfo->_nFillType == -1)
			{
				SIZEUV size;
				pobj->GetSize(size);
				pDocInfo->_nFillType = 3;
				pDocInfo->_xScale = 100;
				pDocInfo->_yScale = 100;
				pDocInfo->_xExtGoal = TwipsFromHimetric(size.du);
				pDocInfo->_yExtGoal = TwipsFromHimetric(size.dv);
			}
			LONG dxBitmap = ped->_pdp->LXtoDX(pDocInfo->_xExtGoal*pDocInfo->_xScale / 100);
			LONG dyBitmap = ped->_pdp->LYtoDY(pDocInfo->_yExtGoal*pDocInfo->_yScale / 100);
			RECT rc = {0, 0, dxBitmap, dyBitmap};
			HBITMAP hbitmap = CreateCompatibleBitmap(W32->GetScreenDC(), dxBitmap, dyBitmap);

			if(hbitmap)
			{
				HBITMAP hbitmapSave = (HBITMAP)SelectObject(hdcBitmap, hbitmap);
				HBRUSH hbrush = CreateSolidBrush(pDocInfo->_crColor);
				HBRUSH hbrushOld = (HBRUSH)SelectObject(hdcBitmap, hbrush);
				PatBlt(hdcBitmap, 0, 0, dxBitmap, dyBitmap, PATCOPY);
				SelectObject(hdcBitmap, hbrushOld);
				DeleteObject(hbrush);
				OleDraw(pobj->GetIUnknown(), pobj->GetDvaspect(), hdcBitmap, &rc);
				if(pDocInfo->_hBitmapBack)
					DeleteObject(pDocInfo->_hBitmapBack);
				pDocInfo->_hBitmapBack = hbitmap;
				SelectObject(hdcBitmap, hbitmapSave);
			}
			DeleteObject(hdcBitmap);
		}
		prg->Set(prg->GetCp(), 1);
		prg->ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_TRD_CHECK);
	}
	return hr;
}

/*
 *	CObjectMgr::RestoreObject(pobj)
 *
 *	@mfunc	[re-]inserts the given object into the list of objects
 *			in the backing store
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::RestoreObject(
	COleObject *pobj)		//@parm Object to insert
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::RestoreObject");

	COleObject **ppobj = _objarray.Insert(FindIndexForCp(pobj->GetCp()), 1);

	if( ppobj == NULL )
		return E_OUTOFMEMORY;

	*ppobj = pobj;
	pobj->AddRef();

	return NOERROR;
}

/*
 *	CObjectMgr::SetRECallback(precall)
 *
 *	@mfunc	sets the callback interface
 *
 *	@rdesc	void
 */
void CObjectMgr::SetRECallback(
	IRichEditOleCallback *precall) //@parm Callback interface pointer
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetRECallback");

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);

	_precall = precall;

	if( _precall )
		_precall->AddRef();
}

/*
 *	CObjectMgr::SetHostNames(pszApp, pszDoc)
 *
 *	@mfunc	set host names for this edit instance
 *
 *	@rdesc	NOERROR or E_OUTOFMEMORY
 */
HRESULT CObjectMgr::SetHostNames(
	LPWSTR	pszApp,	//@parm app name
	LPWSTR  pszDoc)	//@parm doc name
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetHostNames");
	HRESULT hr = NOERROR;

	if( _pszApp )
	{
		delete _pszApp;
		_pszApp = NULL;
	}
	if( _pszDoc )
	{
		delete _pszDoc;
		_pszDoc = NULL;
	}
	if( pszApp )
	{
		_pszApp = new WCHAR[wcslen(pszApp) + 1];
		if( _pszApp )
			wcscpy(_pszApp, pszApp);
		else
			hr = E_OUTOFMEMORY;
	}
	if( pszDoc )
	{
		_pszDoc = new WCHAR[wcslen(pszDoc) + 1];
		if( _pszDoc )
			wcscpy(_pszDoc, pszDoc);
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

/*
 *	CObjectMgr::CObjectMgr
 *
 *	@mfunc constructor
 */
CObjectMgr::CObjectMgr()
{
	_pobjselect = NULL;
	_pobjactive = NULL;
}

/*
 *	CObjectMgr::~CObjectMgr
 *
 *	@mfunc	destructor
 */
CObjectMgr::~CObjectMgr()
{
	LONG i, count;
	COleObject *pobj;

 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::~CObjectMgr");

	count = _objarray.Count();

	for( i = 0; i < count; i++ )
	{
		pobj = *_objarray.Elem(i);
		// We NULL stuff here to try to protect ourselves
		// better in re-entrancy cases.
		*_objarray.Elem(i) = NULL;
		if( pobj )
		{
			pobj->Close(OLECLOSE_NOSAVE);
  			pobj->MakeZombie();
    		SafeReleaseAndNULL((IUnknown**)&pobj);
		}
	}

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);
		
	if( _pszApp )
		delete _pszApp;

	if( _pszDoc )
		delete _pszDoc;
}

/*
 *	CObjectMgr::ReplaceRange (cp, cchDel, publdr)
 *
 *	@mfunc	handles the deletion of objects from a given range.  This
 *			method _must_ be called before any floating range notifications
 *			are sent.
 */
void CObjectMgr::ReplaceRange(
	LONG cp,				//@parm cp starting the deletion
	LONG cchDel,			//@parm Count of characters deleted
	IUndoBuilder *publdr)	//@parm Undo builder for this actions
{
	LONG	i;
	LONG	iDel = -1, 
			cDel = 0;	// index at which to delete && number of objects
						// to delete.
	COleObject *pobj;

	// nothing deleted, don't bother doing anything.
	if( !cchDel )
		return;

	// Basically, we loop through all of the objects within the
	// range of deleted text and ask them to delete themselves.
	// We remember the range of objects deleted (the starting index
	// and # of objects deleted) so that we can remove them from
	// the array all at once.

	i = FindIndexForCp(cp);

	while( i < _objarray.Count() )
	{
		pobj = *_objarray.Elem(i);
		if( pobj && pobj->GetCp() >= cp)
		{
			if( pobj->GetCp() < (cp + cchDel) )
			{
				if( _pobjactive == pobj )
				{
					// Deactivate the object just to be on the safe side.
					_pobjactive->DeActivateObj();
					_pobjactive = NULL;
				}

				if(iDel == -1)
					iDel = i;

				cDel++;
				if (_precall)
				{
					IOleObject *poo;
					if (pobj->GetIUnknown()->QueryInterface(IID_IOleObject,
						(void **)&poo) == NOERROR)
					{
						_precall->DeleteObject(poo);
						poo->Release();
					}
				}

				// if the object was selected, then it obviously
				// can't be anymore!
				if( _pobjselect == pobj )
				{
					_pobjselect = NULL;
				}

				pobj->Delete(publdr);
				*_objarray.Elem(i) = NULL;
				pobj->Release();
			}
			else
				break;
		}
		i++;
	}
	if(cDel)
		_objarray.Remove(iDel, cDel);
	return;
}


//
//	PRIVATE methods
//

/*
 *	CObjectMgr::FindIndexForCp(cp)
 *
 *	@mfunc	does a binary search to find the index at which an object
 *			at the given cp exists or should be inserted.
 *
 *	@rdesc	LONG, an index
 */
LONG CObjectMgr::FindIndexForCp(
	LONG cp)
{
	LONG l, r;
	COleObject *pobj = NULL;
	LONG i = 0;
		
	l = 0; 
	r = _objarray.Count() - 1;
	
	while( r >= l )
	{
		i = (l + r)/2;
		pobj = *_objarray.Elem(i);
		if( !pobj )
		{
			TRACEWARNSZ("null entry in object table.  Recovering...");
			for( i = 0 ; i < _objarray.Count() -1; i++ )
			{
				pobj = *_objarray.Elem(i);
				if( pobj && pobj->GetCp() >= cp )
					return i;
			}
			return i;
		}
		if( pobj->GetCp() == cp )
			return i;

		else if( pobj->GetCp() < cp )
			l = i + 1;

		else
			r = i - 1;
	}

	// Yikes! nothing was found.  Fixup i so that
	// it points to the correct index for insertion.

	Assert(pobj || (!pobj && i == 0));

	if(pobj)
	{
		Assert(pobj->GetCp() != cp);
		if( pobj->GetCp() < cp )
			i++;
	}
	return i;
}
						
/*
 *	CObjectMgr::HandleDoubleClick(ped, &pt, flags)
 *	
 *	@mfunc		Handles a double click message, potentially activating
 *				an object.
 *
 *	@rdesc		BOOL-- TRUE if double click-processing is completely
 *				finished.
 */
BOOL CObjectMgr::HandleDoubleClick(
	CTxtEdit *ped,	//@parm edit context
	const POINTUV &pt,//@parm point of click (WM_LBUTTONDBLCLK wparam)
	DWORD flags)	//@parm flags (lparam)
{
	LONG cp;
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, 
						"CObjectMgr::HandleDoubleClick");

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobj = GetObjectFromCp(cp);

	if (!pobj)
		return FALSE;

	if (_pobjactive != pobj)
	{
		//Deactivate currently active object if any.
		if (_pobjactive)
			_pobjactive->DeActivateObj();

#ifndef NOINKOBJECT
		if (pobj->IsInkObject())
		{
			if (pobj->_pILineInfo)
			{
				CTxtSelection *	psel = ped->GetSel();

				if (psel && psel->GetCch() == 1)	// Only handle single Ink object being selected
				{
					BSTR		bstr = NULL;
					UINT		icch;
					HRESULT		hr = E_FAIL;
					ILineInfo	*pLineInfo = pobj->_pILineInfo;

					pLineInfo->AddRef();
					hr = pLineInfo->TopCandidates(0, &bstr, &icch, 1, 0);

					if (SUCCEEDED(hr) && bstr)
						psel->TypeText(bstr);

					if (bstr)
						SysFreeString(bstr);
					pLineInfo->Release();
				}
			}
			return TRUE;
		}
		else
#endif	// NOINKOBJECT
		{
			POINT ptxy;
			ped->_pdp->PointFromPointuv(ptxy, pt);
			return pobj->ActivateObj(WM_LBUTTONDBLCLK, flags, MAKELONG(ptxy.x, ptxy.y));
		}
	}
	return TRUE;
}

/*
 *	CObjectMgr::HandleClick(ped, &pt)
 *	
 *	@mfunc
 *		The position of the caret is changing.  We need to
 *		Deactivate the active object, if any.  If the change is
 *		because of a mouse click and there is an object at this
 *		cp, we set a new individually selected object. Otherwise
 *		we set the individually selected object to NULL.
 *
 *	@rdesc	returns TRUE if this method set the selection.  Otherwise,
 *		returns FALSE;
 */
ClickStatus CObjectMgr::HandleClick(
	CTxtEdit *ped,	//@parm the edit context
	const POINTUV &pt)//@parm the point of the mouse click 
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleClick");

	COleObject *	pobjnew;//, * pobjold;
	CTxtSelection * psel;
	LONG			cp;
	LONG			cpMin, cpMost;
	
	if( _pobjactive )
	{
		_pobjactive->DeActivateObj();
		return CLICK_OBJDEACTIVATED;
	}

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobjnew = GetObjectFromCp(cp);

	//If we clicked on an object, set the selection to this object.
	//CTxtSelection::UpdateSelection will be called as a result of this
	//and will determine the highlighting.
	if(pobjnew)
	{
		cp = pobjnew->GetCp();
		psel = ped->GetSel();
		if (psel->GetRange(cpMin, cpMost) > 1 && cpMin <= cp && cp <= cpMost)
		{
			// There is more than one character in the selection
			// And the object is part of the selection.
			// Do not change the selection
			return CLICK_SHOULDDRAG;
		}
		
		// don't reset the selection if the object is already selected
		if( pobjnew != _pobjselect )
		{
			// Freeze the Display while we handle this click
			CFreezeDisplay fd(ped->_pdp);

			psel->SetSelection(cp, cp+1);
			if (GetSingleSelect())
			{
				// Note thate the call to SetSelection may have set selected object to NULL !!!!
				// This can happen in some strange scenarios where our state is out of whack
				AssertSz(GetSingleSelect() == pobjnew, "Object NOT Selected!!");
				return CLICK_OBJSELECTED;
			}
			return CLICK_IGNORED;
		}
		return CLICK_OBJSELECTED;
	}
	return CLICK_IGNORED;
}

/*
 *	CObjectMgr::HandleSingleSelect(ped, cp, fHiLite)
 *	
 *	@mfunc
 *		When an object is selected and it is the only thing selected, we do
 *		not highlight it by inverting it.  We Draw a frame and handles around
 *		it.  This function is called either because an object has been
 *		selected and it is the only thing selected, or because we need to
 *		check for an object that used to be in this state but may no longer be.
 */
void CObjectMgr::HandleSingleSelect(
	CTxtEdit *ped,		//@parm edit context
	LONG	  cp,		//@parm cp of object
	BOOL	  fHiLite)	//@parm is this a call for hding the selection
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleSingleSelect");

	COleObject* pobjnew = GetObjectFromCp(cp);

	//This should only be called when we know we have a singley selected
	//object.  However, there are boundary cases (such as inserting an object)
	//where WCH_EMBEDDING is the backing store yet no object exists.  These
	//cases are OK; thus, we check for NULL on pobjnew.
	
	if(pobjnew)
	{
		//The object is the same as the currently selected object (if any)
		//we are deselecting it.  This works like a toggle unless state is messed up.
		//If the object is different, we are replacing the current selected
		//object (if any).
		if(!fHiLite && _pobjselect)
		{
			// This covers _pobjselct == pobjnew  Normal case
			//  and _pobjselect != pobjnew  Degenerate case.
			_pobjselect->SetREOSELECTED(FALSE);
			_pobjselect = NULL;

			//Remove frame/handles from currently selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1, NULL);
		}
		else if(fHiLite && pobjnew != _pobjselect)
		{
			// Only do this if we are setting a new selection.
			_pobjselect = pobjnew;
			_pobjselect->SetREOSELECTED(TRUE);

			//Draw frame/handles on newly selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1, NULL);
		}
		else
		{
			// We want to hilite the selection but the object is already selected.
			// Or we want to undo hilite on the selection but the selected object is NULL.
			// Do nothing.
		}
	}
}


/*
 *	CObjectMgr::ActivateObjectsAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT CObjectMgr::ActivateObjectsAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CObjectMgr::ActivateObjectsAs");

	COleObject * pobj;
	HRESULT hr, hrLatest;

	// Tell the system to treat all rclsid objects as rclsidAs
	hr = CoTreatAsClass(rclsid, rclsidAs);
	if( hr != NOERROR )
		return hr;

	LONG cobj = GetObjectCount();

	// Go through objects, letting them decide if
	// they have anything to do for this.
	for (LONG iobj = 0; iobj < cobj; iobj++)
	{
		pobj = GetObjectFromIndex(iobj);
		hrLatest = pobj->ActivateAs(rclsid, rclsidAs);
		// Make hr the latest hresult unless we have previously had an error.
		if(hr == NOERROR)
			hr = hrLatest;
	}
	return hr;
}

#ifdef DEBUG
void CObjectMgr::DbgDump(void)
{
	Tracef(TRCSEVNONE, "Object Manager %d objects", _objarray.Count());

	for(LONG i = 0 ; i < _objarray.Count();  i++)
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->DbgDump(i);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\ols.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLS.CPP -- COls LineServices object class
 *	
 *	Authors:
 *		Murray Sargent: initial coding up to nonLS RichEdit functionality
 *			(with lots of help from RickSa's ols code)
 *		Keith Curtis and Worachai Chaoweeraprasit: complex script support,
 *			etc.
 *
 *	@todo
 *		LSCHP.dcpMaxContext is never set for complex scripts!
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#ifndef NOLINESERVICES

#include "_edit.h"
#include "_font.h"
#include "_render.h"
#include "_osdc.h"
#include "_tomfmt.h"
#include "_ols.h"
#include "_clasfyc.h"
#include "_uspi.h"
#include "_txtbrk.h"
#include "_hyph.h"

ASSERTDATA

// Guess at the number of characters on the line
const int cchLineHint = 66;

#define OBJID_OLE			0
#define OBJID_REVERSE		1
#define	OBJID_COUNT			2

const WCHAR wchObjectEnd = 0x9F;
const WCHAR rgchObjectEnd[]	= {wchObjectEnd};

#define	MAX_OBJ_DEPTH		3

extern const LSCBK lscbk;

// Kinsoku break pair information
extern const INT g_cKinsokuCategories;

CLineServices *g_plsc = NULL;		// LineServices Context
COls*		   g_pols = NULL;		// COls ptr

const LSBRK rglsbrkDefault[] =
{
	0,0,	// Always prohibited
	0,1,	// OK across blanks
	1,1		// Always allowed
};

// prototypes
void 	EmitBrace(COls* pols, PLSCHP pchp, BOOL* pfHid, DWORD* pcch, PLSRUN* pprun, LPCWSTR* plpwch, int id, LPCWSTR str);
void	DupShapeState(PLSRUN prun, LONG cch);


// public inline functions
//

// Emitting fake brace to LS
inline void EmitBrace(
	COls*		pols,
	PLSCHP		pchp,
	BOOL*		pfHid,
	DWORD*		pcch,
	PLSRUN*		pprun,
	LPCWSTR*	plpwch,
	int			id,
	LPCWSTR		str)
{
	ZeroMemory(pchp, sizeof(*pchp));								
	pchp->idObj = (WORD)id;												
	*pfHid 		= 0;												
	*pcch 		= 1;												
	*pprun 		= pols->GetPlsrun(0, pols->_pme->GetCF(), FALSE);
	*plpwch		= str;												
}

#ifndef NOCOMPLEXSCRIPTS
// Duplicate shaping state to each runs in the chain
// note: this macro used only by GetGlyph and GetGlyphPosition
inline void DupShapeState(
	PLSRUN		prun,
	LONG		cch)
{
	PLSRUN	pnext = prun->_pNext;										
	LONG	cpEnd = prun->_cp + cch;									
	while (pnext && pnext->_cp < cpEnd)
	{
		CopyMemory(&pnext->_a, &prun->_a, sizeof(SCRIPT_ANALYSIS));
		pnext->SetFallback(prun->IsFallback());
		prun = pnext;
		pnext = prun->_pNext;
	}																
	Assert(!pnext && prun->_cp < cpEnd);
}
#endif




LONG COls::GetCpLsFromCpRe(
	LONG cpRe)
{
	if (_rgcp.Count() == 0)
		return cpRe;

	LONG *pcp = _rgcp.Elem(0);

	for(LONG cpLs = cpRe; cpLs >= *pcp; pcp++)
		 cpLs++;

	return cpLs;
}

LONG COls::GetCpReFromCpLs(
	LONG cpLs)
{
	if (_rgcp.Count() == 0)
		return cpLs;

	LONG *pcp = _rgcp.Elem(0);

	for(int dcp = 0; cpLs > *pcp; pcp++)
		dcp--;

	return cpLs + dcp;
}

#ifdef DEBUG
//#define DEBUG_BRACE
#endif
// return TRUE if braces added
BOOL COls::AddBraceCp(long cpLs)
{
	if (_rgcp.Count() == 0)
	{
		long *pcp = _rgcp.Insert(0, 1);
		*pcp = tomForward;
	}

	long *pcp = _rgcp.Elem(0);
	long iel = 0;

	while (cpLs > pcp[iel])
		iel++;

	if (cpLs < pcp[iel])
	{
		pcp = _rgcp.Insert(iel, 1);
		*pcp = cpLs;
		return TRUE;
	}
	return FALSE;
}

// return number of braces before cp
//
LONG COls::BracesBeforeCp(
	LONG cpLs)
{
	LONG 	iel, cbr = 0;
	LONG*	pcp;

	if (!cpLs || (iel = _rgcp.Count()) < 2)
		return 0;

	iel -= 2;		// exclude the last tomForward one and make a count an index
	cpLs--;			// start with the cp preceding given cp

	pcp = _rgcp.Elem(0);

	while (iel > -1 && pcp[iel] > cpLs)		// search the first one
		iel--;

	while (iel > -1 && pcp[iel] == cpLs)	// continue counting
	{
		iel--;
		cpLs--;
		cbr++;
	}
	return cbr;
}

/*
 * 	COls::SetRun(plsrun)
 *
 *	@mfunc
 *		Do whatever is needed to initialize the measurer (pme) to the lsrun
 *		givin by plsrun and return whether the run is for autonumbering.
 *
 *	@rdesc
 *		TRUE if plsrun refers to an autonumbering run
 */
BOOL COls::SetRun(
	PLSRUN plsrun)
{
	LONG cp = plsrun->_cp;
	_pme->SetCp(cp & 0x7FFFFFFF);
	return plsrun->IsBullet();
}

/*
 * 	CLsrun::IsSelected()
 *
 *	@mfunc
 *		return whether or not the run should be drawn as selected.
 *
 *	@rdesc
 *		TRUE if run should be drawn with selection colors
 */
BOOL CLsrun::IsSelected()
{
	if (!_fSelected)
		return FALSE;
	CRenderer *pre = g_pols->GetRenderer();
	Assert(pre->IsRenderer());
	return pre->_fRenderSelection ? TRUE : FALSE;
}

/*
 * 	COls::CreatePlsrun ()
 *
 *	@mfunc
 *		Creates a PLSRUN. Is a little tricky because we allocate them
 *		in chunks.
 *
 *	@rdesc
 *		plsrun
 */
const int cplsrunAlloc = 8;
PLSRUN COls::CreatePlsrun()
{
	CLsrunChunk *plsrunChunk = 0;
	
	//First, find a chunk to use
	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; cchunk && ichunk < cchunk; ichunk++)
	{
		plsrunChunk = _rglsrunChunk.Elem(ichunk);
		if (plsrunChunk->_cel < cplsrunAlloc)
			break;
	}	

	if (!cchunk || ichunk == cchunk || plsrunChunk->_cel == cplsrunAlloc)
	{
		CLsrun *rglsrun = new CLsrun[cplsrunAlloc];
		if (rglsrun)
		{
			plsrunChunk = _rglsrunChunk.Add(1, 0);
			if (!plsrunChunk)
			{
				delete[] rglsrun;
				return 0;
			}
			plsrunChunk->_prglsrun = rglsrun;
		}
		else
			return 0;
	}
	return &plsrunChunk->_prglsrun[plsrunChunk->_cel++];
}

/*
 * 	GetPlsrun(cp, pCF, fAutoNumber)
 *
 *	@func
 *		Return plsrun for info in run. The structure contains the starting cp
 * 		of the run and the script analysis if Uniscribe is activated. The
 *		analysis information is needed by subsequent callbacks - GetGlyphs and
 *		GetGlyphPositions to be passed to Uniscribe in order to shape and
 *		position glyphs correctly for complex scripts.
 *
 *	@rdesc
 *		plsrun corresponding to info in arguments
 */
PLSRUN COls::GetPlsrun(
	LONG 		cp,
	const CCharFormat *pCF,
	BOOL 		fAutoNumber)
{
	if(fAutoNumber)
		cp |= CP_BULLET;

	CLsrun *plsrun = CreatePlsrun();

	if (plsrun)
	{
		ZeroMemory(plsrun, sizeof(CLsrun));

		plsrun->_pCF = pCF;
		plsrun->_cp = fAutoNumber ? _cp | CP_BULLET : cp;

		LONG 	cpSelMin, cpSelMost;
		_pme->GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		plsrun->SetSelected(!plsrun->IsBullet() && cp >= cpSelMin && cp < cpSelMost);

#ifndef NOCOMPLEXSCRIPTS
		if (pCF->_wScript && !_pme->GetPasswordChar())
		{
			CUniscribe*	pusp = _pme->Getusp();
			Assert(pusp);
			const SCRIPT_PROPERTIES* psp = pusp->GeteProp(pCF->_wScript);

			plsrun->_a.eScript = pCF->_wScript < SCRIPT_MAX_COUNT ? pCF->_wScript : 0;
			plsrun->_a.fRTL  = !psp->fNumeric && (IsBiDiCharRep(pCF->_iCharRep) || IsBiDiCharSet(psp->bCharSet));
			plsrun->_a.fLogicalOrder = TRUE;
		}
#endif
	}
	return plsrun;
}

/*
 *	COls::~COls()
 *
 *	@mfunc
 *		Destructor
 */
COls::~COls()
{
	for (int ichunk = 0, cchunk = _rglsrunChunk.Count(); ichunk < cchunk; ichunk++)
		delete []_rglsrunChunk.Elem(ichunk)->_prglsrun;
	DestroyLine(NULL);
	if (g_plsc)
		LsDestroyContext(g_plsc);
}


/*
 *	COls::Init(pme)
 *
 *	@mfunc
 *		Initialize this LineServices object
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR : E_FAIL
 */
HRESULT COls::Init(
	CMeasurer *pme)
{
	_pme = pme;

	if(g_plsc)
		return NOERROR;

	// Build LS context to create
	LSCONTEXTINFO lsctxinf;

	// Setup object handlers
	LSIMETHODS vlsctxinf[OBJID_COUNT];
	vlsctxinf[OBJID_OLE] = vlsimethodsOle;
	if(LsGetReverseLsimethods(&vlsctxinf[OBJID_REVERSE]) != lserrNone)
		return E_FAIL;

	lsctxinf.cInstalledHandlers = OBJID_COUNT;
    lsctxinf.pInstalledHandlers = &vlsctxinf[0];

	// Set default and all other characters to 0xFFFF
    memset(&lsctxinf.lstxtcfg, 0xFF, sizeof(lsctxinf.lstxtcfg));

	lsctxinf.fDontReleaseRuns = TRUE;
	lsctxinf.lstxtcfg.cEstimatedCharsPerLine = cchLineHint;

	// Set the characters we handle
	// FUTURE (keithcu) Support more characters in RE 4.0.
	lsctxinf.lstxtcfg.wchNull			= 0;

	lsctxinf.lstxtcfg.wchSpace			= ' ';
	lsctxinf.lstxtcfg.wchNonBreakSpace	= NBSPACE;

	lsctxinf.lstxtcfg.wchNonBreakHyphen = NBHYPHEN;
	lsctxinf.lstxtcfg.wchNonReqHyphen	= SOFTHYPHEN;
	lsctxinf.lstxtcfg.wchHyphen			= '-';

	lsctxinf.lstxtcfg.wchEmDash			= EMDASH;
	lsctxinf.lstxtcfg.wchEnDash			= ENDASH;

	lsctxinf.lstxtcfg.wchEmSpace		= EMSPACE;
	lsctxinf.lstxtcfg.wchEnSpace		= ENSPACE;
	
	lsctxinf.lstxtcfg.wchTab			= '\t';
	lsctxinf.lstxtcfg.wchEndLineInPara	= '\v';
	lsctxinf.lstxtcfg.wchEndPara1		= '\r';
	lsctxinf.lstxtcfg.wchEndPara2		= '\n';

	lsctxinf.lstxtcfg.wchVisiAltEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndLineInPara = ' ';
	

	// Auto number escape character
	lsctxinf.lstxtcfg.wchEscAnmRun = wchObjectEnd;

    lsctxinf.pols = this;
    lsctxinf.lscbk = lscbk;

	if(LsCreateContext(&lsctxinf, &g_plsc) != lserrNone)
		return E_FAIL;

	//REVIEW (keithcu) Quill seems to have a more mature kinsoku
	//table. For example, we don't allow breaking across space between
	//a word and the ending punctuation. French people want this behavior.
	BYTE  rgbrkpairsKinsoku[cKinsokuCategories][cKinsokuCategories];
	BYTE *prgbrkpairsKinsoku = &rgbrkpairsKinsoku[0][0];
	LCID lcid = pme->GetCF()->_lcid;
	for(LONG i = 0; i < cKinsokuCategories; i++)
	{
		for(LONG j = 0; j < cKinsokuCategories; j++)
		{
			LONG iBreak = 2*CanBreak(i, j);
			// If don't break, allow break across blanks unless first
			// char is open brace or second char is close brace
			if (!iBreak &&				
				GetKinsokuClass(i, 0xFFFF, lcid) != brkclsOpen &&
				GetKinsokuClass(j, 0xFFFF, lcid) != brkclsOpen)
			{
				iBreak = 1;
			}
			*prgbrkpairsKinsoku++ = iBreak;
		}
	}
	if(g_plsc->SetBreaking(ARRAY_SIZE(rglsbrkDefault), rglsbrkDefault,
					 cKinsokuCategories, &rgbrkpairsKinsoku[0][0]) != lserrNone)
	{
		return E_FAIL;
	}

	return NOERROR;
}

/*
 * 	COls::QueryLineInfo(&lslinfo, pupStart, pdupWidth)
 *
 *	@mfunc
 *		Wrapper for LsQueryLineDup which is not called with full-justified
 *		text because it's slow.
 */
void COls::QueryLineInfo(
	LSLINFO &lslinfo, 
	LONG *	 pupStart, 
	LONG *	 pdupWidth)
{
	const CParaFormat *pPF = _pme->Get_pPF();

	if (!lslinfo.fForcedBreak && /* lslinfo.endr <= endrHyphenated && */
		pPF->_bAlignment == PFA_FULL_INTERWORD && _pme->_pdp->GetWordWrap() &&
		pPF->_dxStartIndent == 0 && pPF->_dxOffset == 0 && pPF->_wNumbering == 0)
	{
		*pupStart = 0;
		*pdupWidth = _pme->LUtoDU(_pme->_dulLayout);
	}
	else
	{
		LONG upJunk, upStartTrailing;
		LsQueryLineDup(_plsline, &upJunk, &upJunk, pupStart, &upStartTrailing, &upJunk);
		*pdupWidth = upStartTrailing - *pupStart;
	}
}

/*
 * 	COls::MeasureLine(pliTarget)
 *
 *	@mfunc
 *		Wrapper for LsCreateLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::MeasureLine(
	CLine *	pliTarget)		//@parm Returns target-device line metrics (optional)
{
	CMeasurer *pme = _pme;
	const CDisplay *pdp = pme->_pdp;
	
	LONG cp = pme->GetCp();
#ifdef DEBUG
	LONG cchText = pme->GetTextLength();	// For DEBUG...
	AssertSz(cp < cchText || !pme->IsRich() && cp == cchText, "COls::Measure: trying to measure past EOD");
#endif
	DestroyLine(NULL);

	_cp = cp;
	_pdp = pdp;
	pme->SetUseTargetDevice(FALSE);

	LSDEVRES lsdevres;
	if (IsUVerticalTflow(pme->GetTflow()))
	{
		lsdevres.dxpInch = pme->_dvpInch;
		lsdevres.dypInch = pme->_dupInch;
		lsdevres.dxrInch = pme->_dvrInch;
		lsdevres.dyrInch = pme->_durInch;
	}
	else
	{
		lsdevres.dxpInch = pme->_dupInch;
		lsdevres.dypInch = pme->_dvpInch;
		lsdevres.dxrInch = pme->_durInch;
		lsdevres.dyrInch = pme->_dvrInch;
	}

	g_plsc->SetDoc(TRUE, lsdevres.dyrInch == lsdevres.dypInch &&
					lsdevres.dxrInch == lsdevres.dxpInch, &lsdevres);

	DWORD cBreakRecOut;
	LSLINFO	 lslinfo;
	BREAKREC rgBreak[MAX_OBJ_DEPTH];

	//If the first character on the line is a wrapping OLE object, add it to the
	//the layout queue.
	{
		COleObject *pobj = pme->GetObjectFromCp(cp);
		if(pobj && pobj->FWrapTextAround())
			pme->AddObjectToQueue(pobj);
	}

	LONG dulLayout = pme->_dulLayout;

	if(!pdp->GetWordWrap())
	{
		dulLayout = pme->DUtoLU(pdp->GetDupView());
		const LONG *pl = pme->GetPF()->GetTabs();
		if(pl && GetTabPos(*pl) > dulLayout)// Fix for Access big TAB 7963
			dulLayout *= 4;					// dulLayout has to be larger
	}										//  than TAB
	
	dulLayout = max(dulLayout, 0);

	LSERR lserr = g_plsc->CreateLine(cp, dulLayout, NULL, 0, MAX_OBJ_DEPTH, rgBreak,
						 &cBreakRecOut, &lslinfo, &_plsline);

	//Line Services doesn't put the autonumbering dimensions into the line,
	//so we have to do it ourselves.
	lslinfo.dvpAscent = max(lslinfo.dvpAscent, lslinfo.dvpAscentAutoNumber);
	lslinfo.dvpDescent = max(lslinfo.dvpDescent, lslinfo.dvpDescentAutoNumber);

	pme->SetUseTargetDevice(FALSE);

	lslinfo.cpLim = GetCpReFromCpLs(lslinfo.cpLim);

	if (lserr != lserrNone)
	{
		AssertSz(lserr == lserrOutOfMemory, "Line format failed for invalid reason");
		pme->GetPed()->GetCallMgr()->SetOutOfMemory();
		return FALSE;
	}

	if(!pme->IsRenderer())
	{
		// Save some LineServices results in the measurer's CLine
		pme->_li._cch = lslinfo.cpLim - cp;
		AssertSz(pme->_li._cch > 0,	"no cps on line");

		LONG upStart, dupWidth;
		// Query for line width and indent.
		QueryLineInfo(lslinfo, &upStart, &dupWidth);
		pme->_li._upStart = upStart;
		pme->_li._dup = dupWidth;

		if(pme->IsRich())
		{
			pme->_li._dvpHeight  = lslinfo.dvpAscent + lslinfo.dvpDescent;
			pme->_li._dvpDescent = lslinfo.dvpDescent;
		}
		else
			pme->CheckLineHeight();				// Use default heights

		pme->_li._cchEOP = 0;

		pme->SetCp(lslinfo.cpLim);
		if(pme->_rpTX.IsAfterEOP())				// Line ends with an EOP
		{										// Store cch of EOP (1 or 2)
			pme->_rpTX.BackupCRLF(FALSE);
			UINT ch = pme->GetChar();
			if(ch == CR || pme->GetPed()->fUseCRLF() && ch == LF || ch == CELL)
				pme->_li._fHasEOP = TRUE;
			pme->_li._cchEOP = pme->_rpTX.AdvanceCRLF(FALSE);
		}
		if (lslinfo.cpLim > pme->GetTextLength() &&
			(!pme->IsRich() || pme->IsHidden()))
		{
			Assert(lslinfo.cpLim == pme->GetTextLength() + 1);
			pme->_li._cch--;
		}
		else
			pme->AdjustLineHeight();

		pme->UpdateWrapState(pme->_li._dvpHeight, pme->_li._dvpDescent);
	}

	//Setup pliTarget if caller requests it
	if (pliTarget)
	{
		CLine liSave = pme->_li;
		pme->_li._dvpHeight = max(lslinfo.dvrAscent, lslinfo.dvrAscentAutoNumber) +
							max(lslinfo.dvrDescent, lslinfo.dvrDescentAutoNumber);
		pme->_li._dvpDescent = lslinfo.dvrDescent;
		pme->SetUseTargetDevice(TRUE);
		pme->AdjustLineHeight();
		pme->SetUseTargetDevice(FALSE);
		*pliTarget = pme->_li;
		pme->_li = liSave;
	}
	return TRUE;
}

/*
 * 	COls::RenderLine(&li, fLastLine)
 *
 *	@mfunc
 *		Wrapper for LsDisplayLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::RenderLine(
	CLine &	li,				//@parm Line to render
	BOOL	fLastLine)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::RenderLine");

	LONG		cp = _pme->GetCp();
	CRenderer	*pre = GetRenderer();
	Assert(pre->_fRenderer);

	pre->SetNumber(li._bNumber);
	pre->NewLine(li);
	if(li._fCollapsed)				// Line is collapsed in Outline mode
	{
		pre->Move(li._cch);			// Bypass line
		return TRUE;				// Let dispml continue with next line
	}

	CreateOrGetLine();
	if(!_plsline)
		return FALSE;

	pre->SetCp(cp);						// Back to beginning of line
	pre->Check_pccs(FALSE);
	pre->_li._upStart = 0;
	Assert(pre->_fTarget == FALSE);

	LONG cpSelMin, cpSelMost;
	LONG dup, dvp;
	HDC hdcSave = pre->StartLine(li, fLastLine, cpSelMin, cpSelMost, dup, dvp);

	POINTUV pt = pre->GetCurPoint();			// Must follow offscreen setup
	POINT	ptStart;							//  since _ptCur, _rc change
	RECTUV  rcuv = pre->GetClipRect();

	pt.u += pre->XFromU(0);
	pt.v += li._dvpHeight - li._dvpDescent;
	memcpy(&ptStart, &pt, sizeof(ptStart));

	RECT rc;
	pre->GetPdp()->RectFromRectuv(rc, rcuv);
	LSERR lserr = LsDisplayLine(_plsline, &ptStart, pre->GetPdp()->IsMain() ? ETO_CLIPPED : 0, &rc);

	AssertSz(lserr == lserrNone, "COls::RenderLine: error in rendering line");

	pre->EndLine(hdcSave, dup, dvp);
	pre->SetCp(cp + li._cch);

	return lserr == lserrNone;
}

/*
 * 	COls::CreateOrGetLine()
 *
 *	@mfunc
 *		If _plsline is nonNull and _cp equals _pme->GetCp(), return.  Else
 *		create line with caching so that _plsline and _cp are correct for
 *		current line
 */
void COls::CreateOrGetLine()
{
	if(_plsline && _pme->GetCp() == _cp && _pme->_pdp == _pdp)
		return;

	MeasureLine(NULL);		// Define new _plsline
}

/*
 * 	COls::MeasureText(cch, taMode, pdispdim)
 *
 *	@mfunc
 *		Gets x offset to cp given by CMeasurer _pme + cch chars along with
 *		display dimensions.
 *
 *	@rdesc
 *		xwidth measured
 */
LONG COls::MeasureText(
	LONG	 cch,			//(IN): Max cch to measure
	UINT	 taMode,		//(IN): requested coordinate
	CDispDim *pdispdim)		//(OUT): display dimensions
{
	CMeasurer *	pme = _pme;				
	LONG		cp = pme->GetCp() + cch;	// Enter with me at start of line
	POINT		pt;							// Point at cp in client coords
	BOOL		fAtLogicalRightEdge = FALSE;

	CreateOrGetLine();
	if(!_plsline)
		return 0;
	Assert(pme->_fTarget == FALSE);

	// Query point from cp
	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

    memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLineCpPpoint(_plsline, GetCpLsFromCpRe(cp), MAX_OBJ_DEPTH, &lsqSubInfo[0],
									  &cActualDepth, &lsTextCell);

	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;
	pdispdim->dup = lsTextCell.dupCell;

	LSTFLOW	 lstflowLine = lsqSubInfo[0].lstflowSubline;
	POINT ptStart = {pme->XFromU(0), pme->_li._dvpHeight - pme->_li._dvpDescent};

	POINTUV ptuv = lsTextCell.pointUvStartCell;

	if(taMode & (TA_STARTOFLINE | TA_ENDOFLINE) && cActualDepth > 1)
	{
		ptuv = lsqSubInfo[0].pointUvStartRun;
		if(taMode & TA_ENDOFLINE)
			ptuv.u += lsqSubInfo[0].dupRun;
	}

	//If they ask for position inside ligature or at lim of line, give right edge of cell
	else if (cp > GetCpReFromCpLs(lsTextCell.cpStartCell))
	{
		fAtLogicalRightEdge = TRUE;
		if (lstflowLine != pdispdim->lstflow)
			ptuv.u -= lsTextCell.dupCell;
		else
			ptuv.u += lsTextCell.dupCell;
	}

	LsPointXYFromPointUV(&ptStart, lstflowLine, &ptuv, &pt);

	if (pdispdim->lstflow == lstflowWS && !(taMode & (TA_LOGICAL | TA_STARTOFLINE)))
	{
		if (fAtLogicalRightEdge)
			return pt.x;
		else
			pt.x -= pdispdim->dup - 1;
	}

	if (fAtLogicalRightEdge)
		pdispdim->dup = 0;

	return pt.x;
}

/*
 * 	COls::CchFromUp(pt, pdispdim, pcpActual)
 *
 *	@mfunc
 *		Moves _pme to pt.x. Calls LsQueryLinePointPcp()
 */
void COls::CchFromUp(
	POINTUV pt,			//@parm Point to find cch for in line
	CDispDim *pdispdim,	//@parm dimensions of object
	LONG	*pcpActual) //@parm CP point
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::CchFromUp");

	// Make point relative to LS coordinate system - (0,0) in LS is at the
	// baseline of the line.
	POINTUV ptuv = {_pme->UFromX(pt.u), -pt.v + _pme->_li._dvpHeight - _pme->_li._dvpDescent};

	LONG cpStart = _pme->GetCp();

	CreateOrGetLine();
	if(!_plsline)
		return;
	Assert(_pme->_fTarget == FALSE);

	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

	memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLinePointPcp(_plsline, &ptuv, MAX_OBJ_DEPTH,	&lsqSubInfo[0], &cActualDepth, &lsTextCell);

	if (cActualDepth == 0) //If we got back empty textcell, let's just query cp explicitly to get information
	{
		LsQueryLineCpPpoint(_plsline, cpStart, MAX_OBJ_DEPTH, &lsqSubInfo[0], &cActualDepth, &lsTextCell);
		Assert(cActualDepth != 0);
	}

	pdispdim->dup = lsTextCell.dupCell;
	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;

    LONG cp = GetCpReFromCpLs(lsTextCell.cpStartCell);
	// The queries above can fail in BiDi hidden text. Would be best to suppress
	// BiDi itemization in hidden text, but for now, here's a simple patch
	if(!cp)
		cp = cpStart;
	Assert(cp >= cpStart);
	*pcpActual = cp;

	POINTUV ptuvCell;
	//Convert the hit-test point from u,v of line to u,v of cell
	LsPointUV2FromPointUV1(lsqSubInfo[0].lstflowSubline, &lsTextCell.pointUvStartCell, &ptuv,
		lsqSubInfo[cActualDepth - 1].lstflowSubline, &ptuvCell);

	_pme->SetCp(cp);
	if (ptuvCell.u > lsTextCell.dupCell/2 ||
		ptuvCell.u > W32->GetDupSystemFont()/2 && _pme->GetChar() == WCH_EMBEDDING)
	{
		cp += lsTextCell.cpEndCell - lsTextCell.cpStartCell + 1;
	}

#if !defined(NOCOMPLEXSCRIPTS)
	if (_pme->GetPed()->_pbrk)
	{
		// If text breaker is up, verify cluster before placing the caret
		CTxtBreaker* pbrk = _pme->GetPed()->_pbrk;
		LONG		 cpEnd = _pme->GetPed()->GetTextLength();
		while (cp < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp))
			cp++;
	}
#endif

	_pme->_li._cch = cp - _cp;
	Assert(_pme->_li._cch >= 0);
	_pme->SetCp(cp);
}

/*
 * 	COls::DestroyLine(pdp)
 *
 *	@mfunc
 *		Destroys any line data structures.
 */
void COls::DestroyLine(CDisplay *pdp)
{
	CLock lock;
	if (pdp && pdp != _pdp)
		return;

	if(_plsline)
	{
		g_plsc->DestroyLine(_plsline);
		_plsline = NULL;
	}
	if (_rgcp.Count())
		_rgcp.Clear(AF_KEEPMEM);

	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; ichunk < cchunk; ichunk++)
		_rglsrunChunk.Elem(ichunk)->_cel = 0;
}

/*
 * 	LimitChunk(pch, &cchChunk, f10Mode)
 *
 *	@func
 *		Return object ID at *pch and shorten cchChunk to 1 if object isn't
 *		text and to the count of text chars up to a nontext object if one
 *		occurs within cchChunk and within the current paragraph.
 *
 *	@rdesc
 *		Object ID at *pch
 */
DWORD LimitChunk(
	const WCHAR *pch,
	LONG &		 cchChunk,
	BOOL		 f10Mode)
{
	for(LONG i = 0; i < cchChunk && *pch != CR; i++, pch++)
	{
		switch(*pch)
		{
		case WCH_EMBEDDING:
			if(i == 0)
			{
				cchChunk = 1;
				return OBJID_OLE;		// Entered at an OLE object
			}
			cchChunk = i;				// Will break before
		break;

		case EURO:
			if (i == 0)
			{
				for(; i < cchChunk && *pch == EURO; i++)
					pch++;
			}
			cchChunk = i;
		break;

		case FF:
			if(f10Mode)					// RichEdit 1.0 treats FFs as
				continue;				//  ordinary characters

		case CELL:
			cchChunk = i;				// Will break before
		break;
		}
	}

	return idObjTextChp;
}

/*
 * 	COls::SetLsChp(dwObjId, plsrun, plsChp)
 *
 *	@mfunc
 *		Helper function that initializes an LS chp from RE CCharFormat
 *
 *	@rdesc
 *		TRUE iff IsHidden()
 */
BOOL COls::SetLsChp(
	DWORD		dwObjId,	//(IN): Object id
	PLSRUN		plsrun,		//(IN): Current Run
	PLSCHP		plsChp)		//(OUT): LS chp
{
	ZeroMemory(plsChp, sizeof(*plsChp));
	plsChp->idObj = (WORD)dwObjId;

#ifndef NOCOMPLEXSCRIPTS
	if (_pme->GetPed()->IsComplexScript() && plsrun->_a.eScript && !plsrun->IsBullet())
	{
		CUniscribe*		pusp = _pme->Getusp();
		Assert (pusp);
		const SCRIPT_PROPERTIES *psp = pusp->GeteProp(plsrun->_a.eScript);

		if (psp->fComplex || plsrun->_a.fRTL ||
			psp->fNumeric && W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		{
			// 1. Complex script
			// 2. RTL (internal direction) run (handle mirror glyph i.e.'?')
			// 3. Numeric run and substitution mode is either Native or Context

			plsChp->fGlyphBased	= TRUE;
		}
	}
#endif

	const CCharFormat *pCF = plsrun->_pCF;
	DWORD dwEffects = pCF->_dwEffects;
	const CDisplay *pdp = _pme->_pdp;
	HDC				hdc = pdp->GetDC();

	if((dwEffects & (CFE_UNDERLINE | CFE_LINK | CFE_REVISED)) ||
		GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY && GetTmpUnderline(pCF->_sTmpDisplayAttrIdx))
		plsChp->fUnderline = TRUE;
	pdp->ReleaseDC(hdc);

	if(dwEffects & CFE_STRIKEOUT && !plsrun->IsBullet())
		plsChp->fStrike = TRUE;

	if (pCF->_yOffset || dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
	{
		_pme->SetUseTargetDevice(FALSE);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		LONG yOffset, yAdjust;
		pccs->GetOffset(pCF, _pme->_dvpInch, &yOffset, &yAdjust);

		plsChp->dvpPos += yOffset + yAdjust;
	}

	if (pCF->CanKern() && !plsChp->fGlyphBased)
	{
		CKernCache *pkc = fc().GetKernCache(pCF->_iFont, pCF->_wWeight, pCF->_dwEffects & CFE_ITALIC);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		if (pkc && pkc->FInit(pccs->_hfont))
		{
			plsChp->fApplyKern = TRUE;
			plsChp->dcpMaxContext = max(plsChp->dcpMaxContext, 2);
		}
	}

	//If its an OLE object, but the Object doesn't exist yet, then hide it
	if (dwObjId == OBJID_OLE)
	{
		COleObject *pobj = _pme->GetObjectFromCp(_pme->GetCp());
		if (!pobj)
			return TRUE; //FUTURE (keithcu) Remove the need for this.

		if (pobj->FWrapTextAround())
		{
			_pme->AddObjectToQueue(pobj);
			return TRUE;
		}
	}
	return dwEffects & CFE_HIDDEN;
}

/*
 *	COls::FetchAnmRun(cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@mfunc
 *		 LineServices fetch bullets/numbering callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI COls::FetchAnmRun(
	LSCP	 cp,		//@parm [IN]: RE cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: fHidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if (cp == cpFirstAnm && _pme->Get_pPF()->IsRtl())
	{
		ZeroMemory(plsChp, sizeof(*plsChp));
		plsChp->idObj = OBJID_REVERSE;
		*pfHidden	= 0; *pcchRun = 1;
		*pplsrun	= GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
		*plpwchRun	= &_szAnm[0];
		return lserrNone;
	}

	*plpwchRun = &_szAnm[cp - cpFirstAnm];
	*pcchRun = _cchAnm - (cp - cpFirstAnm);	
	*pplsrun  = GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
	SetLsChp(idObjTextChp, *pplsrun, plsChp);
	*pfHidden = FALSE;

	if (!_pme->GetNumber())
		plsChp->fUnderline = FALSE;

	return lserrNone;	
}

/*
 *	OlsFetchRun(pols, cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch-run callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchRun(
	POLS	 pols,		//@parm [IN]: COls *
	LSCP	 cpLs,		//@parm [IN]: LS cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: Hidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if(cpLs < 0)
		return pols->FetchAnmRun(cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun);

	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtEdit 	*ped = pme->GetPed();
	WCHAR		chPassword = pme->GetPasswordChar();
	LONG		cpAccelerator = ped->GetCpAccelerator();
	BOOL		fAccelerator = FALSE;
	BOOL		f10Mode = ped->Get10Mode();

	if (cpLs == pols->_cp)
	{
		// If we are formatting (or re-formatting) the line, cleanup
		if (pols->_rgcp.Count())
			pols->_rgcp.Clear(AF_KEEPMEM);
		pols->_cEmit = 0;
	}
	long cpRe = pols->GetCpReFromCpLs(cpLs);


	pme->SetCp(cpRe);						// Start fetching at given cp

#ifndef NOCOMPLEXSCRIPTS
	BOOL		fFetchBraces = ped->IsBiDi() && g_pusp && g_pusp->IsValid() &&
							!ped->_fItemizePending && ped->GetAdjustedTextLength();
	BOOL		fStart = FALSE;

	if (fFetchBraces && pme->_rpCF.IsValid())
	{
		// Consider emitting braces only at the run boundary or start of a fetched line
		if (cpRe == pols->_cp || !pme->GetIchRunCF() || !pme->GetCchLeftRunCF())
		{
			SHORT	cBrClose, cBrOpen;
			BYTE	bBaseLevel = pme->IsParaRTL() ? 1 : 0;
			BYTE	bLevel = bBaseLevel;
			BYTE	bLevelPrev = bBaseLevel;			// Assume base level
	
			if (cpRe < ped->GetTextLength())
			{
				CBiDiLevel level;

				bLevel = pme->_rpCF.GetLevel(&level);	// Got level of current run
				fStart = level._fStart;
			}
	
			if (cpRe > pols->_cp && pme->Move(-1))
			{
				if (pme->_rpPF.SameLevel(bBaseLevel))	// Preceding run may be hidden
					bLevelPrev = pme->_rpCF.GetLevel();	// Got level of preceding run
				pme->Move(1);							// Resume position
			}
	
			cBrOpen = cBrClose = bLevel - bLevelPrev;
	
			if (fStart)									// Start embedding at current run
				cBrClose = bBaseLevel - bLevelPrev;		// This means we must close all braces of preceding run
	
			cBrClose = max(0, -cBrClose);

			if (cBrClose > 0 && pols->BracesBeforeCp(cpLs) < cBrClose)
			{
				// Emit close braces
				if (pols->_cEmit > 0)
				{
					EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
					if (pols->AddBraceCp(cpLs))
						pols->_cEmit--;
#ifdef DEBUG_BRACE
					Tracef(TRCSEVNONE, "CLOSE(%d) cpLs %d: emitted %d", cBrClose, cpLs, pols->_cEmit);
#endif
					return lserrNone;
				}
				else
				{
					// We assert. You can click "Ignore All" with no hang.
					AssertSz(FALSE, "Prevent emitting close brace (no open counterpart)");
				}
			}
	
			if (fStart)									// start embedding at the current run
				cBrOpen = bLevel - bBaseLevel;			// we begin openning braces
	
			if (cBrOpen > 0 && pols->BracesBeforeCp(cpLs) < cBrOpen + cBrClose)
			{
				// Emit open braces
				EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, OBJID_REVERSE, L" ");
				if (pols->AddBraceCp(cpLs))
					pols->_cEmit++;
#ifdef DEBUG_BRACE
				Tracef(TRCSEVNONE, "OPEN(%d) cpLs %d: emitted %d", cBrOpen, cpLs, pols->_cEmit);
#endif
				return lserrNone;
			}
		}
	}
#endif

	// Done fetching braces.
	// Begin getting real data...


#ifdef DEBUG_BRACE
	Tracef(TRCSEVNONE, "cpLs %d: emitted %d", cpLs, pols->_cEmit);
#endif

	// Initialized chunk to count of characters in format run
	LONG	cchChunk = pme->GetCchLeftRunCF();
	DWORD	dwObjId	 = idObjTextChp;
	const CCharFormat *pCF = pme->GetCF();

	if(!pme->IsHidden())					// Run isn't hidden
	{
		LONG cch;
		WCHAR ch;

		*plpwchRun = pme->GetPch(cch);		// Get text in run
		if(cch && **plpwchRun == NOTACHAR)
		{
			(*plpwchRun)++;					// Bypass NOTACHAR
			cch--;
		}

		cchChunk = min(cchChunk, cch);		// Maybe less than cchChunk
		if (!pme->GetPdp()->IsMetafile())
			cchChunk = min(cchChunk, 255);  // Prevent us from having runs which are TOO long

		// Support khyphChangeAfter
		if (pols->_cp == cpRe && pme->GetIhyphPrev())
		{
			UINT khyph;
			CHyphCache *phc = ped->GetHyphCache();
			Assert(phc);
			phc->GetAt(pme->GetIhyphPrev(), khyph, ch);
			if (khyph == khyphChangeAfter)
			{
				pols->_rgchTemp[0] = ch;
				*plpwchRun = pols->_rgchTemp;
				cchChunk = 1;
			}
		}

		if (chPassword)
		{
			cchChunk = min(cchChunk, (int)ARRAY_SIZE(pols->_rgchTemp));
			for (int i = 0; i < cchChunk; i++)
			{
				ch = (*plpwchRun)[i];
				if(IN_RANGE(0xDC00, ch, 0xDFFF))
				{							// Surrogate trail word
					if(i)					// Truncate current run at
						cchChunk = i;		//  trail word
					else					// Make trail word a hidden
					{						//  single-char run
						*pplsrun = pols->GetPlsrun(cpRe, pCF, FALSE);
						pols->SetLsChp(dwObjId, *pplsrun, plsChp);
						*pfHidden = TRUE;
						*pcchRun = 1;
						return lserrNone;
					}
				}
				else
					pols->_rgchTemp[i] = IsEOP(ch) ? ch : chPassword;
			}
			*plpwchRun = pols->_rgchTemp;
		}

		if(cpAccelerator != -1)
		{
			LONG cpCur = pme->GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < cpAccelerator &&
				cpCur + cchChunk > cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
			}
		}
		if(pCF->_dwEffects & CFE_ALLCAPS)
		{
			cchChunk = min(cchChunk, (int)ARRAY_SIZE(pols->_rgchTemp));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));
			CharUpperBuff(pols->_rgchTemp, cchChunk);
			*plpwchRun = pols->_rgchTemp;
		}

		//Line Services handles page breaks in a weird way, so lets just convert to a CR.
		if (*plpwchRun && (*(*plpwchRun) == FF && !f10Mode || *(*plpwchRun) == CELL))
		{
			pols->_szAnm[0] = CR;
			*plpwchRun = pols->_szAnm;
			cchChunk = 1;
		}

		AssertSz(cpRe < ped->GetTextLength() || !ped->IsRich(),	"0-length run at end of control");
		AssertSz(cch || !ped->IsRich(),	"0-length run at end of control");

		// Set run size appropriately for any objects that are in run
		dwObjId = LimitChunk(*plpwchRun, cchChunk, f10Mode);

		// Get regular highlighted positions
		LONG cpSelMin, cpSelMost;
		ped->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		if(cpSelMin != cpSelMost)
		{
			if(cpRe >= cpSelMin)
			{
				if(cpRe < cpSelMost)
				{
					// Current text falls inside selection
					cch = cpSelMost - cpRe;
					cchChunk = min(cchChunk, cch);
				}
			}
			else if(cpRe + cchChunk >= cpSelMin)
			{
				// cp < cpSelMin - run starts outside of selection.
				// Limit text to start of selection.
				cchChunk = cpSelMin - cpRe;
			}
		}
	}

	*pplsrun  = pols->GetPlsrun(cpRe, pCF, FALSE);
	*pfHidden = pols->SetLsChp(dwObjId, *pplsrun, plsChp);

	if (fAccelerator)
		plsChp->fUnderline = TRUE;

	if(!cchChunk)							// Happens in plain-text controls
	{										//  and if hidden text to end of story
		if (!ped->IsRich() && pols->_cEmit > 0)
		{
			EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
			TRACEWARNSZ("(plain)Auto-emit a close brace to make balance");
			if (pols->AddBraceCp(cpLs))
				pols->_cEmit--;
			return lserrNone;
		}
		cchChunk = 1;
		*plpwchRun = szCR;
		*pfHidden = FALSE;
#ifndef NOCOMPLEXSCRIPTS
		//Paragraph marks should not have any script state associated with them,
		//even if the pCF that point to does.
		ZeroMemory(&(*pplsrun)->_a, sizeof((*pplsrun)->_a));
#endif
	}
	*pcchRun = cchChunk;

	return lserrNone;
}

/*
 *	OlsGetAutoNumberInfo (pols, plskalAnm, plschpAnm, pplsrunAnm, pwchAdd, plschp, 
 *						  pplsrun, pfWord95Model, pduaSpaceAnm, pduaWidthAnm)
 *	@func
 *		LineServices fetch autonumbering info callback. Return info needed
 *		by LS for auto numbering. Get the chp/run for last char from auto
 *		number run. Always say we are Word95 model Anm and get rest of info
 *		from paragraph properties.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetAutoNumberInfo(
	POLS	 pols,			//(IN): Client context
	LSKALIGN *plskalAnm,	//(OUT):Justification
	PLSCHP   plschpAnm,
	PLSRUN   *pplsrunAnm,
	WCHAR *	 pwchAdd,		//(OUT):char to add (Nil is treated as none)
	PLSCHP	 plsChp,		//(OUT):chp for bridge character
	PLSRUN * pplsrun,		//(OUT):Run for bridge character
	BOOL *	 pfWord95Model,	//(OUT):Type of autonumber run
	long *	 pduaSpaceAnm,	//(OUT):Relevant iff fWord95Model
	long *	 pduaWidthAnm)	//(OUT):Relevant iff fWord95Model
{
	CMeasurer *pme = pols->GetMeasurer();
	const CParaFormat *pPF = pme->Get_pPF();

	*pplsrunAnm = *pplsrun = pols->GetPlsrun(pme->GetCp(), &pols->_CFBullet, TRUE);
	pols->SetLsChp(idObjTextChp, *pplsrun, plsChp);

	if (!pme->GetNumber())
		plsChp->fUnderline = FALSE;

	*plschpAnm		= *plsChp;
	*pwchAdd		= '\t';
	*pfWord95Model	= TRUE;
	*pduaSpaceAnm	= 0;
	*pduaWidthAnm	= pPF->_wNumberingTab ? pPF->_wNumberingTab : pPF->_dxOffset;

	LONG Alignment	= pPF->_wNumberingStyle & 3;
	*plskalAnm		= (LSKALIGN)(lskalLeft + Alignment);
	if(Alignment != tomAlignLeft)
	{
		if(Alignment == tomAlignRight)
		{
			*pduaSpaceAnm = *pduaWidthAnm;	// End at pPF->_dxStartIndent
			*pduaWidthAnm += pPF->_dxStartIndent;
		}
		else
		{
			Assert(Alignment == tomAlignCenter);
			*pduaWidthAnm *= 2;				// Center at pPF->dxStartIndent
		}
	}

	return lserrNone;
}

/*
 *	OlsGetNumericSeparators (pols, plsrun, pwchDecimal, pwchThousands)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetNumericSeparators(
	POLS	pols,			//(IN): pols
	PLSRUN	plsrun,			//(IN): Run (cp here)
	WCHAR *	pwchDecimal,	//(OUT): Decimal separator for this run
	WCHAR *	pwchThousands)	//(OUT): Thousands separator for this run
{
	LCID	lcid = plsrun->_pCF->_lcid;
	WCHAR	ch = TEXT('.');

	// This may need to be virtualized for Win95/CE...
	::GetLocaleInfo(lcid, LOCALE_SDECIMAL, &ch, 1);
	*pwchDecimal = ch;
	ch = TEXT(',');
	::GetLocaleInfo(lcid, LOCALE_STHOUSAND, &ch, 1);
	*pwchThousands = ch;

	return lserrNone;
}

/*
 *	OlsFetchPap (pols, cpLS, plspap)
 *
 *	@func
 *		Fetch paragraph properties
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchPap(
	POLS	pols,		//(IN): pols
	LSCP	cpLs, 		//(IN):  an arbitrary cp value inside paragraph
	PLSPAP	plspap)		//(OUT): Paragraph properties.
{
	CMeasurer *pme = pols->GetMeasurer();
	pme->SetCp(pols->_cp);
	LONG	dvpJunk;

	const CParaFormat *pPF = pme->Get_pPF();
	CTxtEdit *		   ped = pme->GetPed();

	// Default all results to 0
	ZeroMemory(plspap, sizeof(*plspap));

	//LS doesn't really care where the paragraph starts
	plspap->cpFirst = pols->_cp;

	if(plspap->cpFirst && !pme->fFirstInPara())	// Not first in para: say para
		plspap->cpFirst--;						//  starts one char earlier

	plspap->cpFirstContent = plspap->cpFirst;

	if (pPF->IsRtl())
		plspap->lstflow = lstflowWS;

	// Alignment
	plspap->lskal = (LSKALIGN) g_rgREtoTOMAlign[pPF->_bAlignment];

	if (pPF->IsRtl())
	{	//For Line Services, left means near and right means far.
		if (plspap->lskal == lskalLeft)
			plspap->lskal = lskalRight;
		else if (plspap->lskal == lskalRight)
			plspap->lskal = lskalLeft;
	}

	if (pPF->_bAlignment == PFA_FULL_INTERWORD)
	{
		plspap->lskal = lskalLeft;
		plspap->lskj = lskjFullInterWord;
	}

	//Enable hyphenation?
	if (ped->_pfnHyphenate && !(pPF->_wEffects & PFE_DONOTHYPHEN))
	{
		plspap->grpf |= fFmiDoHyphenation;
		plspap->duaHyphenationZone = ped->_dulHyphenateZone;
	}

	// Kind of EOP
	CTxtPtr tp(pme->_rpTX);
	LONG	results;

	tp.FindEOP(tomForward, &results);
	plspap->lskeop = (results & 3) == 2 ? lskeopEndPara12 : lskeopEndPara1;

	// Line breaking
	if (pPF->_bAlignment > PFA_FULL_INTERWORD || !ped->fUseSimpleLineBreak() ||
		!pme->GetPdp()->GetWordWrap())		// No word wrap
	{
		plspap->grpf |= fFmiApplyBreakingRules | fFmiTreatHyphenAsRegular;
	}


	LONG dul = pPF->_dxRightIndent;

	if (pme->IsMeasure())
	{
		COleObject *pobj = pme->FindFirstWrapObj(FALSE);
		if (pobj && pobj->GetCp() <= pols->_cp)
		{
			LONG dulRight;
			pobj->MeasureObj(1440, 1440, dulRight, dvpJunk, dvpJunk, 0, pme->GetTflow());

			dul = max(dul, dulRight);
			pme->_li._cObjectWrapRight = pme->CountQueueEntries(FALSE);
		}
	}
	else if (pme->_li._cObjectWrapRight)
	{
		LONG cpObj = pme->FindCpDraw(pme->GetCp() + 1, pme->_li._cObjectWrapRight, FALSE);
		COleObject *pobj = pme->GetObjectFromCp(cpObj);

		LONG dulRight;
		pobj->MeasureObj(1440, 1440, dulRight, dvpJunk, dvpJunk, 0, pme->GetTflow());
		dul = max(dul, dulRight);
	}

	plspap->uaRightBreak   = dul;
	plspap->uaRightJustify = dul;
	pme->_upRight		   = pme->LUtoDU(dul);

	if (!pme->_pdp->GetWordWrap())
		plspap->uaRightBreak = uLsInfiniteRM;

	if(ped->IsInOutlineView())
	{
		plspap->uaLeft	   = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);
		plspap->duaIndent  = 0;
	}
	else
	{
		LONG dulPicture = 0;

		if (pme->IsMeasure())
		{
			COleObject *pobj = pme->FindFirstWrapObj(TRUE);
			if (pobj && pobj->GetCp() <= pols->_cp)
			{
				pobj->MeasureObj(1440, 1440, dulPicture, dvpJunk, dvpJunk, 0, pme->GetTflow());

				pme->_li._cObjectWrapLeft = pme->CountQueueEntries(TRUE);
			}
		}
		else if (pme->_li._cObjectWrapLeft)
		{
			LONG cpObj = pme->FindCpDraw(pme->GetCp() + 1, pme->_li._cObjectWrapLeft, TRUE);
			COleObject *pobj = pme->GetObjectFromCp(cpObj);
			if(pobj)
			pobj->MeasureObj(1440, 1440, dulPicture, dvpJunk, dvpJunk, 0, pme->GetTflow());
		}

		plspap->uaLeft	  = pPF->_dxStartIndent + pPF->_dxOffset;
		plspap->duaIndent = -pPF->_dxOffset;

		LONG Alignment = pPF->_wNumberingStyle & 3;
		if(pPF->_wNumbering && Alignment != tomAlignLeft)
		{
			// Move back by amount added to duaWidth in OlsGetAutoNumberInfo()
			plspap->duaIndent -= (Alignment == tomAlignRight) ? pPF->_dxStartIndent
							   : pPF->_wNumberingTab ? pPF->_wNumberingTab
							   : pPF->_dxOffset;
		}
		if (dulPicture)
		{
			plspap->uaLeft = max(plspap->uaLeft, dulPicture);
			// if hanging indent causes first line to overlap picture, shift it further
			if (plspap->uaLeft + plspap->duaIndent < dulPicture)
				plspap->duaIndent = dulPicture - plspap->uaLeft;
		}
	}

	if(!pPF->InTable() && plspap->uaLeft < 0)
		plspap->uaLeft = 0;

	// Is this a bulleted paragraph? - ignore bullets in a password
	if(pPF->_wNumbering && pme->fFirstInPara() && !pme->GetPasswordChar() &&
	   !pPF->IsNumberSuppressed())
	{
		CCcs *pccs = pme->GetCcsBullet(&pols->_CFBullet);
		if (pccs)
			pccs->Release();

		plspap->grpf |= fFmiAnm;
		WCHAR *pchAnm = pols->_szAnm;
		pols->_cchAnm = 0;

		if (pPF->IsRtl())				// Open character
			*pchAnm++ = ' ';
		
		//FUTURE (KeithCu) we turn off Indic digits if there is any Hebrew,
		//which should be refined to do a better job with worldwide documents.
		pols->_cchAnm += pPF->NumToStr(pchAnm, pme->GetNumber(),
			(pme->GetPed()->GetCharFlags() & FHEBREW) ? 0 : fIndicDigits);
		pchAnm += pols->_cchAnm;
		
		if (pPF->IsRtl())				// End character for reverser
		{
			*pchAnm++ = wchObjectEnd;
			pols->_cchAnm += 2;			// Alloc space for open and close
		}
		*pchAnm++ = ' ';				// Ensure a little extra space
		*pchAnm++ = wchObjectEnd;		// End character for Anm
		pols->_cchAnm += 2;
	}

	return lserrNone;
}

/*
 *	OlsFetchTabs(pols, LSCP cp, plstabs, pfHangingTab, pduaHangingTab, pwchHangingTabLeader)
 *
 *	@func
 *		Fetch tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchTabs(
	POLS	pols,					//(IN):	(COls *)
	LSCP	cp,						//(IN): Arbitrary cp value inside para
	PLSTABS plstabs,				//(OUT): Tabs array
	BOOL *	pfHangingTab,			//(OUT): There is hanging tab
	long *	pduaHangingTab,			//(OUT): dua of hanging tab
	WCHAR *	pwchHangingTabLeader)	//(OUT): Leader of hanging tab
{
	CMeasurer *pme = pols->GetMeasurer();

	const CParaFormat *pPF = pme->Get_pPF();
	const char rgchTabLeader[] = {0, '.', '-', '_', '_', '='};

	LONG		cTabCount = pPF->_bTabCount;
	LONG		i, iActual;
	LSTBD *		prgTab	  = pols->_rgTab;
	const LONG *prgxTabs  = pPF->GetTabs();

	Assert(cTabCount <= MAX_TAB_STOPS && (prgxTabs || !cTabCount));

	plstabs->duaIncrementalTab = pme->GetPed()->GetDefaultTab();

	*pwchHangingTabLeader = 0;
	*pduaHangingTab = pPF->_dxStartIndent + pPF->_dxOffset;
	*pfHangingTab = pPF->_dxOffset > 0;

	for(i = 0, iActual = 0; i < cTabCount; i++)
	{
		LONG tbAlign, tbLeader;
		pPF->GetTab(i, &prgTab[iActual].ua, &tbAlign, &tbLeader, prgxTabs);

		pme->SetUseTargetDevice(FALSE);
		if (prgTab[iActual].ua > pme->_dulLayout)
			break;

		if(tbAlign <= tomAlignDecimal)		// Don't include tomAlignBar
		{
			prgTab[iActual].lskt = (lsktab) tbAlign;
			prgTab[iActual].wchTabLeader = rgchTabLeader[tbLeader];
			iActual++;
		}
	}

	plstabs->pTab = prgTab;
	plstabs->iTabUserDefMac = iActual;
	return lserrNone;
}

/*
 *	OlsCheckParaBoundaries (pols, cpOld, cpNew, pfChanged)
 *
 *	@func
 *		Determine if para formatting between para containing cpOld and
 *		that containing cpNew are incompatible and shouldn't be formatted
 *		on the same line when connected by hidden text.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckParaBoundaries(
	POLS	pols,		//(IN): Interface object
	LONG	cpOld,		//(IN): cp in one paragraph
	LONG	cpNew,		//(IN): cp in another paragraph
	BOOL *	pfChanged)	//(OUT): "Dangerous" change between para properties
{
	// It's easier (and safer) to allow LS decide which para properties to take.
	// Else we have to close objects (BiDi, for instance) before hidden EOP.

	*pfChanged = fFalse;			// they're always compatible

	return lserrNone;
}
		
/*
 *	OlsGetRunCharWidths (pols, plrun, deviceID, lpwchRun, cwchRun, du,
 *						 kTFlow, prgDu, pduRun, plimDu)
 *	@func
 *		Get run character widths
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharWidths(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	enum lsdevice deviceID, //(IN): Preview, reference, or absolute
	LPCWSTR	  lpwchRun,		//(IN): Run of characters
	DWORD	  cwchRun, 		//(IN): Count of characters in run
	long	  du, 			//(IN): Available space for characters
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	int *	  prgDu,		//(OUT): Widths of characters
	long *	  pduRun,		//(OUT): Sum of widths in rgDx[0] to rgDu[limDx-1]
	long *	  plimDu)		//(OUT): Number of widths fetched
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);
	DWORD i = 0;
	LONG  dup, dupAdjust, duCalc = 0;
	BOOL  fGlyphRun = FALSE;
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

#ifndef NOCOMPLEXSCRIPTS
	if (pme->GetPed()->IsComplexScript() &&
		plsrun->_a.eScript && !plsrun->IsBullet())
	{
		const SCRIPT_PROPERTIES *psp = pme->Getusp()->GeteProp(plsrun->_a.eScript);
		if (psp->fComplex)
			fGlyphRun = TRUE;
	}
#endif

	dupAdjust = pme->LUtoDU(plsrun->_pCF->_sSpacing);
	for(;i < cwchRun; i++, lpwchRun++)
	{
		if (!fGlyphRun)
		{
			if (IsZerowidthCharacter(*lpwchRun))
				dup = 0;
			else
			{
				pccs->Include(*lpwchRun, dup);
				dup =  max(dup + dupAdjust, 1);
			}
		}
		else
		{
			dup = 0;
			if (!IsDiacriticOrKashida(*lpwchRun, 0))
				dup = pccs->_xAveCharWidth;
		}

		duCalc += dup;				// Keep running total of width
		*prgDu++ = dup;				// Store width in output array
		if(dup + duCalc > du)		// Width exceeds width available
		{
			i++;						// Count this char as processed
			break;
		}
	}
	*plimDu = i;						// Store total chars processed
	*pduRun = duCalc;					// Store output total width
	return lserrNone;
}

/*
 *	OlsGetRunTextMetrics (pols, plsrun, deviceID, kTFlow, plsTxMet)
 *
 *	@func
 *		Get run text metrics
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunTextMetrics(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run (cp here)
	enum lsdevice deviceID, //(IN): presentation or reference
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSTXM	  plsTxMet)		//(OUT): Text metrics
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	LONG yFEAdjust = pccs->AdjustFEHeight(pme->FAdjustFELineHt());

	LONG yDescent = pccs->_yDescent + yFEAdjust;

	// Fill in metric structure
	plsTxMet->dvAscent			= pccs->_yHeight + (yFEAdjust << 1) - yDescent;
    plsTxMet->dvDescent			= yDescent;
    plsTxMet->dvMultiLineHeight = plsTxMet->dvAscent + yDescent;
    plsTxMet->fMonospaced		= pccs->_fFixPitchFont;

	if (plsrun->_pCF->_yOffset && pme->GetPF()->_bLineSpacingRule != tomLineSpaceExactly)
	{
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, deviceID == lsdevReference ? pme->_dvrInch :
					    pme->_dvpInch, &yOffset, &yAdjust);

		if (yOffset < 0)
			plsTxMet->dvDescent -= yOffset;
		else
			plsTxMet->dvAscent += yOffset;
	}

	return lserrNone;
}

/*
 *	OlsGetRunUnderlineInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run underline info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunUnderlineInfo(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	PCHEIGHTS pcheights,	//(IN): Height of line
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	PLSULINFO plsUlInfo)	//(OUT): Underline information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL	   fBullet = pols->SetRun(plsrun);
	const CDisplay *pdp = pme->GetPdp();
	HDC				hdc = pdp->GetDC();

	// Initialize output buffer
	ZeroMemory(plsUlInfo, sizeof(*plsUlInfo));
	//REVIEW KeithCu

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	long dvpUlOffset = pccs->_dyULOffset;

	plsUlInfo->cNumberOfLines = 1;

	// Set underline type
	if (plsrun->_pCF->_dwEffects & CFE_LINK)
		plsUlInfo->kulbase = CFU_UNDERLINE;
	else if (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY && GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx))
		plsUlInfo->kulbase	= GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx);
	else if (plsrun->_pCF->_dwEffects & (CFE_UNDERLINE | CFE_REVISED))
		plsUlInfo->kulbase	= plsrun->_pCF->_bUnderlineType;
	else
	{
		Assert(pme->GetPed()->GetCpAccelerator() == plsrun->_cp);
		plsUlInfo->kulbase = CFU_UNDERLINE;
	}
	pdp->ReleaseDC(hdc);

	LONG yDescent = pccs->_yDescent + pccs->AdjustFEHeight(pme->FAdjustFELineHt());

	// Some fonts report invalid offset so we fix it up here
	if(dvpUlOffset >= yDescent)
		dvpUlOffset = yDescent - 1;

	plsUlInfo->dvpFirstUnderlineOffset = dvpUlOffset;
	plsUlInfo->dvpFirstUnderlineSize   = pccs->_dyULWidth;

	return lserrNone;
}

/*
 *	OlsGetRunStrikethroughInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run strikethrough info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunStrikethroughInfo(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run
	PCHEIGHTS pcheights,	//(IN): height of line
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSSTINFO plsStInfo)	//(OUT): Strikethrough information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	AssertSz(plsrun->_pCF->_dwEffects & CFE_STRIKEOUT, "no strikeout");

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// Default number of lines
	plsStInfo->cNumberOfLines = 1;
	plsStInfo->dvpLowerStrikethroughOffset = -pccs->_dySOOffset;
	plsStInfo->dvpLowerStrikethroughSize   = pccs->_dySOWidth;

	return lserrNone;
}

/*	OlsDrawUnderline (pols, plsrun, kUlbase, pptStart, dupUL, dvpUL,
 *					  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw underline
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawUnderline(
	POLS		pols,		//(IN): interface object
	PLSRUN		plsrun,		//(IN): run (cp) to use for underlining
	UINT		kUlbase,	//(IN): underline kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupUL,		//(IN): underline width
	DWORD		dvpUL,		//(IN): underline thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->Check_pccs();

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if (pre->fDisplayDC() && GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx))
	{
		COLORREF	crTmpUnderline;

		GetTmpUnderlineColor(plsrun->_pCF->_sTmpDisplayAttrIdx, crTmpUnderline);
		pre->SetupUnderline(kUlbase, 0, crTmpUnderline);
	}
	else
		pre->SetupUnderline(kUlbase, plsrun->_pCF->_bUnderlineColor);

	pre->RenderUnderline(lstflow == lstflowWS ? pptStart->x - dupUL - 1:
						 pptStart->x, pptStart->y, dupUL, dvpUL);

	return lserrNone;
}

/*
 *	OlsDrawStrikethrough (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw strikethrough
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawStrikethrough(
	POLS		pols,		//(IN): Interface object
	PLSRUN		plsrun,		//(IN): run (cp) for strikethrough
	UINT		kStbase,	//(IN): strikethrough kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupSt,		//(IN): strikethrough width
	DWORD		dvpSt,		//(IN): strikethrough thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->SetSelected(plsrun->IsSelected());

	pre->RenderStrikeOut(lstflow == lstflowWS ? pptStart->x - dupSt - 1:
						 pptStart->x, pptStart->y, dupSt, dvpSt);

	return lserrNone;
}


/*
 *	OlsFInterruptUnderline(pols, plsrunFirst, cpLastFirst, plsrunSecond,
 *						   cpStartSecond, pfInterruptUnderline)
 *	@func
 *		Says whether client wants to interrupt drawing of underline
 *		between the first and second runs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptUnderline(
	POLS   pols,				//(IN): Client context
	PLSRUN plsrunFirst,			//(IN): Run pointer for previous run
	LSCP   cpLastFirst,			//(IN): cp of last character of previous run
	PLSRUN plsrunSecond,		//(IN): Run pointer for current run
	LSCP   cpStartSecond,		//(IN): cp of first character of current run
	BOOL * pfInterruptUnderline)//(OUT): Interrupt underline between runs?
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pre->SetSelected(FALSE); //Selection is handled below

	COLORREF cr = pre->GetTextColor(plsrunFirst->_pCF);

	// Interrupt underline if run text colors differ
	*pfInterruptUnderline = cr != pre->GetTextColor(plsrunSecond->_pCF) ||
							plsrunFirst->IsSelected() != plsrunSecond->IsSelected();
	return lserrNone;
}

/*
 *	OlsDrawTextRun (pols, plsrun, fStrikeoutOkay, fUnderlineOkay, ppt, pwchRun,
 *					rgDupRun, cwchRun, lstflow, kDisp, pptRun, pheightsPres,
 *					dupRun, dupUlLimRun, prcClip)
 *	@func
 *		Draw text run
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawTextRun(
	POLS		pols,			//(IN): Interface object
	PLSRUN		plsrun,			//(IN): Run (cp) to use for text
	BOOL		fStrikeoutOkay, //(IN): TRUE <==> allow strikeout
	BOOL		fUnderlineOkay, //(IN): TRUE <==> allow underlining
	const POINT *ppt, 			//(IN): Starting position
	LPCWSTR		pwchRun, 		//(IN): Run of characters
	const int *	rgDupRun, 		//(IN): Character widths
	DWORD		cwchRun, 		//(IN): Count of chars in run
	LSTFLOW		lstflow,		//(IN): Text direction and orientation
	UINT		kDisp,			//(IN): Display mode - opaque, transparent
	const POINT *pptRun,		//(IN): Starting point of run
	PCHEIGHTS	pheightsPres, 	//(IN): Presentation heights for run
	long		dupRun, 		//(IN): Presentation width for run
	long		dupUlLimRun,	//(IN): Underlining limit
	const RECT *prcClip)		//(IN): Clipping rectangle
{
	CRenderer  *pre = pols->GetRenderer();
	RECT		rc = *prcClip;
	Assert(pre->IsRenderer());

	// Set up drawing point and options
	BOOL fBullet = pols->SetRun(plsrun);
	CCcs *pccs = pre->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// v needs to be moved from baseline to top of character
	POINTUV pt = {ppt->x, ppt->y - (pccs->_yHeight - pccs->_yDescent)};

	if (lstflow == lstflowWS)
		pt.u -= dupRun - 1;

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if(!fBullet && pre->_fBackgroundColor)
	{
		if (pre->_fEraseOnFirstDraw)
			pre->EraseLine();

		kDisp = ETO_OPAQUE | ETO_CLIPPED;
		SetBkMode(pre->_hdc, OPAQUE);

		POINTUV ptCur = pre->GetCurPoint();
		ptCur.u = pt.u;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		RECTUV rcuv = pre->GetClipRect();
		pre->GetPdp()->RectFromRectuv(rc, rcuv);
	}
	else if (!pre->_fEraseOnFirstDraw && cwchRun == 1 && pwchRun[0] == ' ')
		return lserrNone; //Don't waste time drawing a space.

	if (pre->_fEraseOnFirstDraw)
	{
		SetBkMode(pre->_hdc, OPAQUE);
		pre->GetPdp()->RectFromRectuv(rc, pre->_rcErase);
		kDisp |= ETO_OPAQUE;
	}

	pre->RenderExtTextOut(pt, kDisp, &rc, pwchRun, cwchRun, rgDupRun);

	if (pre->_fEraseOnFirstDraw || !fBullet && pre->_fBackgroundColor)
	{
		SetBkMode(pre->_hdc, TRANSPARENT);
		pre->_fEraseOnFirstDraw = FALSE;
	}

	return lserrNone;
}

/*
 *	GetBreakingClasses (pols, plsrun, cpLS, ch, pbrkclsBefore, pbrkclsAfter)
 *
 *	@func
 *		Line services calls this callback for each run, to obtain the
 *		breaking classes (line breaking behaviors) for each character
 *
 *	    For Quill and RichEdit, the breaking class of a character is
 *		independent of whether it occurs Before or After a break opportunity.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakingClasses(
	POLS	pols,			//(IN): Interface object
	PLSRUN	plsrun,			//(IN): Run (cp) to use for text
	LSCP	cpLs,				//(IN): cp of the character
	WCHAR	ch, 			//(IN): Char to return breaking classes for
	BRKCLS *pbrkclsBefore,	//(OUT): Breaking class if ch is lead char in pair
	BRKCLS *pbrkclsAfter)	//(OUT): Breaking class if ch is trail char in pair
{
	// Get line breaking class and report it twice
	LCID		lcid = 0;
	CMeasurer *	pme = pols->GetMeasurer();
	if(W32->OnWin9x())
		lcid = pme->GetCF()->_lcid;

#ifndef NOCOMPLEXSCRIPTS
	long 		cpRe = pols->GetCpReFromCpLs(cpLs);
	CTxtBreaker *pbrk = pme->GetPed()->_pbrk;
	*pbrkclsBefore = *pbrkclsAfter = (pbrk && pbrk->CanBreakCp(BRK_WORD, cpRe)) ?
									brkclsOpen :
									GetKinsokuClass(ch, 0xFFFF, lcid);
#else
	*pbrkclsBefore = *pbrkclsAfter = GetKinsokuClass(ch, 0xFFFF, lcid);
#endif
	return lserrNone;
}

/*
 *	OlsFTruncateBefore (pols, plsrunCur, cpCur, wchCur, durCur, cpPrev, wchPrev,
 *						durPrev, durCut, pfTruncateBefore)
 *	@func
 *		Line services support function. This should always return
 *		FALSE for best performance
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFTruncateBefore(
	POLS	pols,				// (IN): Client context
	PLSRUN  plsrunCur,			// (IN): PLSRUN of cp
	LSCP	cpCur,				// (IN): cp of truncation char
	WCHAR	wchCur,				// (IN): Truncation character
	long	durCur,				// (IN): Width of truncation char
	PLSRUN	plsrunPrev,			// (IN): PLSRUN of cpPrev
	LSCP	cpPrev,				// (IN): cp of truncation char
	WCHAR	wchPrev,			// (IN): Truncation character
	long	durPrev,			// (IN): Width of truncation character
	long	durCut,				// (IN): Width from RM until end of current char
	BOOL *	pfTruncateBefore)	// (OUT): Truncation point is before this char
{
	*pfTruncateBefore = FALSE;
	return lserrNone;
}

/*
 *	OlsCanBreakBeforeChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate following an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakBeforeChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsClose:
	case brkclsNoStartIdeo:
	case brkclsExclaInterr:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsCanBreakAfterChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate preceding an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakAfterChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsOpen:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

#ifndef NOCOMPLEXSCRIPTS
// REVIEW FUTURE : JMO May want some version for non complex script ligatures.
/*
 *	OlsFInterruptShaping (pols, kTFlow, plsrunFirst, plsrunSecond, pfInterruptShaping)
 *
 *	@func
 *		Line services calls this callback to find out if you
 *		would like to ligate across these two runs.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptShaping(
	POLS	pols,					//(IN): Client context
	LSTFLOW	kTFlow,					//(IN): Text direction and orientation
	PLSRUN	plsrunFirst,			//(IN): Run #1
	PLSRUN	plsrunSecond,			//(IN): Run #2
	BOOL	*pfInterruptShaping)	//(OUT): Shape across these 2 runs?
{
	*pfInterruptShaping = FALSE;

	const CCharFormat* pCFFirst = plsrunFirst->_pCF;
	const CCharFormat* pCFSecond = plsrunSecond->_pCF;

	Assert (plsrunFirst->_a.eScript && plsrunSecond->_a.eScript);

	const DWORD dwMask = CFE_BOLD | CFE_ITALIC | CFM_SUBSCRIPT;

	if (pCFFirst == pCFSecond ||
		(plsrunFirst->_a.eScript == plsrunSecond->_a.eScript &&
		!((pCFFirst->_dwEffects ^ pCFSecond->_dwEffects) & dwMask) &&
		pCFFirst->_iFont == pCFSecond->_iFont &&
		pCFFirst->_yOffset == pCFSecond->_yOffset &&
		pCFFirst->_yHeight == pCFSecond->_yHeight))
	{
		// establish link
		plsrunFirst->_pNext = plsrunSecond;
		return lserrNone;
	}

	*pfInterruptShaping = TRUE;
	return lserrNone;
}

// LS calls this callback to shape the codepoint string to a glyph indices string
// for handling glyph based script such as Arabic, Hebrew and Thai.
//
LSERR OlsGetGlyphs(
	POLS 		pols,
	PLSRUN	 	plsrun,
	LPCWSTR		pwch,
	DWORD		cch,
	LSTFLOW		kTFlow,
	PGMAP		pgmap,				// OUT: array of logical cluster information
	PGINDEX*	ppgi, 				// OUT: array of output glyph indices
	PGPROP*		ppgprop, 			// OUT: array of glyph's properties
	DWORD*		pcgi)				// OUT: number of glyph generated
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	WORD*			pwgi;
	SCRIPT_VISATTR *psva;
	int				cgi;

	pme->SetGlyphing(TRUE);

	// Glyphing doesn't care about the target device but always
	// using target device reduces creation of Cccs in general.
	pme->SetUseTargetDevice(TRUE);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	// Digit substitution
	pusp->SubstituteDigitShaper(plsrun, pme);

	if (!(cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva)))
	{
		const SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		// Current font cant shape given string.
		// Try SCRIPT_UNDEF so it generates invalid glyphs
		if (!(cgi = (DWORD)pusp->ShapeString(plsrun, (SCRIPT_ANALYSIS*)&saUndef, pme, pwch, (int)cch, pwgi, pgmap, psva)))
		{
			// For whatever reason we still fails.
			// Abandon glyph processing.
			plsrun->_a.fNoGlyphIndex = TRUE;
			cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva);
		}
	}

	*pcgi = cgi;

	DupShapeState(plsrun, cch);

	*ppgi = (PGINDEX)pwgi;
	*ppgprop = (PGPROP)psva;
	pme->SetGlyphing(FALSE);
	return lserrNone;
}

// LS calls this callback to find out glyph positioning for complex scripts
//
LSERR OlsGetGlyphPositions(
	POLS		pols,
	PLSRUN		plsrun,
	LSDEVICE	deviceID,
	LPWSTR		pwch,
	PCGMAP		pgmap,
	DWORD		cch,
	PCGINDEX	pgi,
	PCGPROP		pgprop,
	DWORD		cgi,
	LSTFLOW		kTFlow,
	int*		pgdx,				// OUT: array of glyph advanced width
	PGOFFSET	pgduv)				// OUT: array of offset between glyphs
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	Assert(pgduv);
	pme->SetGlyphing(TRUE);

	// zero out before passing to shaping engine
	ZeroMemory ((void*)pgduv, cgi*sizeof(GOFFSET));
	pme->SetUseTargetDevice(deviceID == lsdevReference);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	if (!pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
	{
		SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		if (!pusp->PlaceString(plsrun, &saUndef, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
		{
			plsrun->_a.fNoGlyphIndex = TRUE;
			pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL);
		}
	}

	//Support spacing for base glyphs. Note this spreads apart clusters and breaks the lines which connect
	//arabic text, but this might be okay.
	if (plsrun->_pCF->_sSpacing)
	{
		LONG dupAdjust = pme->LUtoDU(plsrun->_pCF->_sSpacing);
		for (DWORD gi = 0; gi < cgi; gi++)
			if (pgdx[gi])
				pgdx[gi] += dupAdjust;
	}

	DupShapeState(plsrun, cch);

	pme->SetGlyphing(FALSE);
	return lserrNone;
}

LSERR OlsDrawGlyphs(
	POLS			pols,
	PLSRUN			plsrun,
	BOOL			fStrikeOut,
	BOOL			fUnderline,
	PCGINDEX		pcgi,
	const int*		pgdx,			// array of glyph width
	const int*		pgdxo,			// array of original glyph width (before justification)
	PGOFFSET		pgduv,			// array of glyph offset
	PGPROP			pgprop,			// array of glyph's properties
	PCEXPTYPE		pgxtype,		// array of expansion type
	DWORD			cgi,
	LSTFLOW			kTFlow,
	UINT			kDisp,
	const POINT*	pptRun,
	PCHEIGHTS		pHeight,
	long			dupRun,
	long			dupLimUnderline,
	const RECT*		prectClip)
{
	BOOL			fBullet = pols->SetRun(plsrun);
	CRenderer*		pre = pols->GetRenderer();
	CUniscribe* 	pusp = pre->Getusp();
	Assert(pusp && pre->IsRenderer());
	pre->SetGlyphing(TRUE);

	RECT			rc = *prectClip;
	CCcs* 			pccs = pre->Check_pccs(fBullet);

	if (!pccs)
		return lserrOutOfMemory;

	// Apply fallback font if we need to
	if (!fBullet)
		pccs = pre->ApplyFontCache(plsrun->IsFallback(), plsrun->_a.eScript);

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	// v needs to be moved from baseline to top of character
	POINTUV  pt = {pptRun->x, pptRun->y - (pccs->_yHeight - pccs->_yDescent)};

	if (kTFlow == lstflowWS)
		pt.u -= dupRun - 1;	
	
	if(!fBullet && pre->_fBackgroundColor)
	{
		if (pre->_fEraseOnFirstDraw)
			pre->EraseLine();

		kDisp = ETO_OPAQUE | ETO_CLIPPED;
		SetBkMode(pre->_hdc, OPAQUE);

		POINTUV ptCur = pre->GetCurPoint();
		ptCur.u = pt.u;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		RECTUV rcuv = pre->GetClipRect();
		pre->GetPdp()->RectFromRectuv(rc, rcuv);
	}

	if (rc.left >= rc.right || rc.top >= rc.bottom)
		goto Exit;

	if (pre->GetPdp()->IsMetafile() && !IsEnhancedMetafileDC(pre->GetDC()))
	{
		// -WMF metafile handling-
		//
		//     If the rendering device is WMF metafile. We metafile the codepoint array
		// instead of glyph indices. This requires that the target OS must know how to
		// playback complex script text (shaping, Bidi algorithm, etc.).
		//     Metafiling glyph indices only works for EMF since the WMF's META_EXTTEXTOUT
		// record stores the input string as an array of byte but a glyph index is 16-bit
		// word element.
		//     WMF also must NOT be used to record ExtTextOutW call otherwise the Unicode
		// string will be converted to mutlibyte text using system codepage. Anything
		// outside the codepage then becomes '?'.
		//     We have the workaround for such case in REExtTextOut to make sure we only
		// metafile ExtTextOutA to WMF. (wchao)
		//
	
		LONG			cch;
		const WCHAR*	pwch = pre->GetPch(cch);
		PINT			piDx;
	
		cch = min(cch, pre->GetCchLeftRunCF());
		cch = min(cch, pre->GetLine()._cch - plsrun->_cp + pols->_cp);

		// make sure that we record ETO with proper reading order.
		kDisp |= plsrun->_a.fRTL ? ETO_RTLREADING : 0;

		if (pusp->PlaceMetafileString(plsrun, pre, pwch, (int)cch, &piDx))
		{
			pre->RenderExtTextOut(pt, kDisp, &rc, pwch, cch, piDx);
			goto Exit;
		}

		TRACEERRORSZ("Recording metafile failed!");

		// Fall through... with unexpected error

		// Else, metafile glyph indices for EMF...
	}

	if (pre->_fEraseOnFirstDraw)
	{
		SetBkMode(pre->_hdc, OPAQUE);
		pre->GetPdp()->RectFromRectuv(rc, pre->_rcErase);
		kDisp |= ETO_OPAQUE;
	}

	//This is duplicated from RenderExtTextOut but the params are different so simplest solution
	//was to copy code.
	if(pre->_fDisabled)
	{
		if(pre->_crForeDisabled != pre->_crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, pre->_dvpInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			pre->SetTextColor(pre->_crShadowDisabled);

			POINTUV ptT = pt;
			ptT.u += offset;
			ptT.v += offset;

			POINT pt;
			pre->GetPdp()->PointFromPointuv(pt, ptT, TRUE);

			ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x, pt.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

			kDisp &= ~ETO_OPAQUE;
			SetBkMode(pre->_hdc, TRANSPARENT);
		}
		pre->SetTextColor(pre->_crForeDisabled);
	}

	POINT ptStart;
	pre->GetPdp()->PointFromPointuv(ptStart, pt, TRUE);

	ScriptTextOut(pre->GetDC(), &pccs->_sc, ptStart.x, ptStart.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

	if (pre->_fEraseOnFirstDraw || !fBullet && pre->_fBackgroundColor)
	{
		SetBkMode(pre->_hdc, TRANSPARENT);
		pre->_fEraseOnFirstDraw = FALSE;
	}

Exit:
	if (!fBullet)
		pre->ApplyFontCache(0, 0);		// reset font fallback if any

	pre->SetGlyphing(FALSE);
	return lserrNone;
}
#endif

/*
 *	OlsResetRunContents (pols, plsrun, cpFirstOld, dcpOld, cpFirstNew, dcpNew)
 *
 *	@func
 *		Line Services calls this routine when a ligature
 *		or kern pair extends across run boundaries.
 *
 *		We don't have to do anything special here if we are
 *		careful about how we use our PLSRUNs.
 *	@rdesc
 *		LSERR
 */
 LSERR WINAPI OlsResetRunContents(
 	POLS 	pols,		//(IN): Client context
 	PLSRUN 	plsrun,		//(IN): Run being combined
 	LSCP 	cpFirstOld, //(IN): cp of the first run being combined
 	LSDCP 	dcpOld,		//(IN):	dcp of the first run being combined
 	LSCP 	cpFirstNew, //(IN): new cp of the run
 	LSDCP 	dcpNew)		//(IN): new dcp of the run
{
	return lserrNone;
}

/*
 *	OlsCheckForDigit (pols, plsrun, wch, pfIsDigit)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckForDigit(
	POLS	pols,		//(IN): pols
	PLSRUN	plsrun,		//(IN): Run (cp here)
	WCHAR	wch,		//(IN): Character to check
	BOOL *	pfIsDigit)	//(OUT): This character is digit
{
	WORD	wType;

	// We could get the run LCID to use for the first parm in the following
	// call, but the digit property should be independent of LCID.
	W32->GetStringTypeEx(0, CT_CTYPE1, &wch, 1, &wType);
	*pfIsDigit = (wType & C1_DIGIT) != 0;

	return lserrNone;
}

/*
 *	OlsGetBreakThroughTab(pols, uaRightMargin, uaTabPos, puaRightMarginNew)
 *
 *	@func
 *		Just follow word95 behavior.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakThroughTab(
	POLS	pols,				//(IN): client context
	long	uaRightMargin,		//(IN): right margin for breaking
	long	uaTabPos,			//(IN): breakthrough tab position
	long *	puaRightMarginNew)	//(OUT): new right margin
{
	*puaRightMarginNew = 20 * 1440;
	return lserrNone;
}

/*
 *	OlsFGetLastLineJustification(pols, lskj, lskal, endr, pfJustifyLastLine, plskalLine)
 *
 *	@func
 *		Just say no to justify last line.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFGetLastLineJustification(
	POLS	pols,				//(IN): client context
	LSKJUST lskj,				//(IN): kind of justification
	LSKALIGN lskal,				//(IN): kind of alignment
	ENDRES	endr,				//(IN): result of formatting
	BOOL	*pfJustifyLastLine,	//(OUT): should last line be fully justified
	LSKALIGN *plskalLine)		//(OUT): kind of alignment for this line
{
	*pfJustifyLastLine = FALSE;
	*plskalLine = lskal;
	return lserrNone;
}

/*
 *	OlsGetHyphenInfo(pols, plsrun, pkysr, pwchYsr)
 *
 *	@func
 *		We don't support fancy YSR types, tell LS so.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetHyphenInfo(
	POLS	pols,				//(IN): client context
	PLSRUN	plsrun,				//(IN)
	DWORD*	pkysr,				//(OUT): Ysr type - see "lskysr.h"
	WCHAR*	pwchYsr)			//(OUT): Character code of YSR
{
	*pkysr = kysrNil;
	*pwchYsr = 0;	
	return lserrNone;
}

/*
 *	OlsHyphenate(pols, pclsHyphLast, cpBeginWord, cpExceed, plshyph)
 *
 *	@func
 *		Prepare the buffer, and then call the client and ask them to hyphenate the word.
 *
 *	Getting perfect word hyphenation is a complex topics which to do properly would
 *	require a lot of work. This code is simple and hopefully good enough. One difficulty
 *	for example is hidden text. The right thing to do here is to strip out hidden text and
 *	build up a cp mapping from the remaining text to it's cp in the backing store. Yuck.
 *
 *	@rdesc
 *		LSERR
 */
extern CHyphCache *g_phc;
LSERR WINAPI OlsHyphenate(
	POLS		pols,				//(IN): client context
	PCLSHYPH	pclsHyphLast,		//(IN): last seen hyphenation opportunity
	LSCP		cpBeginWord,		//(IN): First CP of last word on line
	LSCP		cpExceed,			//(IN): CP which exceeds column
	PLSHYPH		plsHyph)			//(OUT): Hyphenation opportunity found
{
	CMeasurer  *pme = pols->GetMeasurer();
	CTxtEdit   *ped = pme->GetPed();
	CHyphCache *phc = ped->GetHyphCache();
	if (!phc)
		return lserrOutOfMemory;

	if (!pme->IsMeasure())
	{
		phc->GetAt(pme->GetLine()._ihyph, plsHyph->kysr, plsHyph->wchYsr);
		plsHyph->cpYsr = pols->GetCpLsFromCpRe(pols->_cp + pme->GetCchLine()) - 1;

		// No break in the range LS expect...
		if (plsHyph->cpYsr < cpBeginWord || plsHyph->cpYsr >= cpExceed)
			plsHyph->kysr = kysrNil; 
		return lserrNone;
	}

	cpBeginWord = pols->GetCpReFromCpLs(cpBeginWord);
	cpExceed = pols->GetCpReFromCpLs(cpExceed);

	//Strip off leading junk
	pme->SetCp(cpBeginWord);
	for (; cpBeginWord < cpExceed; cpBeginWord++, pme->Move(1))
	{
		WCHAR ch = pme->GetChar();
		WORD type1;
		W32->GetStringTypeEx(pme->GetCF()->_lcid, CT_CTYPE1, &ch, 1, &type1);
		if (type1 & C1_ALPHA)
			break;
	}

	LONG cpEndWord = cpBeginWord + pme->FindWordBreak(WB_RIGHTBREAK, ped->GetAdjustedTextLength());

	//Strip off trailing junk
	pme->SetCp(cpEndWord);
	for (; cpEndWord > cpBeginWord; cpEndWord--, pme->Move(-1))
	{
		WCHAR ch = pme->GetPrevChar();
		WORD type1;
		W32->GetStringTypeEx(pme->GetCF()->_lcid, CT_CTYPE1, &ch, 1, &type1);
		if (type1 & C1_ALPHA)
			break;
	}

	int cchWord = cpEndWord - cpBeginWord;

	//Don't hyphenate unless at least 5 chars in word and can have 2 chars before
	if (cchWord >= 5 && cpExceed - cpBeginWord > 2)
	{
		CTempWcharBuf tb;
		WCHAR *pszWord = tb.GetBuf(cchWord + 1);

		pme->SetCp(cpBeginWord);
		pme->_rpTX.GetText(cchWord, pszWord);
		pszWord[cchWord] = 0;

		cpExceed = min(cpExceed, cpBeginWord + cchWord - 1);

		(*pme->GetPed()->_pfnHyphenate)(pszWord, pme->GetCF()->_lcid, cpExceed - cpBeginWord, (HYPHRESULT*)plsHyph);
		plsHyph->cpYsr += cpBeginWord; //The client gives us an ich, we turn it into a CP

		if (plsHyph->kysr != khyphNil && (plsHyph->cpYsr >= cpExceed || plsHyph->cpYsr < cpBeginWord) || 
			!IN_RANGE(khyphNil, plsHyph->kysr, khyphDelAndChange))
		{
			AssertSz(FALSE, "Bad results from hyphenation proc: ichHyph or khyph are invalid.");
			plsHyph->kysr = kysrNil;
		}
		else
			plsHyph->cpYsr = pols->GetCpLsFromCpRe(plsHyph->cpYsr);
	}
	else
		plsHyph->kysr = kysrNil;

	//Cache into CLine
	pme->GetLine()._ihyph = phc->Find(plsHyph->kysr, plsHyph->wchYsr);
	return lserrNone;
}

/*
 *	OlsCheckRunKernability (pols, plsrunFirst, plsrunSecond, pfKernable)
 *
 *	@func
 *		Return if you can kern across these two runs.
 *
 *	@rdesc
 *		lserrNone
 */
LSERR WINAPI OlsCheckRunKernability(
	POLS	pols, 
	PLSRUN	plsrunFirst, 
	PLSRUN	plsrunSecond, 
	BOOL *	pfKernable)
{
	*pfKernable = plsrunFirst->_pCF->CanKernWith(plsrunSecond->_pCF);

	return lserrNone;
}

/*
 *	OlsGetRunCharKerning(pols, plsrun, deviceID, pchRun, cchRun, ktflow, rgdu)
 *
 *	@func
 *		Fetch and return the kerning pairs to Line Services.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharKerning(
	POLS	 pols,
	PLSRUN	 plsrun,
	LSDEVICE deviceID,
	LPCWSTR	 pchRun,
	DWORD	 cchRun, 
	LSTFLOW	 ktflow,
	int *	 rgdu)
{
	CMeasurer *pme = pols->GetMeasurer();

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	pols->SetRun(plsrun);
	CCcs *pccs = pme->Check_pccs();
	const CCharFormat *pCF = plsrun->_pCF;

	if(!pccs)
		return lserrOutOfMemory;

	CKernCache *pkc = fc().GetKernCache(pCF->_iFont, pCF->_wWeight, pCF->_dwEffects & CFE_ITALIC);
	Assert(pkc); //SetLsChp ensures this exists AND kerning pairs exist.

	for (DWORD ich = 0; ich < cchRun - 1; ich++)
		rgdu[ich] = pkc->FetchDup(pchRun[ich], pchRun[ich + 1], pme->_pccs->_yHeightRequest);

	return lserrNone;
}

/*
 *	OlsReleaseRun (pols, plsrun)
 *
 *	@func
 *		We do nothing because the run is in an array and is
 *		released automatically.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsReleaseRun(
	POLS	pols,	//(IN): interface object
	PLSRUN	plsrun)	//(IN): run (cp) to use for underlining
{
	return lserrNone;
}

/*
 * 	OlsNewPtr(pols, cBytes)
 *
 *	@func
 *		Memory allocator.
 */
void* WINAPI OlsNewPtr(
	POLS	pols,		//@parm Not used
	DWORD	cBytes)		//@parm Count of bytes to alloc
{
	return PvAlloc(cBytes, 0);
}

/*
 * 	OlsDisposePtr(pols, pv)
 *
 *	@func
 *		Memory deallocator.
 */
void WINAPI OlsDisposePtr(
	POLS	pols,		//@parm Not used
	void *	pv)			//@parm [in]: ptr to free
{
	FreePv(pv);
}

/*
 * 	OlsDisposePtr(pols, pv, cBytes)
 *
 *	@func
 *		Memory reallocator.
 */
void* WINAPI OlsReallocPtr(
	POLS	pols,		//@parm Not used
	void *	pv, 		//@parm [in/out]: ptr to realloc
	DWORD	cBytes)		//@parm Count of bytes to realloc
{
	return PvReAlloc(pv, cBytes);
}

const REVERSEINIT reverseinit =
{
	REVERSE_VERSION,
	wchObjectEnd
};

LSERR WINAPI OlsGetObjectHandlerInfo(
	POLS	pols,
	DWORD	idObj, 
	void *	pObjectInfo)
{
	switch (idObj)
	{
	case OBJID_REVERSE:
		memcpy(pObjectInfo, (void *)&reverseinit, sizeof(REVERSEINIT));
		break;
	default:
		AssertSz(0, "Undefined Object handler. Add missing case.");
	}
	return lserrNone;
}

#ifdef DEBUG
/* Debugging APIs */
void WINAPI OlsAssertFailed(
	char *sz,
	char *szFile,
	int	  iLine)
{
	AssertSzFn(sz, szFile, iLine);
}
#endif


extern const LSCBK lscbk =
{
	OlsNewPtr,					// pfnNewPtr
	OlsDisposePtr,				// pfnDisposePtr
	OlsReallocPtr,				// pfnReallocPtr
	OlsFetchRun,				// pfnFetchRun
	OlsGetAutoNumberInfo,		// pfnGetAutoNumberInfo
	OlsGetNumericSeparators,	// pfnGetNumericSeparators
	OlsCheckForDigit,			// pfnCheckForDigit
	OlsFetchPap,				// pfnFetchPap
	OlsFetchTabs,				// pfnFetchTabs
	OlsGetBreakThroughTab,		// pfnGetBreakThroughTab
	OlsFGetLastLineJustification,// pfnFGetLastLineJustification
	OlsCheckParaBoundaries,		// pfnCheckParaBoundaries
	OlsGetRunCharWidths,		// pfnGetRunCharWidths
	OlsCheckRunKernability,		// pfnCheckRunKernability
	OlsGetRunCharKerning,		// pfnGetRunCharKerning
	OlsGetRunTextMetrics,		// pfnGetRunTextMetrics
	OlsGetRunUnderlineInfo,		// pfnGetRunUnderlineInfo
	OlsGetRunStrikethroughInfo,	// pfnGetRunStrikethroughInfo
	0,							// pfnGetBorderInfo
	OlsReleaseRun,				// pfnReleaseRun
	OlsHyphenate,				// pfnHyphenate
	OlsGetHyphenInfo,			// pfnGetHyphenInfo
	OlsDrawUnderline,			// pfnDrawUnderline
	OlsDrawStrikethrough,		// pfnDrawStrikethrough
	0,							// pfnDrawBorder
	0,							// pfnDrawUnderlineAsText //REVIEW (keithcu) Need to implement this??
	OlsFInterruptUnderline,		// pfnFInterruptUnderline
	0,							// pfnFInterruptShade
	0,							// pfnFInterruptBorder
	0,							// pfnShadeRectangle
	OlsDrawTextRun,				// pfnDrawTextRun
	0,							// pfnDrawSplatLine
#ifdef NOCOMPLEXSCRIPTS
	0,
	0,
	0,
	OlsResetRunContents,		// pfnResetRunContents
	0,
#else
	OlsFInterruptShaping,		// pfnFInterruptShaping
	OlsGetGlyphs,				// pfnGetGlyphs
	OlsGetGlyphPositions,		// pfnGetGlyphPositions
	OlsResetRunContents,		// pfnResetRunContents
	OlsDrawGlyphs,				// pfnDrawGlyphs
#endif
	0,							// pfnGetGlyphExpansionInfo
	0,							// pfnGetGlyphExpansionInkInfo
	0,							// pfnGetEms
	0,							// pfnPunctStartLine
	0,							// pfnModWidthOnRun
	0,							// pfnModWidthSpace
	0,							// pfnCompOnRun
	0,							// pfnCompWidthSpace
	0,							// pfnExpOnRun
	0,							// pfnExpWidthSpace
	0,							// pfnGetModWidthClasses
	OlsGetBreakingClasses,		// pfnGetBreakingClasses
	OlsFTruncateBefore,			// pfnFTruncateBefore
	OlsCanBreakBeforeChar,		// pfnCanBreakBeforeChar
	OlsCanBreakAfterChar,		// pfnCanBreakAfterChar
	0,							// pfnFHangingPunct
	0,							// pfnGetSnapGrid
	0,							// pfnDrawEffects
	0,							// pfnFCancelHangingPunct
	0,							// pfnModifyCompAtLastChar
	0,							// pfnEnumText
	0,							// pfnEnumTab
	0,							// pfnEnumPen
	OlsGetObjectHandlerInfo,	// pfnGetObjectHandlerInfo
#ifdef DEBUG
	OlsAssertFailed				// pfnAssertFailed
#else
	0							// pfnAssertFailed
#endif
};

#endif // NOLINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\olsole.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLSOLE.CPP -- OlsOle LineServices object class
 *	
 *	Author:
 *		Murray Sargent (with lots of help from RickSa's ols code)
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#ifndef NOLINESERVICES

#include "_font.h"
#include "_edit.h"
#include "_disp.h"
#include "_ols.h"
#include "_render.h"
extern "C" {
#include "objdim.h"
#include "pobjdim.h"
#include "plsdnode.h"
#include "dispi.h"
#include "pdispi.h"
#include "fmti.h"
#include "lsdnset.h"
#include "lsdnfin.h"
#include "brko.h"
#include "pbrko.h"
#include "locchnk.h"
#include "lsqout.h"
#include "lsqin.h"
#include "lsimeth.h"
}

extern BOOL g_OLSBusy;

/*
 *	OlsOleCreateILSObj(pols, plsc, pclscbk, dword, ppilsobj)
 *
 *	@func
 *		Create LS Ole object handler. We don't have any need for
 *		this, so just set it to 0.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateILSObj(
	POLS	 pols,		//[IN]: COls * 
	PLSC	 plsc,  	//[IN]: LineServices context
	PCLSCBK,
	DWORD,
	PILSOBJ *ppilsobj)	//[OUT]: ptr to ilsobj
{
	*ppilsobj = 0;
	return lserrNone;
}

/*
 *	OlsOleDestroyILSObj(pilsobj)
 *
 *	@func
 *		Destroy LS Ole handler object. Nothing to do, since we don't
 *		use the ILSObj.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyILSObj(
	PILSOBJ pilsobj)
{
	return lserrNone;
}

/*
 *	OlsOleSetDoc(pilsobj, pclsdocinf)
 *
 *	@func
 *		Set doc info. Nothing to do for Ole objects
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetDoc(
	PILSOBJ, 
	PCLSDOCINF)
{
	// Ole objects don't care about this
	return lserrNone;
}

/*
 *	OlsOleCreateLNObj(pilsobj, pplnobj)
 *
 *	@func
 *		Create the line object. Nothing needed in addition to the ped,
 *		so just return the ped as the LN object.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateLNObj(
	PCILSOBJ pilsobj, 
	PLNOBJ * pplnobj)
{
	*pplnobj = (PLNOBJ)g_pols->_pme->GetPed();			// Just the ped
	return lserrNone;
}

/*
 *	OlsOleDestroyLNObj(plnobj)
 *
 *	@func
 *		Destroy LN object. Nothing to do, since ped is destroyed
 *		elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyLNObj(
	PLNOBJ plnobj)
{
	return lserrNone;
}

/*
 *	OlsOleFmt(plnobj, pcfmtin, pfmres)
 *
 *	@func
 *		Compute dimensions of a particular Ole object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFmt(
	PLNOBJ	plnobj, 
	PCFMTIN pcfmtin, 
	FMTRES *pfmres)
{
	const LONG		cp = pcfmtin->lsfrun.plsrun->_cp; //Cannot trust LS cps
	LONG			dup = 0;
	LSERR			lserr;
	OBJDIM			objdim;
	CMeasurer *		pme = g_pols->_pme;
	COleObject *	pobj = pme->GetObjectFromCp(cp);
	Assert(pobj);

	ZeroMemory(&objdim, sizeof(objdim));

	pobj->MeasureObj(pme->_dvrInch, pme->_durInch, objdim.dur, objdim.heightsRef.dvAscent,
					 objdim.heightsRef.dvDescent, pcfmtin->lstxmRef.dvDescent, pme->GetTflow());
	
	pobj->MeasureObj(pme->_dvpInch, pme->_dupInch, dup, objdim.heightsPres.dvAscent,
					 objdim.heightsPres.dvDescent, pcfmtin->lstxmPres.dvDescent, pme->GetTflow());

	pobj->_plsdnTop = pcfmtin->plsdnTop;

	lserr = g_plsc->dnFinishRegular(1, pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, (PDOBJ)pobj, &objdim);
	if(lserrNone == lserr) 
	{
		lserr = g_plsc->dnSetRigidDup(pcfmtin->plsdnTop, dup);
		if(lserrNone == lserr) 
		{
			*pfmres = fmtrCompletedRun;

			if (pcfmtin->lsfgi.urPen + objdim.dur > pcfmtin->lsfgi.urColumnMax 
				&& !pcfmtin->lsfgi.fFirstOnLine)
			{
				*pfmres = fmtrExceededMargin;
			}
		}
	}
	return lserr;
}


/*
 *	OlsOleTruncateChunk(plocchnk, posichnk)
 *
 *	@func
 *		Truncate chunk plocchnk at the point posichnk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleTruncateChunk(
	PCLOCCHNK plocchnk,		// (IN): locchnk to truncate
	PPOSICHNK posichnk)		// (OUT): truncation point
{
	LSERR			lserr;
	OBJDIM			objdim;
	PLSCHNK 		plschnk = plocchnk->plschnk;
	COleObject *	pobj;
	long			ur	 = plocchnk->lsfgi.urPen;
	long			urColumnMax = plocchnk->lsfgi.urColumnMax;

	for(DWORD i = 0; ur <= urColumnMax; i++)
	{
		AssertSz(i < plocchnk->clschnk,	"OlsOleTruncateChunk: exceeded group of chunks");

		pobj = (COleObject *)plschnk[i].pdobj;
		Assert(pobj);

		lserr = g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &objdim);
		if(lserr != lserrNone)
			return lserr;

		ur += objdim.dur;
	}
	posichnk->ichnk = i - 1;
	posichnk->dcp	= 1;
	return lserrNone;
}
/*
 *	OlsOleFindPrevBreakChunk(plocchnk, pposichnk, brkcond, pbrkout)
 *
 *	@func
 *		Find previous break in chunk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFindPrevBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	BRKCOND		brkcond,	//(IN): recommendation about break after chunk
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (pposichnk->ichnk == ichnkOutside && (brkcond == brkcondPlease || brkcond == brkcondCan))
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
		pbrkout->posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
	}
	else
		pbrkout->brkcond = brkcondPlease;

	return lserrNone;
}


/*
 *	OlsOleForceBreakChunk(plocchnk, pposichnk, pbrkout)
 *
 *	@func
 *		Called when forced to break a line.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleForceBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->fSuccessful = fTrue;

	if (plocchnk->lsfgi.fFirstOnLine && pposichnk->ichnk == 0 || pposichnk->ichnk == ichnkOutside)
		{
		pbrkout->posichnk.dcp = 1;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[0].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
		}
	else
		{
		pbrkout->posichnk.ichnk = pposichnk->ichnk;
		pbrkout->posichnk.dcp = 0;
		}

	return lserrNone;
}

/*
 *	OlsOleSetBreak(pdobj, brkkind, nBreakRecord, rgBreakRecord, nActualBreakRecord)
 *
 *	@func
 *		Set break
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetBreak(
	 PDOBJ pdobj,				// (IN): dobj which is broken
	 BRKKIND  brkkind,			// (IN): Previous/Next/Force/Imposed was chosen
	 DWORD	nBreakRecord,		// (IN): size of array
	 BREAKREC* rgBreakRecord,	// (OUT): array of break records
	 DWORD* nActualBreakRecord)	// (OUT): actual number of used elements in array
{
	return lserrNone;
}

LSERR WINAPI OlsOleGetSpecialEffectsInside(
	PDOBJ pdobj,			// (IN): dobj
	UINT *pEffectsFlags)	// (OUT): Special effects for this object
{
	*pEffectsFlags = 0;
	return lserrNone;
}

LSERR WINAPI OlsOleCalcPresentation(
	PDOBJ,					// (IN): dobj
	long,					// (IN): dup of dobj
	LSKJUST,				// (IN): LSKJUST
	BOOL fLastVisibleOnLine)// (IN): this object is last visible object on line
{
	return lserrNone;
}

/*
 *	OlsOleQueryPointPcp(pdobj, ppointuvQuery, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object PointFromCp.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryPointPcp(
	PDOBJ	  pdobj,			//(IN): dobj to query
	PCPOINTUV ppointuvQuery,	//(IN): query point (uQuery,vQuery)
    PCLSQIN	  plsqin,			//(IN): query input
    PLSQOUT	  plsqout)			//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}
	
/*
 *	OlsOleQueryCpPpoint(pdobj, dcp, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object CpFromPoint.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryCpPpoint(
	PDOBJ	pdobj,		//(IN): dobj to query
	LSDCP	dcp,		//(IN):  dcp for query
    PCLSQIN	plsqin,		//(IN): query input
    PLSQOUT	plsqout)	//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}

/*
 *	OlsOleDisplay(pdobj, pcdispin)
 *
 *	@func
 *		Display object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDisplay(
	PDOBJ	 pdobj,			//(IN): dobj to query
	PCDISPIN pcdispin)		//(IN): display info
{
	COleObject *pobj = (COleObject *)pdobj;
	Assert(pobj);

	CRenderer  *pre = g_pols->GetRenderer();
	const CDisplay *pdp = pre->GetPdp();
	
	POINTUV ptuv = {pcdispin->ptPen.x, pcdispin->ptPen.y - pre->GetLine().GetDescent()};

	if (pcdispin->lstflow == lstflowWS)
		ptuv.u -= pcdispin->dup - 1;

	pre->SetSelected(pcdispin->plsrun->IsSelected());
	pre->Check_pccs();
	pre->SetFontAndColor(pcdispin->plsrun->_pCF);

	if (pre->_fEraseOnFirstDraw)
		pre->EraseLine();

	pre->SetCurPoint(ptuv);
	pre->SetClipLeftRight(pcdispin->dup);

	if (!pobj->FWrapTextAround())
	{
		COls			*polsOld = g_pols;
		CLineServices	*plscOld = g_plsc;
		BOOL			fOLSBusyOld = g_OLSBusy;

		BOOL	fRestore = FALSE;

		if (g_plsc && g_pols)
		{
			// This is to fix a re-entrance problem.  
			// We first NULL out the two globals.  If the OleObject is using Richedit, it will
			// create a new LineService context.  By the time it get back to here, we will free that
			// context and restore the current context.  This is necessary since LineService will returns
			// error when we are using the same context in the Parent and then in the Ole Object using RE.
			g_plsc = NULL;
			g_pols = NULL;
			g_OLSBusy = FALSE;
			fRestore = TRUE;
		}
		pobj->DrawObj(pdp, pre->_dvpInch, pre->_dupInch, pre->GetDC(), &pre->GetClipRect(), pdp->IsMetafile(), 
					 &ptuv, pcdispin->ptPen.y - ptuv.v, pre->GetLine().GetDescent(), pre->GetTflow());

		if (fRestore)
		{
			// Time to delete the new context created within the DrawObject.
			if (g_pols)
				delete g_pols;

			// Restore old globals
			g_pols = polsOld;
			g_plsc = plscOld;
			g_OLSBusy = fOLSBusyOld;
		}
	}
	return lserrNone;
}

/*
 *	OlsOleDistroyDObj(pdobj)
 *
 *	@func
 *		Destroy object: nothing to do since object is destroyed elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyDObj(
	PDOBJ pdobj)
{
	return lserrNone;
}


extern const LSIMETHODS vlsimethodsOle =
{
	OlsOleCreateILSObj,
	OlsOleDestroyILSObj,
    OlsOleSetDoc,
    OlsOleCreateLNObj,
    OlsOleDestroyLNObj,
	OlsOleFmt,
	0,//OlsOleFmtResume
	0,//OlsOleGetModWidthPrecedingChar
	0,//OlsOleGetModWidthFollowingChar
    OlsOleTruncateChunk,
    OlsOleFindPrevBreakChunk,
    0,//OlsOleFindNextBreakChunk
    OlsOleForceBreakChunk,
    OlsOleSetBreak,
	OlsOleGetSpecialEffectsInside,
	0,//OlsOleFExpandWithPrecedingChar
	0,//OlsOleFExpandWithFollowingChar
	OlsOleCalcPresentation,
	OlsOleQueryPointPcp,
	OlsOleQueryCpPpoint,
	0,//pfnEnum
    OlsOleDisplay,
    OlsOleDestroyDObj
};
#endif		// NOLINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\osdc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OSDC.CPP -- Off Screen DC class |
 *
 *		This contains method used to implement the off screen
 *		DC class
 *	
 *	Owner:<nl>
 *		Rick Sailor
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_osdc.h"

ASSERTDATA

/*
 *	COffscreenDC::GetDimensions(pdx, pdy)
 *
 *	@mfunc	
 *		return the current height of the osdc
 *
 *	@rdesc
 *		height of the osdc
 */
void COffscreenDC::GetDimensions(long *pdx, long *pdy)
{
	Assert(_hbmp);
	BITMAP bitmap;
	W32->GetObject(_hbmp, sizeof(BITMAP), &bitmap);
	*pdx = bitmap.bmWidth;
	*pdy = bitmap.bmHeight;
}

/*
 *	COffscreenDC::Init(hdc, xWidth, yHeight, crBackground)
 *
 *	@mfunc	
 *		Initialize off screen DC with compatible bitmap
 *
 *	@rdesc
 *		HDC created
 */
HDC	COffscreenDC::Init(
	HDC		 hdc,			//@parm DC to be compatible with
	LONG	 xWidth,		//@parm Width of compatible bitmap
	LONG	 yHeight,		//@parm Height of compatible bitmap
	COLORREF crBackground)	//@parm Default background for bitmap
{
	if (_hdc)
		return _hdc;

	HDC hdcRet	= NULL;					// HDC to return to caller
	_hbmpOld	= NULL;					// Assume failure
	_hbmp		= NULL;
	_hpalOld	= NULL;

	// Create memory DC
	_hdc = CreateCompatibleDC(hdc);
	if(_hdc)
	{
		// Create bitmap based on size of client rectangle
		_hbmp = CreateCompatibleBitmap(hdc, xWidth, yHeight);
		if(_hbmp)
		{
			// Select bitmap into hdc
			_hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
			if(_hbmpOld && SetBkColor(_hdc, crBackground) != CLR_INVALID)
				hdcRet = _hdc;
		}
	}
	if(!hdcRet)
		FreeData();

	return hdcRet;
}

/*
 *	COffscreenDC::SelectPalette(hpal)
 *
 *	@mfunc	
 *		Set a new palette into the hdc
 */
void COffscreenDC::SelectPalette(
	HPALETTE hpal)			//@parm Handle to palette to set
{
#ifndef NOPALETTE
	if(hpal)
	{
		_hpalOld = ::SelectPalette(_hdc, hpal, TRUE);
		RealizePalette(_hdc);
	}
#endif
}

/*
 *	COffscreenDC::FreeData()
 *
 *	@mfunc	
 *		Free resources associated with bitmap
 */
void COffscreenDC::FreeData()
{
	if(_hdc)
	{
#ifndef NOPALETTE
		if(_hpalOld)
			::SelectPalette(_hdc, _hpalOld, TRUE);
#endif
		if(_hbmpOld)
			SelectObject(_hdc, _hbmpOld);

		if(_hbmp)
		{
			DeleteObject(_hbmp);
			_hbmp = NULL;
		}

		DeleteDC(_hdc);

		_hdc = NULL;
	}
}

/*
 *	COffscreenDC::Realloc(xWidth, yHeight)
 *
 *	@mfunc	
 *		Reallocate bitmap
 *
 *	@rdesc
 *		TRUE - succeeded 
 *		FALSE - failed
 */
BOOL COffscreenDC::Realloc(
	LONG xWidth,			//@parm Width of new bitmap
	LONG yHeight)			//@parm Height of new bitmap
{
	// Create bitmap based on size of client rectangle
	HBITMAP hbmpNew = CreateCompatibleBitmap(_hdc, xWidth, yHeight);

	if(!hbmpNew)
	{
		AssertSz(FALSE,	"COffscreenDC::Realloc CreateCompatibleBitmap failed"); 
		return FALSE;
	}

	SelectObject(_hdc, hbmpNew);

	// Delete old bitmap
	DeleteObject(_hbmp);

	// Put in new bitmap
	_hbmp = hbmpNew;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\render.cpp ===
/*
 *	@doc INTERNAL
 *	
 *	@module - RENDER.CPP |
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Keith Curtis (simplified, cleaned up, added support
 *		for non-western textflows.)
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_render.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_layout.h"

// Default colors for background and text on window's host printer
const COLORREF RGB_WHITE = RGB(255, 255, 255);
const COLORREF RGB_BLACK = RGB(0, 0, 0);
const COLORREF RGB_BLUE  = RGB(0, 0, 255);

ASSERTDATA

extern const COLORREF g_Colors[];
static HBITMAP g_hbitmapSubtext = 0;
static HBITMAP g_hbitmapExpandedHeading = 0;
static HBITMAP g_hbitmapCollapsedHeading = 0;
static HBITMAP g_hbitmapEmptyHeading = 0;

void ShiftRect(
	RECTUV &rc,		//@parm rectangle
	LONG	dup,	//@parm shift in u direction
	LONG	dvp)	//@parm shift in v direction
{
	rc.left		-= dup;
	rc.right	-= dup;
	rc.top		-= dvp;
	rc.bottom	-= dvp;
}

HRESULT InitializeOutlineBitmaps()
{
    g_hbitmapSubtext = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_SUBTEXT));
    g_hbitmapExpandedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EXPANDED_HEADING));
    g_hbitmapCollapsedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_COLLAPSED_HEADING));
    g_hbitmapEmptyHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EMPTY_HEADING));

    if (!g_hbitmapSubtext ||
        !g_hbitmapExpandedHeading ||
        !g_hbitmapCollapsedHeading ||
        !g_hbitmapEmptyHeading)
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

void ReleaseOutlineBitmaps()
{
    if (g_hbitmapSubtext)
	{
        DeleteObject(g_hbitmapSubtext);
		DeleteObject(g_hbitmapExpandedHeading);
		DeleteObject(g_hbitmapCollapsedHeading);		
		DeleteObject(g_hbitmapEmptyHeading);
	}
}

/*
 *	CBrush::~CBrush()
 */
CBrush::~CBrush()
{
	if(_hbrush)					// Is NULL if all line borders have 0 width
	{							//  in which case, _hbrushOld is undefined
		SelectObject(_pre->GetDC(), _hbrushOld);
		DeleteObject(_hbrush);
	}
}

/*
 *	CBrush::Draw(x1, y1, x2, y2, dxpLine, cr, fHideGridLines)
 *
 *	@mfunc
 *		Draw a line from (x1, y1) to (x2, y2) with the pen width dxpLine
 *		and color cr.
 */
void CBrush::Draw(
	LONG u1,			//@parm Line starting x coord 
	LONG v1,			//@parm Line starting y coord
	LONG u2,			//@parm Line ending x coord
	LONG v2,			//@parm Line ending y coord
	LONG dxpLine,		//@parm Width of line to draw
	COLORREF cr,		//@parm Color to use
	BOOL fHideGridLines)//@parm If TRUE, hide 0-width gridlines
{
	if(!dxpLine)
	{
		if(fHideGridLines)			// Hide 0-width grid lines
			return;
		cr = RGB(192, 192, 192);	// Display 0-width grid lines as 1-pixel
		dxpLine = 1;				//  gray lines as in Word
	}

	HDC hdc = _pre->GetDC();

	if(!_hbrush || _cr != cr)
	{
		HBRUSH hbrush = CreateSolidBrush(cr);
		HBRUSH hbrushOld = (HBRUSH)SelectObject(hdc, hbrush);

		if(!_hbrush)
			_hbrushOld = hbrushOld;	// Save original brush
		else
			DeleteObject(hbrushOld);

		_hbrush = hbrush;			// Update CPen state
		_cr = cr;
	}
	RECTUV rcuv;					// Convert to rcuv in case of rotation
	
	rcuv.left = u1;
	rcuv.top = v1;
	if(u1 == u2)					// Vertical line
	{								//  (in uv space)
		rcuv.right = rcuv.left + dxpLine;
		rcuv.bottom = v2;
	}
	else							// Horizontal line
	{								//  (in uv space)
		rcuv.right = u2;
		rcuv.bottom = rcuv.top + dxpLine;
	}

	RECT rc;						// Convert uv to xy space
	_pre->GetPdp()->RectFromRectuv(rc, rcuv);

	PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
		   rc.bottom - rc.top, PATCOPY);
}

/*
 * 	IsTooSimilar(cr1, cr2)
 *
 *	@mfunc
 *		Return TRUE if the colors cr1 and cr2 are so similar that they
 *		are hard to distinguish. Used for deciding to use reverse video
 *		selection instead of system selection colors.
 *
 *	@rdesc
 *		TRUE if cr1 is too similar to cr2 to be used for selection
 *
 *	@devnote
 *		The formula below uses RGB. It might be better to use some other
 *		color representation such as hue, saturation, and luminosity
 */
BOOL IsTooSimilar(
	COLORREF cr1,		//@parm First color for comparison
	COLORREF cr2)		//@parm Second color for comparison
{
	if((cr1 | cr2) & 0xFF000000)			// One color and/or the other
		return FALSE;						//  isn't RGB, so algorithm
											//  doesn't apply
	LONG DeltaR = abs(GetRValue(cr1) - GetRValue(cr2));
	LONG DeltaG = abs(GetGValue(cr1) - GetGValue(cr2));
	LONG DeltaB = abs(GetBValue(cr1) - GetBValue(cr2));

	return DeltaR + DeltaG + DeltaB < 80;
}

/*
 * 	GetShadedColor(crf, crb, iShading)
 *
 *	@mfunc
 *		Return shaded color given by a mixture of crf and crb as determined
 *		by iShading. Used for table cell coloration.
 *
 *	@rdesc
 *		Shaded color
 */
COLORREF GetShadedColor(
	COLORREF crf,
	COLORREF crb,
	LONG	 iShading)
{
	if ((crb | crf) & 0xFF000000 ||		// One or the other isn't an RGB
		!iShading)						//  or no shading:
	{
		return crb;						//  just use crb
	}

	DWORD red   = ((300 - iShading)*GetRValue(crb) + iShading*GetRValue(crf))/300; 
	DWORD green = ((300 - iShading)*GetGValue(crb) + iShading*GetGValue(crf))/300; 
	DWORD blue  = ((300 - iShading)*GetBValue(crb) + iShading*GetBValue(crf))/300;

	return RGB(red, green, blue);
}


// CRenderer class

CRenderer::CRenderer (const CDisplay * const pdp) :
	CMeasurer (pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}	
 
CRenderer::CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp) :
	CMeasurer (pdp, rtp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}

CRenderer::~CRenderer()
{
	if(_hdcBitmap)
	{
		SelectObject(_hdcBitmap, _hbitmapSave);
		DeleteDC(_hdcBitmap);
	}
}

/*
 *	CRenderer::Init()
 *
 *	@mfunc
 *		Initialize most things to zero
 */
void CRenderer::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::Init");
	_fRenderer = TRUE;
	CTxtEdit *ped	= GetPed();
	_cpAccelerator = ped->GetCpAccelerator();

	static const RECTUV zrect = { 0, 0, 0, 0 };
	_rcView		= zrect;
	_rcRender	= zrect;	  
	_rc			= zrect;
	_dupLine	= 0;
	_dwFlags	= 0;
	_hdcBitmap	= NULL;
	_ptCur.u	= 0;
	_ptCur.v	= 0;
	_plogpalette   = NULL;

	CDocInfo *pDocInfo = ped->GetDocInfoNC();
	if(pDocInfo)
	{
		_dxBitmap = _pdp->LXtoDX(pDocInfo->_xExtGoal*pDocInfo->_xScale / 100);
		_dyBitmap = _pdp->LYtoDY(pDocInfo->_yExtGoal*pDocInfo->_yScale / 100);
	}
													 
	_crCurTextColor = CLR_INVALID;

	_fRenderSelection = ped->GetSel() && ped->GetSel()->GetShowSelection();
	_fErase = !_pdp->IsTransparent();

	if(!ped->fInOurHost() || !_pdp->IsPrinter())
	{
		// If we are displaying to a window, or we are not in the window's
		// host, we use the colors specified by the host. For text and
		// foreground.
		_crBackground = ped->TxGetBackColor();
		_crTextColor  = ped->TxGetForeColor();
	}
	else
	{
		// When the window's host is printing, the default colors are white
		// for the background and black for the text.
		_crBackground = RGB_WHITE;
		_crTextColor  = RGB_BLACK;
	}

	_hdc = _pdp->GetDC();

	::SetBkColor (_hdc, _crBackground);
	_crCurBackground = _crBackground;

	// For hack around ExtTextOutW OnWin9x EMF problems
	_fEnhancedMetafileDC = IsEnhancedMetafileDC(_hdc);

	_fDisplayDC = GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASDISPLAY;

	// Set text alignment
	// Its much faster to draw using top/left alignment than to draw
	// using baseline alignment.
	SetTextAlign(_hdc, TA_TOP | TA_LEFT);
	SetBkMode(_hdc, TRANSPARENT);
}
 
/*
 * 	CRenderer::StartRender (&rcView, &rcRender)
 *
 *	@mfunc
 *		Prepare this renderer for rendering operations
 *
 *	@rdesc
 *		FALSE if nothing to render, TRUE otherwise	
 */
BOOL CRenderer::StartRender (
	const RECTUV &rcView,		//@parm View rectangle
	const RECTUV &rcRender)		//@parm Rectangle to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartRender");

	// Set view and rendering rects
	_rcView   = rcView;
	_rcRender = rcRender;

	// If this isn't a metafile, we set a flag indicating whether we
	// can safely erase the background
	if(_pdp->IsMetafile() || !_pdp->IsMain())
	{
		// Since this isn't the main display or it is a metafile,
		// we want to ignore the logic to render selections
		_fRenderSelection = FALSE;

		if(_fErase)							// If control is not transparent,
			EraseTextOut(_hdc, &rcRender);	//  clear display

		// This is a metafile or a printer so clear the render rectangle 
		// and then pretend we are transparent.
		_fErase = FALSE;
	}

	return TRUE;
}

/*
 *	CRenderer::EraseLine()
 *
 *	@mfunc
 *		Erase the line
 */
void CRenderer::EraseLine()
{
	Assert(_fEraseOnFirstDraw);
	COLORREF crOld = SetBkColor(_hdc, _crBackground);

	EraseTextOut(_hdc, &_rcErase);
	SetBkColor(_hdc, crOld);
	_fEraseOnFirstDraw = FALSE;
}

/*
 *	CRenderer::EraseRect(prc, crBack)
 *
 *	@mfunc
 *		Erase a specific rectangle for special table cell background color
 *
 *	@rdesc
 *		Old value of _fErase
 */
BOOL CRenderer::EraseRect(
	const RECTUV *prc,		//@parm RECT to erase
	COLORREF	  crBack)	//@parm Background color to use
{
	SetDefaultBackColor(crBack);
	EraseTextOut(_hdc, prc, TRUE);
	BOOL fErase = _fErase;
	_fErase = FALSE;
	return fErase;
}

/*
 *	CRenderer::IsSimpleBackground()
 *
 *	@mfunc
 *		Return TRUE if the background is opaque
 */
BOOL CRenderer::IsSimpleBackground() const
{
	CDocInfo *pDocInfo = GetPed()->GetDocInfoNC();

	if (!pDocInfo || pDocInfo->_nFillType != 7 && !IN_RANGE(1, pDocInfo->_nFillType, 3))
		return TRUE;
	return FALSE;
}

/*
 *	CRenderer::EraseTextOut(hdc, prc, fSimple)
 *
 *	@mfunc
 *		Erase a specific area
 */
void CRenderer::EraseTextOut(
	HDC		hdc,
	const RECTUV *prc,
	BOOL	fSimple)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EraseTextOut");

	CDocInfo *pDocInfo = GetPed()->GetDocInfoNC();
	RECT	  rc;

	_pdp->RectFromRectuv(rc, *prc);

	if (fSimple || IsSimpleBackground())	// No special background
	{
		W32->EraseTextOut(hdc, &rc);
		return;
	}

	// To do background gradients and bitmap fills with rotated coords, need
	// to use rc as above and translate calls to _pdp->GetUpScroll() and
	// _pdp->GetVpScroll().	For directions other than tflowES get rid of
	// screen width and height offsets used in PointFromPointuv(), but keep
	// the minus signs.
	LONG	uScroll = _pdp->GetUpScroll();
	LONG	vScroll = _pdp->GetVpScroll();
	POINT	ptScroll = {uScroll, vScroll};	// Default unrotated

	TFLOW tflow = _pdp->GetTflow();
	switch(tflow)
	{
		case tflowSW:						// Vertical
			ptScroll.x = -vScroll;		
			ptScroll.y = uScroll;
			break;

		case tflowWN:
			ptScroll.x = -uScroll;
			ptScroll.y = -vScroll;
			break;

		case tflowNE:
			ptScroll.x = vScroll;
			ptScroll.y = -uScroll;
			break;
	}

	if(IN_RANGE(1, pDocInfo->_nFillType, 3))
	{
		if(!pDocInfo->_hBitmapBack)
			return;

		if(!_hdcBitmap)
		{
			// Setup compatible DC to use for background BitBlts for
			// the lifetime of this renderer
			_hdcBitmap = CreateCompatibleDC(hdc);
			if(!_hdcBitmap)
				return;						// Out of memory
			_hbitmapSave = (HBITMAP)SelectObject(_hdcBitmap, pDocInfo->_hBitmapBack);
		}

		LONG wBitmap = _dxBitmap;
		LONG hBitmap = _dyBitmap;

		LONG yb = (ptScroll.y + rc.top) % hBitmap;
		if(yb < 0)							
			yb += hBitmap;
		LONG h = hBitmap - yb;
		LONG y = rc.top;

		while(y < rc.bottom)
		{
			if(y + h > rc.bottom)			// Don't overshoot bottom
				h = rc.bottom - y;
			LONG xb = (ptScroll.x + rc.left) % wBitmap;
			if(xb < 0)						// xb can be < 0 if ptScroll.x < 0
				xb += wBitmap;
			LONG w = wBitmap - xb;
			LONG x = rc.left;

			while(x < rc.right)
			{
				if(x + w > rc.right)		// Don't overshoot right
					w = rc.right - x;
				BitBlt(hdc, x, y, w, h, _hdcBitmap, xb, yb, SRCCOPY);
				x += w; 
				w = wBitmap;
				xb = 0;
			}
			y += h;
			h = hBitmap;
			yb = 0;
		}
		return;
	}

	// Gradient fill backgrounds
	LONG	 Angle = pDocInfo->_sFillAngle;
	COLORREF crb = pDocInfo->_crColor;
	COLORREF crf = pDocInfo->_crBackColor;
	LONG	 di = ptScroll.x;				// Default vertical values
	LONG	 h = 0;
	HPEN	 hpen = NULL;
	HPEN	 hpenEntry = NULL;
	LONG	 iFirst = rc.left;
	LONG	 iLim = rc.right;
	LONG	 iShading;

	switch(Angle)
	{
		case -45:							// Diagonal down
		case -135:							// Diagonal	up
			h = rc.bottom - rc.top;
			if(Angle == -45)
			{
				di -= ptScroll.y + rc.top;
				iFirst -= h;
				h = -h;
			}
			else
			{
				di += ptScroll.y + rc.top;
				iLim += h;
			}
			break;

		case 0:								// Horizontal
			iFirst = rc.top;
			iLim = rc.bottom;
			di = ptScroll.y;
			break;
	}

	if(!crf)								// Moderate black a bit (needs work)
		crf = RGB(100, 100, 100);

	for(LONG i = iFirst; i < iLim; i++)
	{
		iShading = (di + i) % 600;
		if(iShading < 0)					// Pattern moves up screen
			iShading += 600;
		if(iShading > 300)
			iShading = 600 - iShading;

		iShading = max(iShading, 30);
		iShading = min(iShading, 270);

		if(hpen)
			DeleteObject(hpen);
		hpen = CreatePen(PS_SOLID, 0, GetShadedColor(crf, crb, iShading));
		if(!hpenEntry)
			hpenEntry = (HPEN)SelectObject(hdc, hpen);
		else
			SelectObject(hdc, hpen);

		POINT rgpt[2];
		if(Angle)							// -90 (vertical) or
		{									//  -135 (diagonal)
			if(i > rc.right)				// Don't let diagonal overshoot
			{
				rgpt[0].x = rc.right;
				rgpt[0].y = rc.top + (i - rc.right);
			}
			else
			{
				rgpt[0].x = i;
				rgpt[0].y = rc.top;
			}
			if(i - h < iFirst)				// Don't let diagonal undershoot
			{
				rgpt[1].x = iFirst - 1;
				rgpt[1].y = rc.bottom - (iFirst - 1 - (i - h));
			}
			else
			{
				rgpt[1].x = i - h;
				rgpt[1].y = rc.bottom;
			}
		}
		else								// Horizontal (0 degrees)
		{
			rgpt[0].x = rc.left;
			rgpt[0].y = i;
			rgpt[1].x = rc.right;
			rgpt[1].y = i;
		}
		Polyline(hdc, rgpt, 2);				// Use Polyline() so as not to
	}										//  break WinCE
	if(hpen)
	{
		DeleteObject(hpen);
		SelectObject(hdc, hpenEntry);
	}
}

/*
 *	CRenderer::DrawWrappedObjects(pliFirst, pliLast, cpFisrt, ptFirst, fLeft)
 *
 *	@mfunc
 *		Draw all wrapped objects in the range on the left or right side.
 *
 */
void CRenderer::DrawWrappedObjects(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst)
{
	for (BOOL fLeft = 0; fLeft != 2; fLeft ++) //For left and right sides...
	{
		CLine *pli = pliFirst;
		LONG cp = cpFirst;
		POINTUV pt = ptFirst;

		//If the first line is part-way through an object, then back up to the beginning.
		if (fLeft && pli->_cObjectWrapLeft || !fLeft && pli->_cObjectWrapRight)
		{
			while (fLeft ? !pli->_fFirstWrapLeft : !pli->_fFirstWrapRight)
			{
				pli--;
				pt.v -= pli->GetHeight();
				cp -= pli->_cch;
			}
		}

		for (;pli <= pliLast; cp += pli->_cch, pt.v += pli->GetHeight(), pli++)
		{
			//Did we find an object which needs to be drawn?
			if (fLeft && pli->_fFirstWrapLeft || !fLeft && pli->_fFirstWrapRight)
			{
				LONG cpObj = FindCpDraw(cp + 1, fLeft ? pli->_cObjectWrapLeft : pli->_cObjectWrapRight, fLeft);
				COleObject *pobj = GetObjectFromCp(cpObj);
				if (!pobj)
					return;

				LONG dvpAscent, dvpDescent, dup;
				pobj->MeasureObj(_dvpInch, _dupInch, dup, dvpAscent, dvpDescent, 0, GetTflow());

				POINTUV ptDraw = pt;
				if (!fLeft) //Right align images
					ptDraw.u += _pdp->GetDupView() - dup;

				RECTUV rc = {_rcRender.left, _rcView.top, _rcRender.right, _rcView.bottom};

				pobj->DrawObj(_pdp, _dvpInch, _dupInch, _hdc, &rc, _pdp->IsMetafile(), 
							 &ptDraw, dvpAscent + dvpDescent, 0, GetTflow());
				
			}
		}
	}
}

/*
 *	CRenderer::EndRender(pliFirst, pliLast, cpFirst, &ptFirst)
 *
 *	@mfunc
 *		Any final operations which are to happen after we've drawn
 *		all of the lines.
 */
void CRenderer::EndRender(
	CLine *	pliFirst, 
	CLine *	pliLast, 
	LONG	cpFirst, 
	const POINTUV &ptFirst)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EndRender");
	AssertSz(_hdc, "CRenderer::EndRender() - No rendering DC");

	if(_fErase && _ptCur.v < _rcRender.bottom)
	{
		RECTUV rc = _rcRender;
		rc.top = _ptCur.v;
		EraseTextOut(_hdc, &rc);
	}
	DrawWrappedObjects(pliFirst, pliLast, cpFirst, ptFirst);
}

/*
 *	CRenderer::NewLine (&li)
 *
 *	@mfunc
 *		Init this CRenderer for rendering the specified line
 */
void CRenderer::NewLine (
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::NewLine");

	_li = li;

	Assert(GetCp() + _li._cch <= GetTextLength());

	_cchLine = li._cch;
	_dupLine = _li._dup;
	_li._dup = 0;
	_ptCur.u = _rcView.left;
	if(!_pPF->InTable())
		_ptCur.u -= _pdp->GetUpScroll();
	_fSelected = _fSelectedPrev = FALSE;
}

/*
 *	CRenderer::SetupOffscreenDC(dup, dvp)
 *
 *	@mfunc
 *		Setup renderer for using an offscreen DC
 *
 *	@rdesc
 *		NULL - an error occurred<nl>
 *		~NULL - DC to save 
 */
HDC CRenderer::SetupOffscreenDC(
	LONG&	dup,		//@parm Offset to u
	LONG&	dvp,		//@parm Offset to v 
	BOOL fLastLine)
{
	// Save render DC
	CTxtEdit *ped		   = GetPed();
	BOOL	  fInOurHost   = ped->fInOurHost();

	HDC		hdcSave = _hdc;

	//If we've already erased (can't prevent flicker now!)
	//or this is some weird textflow, then don't do offscreens.
	if (!_fErase || GetTflow() != tflowES || ped->GetBackgroundType() != -1)
		return NULL;

	RECTUV rc;
	RECT rcBitmap;
	rc.left = _rcRender.left;
	rc.right = _rcRender.right;
	rc.top = _rc.top;
	rc.bottom = _rc.bottom;
	_pdp->RectFromRectuv(rcBitmap, rc);

	if (_osdc.GetDC() == NULL)
	{
		if (!_osdc.Init(_hdc, rcBitmap.right - rcBitmap.left, rcBitmap.bottom - rcBitmap.top, _crBackground))
			return NULL;

		HPALETTE hpal = fInOurHost ? ped->TxGetPalette() : (HPALETTE) GetCurrentObject(_hdc, OBJ_PAL);
		_osdc.SelectPalette(hpal);
	}
	else
	{
		LONG dx, dy;
		_osdc.GetDimensions(&dx, &dy);
		//REVIEW (keithcu) Simplify?
		if (IsUVerticalTflow(GetTflow()))
		{
			if (dx < rcBitmap.bottom - rcBitmap.top)
			{
				if (_osdc.Realloc(_rc.bottom - _rc.top + dy / 16, dy)) //Resize the bitmap, plus a little room
					return NULL;
			}

		}
		else if (dy < rcBitmap.bottom - rcBitmap.top)
		{
			if (_osdc.Realloc(dx, _rc.bottom - _rc.top + dy / 16)) //Resize the bitmap, plus a little room
				return NULL;
		}
	}

	_hdc = _osdc.GetDC();
	_crCurTextColor = CLR_INVALID;
	if(_pccs)
	{
		// There is current a character format for the run so we need to
		// get in sync with that since the offscreen DC isn't necessarily
		// set to that font.
		// Get the character format and set up the font
		SetFontAndColor(GetCF());
	}

	// We are rendering to a transparent background
	_fErase = FALSE;

	// Clear bitmap
	::SetBkColor(_hdc, _crBackground);
	_osdc.FillBitmap(rcBitmap.right - rcBitmap.left, rcBitmap.bottom - rcBitmap.top);

	//If the first line, erase to edge of rcRender
	if (_rc.top <= _rcView.top)
	{
		//Clear top of rcRender if necessary
		RECTUV rcErase = _rcRender;

		rcErase.top = min(_rcView.top, _rcRender.top);
		rcErase.bottom = _rc.top;

		if (rcErase.bottom > rcErase.top)
			EraseTextOut(hdcSave, &rcErase);
	}

	// Restore background color if necessary
	if(_crBackground != _crCurBackground)
		::SetBkColor(_hdc, _crCurBackground);

	SetBkMode(_hdc, TRANSPARENT);

	// Store v adjustment to use in rendering off-screen bitmap
	dvp = _rc.top;

	// Store u adjustment to use in rendering off-screen bitmap
	dup = _rcRender.left;

	// Normalize _rc, _rcView, & _rcRender
	ShiftRect(		_rc, dup, dvp);
	ShiftRect(	_rcView, dup, dvp);
	ShiftRect(_rcRender, dup, dvp);

	// Normalize _ptCur for rendering to off-screen bitmap
	_ptCur.u	-= dup;
	_ptCur.v	-= dvp;

	return hdcSave;
}

/*
 *	CRenderer::RenderOffscreenBitmap(hdc, dup, yAdj)
 *
 *	@mfunc
 *		Render off screen bitmap and restore the state of the render.
 */
void CRenderer::RenderOffscreenBitmap(
	HDC		hdc,		//@parm DC to render to
	LONG	dup,		//@parm offset to real u base
	LONG	dvp)		//@parm offset to real v base 
{	
	// Palettes for rendering bitmap
	HPALETTE hpalOld = NULL;
	HPALETTE hpalNew = NULL;

	// Restore pt
	_ptCur.u	+= dup;
	_ptCur.v	+= dvp;

	// Restore rect
	LONG dupTemp = -dup;
	LONG dvpTemp = -dvp;
	ShiftRect(		_rc, dupTemp, dvpTemp);
	ShiftRect(	_rcView, dupTemp, dvpTemp);
	ShiftRect(_rcRender, dupTemp, dvpTemp);

	// Create a palette if one is needed
	if(_plogpalette)
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);

	RECTUV rcuv = {dup, dvp, dup + _rcRender.right - _rcRender.left, dvp + _rc.bottom - _rc.top};
	RECT   rc;
	_pdp->RectFromRectuv(rc, rcuv);
	// Render bitmap to real DC and restore _ptCur & _rc
	_osdc.RenderBitMap(hdc, rc.left, rc.top, _rcRender.right - _rcRender.left, _rc.bottom - _rc.top);

	// Restore palette after render if necessary
	if(_plogpalette)				
	{
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);
		CoTaskMemFree(_plogpalette);
		_plogpalette = NULL;
	}

	// Restore HDC to actual render DC
	_hdc = hdc;

	// Set this flag to what it should be for restored DC
	_fErase = TRUE;

	_crCurTextColor = CLR_INVALID;

	// Reset screen DC font 
	// Set up font on non-screen DC
	// Force color resynch
	if(!FormatIsChanged())				// Not on a new block,
		SetFontAndColor(GetCF());		//  so just set font and color
	else
	{									// On new block,
		ResetCachediFormat();			//  so reset everything
		SetNewFont();
	}
}

/*
 *	CRenderer::RenderLine (&li, fLastLine)
 *
 *	@mfunc
 *		Render visible part of current line
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 *
 *	@devnote
 *		Only call this from CLine::RenderLine()
 */
BOOL CRenderer::RenderLine (
	CLine &	li,				//@parm Line to render
	BOOL	fLastLine)		//@parm True if last line in layout
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderLine");

	BYTE	bUnderlineSave = 0;
	LONG 	cch;
	LONG 	cchChunk;
	LONG	cchInTextRun;
	BOOL	fAccelerator = FALSE;
	const WCHAR * pstrToRender;
	CTempWcharBuf twcb;
	WCHAR	chPassword = GetPasswordChar();

	UpdatePF();

	// This is used as a temporary buffer so that we can guarantee that we will
	// display an entire format run in one ExtTextOut.
	WCHAR *	pszTempBuffer = NULL;

	NewLine(li);							// Init render at start of line
	_fLastChunk = FALSE;
	_ptCur.u += _li._upStart;				// Add in line left indent 

	// Allow for special rendering at start of line
	LONG cpSelMin, cpSelMost;
	LONG dup, dvp;
	HDC	 hdcSave = StartLine(li, fLastLine, cpSelMin, cpSelMost, dup, dvp);

	cch = _li._cch;
	if(chPassword && IsRich())
	{
		// It is kind of stupid to allow rich text password edit controls.
		// However, it does make it that much easier to create a password
		// edit control since you don't have to know to change the box to
		// plain. Anyway, if there is such a thing, we don't want to put
		// out password characters for EOPs in general and the final EOP
		// specifically. Therefore, the following ...
		if(_pdp->IsMultiLine())
			cch -= _li._cchEOP;
		else
			cch = GetPed()->GetAdjustedTextLength();
	}

	for(; cch > 0; cch -= cchChunk)
	{
		// Initial chunk (number of characters to render in a single TextOut)
		// is min between CHARFORMAT run length and line length. Start with
		// count of characters left in current format run
		cchChunk = GetCchLeftRunCF();
		AssertSz(cchChunk != 0, "empty CHARFORMAT run");

		DWORD dwEffects = GetCF()->_dwEffects;
		if(dwEffects & CFE_HIDDEN)			// Don't display hidden text
		{										
			Move(cchChunk);
			continue;
		}
		if(GetChar() == NOTACHAR)			// Ignore NOTACHAR code
		{
			Move(1);
			continue;
		}

		// Limit chunk to count of characters we want to display.
		cchChunk = min(cch, cchChunk);

		// Get count of characters in text run
		pstrToRender = _rpTX.GetPch(cchInTextRun);
		AssertSz(cchInTextRun > 0, "empty text run");

		if (cchInTextRun < cchChunk || chPassword || dwEffects & CFE_ALLCAPS)
		{
			// The count of contiguous chars in the backing store run is
			// less than the count of characters we wish to display or this
			// is a password control or we want all caps. We copy the data
			// out of the backing store.
			if(!pszTempBuffer)
			{
				// Allocate buffer big enough to handle all future
				// requests in this loop.
				pszTempBuffer = twcb.GetBuf(cch);
				if (!pszTempBuffer)
				{
					CCallMgr *	pcallmgr = GetPed()->GetCallMgr();

					if (pcallmgr)
						pcallmgr->SetOutOfMemory();

					return FALSE;			// Fail to allocate memory
				}
			}
			_rpTX.GetText(cchChunk, pszTempBuffer);
			pstrToRender = pszTempBuffer;	// Point at buffer
			if(chPassword)
			{
				// Fill buffer with password characters
				for (int i = 0, j = 0; i < cchChunk; i++)
				{
					if(!IN_RANGE(0xDC00, pszTempBuffer[i], 0xDFFF))
						pszTempBuffer[j++] = chPassword;
				}
				cch -= cchChunk - j;
				Move(cchChunk - j);
				cchChunk = j;
			}
			else if(dwEffects & CFE_ALLCAPS)
				CharUpperBuff(pszTempBuffer, cchChunk);
		}

		if(_cpAccelerator != -1)
		{
			LONG cpCur = GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < _cpAccelerator &&
				cpCur + cchChunk > _cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = _cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == _cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
				_cpAccelerator = -1;	// Only 1 accelerator per line
			}
		}
		
		// Reduce chunk to account for selection if we are rendering for a
		// display that cares about selections.
		if(_fRenderSelection && cpSelMin != cpSelMost)
		{
			LONG cchSel = cpSelMin - GetCp();
			if(cchSel > 0)
				cchChunk = min(cchChunk, cchSel);

			else if(GetCp() < cpSelMost)
			{
				cchSel = cpSelMost - GetCp();
				if(cchSel >= cch)
					_fSelectToEOL = TRUE;
				else
					cchChunk = min(cchChunk, cchSel);

				_fSelected = TRUE;		// cpSelMin <= GetCp() < cpSelMost
			}							//  so current run is selected
		}

		// If start of CCharFormat run, select font and color
		if(FormatIsChanged() || _fSelected != _fSelectedPrev)
		{
			ResetCachediFormat();
			_fSelectedPrev = _fSelected;
			if(!SetNewFont())
				return FALSE;					// Failed
		}

		if(fAccelerator)
		{
			bUnderlineSave = _bUnderlineType;
			SetupUnderline(CFU_UNDERLINE, 0);
		}

		// Allow for further reduction of the chunk and rendering of 
		// interleaved rich text elements
		if(_li._fHasSpecialChars && RenderChunk(cchChunk, pstrToRender, cch))
		{
			AssertSz(cchChunk > 0, "CRenderer::RenderLine(): cchChunk == 0");
			_fSelected = FALSE;
			continue;
		}

		AssertSz(cchChunk > 0,"CRenderer::RenderLine() - cchChunk == 0");

		_fLastChunk = (cchChunk == cch);
		RenderText(pstrToRender, cchChunk);	// Render the text

		if(fAccelerator)
		{
			_bUnderlineType = bUnderlineSave;
			fAccelerator = FALSE;			// Turn off special accelerator
		}						 			//  processing
		Move(cchChunk);

		// Break if we went past right of render rect.
		if(_ptCur.u >= _rcRender.right)
		{
			cch -= cchChunk;
			break;
		}
	}

	EndLine(hdcSave, dup, dvp);
	Move(cch);
	return TRUE;						// Success
}

/*
 *	CRenderer::EndLine (hdcSave, dup, dvp)
 *
 *	@mfunc
 *		Finish up rendering of line, drawing table borders, rendering
 *		offscreen DC, and erasing to right of render rect if necessary.
 */
void CRenderer::EndLine(
	HDC	 hdcSave,
	LONG dup,
	LONG dvp)
{
	if(hdcSave)
		RenderOffscreenBitmap(hdcSave, dup, dvp);

	// Handle setting background color. We need to do this for each line 
	// because we return the background color to the default after each
	// line so that opaquing will work correctly.
	if(_crBackground != _crCurBackground)
	{
		::SetBkColor(_hdc, _crBackground);	// Tell window background color
		_crCurBackground = _crBackground;
	}
}

/*
 *	CRenderer::GetColorFromIndex (icr, fForeColor, pPF)
 *
 *	@mfunc
 *		Returns COLORREF corresponding to color index icr
 *
 *	@rdesc
 *		Get COLORREF corresponding to color index icr as follows:
 *		icr = 1 to 16 is g_Colors[icr-1]
 *		icr = 17 is pCF->_crTextColor
 *		icr = 18 is pCF->_crBackColor
 *		else CRenderer autocolor corresponding to fForeColor
 */
COLORREF CRenderer::GetColorFromIndex(
	LONG  icr,						//@parm Color index
	BOOL  fForeColor,				//@parm TRUE if foreground color (for autocolor)
	const CParaFormat *pPF) const	//@parm PF for two custom colors
{
	icr &= 0x1F;							// Mask off other indices

	if(!IN_RANGE(1, icr, 18))
		return fForeColor ? _crTextColor : _crBackground;	// autocolor

	if(IN_RANGE(1, icr, 16))				// One of standard 16 colors
		return g_Colors[icr - 1];

	// Two custom colors
	return (icr == 17) ? pPF->_crCustom1 : pPF->_crCustom2;
}

/*
 *	CRenderer::GetShadedColorFromIndices (icrf, icrb, iShading, pPF)
 *
 *	@mfunc
 *		Returns COLORREF corresponding to color index icr
 *
 *	@rdesc
 *		Get COLORREF corresponding to foreground/background indices
 *		icrf and icrb according to shading iShading
 */
COLORREF CRenderer::GetShadedColorFromIndices(
	LONG  icrf,						//@parm Foreground color index
	LONG  icrb,						//@parm Background color index
	LONG  iShading,					//@parm Shading in .01 percent
	const CParaFormat *pPF) const	//@parm PF for two custom colors
{
	Assert(iShading <= 200);

	COLORREF crb = GetColorFromIndex (icrb, FALSE, pPF);
	COLORREF crf = GetColorFromIndex (icrf, TRUE,  pPF);

	return GetShadedColor(crf, crb, (iShading*3)/2);
}

/*
 *	CRenderer::DrawTableBorders (pPF, u, vHeightRow, iDrawBottomLine, dulRow, pPFAbove)
 *
 *	@mfunc
 *		Draws table borders.  If iDrawBottomLine is nonzero, draw bottom line
 *		as well as others.  If iDrawBottomLine & 1, width of bottom line is
 *		included in vHeightRow; else if iDrawBottomLine is nonzero, draw bottom
 *		line immediately below the row and return the extra height.
 *
 *	@rdesc
 *		Extra dvp if extra bottom line is drawn
 */
LONG CRenderer::DrawTableBorders(
	const CParaFormat *pPF,		//@parm PF with cell data
	LONG  u,					//@parm u position to start table row borders
	LONG  vHeightRow,			//@parm Height of row
	LONG  iDrawBottomLine,		//@parm Flags on drawing bottom line
	LONG  dulRow,				//@parm Length of row
	const CParaFormat *pPFAbove)//@parm PF for row above
{
	CBrush	 brush(this);
	LONG	 cCell = pPF->_bTabCount;
	LONG	 cCellAbove = 0;
	COLORREF cr;
	LONG	 dupRow = LUtoDU(dulRow);
	LONG	 dvp = 0;
	LONG	 dxlLine;
	LONG	 dxlLinePrevRight = 0;
	LONG	 dxpLine;
	BOOL	 fHideGridlines = GetPed()->fHideGridlines() || !fDisplayDC();
	BOOL	 fRTLRow = pPF->IsRtl();
	LONG	 iCell;
	LONG	 icr;
	const CELLPARMS *prgCellParms = pPF->GetCellParms();
	const CELLPARMS *prgCellParmsAbove = NULL;
	LONG	 vTop = _ptCur.v;
	LONG	 vBot = vTop + vHeightRow;
	LONG	 v = vBot;

	if(pPFAbove)
	{
		prgCellParmsAbove = pPFAbove->GetCellParms();
		cCellAbove = pPFAbove->_bTabCount;
	}
	if(_fErase)
	{
		//Erase left and right edges of table
		LONG	cpSelMin, cpSelMost;
		RECTUV	rc = {_rcRender.left, vTop, u, vBot};

		EraseTextOut(_hdc, &rc);

		rc.left = u + dupRow;
		rc.right = _rcRender.right;
		EraseTextOut(_hdc, &rc);

		//If first line, erase to edge of rcRender
		if (rc.top <= _rcView.top)
			rc.top = _rcRender.top;
		rc.left = 0;
		rc.bottom = vTop;
		EraseTextOut(_hdc, &rc);

		// Display row selection mark if row is selected
		GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
		Assert(_rpTX.IsAfterTRD(ENDFIELD));
		if(GetCp() <= cpSelMost && GetCp() > cpSelMin)
		{									// Row is selected
			COLORREF crSave = _crBackground;
			LONG	 dup;
			if(!_pccs)
				_pccs = GetCcs(GetCF());
			if(_pccs && _pccs->Include(' ', dup))
			{
				rc.left  = u + dupRow + 
					GetPBorderWidth(prgCellParms[cCell-1].GetBrdrWidthRight()/2);
				rc.right = rc.left + dup;
				rc.top	 = vTop + GetPBorderWidth(prgCellParms->GetBrdrWidthTop());
				rc.top++;
				rc.bottom= vBot;
				if(iDrawBottomLine & 1)
					rc.bottom = vBot - GetPBorderWidth(prgCellParms->GetBrdrWidthBottom());
				SetBkColor(_hdc, GetPed()->TxGetSysColor(COLOR_HIGHLIGHT));
				EraseTextOut(_hdc, &rc, TRUE);
				SetBkColor(_hdc, crSave);
			}
		}
	}

	if(iDrawBottomLine)					// Row bottom border
	{
		LONG dxp = GetPBorderWidth(prgCellParms->GetBrdrWidthLeft())/2;						
		LONG u1 = u - dxp;
		LONG u2 = u + dupRow;
		dxpLine = GetPBorderWidth(prgCellParms->GetBrdrWidthBottom());
		cr = GetColorFromIndex(prgCellParms->GetColorIndexBottom(), TRUE, pPF);
		if(iDrawBottomLine & 1)			// Line width incl in cell height
		{								// Don't draw left vertical lines
			v -= dxpLine;				//  over bottom line
			if(!dxpLine && !fHideGridlines)
				v--;					// Overlay cell bottom with gray
		}								//  gridline
		else							// Line width not incl in cell height
		{
			dvp = dxpLine;				// Return extra width due to bottom line
			if(!dxpLine && !fHideGridlines)
				dvp = 1;
			vBot += dvp;				// Set up outside vertical lines
		}
		brush.Draw(u1, v, u2, v, dxpLine, cr, fHideGridlines);
	}
	LONG uPrev, uCur = u;
	LONG dul = 0;
	LONG dup;

	if(fRTLRow)
		uCur = u + dupRow;

	for(LONG i = cCell; i >= 0; i--)
	{									
		// Draw cell side border		
		if(i)							// Left border
		{
			icr		 = prgCellParms->GetColorIndexLeft();
			dxlLine  = prgCellParms->GetBrdrWidthLeft();
			dxlLine	 = max(dxlLine, dxlLinePrevRight);
			dxlLinePrevRight = prgCellParms->GetBrdrWidthRight();
		}
		else							// Right border
		{								
			prgCellParms--;
			icr		 = prgCellParms->GetColorIndexRight();
			dxlLine  = dxlLinePrevRight;
			v = vBot;					// Be sure bottom right corner is square
		}
		cr = GetColorFromIndex(icr, TRUE, pPF);
		dxpLine = GetPBorderWidth(dxlLine);
		brush.Draw(uCur - dxpLine/2, vTop, uCur - dxpLine/2, v, dxpLine, cr, fHideGridlines);

		if(i)
		{
			dul += GetCellWidth(prgCellParms->uCell);	// Stay logical to
			dup = LUtoDU(dul);							//  avoid roundoff
			uPrev = uCur;
			uCur = u + dup;
			if(fRTLRow)
				uCur = u + dupRow - dup;
			if(!IsLowCell(prgCellParms->uCell))
			{								// Cell top border
				dxlLine = prgCellParms->GetBrdrWidthTop();
				if(prgCellParmsAbove)		// Choose thicker of this row's top
				{							//  & above row's bottom borders  
					iCell = prgCellParmsAbove->ICellFromUCell(dul, cCellAbove);
					if(iCell >= 0)
					{
						LONG dxlAbove = prgCellParmsAbove[iCell].GetBrdrWidthBottom();
						dxlLine = max(dxlLine, dxlAbove);
					}
				}
				dxpLine = GetPBorderWidth(dxlLine);
				cr = GetColorFromIndex(prgCellParms->GetColorIndexTop(), TRUE, pPF);
				brush.Draw(uPrev, vTop, uCur, vTop, dxpLine, cr, fHideGridlines);
			}
			prgCellParms++;
		}
	}
	if(prgCellParmsAbove && !pPFAbove->IsRtl())
	{										// Draw more top borders if row
		LONG dulAbove = 0;					//  above extends beyond current
		for(i = cCellAbove; i > 0; i--)		//  row (LTR rows only for now)
		{
			dulAbove += GetCellWidth(prgCellParmsAbove->uCell);
			if(dulAbove > dul)
			{
				dup = LUtoDU(dulAbove);
				if(i == 1)
					dup += GetPBorderWidth((prgCellParmsAbove->GetBrdrWidthRight()+1)/2);
				uPrev = uCur;
				uCur = u + dup;
				dxpLine = GetPBorderWidth(prgCellParmsAbove->GetBrdrWidthBottom());
				cr = GetColorFromIndex(prgCellParmsAbove->GetColorIndexBottom(), TRUE, pPFAbove);
				brush.Draw(uPrev, vTop, uCur, vTop, dxpLine, cr, fHideGridlines);
			}
			prgCellParmsAbove++;
		}
	}
	return dvp;
}

/*
 *	CRenderer::UpdatePalette (pobj)
 *
 *	@mfunc
 *		Stores palette information so that we can render any OLE objects
 *		correctly in a bitmap.
 */
void CRenderer::UpdatePalette(
	COleObject *pobj)		//@parm OLE object wrapper.
{
#ifndef NOPALETTE
	LOGPALETTE *plogpalette = NULL;
	LOGPALETTE *plogpaletteMerged;
	IViewObject *pviewobj;

	// Get IViewObject interface information so we can build a palette
	// to render the object correctly.
	if (((pobj->GetIUnknown())->QueryInterface(IID_IViewObject, 
		(void **) &pviewobj)) != NOERROR)
	{
		// Couldn't get it, so pretend this didn't happen
		return;
	}

	// Get logical palette information from object
	if(pviewobj->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, 
			NULL, &plogpalette) != NOERROR || !plogpalette)
	{
		// Couldn't get it, so pretend this didn't happen
		goto CleanUp;
	}

	if(!_plogpalette)				
	{								// No palette entries yet
		_plogpalette = plogpalette;	// Just use the one returned
		goto CleanUp;
	}

	// We have had other palette entries. We just reallocate the table
	// and put the newest entry on the end. This is crude, we might
	// sweep the table and actually merge it. However, this code
	// should be executed relatively infrequently and therefore, crude
	// should be good enough.

	// Allocate a new table - Note the " - 1" in the end has to do with
	// the fact that LOGPALETTE is defined to have one entry already.
	AssertSz(_plogpalette->palNumEntries + plogpalette->palNumEntries >= 1,
		"CRenderer::UpdatePalette - invalid palettes to merge");
	plogpaletteMerged = (LOGPALETTE *) CoTaskMemAlloc(sizeof(LOGPALETTE) + 
		((_plogpalette->palNumEntries + plogpalette->palNumEntries - 1) * sizeof(PALETTEENTRY)));

	if(!plogpaletteMerged)				// Memory allocation failed
		goto CleanTempPalette;			// Just pretend it didn't happen

	// Copy in original table.
	memcpy(&plogpaletteMerged->palPalEntry[0], &_plogpalette->palPalEntry[0],
		_plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Put new data at end
	memcpy(&plogpaletteMerged->palPalEntry[_plogpalette->palNumEntries], 
		&plogpalette->palPalEntry[0],
		plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Set the version number and count
	plogpaletteMerged->palVersion = plogpalette->palVersion;
	plogpaletteMerged->palNumEntries = _plogpalette->palNumEntries 
		+ plogpalette->palNumEntries;

	// Replace current palette table with merged table
	CoTaskMemFree(_plogpalette);
	_plogpalette = plogpaletteMerged;

CleanTempPalette:
	CoTaskMemFree(plogpalette);

CleanUp:

	// Release object we got since we don't need it any more
	pviewobj->Release();
#endif // NOPALETTE
}


/*
 *	CRenderer::RenderChunk (&cchChunk, pchRender, cch)
 *
 *	@mfunc
 *		Method reducing the length of the chunk (number of character
 *		rendered in one RenderText) and to render items interleaved in text.
 *
 *	@rdesc	
 *		TRUE if this method actually rendered the chunk, 
 * 		FALSE if it just updated cchChunk and rendering is still needed
 */
BOOL CRenderer::RenderChunk(
	LONG &		 cchChunk,		//@parm in: chunk cch; out: # chars rendered
								//  if return TRUE; else # chars yet to render
	const WCHAR *pchRender,		//@parm pchRender render up to cchChunk chars
	LONG		 cch) 			//@parm # chars left to render on line
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderChunk");

	LONG		cchValid = cchChunk;
	LONG		i;
	const WCHAR *pchT;

	// Search for object in chunk
	for(pchT = pchRender, i = 0; i < cchValid && *pchT != WCH_EMBEDDING; i++)
		pchT++;

	if(i == 0)
	{
		// First character is object so display object
		COleObject *pobj = GetObjectFromCp(GetCp());
		if(pobj)
		{
			LONG dvpAscent, dvpDescent, dupObject;
			pobj->MeasureObj(_dvpInch, _dupInch, dupObject, dvpAscent, dvpDescent, _li._dvpDescent, GetTflow());

			if (W32->FUsePalette() && _li._fUseOffscreenDC && _pdp->IsMain())
			{
				// Keep track of palette needed for rendering bitmap
				UpdatePalette(pobj);
			}

			SetClipLeftRight(dupObject);

			pobj->DrawObj(_pdp, _dvpInch, _dupInch, _hdc, &GetClipRect(), _pdp->IsMetafile(), &_ptCur, 
						  _li._dvpHeight - _li._dvpDescent, _li._dvpDescent, GetTflow());

			_ptCur.u	+= dupObject;
			_li._dup += dupObject;
		}
		cchChunk = 1;
		// Both tabs and object code need to advance the run pointer past
		// each character processed.
		Move(1);
		return TRUE;
	}
	cchChunk -= cchValid - i;				// Limit chunk to char before object

	// Handle other special characters
	LONG cchT = 0;
	for(pchT = pchRender; cchT < cchChunk; pchT++, cchT++)
	{
		switch(*pchT)
		{
		case EURO: //NOTE: (keithcu) Euro's need this special logic only for printing/metafiles
		case TAB:
		case NBSPACE:
		case SOFTHYPHEN:
		case NBHYPHEN:
		case EMSPACE:
		case ENSPACE:
			break;
		default:
			continue;
		}
		break;
	}
	if(!cchT)
	{
		// First char is a tab, render it and any that follow
		if(*pchT == TAB)
			cchChunk = RenderTabs(cchChunk);
		else
		{
			WCHAR chT = *pchT;

			if (*pchT == NBSPACE)
				chT = ' ';
			else if (*pchT == NBHYPHEN || *pchT == SOFTHYPHEN)
				chT = '-';

			if(*pchT != SOFTHYPHEN || cch == 1)	// Only render hyphens/blank at EOL
				RenderText(&chT, 1);

			Move(1);					// Skip those within line
			cchChunk = 1;
		}
		Assert (cchChunk > 0);
		return TRUE;
	}
	cchChunk = cchT;		// Update cchChunk not to incl trailing tabs

	return FALSE;
}		

/*
 *	CRenderer::SetClipRect()
 *
 *	@mfunc
 *		Helper to set clipping rect for the line
 */
void CRenderer::SetClipRect()
{
	_rc = _rcRender;

	_rc.top = _ptCur.v;
	_rc.bottom = _rc.top + _li._dvpHeight;

	_rc.top = max(_rc.top, _rcView.top);
	_rc.bottom = min(_rc.bottom, _rcView.bottom);
}

/*
 *	CRenderer::SetClipLeftRight (dup)
 *
 *	@mfunc
 *		Helper to sets left and right of clipping/erase rect.
 *	
 *	@rdesc
 *		Sets _rc left and right	
 */
void CRenderer::SetClipLeftRight(
	LONG dup)		//@parm	Width of chunk to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetClipLeftRight");

	//Nominal value
	_rc.left = _ptCur.u;
	_rc.right = _rc.left + dup;

	//Constrain left and right based on rcView, rcRender
	_rc.left = max(_rc.left, _rcRender.left);

	_rc.right = max(_rc.right, _rc.left);
	_rc.right = min(_rc.right, _rcRender.right);
}
	
/*
 *	CRenderer::GetConvertMode()
 *
 *	@mfunc
 *		Return the mode that should really be used in the RenderText call
 */
CONVERTMODE	CRenderer::GetConvertMode()
{
	CONVERTMODE cm = (CONVERTMODE)_pccs->_bConvertMode;

	// For hack around ExtTextOutW Win95 problems.
	if (cm != CVT_LOWBYTE && W32->OnWin9x() && (_pdp->IsMetafile() || _fEnhancedMetafileDC))
		return CVT_WCTMB;

	if (cm != CVT_LOWBYTE && _pdp->IsMetafile() && !_fEnhancedMetafileDC)
		return CVT_WCTMB;	// WMF cant store Unicode so we cant use ExtTextOutW

	return cm;
}		

/*
 *	CRenderer::RenderExtTextOut (ptuv, fuOptions, prc, pwchRun, cch, rgdxp)
 *
 *	@mfunc
 *		Calls ExtTextOut and handles disabled text. There is duplicate logic in OlsDrawGlyphs, but
 *		the params are different so that was simplest way.
 *
 */
extern ICustomTextOut *g_pcto;
void CRenderer::RenderExtTextOut(
	POINTUV ptuv,
	UINT fuOptions, 
	RECT *prc, 
	PCWSTR pch, 
	UINT cch, 
	const INT *rgdxp)
{
	CONVERTMODE cm = GetConvertMode();

	if (prc->left >= prc->right || prc->top >= prc->bottom)
		return;

	DWORD dwETOFlags = GetTflow();
	if (_fFEFontOnNonFEWin9x)
		dwETOFlags |= fETOFEFontOnNonFEWin9x;
	if (_pccs->_fCustomTextOut)
		dwETOFlags |= fETOCustomTextOut;

	if(_fDisabled)
	{
		if(_crForeDisabled != _crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, _dvpInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			SetTextColor(_crShadowDisabled);

			POINTUV ptuvT = ptuv;
			ptuvT.u += offset;
			ptuvT.v += offset;
			POINT pt;
			_pdp->PointFromPointuv(pt, ptuvT, TRUE);
			
			W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, pt.x, pt.y,
				fuOptions, prc, pch, cch, rgdxp, dwETOFlags);

			// Now set drawing mode to transparent
			fuOptions &= ~ETO_OPAQUE;
			SetBkMode(_hdc, TRANSPARENT);
		}
		SetTextColor(_crForeDisabled);
	}

	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv, TRUE);

	W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, pt.x, pt.y, fuOptions, prc, pch, cch, rgdxp, dwETOFlags);
}

/*
 *	CRenderer::RenderText (pch, cch)
 *
 *	@mfunc
 *		Render text in the current context of this CRenderer
 *
 *	@devnote
 *		Renders text only: does not do tabs or OLE objects
 */
void CRenderer::RenderText(
	const WCHAR *pch,	//@parm Text to render
	LONG cch)			//@parm Length of text to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderText");

	LONG		dvp, cchT;

	// Variables used for calculating length of underline.
	LONG		dupSelPastEOL = 0;
	BOOL		fCell = FALSE;
	UINT		fuOptions = _pdp->IsMain() ? ETO_CLIPPED : 0;
	LONG		dup;
	LONG		dupT;
	CTempBuf	rgdu;

	//Reset clip rectangle to greater of view/render rectangle
	_rc.left = _rcRender.left;
	_rc.right = _rcRender.right;

	// Trim all nondisplayable linebreaking chars off end
	while(cch && IsASCIIEOP(pch[cch - 1]))
		cch--;

	if(cch && pch[cch-1] == CELL)
	{
		fCell = TRUE;
		cch--;
	}
	
	int *pdu = (int *)rgdu.GetBuf(cch * sizeof(int));

	// Measure width of text to write so next point to write can be
	// calculated.
	dup = 0;

	for(cchT = 0; 
		cchT < cch && dup < _rc.right - _ptCur.u; 
		cchT++)
	{
		dupT = 0;
		if (!_pccs->Include(*pch, dupT))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error filling CCcs", E_FAIL);
			return;
		}

		if (pdu)
			*pdu++ = dupT;
  		pch++;
		dup += dupT;
	}

	// Go back to start of chunk
	cch = cchT;
	pch -= cch;
	if (pdu)
		pdu -= cch;

	if(_fLastChunk && _fSelectToEOL && _li._cchEOP)
	{
		// Use the width of the current font's space to highlight
		if(!_pccs->Include(' ', dupT))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error no length of space", E_FAIL);
			return;
		}
		dupSelPastEOL = dupT;
		dup += dupSelPastEOL;
		_fSelectToEOL = FALSE;			// Reset the flag
	}

	_li._dup += dup;

	// Setup for drawing selections via ExtTextOut.
 	if(_fSelected || _crBackground != _crCurBackground)
	{
		SetClipLeftRight(dup);
		if(_fSelected && fCell)
		{
			// Needs work, but this is a start. _rcRender has the cell
			// boundaries, so we need to use them on the right calls.
			_rc.right = _rcRender.right;
		}
		fuOptions = ETO_CLIPPED | ETO_OPAQUE;
	}

	dvp = _ptCur.v + _li._dvpHeight - _li._dvpDescent + _pccs->_yDescent - _pccs->_yHeight;
		
	LONG dvpOffset, dvpAdjust;
	_pccs->GetOffset(GetCF(), _dvpInch, &dvpOffset, &dvpAdjust);
	dvp -= dvpOffset + dvpAdjust;

	POINTUV ptuv = {_ptCur.u, dvp};
	RECT rc;
	_pdp->RectFromRectuv(rc, _rc);

	//For 1 char runs, we may need to swap the character we output.
	WCHAR ch;
	if (cch == 1)
	{
		switch(*pch)
		{
		case EMSPACE:
		case ENSPACE:
			ch = ' ';
			pch = &ch;
			break;
		}
	}

	RenderExtTextOut(ptuv, fuOptions, &rc, pch, cch, pdu);

	// Calculate width to draw for underline/strikeout
	// FUTURE (keithcu) Don't underline trailing spaces?
	if(_bUnderlineType != CFU_UNDERLINENONE	|| _fStrikeOut)
	{
		LONG dupToDraw = dup - dupSelPastEOL;
		LONG upStart = _ptCur.u;
		LONG upEnd = upStart + dupToDraw;
		
		upStart = max(upStart, _rcRender.left);

		upEnd = min(upEnd, _rcRender.right);

		dupToDraw = upEnd - upStart;

		if(dupToDraw > 0)
		{
			LONG y = _ptCur.v + _li._dvpHeight - _li._dvpDescent;

			y -= dvpOffset + dvpAdjust;

			// Render underline if required
			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(upStart, y + _pccs->_dyULOffset, dupToDraw, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(upStart, y + _pccs->_dySOOffset, dupToDraw, _pccs->_dySOWidth);
		}
	}

	_fSelected = FALSE;
	_ptCur.u += dup;					// Update current point
}

/*
 *	CRenderer::RenderTabs (cchMax)
 *
 *	@mfunc
 *		Render a span of zero or more tab characters in chunk *this
 *
 *	@rdesc
 *		number of tabs rendered
 *
 *	@devnote
 *		*this is advanced by number of tabs rendered
 *		MS - tabs should be rendered using opaquing rect of adjacent string
 */
LONG CRenderer::RenderTabs(
	LONG cchMax)	//@parm Max cch to render (cch in chunk)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderTabs");

	LONG cch = cchMax;
	LONG ch = GetChar();
	LONG chPrev = 0;
	LONG upTab, upTabs;
	
	for(upTabs = 0; cch && ch == TAB; cch--)
	{
		upTab	= MeasureTab(ch);
		_li._dup += upTab;				// Advance internal width
		upTabs	+= upTab;				// Accumulate width of tabbed
		Move(1);						//  region
		chPrev = ch;
		ch = GetChar();					   
	}

	if(_li._dup > _dupLine)
	{
		upTabs = 0;
		_li._dup = _dupLine;
	}

	if(upTabs)
	{
		LONG dup = 0;
		LONG upGap = 0;

		if(_fSelected && chPrev == CELL && ch != CR && _pPF->InTable())
		{
			LONG cpSelMin, cpSelMost;
			GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
			if(GetCp() == cpSelMin || GetCp() == cpSelMost)
			{
				upGap = LUtoDU(_pPF->_dxOffset);
				if(GetCp() == cpSelMost)
				{
					dup = upGap;
					upGap = 0;
				}
			}
		}
		SetClipLeftRight(upTabs - dup);
		if(_rc.left < _rc.right)			// Something to erase
		{
			if(_fSelected)					// Use selection background color
			{
			    COLORREF cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
				if (!UseXOR(cr))

				{
				    ::SetBkColor (_hdc, cr);
    				_crCurTextColor = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);    				
				}
    			else
    			{ 
    			    const CCharFormat* pCF = GetCF();
    			    ::SetBkColor (_hdc, (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ? 
    			                  _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE);    		            		        
    				_crCurTextColor =  (pCF->_dwEffects & CFE_AUTOCOLOR) ? 
    				              _crTextColor ^ RGB_WHITE : pCF->_crTextColor ^ RGB_WHITE;    				
    			}
			}

			// Paint background with appropriate color
			if(_fSelected || _crBackground != _crCurBackground)
				EraseTextOut(_hdc, &_rc, TRUE);

			// Render underline if required
			dup = _rc.right - _rc.left;
			LONG vp = _ptCur.v + _li._dvpHeight - _li._dvpDescent;
			
			LONG dvpOffset, dvpAdjust;
			_pccs->GetOffset(GetCF(), _dvpInch, &dvpOffset, &dvpAdjust);
			vp -= dvpOffset + dvpAdjust;

			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(_rc.left, vp + _pccs->_dyULOffset, dup, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(_rc.left, vp +  _pccs->_dySOOffset, dup, _pccs->_dySOWidth);

			if(_fSelected)					// Restore colors
				::SetBkColor(_hdc, _crCurBackground);
		}
		_ptCur.u += upTabs;					// Update current point
	}
	return cchMax - cch;					// Return # tabs rendered
}

/*
 * 	CRenderer::SetNewFont()
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 *
 *	@rdesc
 *		TRUE if it succeeds
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
BOOL CRenderer::SetNewFont()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetNewFont");

	const CCharFormat	*pCF = GetCF();
	DWORD				dwEffects = pCF->_dwEffects;
	BOOL				fDisplay = fDisplayDC();

	// Release previous font in use
	if(_pccs)
		_pccs->Release();

	Assert(_fTarget == FALSE);
	_pccs = GetCcs(pCF);

	if(!_pccs)
	{
		TRACEERRSZSC("CRenderer::SetNewFont(): no CCcs", E_FAIL);
		return FALSE;
	}

	// Select font in _hdc
	AssertSz(_pccs->_hfont, "CRenderer::SetNewFont _pccs->_hfont is NULL");

	SetFontAndColor(pCF);
	
	// Assume no underlining
	_bUnderlineType = CFU_UNDERLINENONE;

	// We want to draw revision marks and native hyperlinks with underlining,
	// so just fake out our font information.
	if((dwEffects & (CFE_UNDERLINE | CFE_REVISED)) ||
	   (dwEffects & (CFE_LINKPROTECTED | CFE_LINK)) == CFE_LINK ||
	   fDisplay && GetTmpUnderline(pCF->_sTmpDisplayAttrIdx))
	{
		if (dwEffects & CFE_LINK)
			SetupUnderline(CFU_UNDERLINE, 0);
		else
		{
			BYTE bTmpUnderlineIdx = 0;

			if (fDisplay)
				bTmpUnderlineIdx = GetTmpUnderline(pCF->_sTmpDisplayAttrIdx);

			if (bTmpUnderlineIdx)
			{
				COLORREF	crTmpUnderline;

				GetTmpUnderlineColor(pCF->_sTmpDisplayAttrIdx, crTmpUnderline);
				SetupUnderline(bTmpUnderlineIdx, 0, crTmpUnderline);
			}
			else
				SetupUnderline(pCF->_bUnderlineType, pCF->_bUnderlineColor);
		}
	}

	_fStrikeOut = (dwEffects & (CFE_STRIKEOUT | CFE_DELETED)) != 0;
	return TRUE;
}

/*
 * 	CRenderer::SetupUnderline (bULType, bULColorIdx, crULColor)
 *
 *	@mfunc
 *		Setup internal variables for underlining
 */
void CRenderer::SetupUnderline(
	BYTE		bULType,
	BYTE		bULColorIdx,
	COLORREF	crULColor)
{
	_bUnderlineType	= bULType;
	_crUnderlineClr = crULColor;

	if (bULColorIdx)
		GetPed()->GetEffectColor(bULColorIdx, &_crUnderlineClr);
}

/*
 * 	CRenderer::UseXOR (cr)
 *
 *	@mfunc
 *		Return if reverse video selection should be used for the nominal
 *		selection color cr. RichEdit 1.0 mode always uses reverse video
 *		selection. Else use it if cr is too close to the current window
 *		background.
 *
 *	@rdesc
 *		Return if caller should use reverse video for cr
 */
BOOL CRenderer::UseXOR(
	COLORREF cr)		//@parm Color to compare _crBackground to
{
	return GetPed()->Get10Mode() ||
		(_crBackground != GetPed()->TxGetSysColor(COLOR_WINDOW) &&
			IsTooSimilar(_crBackground, cr));
}

/*
 * 	CRenderer::SetFontAndColor (pCF)
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 */
void CRenderer::SetFontAndColor(
	const CCharFormat *pCF)			//@parm Character format for colors
{
	CTxtEdit *ped = GetPed();

	_fDisabled = FALSE;
	if((pCF->_dwEffects & (CFE_AUTOCOLOR | CFE_DISABLED))
					   == (CFE_AUTOCOLOR | CFE_DISABLED))
	{		
		_fDisabled = TRUE;
		
		_crForeDisabled   = ped->TxGetSysColor(COLOR_3DSHADOW);
		_crShadowDisabled = ped->TxGetSysColor(COLOR_3DHILIGHT);
	}

	_fFEFontOnNonFEWin9x = FALSE;
	if (IsFECharRep(pCF->_iCharRep) && W32->OnWin9x() && !W32->OnWin9xFE())
		_fFEFontOnNonFEWin9x = TRUE;

	SelectFont(_hdc, _pccs->_hfont);

	// Compute height and descent if not yet done
	if(_li._dvpHeight == -1)
	{
		SHORT	dvpAdjustFE = _pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
		// Note: this assumes plain text 
		// Should be used only for single line control
		_li._dvpHeight  = _pccs->_yHeight + (dvpAdjustFE << 1);
		_li._dvpDescent = _pccs->_yDescent + dvpAdjustFE;
	}
	SetTextColor(GetTextColor(pCF));	// Set current text color

	COLORREF  cr;

	if(_fSelected)						// Set current background color
	{
	    cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
	    if (UseXOR(cr))
		{
		    // There are 2 cases to be concerned with
		    // 1) if the background color is the same as the selection color or
		    // 2) if 1.0 Window and the background color is NOT system default
		    cr = (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ?
		          _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE;	    
		}
	}
	else if(!fDisplayDC() ||
		!(GetTmpBackColor(pCF->_sTmpDisplayAttrIdx, cr)))	// Any temp. background color?
	{															//	No, use regular background color
		if(pCF->_dwEffects & CFE_AUTOBACKCOLOR)
			cr = _crBackground;
		else													// Text run has some kind of back color
			cr = pCF->_crBackColor;
	}

	if(cr != _crCurBackground)
	{
		::SetBkColor(_hdc, cr);			// Tell window background color
		_crCurBackground = cr;			// Remember current background color
		_fBackgroundColor = _crBackground != cr; // Change render settings so we
	}									//  won't fill with background color
}

/*
 * 	CRenderer::SetDefaultBackColor (cr)
 *
 *	@mfunc
 *		Select given background color in the _hdc. Used for	setting
 *		background color in table cells.
 */
void CRenderer::SetDefaultBackColor(
	COLORREF cr)		//@parm Background color to use
{
	if(cr == tomAutoColor)
		cr = GetPed()->TxGetBackColor();		// Printer needs work...

	if(_crBackground != cr)
	{
		_crCurBackground = _crBackground = cr;
		::SetBkColor(_hdc, cr);
	}
}

/*
 * 	CRenderer::SetDefaultTextColor (cr)
 *
 *	@mfunc
 *		Select given foreground color in the _hdc. Used for	setting
 *		text color in table cells.
 */
void CRenderer::SetDefaultTextColor(
	COLORREF cr)		//@parm Background color to use
{
	if(cr == tomAutoColor)
		cr = GetPed()->TxGetForeColor();		// Printer needs work...

	if(_crTextColor != cr)
	{
		_crCurTextColor = _crTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 * 	CRenderer::SetTextColor (cr)
 *
 *	@mfunc
 *		Select given text color in the _hdc
 *		Used to maintain _crCurTextColor cache
 */
void CRenderer::SetTextColor(
	COLORREF cr)			//@parm color to set in the dc
{
	if(cr != _crCurTextColor)
	{
		_crCurTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 *	CRenderer::GetTextColor(pCF)
 *
 *	@mfunc
 *		Return text color for pCF. Depends on _bRevAuthor, display tech
 *
 *  FUTURE (keithcu) It might be nice to have black or blue selected text be
 *  white, but to have all other colors stay their other colors. What do we
 *	do if the backcolor is blue??
 *
 *	@rdesc	
 *		text color
 */
COLORREF CRenderer::GetTextColor(
	const CCharFormat *pCF)	//@parm CCharFormat specifying text color
{
	if(_fSelected)
	{
	    // There are 2 cases where XOR for selection is needed
	    // 1) if the background is the same as the selection background
	    // 2) if 1.0 window and the background isn't the system default window
	    // background color

	    // if this doesn't match the above case just return the cr
	    if (!UseXOR(GetPed()->TxGetSysColor(COLOR_HIGHLIGHT)))
	        return GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);

	    // xor the current text color for the selected text color
		return (pCF->_dwEffects & CFE_AUTOCOLOR) ? _crTextColor ^ RGB_WHITE :
		    pCF->_crTextColor ^ RGB_WHITE;
    }

	// The following could be generalized to return a different color for
	// links that have been visited for this text instance (need to define
	// extra CCharFormat::_dwEffects internal flag to ID these links)
	if((pCF->_dwEffects & (CFE_LINK | CFE_LINKPROTECTED)) == CFE_LINK)
	{
		// Blue doesnt show up very well against dark backgrounds.
		// In these situations, use the system selected text color.
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		if (IsTooSimilar(crBackground, RGB_BLACK) || IsTooSimilar(crBackground, RGB_BLUE))
		{
			COLORREF crHighlightText = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);
			if (IsTooSimilar(crBackground, crHighlightText))
			{
				// Background is similar to highlight, use window text color
				return GetPed()->TxGetSysColor(COLOR_WINDOWTEXT);
			}
			else
			{
				return crHighlightText;
			}
		}
		// If not high contrast, fall through
	}

	BOOL fDisplay = fDisplayDC();
#ifndef NODRAFTMODE
	// Use draft mode text color only for displays
	if (GetPed()->_fDraftMode && (!_hdc || fDisplay))
	{
		SHORT iFont;
		SHORT yHeight;
		QWORD qwFontSig;
		COLORREF crColor;

		if (W32->GetDraftModeFontInfo(iFont, yHeight, qwFontSig, crColor))
			return crColor;
	}
#endif

	// If we did not return the URL color via draft mode or the high contrast check, do it now
	if((pCF->_dwEffects & (CFE_LINK | CFE_LINKPROTECTED)) == CFE_LINK)
		return RGB_BLUE;

	if(pCF->_bRevAuthor)				// Rev author
	{
		// Limit color of rev authors to 0 through 7.
		return rgcrRevisions[(pCF->_bRevAuthor - 1) & REVMASK];
	}

	COLORREF cr = (pCF->_dwEffects & CFE_AUTOCOLOR)	? _crTextColor : pCF->_crTextColor;
	COLORREF crTmpTextColor;

	if(fDisplay && GetTmpTextColor(pCF->_sTmpDisplayAttrIdx, crTmpTextColor))
		cr = crTmpTextColor;

	if(cr == RGB_WHITE)					// Text is white
	{
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		COLORREF crTmpBackground;
		if(fDisplay && GetTmpBackColor(pCF->_sTmpDisplayAttrIdx, crTmpBackground))
			crBackground = crTmpBackground;

		if(crBackground != RGB_WHITE)
		{
			// Background color isn't white, so white text is probably
			// visible unless display device is only black/white. So we
			// switch to black text on such devices.
			if (GetDeviceCaps(_hdc, NUMCOLORS) == 2 ||
				GetDeviceCaps(_hdc, TECHNOLOGY) == DT_PLOTTER)
			{
				cr = RGB_BLACK;
			}
		}
	}
	return cr;
}

extern BOOL g_OLSBusy;

/*
 *	CRenderer::StartLine(&li, fLastLine, &cpSelMin, &cpSelMost, &dup, &dvp)
 *
 *	@mfunc
 *		Render possible outline symbol and bullet if at start of line
 *
 *	@rdesc	
 *		hdcSave if using offscreen DC
 */
HDC CRenderer::StartLine(
	CLine &	li,			//@parm Line to render
	BOOL	fLastLine,	//@parm True if last line in layout
	LONG &	cpSelMin,	//@parm Out parm for current selection cpMin
	LONG &	cpSelMost,	//@parm Out parm for current selection cpMost
	LONG &	dup,		//@parm Offset to u
	LONG &	dvp)		//@parm Offset to v
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartLine");
	BOOL fDrawBack = !(GetCF()->_dwEffects & CFE_AUTOBACKCOLOR) && GetPed()->_fExtendBackColor;
	RECTUV rcErase = _rcRender;
	_fEraseOnFirstDraw = FALSE;

	GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
	if(cpSelMost != cpSelMin && cpSelMost == GetCp())
		_fSelectedPrev = TRUE;

	LONG	 cpMost = GetCp() + _li._cch;
	COLORREF crPrev = 0xFFFFFFFF;
	BOOL	 fUseSelColors = FALSE;

	if (cpMost <= cpSelMost && cpMost - 1 >= cpSelMin &&
		_pPF->InTable() && _fRenderSelection)
	{
		CTxtPtr tp(_rpTX);
		tp.SetCp(cpMost);
		if(tp.GetPrevChar() == CELL)
		{
			fUseSelColors = TRUE;
			crPrev = ::SetBkColor(GetDC(), GetPed()->TxGetSysColor(COLOR_HIGHLIGHT));
		}
	}
	SetClipRect();

	HDC hdcSave = NULL;
	dup = dvp = 0;
	if(li._cch > 0 && li._fUseOffscreenDC)
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = SetupOffscreenDC(dup, dvp, fLastLine);
		if(li._fOffscreenOnce)
			li._fUseOffscreenDC = li._fOffscreenOnce = FALSE;
	}

	rcErase.top = _ptCur.v;
	rcErase.bottom = min(rcErase.top + _li._dvpHeight, _rcRender.bottom);

	//If first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = _rcRender.top;

	//If last line, erase to bottom edge of rcRender
	if (fLastLine)
		rcErase.bottom = _rcRender.bottom;

	if (_fErase && !fDrawBack)
	{
		if(g_OLSBusy && IsSimpleBackground() && !fUseSelColors)
		{
			_fEraseOnFirstDraw = TRUE;
			_rcErase = rcErase;
		}
		else
			EraseTextOut(GetDC(), &rcErase);
	}

	// Fill line with background color if we are in fExtendBackColor mode
	if (fDrawBack || fUseSelColors)
	{
		// Capture old color so we reset it to what it was when we're finished
		COLORREF crOld = 0;
		if(fDrawBack)
			crOld = ::SetBkColor(GetDC(), GetCF()->_crBackColor);
		EraseTextOut(GetDC(), &_rc);

		// Reset background color to old color
		if(fDrawBack)
			::SetBkColor(GetDC(), crOld);

		//Erase the remainder of the background area
		if (_fErase)
		{
			RECTUV rcTemp = rcErase;
			//Erase the top part if necessary
			if (rcErase.top < _rc.top)
			{
				rcTemp.bottom = _rc.top;
				EraseTextOut(GetDC(), &rcTemp);
			}

			//Erase the left and right parts if necessary
			rcTemp.top = _rc.top;
			rcTemp.bottom = _rc.bottom;
			if (rcErase.left < _rc.left)
			{
				rcTemp.right = _rc.left;
				EraseTextOut(GetDC(), &rcTemp);
			}
			if (rcErase.right > _rc.right)
			{
				rcTemp.left = _rc.right;
				rcTemp.right = rcErase.right;
				EraseTextOut(GetDC(), &rcTemp);
			}
		}
	}

	if(crPrev != 0xFFFFFFFF)
		::SetBkColor(GetDC(), crPrev);

	if(IsRich() && _li._fFirstInPara && _pPF)
	{
		if(IsInOutlineView())
			RenderOutlineSymbol();

		if(_pPF->_wNumbering && !fUseLineServices())
			RenderBullet();	
	}

	// Reset format if there is special background color for previous line.
	// Otherwise, current line with the same format will not re-paint with the
	// special background color
	if (_fBackgroundColor)
	{
		_iFormat = -10;					// Reset to invalid format

		// Assume that there is no special background color for the line
		_fBackgroundColor = FALSE;
	}

	// Handle setting background color. If the current background
	// color is different than the default, we need to set the background
	// to this because the end of line processing reset the color so
	// that opaquing would work.
	if(_crBackground != _crCurBackground)
	{
		// Tell the window the background color
		::SetBkColor(_hdc, _crCurBackground);
		_fBackgroundColor = TRUE;
	}

	return hdcSave;
}

/*
 *	CRenderer::EraseToBottom()
 *
 *	@mfunc
 *		Erase from current display position to bottom of render RECT.
 *		Used by tables for last line in a display
 */
void CRenderer::EraseToBottom()
{
	if(_ptCur.v < _rcRender.bottom)
	{
		RECTUV rcErase = _rcRender;
		rcErase.top = _ptCur.v;
		EraseTextOut(GetDC(), &rcErase);
	}
}

/*
 *	CRenderer::RenderOutlineSymbol()
 *
 *	@mfunc
 *		Render outline symbol for current paragraph
 *
 *	@rdesc
 *		TRUE if outline symbol rendered
 */
BOOL CRenderer::RenderOutlineSymbol()
{
	AssertSz(IsInOutlineView(), 
		"CRenderer::RenderOutlineSymbol called when not in outline view");

	HBITMAP	hbitmap;
	LONG	height;
	LONG	width;
	LONG	up = _ptCur.u - _li._upStart + LUtoDU(lDefaultTab/2 * _pPF->_bOutlineLevel);
	LONG	vp = _ptCur.v;

	if(!g_hbitmapSubtext && InitializeOutlineBitmaps() != NOERROR)
		return FALSE;

    HDC hMemDC = CreateCompatibleDC(_hdc); // REVIEW: performance

    if(!hMemDC)
        return FALSE; //REVIEW: out of memory

	if(_pPF->_bOutlineLevel & 1)			// Subtext
	{
		width	= BITMAP_WIDTH_SUBTEXT;
		height	= BITMAP_HEIGHT_SUBTEXT;
		hbitmap	= g_hbitmapSubtext;
	}
	else									// Heading
	{
		width	= BITMAP_WIDTH_HEADING;
		height	= BITMAP_HEIGHT_HEADING;
		hbitmap	= g_hbitmapEmptyHeading;

		CPFRunPtr rp(*this);				// Check next PF for other
		LONG	  cch = _li._cch;		 	//  outline symbols

		if(_li._cch < rp.GetCchLeft())		// Set cch = count to heading
		{									//  EOP
			CTxtPtr tp(_rpTX);
			cch = tp.FindEOP(tomForward);
		}
		rp.Move(cch);						// Go to next paragraph
		if(rp.IsCollapsed())
			hbitmap	= g_hbitmapCollapsedHeading;

		else if(_pPF->_bOutlineLevel < rp.GetOutlineLevel())
			hbitmap	= g_hbitmapExpandedHeading;
	}

	if(!hbitmap)
		return FALSE;

    HBITMAP hbitmapDefault = (HBITMAP)SelectObject(hMemDC, hbitmap);

    // REVIEW: what if the background color changes?  Also, use a TT font
	// for symbols
	LONG dvpSymbol = _pdp->Zoom(height);
	LONG dvp = _li._dvpHeight - _li._dvpDescent - dvpSymbol;

	if(dvp > 0)
		dvp /= 2;
	else
		dvp = -dvp;

	POINTUV ptuv = {up, vp + dvp};
	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv);
    StretchBlt(_hdc, pt.x, pt.y, _pdp->Zoom(width), dvpSymbol, hMemDC, 0, 0, width, height, SRCCOPY);

    SelectObject(hMemDC, hbitmapDefault);
    DeleteDC(hMemDC);
	return TRUE;
}

/*
 *	CRenderer::RenderBullet()
 *
 *	@mfunc
 *		Render bullet at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderBullet");

	AssertSz(_pPF->_wNumbering, 
		"CRenderer::RenderBullet called for non-bullet");

	// Width of the bullet character
	LONG dup;

	// FUTURE: Unicode bullet is L'\x2022' We want to migrate to this and
	// other bullets
	LONG		cch;
	CCharFormat CF;
	WCHAR		szBullet[CCHMAXNUMTOSTR];

	CCcs *pccs = GetCcsBullet(&CF);

	if(!pccs)								// Bullet is suppressed because
		return TRUE;						//  preceding EOP is VT

	if(_pccs)
		_pccs->Release();

	_pccs = pccs;

	// Default to no underline
	_bUnderlineType = CFU_UNDERLINENONE;

	if(_pPF->IsListNumbered() && CF._dwEffects & CFE_UNDERLINE)
		SetupUnderline(CF._bUnderlineType, CF._bUnderlineColor);

	SetFontAndColor(&CF);

	LONG dupLineSave = _dupLine;
	LONG dupOffset = LUtoDU(_pPF->_wNumberingTab ? _pPF->_wNumberingTab : _pPF->_dxOffset);
	LONG upSave	   = _ptCur.u;

	// Set-up to render bullet in one chunk
	cch = GetBullet(szBullet, _pccs, &dup);
	dupOffset = max(dupOffset, dup);
	_dupLine = dupOffset;
	if(IsInOutlineView())
		dupOffset = _li._upStart - LUtoDU(lDefaultTab/2 * (_pPF->_bOutlineLevel + 1));
	_ptCur.u -= dupOffset;
	switch(_pPF->_wNumberingStyle & 3)
	{
		case tomAlignCenter:
			dup /= 2;						// Fall thru to tomAlignRight

		case tomAlignRight:
			_ptCur.u -= dup;
	}

	// Render bullet
	_fLastChunk = TRUE;
	RenderText(szBullet, cch);

	// Restore render vars to continue with remainder of line.
	_ptCur.u = upSave;
	_dupLine = dupLineSave;
	_li._dup = 0;

	// This releases the _pccs that we put in for the bullet
	SetNewFont();
	return TRUE;
}

/*
 *	CRenderer::DrawLine(ptStart, ptEnd)
 *
 *	@mfunc
 *		Rotate the points passed and then call the OS.
 */
void CRenderer::DrawLine(const POINTUV &ptStart, const POINTUV &ptEnd)
{
	POINT rgpt[2];
	_pdp->PointFromPointuv(rgpt[0], ptStart);
	_pdp->PointFromPointuv(rgpt[1], ptEnd);

	Polyline(_hdc, rgpt, 2);
}

/*
 *	CRenderer::RenderUnderline(upStart, vpStart, dup, dvp)
 *
 *	@mfunc
 *		Render underline
 */
void CRenderer::RenderUnderline(
	LONG upStart, 	//@parm Horizontal start of underline
	LONG vpStart,	//@parm Vertical start of underline
	LONG dup,		//@parm Length of underline
	LONG dvp)		//@parm Thickness of underline
{
	BOOL	 fUseLS = fUseLineServices();
	COLORREF crUnderline = _crUnderlineClr;
	RECTUV	 rcT, rcIntersection;

	rcT.top		= vpStart;
	rcT.bottom	= vpStart + dvp;
	rcT.left	= upStart;
	rcT.right	= upStart + dup;

	if (!IntersectRect((RECT*)&rcIntersection, (RECT*)&_rcRender, (RECT*)&rcT))
		return;		// Underline not inside rc, forget it.
	upStart = rcIntersection.left;
	dup = rcIntersection.right - rcIntersection.left;
	vpStart = rcIntersection.top;
	dvp = rcIntersection.bottom - rcIntersection.top;

	if (crUnderline == tomAutoColor || crUnderline == tomUndefined)
	{
		crUnderline = _crCurTextColor;
	}

	if (_bUnderlineType != CFU_INVERT &&
		!IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE) &&
		!IN_RANGE(CFU_UNDERLINEDOUBLEWAVE, _bUnderlineType, CFU_UNDERLINETHICKLONGDASH))
	{
		// Regular single underline case
		// Calculate where to put underline
		rcT.top = vpStart;

		if (CFU_UNDERLINETHICK == _bUnderlineType)
		{
			if (rcT.top > _rcRender.top + dvp)
			{
				rcT.top -= dvp;
				dvp += dvp;
			}
		}

		// There are some cases were the following can occur - particularly
		// with bullets on Japanese systems.
		if(!fUseLS && rcT.top >= _ptCur.v + _li._dvpHeight)
			rcT.top = _ptCur.v + _li._dvpHeight - dvp;

		rcT.bottom	= rcT.top + dvp;
		rcT.left	= upStart;
		rcT.right	= upStart + dup;
		FillRectWithColor(&rcT, crUnderline);
		return;
	}

	if(_bUnderlineType == CFU_INVERT)			// Fake selection.
	{											// NOTE, not really
		rcT.top	= _ptCur.v;						// how we should invert text!!
		rcT.left = upStart;						// check out IME invert.
		rcT.bottom = rcT.top + _li._dvpHeight - _li._dvpDescent + _pccs->_yDescent;
		rcT.right = rcT.left + dup;

		RECT rc;
		_pdp->RectFromRectuv(rc, rcT);
  		InvertRect(_hdc, &rc);
		return;
	}

	if(IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE) ||
	   IN_RANGE(CFU_UNDERLINEDOUBLEWAVE, _bUnderlineType, CFU_UNDERLINETHICKLONGDASH))
	{
		static const char pen[] = {PS_DOT, PS_DASH, PS_DASHDOT, PS_DASHDOTDOT, PS_SOLID, 
			                       PS_SOLID, PS_SOLID, PS_SOLID, PS_SOLID, PS_DASH, PS_DASH,
		                           PS_DASHDOT, PS_DASHDOTDOT, PS_DOT, PS_DASHDOT};

		HPEN hPen = CreatePen(pen[_bUnderlineType - CFU_UNDERLINEDOTTED], 1, crUnderline);	
		if(hPen)
		{
			HPEN hPenOld = SelectPen(_hdc, hPen);
			LONG upEnd = upStart + dup;
			POINTUV ptStart, ptEnd;

			ptStart.u = upStart;
			ptStart.v = vpStart;
			if((_bUnderlineType == CFU_UNDERLINEWAVE) || 
			   (_bUnderlineType == CFU_UNDERLINEDOUBLEWAVE) ||
			   (_bUnderlineType == CFU_UNDERLINEHEAVYWAVE))
			{
				LONG dv	= 1;					// Vertical displacement
				LONG u	= upStart + 1;			// u coordinate
				upEnd++;						// Round up rightmost u
				for( ; u < upEnd; dv = -dv, u += 2)
				{
					ptEnd.u = u;
					ptEnd.v = vpStart + dv;
					DrawLine(ptStart, ptEnd);
					ptStart = ptEnd;
				}
			}
			else
			{
				ptEnd.u = upEnd;
				ptEnd.v = vpStart;
				DrawLine(ptStart, ptEnd);
			}

			if(hPenOld)							// Restore original pen.
				SelectPen(_hdc, hPenOld);

			DeleteObject(hPen);
		}
	}
}

/*
 *	CRenderer::RenderStrikeOut(upStart, vpStart, dup, dvp)
 *
 *	@mfunc
 *		Render strikeout
 */
void CRenderer::RenderStrikeOut(
	LONG upStart, 	//@parm start of strikeout
	LONG vpStart,	//@parm start of strikeout
	LONG dup,		//@parm Length of strikeout
	LONG dvp)		//@parm Thickness of strikeout
{
	RECTUV rcT, rcIntersection;

	// Calculate where to put strikeout rectangle 
	rcT.top		= vpStart;
	rcT.bottom	= vpStart + dvp;
	rcT.left	= upStart;
	rcT.right	= upStart + dup;

	if (!IntersectRect((RECT*)&rcIntersection, (RECT*)&_rcRender, (RECT*)&rcT))
		return;		// Line not inside rc, forget it.

	FillRectWithColor(&rcIntersection, GetTextColor(GetCF()));
}

/*
 *	CRenderer::FillRectWithTextColor(prc, cr)
 *
 *	@mfunc
 *		Fill input rectangle with current color of text
 */
void CRenderer::FillRectWithColor(
	const RECTUV *	 prc,		//@parm Rectangle to fill with color
	COLORREF cr)		//@parm Color to use
{
	// Create a brush with the text color
	HBRUSH hbrush = CreateSolidBrush(_fDisabled ? _crForeDisabled : cr);

	// Note if the CreateSolidBrush fails we just ignore it since there
	// isn't anything we can do about it anyway.
	if(hbrush)
	{
		// Save old brush
		HBRUSH hbrushOld = (HBRUSH)SelectObject(_hdc, hbrush);

		// Fill rectangle for underline
		RECT rc;
		_pdp->RectFromRectuv(rc, *prc);
		PatBlt(_hdc, rc.left, rc.top, rc.right - rc.left,
			   rc.bottom - rc.top, PATCOPY);
		SelectObject(_hdc, hbrushOld);	// Put old brush back
		DeleteObject(hbrush);			// Free brush we created.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\range.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RANGE.C - Implement the CTxtRange Class |
 *	
 *		This module implements the internal CTxtRange methods.
 *		See tomrange.cpp for the ITextRange methods.
 *
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	Revisions: <nl>
 *		AlexGo: update to runptr text ptr; floating ranges, multilevel undo
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_text.h"
#include "_rtext.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_disp.h"
#include "_uspi.h"
#include "_rtfconv.h"
#include "_txtbrk.h"
#include "_font.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

ASSERTDATA

WCHAR	szEmbedding[] = {WCH_EMBEDDING, 0};

// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtRange::Invariant( void ) const
{
	LONG cpMin, cpMost;
	GetRange(cpMin, cpMost);

	Assert ( cpMin >= 0 );
	Assert ( cpMin <= cpMost );
	Assert ( cpMost <= GetTextLength() );
	Assert ( cpMin != cpMost || cpMost <= GetAdjustedTextLength());

	static LONG	numTests = 0;
	numTests++;				// how many times we've been called.

	// make sure the selections are in range.

	return CRchTxtPtr::Invariant();
}

BOOL CTxtRange::IsOneEndUnHidden() const
{
	CCFRunPtr rp(*this);
	rp.AdjustBackward();
	if(!rp.IsHidden())
		return TRUE;
	rp.AdjustForward();
	if(!rp.IsHidden())
		return TRUE;
	if(!_cch)
		return FALSE;
	rp.Move(-_cch);
	if(!rp.IsHidden())
		return TRUE;
	rp.AdjustBackward();
	if(!rp.IsHidden())
		return TRUE;
	return FALSE;
}

#endif

void CTxtRange::RangeValidateCp(LONG cp, LONG cch)
{
	LONG cchText = GetAdjustedTextLength();
	LONG cpOther = cp - cch;			// Calculate cpOther with entry cp

	_wFlags = FALSE;					// This range isn't a selection
	_iFormat = -1;						// Set up the default format, which
										//  doesn't get AddRefFormat'd
	ValidateCp(cpOther);				// Validate requested other end
	cp = GetCp();						// Validated cp
	if(cp == cpOther && cp > cchText)	// IP cannot follow undeletable
		cp = cpOther = SetCp(cchText, FALSE);//  EOP at end of story

	_cch = cp - cpOther;				// Store valid length
}

CTxtRange::CTxtRange(CTxtEdit *ped, LONG cp, LONG cch) :
	CRchTxtPtr(ped, cp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	RangeValidateCp(cp, cch);
	Update_iFormat(-1);					// Choose _iFormat

	CNotifyMgr *pnm = ped->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(CRchTxtPtr& rtp, LONG cch) :
	CRchTxtPtr(rtp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	RangeValidateCp(GetCp(), cch);
	Update_iFormat(-1);					// Choose _iFormat

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(const CTxtRange &rg) :
	CRchTxtPtr((CRchTxtPtr)rg)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	_cch = rg._cch;
	_wFlags = FALSE;				// This range isn't a selection
	_iFormat = -1;					// Set up the default format, which
									//  doesn't get AddRefFormat'd
	Set_iCF(rg._iFormat);

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add((ITxNotify *)this);
}

CTxtRange::~CTxtRange()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::~CTxtRange");

	if(!IsZombie())
	{
		CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
		if(pnm )
			pnm->Remove((ITxNotify *)this);
	}
	ReleaseFormats(_iFormat, -1);
}

CRchTxtPtr& CTxtRange::operator =(const CRchTxtPtr &rtp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

	_TEST_INVARIANT_ON(rtp)

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::operator =(rtp);
	Assert(FALSE);
	CheckChange(cpSave, FALSE);
	return *this;
}

CTxtRange& CTxtRange::operator =(const CTxtRange &rg)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

	_TEST_INVARIANT_ON( rg );

	LONG cchSave = _cch;			// Save entry _cp, _cch for change check
	LONG cpSave  = GetCp();

	CRchTxtPtr::operator =(rg);
	_cch = rg._cch;

	Update_iFormat(-1);
	_TEST_INVARIANT_

	if( _fSel && (cpSave != GetCp() || cchSave != _cch) )
		GetPed()->GetCallMgr()->SetSelectionChanged();

	return *this;
}

/*
 *	CTxtRange::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *									cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		called when the backing store changes
 *
 *	@devnote
 *		1) if this range is before the changes, do nothing
 *
 *		2) if the changes are before this range, simply
 *		add the delta change to GetCp()
 *
 *		3) if the changes overlap one end of the range, collapse
 *		that end to the edge of the modifications
 *
 *		4) if the changes are completely internal to the range,
 *		adjust _cch and/or GetCp() to reflect the new size.  Note
 *		that two overlapping insertion points will be viewed as
 *		a 'completely internal' change.
 *
 *		5) if the changes overlap *both* ends of the range, collapse
 *		the range to cp
 *
 *		Note that there is an ambiguous cp case; namely the changes
 *		occur *exactly* at a boundary.  In this case, the type of
 *		range matters.  If a range is normal, then the changes
 *		are assumed to fall within the range.  If the range is
 *		is protected (either in reality or via DragDrop), then
 *		the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPreReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN == cp)
	{
		// We need to dump our formatting because it is gone
		_rpCF.SetToNull();
		_rpPF.SetToNull();

		if(_fSel)
			GetPed()->_fUpdateSelection = TRUE;	

		Update_iFormat(-1);
		return;
	}
}

/*
 *	CTxtRange::OnPostReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *									cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		called when the backing store changes
 *
 *	@devnote
 *		1) if this range is before the changes, do nothing
 *
 *		2) if the changes are before this range, simply
 *		add the delta change to GetCp()
 *
 *		3) if the changes overlap one end of the range, collapse
 *		that end to the edge of the modifications
 *
 *		4) if the changes are completely internal to the range,
 *		adjust _cch and/or GetCp() to reflect the new size.  Note
 *		that two overlapping insertion points will be viewed as
 *		a 'completely internal' change.
 *
 *		5) if the changes overlap *both* ends of the range, collapse
 *		the range to cp
 *
 *		Note that there is an ambiguous cp case; namely the changes
 *		occur *exactly* at a boundary.  In this case, the type of
 *		range matters.  If a range is normal, then the changes
 *		are assumed to fall within the range.  If the range is
 *		is protected (either in reality or via DragDrop), then
 *		the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPostReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPostReplaceRange");

	// NB!! We can't do invariant testing here, because we could
	// be severely out of date!

	LONG cchtemp;
	LONG cpMin, cpMost;
	LONG cchAdjTextLen;
	LONG delta = cchNew - cchDel;

	Assert (CONVERT_TO_PLAIN != cp);
	GetRange(cpMin, cpMost);
	
	// This range is before the changes. Note: an insertion pt at cp
	// shouldn't be changed
	if( cp >= cpMost )
	{
		if (pNotifyData)
		{
			if (pNotifyData->id == NOTIFY_DATA_TEXT_ID && 
				(pNotifyData->dwFlags & TN_TX_CELL_SHRINK))	// Rebind TX cp if cell number decrease.
				_rpTX.BindToCp(GetCp());							//	or else we may be using the wrong cell.
		}

		// Double check to see if we need to fix up our format
		// run pointers.  If so, all we need to do is rebind
		// our inherited rich text pointer

		if(cpFormatMin <= cpMost || cpFormatMin == CP_INFINITE)
			InitRunPtrs();

		else
		{
		 	// It's possible that the format runs changed anyway,
			// e.g., they became allocated, deallocated, or otherwise
			// changed.  Normally, BindToCp takes care of this
			// situation, but we don't want to pay that cost all
			// the time.
			//
			// Note that starting up the rich text subsystem will
			// generate a notification with cpFormatMin == CP_INFINITE
			//
			// So here, call CheckFormatRuns.  This makes sure that
			// the runs are in sync with what CTxtStory has
			// (doing an InitRunPtrs() _only_ if absolutely necessary).
			CheckFormatRuns();
		}
		return;
	}


	// Anywhere in the following that we want to increment the current cp by a
	// delta, we are counting on the following invariant.
	Assert(GetCp() >= 0);

	// Changes are entirely before this range.  Specifically,
	// that's determined by looking at the incoming cp *plus* the number
	// of characters deleted
	if(cp + cchDel < cpMin || _fDragProtection && cp + cchDel <= cpMin)
	{
		cchtemp = _cch;
		BindToCp(GetCp() + delta);
		_cch = cchtemp;
	}	
	// The changes are internal to the range or start within the
	// range and go beyond.
	else if( cp >= cpMin && cp <= cpMost )
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		if( cp + cchDel <= cpMost )
		{
			// Changes are purely internal, so
			// be sure to preserve the active end.  Basically, if
			// GetCp() *is* cpMin, then we only need to update _cch.
			// Otherwise, GetCp() needs to be moved as well
			if( _cch >= 0 )
			{
				Assert(GetCp() == cpMost);
				cchtemp = _cch;
				BindToCp(GetCp() + delta);
				_cch = cchtemp + delta;
			}
			else
			{
				BindToCp(GetCp());
				_cch -= delta;
			}

			// Special case: the range is left with only the final EOP
			// selected. This means all the characters in the range were
			// deleted so we want to move the range back to an insertion
			// point at the end of the text.
			cchAdjTextLen = GetAdjustedTextLength();

			if(GetCpMin() >= cchAdjTextLen && !GetPed()->IsStreaming())
			{
				// Reduce the range to an insertion point
				_cch = 0;

				// Set the cp to the end of the document.
				SetCp(cchAdjTextLen, FALSE);
			}
		}
		else
		{
			// Changes extended beyond cpMost.  In this case,
			// we want to truncate cpMost to the *beginning* of
			// the changes (i.e. cp)

			if( _cch > 0 )
			{
				BindToCp(cp);
				_cch = cp - cpMin;
			}
			else
			{
				BindToCp(cpMin);
				_cch = cpMin - cp;
			}
		}
	}
	else if( cp + cchDel >= cpMost )
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		// Entire range was deleted, so collapse to an insertion point at cp
		BindToCp(cp);
		_cch = 0;
	}
	else
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		// The change crossed over just cpMin.  In this case move cpMin
		// forward to the unchanged part
		LONG cchdiff = (cp + cchDel) - cpMin;

		Assert( cp + cchDel < cpMost );
		Assert( cp + cchDel >= cpMin );
		Assert( cp < cpMin );

		cchtemp = _cch;
		if( _cch > 0 )
		{
			BindToCp(GetCp() + delta);
			_cch = cchtemp - cchdiff;
		}
		else
		{
			BindToCp(cp + cchNew);
			_cch = cchtemp + cchdiff;
		}
	}

	if( _fSel )
	{
		GetPed()->_fUpdateSelection = TRUE;		
		GetPed()->GetCallMgr()->SetSelectionChanged();
	}

	Update_iFormat(-1);					// Make sure _iFormat is up to date

	_TEST_INVARIANT_
}	

/*
 *	CTxtRange::Zombie ()
 *
 *	@mfunc
 *		Turn this range into a zombie (_cp = _cch = 0, NULL ped, ptrs to
 *		backing store arrays.  CTxtRange methods like GetRange(),
 *		GetCpMost(), GetCpMin(), and GetTextLength() all work in zombie mode,
 *		returning zero values.
 */
void CTxtRange::Zombie()
{
	CRchTxtPtr::Zombie();
	_cch = 0;
}

/*
 *	CTxtRange::CheckChange(cpSave, fExtend)
 *
 *	@mfunc
 *		Set _cch according to fExtend and set selection-changed flag if
 *		this range is a CTxtSelection and the new _cp or _cch differ from
 *		cp and cch, respectively.
 *
 *	@devnote
 *		We can count on GetCp() and cpSave both being <= GetTextLength(),
 *		but we can't leave GetCp() equal to GetTextLength() unless _cch ends
 *		up > 0.
 */
LONG CTxtRange::CheckChange(
	LONG cpSave,		//@parm Original _cp for this range
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	LONG cchAdj = GetAdjustedTextLength();
	LONG cchSave = _cch;

	if(fExtend)									// Wants to be nondegenerate
	{											//  and maybe it is
		LONG cp = GetCp();

		_cch = cp - (cpSave - cchSave);
		CheckIfSelHasEOP(cpSave, cchSave);
	}
	else
	{
		_cch = 0;								// Insertion point
		_fSelHasEOP = FALSE;					// Selection doesn't contain
		_fSelExpandCell = FALSE;				//  any char, let alone a CR
		_nSelExpandLevel = 0;					//  or table cell or row
	}											

	if(!_cch && GetCp() > cchAdj)				// If still IP and active end
		CRchTxtPtr::SetCp(cchAdj);				//  follows nondeletable EOP,
												//  backspace over that EOP
	LONG cch = GetCp() - cpSave;
	_fMoveBack = cch < 0;

	if(cch || cchSave != _cch)
	{
		Update_iFormat(-1);
		if(_fSel)
			GetPed()->GetCallMgr()->SetSelectionChanged();

		_TEST_INVARIANT_
	}

	return cch;
}

/*
 *	CTxtRange::CheckIfSelHasEOP(cpSave, cchSave, fDoRange)
 *	
 *	@mfunc
 *		Maintains _fSelHasEOP = TRUE iff selection contains one or more EOPs.
 *		When cpSave = -1, calculates _fSelHasEOP unconditionally and cchSave
 *		is ignored (it's only used for conditional execution). Else _fSelHasEOP
 *		is only calculated for cases that may change it, i.e., it's assumed
 *		be up to date before the change.
 *
 *	@rdesc
 *		TRUE iff (_fSel or fDoRange) and _cch
 *
 *	@devnote
 *		Call after updating range _cch
 */
BOOL CTxtRange::CheckIfSelHasEOP(
	LONG cpSave,	//@parm Previous active end cp or -1
	LONG cchSave,	//@parm Previous signed length if cpSave != -1
	BOOL fDoRange)	//@parm Do function even if !_fSel
{
	// _fSelHasEOP only maintained for the selection
	if(!_fSel && !fDoRange)
		return FALSE;

	_fSelExpandCell = FALSE;			// Default no need to expand
	_nSelExpandLevel = 0;				// to table row/cell
	if(!_cch)
	{
		_fSelHasEOP  = FALSE;			// Selection doesn't contain
		return FALSE;					// CR, CELL or table row delims
	}

	LONG cpMin, cpMost;					
	LONG cpMinPrev  = cpSave;
	LONG cpMostPrev = cpSave;
	LONG FEOP_Results;

	GetRange(cpMin, cpMost);

	if(cpSave != -1)					// Selection may have changed
	{									
		if(cchSave > 0)					// Calculate previous cpMin
			cpMinPrev  -= cchSave;		//  and cpMost
		else
			cpMostPrev -= cchSave;

		if(!_fSelHasEOP && cpMin >= cpMinPrev && cpMost <= cpMostPrev)
			return TRUE;				// _fSelHasEOP can't change
	}									//  nor can _fSelHasCell/Row
	
	CTxtPtr tp(_rpTX);					
	if (!_fSelHasEOP || cpSave == -1 ||	// If any of these conditions, scan
		cpMin > cpMinPrev ||			//  range for an EOP. Could be
		cpMost < cpMostPrev)			//  CELL or CR. Table row delims have
	{									//  CRs, so catch them too
		tp.SetCp(cpMin);				
		tp.FindEOP(cpMost - cpMin, &FEOP_Results);
		_fSelHasEOP = (FEOP_Results & FEOP_EOP) != 0;
	}

	if(_fSelHasEOP && _rpPF.IsValid())	// Might have CELL or unmatched table
		CalcTableExpandParms();			//  row delim at range table level
	return TRUE;
}

/*
 *	CTxtRange::CalcTableExpandParms()
 *	
 *	@mfunc
 *		Calculate _fSelExpandCell and _nSelExpandLevel for ensuring that
 *		range selects a valid table piece (fraction of single cell,
 *		multiple, but not all, cells in a table row, one or more table
 *		rows.
 */
void CTxtRange::CalcTableExpandParms()
{
	LONG cpMin, cpMost;
	LONG cch = GetRange(cpMin, cpMost);
	CPFRunPtr rp(*this);

	if(_cch > 0)
		rp.Move(-_cch);					// Start at cpMin
	_fSelExpandCell = FALSE;			// Default no need to expand
	_nSelExpandLevel = 0;				// to table row/cell

	LONG cchRun;
	LONG LevelCpMin  = rp.GetTableLevel();
	LONG LevelCpMost = LevelCpMin;
	LONG LevelMin	 = LevelCpMin;
	LONG LevelTRDMin = tomForward;

	while(cch > 0)						// Walk range fast using PF runs
	{									//  gathering table level info
		LevelCpMost = rp.GetTableLevel();
		LevelMin = min(LevelMin, LevelCpMost);
		if(rp.IsTableRowDelimiter())
			LevelTRDMin = min(LevelTRDMin, LevelCpMost);
		cchRun = rp.GetCchLeft();
		cch -= cchRun;
		rp.Move(cchRun);
	}
	if(!(LevelCpMin | LevelCpMost))		// If beginning & end are 0, we're done
		return;

	if(LevelCpMin  >= LevelTRDMin ||	// Crossed a table-row delimiter
	   LevelCpMost >= LevelTRDMin)		//  of minimum level
	{
		Assert(LevelTRDMin < 16);		// Only nibble is allocated
		_nSelExpandLevel = LevelTRDMin;
		if(LevelTRDMin == LevelMin)
			return;						// Expand to LevelTRDMin
	}

	// At least one end has a table level < minimum table row delim level.
	// May need to expand to row, but check if a CELL is included
	// at the minimum level, in which case, need to expand to Cell.
	if(cch < 0)
		rp.Move(cch);					// rp is at cpMost

	LONG	cp = cpMost;
	CTxtPtr tp(_rpTX);

	for(cch = cpMost - cpMin; cch > 0; )
	{
		rp.AdjustBackward();
		Assert(rp.GetIch() || rp._iRun);
		if(rp.GetTableLevel() == LevelMin)
		{								// Only look for CELLs at min level
			LONG cchFind;
			cchRun = rp.GetIch();
			cchRun = min(cchRun, cch);
			tp.SetCp(cp);
			while(cchRun > 0)
			{
				if(tp.GetPrevChar() == CELL)
				{
					_fSelExpandCell = TRUE;
					_nSelExpandLevel = 0;
					return;				// Found a CELL at min level, so need
				}						//  to expand to Cell at that level
				cchFind = tp.FindEOP(-cchRun, NULL);
				if(!cchFind)
					break;
				cchRun += cchFind;
			}
		}
		cch -= rp.GetIch();				// Go back to previous PF run
		cp -= rp.GetIch();				// Cheaper to move cp than tp
		rp.SetIch(0);					// (might be at/before cpMin)
	}
}

/*
 *	CTxtRange::CheckTableSelection(fUpdate, fEnableExpandCell, pfTRDsInvolved, dwFlags)
 *	
 *	@mfunc
 *		Select only the first cell if one or more CELLs are selected, but
 *		not the whole row, at the minimum table level.
 *
 *	@rdesc
 *		TRUE iff selected only contents of first cell in range without the
 *		CELL mark
 */
BOOL CTxtRange::CheckTableSelection (
	BOOL  fUpdate,			//@parm Call Update() if change occurs
	BOOL  fEnableExpandCell,//@parm If TRUE select only 1st cell of multiple
	BOOL *pfTRDsInvolved,	//@parm Out parm to say if TRDs at range ends
	DWORD dwFlags)			//@parm Flags for ReplaceRange()
{
	LONG cpMin, cpMost;
	BOOL fRet = FALSE;
	BOOL fTRDsInvolved = FALSE;

	AdjustCRLF(1);
	if(!_cch)
	{
		while(_rpTX.IsAtTRD(0))
			AdvanceCRLF(CSC_NORMAL, FALSE);
		goto checkLP;
	}

	if(!_fSel && _rpPF.IsValid())			// It's a range; find out if
	{										//  tables are involved
		CPFRunPtr rp(*this);
		LONG cch = _cch;

		if(_cch > 0)						// Active end at cpMost: will
			rp.AdjustBackward();			//  scan backward

		while(!rp.InTable())
		{
			if(_cch > 0)
			{
				cch -= rp.GetIch();
				if(!rp.PrevRun())
					goto checkLP;			// Done, since not in table
				cch -= rp.GetCchLeft();
				if(cch <= 0)
					goto checkLP;			// Ditto
			}
			else
			{
				cch += rp.GetCchLeft();
				if(cch >= 0 || !rp.NextRun())
					goto checkLP;			// Not in table
			}
		}
		// Range fiddling with tables: calc whether to expand to cell or row
		// NB: expand to cell/row includes contained nested tables.
		CalcTableExpandParms();
		if(!_fSelExpandCell && _nSelExpandLevel)
		{									// Expand to row (but not to cell)
			FindRow(&cpMin, &cpMost, _nSelExpandLevel);
			Set(cpMost, cpMost - cpMin);
			_nSelExpandLevel = 0;
			fTRDsInvolved = TRUE;
			goto checkLP;
		}
	}
	if(_fSelExpandCell && fEnableExpandCell)// Partial row selected
	{										// Reduce selection to contents
		Collapser(TRUE);					//  of first cell
		while(_rpTX.IsAtTRD(STARTFIELD))
			AdvanceCRLF(CSC_NORMAL, FALSE);
		FindCell(&cpMin, &cpMost);
		Assert(cpMost > cpMin || _rpTX.GetChar() == CELL && _rpTX.IsAtStartOfCell());
		cpMost--;
		Set(cpMost, cpMost - cpMin);
		Assert(!_fSelExpandCell);
		if(fUpdate)
			Update(TRUE);
		fRet = TRUE;
	}
	if(pfTRDsInvolved)						// Caller wants to know if table-
	{										//  row-delimiters are involved
		CPFRunPtr rp(*this);
		rp.AdjustForward();
		fTRDsInvolved = TRUE;				// Default TRUE
		if(!rp.IsTableRowDelimiter())		// Check both sides of one end
		{
			rp.AdjustBackward();
			if(!rp.IsTableRowDelimiter())
			{
				rp.Move(-_cch);				// Check both sides of other end
				if(!rp.IsTableRowDelimiter())
				{
					rp.AdjustBackward();
					if(!rp.IsTableRowDelimiter())
						fTRDsInvolved = FALSE;// Neither end has TRD
				}
			}
		}
	}

checkLP:
	LONG iFormat = _iFormat;
	if(CheckLinkProtection(dwFlags, iFormat))
		Set_iCF(iFormat);

	if(pfTRDsInvolved)
		*pfTRDsInvolved = fTRDsInvolved;
	return fRet;
}

/*
 *	CTxtRange::CheckLinkProtection(&dwFlags, &iFormat)
 *
 *	@mfunc
 *		If friendly part of link is selected, select hidden part too.
 *
 *	@rdesc
 *		TRUE iff change made
 */
BOOL CTxtRange::CheckLinkProtection(
	DWORD & dwFlags,
	LONG  & iFormat)
{
	if(dwFlags & RR_NO_LP_CHECK)
		return FALSE;

	LONG	  cpMin, cpMost;
	LONG	  cch = GetRange(cpMin, cpMost);
	CCFRunPtr rp(*this);

	if(_cch > 0)							// Ensure rp is positioned at
		rp.Move(-_cch);						//  cpMin

	rp.AdjustBackward();
	DWORD dw = rp.GetEffects();
	if((dw & (CFE_LINKPROTECTED | CFE_HIDDEN)) == (CFE_LINKPROTECTED | CFE_HIDDEN))
	{
		if(_cch)
		{
			if(!cpMin)						// Already at start of inst field
				return FALSE;
											// If deleting rest of friendly
			while(cch >= 0)					//  hyperlink name, need to
			{								//  delete instruction field too
				if(!rp.IsLinkProtected())
				{
					FindAttributes(&cpMin, NULL, CFE_LINKPROTECTED | 0x80000000);
					Set(cpMin, cpMin - cpMost);
					return TRUE;
				}
				cch -= rp.GetCchLeft();
				rp.NextRun();
			}
		}
		else
		{
			// Inserting new text between hidden and friendly part of hyperlink:
			// back up over hidden part
			FindAttributes(&cpMin, NULL, CFE_LINKPROTECTED | 0x80000000);
			SetCp(cpMin, FALSE);
			dwFlags |= RR_UNHIDE;
			_rpCF.AdjustBackward();
			iFormat = _rpCF.GetFormat();
			return TRUE;
		}
	}
	else if(!(dw & CFE_LINK) && GetPed()->GetCharFormat(iFormat)->_dwEffects & CFE_LINK)
	{
		iFormat = rp.GetFormat();
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtRange::GetRange(&cpMin, &cpMost)
 *	
 *	@mfunc
 *		set cpMin  = this range cpMin
 *		set cpMost = this range cpMost
 *		return cpMost - cpMin, i.e. abs(_cch)
 *	
 *	@rdesc
 *		abs(_cch)
 */
LONG CTxtRange::GetRange (
	LONG& cpMin,				//@parm Pass-by-ref cpMin
	LONG& cpMost) const			//@parm Pass-by-ref cpMost
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetRange");

	LONG cch = _cch;

	if(cch >= 0)
	{
		cpMost	= GetCp();
		cpMin	= cpMost - cch;
	}
	else
	{
		cch		= -cch;
		cpMin	= GetCp();
		cpMost	= cpMin + cch;
	}
	return cch;
}

/*
 *	CTxtRange::GetCpMin()
 *	
 *	@mfunc
 *		return this range's cpMin
 *	
 *	@rdesc
 *		cpMin
 *
 *	@devnote
 *		If you need cpMost and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMin() const
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMin");

	LONG cp = GetCp();
	return _cch <= 0 ? cp : cp - _cch;
}

/*
 *	CTxtRange::GetCpMost()
 *	
 *	@mfunc
 *		return this range's cpMost
 *	
 *	@rdesc
 *		cpMost
 *
 *	@devnote
 *		If you need cpMin and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMost() const
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMost");

	LONG cp = GetCp();
	return _cch >= 0 ? cp : cp - _cch;
}

/*
 *	CTxtRange::Update(fScrollIntoView)
 *
 *	@mfunc
 *		Virtual stub routine overruled by CTxtSelection::Update() when this
 *		text range is a text selection.  The purpose is to update the screen
 *		display of the caret or	selection to correspond to changed cp's.
 *
 *	@rdesc
 *		TRUE
 */
BOOL CTxtRange::Update (
	BOOL fScrollIntoView)		//@parm TRUE if should scroll caret into view
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update");

	return TRUE;				// Simple range has no selection colors or
}								//  caret, so just return TRUE

/*
 * CTxtRange::SetCp(cp, fExtend)
 *
 *	@mfunc
 *		Set active end of this range to cp. Leave other end where it is or
 *		collapse range depending on fExtend (see CheckChange()).
 *
 *	@rdesc
 *		cp at new active end (may differ from cp, since cp may be invalid).
 */
LONG CTxtRange::SetCp(
	LONG cp,			//@parm new cp for active end of this range
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtRange::SetCp");

	LONG cpSave = GetCp();

	CRchTxtPtr::SetCp(cp);
	CheckChange(cpSave, fExtend);			// NB: this changes _cp if after
	return GetCp();							//  final CR and _cch = 0
}

/*
 *	CTxtRange::Set (cp, cch)
 *	
 *	@mfunc
 *		Set this range's active-end cp and signed cch
 *
 *	@rdesc
 *		TRUE if range cp or cch changed.
 */
BOOL CTxtRange::Set (
	LONG cp,					//@parm Desired active end cp
	LONG cch)					//@parm Desired signed count of chars
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set");

	BOOL bRet	 = FALSE;
	LONG cchSave = _cch;			// Save entry _cp, _cch for change check
	LONG cchText = GetAdjustedTextLength();
	LONG cpSave  = GetCp();
	LONG cpOther = cp - cch;		// Desired "other" end

	ValidateCp(cp);							// Be absolutely sure to validate
	ValidateCp(cpOther);					//  both ends

	if(cp == cpOther && cp > cchText)		// IP cannot follow undeletable
		cp = cpOther = cchText;				//  EOP at end of story

	CRchTxtPtr::Move(cp - GetCp());
	AssertSz(cp == GetCp(),
		"CTxtRange::Set: inconsistent cp");

	if(GetPed()->fUseCRLF())
	{
		cch = _rpTX.AdjustCRLF();
		if(cch)
		{
			_rpCF.Move(cch);			// Keep all 3 runptrs in sync
			_rpPF.Move(cch);
			cp = GetCp();
		}
		if(cpOther != cp)
		{
			CTxtPtr tp(_rpTX);
			tp.Move(cpOther - cp);
			cpOther += tp.AdjustCRLF();
		}
	}

	_cch = cp - cpOther;					// Validated _cch value
	CheckIfSelHasEOP(cpSave, cchSave);		// Maintain _fSelHasEOP in
											//  outline mode
	_fMoveBack = GetCp() < cpSave;

	if(cpSave != GetCp() || cchSave != _cch)
	{
		if(_fSel)
			GetPed()->GetCallMgr()->SetSelectionChanged();

		Update_iFormat(-1);
		bRet = TRUE;
	}
	
	_TEST_INVARIANT_
	return bRet;
}

/*
 *	CTxtRange::Move(cch, fExtend)
 *
 *	@mfunc
 *		Advance active end of range by cch.
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::Move (
	LONG cch,			//@parm Signed char count to move active end
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Move");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()
		
	CRchTxtPtr::Move(cch);
	return CheckChange(cpSave, fExtend);
}	

/*
 *	CTxtRange::AdvanceCRLF(csc, fExtend)
 *
 *	@mfunc
 *		Advance active end of range one char, treating CRLF as a single char.
 *		Other end stays put iff fExtend is nonzero.
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::AdvanceCRLF(
	CSCONTROL csc,		//@parm Complex Script Control
	BOOL	  fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::AdvanceCRLF");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::AdvanceCRLF();
#ifndef NOCOMPLEXSCRIPTS
	if(csc == CSC_SNAPTOCLUSTER)
		SnapToCluster(1);			// Snap to cluster forward
#endif
	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::BackupCRLF(csc, fExtend)
 *
 *	@mfunc
 *		Backup active end of range one char, treating CRLF as a single char.
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch actually moved
 */
LONG CTxtRange::BackupCRLF(
	CSCONTROL csc,		//@parm Complex Script Control
	BOOL	  fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::BackupCRLF");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()
	
	CRchTxtPtr::BackupCRLF(csc != CSC_NOMULTICHARBACKUP);

#ifndef NOCOMPLEXSCRIPTS
	if(csc == CSC_SNAPTOCLUSTER)
		SnapToCluster(-1);			// Snap to cluster backward
#endif

	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::AdjustCRLF(iDir)
 *
 *	@mfunc
 *		Adjust the position of this range's ends to the beginning of a CRLF
 *		or CRCRLF combination, if it is in the middle of such a combination.
 *		Move range end to the end of a Unicode surrogate pair or a STARTFIELD/
 *		ENDFIELD pair if it is in the middle of such a pair. Similarly move
 *		the range start to the beginning of such a pair.
 *
 *	@rdesc
 *		TRUE iff change occurred
 */
BOOL CTxtRange::AdjustCRLF(
	LONG iDir)		//@parm Move forward/backward for iDir = 1/-1, respectively
{
	LONG cch;
	if(!_cch)								// Insertion point
	{
		cch = _rpTX.AdjustCRLF(iDir);
		if(cch)
		{
			_rpCF.Move(cch);
			_rpPF.Move(cch);
			return TRUE;
		}
		return FALSE;
	}

	CTxtPtr tp(_rpTX);						// Nondegenerate range
	cch = _cch + tp.AdjustCRLF(_cch);		// Adjust active end

	LONG cp = tp.GetCp();					// Possibly new active end
	tp.Move(-cch);							// Go to other end
	cch -= tp.AdjustCRLF(-cch); 			// Calc its adjustment
	if(cch != _cch || cp != GetCp())		// If adjustment occurred,
	{										//  set new values
		Set(cp, cch);							
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtRange::FindWordBreak(action, fExtend)
 *
 *	@mfunc
 *		Move active end as determined by plain-text FindWordBreak().
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::FindWordBreak (
	INT  action,		//@parm action defined by CTxtPtr::FindWordBreak()
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::FindWordBreak(action);
	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::FlipRange()
 *
 *	@mfunc
 *		Flip active and non active ends
 */
void CTxtRange::FlipRange()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FlipRange");

	_TEST_INVARIANT_

	CRchTxtPtr::Move(-_cch);
	_cch = -_cch;
}

/*
 *	CTxtRange::HexToUnicode(publdr)
 *	
 *	@mfunc
 *		Convert hex number ending at this range's cpMost to a Unicode
 *		character and replace the hex number by that character. Take into
 *		account	Unicode surrogates for hex values from 0x10000 up to 0x10FFFF.
 *	
 *	@rdesc
 *		HRESULT S_OK if conversion successful and hex number is replaced by
 *		the corresponding Unicode character
 */
HRESULT CTxtRange::HexToUnicode (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	LONG ch;								// Handy char value
	LONG cpMin, cpMost;						// This range's cpMin and cpMost
	LONG cch = GetRange(cpMin, cpMost);		// Count of chars in range
	LONG i;									//  = cpMost - cpMin
	LONG lch = 0;							// Collects hex into binary value
	LONG cchSave = _cch;					// Save this range's cch
	LONG cpSave = GetCp();					//	and cp so we can restore in case of error

	if(cch)									// Range has cch chars selected
	{										//  so only convert these chars
		if(cpMost > GetAdjustedTextLength() || cch > 6)
			return S_FALSE;
		Collapser(tomEnd);					// Collapse range to IP at cpMost
	}
	else									// Range is insertion point so
		cch = 6;							//  check up to 6 prev chars
											
	// Convert preceding span of up to cch hexadigits to binary number (lch)
	for(i = 0; cch--; i += 4)				// i is shift count for hex
	{
		ch = GetPrevChar();					// ch = previous char
		if(ch == '+')						// Check for U+xxxx notation
		{									// If it's there, set up to
			Move(-1, TRUE);					//  delete the U+ (or u+)
			Move((GetPrevChar() | 0x20) == 'u' ? -1 : 1, TRUE);
			break;							// Else leave the +
		}
		if(ch > 'f' || !IsXDigit(ch))		// Break on nonhex chars
			break;
		Move(-1, TRUE);						// Move back one char
		ch |= 0x20;							// Convert hex to lower case if
		ch -= (ch >= 'a') ? 'a' - 10 : '0';	//  upper case; then to binary
		lch += (ch << i);					// Shift left & add in binary hex
	}

	if(!lch)								// No number: convert preceding
		return UnicodeToHex(publdr);		//  char back to hex

	if (lch > 0x10FFFF ||					// Don't insert numbers beyond Unicode's 17 planes
		IN_RANGE(0xD800, lch, 0xDFFF) ||	//	nor Unicode surrogate lead/trail word,
		IN_RANGE(STARTFIELD, lch,NOTACHAR)||//  nor internal use chars
		lch == CELL ||
		IsEOP(GetPrevChar()) && IN_RANGE(0x300, lch, 0x36F))
	{										// Note: CleanseAndReplaceRange suppresses others					
		Set(cpSave, cchSave);				// Restore previous selection	
		return S_FALSE;	
	}

	WCHAR str[2] = {(WCHAR)lch};
	cch = 1;								// Default one 16-bit code
	if(lch > 0xFFFF)						// Beyond BMP: so use  
	{										//  Unicode surrogate pair
		lch -= 0x10000;
		str[0] = 0xD800 + (lch >> 10);
		str[1] = 0xDC00 + (lch & 0x3FF);
		cch = 2;
	}
	if(publdr)								// If undo enabled, stop
		publdr->StopGroupTyping();			//  collecting typing string

	_rpCF.AdjustBackward();					// Use format of run preceding
	Set_iCF(_rpCF.GetFormat());				//  hex number
	_fUseiFormat = TRUE;
	_rpCF.AdjustForward();

	// Replace hexadigits with corresponding Unicode character choosing an
	// appropriate font if font preceding hex can't support character
	CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
	return S_OK;
}

/*
 *	CTxtRange::UnicodeToHex(publdr)
 *	
 *	@mfunc
 *		Convert Unicode character(s) preceeding cpMin to a hex number and
 *		select it. Translate Unicode surrogates into corresponding for hex
 *		values from 0x10000 up to 0x10FFFF.
 *	
 *	@rdesc
 *		HRESULT S_OK if conversion successful and Unicode character(s) is
 *		replaced by corresponding hex number.
 */
HRESULT CTxtRange::UnicodeToHex (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	if(_cch)							// If there's a selection,
	{									//  convert 1st char in sel
		Collapser(tomStart);
		AdvanceCRLF(CSC_NORMAL, FALSE);
	}
	LONG cp = GetCp();
	if(!cp || _rpTX.IsAfterTRD(0))
		return S_FALSE;					// No character to convert

	_cch = 1;							// Select previous char
	LONG n = GetPrevChar();				// Get it

	if(n == CELL || IN_RANGE(STARTFIELD, n, NOTACHAR))
		return S_FALSE;					// Don't convert CELL marks

	if(publdr)
		publdr->StopGroupTyping();

	if(IN_RANGE(0xDC00, n, 0xDFFF))		// Unicode surrogate trail word
	{
		if(cp <= 1)						// No lead word
			return S_FALSE;
		Move(-2, TRUE);
		LONG ch = CRchTxtPtr::GetChar();
		Assert(IN_RANGE(0xD800, ch, 0xDBFF));
		n = (n & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
		_cch = -2;
	}

	// Convert ch to str
	LONG	cch = 0;
	LONG	quot, rem;					// ldiv results
	WCHAR	str[6];
	WCHAR *	pch = &str[0];

	for(LONG d = 1; d < n; d <<= 4)		// d = smallest power of 16 > n
		;								
	if(n && d > n)
		d >>= 4;

	while(d)
	{
		quot = n / d;					// Avoid an ldiv
		rem = n % d;
		n = quot + '0';
		if(n > '9')
			n += 'A' - '9' - 1;
		*pch++ = (WCHAR)n;				// Store digit
		cch++;
		n = rem;						// Setup remainder
		d >>= 4;
	}

	CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
	_cch = cch;							// Select number

	if(_fSel)
		Update(FALSE);

	return S_OK;
}

/*
 *	CTxtRange::IsInputSequenceValid(pch, cchIns, fOverType, pfBaseChar)
 *
 *	@mfunc
 *		Verify the sequence of incoming text. Return FALSE if invalid
 *		combination	is found. The criteria is to allow any combinations
 *		that are displayable on screen (the simplest approach used by system
 *		edit control).
 *
 *	@rdesc
 *		Return FALSE if invalid combination is found; else TRUE.
 *
 *  	FUTURE: We may consider to support bad sequence filter or text streaming.
 *  	The code below can be extended easily enough to do so.
 */
BOOL CTxtRange::IsInputSequenceValid(
	WCHAR*	pch,			// Inserting string
	LONG	cchIns,			// Character count
	BOOL	fOverType,		// Insert or Overwrite mode
	BOOL*	pfBaseChar)		// Is pwch[0] a cluster start (base char)?
{
#ifndef NOCOMPLEXSCRIPTS
	CTxtEdit*		ped = GetPed();
	CTxtPtr 		tp(_rpTX);
	HKL				hkl = GetKeyboardLayout(0);
	BOOL			fr = TRUE;

	if (ped->fUsePassword() || ped->_fNoInputSequenceChk)
		return TRUE;		// no check when editing password

	if (PRIMARYLANGID(hkl) == LANG_VIETNAMESE)
	{
		// No concern about overtyping or cluster since we look backward only
		// 1 char and dont care characters following the insertion point.
		if(_cch > 0)
			tp.Move(-_cch);
		fr = IsVietCdmSequenceValid(tp.GetPrevChar(), *pch);
	}
	else if (PRIMARYLANGID(hkl) == LANG_THAI ||
		W32->IsIndicLcid(LOWORD(hkl)))
	{
		// Do complex things for Thai and Indic
	
		WCHAR			rgchText[32];
		WCHAR*			pchText = rgchText;
		CUniscribe*		pusp = ped->Getusp();
		CTxtBreaker*	pbrk = ped->_pbrk;
		LONG			found = 0;
		LONG			cp, cpSave, cpLimMin, cpLimMax;
		LONG			cchDel = 0, cchText, ich;
		LONG			cpEnd = ped->GetAdjustedTextLength();
	
		if (_cch > 0)
			tp.Move(-_cch);
	
		cp = cpSave = cpLimMin = cpLimMax = tp.GetCp();

		if (_cch)
		{
			cchDel = abs(_cch);
		}
		else if (fOverType && !tp.IsAtEOP() && cp != cpEnd)
		{
			// Delete up to the next cluster in overtype mode
			cchDel++;
			if (pbrk)
				while (cp + cchDel < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp + cchDel))
					cchDel++;
		}
		cpLimMax += cchDel;
	
		// Figure the min/max boundaries
		if (pbrk)
		{
			// Min boundary
			cpLimMin += tp.FindEOP(tomBackward, &found);
			if (!(found & FEOP_EOP))
				cpLimMin = 0;
	
			while (--cp > cpLimMin && !pbrk->CanBreakCp(BRK_CLUSTER, cp));
			cpLimMin = max(cp, cpLimMin);		// more precise boundary
	
			// Max boundary
			cp = cpLimMax;
			tp.SetCp(cpLimMax);
			cpLimMax += tp.FindEOP(tomForward, &found);
			if (!(found & FEOP_EOP))
				cpLimMax = ped->GetTextLength();
	
			while (cp < cpLimMax && !pbrk->CanBreakCp(BRK_CLUSTER, cp++));
			cpLimMax = min(cp, cpLimMax);		// more precise boundary
		}
		else
		{
			// No cluster info we statically bound to -1/+1 from selection range
			cpLimMin--;
			cpLimMin = max(0, cpLimMin);
	
			cpLimMax += cchDel + 1;
			cpLimMax = min(cpLimMax, ped->GetTextLength());
		}
	
		cp = cpSave + cchDel;
		cchText = cpSave - cpLimMin + cchIns + cpLimMax - cp;
	
		tp.SetCp(cpLimMin);
	
		if (cchText > 32)
			pchText = new WCHAR[cchText];
	
		if (pchText)
		{
			// prepare text
			cchText = tp.GetText (cpSave - cpLimMin, pchText);
			tp.Move (cchText + cchDel);
			ich = cchText;
			wcsncpy (&pchText[cchText], pch, cchIns);
			cchText += cchIns;
			cchText += tp.GetText (cpLimMax - cpSave - cchDel, &pchText[cchText]);
			Assert (cchText == cpLimMax - cpLimMin - cchDel + cchIns);

			if (pusp)
			{
				SCRIPT_STRING_ANALYSIS	ssa;
				HRESULT					hr;
				BOOL					fDecided = FALSE;
	
				hr = ScriptStringAnalyse(NULL, pchText, cchText, GLYPH_COUNT(cchText), -1,
									SSA_BREAK, -1, NULL, NULL, NULL, NULL, NULL, &ssa);
				if (S_OK == hr)
				{
					if (fOverType)
					{
						const SCRIPT_LOGATTR* psla = ScriptString_pLogAttr(ssa);
						BOOL	fBaseChar = !psla || psla[ich].fCharStop;

						if (!fBaseChar)
						{
							// In overtype mode, if the inserted char is not a cluster start.
							// We act like insert mode. Recursive call with fOvertype = FALSE.
							fr = IsInputSequenceValid(pch, cchIns, 0, NULL);
							fDecided = TRUE;
						}

						if (pfBaseChar)
							*pfBaseChar = fBaseChar;
					}
					if (!fDecided && S_FALSE == ScriptStringValidate(ssa))
						fr = FALSE;
	
					ScriptStringFree(&ssa);
				}
			}
			if (pchText != rgchText)
				delete[] pchText;
		}
	}
	return fr;
#else
	return TRUE;
#endif // NOCOMPLEXSCRIPTS
}

/*
 *	CTxtRange::CleanseAndReplaceRange(cch, *pch, fTestLimit, publdr,
 *									  pchD, pcchMove, dwFlags)
 *	@mfunc
 *		Cleanse the string pch (replace CRLFs by CRs, etc.) and substitute
 *		the resulting string for the text in this range using the CCharFormat
 *		_iFormat and updating other text runs as needed. For single-line
 *		controls, truncate on the first EOP and substitute the truncated
 *		string.  Also truncate if string would overflow the max text length.
 *	
 *	@rdesc
 *		Count of new characters added
 */
LONG CTxtRange::CleanseAndReplaceRange (
	LONG			cchS,		//@parm Length of replacement (Source) text
	const WCHAR *	pchS,		//@parm Replacement (Source) text
	BOOL			fTestLimit,	//@parm Whether to do limit test
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	WCHAR *			pchD,		//@parm Destination string (multiline only)
	LONG*			pcchMove,	//@parm Count of chars moved in 1st replace
	DWORD			dwFlags)	//@parm ReplaceRange's flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CleanseAndReplaceRange");

	CTxtEdit *	   ped = GetPed();
	BYTE		   iCharRepDefault;
	LONG		   cchM = 0;
	LONG		   cchMove = 0;
	LONG		   cchNew = 0;				// Collects total cch inserted
	LONG		   cch;						// Collects cch for cur charset
	DWORD		   ch, ch1;
	WCHAR		   chPassword = ped->TxGetPasswordChar();
	LONG		   cpFirst = GetCpMin();
	QWORD		   qw = 0;
	QWORD		   qwCharFlags = 0;
	QWORD		   qwCharMask = GetCharRepMask();
	DWORD		   dwCurrentFontUsed = 0;
	BOOL		   f10Mode = ped->Get10Mode();
	BOOL		   fCallerDestination = pchD != 0;	// Save if pchD enters as 0
	BOOL		   fDefFontHasASCII = FALSE;
	CFreezeDisplay fd(ped->_pdp);
	BOOL		   fDefFontSymbol = qwCharMask == FSYMBOL;
	BOOL		   fFEBaseFont;
	BOOL		   fMultiLine	= ped->_pdp->IsMultiLine();
	BOOL		   fSurrogate;
	bool		   fUIFont		= fUseUIFont();
	BOOL		   fUseCRLF		= ped->fUseCRLF();

	const WCHAR *  pch = pchS;
	CTempWcharBuf  twcb;					// Buffer needed for multiline if pchD = 0
	CCharFormat		CFCurrent;				// Current CF used during IME composition

	const	DWORD	fALPHA = 0x01;
	BOOL			fDeleteChar = !ped->_fIMEInProgress && !ped->IsRich() && _cch;

	DWORD			dwFlagsSave = dwFlags;
	LONG			iFormatCurrent = GetiFormat();

	dwFlags = (dwFlags & ~7) | RR_ITMZ_NONE;
	if (ped->_fIMEInProgress)
	{
		// Initialize data to handle alpha/ASCII dual font mode
		// during IME composition
		dwCurrentFontUsed = FFE;
		CFCurrent = *ped->GetCharFormat(iFormatCurrent);

		UINT	iCharRepKB = GetKeyboardCharRep(0);
		if (iCharRepKB != CFCurrent._iCharRep && IsFECharRep(iCharRepKB))
		{
			CCFRunPtr	rp(_rpCF, ped);
			int			iFormatFound = iFormatCurrent;
			CCharFormat	CFTemp;

			// Search the range for font that support this keyboard
			if(rp.GetPreferredFontInfo(iCharRepKB, CFTemp._iCharRep, CFTemp._iFont, CFTemp._yHeight,
				CFTemp._bPitchAndFamily, -1, MATCH_CURRENT_CHARSET, &iFormatFound) 
				&& iFormatFound != iFormatCurrent)
			{
				CFCurrent = *ped->GetCharFormat(iFormatFound);
			}
		}
	}

	// Check if default font supports full ASCII and Symbol
	if (fUIFont)
	{
		QWORD qwMaskDefFont = GetCharRepMask(TRUE);
		fDefFontHasASCII = (qwMaskDefFont & FASCII) == FASCII;
		fDefFontSymbol = qwMaskDefFont == FSYMBOL;
		iCharRepDefault = ped->GetCharFormat(-1)->_iCharRep;
	}
	else
		iCharRepDefault = ped->GetCharFormat(iFormatCurrent)->_iCharRep;

	fFEBaseFont	= IsFECharRep(iCharRepDefault);
	if(!pchS)
		cchS = 0;
	else if(fMultiLine)
	{
		if(cchS < 0)						// Calculate length for
			cchS = wcslen(pchS);			//  target buffer
		if(cchS && !pchD)
		{
			pchD = twcb.GetBuf(cchS);
			if(!pchD)						// Couldn't allocate buffer:
				return 0;					//  give up with no update
		}
		pch = pchD;
	}
	else if(cchS < 0)						// Calculate string length
		cchS = tomForward;					//  while looking for EOP

	WORD fDontUpdateFmt = _fDontUpdateFmt;
	_fDontUpdateFmt = TRUE;
	for(cch = 0; cchS; cchS--)
	{										
		ch = *pchS;							
		if(!ch && (!fMultiLine || !fCallerDestination))
			break;

		if(IN_RANGE(CELL, ch, CR))			// Handle CR and LF combos
		{
			if(!fMultiLine && !IN_RANGE(8, ch, 9))// Truncate at 1st EOP to
				break;						//  be compatible with user.exe SLE
											//  and for consistent behavior
			if(ch == CR && !f10Mode)
			{
				if(cchS > 1)
				{
					ch1 = *(pchS + 1);
					if(cchS > 2 && ch1 == CR && *(pchS+2) == LF)
					{
						if(fUseCRLF)
						{
							*pchD++ = ch;
							*pchD++ = ch1;
							ch = LF;
							cch += 2;
						}
						else
						{
							// Translate CRCRLF to CR or to ' '
							ch = ped->fXltCRCRLFtoCR() ? CR : ' ';	
						}
						pchS += 2;			// Bypass two chars
						cchS -= 2;
					}
					else if(ch1 == LF)
					{
						if(fUseCRLF)		// Copy over whole CRLF
						{
							*pchD++ = ch;	// Here we copy CR
							ch = ch1;		// Setup to copy LF
							cch++;
						}
						pchS++;
						cchS--;
					}
				}
			}
			else if(!fUseCRLF && ch == LF)	// Treat lone LFs as EOPs, i.e.,
				ch = CR;					//  be nice to Unix text files

			else if(ch == CELL)
				ch = ' ';
		}
		else if((ch | 1) == PS)				// Translate Unicode para/line
		{									//  separators into CR/VT
			if(!fMultiLine)
				break;
			ch = (ch == PS) ? CR : VT;
		}
		else if(IN_RANGE(STARTFIELD, ch, NOTACHAR))
			ch = ' ';
											
		qw = FSYMBOL;
		fSurrogate = FALSE;
		if(!fDefFontSymbol)
		{
			qw = GetCharFlags(pchS, cchS, iCharRepDefault);// Check for complex scripts
			if(qw & FSURROGATE && cchS > 1)
			{
				fSurrogate = TRUE;
				pchS++;
				cchS--;
				if (pchD)
					*pchD++ = ch;			// Copy lead surrogate
				ch = *pchS;					// Setup to copy trail surrogate
			}
		}
		if(chPassword)
			qw = GetCharFlags(&chPassword, 1, iCharRepDefault);
		qwCharFlags |= qw;					// FE, and charset changes
		qw &= ~0x2F;						// Exclude non-fontbind flags
		if(fMultiLine)						// In multiline controls, collect
		{									//  possibly translated chars
			if(qw & FSYMBOL)				// Convert 0xF000 thru 0xF0FF to
				ch &= 0xFF;					//  SYMBOL_CHARSET with 0x00 thru
			*pchD++ = ch;					//  0xFF. FUTURE: make work for
		}									//  single line too...
		pchS++;								// pchS points at next char
		if(ped->IsAutoFont() && !fDefFontSymbol)
		{
			BOOL fReplacedText = FALSE;

			if (fDeleteChar)
			{
				fDeleteChar = FALSE;
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL, dwFlags);
				Set_iCF(-1);
				qwCharMask = GetCharRepMask(TRUE);
			}

			if (!ped->_fIMEInProgress)
			{
				// Simp. Chinese uses some of the Latin2 symbols
				if (fUIFont && (qw == FLATIN2 || IN_RANGE(0x0250, ch, 0x02FF) ||
					IN_RANGE(0xFE50, ch, 0xFE6F)))
				{
					if (iCharRepDefault == BIG5_INDEX || iCharRepDefault == GB2312_INDEX ||
						GetACP() == CP_CHINESE_SIM || GetACP() == CP_CHINESE_TRAD)
					{
						if (VerifyFEString(CP_CHINESE_SIM,  (const WCHAR *)&ch, 1, TRUE) == CP_CHINESE_SIM ||
							VerifyFEString(CP_CHINESE_TRAD, (const WCHAR *)&ch, 1, TRUE) == CP_CHINESE_TRAD)
							qw = FCHINESE;
					}
				}
				if (fUIFont && qw == FHILATIN1 && fFEBaseFont &&
					(iCharRepDefault == SHIFTJIS_INDEX || iCharRepDefault == HANGUL_INDEX || ch >= 0x100))	// Special characters that are classiied as HiAnsi
				{
					// Use Ansi font for HiAnsi
					if (dwCurrentFontUsed != FHILATIN1)
					{
						fReplacedText = TRUE;
						cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
							qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
					}
					dwCurrentFontUsed = FHILATIN1;
				}
				else if (fUIFont && fDefFontHasASCII && _rpCF.IsValid() &&
					(qw & FASCII || IN_RANGE(0x2018, ch, 0x201D)))
				{				
					if (dwCurrentFontUsed != FASCII)
					{
						fReplacedText = TRUE;
						cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
							0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
						
						// Use the -1 font charset/face/size so the current font effect
						// will still be used.
						CCharFormat CFDefault = *ped->GetCharFormat(-1);
						SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
								 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
						dwCurrentFontUsed = FASCII;
					}
				}
				else if (!fUIFont && qwCharMask & FLATIN1 
					&& ((IN_RANGE(0x2018, ch, 0x201D) || ch == 0x2026))
					|| (qw & (FCHINESE | FBIG5) && qwCharMask & (FCHINESE | FKANA | FBIG5 | FHANGUL)))
				{										// Stay with current font
					;									//	and do Nothing
				}
				else if (qw && (qw & qwCharMask) != qw	// No match: need charset change
					 || dwCurrentFontUsed)				//  or change in classification
				{										
					fReplacedText = TRUE;
					dwCurrentFontUsed = 0;
					if(qw & (FCHINESE | FBIG5 | FFE2))	// If Han char, check next few
					{									//  chars for a Hangul or Kana
						Assert(cchS);
						const WCHAR *pchT = pchS;
						QWORD qw0;
						LONG i = min(10, cchS - 1);

						for (int j=0; j < 2; j++)
						{
							if (j)
							{
								// Check current text
								pchT = pch;
								i = min(6, cch);
							}

							for(; i > 0 && *pchT; i--)
							{
								qw0 = GetCharFlags(pchT++, i, iCharRepDefault);
								qw |= qw0 & ~FSURROGATE;
								if(qw0 & FSURROGATE && i > 1)
								{
									pchT++;
									i--;
								}
							}
						}

						i = CalcTextLenNotInRange();
						if(cchS < 6 && i)			// Get flags around range
						{
							CTxtPtr tp(_rpTX);
							i = min(i, 6);
							if(!_cch)				// For insertion point, backup
								tp.Move(-i/2);		//  half way
							else if(_cch < 0)		// Active end at cpMin, backup
								tp.Move(-i);		//  whole way
							qw |= tp.GetCharFlagsInRange(i, iCharRepDefault);
						}

						qw &= FFE | FFE2 | FSURROGATE;
					}
					else if(qw & (FHILATIN1 | FLATIN2) && qwCharMask & FLATIN)
					{
						LONG i = qwCharMask & FLATIN;
						qw = W32->GetCharFlags125x(ch) & FLATIN;
						if(!(qw & i))
							for(i = 0x100; i < 0x20000 && !(qw & i); i <<= 1)
								;
						qw &= i;
					}
					else if(qw & FMATH)
					{
						// Bind math fonts here (combos of ital, bold, script,
						// fraktur, open, sans, mono)
					}
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						qw, &cchM, cpFirst, MATCH_FONT_SIG, dwFlags);	// Replace text up to previous char
				}			
			}
			else
			{				// IME in progress, only need to check ASCII cases
				BOOL fHandled = FALSE;
				if (ch <= 0x7F)
				{
					if (fUIFont)
					{
						// Use default font
						if (dwCurrentFontUsed != FASCII)
						{
							cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
								0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
							
							// Use the -1 font charset/face/size so the current font effect
							// will still be used.
							CCharFormat CFDefault = *ped->GetCharFormat(-1);
							SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
									 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
							
							fReplacedText = TRUE;
							dwCurrentFontUsed = FASCII;
						}
						fHandled = TRUE;
					}
					else if (ped->_fDualFont && IsASCIIAlpha(ch))
					{
						// Use English Font
						if (dwCurrentFontUsed != fALPHA)
						{
							cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
								qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char						
							fReplacedText = TRUE;
							dwCurrentFontUsed = fALPHA;
						}
						fHandled = TRUE;
					}
				}
				else if (qw & FSURROGATE ||
					(qw & FOTHER && 
					(IN_RANGE(0x03400, ch, 0x04DFF) || IN_RANGE(0xE000, ch, 0x0F8FF))))
				{
					// Try font binding for Surrogate, Extension-A, and Private Usage Area
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char						
					fReplacedText = TRUE;
					dwCurrentFontUsed = FSURROGATE;
					fHandled = TRUE;
				}

				// Use current FE font
				if(!fHandled && dwCurrentFontUsed != FFE)
				{
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
					SetCharFormat(&CFCurrent, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
						CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
					fReplacedText = TRUE;
					dwCurrentFontUsed = FFE;
				}
			}

			if (fReplacedText)
			{
				qwCharMask = (qw & FSYMBOL) ? FSYMBOL : GetCharRepMask();
				if(cchM)
					cchMove = cchM;			// Can only happen on 1st replace
				pch = fMultiLine ? pchD : pchS;
				pch--;
				if(fSurrogate)
					pch--;
				cch = 0;
			}
		}
		cch++;
		if(fSurrogate)
			cch++;
	}										
    ped->OrCharFlags(qwCharFlags, publdr);

	cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr, (qw & (FOTHER | FSURROGATE)), &cchM, cpFirst,
									IGNORE_CURRENT_FONT, dwFlags);
	if(cchM)
		cchMove = cchM;						// Can only happen on 1st replace

	if (pcchMove)
		*pcchMove = cchMove;

	if (ped->IsComplexScript())
	{
		if (dwFlagsSave & RR_ITMZ_NONE || ped->IsStreaming())
			ped->_fItemizePending = TRUE;
		else
			ItemizeReplaceRange(cchNew, cchMove, publdr, dwFlagsSave & RR_ITMZ_UNICODEBIDI);
	}
	_fDontUpdateFmt = fDontUpdateFmt;
	Update_iFormat(-1);					// Choose _iFormat
	return cchNew;
}

/*
 *	CTxtRange::CheckLimitReplaceRange(cchNew, *pch, fTestLimit, publdr,
 *									  qwCharFlags, pcchMove, prp, iMatchCurrent, &dwFlags)
 *	@mfunc
 *		Replace the text in this range by pch using CCharFormat _iFormat
 *		and updating other text runs as needed.
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::CheckLimitReplaceRange (
	LONG			cch,			//@parm Length of replacement text
	WCHAR const *	pch,			//@parm Replacement text
	BOOL			fTestLimit,		//@parm Whether to do limit test
	IUndoBuilder *	publdr,			//@parm UndoBuilder to receive antievents
	QWORD			qwCharFlags,	//@parm CharFlags following pch
	LONG *			pcchMove,		//@parm Count of chars moved in 1st replace
	LONG			cpFirst,		//@parm Starting cp for font binding
	int				iMatchCurrent,	//@parm Font matching method
	DWORD &			dwFlags)		//@parm ReplaceRange's flags
{
	CTxtEdit *ped = GetPed();

	if(cch || _cch)
	{
		if(fTestLimit)
		{
			LONG	cchLen = CalcTextLenNotInRange();
			DWORD	cchMax = ped->TxGetMaxLength();
			if((DWORD)(cch + cchLen) > cchMax)	// New plus old	count exceeds
			{									//  max allowed, so truncate
				cch = cchMax - cchLen;			//  down to what fits
				cch = max(cch, 0);				// Keep it positive
				ped->GetCallMgr()->SetMaxText(); // Report exceeded
			}
		}
		
		if (cch && ped->IsAutoFont() && !ped->_fIMEInProgress)
		{
			LONG iFormatTemp;
			if (fUseUIFont() && GetAdjustedTextLength() != _cch)
			{
				// Delete the old string first so _iFormat is defined
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
				iFormatTemp = _iFormat;
			}
			else
				iFormatTemp = GetiFormat();

			BYTE iCharRepCurrent = ped->GetCharFormat(iFormatTemp)->_iCharRep;
			
			if (IsFECharRep(iCharRepCurrent) && !(qwCharFlags & (FOTHER | FSURROGATE)))
			{
				// Check if current font can handle this string.
				INT	cpgCurrent = CodePageFromCharRep(iCharRepCurrent);
				INT	cpgNew = VerifyFEString(cpgCurrent, pch, cch, FALSE);

				if (cpgCurrent != cpgNew)
				{
					// Setup the new CodePage to handle this string
					CCharFormat CF;
					BYTE		iCharRep = CharRepFromCodePage(cpgNew);
					CCFRunPtr	rp(_rpCF, ped);
					rp.Move(cpFirst - GetCp());

					CF._iCharRep = iCharRep;
					if(rp.GetPreferredFontInfo(iCharRep, CF._iCharRep, CF._iFont, CF._yHeight,
							CF._bPitchAndFamily, _iFormat, iMatchCurrent))
					{
						SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
							 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
					}
				}
			}
		}
		cch = ReplaceRange(cch, pch, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
		dwFlags |= RR_NO_LP_CHECK;
	}

	// If following string contains Hangul or Kana, use Korean or Japanese
	// font signatures, respectively. Else use incoming qwCharFlags
	if(!qwCharFlags)
		return cch;

	qwCharFlags &= ~0x2F;
	if(qwCharFlags & (FFE | FFE2))
	{
		BOOL fFE2 = (qwCharFlags & FSURROGATE) != 0;
		if(qwCharFlags & FHANGUL)
			qwCharFlags = fFE2 ? (FKOR2 | FSURROGATE) : FHANGUL;

		else if(qwCharFlags & FKANA)
			qwCharFlags = fFE2 ? (FJPN2 | FSURROGATE) : FKANA;

		else if(qwCharFlags & FBIG5)
			qwCharFlags = fFE2 ? (FCHT2 | FSURROGATE) : FBIG5;

		else if(fFE2)
			qwCharFlags = FCHS2 | FSURROGATE;
	}

	CCharFormat CF;
	bool		fCFDefined = FALSE;
	bool		fCFDefDefined = FALSE;
	bool		fUIFont = ped->fUseUIFont();

	CF._iCharRep = W32->CharRepFromFontSig(qwCharFlags);
	CF._iFont = 0;

	if (W32->IsExternalFontCheckActive() &&
		(qwCharFlags & (FOTHER | FSURROGATE) ||
		 !(fCFDefDefined = W32->IsDefaultFontDefined(CF._iCharRep, fUIFont, CF._iFont))))
	{
		// REMARK: Currently pch[cch] is the current char and others might
		// follow as well. We could get some text from _rpTX to provide more
		// context.
		fCFDefined = W32->GetExternalPreferredFontInfo(pch, 
				(qwCharFlags & FSURROGATE) ? cch + 2 : cch + 1,
				CF._iCharRep, CF._iFont, CF._bPitchAndFamily, fUIFont || ped->Get10Mode());
	}
	if(fCFDefined || fCFDefDefined || qwCharFlags != FOTHER)
	{
		SHORT iFontDummy = CF._iFont;
		CCFRunPtr rp(_rpCF, ped);
		rp.Move(cpFirst - GetCp());
		fCFDefined = rp.GetPreferredFontInfo(CF._iCharRep, CF._iCharRep, fCFDefined ? iFontDummy : CF._iFont, CF._yHeight,
			CF._bPitchAndFamily, (_cch ? -1 : _iFormat), fCFDefined ? GET_HEIGHT_ONLY : iMatchCurrent);
	}
	if(fCFDefined)
	{
		SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
			 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
	}
	return cch;
}

/*
 *	CTxtRange::ReplaceRange(cchNew, *pch, publdr. selaemode, pcchMove)
 *	
 *	@mfunc
 *		Replace the text in this range by pch using CCharFormat _iFormat
 *		and updating other text runs as needed.
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::ReplaceRange (
	LONG			cchNew,		//@parm Length of replacement text
	WCHAR const *	pch,		//@parm Replacement text
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode,	//@parm Controls how selection antievents are to be generated.
	LONG *			pcchMove,	//@parm Number of chars moved after replace
	DWORD			dwFlags)	//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

	LONG lRet;
	LONG iFormat = _iFormat;
	BOOL fReleaseFormat = FALSE;
	ICharFormatCache * pcf = GetCharFormatCache();

	_TEST_INVARIANT_

	if(!(cchNew | _cch))					// Nothing to add or delete,
	{										//  so we're done
		if(pcchMove)
			*pcchMove = 0;
		return 0;
	}

	if(publdr && selaemode != SELRR_IGNORE)
	{
		Assert(selaemode == SELRR_REMEMBERRANGE);
		HandleSelectionAEInfo(GetPed(), publdr, GetCp(), _cch,
				GetCpMin() + cchNew, 0, SELAE_MERGE);
	}
	
	CFreezeDisplay fd(GetPed()->_pdp);
	if(_cch > 0)
		FlipRange();

	CheckLinkProtection(dwFlags, iFormat);

	// If we are replacing a non-degenerate selection, then the Word95
	// UI specifies that we should use the rightmost formatting at cpMin.
	if(_cch < 0 && _rpCF.IsValid() && !_fDualFontMode && !_fUseiFormat)
	{
		_rpCF.AdjustForward();
		iFormat = _rpCF.GetFormat();

		// This is a bit icky, but the idea is to stabilize the
		// reference count on iFormat.  When we get it above, it's
		// not addref'ed, so if we happen to delete the text in the
		// range and the range is the only one with that format,
		// then the format will go away.
		pcf->AddRef(iFormat);
		fReleaseFormat = TRUE;
	}
	const	CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);
	BOOL	fTmpDispAttr = pCF->_sTmpDisplayAttrIdx != -1;

	if((fTmpDispAttr || dwFlags & (RR_UNHIDE | RR_UNLINK)) && cchNew)	// Don't hide or protect or apply temp. 
	{																	//	display attributes to inserted text
		BOOL fUnhide = dwFlags & RR_UNHIDE && pCF->_dwEffects & (CFE_HIDDEN | CFE_PROTECTED);
		BOOL fUnlink = dwFlags & RR_UNLINK && pCF->_dwEffects & CFE_LINK;
		if(fTmpDispAttr | fUnhide | fUnlink)	// Switch to unhidden/unlinked iFormat or
		{										//	turn of temp. display attribute
			CCharFormat CF = *pCF;
			if(fReleaseFormat)					// Need to release iFormat ref'd
				pcf->Release(iFormat);			//  above, since no longer need it
			if(fUnhide)
			{
				CF._dwEffects &= ~(CFE_HIDDEN | CFE_PROTECTED);
				if (CF._dwEffects & CFE_LINKPROTECTED)
					CF._dwEffects &= ~(CFE_LINKPROTECTED | CFE_LINK);
			}
			if(fUnlink)
				CF._dwEffects &= ~CFE_LINK;
			if(fTmpDispAttr)
				CF._sTmpDisplayAttrIdx = -1;
			pcf->Cache(&CF, &iFormat);
			fReleaseFormat = TRUE;				// Be sure to release new one
		}
	}
	_fUseiFormat = FALSE;
	
	LONG cchForReplace = -_cch;	
	_cch = 0;
	lRet = CRchTxtPtr::ReplaceRange(cchForReplace, cchNew, pch, publdr,
				iFormat, pcchMove, dwFlags);
	if(cchForReplace)
		CheckMergedCells(publdr);

	if(lRet)
		_fMoveBack = FALSE;

	Update_iFormat(fReleaseFormat ? iFormat : -1);

	if(fReleaseFormat)
	{
		Assert(pcf);
		pcf->Release(iFormat);
	}
	return lRet;
}

/*
 *	CTxtRange::DeleteWithTRDCheck(publdr. selaemode, pcchMove, dwFlags)
 *
 *	@mfunc
 *		Delete text in this range, inserting an EOP in place of the text
 *		if the range ends at a table-row start delimiter
 *
 *	@rdesc
 *		Count of new characters added
 *
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::DeleteWithTRDCheck (
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode,	//@parm Controls how selection antievents are to be generated.
	LONG *			pcchMove,	//@parm Count of chars moved after replace
	DWORD			dwFlags)	//@parm ReplaceRange flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

	LONG	cchEOP = 0;
	WCHAR	szEOP[] = {CR, LF, 0};

	if(IsRich())
	{
		CTxtPtr tp(_rpTX);					// If inserting before a table
		if(GetCch() < 0)					//  row, ReplaceRange with EOP,
			tp.Move(-GetCch());				//  which we delete after read
		if(tp.IsAtTRD(STARTFIELD))			//  if read ends with an EOP
			cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
	}

	if(!(_cch | cchEOP))
		return 0;							// Nothing to do

	ReplaceRange(cchEOP, szEOP, publdr, selaemode, pcchMove, dwFlags);

	if(GetCch())
	{
		// Text deletion failed because range didn't collapse. Our work
		// here is done.
		return 0;
	}
	if(cchEOP)
	{
		_rpPF.AdjustBackward();
		const CParaFormat *pPF = GetPF();
		_rpPF.AdjustForward();
		if(pPF->_wEffects & PFE_TABLE)
		{
			CParaFormat PF = *GetPed()->GetParaFormat(-1);
			PF._bTableLevel = pPF->_bTableLevel - 1;
			Assert(PF._bTableLevel >= 0);
			_cch = cchEOP;					// Select EOP just inserted
			PF._wEffects &= ~PFE_TABLE;		// Default not in table
			if(PF._bTableLevel)
				PF._wEffects |= PFE_TABLE;	// It's in a table
			SetParaFormat(&PF, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);
			SetCp(GetCp() - cchEOP, FALSE);	// Collapse before EOP
		}
	}
	return cchEOP;
}

/*
 *	CTxtRange::Delete(publdr. selaemode)
 *	
 *	@mfunc
 *		Delete text in this range.
 */
void CTxtRange::Delete (
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode)	//@parm Controls generation of selection antievents
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Delete");

	if(!_cch)
		return;							// Nothing to delete

	if(!GetPed()->IsBiDi())
	{
		ReplaceRange(0, NULL, publdr, selaemode, NULL);
		return;
	}

	CFreezeDisplay fd(GetPed()->_pdp);

	ReplaceRange(0, NULL, publdr, selaemode);
}

/*
 *	CTxtRange::BypassHiddenText(iDir, fExtend)
 *
 *	@mfunc
 *		Bypass hidden text forward/backward for iDir positive/negative
 *
 *	@rdesc
 *		TRUE if succeeded or no hidden text. FALSE if at document limit
 *		(end/start for Direction positive/negative) or if hidden text between
 *		cp and that limit.
 */
BOOL CTxtRange::BypassHiddenText(
	LONG iDir,
	BOOL fExtend)
{
	if (!_rpCF.IsValid())
		return TRUE;		// No format run, not hidden

	if(iDir > 0)
		_rpCF.AdjustForward();
	else
		_rpCF.AdjustBackward();

	if(!(GetPed()->GetCharFormat(_rpCF.GetFormat())->_dwEffects & CFE_HIDDEN))
		return TRUE;

	CCFRunPtr rp(*this);
	LONG cch = (iDir > 0)
			 ? rp.FindUnhiddenForward() : rp.FindUnhiddenBackward();

	BOOL bRet = !rp.IsHidden();				// Note whether still hidden
	if(bRet)								// It isn't:
		Move(cch, fExtend);					//  bypass hidden text
	return bRet;
}

/*
 *	CTxtRange::CheckMergedCells(publdr)
 *
 *	@mfunc
 *		If range is at a table-row start delimiter, ensure that cells
 *		that are vertically merged with cells above have a top cell.
 *
 *		If the text before this range is a row that contains top cells
 *		these cells have to be converted to nonmerged cells unless the
 *		text starting at this range contains corresponding low cells.
 *
 *		If the text starting at this range is a table row with low cells,
 *		they may have to be converted to top or nonmerged cells.
 */
void CTxtRange::CheckMergedCells (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	Assert(!_cch);						// Assumes this range is an IP

	unsigned ch = _rpTX.GetChar();

	if(ch != CR && ch != STARTFIELD)	// Early out
		return;

	if(ch == CR)						// CRchTxtPtr::ReplaceRange() may
	{									//  leave a CR at end before a table
		CTxtPtr tp(_rpTX);				//  row start delimiter, so check for
		LONG cch = tp.AdvanceCRLF(FALSE);// that case
		if(!tp.IsAtTRD(STARTFIELD))
			return;
		Move(cch, FALSE);				// Check that row
	}
	else if(!_rpTX.IsAtTRD(STARTFIELD))	// Allow top cells to remain w/o row
		return;							//  below so that complex tables can
										//  be inserted
	const CParaFormat *pPF0 = NULL;		// Default no row to compare to

	if(_rpTX.IsAfterTRD(ENDFIELD))		// Range is at table row, so do top
	{									//  cell check on previous row
		CheckTopCells(publdr);
		_rpPF.AdjustBackward();
		pPF0 = GetPF();					// Compare to preceding row
		_rpPF.AdjustForward();
	}

	const CParaFormat *	pPF1 = GetPF();	// Point at current row PF
	CELLPARMS			rgCellParms[MAX_TABLE_CELLS];

	if(CheckCells(&rgCellParms[0], pPF1, pPF0, fLowCell, fLowCell | fTopCell))
	{									// One or more cells need changes
		CTxtRange rg(*this);
		rg._rpPF.AdjustForward();
		rg.SetCellParms(&rgCellParms[0], pPF1->_bTabCount, TRUE, publdr);
		rg.CheckTopCells(publdr);		// Do top cell check on entry row
	}
	if(ch == CR)
		BackupCRLF(CSC_NORMAL, FALSE);	// Restore this range
}

/*
 *	CTxtRange::CheckTopCells(publdr)
 *
 *	@mfunc
 *		If this range follows a table-row end delimiter, normalize any top
 *		cells in the previous row that don't have corresponding low cells
 *		in the current row.
 */
void CTxtRange::CheckTopCells (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	Assert(_rpTX.IsAfterTRD(ENDFIELD));

	_rpPF.AdjustBackward();
	const CParaFormat *	pPF0 = GetPF();
	_rpPF.AdjustForward();
	const CParaFormat *	pPF1 = _rpTX.IsAtTRD(STARTFIELD) ? GetPF() : NULL;
	CELLPARMS			rgCellParms[MAX_TABLE_CELLS];

	if(CheckCells(&rgCellParms[0], pPF0, pPF1, fTopCell, fLowCell))
	{
		LONG	  cpMin;
		CTxtRange rg(*this);

		rg.Move(-2, FALSE);					// Back up before table row end delimiter
		rg.FindRow(&cpMin, NULL, rg.GetPF()->_bTableLevel);
		rg.Set(cpMin, 0);
		rg.SetCellParms(&rgCellParms[0], pPF0->_bTabCount, FALSE, publdr);
	}
}

/*
 *	CTxtRange::CheckCells(prgCellParms, pPF1, pPF0, dwMaskCell, dwMaskCellAssoc)
 *
 *	@mfunc
 *		Check cells with type dwMaskCell in row for pPF1 to see if their 
 *		associated cells in row for pPF0 are compatible and make appropriate
 *		changes in prgCellParms if a discrepancy is found.
 *
 *	@rdesc
 *		TRUE if prgCellParms contains changes from the cells in pPF1.
 */
BOOL CTxtRange::CheckCells (
	CELLPARMS *	prgCellParms,	//@parm	CellParms to update
	const CParaFormat *	pPF1,	//@parm PF for row to check cells on	
	const CParaFormat *	pPF0,	//@parm PF for row to compare cells to
	DWORD dwMaskCell,			//@parm Mask for cell type to check
	DWORD dwMaskCellAssoc)		//@parm Mask for desired associated type
{
	LONG			 cCell1 = pPF1->_bTabCount;
	BOOL			 fCellsChanged = FALSE;
	const CELLPARMS *prgCellParms1 = pPF1->GetCellParms();

	for(LONG iCell1 = 0, dul1 = 0; iCell1 < cCell1; iCell1++)
	{
		LONG uCell1 = prgCellParms1[iCell1].uCell;
		prgCellParms[iCell1] = prgCellParms1[iCell1];// Copy current cell parms
		dul1 += GetCellWidth(uCell1);
		if(uCell1 & dwMaskCell)				// Need to check cell: see if		
		{									//  associated cell is compatible
			BOOL fChangeCellParm = TRUE;	// Default that it isn't
			if(pPF0)						// Compare to associated row
			{
				LONG cCell0 = pPF0->_bTabCount;
				const CELLPARMS *prgCellParms0 = pPF0->GetCellParms();

				fChangeCellParm = FALSE;	// Maybe no change needed
				for(LONG iCell0 = 0, dul0 = 0; iCell0 < cCell0; iCell0++)
				{							// Find cell above
					LONG uCell0 = prgCellParms0[iCell0].uCell;
					dul0 += GetCellWidth(uCell0);
					if(dul0 == dul1)		// Found cell above
					{
						// Should check both ends of cell to be sure it
						// matches the present one
						if(!(uCell0 & dwMaskCellAssoc))
							fChangeCellParm = TRUE;	// Need cell parm change
						break;
					}
				}
			}
			if(fChangeCellParm)
			{
				uCell1 &= ~dwMaskCell;
				if(dwMaskCell == fLowCell)
				{
					// REMARK: it would be possible to get the pPF for the para
					// following this row and check to see if the current cell
					// should be a top cell. For now we assume it is and fix it
					// up by an additional pass in CheckMergeCells()
					uCell1 |= fTopCell;
				}
				prgCellParms[iCell1].uCell = uCell1;
				fCellsChanged = TRUE;
			}
		}
	}
	return fCellsChanged;
}

/*
 *	CTxtRange::SetCellParms(prgCellParms, cCell, fConvertLowCells, publdr)
 *
 *	@mfunc
 *		Set cell parms for row pointed to by this range equal to *prgCellParms.
 *		Return with this range pointing just after the row end delimiter.
 */
void CTxtRange::SetCellParms (
	CELLPARMS *	  prgCellParms,		//@parm New cell parms to use
	LONG		  cCell,			//@parm # cells
	BOOL		  fConvertLowCells,	//@parm TRUE if low cells are being converted
	IUndoBuilder *publdr)			//@parm UndoBuilder to receive antievents
{
	LONG		cpMost;
	LONG		Level = GetPF()->_bTableLevel;
	CParaFormat	PF;

	Assert(_rpTX.IsAtTRD(STARTFIELD) && Level > 0);

	PF._bTabCount = cCell;
	PF._iTabs = GetTabsCache()->Cache((LONG *)prgCellParms, cCell*(CELL_EXTRA+1));
	Move(2, TRUE);							// Select table-row-start delimiter
	SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	_cch = 0;
	FindRow(NULL, &cpMost, Level);
	if(fConvertLowCells)
	{
		while(GetCp() < cpMost - 2)			// Delete NOTACHARs
		{
			if(_rpTX.GetChar() == NOTACHAR && Level == GetPF()->_bTableLevel)
			{
				_cch = -1;
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL);
				cpMost--;
			}
			Move(1, FALSE);
		}
	}
	Set(cpMost, 2);						// Select table-row end delimiter
	Assert(_rpTX.IsAfterTRD(ENDFIELD));
	SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	GetTabsCache()->Release(PF._iTabs);
	_cch = 0;
}

/*
 *	CTxtRange::GetCharFormat(pCF, flags)
 *	
 *	@mfunc
 *		Set *pCF = CCharFormat for this range. If cbSize = sizeof(CHARFORMAT)
 *		only transfer CHARFORMAT data.
 *
 *	@rdesc
 *		Mask of unchanged properties over range (for CHARFORMAT::dwMask)
 *
 *	@devnote
 *		NINCH means No Input No CHange (a Microsoft Word term). Here used for
 *		properties that change during the range of cch characters.	NINCHed
 *		properties in a Word-Font dialog have grayed boxes. They are indicated
 *		by zero values in their respective dwMask bit positions. Note that
 *		a blank at the end of the range does not participate in the NINCH
 *		test, i.e., it can have a different CCharFormat without zeroing the
 *		corresponding dwMask bits.  This is done to be compatible with Word
 *		(see also CTxtSelection::SetCharFormat when _fWordSelMode is TRUE).
 */
DWORD CTxtRange::GetCharFormat (
	CCharFormat *pCF, 		//@parm CCharFormat to fill with results
	DWORD flags) const		//@parm flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCharFormat");
	_TEST_INVARIANT_
	
	CTxtEdit * const ped = GetPed();

	if(!_cch || !_rpCF.IsValid())					// IP or invalid CF
	{												//	run ptr: use CF at
		*pCF = *ped->GetCharFormat(_iFormat);		//  this text ptr
		return CFM_ALL2;
	}

	LONG		  cpMin, cpMost;					// Nondegenerate range:
	LONG		  cch = GetRange(cpMin, cpMost);	//  need to scan
	LONG		  cchChunk;							// cch in CF run
	DWORD		  dwMask = CFM_ALL2;				// Initially all prop def'd
	LONG		  iDirection;						// Direction of scan
	CFormatRunPtr rp(_rpCF);						// Nondegenerate range

	/*
	 * The code below reads character formatting the way Word does it,
	 * that is, by not including the formatting of the last character in the
	 * range if that character is a blank.
	 *
	 * See also the corresponding code in CTxtSelection::SetCharFormat().
	 */

	if(cch > 1 && _fSel && (flags & SCF_USEUIRULES))// If more than one char,
	{												//  don't include trailing
		CTxtPtr tp(ped, cpMost - 1);				//  blank in NINCH test
		if(tp.GetChar() == ' ')
		{											// Have trailing blank:
			cch--;									//  one less char to check
			if(_cch > 0)							// Will scan backward, so
				rp.Move(-1);					//  backup before blank
		}
	}

	if(_cch < 0)									// Setup direction and
	{												//  initial cchChunk
		iDirection = 1;								// Scan forward
		rp.AdjustForward();
		cchChunk = rp.GetCchLeft();					// Chunk size for _rpCF
	}
	else
	{
		iDirection = -1;							// Scan backward
		rp.AdjustBackward();						// If at BOR, go to
		cchChunk = rp.GetIch();						//  previous EOR
	}

	*pCF = *ped->GetCharFormat(rp.GetFormat());		// Initialize *pCF to
													//  starting format
	while(cchChunk < cch)							// NINCH properties that
	{												//  change over the range
		cch -= cchChunk;							//	given by cch
		if(!rp.ChgRun(iDirection))					// No more runs
			break;									//	(cch too big)
		cchChunk = rp.GetRun(0)->_cch;

		const CCharFormat *pCFTemp = ped->GetCharFormat(rp.GetFormat());

		dwMask &= ~pCFTemp->Delta(pCF,				// NINCH properties that
						flags & CFM2_CHARFORMAT);	//  changed, i.e., reset
	}												//  corresponding bits
	return dwMask;
}

/*
 *	CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2)
 *	
 *	@mfunc
 *		apply CCharFormat *pCF to this range.  If range is an insertion point,
 *		and (flags & SCF_WORD) != 0, then apply CCharFormat to word surrounding
 *		this insertion point
 *	
 *	@rdesc
 *		HRESULT = (successfully set whole range) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		SetParaFormat() is similar, but simpler, since it doesn't have to
 *		special case insertion-point ranges or worry about bullet character
 *		formatting, which is given by EOP formatting.
 */
HRESULT CTxtRange::SetCharFormat (
	const CCharFormat *pCF,	//@parm CCharFormat to fill with results
	DWORD		  flags,	//@parm SCF_WORD OR SCF_IGNORESELAE
	IUndoBuilder *publdr,	//@parm Undo builder to use
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetCharFormat");

	LONG				cch = -_cch;			// Defaults for _cch <= 0
	LONG				cchBack = 0;			// cch to back up for formatting
	LONG				cchFormat;				// cch for formatting
	CCharFormat			CF;						// Temporary CF
	LONG				cp;
	LONG				cpMin, cpMost;
	LONG                cpStart = 0;
	LONG				cpWordMin, cpWordMost;
	BOOL				fApplyToEOP = FALSE;
	BOOL				fProtected = FALSE;
	HRESULT				hr = NOERROR;
	LONG				iCF;
	CTxtEdit * const	ped = GetPed();			//  defined and not style
	ICharFormatCache *	pf = GetCharFormatCache();
	CFreezeDisplay		fd(ped->_pdp);

 	_TEST_INVARIANT_

	if(!Check_rpCF())							// Not rich
		return NOERROR;

	if(_cch > 0)								// Active end at range end
	{
		cchBack = -_cch;						// Setup to back up to
		cch = _cch;								//  start of format area
	}
	else if(_cch < 0)
        _rpCF.AdjustForward();

	else if(!cch && (flags & (SCF_WORD | SCF_USEUIRULES)))
	{
		BOOL fCheckEOP = TRUE;
		if(flags & SCF_WORD)
		{
			FindWord(&cpWordMin, &cpWordMost, FW_EXACT);

			// If nearest word is within this range, calculate cchback and cch
			// so that we can apply the given format to the word
			if(cpWordMin < GetCp() && GetCp() < cpWordMost)
			{
				// RichEdit 1.0 made 1 final check: ensure word's format
				// is constant w.r.t. the format passed in
				CTxtRange rg(*this);

				rg.Set(cpWordMin, cpWordMin - cpWordMost);
				fProtected = rg.WriteAccessDenied();
				if(!fProtected && (rg.GetCharFormat(&CF) & dwMask) == dwMask)
				{
					cchBack = cpWordMin - GetCp();
					cch = cpWordMost - cpWordMin;
				}
				fCheckEOP = FALSE;
			}
		}
		if(fCheckEOP && _rpTX.IsAtEOP() && !GetPF()->_wNumbering)
		{
			CTxtPtr tp(_rpTX);
			cch = tp.AdvanceCRLF(FALSE);
			_rpCF.AdjustForward();				// Go onto format EOP
			fApplyToEOP = TRUE;

			// Apply the characterset and face to EOP because EOP can be in any charset
			dwMask2 |= CFM2_NOCHARSETCHECK;
		}
	}
	cchFormat = cch;

	BOOL fApplyStyle = pCF->fSetStyle(dwMask, dwMask2);

	if(!cch)									// Set degenerate-range	(IP)
	{											//  CF
LApplytoIP:
		DWORD dwMsk = dwMask;
		dwMask2 |= CFM2_NOCHARSETCHECK;
		CF = *ped->GetCharFormat(_iFormat);		// Copy current CF at IP to CF
		if ((CF._dwEffects & CFE_LINK) &&		// Don't allow our URL
			ped->GetDetectURL() && !ped->IsStreaming())	//  formatting to be changed
		{
			dwMsk &= ~CFM_LINK;
		}
		if(fApplyStyle)
			CF.ApplyDefaultStyle(pCF->_sStyle);
		hr = CF.Apply(pCF, dwMsk, dwMask2);		// Apply *pCF
		if(hr != NOERROR)						// Cache result if new
			return hr;
		hr = pf->Cache(&CF, &iCF);				// In any case, get iCF
		if(hr != NOERROR)						//  (which AddRef's it)
			return hr;

#ifndef NOLINESERVICES
		if (g_pols)
			g_pols->DestroyLine(NULL);
#endif

		pf->Release(_iFormat);
		_iFormat = iCF;
		if(fProtected)							// Signal to beep if UI
			hr = S_FALSE;
	}
	else										// Set nondegenerate-range CF
	{											// Get start of affected area
		CNotifyMgr *pnm = NULL;

		if (!(flags & SCF_IGNORENOTIFY))
		{
			pnm = ped->GetNotifyMgr();			// Get the notification mgr
			if(pnm)
			{
				cpStart = GetCp() + cchBack;	// Bulletting may move
												//  affected area back if
				if(GetPF()->_wNumbering)		//  formatting hits EOP that
				{								//  affects bullet at BOP
					FindParagraph(&cpMin, &cpMost);
	
					if(cpMost <= GetCpMost())
						cpStart = cpMin;
				}
				pnm->NotifyPreReplaceRange(this,// Notify interested parties of
					CP_INFINITE, 0, 0, cpStart,	// the impending update
						cpStart + cchFormat);
			}
		}

		// Move _rpCF in front of the changes to allow easy rebinding
		_rpCF.Move(cchBack);					// Back up to formatting start
		CFormatRunPtr rp(_rpCF);				// Clone _rpCF to walk range
		
		cp = GetCp() + cchBack;
		if(publdr)
		{
			LONG	cchBackup = 0, cchAdvance = 0;
			if (ped->IsBiDi())
			{
				CRchTxtPtr	rtp(*this);
				if(cchBack)
				{
					rtp._rpPF.Move(cchBack);	// Move _rpPF and _rpTX back
					rtp._rpTX.Move(cchBack);	//  (_rpCF moved back above)
				}
				cchBackup = rtp.ExpandRangeFormatting(cch, 0, cchAdvance);
				Assert(cchBackup <= 0);
			}
			rp.Move(cchBackup);					// Move rp back

			IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(ped,
								cp + cchBackup, rp, cch - cchBackup + cchAdvance,
								pf, CharFormat);

			rp.Move(-cchBackup);				// Restore rp
			if(pae)
				publdr->AddAntiEvent(pae);
		}
		
		// Following Word, we translate runs for 8-bit charsets to/from
		// SYMBOL_CHARSET
		LONG	cchLeft;
		LONG	cchRun;
		LONG	cchSkip	= 0;
		LONG	cchSkipHidden = 0;
		LONG	cchTrans;
		QWORD	qwFontSig = 0;
		DWORD	dwMaskSave	= dwMask;
		DWORD	dwMask2Save = dwMask2;
		BOOL	fBiDiCharRep = IsBiDiCharRep(pCF->_iCharRep);
		BOOL	fFECharRep = IsFECharRep(pCF->_iCharRep);
		BOOL	fFontCheck = (dwMask2 & CFM2_MATCHFONT);
		BOOL	fHidden	   = dwMask & CFM_HIDDEN & pCF->_dwEffects;
		BOOL	fInRange;
		BOOL	fSymbolCharRep = IsSymbolOrOEMCharRep(pCF->_iCharRep);
		UINT	iCharRep = 0;
		CTxtPtr tp(_rpTX);

		if(fFontCheck && !fSymbolCharRep)
		{
			GetFontSignatureFromFace(pCF->_iFont, &qwFontSig);
			if(!qwFontSig)
				qwFontSig = FontSigFromCharRep(pCF->_iCharRep);
		}

		if (ped->_fIMEInProgress && !(dwMask2 & CFM2_SCRIPT))
			dwMask2 |= CFM2_NOCHARSETCHECK;		// Don't check charset or it will display garbage

		while(cch > 0 && rp.IsValid())
		{
			CF = *ped->GetCharFormat(rp.GetFormat());// Copy rp CF to temp CF
			if(fApplyStyle)
				CF.ApplyDefaultStyle(pCF->_sStyle);
			cchRun = cch;

			// Don't apply CFE_HIDDEN to table row delimiters or CELL
			if(fHidden)							
			{		 
				// For better perf, this could be done as a CTxtPtr function 
				// that has a prototype like CTxtPtr::TranslateRange().
				// REMARK: similar run breaking should be incorporated into
				// CTxtRange::ReplaceRange in case table structure elements
				// are inserted into a hidden run.
				if(cchSkipHidden)
				{
					cchRun = cchSkipHidden;		// Bypass table structure chars
					cchSkipHidden = 0;			//  found on preceding pass
					dwMask &= ~CFM_HIDDEN;
				}
				else							// Check for table structure 
				{								//  characters
					WCHAR ch;
					tp.SetCp(cp);
					cchLeft = rp.GetCchLeft(); 
					for(LONG i = 0; i < cchLeft;)
					{
						ch = tp.GetChar();
						if(ch == CELL)
						{
							cchSkipHidden = 1;
							cchRun = i;
							break;
						}
						if(IN_RANGE(STARTFIELD, ch, ENDFIELD) &&
							tp.IsAtTRD(0))
						{
							cchSkipHidden = 2;
							cchRun = i;
							break;
						}
						LONG cch = tp.AdvanceCRLF(TRUE);
						if(IsASCIIEOP(ch))		// Don't hide EOP if 
						{						//  followed by a TRD start
							if(tp.IsAtTRD(STARTFIELD))
							{
								cchSkipHidden = cch + 2;
								cchRun = i;
								break;
							}
						}
						i += cch;
					}
					if(!cchRun)
					{
						AssertSz(cchSkipHidden, "CTxtRange::SetCharFormat: cchRun = 0");
						continue;
					}
				}
			}
			if (CF._dwEffects & CFE_RUNISDBCS)
			{
				// Don't allow charset/face name change for DBCS run
				// causing these are garbage characters
				dwMask &= ~(CFM_CHARSET | CFM_FACE);
			}
			else if(fFontCheck)					// Only apply font if it						
			{									//  supports run's charset
				cchLeft = rp.GetCchLeft();
				cchRun = min(cchRun, cchLeft);	// Translate up to end of
				cchRun = min(cch, cchRun);		//  current CF run
				dwMask &= ~CFM_CHARSET;			// Default no charset change

				if(cchSkip)
				{								// Skip cchSkip chars (were
					cchRun = cchSkip;			//  not translatable with
					cchSkip = 0;				//  CodePage)
				}
				else if(fSymbolCharRep ^ IsSymbolOrOEMCharRep(CF._iCharRep))
				{								// SYMBOL to/from nonSYMBOL
					iCharRep = fSymbolCharRep ? CF._iCharRep : pCF->_iCharRep;
					if(!Is8BitCharRep(iCharRep))
						goto DoASCII;

					dwMask |= CFM_CHARSET;		// Need to change charset
					if(fSymbolCharRep)
						CF._iCharRepSave = iCharRep;

					else if(Is8BitCharRep(CF._iCharRepSave))
					{
						iCharRep = CF._iCharRep = CF._iCharRepSave;
						dwMask &= ~CFM_CHARSET;	// Already changed
					}

					tp.SetCp(cp);				// Point tp at start of run
					cchTrans = tp.TranslateRange(cchRun, CodePageFromCharRep(iCharRep),
										fSymbolCharRep,	publdr /*, cchSkip */);
					if(cchTrans < cchRun)		// Ran into char not in
					{							//  CodePage, so set up to
						cchSkip = 1;			//  skip the char
						cchRun = cchTrans;		// FUTURE: use cchSkip out
						if(!cchRun)				//  parm from TranslateRange
							continue;			//  instead of skipping 1 char
					}							//  at a time
				}
				else if(!fSymbolCharRep)
				{
DoASCII:			tp.SetCp(cp);				// Point tp at start of run
					fInRange = tp.GetChar() < 0x80;

					if (!fBiDiCharRep && !IsBiDiCharRep(CF._iCharRep) &&
						fInRange && 
                        ((qwFontSig & FASCII) == FASCII || fFECharRep || fSymbolCharRep))
					{
						// ASCII text and new font supports ASCII

						// -FUTURE-
						// We exclude BiDi here. We cannot allow applying BiDi
						// charset to non-BiDi run or vice versa. This because
						// we use charset for BiDi reordering. In the future,
						// we should use something more elegant than charset.
						if (!(FontSigFromCharRep(CF._iCharRep) & ~FASCII & qwFontSig))
							// New font doesn't support underlying charset,
							// apply new charset to ASCII
							dwMask |= CFM_CHARSET;
					}
					else if (!(FontSigFromCharRep(CF._iCharRep) & ~FASCII & qwFontSig) &&
						CF._iCharRep != DEFAULT_INDEX &&
						!IN_RANGE(JPN2_INDEX, CF._iCharRep, CHT2_INDEX))
						// New font doesn't support underlying charset: suppress
						// both new charset and facename except for default
						// index and surrogate pairs, for which we still know
						// too little to be sure
						dwMask &= ~CFM_FACE;

					cchRun -= tp.MoveWhile(cchRun, 0, 0x7F, fInRange);
				}
			}
			hr = CF.Apply(pCF, dwMask, dwMask2);// Apply *pCF
			if(hr != NOERROR)
				return hr;
			dwMask = dwMaskSave;				// Restore mask in case
			dwMask2 = dwMask2Save;				//  changed above
			hr = pf->Cache(&CF, &iCF);			// Cache result if new, In any
			if(hr != NOERROR)					//  cause, use format index iCF
				break;							

#ifndef NOLINESERVICES
			if (g_pols)
				g_pols->DestroyLine(NULL);
#endif
			// Set format for this run. Proper levels will be generated 
			// later by BiDi FSM.
			cchLeft = rp.SetFormat(iCF, cchRun, pf);
			if(cchLeft < cchRun)				// Didn't format all of cchRun:
				cchSkip = cchSkipHidden = 0;	// Turn off cchSkip, since need
			cchRun = cchLeft;					//  to format rest of cchRun 1st
			pf->Release(iCF);					// Release count from Cache above
												// rp.SetFormat AddRef's as needed
			if(cchRun == CP_INFINITE)
			{
				ped->GetCallMgr()->SetOutOfMemory();
				break;
			}
			cp += cchRun;
			cch -= cchRun;
		}
		_rpCF.AdjustBackward();					// Expand scope for merging
		rp.AdjustForward();						//  runs

		rp.MergeRuns(_rpCF._iRun, pf);			// Merge adjacent runs that
												//  have the same format
		if(cchBack)								// Move _rpCF back to where it
			_rpCF.Move(-cchBack);				//  was
		else									// Active end at range start:
			_rpCF.AdjustForward();				//  don't leave at EOR

		if(pnm)
		{
			pnm->NotifyPostReplaceRange(this, 	// Notify interested parties
				CP_INFINITE, 0, 0, cpStart,		// of the change.
					cpStart + cchFormat - cch);
		}

		if(publdr && !(flags & SCF_IGNORESELAE))
		{
			HandleSelectionAEInfo(ped, publdr, GetCp(), _cch, GetCp(), _cch,
					SELAE_FORCEREPLACE);
		}

		if(!_cch)								// In case IP with ApplyToWord
		{
			if(fApplyToEOP)						// Formatting EOP only
				goto LApplytoIP;

			Update_iFormat(-1);				
		}
		if (ped->IsRich())
			ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	}
	if(_fSel && ped->IsRich() && !ped->_f10Mode /*bug fix #5211*/)
		ped->GetCallMgr()->SetSelectionChanged();

	AssertSz(GetCp() == (cp = _rpCF.CalculateCp()),
		"RTR::SetCharFormat(): incorrect format-run ptr");

	if (!(dwMask2 & (CFM2_SCRIPT | CFM2_HOLDITEMIZE)) && cchFormat && hr == NOERROR && !cch)
	{
		// A non-degenerate range not coming from ItemizeRuns

		// It's faster to make a copy pointer since we dont need to worry about fExtend.
		CRchTxtPtr 	rtp(*this);

		rtp.Move(cchBack + cchFormat);
		rtp.ItemizeReplaceRange(cchFormat, 0, publdr);

		return hr;
	}
		
	return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *	CTxtRange::GetParaFormat(pPF)
 *	
 *	@mfunc
 *		return CParaFormat for this text range. If no PF runs are allocated,
 *		then return default CParaFormat
 *
 *	@rdesc
 *		Mask of defined properties: 1 bit means corresponding property is
 *		defined and constant throughout range.  0 bit means it isn't constant
 *		throughout range.  Note that PARAFORMAT has fewer relevant bits
 *		(PFM_ALL vs PFM_ALL2)
 */
DWORD CTxtRange::GetParaFormat (
	CParaFormat *pPF,			//@parm ptr to CParaFormat to be filled
	DWORD		 dwMask2) const	//@parm Mask specifying PFM2_PARAFORMAT
{								
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetParaFormat");

	CTxtEdit * const ped = GetPed();

   	_TEST_INVARIANT_

	DWORD dwMask = dwMask2 & PFM2_PARAFORMAT		// Default presence of
				 ? PFM_ALL : PFM_ALL2;				//  all properties	

	CFormatRunPtr rp(_rpPF);
	LONG		  cch = -_cch;

	if(cch < 0)										// At end of range:
	{												//  go to start of range
		rp.Move(cch);
		cch = -cch;									// Count with cch > 0
	}

	*pPF = *ped->GetParaFormat(rp.GetFormat());		// Initialize *pPF to
													//  starting paraformat
	if(!cch || !rp.IsValid())						// No cch or invalid PF
		return dwMask;								//	run ptr: use PF at
													//  this text ptr
	LONG cchChunk = rp.GetCchLeft();				// Chunk size for rp
	while(cchChunk < cch)							// NINCH properties that
	{												//  change over the range
		cch -= cchChunk;							//	given by cch
		if(!rp.NextRun())		 					// Go to next run													// No more runs
			break;									//	(cch too big)
		cchChunk = rp.GetCchLeft();
		dwMask &= ~ped->GetParaFormat(rp.GetFormat())// NINCH properties that
			->Delta(pPF, dwMask2 & PFM2_PARAFORMAT);//  changed, i.e., reset
	}												//  corresponding bits
	return dwMask;
}

/*
 *	CTxtRange::SetParaFormat(pPF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		apply CParaFormat *pPF to this range.
 *
 *	@rdesc
 *		if successfully set whole range, return NOERROR, otherwise
 *		return error code or S_FALSE.
 */
HRESULT CTxtRange::SetParaFormat (
	const CParaFormat* pPF,		//@parm CParaFormat to apply to this range
	IUndoBuilder *publdr,		//@parm Undo context for this operation
	DWORD		  dwMask,		//@parm Mask to use
	DWORD		  dwMask2)		//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::SetParaFormat");

	LONG				cch;				// Length of text to format
	LONG				cchBack;			// cch to back up for formatting
	LONG				cp;	
	LONG				cpMin, cpMost;		// Limits of text to format
	LONG				delta;
	HRESULT				hr = NOERROR;
	LONG				iPF = 0;			// Index to a CParaFormat
	CTxtEdit * const	ped = GetPed();
	CParaFormat			PF;					// Temporary CParaFormat
	IParaFormatCache *	pf = GetParaFormatCache();// Format cache ptr for Cache,
											//  AddRefFormat, ReleaseFormat
	CBiDiLevel*			pLevel;
	CBiDiLevel			lvRTL = {1, 0};
	CBiDiLevel			lvLTR = {0, 0};
	CFreezeDisplay		fd(ped->_pdp);

 	_TEST_INVARIANT_

	if(!Check_rpPF())
		return E_FAIL;

	FindParagraph(&cpMin, &cpMost);				// Get limits of text to
	cch = cpMost - cpMin;						//  format, namely closest

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
	{
		pnm->NotifyPreReplaceRange(this,		// Notify interested parties of
			CP_INFINITE, 0, 0, cpMin, cpMost);	// the impending update
	}

	cchBack = cpMin - GetCp();

	// Move _rpPF in front of the changes to allow easy rebinding
	_rpPF.Move(cchBack);						// Back up to formatting start
	CFormatRunPtr rp(_rpPF);					// Clone _rpPF to walk range

	if(publdr)
	{
		IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE(ped,
							cpMin, rp, cch, pf, ParaFormat);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	
	BOOL 	fLevelChanged = FALSE;
	const CParaFormat *pPFRun = ped->GetParaFormat(rp.GetFormat());
	LONG	TableLevel = pPFRun->_bTableLevel;

	if(pPFRun->IsTableRowDelimiter())
		TableLevel--;

	CParaFormat PFStyle;
	if(ped->HandleStyle(&PFStyle, pPF, dwMask, dwMask2) == NOERROR)
	{
		pPF = &PFStyle;
		dwMask = PFM_ALL2 ^ PFM_TABLE;
	}

	DWORD dwMaskSave = dwMask;
	do
	{
		dwMask = dwMaskSave;
		pPFRun = ped->GetParaFormat(rp.GetFormat());// Get current PF

		LONG TableLevelRun = pPFRun->_bTableLevel;
		WORD wEffectsRun = pPFRun->_wEffects;	// Save effects to avoid using
												//  pPFRun, which may be invalid
		if(pPFRun->IsTableRowDelimiter())		//	after PF.Apply()
		{
			TableLevelRun--;
			if(!(dwMask2 & PFM2_ALLOWTRDCHANGE))
			{
				dwMask &= PFM_STARTINDENT | PFM_ALIGNMENT | PFM_OFFSETINDENT | 
						  PFM_RIGHTINDENT | PFM_RTLPARA;
			}
		}
		if(TableLevelRun > TableLevel)
		{
			cch -= rp.GetCchLeft();				// Skip run
			rp.NextRun();
			continue;
		}
		PF = *pPFRun;
		hr = PF.Apply(pPF, dwMask, dwMask2);	// Apply *pPF
		if(hr != NOERROR)						//  (Probably E_INVALIDARG)
			break;								// Cache result if new; in any
		hr = pf->Cache(&PF, &iPF);				//  case, get format index iPF
		if(hr != NOERROR)						// Can't necessarily return
			break;								//  error, since may need
		if(!fLevelChanged)
			fLevelChanged = (wEffectsRun ^ PF._wEffects) & PFE_RTLPARA;

		pLevel = PF.IsRtl() ? &lvRTL : &lvLTR;

		delta = rp.SetFormat(iPF, cch, pf, pLevel);	// Set format for this run
		pf->Release(iPF);						// rp.SetFormat AddRefs as needed

		if(delta == CP_INFINITE)
		{
			ped->GetCallMgr()->SetOutOfMemory();
			break;
		}
		cch -= delta;
	} while (cch > 0) ;

	_rpPF.AdjustBackward();						// If at BOR, go to prev EOR
	rp.MergeRuns(_rpPF._iRun, pf);				// Merge any adjacent runs
												//  that have the same format
	if(cchBack)									// Move _rpPF back to where it
		_rpPF.Move(-cchBack);					//  was
	else										// Active end at range start:
		_rpPF.AdjustForward();					//  don't leave at EOR

	if(pnm)
	{
		pnm->NotifyPostReplaceRange(this,		// Notify interested parties of
			CP_INFINITE, 0, 0, cpMin,	cpMost);	//  the update
	}

	if(publdr)
	{
		// Paraformatting works a bit differently, it just remembers the
		// current selection. Cast selection to range to avoid including
		// _select.h; we only need range methods.
		CTxtRange *psel = (CTxtRange *)GetPed()->GetSel();
		if(psel)
		{
			cp  = psel->GetCp();
			HandleSelectionAEInfo(ped, publdr, cp, psel->GetCch(),
								  cp, psel->GetCch(), SELAE_FORCEREPLACE);
		}
	}

	ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	AssertSz(GetCp() == (cp = _rpPF.CalculateCp()),
		"RTR::SetParaFormat(): incorrect format-run ptr");

	if (fLevelChanged && cpMost > cpMin)
	{
        ped->OrCharFlags(FRTL, publdr);

		// make sure the CF is valid
		Check_rpCF();

		CTxtRange	rg(*this);

		if (publdr)
		{
			// Create anti-events to keep BiDi level of paragraphs in need
			ICharFormatCache*	pcfc = GetCharFormatCache();
			CFormatRunPtr		rp(_rpCF);

			rp.Move(cpMin - _rpTX.GetCp());

			IAntiEvent *pae = gAEDispenser.CreateReplaceFormattingAE (ped,
								cpMin, rp, cpMost - cpMin, pcfc, CharFormat);
			if (pae)
				publdr->AddAntiEvent(pae);
		}
		rg.Set(cpMost, cpMost - cpMin);
		rg.ItemizeRuns (publdr);
	}

	return (hr == NOERROR && cch) ? S_FALSE : hr;
}

/*
 *	CTxtRange::SetParaStyle(pPF, publdr, dwMask)
 *
 *	@mfunc
 *		apply CParaFormat *pPF using the style pPF->sStyle to this range.
 *
 *	@rdesc
 *		if successfully set whole range, return NOERROR, otherwise
 *		return error code or S_FALSE.
 *
 *	@comm
 *		If pPF->dwMask & PFM_STYLE is nonzero, this range is expanded to
 *		complete paragraphs.  If it's zero, this call just passes control
 *		to CTxtRange::SetParaStyle().
 */
 HRESULT CTxtRange::SetParaStyle (
	const CParaFormat* pPF,		//@parm CParaFormat to apply to this range
	IUndoBuilder *publdr,		//@parm Undo context for this operation
	DWORD		  dwMask)		//@parm Mask to use
{
	LONG	cchSave = _cch;			// Save range cp and cch in case
	LONG	cpSave  = GetCp();		//  para expand needed
	HRESULT hr;
	
	if(publdr)
		publdr->StopGroupTyping();

	if(pPF->fSetStyle(dwMask, 0))
	{
		CCharFormat	CF;				// Need to apply associated CF
		LONG		cpMin, cpMost;
		DWORD		dwMaskCF = CFM_STYLE;

		Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

		CF._sStyle = pPF->_sStyle;
		if(CF._sStyle == STYLE_NORMAL)
		{
			CF = *GetPed()->GetCharFormat(-1);
			dwMaskCF = CFM_ALL2;
		}
		hr = SetCharFormat(&CF, 0, publdr, dwMaskCF, 0);
		if(hr != NOERROR)
			return hr;
	}
	hr = SetParaFormat(pPF, publdr, dwMask, 0);
	Set(cpSave, cchSave);			// Restore this range in case expanded
	return hr;
}

/*
 *	CTxtRange::Update_iFormat(iFmtDefault)
 *	
 *	@mfunc
 *		update _iFormat to CCharFormat at current active end
 *
 *	@devnote
 *		_iFormat is only used when the range is degenerate
 *
 *		The Word 95 UI specifies that the *previous* format should
 *		be used if we're in at an ambiguous cp (i.e. where a formatting
 *		change occurs) _unless_ the previous character is an EOP
 *		marker _or_ if the previous character is protected.
 */
void CTxtRange::Update_iFormat (
	LONG iFmtDefault)		//@parm Format index to use if _rpCF isn't valid
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update_iFormat");

	DWORD	dwEffects;
	LONG	ifmt, iFormatForward;
	const CCharFormat *pCF, *pCFForward;

	if(_cch)
		return;

	_fSelHasEOP  = FALSE;						// Empty ranges don't contain
	_fSelExpandCell = FALSE;					//  anything, incl EOPs/cells
	_nSelExpandLevel  = 0;

	if(_fDontUpdateFmt)							// _iFormat is only used
		return;									//  for degenerate ranges

	if(_rpCF.IsValid() && iFmtDefault == -1)
	{
		// Get forward info before possibly adjusting backward
		_rpCF.AdjustForward();
		ifmt = iFormatForward = _rpCF.GetFormat();
		pCF  = pCFForward = GetPed()->GetCharFormat(ifmt);
		
		if(!_rpTX.IsAfterEOP())
		{
			_rpCF.AdjustBackward();				// Adjust backward
			ifmt = _rpCF.GetFormat();
			pCF = GetPed()->GetCharFormat(ifmt);
		}
		dwEffects = pCF->_dwEffects;

		if (!(GetPed()->_fIMEInProgress))		// Dont change format during IME
		{		
			if(!_rpTX.GetCp() && (dwEffects & CFE_RUNISDBCS))
			{
				// If at beginning of document, and text is protected, just use
				// default format.
				ifmt = iFmtDefault;
			}
			else if(dwEffects & (CFE_PROTECTED | CFE_LINK | CFE_HIDDEN | CFE_RUNISDBCS))
			{
				// If range is protected, hidden, or a friendly hyperlink,
				// pick forward format
				ifmt = iFormatForward;
			}
			else if(ifmt != iFormatForward && _fMoveBack &&
				IsRTLCharRep(pCF->_iCharRep) != IsRTLCharRep(pCFForward->_iCharRep))
			{
				ifmt = iFormatForward;
			}
		}
		iFmtDefault = ifmt;
	}

	// Don't allow _iFormat to include CFE_HIDDEN attributes
	// unless they're the default
	if(iFmtDefault != -1)
	{
		pCF = GetPed()->GetCharFormat(iFmtDefault);
		if(pCF->_dwEffects & (CFE_HIDDEN | CFE_LINKPROTECTED))
		{
			if(!(pCF->_dwEffects & CFE_LINKPROTECTED))
			{
				CCharFormat CF = *pCF;
				CF._dwEffects &= ~CFE_HIDDEN;

				Assert(_cch == 0);				// Must be an insertion point
				SetCharFormat(&CF, FALSE, NULL, CFM_ALL2, 0);
				return;
			}
			if(!(pCF->_dwEffects & CFE_HIDDEN) && !(GetCF()->_dwEffects & CFE_LINK))
				iFmtDefault = _rpCF.GetFormat();// Don't extend friendly link names
		}
	}
	Set_iCF(iFmtDefault);
}

/*
 *	CTxtRange::GetCharRepMask(fUseDocFormat)
 *	
 *	@mfunc
 *		Get this range's char repertoire mask corresponding to _iFormat.
 *		If fUseDocFormat is TRUE, then use -1 instead of _iFormat.
 *
 *	@rdesc
 *		char repertoire mask for range or default document
 */
QWORD CTxtRange::GetCharRepMask(
	BOOL fUseDocFormat)
{
	LONG iFormat = fUseDocFormat ? -1 : GetiFormat();
	QWORD qwMask = FontSigFromCharRep((GetPed()->GetCharFormat(iFormat))->_iCharRep);

	qwMask &= ~FOTHER;

	if(qwMask & FSYMBOL)
		return qwMask;

	// For now, Indic fonts match only ASCII digits
	qwMask |= FBELOWX40;
	if(!(qwMask & FINDIC))
		qwMask |= FASCII;					// FASCIIUPR+FBELOWX40

	if(qwMask & FLATIN)
		qwMask |= FCOMBINING;

	return qwMask;
}

/*
 *	CTxtRange::GetiFormat()
 *	
 *	@mfunc
 *		Return (!_cch || _fUseiFormat) ? _iFormat : iFormat at cpMin
 *	
 *	@rdesc
 *		iFormat at cpMin if nondegenerate and !_fUseiFormat; else _iFormat
 *
 *	@devnote
 *		This routine doesn't AddRef iFormat, so it shouldn't be used if
 *		it needs to be valid after character formatting has changed, e.g.,
 *		by ReplaceRange or SetCharFormat or SetParaStyle
 */
LONG CTxtRange::GetiFormat() const
{
	if(!_cch || _fUseiFormat)
		return _iFormat;

	if(_cch > 0)
	{
		CFormatRunPtr rp(_rpCF);
		rp.Move(-_cch);
		return rp.GetFormat();
	}
	return _rpCF.GetFormat();
}

/*
 *	CTxtRange::Get_iCF()
 *	
 *	@mfunc
 *		Get this range's _iFormat (AddRef'ing, of course)
 *
 *	@devnote
 *		Get_iCF() is used by the RTF reader
 */
LONG CTxtRange::Get_iCF ()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Get_iCF");

	GetCharFormatCache()->AddRef(_iFormat);
	return _iFormat;
}

/*
 *	CTxtRange::Set_iCF(iFormat)
 *	
 *	@mfunc
 *		Set range's _iFormat to iFormat, AddRefing and Releasing as required.
 *
 *	@rdesc
 *		TRUE if _iFormat changed
 */
BOOL CTxtRange::Set_iCF (
	LONG iFormat)				//@parm Index of char format to use
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set_iCF");

	if(iFormat == _iFormat)
		return FALSE;

	ICharFormatCache *pCFC = GetCharFormatCache();

	pCFC->AddRef(iFormat);
	pCFC->Release(_iFormat);			// Note: _iFormat = -1 doesn't
	_iFormat = iFormat;					//  get AddRef'd or Release'd

	AssertSz(GetCF(), "CTxtRange::Set_iCF: illegal format");
	return TRUE;
}

/*
 *	CTxtRange::IsHidden()
 *
 *	@mfunc
 *		Return TRUE iff range end is hidden. If nondegenerate, check
 *		char at appropriate range end
 *
 *	@rdesc
 *		TRUE if range active end is hidden
 */
BOOL CTxtRange::IsHidden()
{
	if(_cch > 0)
		_rpCF.AdjustBackward();

	BOOL fHidden = CRchTxtPtr::IsHidden();

	if(_cch > 0)
		_rpCF.AdjustForward();

	return fHidden;
}

#ifndef NOCOMPLEXSCRIPTS
/*
 *	CTxtRange::BiDiLevelFromFSM(pFSM)
 *	
 *	@mfunc
 *		Run BiDi FSM to generate proper embedding level for runs
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CTxtRange::BiDiLevelFromFSM (
	const CBiDiFSM*	pFSM) 		// in: ptr to FSM
{
	AssertSz(pFSM && _rpCF.IsValid(), "Not enough information to run BiDi FSM");
	
	LONG				cpMin, cpMost, cp, cchLeft;
	LONG				ich, cRunsStart, cRuns = 0;
	HRESULT				hr = S_OK;

	GetRange(cpMin, cpMost);

	AssertSz (cpMost - cpMin > 0, "FSM: Invalid range");

	CRchTxtPtr			rtp(*this);

	rtp.Move(cpMin - rtp.GetCp());					// initiate position to cpMin
	CFormatRunPtr	rpPF(rtp._rpPF);				// pointer to current paragraph

	cchLeft = cpMost - cpMin;
	cp = cpMin;

	while (cchLeft > 0 && SUCCEEDED(hr))
	{
		// accumulate runs within the same paragraph level
		cRuns = GetRunsPF(&rtp, &rpPF, cchLeft);
		cRunsStart = 0;								// assume no start run

		ich = rtp.Move(-rtp.GetIchRunCF());			// locate preceding run
		rtp._rpCF.AdjustBackward();					// adjusting format backward
		rtp._rpPF.AdjustBackward();					// adjusting format backward

		if(rtp._rpPF.SameLevel(&rpPF))
		{
			// start at the beginning of preceding run
			if (rtp.Move(-rtp.GetCchRunCF()))
				cRunsStart++;
		}
		else
		{
			// preceding run is not at the same paragraph level, resume position
			rtp.Move(-ich);
		}

		rtp._rpCF.AdjustForward();					// make sure we have forward run pointers
		rtp._rpPF.AdjustForward();

		// Run FSM for the number of runs in multiple paragraphs with the same level
		hr = pFSM->RunFSM(&rtp, cRuns, cRunsStart, rtp.IsParaRTL() ? 1 : 0);

		cp = cpMost - cchLeft;
		rtp.Move(cp - rtp.GetCp());					// Advance to next paragraph(s)
		rpPF = rtp._rpPF;							// paragraph format at cp
	}

	AssertSz (cp == cpMost , "Running BiDi FSM partially done!");

	_rpCF = rtp._rpCF;								// We may have splitted CF runs

	return hr;
}
#endif // NOCOMPLEXSCRIPTS

/*
 *  CTxtRange::GetRunsPF(prtp, prpPF, cchLeft)
 *
 *	@mfunc
 *		Get the number of CF runs within the same paragraph's base level.
 *  Its scope could cover multiple paragraphs. As long as they are in the
 *  same level, we can run them through the FSM in one go.
 *
 */
LONG CTxtRange::GetRunsPF(
	CRchTxtPtr*			prtp, 		// in: RichText ptr to the first run in range
	CFormatRunPtr*		prpPF,		// in: Pointer to current paragraph run
	LONG&	   			cchLeft)	// in/out: number of char left
{
	Assert (prtp && prtp->_rpPF.SameLevel(prpPF) && cchLeft > 0);

	LONG				cRuns = 0;
	LONG				cchRun, cchText = cchLeft;
	ICharFormatCache*	pf = GetCharFormatCache();


	// check if the first CF run is PF bound
	//

	prtp->_rpPF.AdjustBackward();

	if (prtp->GetIchRunCF() > 0 && !prtp->_rpPF.SameLevel(prpPF))
		prtp->_rpCF.SplitFormat(pf);					// PF breaks inside a CF run, split the run

	prtp->_rpPF.AdjustForward();						// make sure we are all forward.
	prtp->_rpCF.AdjustForward();


	while (cchText > 0)
	{
		cchRun = min(prtp->GetCchLeftRunPF(), prtp->GetCchLeftRunCF());
		cchRun = min(cchText, cchRun);					// find out the nearest hop
		cchText -= cchRun;

		prtp->Move(cchRun);								// to the next hop

		if (!prtp->_rpPF.SameLevel(prpPF))
		{												// this is a para with different level
			prtp->_rpCF.SplitFormat(pf);				// split that CF run
			cRuns++;									// count the splitted
			break;										// and we're done
		}

		if (!cchText || 								// this is the last hop -or-
			!prtp->GetIchRunCF() || 					// we're at the start or the end of a CF run
			!prtp->GetCchLeftRunCF())
		{
			cRuns++;				  					// count this hop
		}
	}

	prtp->Move(cchText - cchLeft);						// resume position
	cchLeft = cchText;									// update number of char left

	return cRuns;
}

/*
 *	CTxtRange::SpanSubstring (pusp, prp, pwchString, cchString, &uSubStrLevel,
 *							  dwInFlags, &dwOutFlags, &wBiDiLangId)
 *	@mfunc
 *		Span the run of text bound by or contains only block separators
 *		and share the same charset directionality.
 *
 *	@rdesc
 *		number of span'ed text characters
 */
LONG CTxtRange::SpanSubstring(
	CUniscribe *	pusp,			//@parm in: Uniscribe interface
	CFormatRunPtr *	prp,			//@parm in: Format run pointer
	WCHAR *			pwchString,		//@parm in: Input string
	LONG			cchString,		//@parm in: String character count
	WORD &			uSubStrLevel,	//@parm in/out: BiDi substring initial level
	DWORD			dwInFlags,		//@parm in: Input flags
	CCharFlags*		pCharflags,		// out:Output charflags
	WORD &			wBiDiLangId)	//@parm out:Primary language of a BiDi run
{
	Assert (pusp && cchString > 0 && prp && prp->IsValid());

	LONG cch, cchLeft;

	cch = cchLeft = cchString;

	wBiDiLangId = LANG_NEUTRAL;		// assume unknown

	if (dwInFlags & SUBSTR_INSPANCHARSET)
	{
		// span runs with same charset's direction

		CTxtEdit*	   		ped = GetPed();
		CFormatRunPtr		rp(*prp);
		const CCharFormat*	pCF;
		BOOL				fNext;
		BYTE				iCharRep1, iCharRep2;

		rp.AdjustForward();
	
		pCF = ped->GetCharFormat(rp.GetFormat());
	
		iCharRep1 = iCharRep2 = pCF->_iCharRep;
	
		while (!(iCharRep1 ^ iCharRep2))
		{
			cch = min(rp.GetCchLeft(), cchLeft);
			cchLeft -= cch;
	
			if (!(fNext = rp.NextRun()) || !cchLeft)
				break;
			
			iCharRep1 = iCharRep2;
	
			pCF = ped->GetCharFormat(rp.GetFormat());
			iCharRep2 = pCF->_iCharRep;
		}
		uSubStrLevel = IsBiDiCharRep(iCharRep1) ? 1 : 0;

		if (uSubStrLevel & 1)
			wBiDiLangId = iCharRep1 == ARABIC_INDEX ? LANG_ARABIC : LANG_HEBREW;

		cchString -= cchLeft;
		cch = cchString;

		dwInFlags |= SUBSTR_INSPANBLOCK;
	}

    if (dwInFlags & SUBSTR_INSPANBLOCK)
    {
        // scan the whole substring to collect information about it

        DWORD   dwBS = IsEOP(*pwchString) ? 1 : 0;
		BYTE	bCharMask;

        cch = 0;

		if (pCharflags)
			pCharflags->_bFirstStrong = pCharflags->_bContaining = 0;

        while (cch < cchString && !((IsEOP(pwchString[cch]) ? 1 : 0) ^ dwBS))
        {
			if (!dwBS && pCharflags)
			{
				bCharMask = 0;
	
				switch (MECharClass(pwchString[cch]))
				{
					case CC_ARABIC:
					case CC_HEBREW:
					case CC_RTL:
							bCharMask = SUBSTR_OUTCCRTL;
							break;
					case CC_LTR:
							bCharMask = SUBSTR_OUTCCLTR;
					default:
							break;
				}
	
				if (bCharMask)
				{
					if (!pCharflags->_bFirstStrong)
						pCharflags->_bFirstStrong |= bCharMask;
	
					pCharflags->_bContaining |= bCharMask;
				}
			}
            cch++;
        }
    }
	return cch;
}

/*
 *  CTxtRange::ItemizeRuns(publdr, fUnicodeBidi, fUseCtxLevel)
 *
 *	@mfunc
 *		Break text range into smaller run(s) containing
 *
 *		1. Script ID for complex script shaping
 *		2. Charset for run internal direction
 *		3. BiDi embedding level
 *
 *	@rdesc
 *		TRUE iff one or more items found.
 *		The range's active end will be at cpMost upon return.
 *
 *	@devnote
 *		This routine could handle mixed paragraph runs
 */
BOOL CTxtRange::ItemizeRuns(
    IUndoBuilder	*publdr,        //@parm Undo context for this operation
    BOOL			fUnicodeBiDi,   //@parm TRUE: Caller needs Bidi algorithm
    BOOL			fUseCtxLevel)	//@parm Itemize using context based level (only valid if fUnicodeBiDi is true)
{
#ifndef NOCOMPLEXSCRIPTS
	CTxtEdit*		ped = GetPed();
	LONG			cch, cchString;
	CCharFormat		CF;
	CCharFlags		charflags = {0};
	int				cItems = 0;
	LONG			cpMin, cpMost;
	BOOL			fBiDi = ped->IsBiDi();
	CFreezeDisplay	fd(ped->_pdp);			// Freeze display
	BOOL			fChangeCharSet = FALSE;
	BOOL			fRunUnicodeBiDi;
	BOOL			fStreaming = ped->IsStreaming();
	BYTE			iCharRepDefault = ped->GetCharFormat(-1)->_iCharRep;
	BYTE			pbBufIn[MAX_CLIENT_BUF];
	SCRIPT_ITEM *	psi;
	CTxtPtr			tp(_rpTX);
	WORD			uParaLevel;				// Paragraph initial level
	WORD			uSubStrLevel;			// Substring initial level
	WORD			wBiDiLangId;
#ifdef DEBUG
	LONG			cchText = GetTextLength();
#endif

	// Get range and setup text ptr to the start
	cch = cchString = GetRange(cpMin, cpMost);
	if (!cch)
		return FALSE;

	tp.SetCp(cpMin);

	// Prepare Uniscribe
	CUniscribe *pusp = ped->Getusp();
	if (!pusp)
		return FALSE;

	// Allocate temp buffer for itemization
	PUSP_CLIENT	pc = NULL;
	pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize);
	if(!pc)
		return FALSE;

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->NotifyPreReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);

	LONG cp = cpMin;	// Set cp starting point at cpMin
	Set(cp, 0);			// equals to Collapser(tomStart)
	Check_rpCF();		// Make sure _rpCF is valid

	// Always run UnicodeBidi for plain text control
	// (2.1 backward compatible)
    if(!ped->IsRich())
    {
        fUnicodeBiDi = TRUE;
		fUseCtxLevel = FALSE;
    }
	if(!fBiDi)
		fUnicodeBiDi = FALSE;

	uSubStrLevel = uParaLevel = IsParaRTL() ? 1 : 0;	// initialize substring level

	WCHAR *pwchString = pc->si->pwchString;
	tp.GetTextForUsp(cchString, pwchString, ped->_fNeutralOverride);

    while ( cchString > 0 &&
            ((cch = SpanSubstring(pusp, &_rpCF, pwchString, cchString, uSubStrLevel,
                    fUnicodeBiDi ? SUBSTR_INSPANBLOCK : SUBSTR_INSPANCHARSET,
					(fStreaming || fUseCtxLevel) ? &charflags : NULL,
                    wBiDiLangId)) > 0) )
	{
		LONG cchSave = cch;
		BOOL fWhiteChunk = FALSE;			// Chunk contains only whitespaces

		if (uSubStrLevel ^ uParaLevel)
		{
			// Handle Bidi spaces when substring level counters paragraph base direction.

			// Span leading spaces
			cch = 0;
			while (cch < cchSave && pwchString[cch] == 0x20)
				cch++;

			if (cch)
				fWhiteChunk = TRUE;
			else
			{
				// Trim out trailing whitespaces (including CR)
				cch = cchSave;
				while (cch > 0 && IsWhiteSpace(pwchString[cch-1]))
					cch--;
				if (!cch)
					cch = cchSave;
			}
			Assert(cch > 0);
		}

        // Itemize with Unicode Bidi algorithm when
        //   a. Plain text mode
        //   b. Caller wants (fUnicodeBidi != 0)
        //   c. Substring is RTL.
        fRunUnicodeBiDi = fUnicodeBiDi || uSubStrLevel;
        fChangeCharSet = fUnicodeBiDi;

        if (!fUnicodeBiDi && uSubStrLevel == 1 && fStreaming)
        {
            // During RTF streaming if the RTL run contains strong LTR,
            // we resolve them using the paragraph base level
            if (charflags._bContaining & SUBSTR_OUTCCLTR)
                uSubStrLevel = uParaLevel;

            fChangeCharSet = TRUE;
        }

        // Caller wants context based level.
        // We want to itemize incoming plain text (into richtext doc) with the base level
        // of the first strong character found in each substrings (wchao - 7/15/99)
		if (fUnicodeBiDi && fUseCtxLevel && charflags._bFirstStrong)
			uSubStrLevel = (WORD)(charflags._bFirstStrong & SUBSTR_OUTCCRTL ? 1 : 0);

		if (fWhiteChunk || pusp->ItemizeString (pc, uSubStrLevel, &cItems, pwchString, cch,
												fRunUnicodeBiDi, wBiDiLangId) > 0)
		{
			const SCRIPT_PROPERTIES *psp;
			DWORD 					 dwMask1;
	
			psi = pc->si->psi;
			if (fWhiteChunk)
			{
				cItems = 1;
				psi[0].a.eScript = SCRIPT_WHITE;
				psi[0].iCharPos = 0;
				psi[1].iCharPos = cch;
			}

			Assert(cItems > 0);
	
			// Process items
			for(LONG i = 0; i < cItems; i++)
			{
				cp += psi[i+1].iCharPos - psi[i].iCharPos;
				AssertNr (cp <= cchText);
				SetCp(min(cp, cpMost), TRUE);
				
				dwMask1 = 0;

				// Associate the script properties
				psp = pusp->GeteProp(psi[i].a.eScript);
				Assert (psp);

				if (!psp->fComplex && !psp->fNumeric &&
					!psi[i].a.fRTL && psi[i].a.eScript < SCRIPT_MAX_COUNT)
				{
					// Note: Value 0 here is a valid script ID (SCRIPT_UNDEFINED),
					// guaranteed by Uniscribe to be available all the time
					// so we're safe using it as our simplified script ID.
					psi[i].a.eScript = 0;
					psp = pusp->GeteProp(0);
				}
				CF._wScript = psi[i].a.eScript;
			
				// Stamp appropriate charset
				if (pusp->GetComplexCharRep(psp, iCharRepDefault, CF._iCharRep))
				{
					// Complex script that has distinctive charset
					dwMask1 |= CFM_CHARSET;
				}
				else if (fChangeCharSet)
				{
					// We run UnicodeBidi to analyse the whole thing so
					// we need to figure out the proper charset to use as well.
					//
					// Note that we don't want to apply charset in general, say things
					// like East Asia or GREEK_CHARSET should remain unchanged by
					// this effect. But doing charset check is tough since we deal
					// with text in range basis, so we simply call to update it here
					// and let CCharFormat::Apply do the charset test in down level.

					CF._iCharRep = CharRepFromCharSet(psp->bCharSet);	// Assume what Uniscribe has given us
					if (psi[i].a.fRTL || psi[i].a.fLayoutRTL)
					{
						// Those of strong RTL and RTL digits need RTL char repertoire
						CF._iCharRep = pusp->GetRtlCharRep(ped, this);
					}
					
					Assert(CF._iCharRep != DEFAULT_INDEX);
					dwMask1 |= CFM_CHARSET;
				}

				// No publdr for this call so no antievent for itemized CF
				SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, dwMask1, CFM2_SCRIPT);
				Set(cp, 0);
#ifdef DEBUG
				if(IN_RANGE(0xDC00, GetPrevChar(), 0xDFFF))
				{
					_rpCF.AdjustBackward();
					if(_rpCF.GetIch() == 1)	// Solo trail surrogate in run
					{
						CTxtPtr tp(_rpTX);	// If lead surrogate preceeds it,
						tp.Move(-1);		//  Assert
						AssertSz(!IN_RANGE(0xD800, tp.GetPrevChar(), 0xDBFF),
							 "CTxtRange::ItemizeRuns: nonuniform CF for surrogate pair");
					}
					_rpCF.AdjustForward();
				}
#endif
			}
		}
		else
		{
			// Itemization fails.
			cp += cch;		
			SetCp(min(cp, cpMost), TRUE);

			// Reset script id to 0
			CF._wScript = 0;
			SetCharFormat(&CF, SCF_IGNORENOTIFY, NULL, 0, CFM2_SCRIPT);
			Set(cp, 0);
		}
		pwchString = &pc->si->pwchString[cp - cpMin];	// Point at next substring
		cchString -= cch;
		uParaLevel = IsParaRTL() ? 1 : 0;	// Paragraph level might have changed
	}
	Assert (cpMost == cp);

	Set(cpMost, cpMost - cpMin);			// Restore original range (may change active end)
	if(fBiDi)
	{
		// Retrieve ptr to Bidi FSM
		HRESULT			hr = E_FAIL;
		const CBiDiFSM*	pFSM = pusp->GetFSM();
		Check_rpPF();						// Be sure PF runs are instantiated
		if (pFSM)
			hr = BiDiLevelFromFSM (pFSM);

		AssertSz(SUCCEEDED(hr), "Unable to run or running BiDi FSM fails! We are in deep trouble,");
	}
	if (pc && pbBufIn != (BYTE *)pc)
		FreePv(pc);

	ped->_fItemizePending = FALSE;			// Update flag

	// Notify backing store change to all notification sinks
	if(pnm)
		pnm->NotifyPostReplaceRange(this, CP_INFINITE, 0, 0, cpMin, cpMost);

	return cItems > 0;
#else
	return TRUE;
#endif // NOCOMPLEXSCRIPTS
}

/*
 *	CTxtRange::IsProtected(iDirection)
 *	
 *	@mfunc
 *		Return TRUE if any part of this range is protected (HACK:  or
 *		if any part of the range contains DBCS text stored in our Unicode
 *		backing store).  If degenerate,
 *		use CCharFormat from run specified by iDirection, that is, use run
 *		valid up to, at, or starting at this GetCp() for iDirection less, =,
 *		or greater than 0, respectively.
 *	
 *	@rdesc
 *		TRUE iff any part of this range is protected (HACK:  or if any part
 *		of the range contains DBCS text stored in our Unicode backing store
 *		For this to work correctly, GetCharFormat() needs to return dwMask2
 *		as well).
 */
PROTECT CTxtRange::IsProtected (
	CHECKPROTECT chkprot)	//@parm Controls which run to check if range is IP
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::IsProtected");

	CCharFormat	CF;
	BOOL		fTOM = FALSE;
	LONG		iFormat = -1;					// Default default CF

	_TEST_INVARIANT_

	if(chkprot == CHKPROT_TOM)
	{
		fTOM = TRUE;
		chkprot = CHKPROT_EITHER;
	}
	if(_rpCF.IsValid())							// Active rich-text runs
	{
		if(_cch)								// Range is nondegenerate
		{
			DWORD dwMask = GetCharFormat(&CF);
			if(CF._dwEffects & CFE_RUNISDBCS)
				return PROTECTED_YES;

			if (!(dwMask & CFM_PROTECTED) ||
				(CF._dwEffects & CFE_PROTECTED))
			{
				return PROTECTED_ASK;
			}
			return PROTECTED_NO;
		}
		iFormat = _iFormat;						// Degenerate range: default
		if(chkprot != CHKPROT_EITHER)			//  this range's iFormat
		{										// Specific run direction
			CFormatRunPtr rpCF(_rpCF);

			if(chkprot == CHKPROT_BACKWARD)		// If at run ambiguous pos,
				rpCF.AdjustBackward();			//  use previous run
			else
				rpCF.AdjustForward();

			iFormat = rpCF.GetFormat();			// Get run format
		}
	}
	
	const CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);

	if(pCF->_dwEffects & CFE_RUNISDBCS)
		return PROTECTED_YES;

	if(!fTOM && !(pCF->_dwEffects & CFE_PROTECTED))
		return PROTECTED_NO;

	if(!_cch && chkprot == CHKPROT_EITHER)		// If insertion point and
	{											//  no directionality, return
		CFormatRunPtr rpCF(_rpCF);				//  PROTECTED_NO if either
		rpCF.AdjustBackward();					//  forward or previous run is
		pCF = GetPed()->GetCharFormat(rpCF.GetFormat());//  unprotected
		if(!(pCF->_dwEffects & CFE_PROTECTED))
 			return PROTECTED_NO;
		rpCF.AdjustForward();
		pCF = GetPed()->GetCharFormat(rpCF.GetFormat());
	}
	return (pCF->_dwEffects & CFE_PROTECTED) ? PROTECTED_ASK : PROTECTED_NO;
}

/*
 *	CTxtRange::AdjustEndEOP (NewChars)
 *
 *	@mfunc
 *		If this range is a selection and ends with an EOP and consists of
 *		more than just this EOP and fAdd is TRUE, or this EOP is the final
 *		EOP (at the story end), or this selection doesn't begin at the start
 *		of a paragraph, then move cpMost just before the end EOP. This
 *		function is used by UI methods that delete the selected text, such
 *		as PutChar(), Delete(), cut/paste, drag/drop.
 *
 *	@rdesc
 *		TRUE iff range end has been adjusted
 *
 *	@devnote
 *		This method leaves the active end at the selection cpMin.  It is a
 *		CTxtRange method to handle the selection when it mascarades as a
 *		range for Cut/Paste.
 */
BOOL CTxtRange::AdjustEndEOP (
	EOPADJUST NewChars)			//@parm NEWCHARS if chars will be added
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::AdjustEndEOP");

	LONG cpMin, cpMost;
	LONG cch = GetRange(cpMin, cpMost);
	LONG cchSave = _cch;
	BOOL fRet = FALSE;

	if(cch && (cch < GetTextLength() || NewChars == NEWCHARS))
	{
		CTxtPtr tp(_rpTX);
		if(_cch > 0)							// Ensure active end is cpMin
			FlipRange();						// (ReplaceRange() needs to
		else									//  do this anyhow)
			tp.Move(-_cch);						// Ensure tp is at cpMost

		LONG cchEOP = -tp.BackupCRLF();
			  
		if (IsASCIIEOP(tp.GetChar()) &&			// Don't delete EOP	at sel
			!tp.IsAtTRD(ENDFIELD) &&			//  end if EOP isn't end of
			(NewChars == NEWCHARS ||			//  table row and if there're
			 cpMin && !_rpTX.IsAfterEOP() &&	//  chars to add, or cpMin
			  cch > cchEOP))					//  isn't at BOD and more than
		{										//  EOP is selected
			_cch += cchEOP;						// Shorten range before EOP
			Update_iFormat(-1);					//  negative _cch to make
			fRet = TRUE;						//  it less negative
		}
		if((_cch ^ cchSave) < 0 && _fSel)		// Keep active end the same
			FlipRange();						//  for selection undo
	}
	return fRet;
}

/*
 *	CTxtRange::DeleteTerminatingEOP (publdr)
 *
 *	@mfunc
 *		If this range is an insertion point that follows an EOP, select
 *		and delete that EOP
 */
void CTxtRange::DeleteTerminatingEOP(
	IUndoBuilder *publdr)
{
	Assert(!_cch);
	if(_rpTX.IsAfterEOP())
	{								
		BackupCRLF(CSC_NORMAL, TRUE);
		if(IN_RANGE(STARTFIELD, CRchTxtPtr::GetChar(), ENDFIELD))
			AdvanceCRLF(CSC_NORMAL, TRUE);	// Leave range the way it was
		else
			ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL, RR_NO_LP_CHECK);
	}
}

/*
 *	CTxtRange::CheckTextLength(cch)
 *
 *	@mfunc
 *		Check to see if can add cch characters. If not, notify parent
 *
 *	@rdesc
 *		TRUE if OK to add cch chars
 */
BOOL CTxtRange::CheckTextLength (
	LONG cch,
	LONG *pcch)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CheckTextLength");

	_TEST_INVARIANT_
	
	DWORD cchNew = (DWORD)(CalcTextLenNotInRange() + cch);

	if(cchNew > GetPed()->TxGetMaxLength())
	{		
		if (pcch)
			*pcch = cchNew - GetPed()->TxGetMaxLength();
		else
			GetPed()->GetCallMgr()->SetMaxText();

		return FALSE;
	}
	return TRUE;
}

/*
 *	CTxtRange::InsertTableRow(pPF, publdr)
 *
 *	@mfunc
 *		Insert empty table row with parameters given by pPF
 *
 *	@rdesc
 *		Count of CELL and NOTACHAR chars inserted if successful; else 0
 */
LONG CTxtRange::InsertTableRow(
	const CParaFormat *pPF,	//@parm CParaFormat to use for delimiters
	IUndoBuilder *publdr)	//@parm If non-NULL, where to put anti-events
{
	AssertSz(pPF->_bTabCount && pPF->IsTableRowDelimiter(),
		"CTxtRange::InsertTableRow: illegal pPF");
	AssertSz(!_cch, "CTxtRange::InsertTableRow: nondegenerate range");

	if(GetPed()->TxGetPasswordChar())		// Tsk, tsk, no inserting tables
		return 0;							//  into password controls

	LONG	cCell = pPF->_bTabCount;
	LONG	cchCells = cCell;
	LONG	dul = 0;
	BOOL	fIsAtTRED = _rpTX.IsAtTRD(ENDFIELD);
	WCHAR	szBlankRow[2*MAX_TABLE_CELLS + 6] = {CR, STARTFIELD, CR};
	WCHAR *	pch = szBlankRow + 3;
	CFreezeDisplay	 fd(GetPed()->_pdp);
	CParaFormat PF1 = *pPF;				// Save *pPF, since may move
	const CELLPARMS *prgCellParms = PF1.GetCellParms();
										//  due to 
	// Get cell info on preceding row
	const CELLPARMS *prgCellParmsPrev = NULL;
	LONG	cCellPrev;

	if(fIsAtTRED)
	{
		prgCellParmsPrev = prgCellParms;// Same CParaFormat
		cCellPrev = pPF->_bTabCount;
	}
	else
	{
		_rpPF.AdjustBackward();
		const CParaFormat *pPFPrev = GetPF();
		cCellPrev = pPFPrev->_bTabCount;
		_rpPF.AdjustForward();
		if (GetCp() && pPFPrev->IsTableRowDelimiter() &&
			pPFPrev->_bTableLevel == pPF->_bTableLevel)
		{
			prgCellParmsPrev = pPFPrev->GetCellParms();
		}
	}

	// Define plain text for row (CELLs, NOTACHARs, TRDs)
	for(LONG i = 0; i < cCell; i++)
	{
		LONG uCell = prgCellParms[i].uCell;
		dul += GetCellWidth(uCell);
		if(IsLowCell(uCell))
		{
			if(!prgCellParmsPrev)		// No previous row, so cell can't
				return 0;				//  be merged with one above
			
			LONG iCell = prgCellParmsPrev->ICellFromUCell(dul, cCellPrev);
			if(iCell < 0 || !IsVertMergedCell(prgCellParmsPrev[iCell].uCell))
				return 0;

			*pch++ = NOTACHAR;
			cchCells++;					// Add in extra char
		}
		*pch++ = CELL;
	}
	*pch++ = ENDFIELD;
	*pch++ = CR;

	LONG cch = cchCells + 5;			// cch to insert
	pch = szBlankRow;
	if(!GetCp() || _rpTX.IsAfterEOP())	// New row follows CR, so don't
	{									//  need to insert a leading CR
		pch++;
		cch--;
		if(GetCp())						// Still need to unhide CR if it's
		{								//  hidden
			_rpCF.AdjustBackward();
			const CCharFormat *pCF = GetCF();
			_rpCF.AdjustForward();
			if(pCF->_dwEffects & CFE_HIDDEN)
			{
				CTxtPtr tp(_rpTX);
				CCharFormat CF = *pCF;
				CF._dwEffects = 0;		// Turn off hidden
				_cch = -tp.BackupCRLF(FALSE);
				SetCharFormat(&CF, 0, publdr, CFM_HIDDEN, 0);
				_cch = 0;
			}
		}
	}
	if(_cch || !CheckTextLength(cch))	// If nondegen or empty row can't
		return 0;						//  fit, fail call
										
	if(publdr)
		publdr->StopGroupTyping();

	if(fIsAtTRED)						// Don't insert new table between
		AdvanceCRLF(CSC_NORMAL, FALSE);	//  final CELL and table-row end
										//  delimiter
	if(_rpTX.IsAfterTRD(ENDFIELD))
	{
		_rpCF.AdjustBackward();			// Use CF of TR end delimiter
		Set_iCF(_rpCF.GetFormat());
	}

	ReplaceRange(cch, pch, publdr, SELRR_REMEMBERRANGE, NULL, RR_UNHIDE);
	_cch = 2;							// Select row end marker
	SetParaFormat(&PF1, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);

	CParaFormat PF;						// Create PF for cell markers
	PF = *(GetPed()->GetParaFormat(-1));//  and possible lead CR
	PF._wEffects |= PFE_TABLE;
	PF._bTableLevel = pPF->_bTableLevel;
	AssertSz(PF._bTableLevel > 0, "CTxtRange::InsertTableRow: invalid table level");

	Set(GetCp() - 2, cchCells);			// Select cell markers
	SetParaFormat(&PF, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);

	Set(GetCp() - cchCells, 2);			// Select row start marker 
	SetParaFormat(&PF1, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);

	if(pch == szBlankRow)
	{
		Set(GetCp() - 2, 1);			// Select lead CR
		PF._bTableLevel--;
		if(!PF._bTableLevel)
			PF._wEffects &= ~PFE_TABLE;
		AssertSz(PF._bTableLevel >= 0, "CTxtRange::InsertTableRow: invalid table level");
		SetParaFormat(&PF, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);
		Move(2, FALSE);
	}
	Collapser(FALSE);					// Leave in first cell of new row
	_fMoveBack = FALSE;
	Update(TRUE);
	return cchCells;
}

/*
 *	CTxtRange::FindObject(pcpMin, pcpMost)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest embedded object cpMin <lt>= range cpMin
 *		Set *pcpMost = closest embedded object cpMost <gt>= range cpMost
 *
 *	@rdesc
 *		TRUE iff object found
 *
 *	@comm
 *		An embedded object cpMin points at the first character of an embedded
 *		object. For RichEdit, this is the WCH_EMBEDDING character.  An
 *		embedded object cpMost follows the last character of an embedded
 *		object.  For RichEdit, this immediately follows the WCH_EMBEDDING
 *		character.
 */
BOOL CTxtRange::FindObject(
	LONG *pcpMin,		//@parm Out parm to receive object's cpMin;  NULL OK
	LONG *pcpMost) const//@parm Out parm to receive object's cpMost; NULL OK
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindObject");

	if(!GetObjectCount())					// No objects: can't move, so
		return FALSE;						//  return FALSE

	BOOL	bRet = FALSE;					// Default no object
	LONG	cpMin, cpMost;
	CTxtPtr tp(_rpTX);

	GetRange(cpMin, cpMost);
	if(pcpMin)
	{
		tp.SetCp(cpMin);
		if(tp.GetChar() != WCH_EMBEDDING)
		{
			cpMin = tp.FindExact(tomBackward, szEmbedding);
			if(cpMin >= 0)
			{
				bRet = TRUE;
				*pcpMin = cpMin;
			}
		}
	}
	if(pcpMost)
	{
		tp.SetCp(cpMost);
		if (tp.PrevChar() != WCH_EMBEDDING &&
			tp.FindExact(tomForward, szEmbedding) >= 0)
		{
			bRet = TRUE;
			*pcpMost = tp.GetCp();
		}
	}
	return bRet;
}

/*
 *	CTxtRange::FindCell(pcpMin, pcpMost)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest cell cpMin  <lt>= range cpMin (see comment)
 *		Set *pcpMost = closest cell cpMost <gt>= range cpMost
 *	
 *	@comment
 *		This function returns range cpMin and cpMost if the range isn't
 *		completely in a table or if the range already selects one or more
 *		cells at the same table level.
 */
void CTxtRange::FindCell (
	LONG *pcpMin,			//@parm Out parm for bounding-cell cpMin
	LONG *pcpMost) const	//@parm Out parm for bounding-cell cpMost
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindCell");

	LONG		cch;
	LONG		cpMin, cpMost;
	LONG		Results;
	CPFRunPtr	rp(*this);
	LONG		Level = rp.GetMinTableLevel(_cch);
	CTxtPtr		tp(_rpTX);

	_TEST_INVARIANT_

	GetRange(cpMin, cpMost);
	LONG cp = cpMin;

	if(Level)
	{
		tp.SetCp(cpMin);
		if(tp.IsAtTRD(STARTFIELD) && rp.GetTableLevel() == Level)
			Level--;
	}

	if(pcpMin)
	{
		if(Level && rp.InTable())
		{
			rp.AdjustBackward();
			while(rp.GetTableLevel() >= Level && tp.GetCp())
			{
				if(tp.IsAtStartOfCell() && rp.GetTableLevel() <= Level)
					break;
				while(1)						// Ensure at correct table level
				{
					rp.AdjustBackward();
					if(rp.GetTableLevel() <= Level)
						break;
					tp.Move(-rp.GetIch());		// Bypass paraformat runs back 
					rp.SetIch(0);				//  to desired level
				}
				if(tp.IsAfterTRD(STARTFIELD))
					break;
				cch = tp.FindEOP(tomBackward, &Results);
				if(!cch)
					break;
				rp.Move(cch);					// Keep rp in sync with tp
			}									
			cp = tp.GetCp();
		}
		*pcpMin = cp;
	}

	if(pcpMost)
	{
		rp.Move(cpMost - cp);
		tp.SetCp(cpMost);
		if(Level && rp.InTable())
		{
			if(pcpMin && !_cch && *pcpMin == cpMost)
				rp.Move(tp.FindEOP(tomForward, &Results));

			while(rp.GetTableLevel() >= Level)
			{
				if(tp.GetPrevChar() == CELL)
				{
					rp.AdjustBackward();
					if(rp.GetTableLevel() == Level)
						break;
				}
				do								// Ensure at correct table level
				{
					if(rp.GetTableLevel() <= Level)
						break;
					tp.Move(rp.GetCchLeft());	// Bypass paraformats up to
				} while(rp.NextRun());			//  desired level
				cch = tp.FindEOP(tomForward, &Results);
				if(!cch)
					break;
				rp.Move(cch);					// Keep rp in sync with tp
			}
		}
		*pcpMost = tp.GetCp();
	}
}

/*
 *	CTxtRange::FindRow(pcpMin, pcpMost, Level)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest row cpMin  <lt>= range cpMin.
 *		Set *pcpMost = closest row cpMost <gt>= range cpMost.
 *		In both cases the row(s) chosen correspond to the 
 *		table level of range.
 */
void CTxtRange::FindRow (
	LONG *pcpMin,			//@parm Out parm for bounding-row cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-row cpMost
	LONG Level) const		//@parm Table row level to expand to
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindRow");

	_TEST_INVARIANT_

	LONG	  cchAdjText = GetAdjustedTextLength();
	WCHAR	  ch;
	LONG	  cpMin, cpMost;
	CPFRunPtr rp(*this);
	CTxtPtr	  tp(_rpTX);						
	const CParaFormat *pPF;					 
											   
	if(Level < 0)								// Get range min Level
		Level = rp.GetMinTableLevel(_cch);		//  and move rp to cpMin
	else if(_cch > 0)
		rp.Move(-_cch);

	GetRange(cpMin, cpMost);

	LONG cp = cpMin;

	if(pcpMin)
	{
		while(1)
		{
			pPF = rp.GetPF();
			if(pPF->_bTableLevel < Level || !pPF->_bTableLevel)
				break;
			cp -= rp.GetIch();				// Go to start of PF run
			rp.SetIch(0);
			if(pPF->IsTableRowDelimiter())
			{
				LONG cchMove = 0;
				if(rp.GetCchLeft() == 4 && cp <= cpMin - 2)
					cchMove = 2;			// For end-start pair, setup to
											//  advance to start
				tp.SetCp(cp);				// Update tp to get char
				ch = tp.GetChar();
				if(ch == STARTFIELD || cchMove)
				{
					AssertSz(!cchMove || ch == ENDFIELD, "CTxtRange::FindRow: illegal table row"); 

					if(Level == pPF->_bTableLevel)
					{
						if(cchMove)
						{
							cp += cchMove;
							rp.Move(cchMove);
						}
						break;
					}
				}
			}
			if(!rp.PrevRun())				// Go to previous run if there is one
			{
				AssertSz(!cp && !Level, "CTxtRange::FindRow: badly formed table");
				break;
			}
			cp -= rp.GetCchLeft();
		}
		*pcpMin = cp;
	}
	if(pcpMost)
	{
		rp.Move(cpMost - cp);				// Advance to cpMost of range
		Assert(!rp.IsValid() || (cp = rp.CalculateCp()) == cpMost);
		cp = cpMost;
		rp.AdjustBackward();				// If cpMost directly follows
		if(rp.IsTableRowDelimiter())		//  row-end delimiter, backup over
		{									//  it to catch case when range
			tp.SetCp(cp);					//  already selects a row
			if(tp.GetChar() == CR)			// In middle of TR delimiter
			{								//  so move to its start
				cp--;						
				rp.Move(-1);
			}
			else if(abs(_cch) > 2 && tp.IsAfterTRD(ENDFIELD))
			{
				cp -= 2;					
				rp.Move(-2);
			}
		}
		rp.AdjustForward();
		while(cp < cchAdjText)
		{
			pPF = rp.GetPF();
			if(pPF->_bTableLevel < Level || !pPF->_bTableLevel)
				break;
			if(pPF->IsTableRowDelimiter())
			{
				tp.SetCp(cp);
				ch = tp.GetChar();
				if(ch == ENDFIELD && Level == pPF->_bTableLevel)
				{
					cp += tp.AdvanceCRLF(FALSE);// Bypass row end delimiter
					break;
				}
			}
			cp += rp.GetCchLeft();
			if(!rp.NextRun())
				break;
		}
		*pcpMost = cp;
	}
}

/*
 *	CTxtRange::FindParagraph(pcpMin, pcpMost)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest paragraph cpMin  <lt>= range cpMin (see comment)
 *		Set *pcpMost = closest paragraph cpMost <gt>= range cpMost
 *	
 *	@devnote
 *		If this range's cpMost follows an EOP, use it for bounding-paragraph
 *		cpMost unless 1) the range is an insertion point, and 2) pcpMin and
 *		pcpMost are both nonzero, in which case use the next EOP.  Both out
 *		parameters are nonzero if FindParagraph() is used to expand to full
 *		paragraphs (else StartOf or EndOf is all that's requested).  This
 *		behavior is consistent with the selection/IP UI.  Note that FindEOP
 *		treats the beginning/end of document (BOD/EOD) as a BOP/EOP,
 *		respectively, but IsAfterEOP() does not.
 */
void CTxtRange::FindParagraph (
	LONG *pcpMin,			//@parm Out parm for bounding-paragraph cpMin
	LONG *pcpMost) const	//@parm Out parm for bounding-paragraph cpMost
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindParagraph");

	LONG	cpMin, cpMost;
	CTxtPtr	tp(_rpTX);

	_TEST_INVARIANT_

	GetRange(cpMin, cpMost);
	if(pcpMin)
	{
		tp.SetCp(cpMin);					// tp points at this range's cpMin
		if(!tp.IsAfterEOP())				// Unless tp directly follows an
			tp.FindEOP(tomBackward);		//  EOP, search backward for EOP
		*pcpMin = cpMin = tp.GetCp();
	}

	if(pcpMost)
	{
		tp.SetCp(cpMost);					// If range cpMost doesn't follow
		if (!tp.IsAfterEOP() ||				//  an EOP or else if expanding
			(!cpMost || pcpMin) &&
			 cpMin == cpMost)				//  IP at paragraph beginning,
		{
			tp.FindEOP(tomForward);			//  search for next EOP
		}
		*pcpMost = tp.GetCp();
	}
}

/*
 *	CTxtRange::FindSentence(pcpMin, pcpMost)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest sentence cpMin  <lt>= range cpMin
 *		Set *pcpMost = closest sentence cpMost <gt>= range cpMost
 *	
 *	@devnote
 *		If this range's cpMost follows a sentence end, use it for bounding-
 *		sentence cpMost unless the range is an insertion point, in which case
 *		use the	next sentence end.  The routine takes care of aligning on
 *		sentence beginnings in the case of range ends that fall on whitespace
 *		in between sentences.
 */
void CTxtRange::FindSentence (
	LONG *pcpMin,			//@parm Out parm for bounding-sentence cpMin
	LONG *pcpMost) const	//@parm Out parm for bounding-sentence cpMost
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindSentence");

	LONG	cpMin, cpMost;
	CTxtPtr	tp(_rpTX);

	_TEST_INVARIANT_

	GetRange(cpMin, cpMost);
	if(pcpMin)								// Find sentence beginning
	{
		tp.SetCp(cpMin);					// tp points at this range's cpMin
		if(!tp.IsAtBOSentence())			// If not at beginning of sentence
			tp.FindBOSentence(tomBackward);	//  search backward for one
		*pcpMin = cpMin = tp.GetCp();
	}

	if(pcpMost)								// Find sentence end
	{										// Point tp at this range's cpLim
		tp.SetCp(cpMost);					// If cpMost isn't at sentence
		if (!tp.IsAtBOSentence() ||			//  beginning or if at story
			(!cpMost || pcpMin) &&			//  beginning or expanding
			 cpMin == cpMost)				//  IP at sentence beginning,
		{									//  find next sentence beginning
			if(!tp.FindBOSentence(tomForward))
				tp.SetCp(GetTextLength());	// End of story counts as
		}									//  sentence end too
		*pcpMost = tp.GetCp();
	}
}

/*
 *	CTxtRange::FindVisibleRange(pcpMin, pcpMost)
 *	
 *	@mfunc
 *		Set *pcpMin  = _pdp->_cpFirstVisible
 *		Set *pcpMost = _pdp->_cpLastVisible
 *	
 *	@rdesc
 *		TRUE iff calculated cp's differ from this range's cp's
 *	
 *	@devnote
 *		CDisplay::GetFirstVisible() and GetCliVisible() return the first cp
 *		on the first visible line and the last cp on the last visible line.
 *		These won't be visible if they are scrolled off the screen.
 *		FUTURE: A more general algorithm would CpFromPoint (0,0) and
 *		(right, bottom).
 */
BOOL CTxtRange::FindVisibleRange (
	LONG *pcpMin,			//@parm Out parm for cpFirstVisible
	LONG *pcpMost) const	//@parm Out parm for cpLastVisible
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindVisibleRange");

	_TEST_INVARIANT_

	CDisplay *	pdp = GetPed()->_pdp;

	if(!pdp)
		return FALSE;

	if(pcpMin)
		*pcpMin = pdp->GetFirstVisibleCp();

	pdp->GetCliVisible(pcpMost);

	return TRUE;
}

/*
 *	CTxtRange::FindWord(pcpMin, pcpMost, type)
 *	
 *	@mfunc
 *		Set *pcpMin  = closest word cpMin  <lt>= range cpMin
 *		Set *pcpMost = closest word cpMost <gt>= range cpMost
 *
 *	@comm
 *		There are two interesting cases for finding a word.  The first,
 *		(FW_EXACT) finds the exact word, with no extraneous characters.
 *		This is useful for situations like applying formatting to a
 *		word.  The second case, FW_INCLUDE_TRAILING_WHITESPACE does the
 *		obvious thing, namely includes the whitespace up to the next word.
 *		This is useful for the selection double-click semantics and TOM.
 */
void CTxtRange::FindWord(
	LONG *pcpMin,			//@parm Out parm to receive word's cpMin; NULL OK
	LONG *pcpMost,			//@parm Out parm to receive word's cpMost; NULL OK
	FINDWORD_TYPE type) const //@parm Type of word to find
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindWord");

	LONG	cch, cch1;
	LONG	cpMin, cpMost;
	CTxtPtr	tp(_rpTX);

	_TEST_INVARIANT_

	Assert(type == FW_EXACT || type == FW_INCLUDE_TRAILING_WHITESPACE );

	GetRange(cpMin, cpMost);
	if(pcpMin)
	{
		tp.SetCp(cpMin);
		if(!tp.IsAtBOWord())							// cpMin not at BOW:
			cpMin += tp.FindWordBreak(WB_MOVEWORDLEFT);	//  go there

		*pcpMin = cpMin;

		Assert(cpMin >= 0 && cpMin <= GetTextLength());
	}

	if(pcpMost)
	{
		tp.SetCp(cpMost);
		if (!tp.IsAtBOWord() ||							// If not at word strt
			(!cpMost || pcpMin) && cpMin == cpMost)		//  or there but need
		{												//  to expand IP,
			cch = tp.FindWordBreak(WB_MOVEWORDRIGHT);	//  move to next word

			if(cch && type == FW_EXACT)					// If moved and want
			{											//  word proper, move
				cch1 = tp.FindWordBreak(WB_LEFTBREAK);	//  back to end of
				if(cch + cch1 > 0)						//  preceding word
					cch += cch1;						// Only do so if were
			}											//  not already at end
			cpMost += cch;
		}
		*pcpMost = cpMost;

		Assert(cpMost >= 0 && cpMost <= GetTextLength());
		Assert(cpMin <= cpMost);
	}
}

/*
 *	CTxtRange::FindAttributes(pcpMin, pcpMost, dwMask)
 *
 *	@mfunc	
 *		Set *pcpMin  = closest attribute-combo cpMin  <lt>= range cpMin
 *		Set *pcpMost = closest attribute-combo cpMost <gt>= range cpMost
 *		The attribute combo is given by Unit and is any OR combination of
 *		TOM attributes, e.g., tomBold, tomItalic, or things like
 *		tomBold | tomItalic.  The combo is found if any of the attributes
 *		is present.
 *
 *	@devnote
 *		Plan to add other logical combinations: tomAND, tomExact
 */
void CTxtRange::FindAttributes (
	LONG *pcpMin,			//@parm Out parm for bounding-sentence cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-sentence cpMost
	LONG Unit) const		//@parm TOM attribute mask
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FindAttributes");
	LONG		cch;
	LONG		cpMin, cpMost;
	DWORD		dwMask = Unit & ~0x80000000;	// Kill sign bit
	CCFRunPtr	rp(*this);

	Assert(Unit < 0);
	GetRange(cpMin, cpMost);

	if(!rp.IsValid())						// No CF runs instantiated
	{
		if(rp.IsMask(dwMask))				// Applies to default CF
		{
			if(pcpMin)
				*pcpMin = 0;
			if(pcpMost)
				*pcpMost = GetTextLength();
		}
		return;
	}

	// Start at cpMin
	if(_cch > 0)
		rp.Move(-_cch);

	// Go backward until we don't match dwMask
	if(pcpMin)
	{
		rp.AdjustBackward();
		while(rp.IsMask(dwMask) && rp.GetIch())
		{
			cpMin -= rp.GetIch();
			rp.Move(-rp.GetIch());
			rp.AdjustBackward();
		}
		*pcpMin = cpMin;
	}

	// Now go forward from cpMost until we don't match dwMask
	if(pcpMost)
	{
		rp.Move(cpMost - cpMin);
		rp.AdjustForward();					// In case cpMin = cpMost
		cch = rp.GetCchLeft();
		while(rp.IsMask(dwMask) && cch)
		{
			cpMost += cch;
			rp.Move(cch);
			cch = rp.GetCchLeft();
		}
		*pcpMost = cpMost;
	}
}

/*
 *	CTxtRange::CountCells(cCell, cchMax)
 *
 *	@mfunc	
 *		Count characters up to <p cRun> cells away or <p cchMax> chars,
 *		whichever comes first. Helper function for CRchTxtPtr::UnitCounter().
 *		
 *	@rdesc
 *		Return the signed cch counted and set <p cRun> equal to count of cells
 *		actually counted. 
 */
LONG CTxtRange::CountCells (
	LONG &	cCell,		//@parm Count of cells to get cch for
	LONG	cchMax) 	//@parm Maximum char count
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtRange::CountCells");

	LONG cch = 0;
	LONG cpSave = GetCp();
	LONG cp;
	LONG j = cCell;

	Assert(!_cch);

	while(j && cch < cchMax && InTable())
	{
		if(cCell > 0)						// Move forward
		{
			if(GetPrevChar() == CELL)
				Move(1, FALSE);
			FindCell(NULL, &cp);			// Find cp at end of cell
			j--;
			cch = cp - cpSave;
		}
		else								// Move backward
		{
			if(_rpTX.IsAtStartOfCell())
			{
				if(GetPrevChar() == CELL)
					Move(-1, FALSE);		// Backup in front of CELL
				else
				{
					Move(-2, FALSE);		// Backup in front of TRD
					if(!_rpTX.IsAfterTRD(ENDFIELD))
					{
						Move(2, FALSE);		// At start of table: restore
						break;				//  position and quit
					}
					Move(-3, FALSE);		// Backup before CELL TRD
				}
			}
			FindCell(&cp, NULL);			// Find cp at start of cell
			j++;
			cch = cpSave - cp;
		}
		SetCp(cp, FALSE);					// Move to cell start/end
	}
	cCell -= j;								// Subtract any cells not bypassed
	return GetCp() - cpSave;			
}

/*
 *	CTxtRange::CalcTextLenNotInRange()
 *	
 *	@mfunc
 *		Helper function that calculates the total length of text
 *		excluding the current range.
 *
 *	@comm
 *		Used for limit testing. The problem being solved is that
 *		the range can contain the final EOP which is not included
 *		in the adjusted text length.
 */
LONG CTxtRange::CalcTextLenNotInRange()
{
	LONG	cchAdjLen = GetPed()->GetAdjustedTextLength();
	LONG	cchLen = cchAdjLen - abs(_cch);
	LONG	cpMost = GetCpMost();

	if (cpMost > cchAdjLen)
	{
		// Selection extends beyond adjusted length. Put amount back in the
		// selection as it has become too small by the difference.
		cchLen += cpMost - cchAdjLen;
	}
	return cchLen;
}

////////////////////////// Outline Support //////////////////////////////////

/*
 *	CTxtRange::Promote(lparam, publdr)
 *
 *	@mfunc
 *		Promote selected text according to:
 *
 *		LOWORD(lparam) == 0 ==> promote to body-text
 *		LOWORD(lparam) != 0 ==> promote/demote current selection by
 *								LOWORD(lparam) levels
 *	@rdesc
 *		TRUE iff promotion occurred
 *
 *	@devnote
 *		Changes this range
 */
HRESULT CTxtRange::Promote (
	LPARAM		  lparam,	//@parm 0 to body, < 0 demote, > 0 promote
	IUndoBuilder *publdr)	//@parm undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::Promote");

	if(abs(lparam) >= NHSTYLES)
		return E_INVALIDARG;

	if(publdr)
		publdr->StopGroupTyping();

	if(_cch > 0)							// Point at cpMin
		FlipRange();

	LONG		cchText = GetTextLength();
	LONG		cpEnd = GetCpMost();
	LONG		cpMin, cpMost;
	BOOL		fHeading = TRUE;			// Default heading in range
	HRESULT		hr;
	LONG		Level;
	LONG		nHeading = NHSTYLES;		// Setup to find any heading
	CParaFormat PF;
	const CParaFormat *pPF;
	CPFRunPtr	rp(*this);
	LONG		cch = rp.FindHeading(abs(_cch), nHeading);
	WORD		wEffects;

	if(!lparam)								// Demote to subtext
	{
		if(cch)								// Already in subtext so don't
			return S_FALSE;					//  need to demote

		CTxtPtr tp(_rpTX);

		if(!tp.IsAfterEOP())
			cch = tp.FindEOP(tomBackward);
		nHeading = 1;
		if(tp.GetCp())						// Get previous level and convert
		{									//  to heading to set up
			rp.Move(cch);					//  following Level code
			rp.AdjustBackward();
			nHeading = rp.GetOutlineLevel()/2 + 1;
		}
	}
	else if(cch == tomBackward)				// No heading in range					
	{										// Set up to promote to
		nHeading = rp.GetOutlineLevel()/2	//  heading
				 + (lparam > 0 ? 2 : 1);
		fHeading = FALSE;					// Signal no heading in range
	}
	else if(cch)							// Range starts in subtext
		Move(cch, TRUE);					// Bypass initial nonheading

	Level = 2*(nHeading - 1);				// Heading level
	PF._bOutlineLevel = (BYTE)(Level | 1);	// Corresponding subtext level

	if (!Level && lparam > 0 ||				// Can't promote Heading 1
		nHeading == NHSTYLES && lparam < 0)	//  or demote Heading 9
	{										
		return S_FALSE;
	}
	do									
	{
		_cch = 0;
		Level -= long(2*lparam);			// Promote Level
		pPF = GetPF();
		wEffects = pPF->_wEffects;
		if(pPF->_bOutlineLevel & 1)			// Handle contiguous text in
		{									//  one fell swoop
			cch = fHeading ? _rpPF.GetCchLeft() : cpEnd - GetCp();
			if(cch > 0)
				Move(cch, TRUE);
		}
		Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);

		if((unsigned)Level < 2*NHSTYLES)
		{									// Promoted Level is valid
			DWORD dwMask = PFM_OUTLINELEVEL;// Default setting subtext level
			if(!(Level & 1) && lparam)		// Promoting or demoting heading
			{								// Preserve collapse status
				PF._wEffects = Level ? wEffects : 0; // H1 is aways expanded		
				PF._sStyle = (SHORT)(-Level/2 + STYLE_HEADING_1);
				PF._bOutlineLevel = (BYTE)(Level | 1);// Set up subtext
				dwMask = PFM_STYLE + PFM_COLLAPSED;
			}
			else if(!lparam)				// Changing heading to subtext
			{								//  or uncollapsing subtext
				PF._wEffects = 0;			// Turn off collapsed
				PF._sStyle = STYLE_NORMAL;
				dwMask = PFM_STYLE + PFM_OUTLINELEVEL + PFM_COLLAPSED;
			}
			hr = SetParaStyle(&PF, publdr, dwMask);
			if(hr != NOERROR)
				return hr;
		}
		if(GetCp() >= cchText)				// Have handled last PF run
			break;
		Assert(_cch > 0);					// Para/run should be selected
		pPF = GetPF();						// Points at next para
		Level = pPF->_bOutlineLevel;
	}										// Iterate until past range &
	while((Level & 1) || fHeading &&		// any subtext that follows
		  (GetCp() < cpEnd || pPF->_wEffects & PFE_COLLAPSED));

	return NOERROR;
}

/*
 *	CTxtRange::ExpandOutline(Level, fWholeDocument)
 *
 *	@mfunc
 *		Expand outline according to Level and fWholeDocument. Wraps
 *		OutlineExpander() helper function and updates selection/view
 *
 *	@rdesc
 *		NOERROR if success
 */
HRESULT CTxtRange::ExpandOutline(
	LONG Level,				//@parm If < 0, collapse; else expand, etc.
	BOOL fWholeDocument)	//@parm If TRUE, whole document
{
	if (!IsInOutlineView())
		return NOERROR;

	HRESULT hres = OutlineExpander(Level, fWholeDocument);
	if(hres != NOERROR)
		return hres;

	GetPed()->TxNotify(EN_PARAGRAPHEXPANDED, NULL);
	return GetPed()->UpdateOutline();
}

/*
 *	CTxtRange::OutlineExpander(Level, fWholeDocument)
 *
 *	@mfunc	
 *		Expand/collapse outline for this range according to Level
 *		and fWholeDocument.  If fWholeDocument is TRUE, then
 *		1 <= Level <= NHSTYLES collapses all headings with numbers
 *		greater than Level and collapses all nonheadings. Level = -1
 *		expands all.
 *
 *		fWholeDocument = FALSE expands/collapses (Level > 0 or < 0)
 *		paragraphs depending on whether an EOP and heading are included
 *		in the range.  If Level = 0, toggle heading's collapsed status.
 *
 *	@rdesc
 *		(change made) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::OutlineExpander(
	LONG Level,				//@parm If < 0, collapse; else expand, etc.
	BOOL fWholeDocument)	//@parm If TRUE, whole document
{
	CParaFormat PF;

    if(fWholeDocument)							// Apply to whole document
	{
        if (IN_RANGE(1, Level, NHSTYLES) ||		// Collapse to heading
	        Level == -1)						// -1 means all
		{
			Set(0, tomBackward);				// Select whole document
			PF._sStyle = (SHORT)(STYLE_COMMAND + (BYTE)Level);
			SetParaFormat(&PF, NULL, PFM_STYLE, 0);// No undo
			return NOERROR;
		}
		return S_FALSE;							// Nothing happened (illegal
	}											//  arg)

	// Expand/Collapse for Level positive/negative, respectively

	LONG cpMin, cpMost;							// Get range cp's
	LONG cchMax = GetRange(cpMin, cpMost);
	if(_cch > 0)								// Ensure cpMin is active
		FlipRange();							//  for upcoming rp and tp

	LONG	  nHeading = NHSTYLES;				// Setup to find any heading
	LONG	  nHeading1;
	CTxtEdit *ped = GetPed();
	CPFRunPtr rp(*this);
	LONG	  cch = rp.FindHeading(cchMax, nHeading);

	if(cch == tomBackward)						// No heading found within range
		return S_FALSE;							// Do nothing

	Assert(cch <= cchMax && (Level || !cch));	// cch is count up to heading
	CTxtPtr tp(_rpTX);
	cpMin += cch;								// Bypass any nonheading text
	tp.Move(cch);								//  at start of range

	// If toggle collapse or if range contains an EOP,
	// collapse/expand all subordinates
	cch = tp.FindEOP(tomForward);				// Find next para
	if(!cch)
		return NOERROR;

    if(!Level || cch < -_cch)					// Level = 0 or EOP in range
	{
		if(!Level)								// Toggle collapse status
		{
			LONG cchLeft = rp.GetCchLeft();
			if (cch < cchLeft || !rp.NextRun() ||
				nHeading == STYLE_HEADING_1 - rp.GetStyle() + 1)
			{
				return NOERROR;					// Next para has same heading
			}
			Assert(cch == cchLeft);
			Level = rp.IsCollapsed();
			rp.Move(-cchLeft);
		}
		PF._wEffects = Level > 0 ? 0 : PFE_COLLAPSED;
		while(cpMin < cpMost)
		{										// We're at a heading
			tp.SetCp(cpMin);
			cch = tp.FindEOP(-_cch);
			cpMin += cch;						// Bypass it		
			if(!rp.Move(cch))					// Point at next para
				break;							// No more, we're done
			nHeading1 = nHeading;				// Setup to find heading <= nHeading
			cch = rp.FindHeading(tomForward, nHeading1);
			if(cch == tomBackward)				// No more higher headings
				cch = GetTextLength() - cpMin;	// Format to end of text
			Set(cpMin, -cch);					// Collapse/expand up to here
			SetParaFormat(&PF, NULL, PFM_COLLAPSED, 0);
			cpMin += cch;						// Move past formatted area
			nHeading = nHeading1;				// Update nHeading to possibly
		}										//  lower heading #
		return NOERROR;
	}

	// Range contains no EOP: expand/collapse deepest level.
	// If collapsing, collapse all nonheading text too. Expand
	// nonheading text only if all subordinate levels are expanded.
	BOOL	fCollapsed;
	LONG	nHeadStart, nHeadDeepNC, nHeadDeep;
	LONG	nNonHead = -1;						// No nonHeading found yet
	const CParaFormat *pPF;

	cpMin = tp.GetCp();							// Point at start of
	cpMost = cpMin;								//  next para
	pPF = ped->GetParaFormat(_rpPF.GetFormat());
	nHeading = pPF->_bOutlineLevel;

	Assert(!(nHeading & 1) &&					// Must start with a heading
		!(pPF->_wEffects & PFE_COLLAPSED));		//  that isn't collapsed

	nHeadStart = nHeading/2 + 1;				// Convert outline level to
	nHeadDeep = nHeadDeepNC = nHeadStart;		//  heading number

	while(cch)									// Determine deepest heading
	{											//  and deepest collapsed
		rp.Move(cch);							//  heading
		pPF = ped->GetParaFormat(rp.GetFormat());
		fCollapsed = pPF->_wEffects & PFE_COLLAPSED;
		nHeading = pPF->_bOutlineLevel;
		if(nHeading & 1)						// Text found
		{										// Set nNonHead > 0 if
			nNonHead = fCollapsed;				//  collapsed; else 0
			cch = rp.GetCchLeft();				// Zip to end of contiguous
			tp.Move(cch);						//  text paras
		}										
		else									// It's a heading
		{
			nHeading = nHeading/2 + 1;			// Convert to heading number
			if(nHeading <= nHeadStart)			// If same or shallower as
				break;							//  start heading we're done

			// Update deepest and deepest nonCollapsed heading #'s
			nHeadDeep = max(nHeadDeep, nHeading);
			if(!fCollapsed)						
				nHeadDeepNC = max(nHeadDeepNC, nHeading);
			cch = tp.FindEOP(tomForward);		// Go to next paragraph
		}				
		cpMost = tp.GetCp();					// Include up to it
	}

	PF._sStyle = (SHORT)(STYLE_COMMAND + nHeadDeepNC);
	if(Level > 0)								// Expand
	{
		if(nHeadDeepNC < nHeadDeep)				// At least one collapsed
			PF._sStyle++;						//  heading: expand shallowest
		else									// All heads expanded: do others
			PF._sStyle = (unsigned short) (STYLE_COMMAND + 0xFF);
	}											// In any case, expand nonheading
	else if(nNonHead)							// Collapse. If text collapsed
	{											//  or missing, do headings
		if(nHeadDeepNC == nHeadStart)
			return S_FALSE;						// Everything already collapsed
		PF._sStyle--;							// Collapse to next shallower
	}											//  heading

	Set(cpMin, cpMin - cpMost);					// Select range to change
	SetParaFormat(&PF, NULL, PFM_STYLE, 0);		// No undo
	return NOERROR;
}

/*
 *	CTxtRange::CheckOutlineLevel(publdr)
 *
 *	@mfunc	
 *		If the paragraph style at this range isn't a heading, make
 *		sure its outline level is compatible with the preceeding one
 */
void CTxtRange::CheckOutlineLevel(
	IUndoBuilder *publdr)		//@parm Undo context for this operation
{
	LONG	  LevelBackward, LevelForward;
	CPFRunPtr rp(*this);

	Assert(!_cch);

	rp.AdjustBackward();
	LevelBackward = rp.GetOutlineLevel() | 1;	// Nonheading level corresponding
												//  to previous PF run
	rp.AdjustForward();
	LevelForward = rp.GetOutlineLevel();

	if (!(LevelForward & 1) || 					// Any heading can follow
		LevelForward == LevelBackward)			//  any style. Also if
	{											//  forward level is correct,
		return;									//  return
	}

	LONG		cch;							// One or more nonheadings
	LONG		lHeading = NHSTYLES;			//  with incorrect outline
	CParaFormat PF;								//  levels follow

	PF._bOutlineLevel = (BYTE)LevelBackward;		//  level

	cch = rp.FindHeading(tomForward, lHeading);	// Find next heading
	if(cch == tomBackward)
		cch = tomForward;

	Set(GetCp(), -cch);							// Select all nonheading text
	SetParaFormat(&PF, publdr, PFM_OUTLINELEVEL, 0);// Change its outline level
	Set(GetCp(), 0);							// Restore range to IP
}

#if defined(DEBUG) && !defined(NOFULLDEBUG)
/*
 *	CTxtRange::::DebugFont (void)
 *
 *	@mfunc	
 *		Dump out the character and Font info for current selection.
 */
void CTxtRange::DebugFont (void)
{
	LONG			ch;
	LONG			cpMin, cpMost;
	LONG			cch = GetRange(cpMin, cpMost);
	LONG			i;
	char			szTempBuf[64];
	CTxtEdit		*ped = GetPed();
	const			WCHAR *wszFontname;
	const			CCharFormat	*CF;				// Temporary CF	
	const			WCHAR *GetFontName(LONG iFont);

	char			szTempPath[MAX_PATH] = "\0";
	DWORD			cchLength;
	HANDLE			hfileDump;
	DWORD			cbWritten;

	LONG			cchSave = _cch;					// Save this range's cch
	LONG			cpSave = GetCp();					//	and cp so we can restore in case of error
	
	SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

	// append trailing backslash if neccessary
	if(szTempPath[cchLength - 1] != '\\')
	{
		szTempPath[cchLength] = '\\';
		szTempPath[cchLength + 1] = 0;
	}

	strcat(szTempPath, "DumpFontInfo.txt");
	
	SideAssert(hfileDump = CreateFileA(szTempPath,
			GENERIC_WRITE,
			FILE_SHARE_READ,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL));

	if(_cch > 0)							// start from cpMin
		FlipRange();

	CFormatRunPtr rp(_rpCF);

	for (i=0; i <= cch; i++)
	{
		LONG	iFormat;

		if (GetChar(&ch) != NOERROR)
			break;

		if (ch <= 0x07f)
			sprintf(szTempBuf, "Char= '%c'\r\n", (char)ch);
		else
			sprintf(szTempBuf, "Char= 0x%x\r\n", ch);
		OutputDebugStringA(szTempBuf);
		if (hfileDump)
			WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
		
		iFormat = rp.GetFormat();
		CF = ped->GetCharFormat(iFormat);
		Assert(CF);

		sprintf(szTempBuf, "Font iFormat= %d, CharRep = %d, Size= %d\r\nName= ",
			iFormat, CF->_iCharRep, CF->_yHeight);
		OutputDebugStringA(szTempBuf);
		if (hfileDump)
			WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
		
		wszFontname = GetFontName(CF->_iFont);
		if (wszFontname)
		{
			if (*wszFontname <= 0x07f)
			{
				szTempBuf[0] = '\'';
				WCTMB(CP_ACP, 0,
						wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf)-1,
						NULL, NULL,	NULL);
				strcat(szTempBuf,"\'");
				OutputDebugStringA(szTempBuf);
				if (hfileDump)
					WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
			}
			else
			{
				for (; *wszFontname; wszFontname++)
				{
					sprintf(szTempBuf, "0x%x,", *wszFontname);
					OutputDebugStringA(szTempBuf);
					if (hfileDump)
						WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
				}
			}
		}

		OutputDebugStringA("\r\n");
		if (hfileDump)
			WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

		Move(1, FALSE);

		rp.Move(1);
	}

	// Now dump the doc font info
	CF = ped->GetCharFormat(-1);
	Assert(CF);

	sprintf(szTempBuf, "Default Font iFormat= -1, CharRep= %d, Size= %d\r\nName= ",
		CF->_iCharRep, CF->_yHeight);
	OutputDebugStringA(szTempBuf);
	if (hfileDump)
		WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
	
	wszFontname = GetFontName(CF->_iFont);
	if (wszFontname)
	{
		if (*wszFontname <= 0x07f)
		{
			szTempBuf[0] = '\'';
			WCTMB(CP_ACP, 0,
					wszFontname, -1, &szTempBuf[1], sizeof(szTempBuf),
					NULL, NULL,	NULL);
			strcat(szTempBuf,"\'");
			OutputDebugStringA(szTempBuf);
			if (hfileDump)
				WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
		}
		else
		{
			for (; *wszFontname; wszFontname++)
			{
				sprintf(szTempBuf, "0x%x,", *wszFontname);
				OutputDebugStringA(szTempBuf);
				if (hfileDump)
					WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
			}
		}
	}

	OutputDebugStringA("\r\n");
	if (hfileDump)
		WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);


	if (ped->IsRich())
	{
		if (ped->fUseUIFont())
			sprintf(szTempBuf, "Rich Text with UI Font");
		else
			sprintf(szTempBuf, "Rich Text Control");
	}
	else
		sprintf(szTempBuf, "Plain Text Control");

	OutputDebugStringA(szTempBuf);
	if (hfileDump)
		WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

	OutputDebugStringA("\r\n");
	if (hfileDump)
		WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

	if (hfileDump)
		CloseHandle(hfileDump);

	Set(cpSave, cchSave);				// Restore previous selection	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\reinit.cpp ===
/*
 *
 *	REINIT.CPP
 *	
 *	Purpose:
 *		RICHEDIT initialization routines
 *	
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_format.h"
#include "_disp.h"
#include "_clasfyc.h"
#include "zmouse.h"
#include "_rtfconv.h"
#ifndef NOLINESERVICES
#include "_ols.h"
#ifndef NODELAYLOAD
#include <delayimp.h>
#endif
#endif
#include "_host.h"
#ifndef NOVERSIONINFO
#include <shlwapi.h>
#include "_version.h"
#endif

ASSERTDATA

class CTxtEdit;
class CCmbBxWinHost;

extern void ReleaseTypeInfoPtrs();

static WCHAR wszClassREW[sizeof(MSFTEDIT_CLASS)/sizeof(WCHAR)];

static WCHAR wszClassLBW[] = LISTBOX_CLASSW;
static WCHAR wszClassCBW[] = COMBOBOX_CLASSW;
#define REGISTERED_LISTBOX	1
#define REGISTERED_COMBOBOX 2

// a critical section for multi-threading support.
CRITICAL_SECTION g_CriticalSection;

HINSTANCE hinstRE = 0;

static BOOL RichFRegisterClass(VOID);

#ifdef DEBUG
BOOL fInDllMain = FALSE;  // used to ensure that GDI calls are not made during
						  // DLL_PROCESS_ATTACH
#endif

void FreeFontCache();					// Defined in font.cpp
void ReleaseOutlineBitmaps();			// Defined in render.cpp 

#ifdef DEBUG
	void CatchLeaks(void);
#endif

extern HANDLE g_hHeap;

void FreeHyphCache(void);

#ifndef NODELAYLOAD
static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

void OurUnloadDelayLoadedDlls(void)
{
    PUnloadInfo pui = __puiHead;
    
	for (;pui;)
	{
#ifdef _WIN64
		if (pui->pidd->rvaUnloadIAT)
		{
			PCImgDelayDescr pidd = pui->pidd;
			HMODULE*		phmod = PFromRva(pidd->rvaHmod, (HMODULE *)NULL);
			HMODULE			hmod = *phmod;

			if (hmod)
			{
				// NOTE:  (honwch  3/6/01) We don't need to reset pIAT since this
				// routine is being called on DLL_PROCESS_DETACH.  We only need to reset
				// pIAT iff RE is staying around and we need to re-load this DLL again.
				// The following line would crash because of a bug in BBT3.0 and delayed load.
				// If RE is loaded into a different address space, pUnloadIAT is not fixed up
				// correctly.  (RE Bug 9292) 
				// OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
				::FreeLibrary(hmod);
				*phmod = NULL;
			}
#else
		if (pui->pidd->pUnloadIAT)
		{
			PCImgDelayDescr pidd = pui->pidd;
			HMODULE         hmod = *pidd->phmod;

			if (hmod)
			{
				// NOTE:  (honwch  3/6/01) We don't need to reset pIAT since this
				// routine is being called on DLL_PROCESS_DETACH.  We only need to reset
				// pIAT iff RE is staying around and we need to re-load this DLL again.
				// The following line would crash because of a bug in BBT3.0 and delayed load.
				// If RE is loaded into a different address space, pUnloadIAT is not fixed up
				// correctly.  (RE Bug 9292) 
				// OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
				::FreeLibrary(hmod);
				*pidd->phmod = NULL;
			}
#endif
			PUnloadInfo puiT = pui->puiNext;
			::LocalFree(pui);
			pui = puiT;
		}

	}
}
#endif

//CLEARTYPE test code Turn this flag on to test.
//#define CLEARTYPE_DEBUG

#ifdef CLEARTYPE_DEBUG
#include "ct_ras_win.h"

class CCustomTextOut:public ICustomTextOut
{
	virtual BOOL WINAPI ExtTextOutW(HDC hdc, int X, int Y, UINT fuOptions,  
			CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx);
	virtual BOOL WINAPI GetCharWidthW(HDC hdc,UINT iFirstChar, UINT iLastChar,
			LPINT lpBuffer);
	virtual BOOL WINAPI NotifyCreateFont(HDC hdc);
	virtual void WINAPI NotifyDestroyFont(HFONT hFont);
};


extern "C" HINSTANCE g_hRE;
typedef HRESULT (*PFNPROC)(ICustomTextOut**);    
PFNPROC _pfnProc = NULL;
CCustomTextOut *pCTO; 
HINSTANCE _hctras = NULL;
EXTERN_C long g_ClearTypeNum=0;
typedef BOOL (WINAPI *PFNEXTTEXTOUTW)(HDC, LONG, LONG, DWORD,
							  CONST RECT*, PWSTR, ULONG, CONST LONG*);
typedef BOOL (WINAPI *PFNGETCHARWIDTHW)(HDC, WCHAR, WCHAR, PLONG);
typedef BOOL (WINAPI *PFNCREATEFONTINSTANCE)(HDC, DWORD);
typedef BOOL (WINAPI *PFNDELETEFONTINSTANCE)(HFONT);
PFNEXTTEXTOUTW			_pfnExtTextOutW = NULL;
PFNGETCHARWIDTHW		_pfnGetCharWidthW = NULL;
PFNCREATEFONTINSTANCE	_pfnCreateFontInstance = NULL;
PFNDELETEFONTINSTANCE	_pfnDeleteFontInstance = NULL;



BOOL CCustomTextOut::ExtTextOutW(HDC hdc, int X, int Y, UINT fuOptions,  
			CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx)
{
	return _pfnExtTextOutW(hdc, X, Y, fuOptions, lprc, (USHORT*) lpString, cbCount, (LONG*) lpDx);		 
}

BOOL CCustomTextOut::GetCharWidthW(HDC hdc,UINT iFirstChar, UINT iLastChar,
			LPINT lpBuffer)
{
	 return _pfnGetCharWidthW(hdc, iFirstChar, iLastChar, (LONG*) lpBuffer);
}


BOOL CCustomTextOut::NotifyCreateFont(HDC hdc)
{
	 return _pfnCreateFontInstance(hdc, 0);
}


void CCustomTextOut::NotifyDestroyFont(HFONT hFont)
{
	_pfnDeleteFontInstance(hFont);
}

extern "C" void ClearTypeUnInitialize();

extern "C" HRESULT ClearTypeInitialize()
{
	_hctras=LoadLibraryA("ctras.dll");
	// check - cleartype dll is not gauranteed to be present
	if (!_hctras)
	{
		ClearTypeUnInitialize();
		return E_NOINTERFACE;
	}
	_pfnExtTextOutW=(PFNEXTTEXTOUTW)GetProcAddress(_hctras, "WAPI_EZCTExtTextOutW");
	_pfnGetCharWidthW=(PFNGETCHARWIDTHW)GetProcAddress(_hctras, "WAPI_EZCTGetCharWidthW");
	_pfnCreateFontInstance=(PFNCREATEFONTINSTANCE)GetProcAddress(_hctras, "WAPI_EZCTCreateFontInstance");
	_pfnDeleteFontInstance=(PFNDELETEFONTINSTANCE)GetProcAddress(_hctras, "WAPI_EZCTDeleteFontInstance");

	// check that we got these correctly
	// future versions of cleartype could change this API
	if(!_pfnExtTextOutW || !_pfnGetCharWidthW || !_pfnCreateFontInstance || !_pfnDeleteFontInstance)
	{
		ClearTypeUnInitialize();
		return E_NOINTERFACE;
	}

	pCTO=new CCustomTextOut;
	ICustomTextOut *pICTO=pCTO;	

	SetCustomTextOutHandlerEx(&pICTO, 0);
	return NOERROR;
}

extern "C" void ClearTypeUnInitialize()
{ 
	if(_hctras)
	{
		FreeLibrary(_hctras);
		_hctras = NULL;
	}

	if(pCTO)
	{
		delete pCTO;
		pCTO = NULL;
	}

	_pfnExtTextOutW = NULL;
	_pfnGetCharWidthW = NULL;
	_pfnCreateFontInstance = NULL;
	_pfnDeleteFontInstance = NULL;
}

#endif

extern "C"
{

BOOL WINAPI DllMain(HANDLE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	DebugMain ((HINSTANCE) hmod, dwReason, lpvReserved);

	if(dwReason == DLL_PROCESS_DETACH)		// We are unloading
	{
#ifndef NOWINDOWHOSTS
		DeleteDanglingHosts();
#endif
		CRTFConverter::FreeFontSubInfo();
		FreeFontCache();
		DestroyFormatCaches();
		ReleaseTypeInfoPtrs();
		UninitKinsokuClassify();
		FreeHyphCache();

		
		// Release various resouces allocated during running...
#ifndef NOLINESERVICES
		delete g_pols;
#endif

#ifndef NOCOMPLEXSCRIPTS
		delete g_pusp;
		g_pusp = NULL;
#endif

		ReleaseOutlineBitmaps();

#ifdef CLEARTYPE_DEBUG
		ClearTypeUnInitialize();
#endif

		if(hinstRE)
		{
			W32->UnregisterClass(wszClassREW, hinstRE);
			if (W32->_fRegisteredXBox)
			{
				// There may be cases where these window classes
				// are still in memory in which case UnregisterClass
				// will fail.  So keep track of that
				if (W32->UnregisterClass(wszClassLBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_LISTBOX;
				if (W32->UnregisterClass(wszClassCBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_COMBOBOX;
			}
		}
		delete W32;

#if defined(DEBUG) && !defined(NOFULLDEBUG)
		CatchLeaks();
#endif

#ifndef NODELAYLOAD
		// lpvReserved is not NULL when DllMain DLL_PROCESS_DETACH is being called during process exit.
		// In such case, we should not mess around with the delay loaded dll thunks
		if (!lpvReserved)
			OurUnloadDelayLoadedDlls();
#endif
		HeapDestroy(g_hHeap);
		DeleteCriticalSection(&g_CriticalSection);
	}
	else if(dwReason == DLL_PROCESS_ATTACH) // We have just loaded
	{
		#ifdef DEBUG
			fInDllMain = TRUE;
		#endif
		InitializeCriticalSection(&g_CriticalSection);
#if !defined(DEBUG) && !defined(UNDER_CE)
		// REVIEW (gheino) We should investigate if there is another
		// way to do this on CE
		DisableThreadLibraryCalls((HINSTANCE) hmod);
#endif
		hinstRE = (HINSTANCE) hmod;

		W32 = new CW32System;

		CopyMemory(wszClassREW, MSFTEDIT_CLASS, sizeof(MSFTEDIT_CLASS));

		if(!RichFRegisterClass())
			return FALSE;

#ifdef CLEARTYPE_DEBUG
		ClearTypeInitialize();
#endif

		#ifdef DEBUG
			fInDllMain = FALSE;
		#endif
	}

	return TRUE;
}

#ifndef NOVERSIONINFO
HRESULT CALLBACK DllGetVersion(
    DLLVERSIONINFO *pdvi
)
{
	if (pdvi->cbSize != sizeof(DLLVERSIONINFO))
		return E_INVALIDARG;
	pdvi->dwBuildNumber =  RICHEDIT_VERBUILD;
	pdvi->dwMajorVersion = RICHEDIT_VERMAJ;
	pdvi->dwMinorVersion = RICHEDIT_VERMIN;
	pdvi->dwPlatformID = DLLVER_PLATFORM_WINDOWS ;
	return NOERROR;
}
#endif

} 	// extern "C"

/*
 *	RichFRegisterClass
 *
 *	Purpose:	
 *		registers the window classes used by richedit
 *
 *	Algorithm:
 *		register two window classes, a Unicode one and an ANSI
 *		one.  This enables clients to optimize their use of 
 *		the edit control w.r.t to ANSI/Unicode data 
 */

static BOOL RichFRegisterClass(VOID)
{
#ifndef NOWINDOWHOSTS
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichFRegisterClass");
	WNDCLASS wc;

	wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
	wc.lpfnWndProc = RichEditWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = sizeof(CTxtEdit FAR *);
	wc.hInstance = hinstRE;
	wc.hIcon = 0;
	wc.hCursor = 0;
	wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = wszClassREW;

	if( W32->RegisterREClass(&wc) == NULL )
		return FALSE;
#endif // NOWINDOWHOSTS
	return TRUE;
}

#ifndef NOLISTCOMBOBOXES

extern "C" LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);
extern "C" LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);
__declspec(dllexport) BOOL WINAPI REExtendedRegisterClass(VOID)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "REExtendedRegisterClass");
		
	WNDCLASS wc;

	if (!(W32->_fRegisteredXBox & REGISTERED_LISTBOX))
	{
		// Globally register the listbox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
		wc.lpfnWndProc = RichListBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CTxtEdit FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassLBW;

		if(W32->RegisterREClass(&wc))
			W32->_fRegisteredXBox |= REGISTERED_LISTBOX;
	}

	if (!(W32->_fRegisteredXBox & REGISTERED_COMBOBOX))
	{
		// globally register the combobox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC | CS_VREDRAW | CS_HREDRAW;
		wc.lpfnWndProc = RichComboBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CCmbBxWinHost FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassCBW;

		if(W32->RegisterREClass(&wc))
			W32->_fRegisteredXBox |= REGISTERED_COMBOBOX;
	}

	//Set flag so we unregister the window class
	return W32->_fRegisteredXBox;
}
#else // NOLISTCOMBOBOXES
__declspec(dllexport) BOOL WINAPI REExtendedRegisterClass(VOID)
{
	return FALSE;
}
#endif  // NOLISTCOMBOBOXES

#if !defined(NOLINESERVICES)
BOOL g_fNoLS = FALSE;
#endif

#if !defined(NOCOMPLEXSCRIPTS)
BOOL g_fNoUniscribe = FALSE;
#endif

#if !defined(NOLINESERVICES) && !defined(NOCOMPLEXSCRIPTS)
char *g_szMsgBox = NULL;

//This is a stub function which we call when we can't find LineServices.
//The stub function needs to be the the first function we call in LS.
LSERR WINAPI LsGetReverseLsimethodsStub(LSIMETHODS *plsim)
{
	return lserrOutOfMemory;
}

//Ugly, but good enough
BOOL FIsUniscribeDll (const char *szDll)
{
	return (*szDll == 'u' || *szDll == 'U');
}

BOOL FIsLineServicesDll (const char *szDll)
{
	return (*szDll == 'm' || *szDll == 'M') &&
		   (*(szDll+1) == 's' || *(szDll+1) == 'S') &&
		   (*(szDll+2) == 'l' || *(szDll+2) == 'L');
}

HRESULT WINAPI ScriptGetPropertiesStub(const SCRIPT_PROPERTIES ***ppSp,int *piNumScripts)
{
	return E_FAIL;
}

const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttrStub(SCRIPT_STRING_ANALYSIS ssa)
{
	// USP build 0175 (shipped with IE5 and Office2K) doesnt support this API.
	return NULL;
}

// Get Uniscibe's fake entry points

FARPROC WINAPI GetUniscribeStubs(LPCSTR szProcName)
{
	if (!lstrcmpiA(szProcName, "ScriptGetProperties"))
		return (FARPROC)ScriptGetPropertiesStub;

	if (!lstrcmpiA(szProcName, "ScriptString_pLogAttr"))
		return (FARPROC)ScriptString_pLogAttrStub;

#ifdef DEBUG
	char szAssert[128];

	wsprintfA(szAssert, "Uniscribe API =%s= is missing. Fix it NOW!", szProcName);

	AssertSz(FALSE, szAssert);
#endif

	return (FARPROC)ScriptGetPropertiesStub;	// we're dying...
}

#ifndef NODELAYLOAD

FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
	FARPROC fp = 0;

	switch (dliNotify)
	{
	// Handy for debugging for now.	
	case dliNotePreGetProcAddress:
		if (FIsLineServicesDll(pdli->szDll))
			fp = 0;
		break;

	case dliFailLoadLib:
		{
			if (FIsUniscribeDll(pdli->szDll))
				g_fNoUniscribe = TRUE;
			else
				g_fNoLS = TRUE;

			fp = (FARPROC)(HMODULE)hinstRE;

			CLock lock;
			if(!g_szMsgBox)
			{
				g_szMsgBox = (char *)PvAlloc(255, GMEM_ZEROINIT);

				FormatMessageA(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
							  ERROR_MOD_NOT_FOUND, 
							  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							  (char *)g_szMsgBox, 255, NULL);

				CopyMemory(g_szMsgBox + lstrlenA(g_szMsgBox), " (", 3);
				CopyMemory(g_szMsgBox + lstrlenA(g_szMsgBox), pdli->szDll, lstrlenA(pdli->szDll) + 1);
				CopyMemory(g_szMsgBox + lstrlenA(g_szMsgBox), ")", 2);
			}
		}
	break;

	case dliFailGetProc:
		if (FIsUniscribeDll(pdli->szDll))
			fp = (FARPROC)GetUniscribeStubs(pdli->dlp.szProcName);
		else
			fp = (FARPROC)LsGetReverseLsimethodsStub;
	break;
	}

	return fp;
}

PfnDliHook __pfnDliFailureHook = DliHook;
PfnDliHook __pfnDliNotifyHook  = DliHook;
#endif // NODELAYLOAD

#endif // NOLINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by richedit.rc
//
#define CUR_CROSS                       104
#define CUR_HAND                        105
#define CUR_ITALIC                      106
#define CUR_SELBAR                      107

#define IDC_DRAGDROPCOPY                109
#define IDC_DRAGDROPMOVE                110
#define IDC_DRAGDROPNONE                111

#if defined(APSTUDIO_INVOKED) || !defined(_MAC)
#define IDC_NOSCROLLH                   112
#define IDC_NOSCROLLV                   113
#define IDC_NOSCROLLVH                  114
#define IDC_SCROLLEAST                  115
#define IDC_SCROLLNE                    116
#define IDC_SCROLLNORTH                 117
#define IDC_SCROLLNW                    118
#define IDC_SCROLLSE                    119
#define IDC_SCROLLSOUTH                 120
#define IDC_SCROLLSW                    121
#define IDC_SCROLLWEST                  122
#define IDB_1DVSCROL                    125
#define IDB_2DSCROL                     126
#define IDB_1DHSCROL                    127
#endif
#define CUR_VIBEAM						129
#define	CUR_VITALIC						130

//Outline support
#if defined(DEBUG) || defined (_RELEASE_ASSERTS_)
#define IDC_MSG							200
#define IDD_ASSERT						201
#define ID_IGNOREALL					202
#define IDD_DEBUG						203
#define	IDC_MEMORY_STATISTICS			1000
#endif
#define BITMAP_ID_SUBTEXT               2100
#define BITMAP_ID_EXPANDED_HEADING      2101
#define BITMAP_ID_COLLAPSED_HEADING     2102
#define BITMAP_ID_EMPTY_HEADING         2103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        128
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtext.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTEXT.CPP - Rich-text ptr class |
 *
 *		This text ptr consists of a plain text ptr (_rpTX), a CCharFormat
 *		run ptr (_rpCF), and a CParaFormat run ptr (_rpPF). This module
 *		contains the methods to manipulate this combination of run ptrs
 *		consistently.
 *	
 *	Authors:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Main implementation: Murray Sargent <nl>
 *		Undo and notification implementations: Alex Gounares <nl>
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_disp.h"
#include "_select.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_objmgr.h"
#include "_txtbrk.h"

ASSERTDATA

#define DEBUG_CLASSNAME CRchTxtPtr
#include "_invar.h"

#ifdef DEBUG
/*
 *	CRchTxtPtr::Invariant
 */
BOOL CRchTxtPtr::Invariant( void ) const
{
	if (m_InvariantCheckInterval < 1 || m_InvariantCheckInterval > 10)
		const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval = 10;

	const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval--;

	if (m_InvariantCheckInterval)
		return TRUE;

	unsigned ch;
	LONG cch;
	LONG cchLength = GetTextLength();
	LONG cp;

	_rpTX.Invariant();
	_rpCF.Invariant();
	_rpPF.Invariant();

	if(_rpCF.IsValid())
	{
		cp  = _rpCF.CalculateCp();
		cch = _rpCF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);
		Assert(!_rpCF._iRun || GetPed()->IsBiDi() || _rpCF.GetRun(0)->_iFormat != _rpCF.GetRun(-1)->_iFormat);
	}

	if(_rpPF.IsValid())
	{
		cp  = _rpPF.CalculateCp();
		cch = _rpPF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);

		CTxtPtr	tp(_rpTX);

		tp.Move(_rpPF.GetCchLeft() - 1);
		ch = tp.GetChar();
		if(!IsEOP(ch))
		{
			_rpTX.MoveGapToEndOfBlock();			// Make it easier to see
			AssertSz(FALSE,							//  what's going on
				"CRchTxtPtr::Invariant: PF run doesn't end with EOP");
		}

#ifdef EXTREME_CHECKING
		// We don't do this check normally as it is _extremely_ slow.
		// However, it's very useful for catching para-format run problems

		// Make sure each para format run ends on a paragraph mark!
		CFormatRunPtr	rpPF(_rpPF);

		rpPF.BindToCp(0);
		tp.BindToCp(0);
		do
		{
			tp.Move(rpPF.GetRun(0)->_cch);
			if(!tp.IsAfterEOP())
			{
				AssertSz(0, "ParaFormat Run not aligned along paragraphs!");
			}
		} while( rpPF.NextRun() );
#endif // EXTREME_CHECKING
	}
	return TRUE;
}

/*
 *	CRchTxtPtr::GetParaNumber ()
 *
 *	@mfunc
 *		Return number of current paragraph in a numbered list. This is
 *		0 if the current paragraph isn't part of a list. It's 1 if it's
 *		the first paragraph in a list, 2 if it's the second, etc.
 *
 *	@rdesc
 *		paragraph number active at this rich text ptr
 *
 *	@devnote
 *		When the display is calc'd from the beginning or recalc'd from
 *		a previous valid position, the list number can be determined from
 *		the display.  But if CDisplayPrinter::FormatRange() works without
 *		a display, it needs to know the number.  This routine can be so used
 *		for this purpose and for debugging the display choices.
 */
LONG CRchTxtPtr::GetParaNumber() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetParaNumber");

	LONG		 ch;
	LONG		 cPara = 0;
	LONG		 n;
	const CParaFormat *pPF, *pPFLast = NULL;
	CRchTxtPtr	 rtp(*this);

	while(1)
	{
		pPF = rtp.GetPF();
		if(pPF->_wEffects & PFE_TABLEROWDELIMITER)
			break;
		// CParaFormat::UpdateNumber(2, pPFLast) returns:
		//		0 -- not a numbered list
		//		1 -- new numbered list or pPFLast = NULL
		//		2 -- list number suppressed
		//		3 -- different number in same list
		n = pPF->UpdateNumber(2, pPFLast);
		if(n == 0 || n == 1 && pPFLast && cPara)
			break;
		ch = rtp.GetPrevChar();
		if((!ch || IsASCIIEOP(ch) && !IN_RANGE(VT, ch, FF) || ch == CELL) && n != 2)
			cPara++;
		if(!ch || rtp._rpTX.IsAtStartOfCell())
			break;
		rtp._rpPF.Move(rtp._rpTX.FindEOP(tomBackward));	
		pPFLast = pPF;						// Don't need to update _rpCF
	}										//  for this calculation
	return cPara;
}

#endif  // DEBUG

//======================= CRchTxtPtr constructors ========================================

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped) :
	_rpTX(ped, 0), _rpCF(NULL),	_rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped, LONG cp) :
	_rpTX(ped, cp), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr (const CRchTxtPtr& rtp) :
	_rpTX(rtp._rpTX), _rpCF(rtp._rpCF), _rpPF(rtp._rpPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	_rpCF.AdjustForward();		// In case rtp is adjusted backward...
	_rpPF.AdjustForward();
}

CRchTxtPtr::CRchTxtPtr (const CDisplay * pdp) :
	_rpTX(pdp->GetPed(), 0), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

/*
 *	CRchTxtPtr::Move(cch)
 *	
 *	@mfunc
 *		Move this rich-text ptr forward <p cch> characters.  If <p cch>
 *		<lt> 0, move backward by -<p cch> characters.
 *	
 *	@rdesc
 *		cch actually moved
 */
LONG CRchTxtPtr::Move(
	LONG cch)			// @parm count of characters to move - may be <lt> 0
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Move");

	if( cch != 0 )
	{
		cch = _rpTX.Move(cch);
		_rpCF.Move(cch);
		_rpPF.Move(cch);
		_TEST_INVARIANT_
	}
	return cch;
}

/*
 *  CRchTxtPtr::AdvanceCRLF()
 *
 *  @mfunc
 *      Advance this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::AdvanceCRLF()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::AdvanceCRLF");

    LONG cch = _rpTX.AdvanceCRLF();
    _rpPF.Move(cch);
    _rpCF.Move(cch);
    return cch;
}

/*
 *  CRchTxtPtr::SnapToCluster(iDirection)
 *
 *  @mfunc
 *      If this text ptr is not at cluster boundary, move it to the closest one.
 *
 *  @rdesc
 *      cch actually moved
 */
#ifndef NOCOMPLEXSCRIPTS
LONG CRchTxtPtr::SnapToCluster(INT iDirection)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::SnapToCluster");

	LONG	cch = 0;
	LONG	cp;

	if (GetPed()->_pbrk)
	{
		if (iDirection >= 0)
		{
			LONG	cpEnd = GetPed()->GetAdjustedTextLength();

			while ((cp = GetCp()) < cpEnd && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += AdvanceCRLF();
		}
		else
		{
			while ((cp = GetCp()) > 0 && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += BackupCRLF();
		}
	}
    return cch;
}
#endif

/*
 *  CRchTxtPtr::BackupCRLF(fDiacriticCheck)
 *
 *  @mfunc
 *      Backup this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::BackupCRLF(
	BOOL fDiacriticCheck)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::BackupCRLF");

    LONG cch = _rpTX.BackupCRLF(fDiacriticCheck);
    _rpPF.Move(cch);
    _rpCF.Move(cch);
    return cch;
}

/*
 * CRchTxtPtr::ValidateCp(&cp)
 *
 *	@mfunc
 *		If <p cp> <lt> 0, set it to 0; if it's <gt> text length, set it to
 *		text length.
 */
void CRchTxtPtr::ValidateCp(
	LONG &cp) const			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ValidateCp");

	LONG cchT = GetTextLength();

	cp = min(cp, cchT);				// Be sure cp is valid
	cp = max(cp, 0);
}

/*
 * CRchTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		Set this rich text ptr's cp to cp
 */
LONG CRchTxtPtr::SetCp(
	LONG cp)			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetCp");

	CRchTxtPtr::Move(cp - GetCp());
	return GetCp();
}

/*	CRchTxtPtr::GetIchRunXX() and CRchTxtPtr::GetCchRunXX()
 *
 *	@mfunc
 *		Text-run management to retrieve current text run cch and offset
 *
 *	@rdesc
 *		current run ich or cch
 *
 *	@devnote
 *		Use of queries like _rpCF.IsValid() instead of an inclusive fRich
 *		allows rich-text formatting to be applied per rich-text category,
 *		e.g., CHARFORMATs, but not necessarily PARAFORMATs.  If the rp isn't
 *		valid, _cp is used for ich and the document length is used for cch,
 *		i.e., the values for a document describable by a single plain-text run
 */
LONG CRchTxtPtr::GetIchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetIchRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunPF");

	return _rpPF.IsValid() ? _rpPF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetCchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetRun(0)->_cch : GetTextLength();
}

/*	CRchTxtPtr::GetCchLeftRunCF() / GetCchLeftRunPF()
 *
 *	@mfunc
 *		Return cch left in run, i.e., cchRun - ich
 *
 *	@rdesc
 *		cch left in run
 */
LONG CRchTxtPtr::GetCchLeftRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunCF");

	return _rpCF.IsValid()
		? _rpCF.GetCchLeft() : GetTextLength() - GetCp();
}

LONG CRchTxtPtr::GetCchLeftRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunPF");

	return _rpPF.IsValid()
		? _rpPF.GetCchLeft() : GetTextLength() - GetCp();
}

/*
 *	CRchTxtPtr::FindText(cpMost, dwFlags, pch, cchToFind)
 *	
 *	@mfunc
 *		Find text in a range starting at this text pointer;
 *		if found, moves this text pointer to that position.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 *
 *	@devnote
 *		Would be easy to match a single format (like Word 6) provided
 *		cchToFind is nonzero.  Else need to search runs (also pretty easy).
 *		For format-sensitive searches, might be easier to search for matching
 *		format run first and then within that run search for text.
 */
LONG CRchTxtPtr::FindText (
	LONG		cpMost,		// @parm Limit of search; <lt> 0 for end of text
	DWORD		dwFlags,	// @parm FR_MATCHCASE	case must match
							//		 FR_WHOLEWORD	match must be a whole word
	TCHAR const *pch,		// @parm Text to search for
	LONG		cchToFind)	// @parm Length of text to search for
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindText");

	_TEST_INVARIANT_

	LONG cpSave = GetCp();
	LONG cpMatch = _rpTX.FindText(cpMost, dwFlags, pch, cchToFind);

	if(cpMatch >= 0)					// cpMatch = -1 means "not found"
		SetRunPtrs(GetCp(), cpSave);	
	
			// possible code for format-dependent Finds
	return cpMatch;
}

/*
 *	CRchTxtPtr::GetCF()/GetPF()
 *	
 *	@mfunc
 *		Return ptr to CCharFormat/CParaFormat at this text ptr. If no CF/PF runs
 *		are allocated, then return ptr to default format
 *	
 *	@rdesc
 *		Ptr to CCharFormat/CParaFormat at this text ptr
 */
const CCharFormat* CRchTxtPtr::GetCF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCF");

	return ((CTxtArray *)_rpTX._pRuns)->GetCharFormat(_rpCF.GetFormat());
}

const CParaFormat* CRchTxtPtr::GetPF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetPF");

	return ((CTxtArray *)_rpTX._pRuns)->GetParaFormat(_rpPF.GetFormat());
}

/*
 *	CRchTxtPtr::Get_iCF()
 *	
 *	@mfunc
 *		Get character format index at this text pointer
 *
 *	@rdesc
 *		Get iCF at this text pointer
 */
LONG CRchTxtPtr::Get_iCF ()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::Get_iCF");

	LONG iCF = _rpCF.GetFormat();

	GetCharFormatCache()->AddRef(iCF);
	return iCF;
}

/*
 *	CRchTxtPtr::Get_iPF()
 *	
 *	@mfunc
 *		Get paragraph format index at this text pointer
 *
 *	@rdesc
 *		Get iPF at this text pointer
 */
LONG CRchTxtPtr::Get_iPF ()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::Get_iPF");

	LONG iPF = _rpPF.GetFormat();

	GetParaFormatCache()->AddRef(iPF);
	return iPF;
}

/*
 *	CRchTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize, fUseCRLF)
 *
 *	@mfunc
 *		Same as CTxtPtr except that hidden text isn't copied
 *
 *	@rdesc
 *		Count of characters copied
 */
LONG CRchTxtPtr::GetPlainText(
	LONG	cchBuff,		//@parm Buffer cch
	WCHAR *	pch,			//@parm Buffer to copy text into
	LONG	cpMost,			//@parm Largest cp to get
	BOOL	fTextize,		//@parm True if break on WCH_EMBEDDING
	BOOL	fUseCRLF)		//@parm If TRUE, CR or LF -> CRLF
{
	LONG	  cchTotal = 0;
	CTxtEdit *ped = GetPed();
	CTxtPtr	  tp(_rpTX);					// tp to get unhidden text

	if(!_rpCF.IsValid() || !ped->IsRich())
		cchTotal = tp.GetPlainText(cchBuff, pch, cpMost, fTextize, fUseCRLF);

	else
	{
		LONG	  cch = 0;
		LONG	  cp;
		CCFRunPtr rp(*this);				// rp to check for hidden text

		cpMost = min(cpMost, GetPed()->GetAdjustedTextLength());
		for(; cchTotal < cchBuff; pch += cch)
		{
			cch = rp.FindUnhiddenForward();
			if(tp.GetCp() + cch >= cpMost)
			{
				SetCp(cpMost);
				return cchTotal;
			}
			tp.Move(cch);					// Bypass hidden text
			for(cch = 0; !rp.IsHidden() && cch < cchBuff; )
			{
				cch += rp.GetCchLeft();
				if(tp.GetCp() + cch >= cpMost || !rp.NextRun())
					break;
			}
			if(cch)							// Copy unhidden text
			{
				cp = tp.GetCp() + cch;
				cp = min(cp, cpMost);
				cch = tp.GetPlainText(cchBuff - cchTotal, pch, cp, fTextize, fUseCRLF);
				cchTotal += cch;
			}
			if(tp.GetCp() >= cpMost || !cch)
				break;
		}
	}
	SetCp(tp.GetCp());
	return cchTotal;
}

/*
 *	CRchTxtPtr::ReplaceRange(cchOld, cchNew, *pch, pcpFirstRecalc, publdr,
 *							 iFormat, dwFlags)
 *	@mfunc
 *		Replace a range of text at this text pointer using CCharFormat iFormat
 *		and updating other text runs as needed
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CRchTxtPtr::ReplaceRange(
	LONG		cchOld,		//@parm length of range to replace
							//		(<lt> 0 means to end of text)
	LONG		cchNew,		//@parm length of replacement text
	TCHAR const *pch,		//@parm replacement text
	IUndoBuilder *publdr,	//@parm Undo bldr to receive antievents
	LONG		iFormat,	//@parm CCharFormat iFormat to use for cchNew
	LONG *		pcchMove,	//@parm Out parm returning cch moved if paradir change
	DWORD		dwFlags)	//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRange");

	LONG		  cch;
	LONG		  cchEndEOP = 0;				// Default 0 final EOP fixup
	LONG		  cchAdvance = 0;
	LONG		  cchBackup = 0;
	LONG		  cchMove = 0;					// Default nothing to move
	LONG		  cchNextEOP = cchOld;			// cch to next EOP
	LONG		  cchPrevEOP = 0;				// cch back to previous EOP
	LONG		  cpFR;							//  between PF runs
	LONG 		  cpSave = GetCp();
	LONG		  cpFormatMax;
	LONG		  cpFormatMin = cpSave;			// Used for notifications
	LONG		  cpFormat = cpSave;			// Will add cchOld, maybe cchMove
	BOOL		  fParaDirChange = FALSE;
	CTxtEdit *	  ped = GetPed();
	IAntiEvent *  paeCF = NULL;
	IAntiEvent *  paePF = NULL;
	CNotifyMgr *  pnm;
	CObjectMgr *  pobjmgr;
	CFreezeDisplay fd(ped->_pdp);				// freeze until itemization is done

 	_TEST_INVARIANT_

	LONG cchEnd = GetTextLength() - GetCp();
	LONG cOldRuns = _rpTX.Count();

	if(cchOld < 0 || cchOld > cchEnd)
		cchOld = cchEnd;

  	if(IsRich() && cchOld == cchEnd)			// Attempting to delete up
	{											//  thru final EOP
		cchEndEOP = (ped->fUseCRLF())			// Calc cch of final EOP
				  ? CCH_EOD_10 : CCH_EOD_20;

		if(cchEndEOP <= cchOld)					// Don't delete it unless
			cchOld -= cchEndEOP;				//  converting from 2.0
		if(_rpPF.IsValid())
		{
			_rpPF.AdjustBackward();				// If previous para is a
			if(GetPF()->InTable())				//  table row, don't delete
				cchEndEOP = 0;					//  final para formatting
			_rpPF.AdjustForward();
		}
	}
	else if(_rpPF.IsValid())					// PARAFORMATs are enabled
	{		
		_rpPF.AdjustForward();		
		LONG iPF2 = _rpPF.GetFormat();			
		BOOL fIsTRD2 = ped->GetParaFormat(iPF2)->IsTableRowDelimiter();
		BOOL fNoTrdCheck = dwFlags & RR_NO_TRD_CHECK;

		if(cchOld)								
		{											
			CFormatRunPtr rp(_rpPF);				
			CTxtPtr 	  tp(_rpTX);			// Get tp and rp at end of	
												//  range. Need bounding para	
			tp.Move(cchOld);					//  counts to save valid PF
			if(tp.GetCp() < ped->GetAdjustedTextLength())
				cchOld += tp.AdjustCRLF(1);
			rp.Move(cchOld);					//  for undo

			LONG iPF1 = rp.GetFormat();
			BOOL fIsTRD1 = ped->GetParaFormat(iPF1)->IsTableRowDelimiter();
			cch = 0;
			if(tp.IsAfterEOP())					// Range ends with an EOP
			{										
				if ((tp.GetPrevChar() == CELL ||// Don't delete table cell
					fIsTRD2 && cchOld == 2) &&	//  at end of range
					!fNoTrdCheck)
				{
					return 0;					//  or solo row delimiter
				}
				cch = -tp.BackupCRLF();			// Get EOP length by
				tp.Move(cch);					//  backing up over it
			}									// Move past EOP
			BOOL fIsAtBOP = !GetCp() || _rpTX.IsAfterEOP();
			if(tp.IsAtTRD(0))
			{
				AssertSz(tp.IsAtTRD(STARTFIELD), "Illegal deletion attempt");
				cchNextEOP = 0;
				if(!fIsAtBOP)
				{
					cchOld--;					// Leave end CR there
					if(tp.IsAfterTRD(ENDFIELD))	// If CR of TRED, move it
					{							//  into prec PF run
						cchMove = cchNextEOP = 1;
						cpFormat++;
					}
				}
			}
			else
			{
				cchNextEOP = tp.FindEOP(tomForward);// Get cch up to next EOP
				AssertSz(rp.GetCchLeft() >= cchNextEOP,
					"CRchTxtPtr::ReplaceRange: missing EOP");
			}
			if (!fIsAtBOP && cch == cchOld &&	// Deleting EOP alone before
				!rp.GetIch())					// new PARAFORMAT run start
			{									// in para with more than EOP
				if(fIsTRD1)
					return 0;					// Don't merge with table row delim
				cchMove = cchNextEOP;			// Need to move chars up to	
				cpFormat += cchMove;			//  end of next para for	
			}										
			
			cchNextEOP += cchOld;				// Count from GetCp() to EOP
				
			tp.SetCp(GetCp());					// Back to this ptr's _cp
			if(!fIsAtBOP)
			{
				cchPrevEOP = tp.FindEOP(tomBackward);// Get cch to start of para
				AssertSz(_rpPF.GetIch() >= -cchPrevEOP,
					"CRchTxtPtr::ReplaceRange: missing EOP");
			}
			// If deleting from within one format run up to or into another, set
			// up to move last para in starting format run into the run following
			// the deleted text
			if(iPF1 != iPF2)					// Change of format during
			{									//  deleted text not starting
				if(!fIsAtBOP && !cchMove && !fIsTRD1)//  at BOP
				{
					cchMove = cchPrevEOP;		// Get cch to start of para
					cpFormatMin += cchMove;		//  in this ptr's run for
				}								//  moving into rp's run

				if (((ped->GetParaFormat(iPF1)->_wEffects ^
					  ped->GetParaFormat(iPF2)->_wEffects) & PFE_RTLPARA) &&
					!(fIsTRD1 | fIsTRD2))
				{
					fParaDirChange = TRUE;		// Note that para direction
					Assert(ped->IsBiDi());		//  changed
				}									
			}
		}
		else
		{
			UINT ch = GetPrevChar();
			if (fIsTRD2 && ch == CELL &&		// Don't paste between CELL
				(_rpTX.IsAtTRD(ENDFIELD) || !fNoTrdCheck) || //  & row terminator
				ch == NOTACHAR && !ped->IsStreaming() ||
				GetChar() == NOTACHAR)			//  or before/after NOTACHAR
			{
				return 0;							
			}
		}
	}	
	
	Assert(cchNew >= 0 && cchOld >= 0);
	if(!(cchNew + cchOld))						// Nothing to do (note: all
	{											//  these cch's are >= 0)
		if(pcchMove)
			*pcchMove = 0;
		return 0;
	}						

	// If BiDi doc, expand the range to cover the boundaries that guarantee
	// the valid state of the BiDi level so we can undo it properly. (wchao)
	cpFormatMax = cpFormat + cchOld;
	if(ped->IsBiDi())
	{
		cchBackup = ExpandRangeFormatting (cchOld + cchEndEOP,
										fParaDirChange ? cchMove : 0, cchAdvance);
		Assert (cchBackup <= 0);
		if(cchMove >= 0)					// In this case, cchBackup is minus
		{									//  the sum of the two previous
			cpFormatMin += cchBackup;		//  run counts
			Assert(cpFormatMin >= 0);
		}
		if(cchMove <= 0)					// In this case cchAdvance is sum
		{									//  of next two run counts (or less)
			cpFormatMax += cchAdvance;
			Assert(cpFormatMax <= GetTextLength());
		}
	}

	// Handle pre-replace range notifications.  This method is very
	// useful for delayed rendering of data copied to the clipboard.
	pnm = ped->GetNotifyMgr();
	if(pnm)
	{
		pnm->NotifyPreReplaceRange((ITxNotify *)this, cpSave, cchOld,
			cchNew, cpFormatMin, cpFormatMax);
	}

	if(iFormat >= 0)
		Check_rpCF();

	// Get rid of objects first.  This lets us guarantee that when we
	// insert the objects as part of an undo, the objects themselves are
	// restored _after_ their corresponding WCH_EMBEDDINGs have been
	// added to the backing store.

	if(GetObjectCount())
	{
		pobjmgr = ped->GetObjectMgr();
		Assert(pobjmgr);
		pobjmgr->ReplaceRange(cpSave, cchOld, publdr);
	}

	// The anti-events used below are a bit tricky (paeCF && paePF).
	// Essentially, this call, CRchTxtPtr::ReplaceRange generates one
	// 'combo' anti-event composed of up to two formatting AE's plus
	// the text anti-event.  These anti-events are combined together
	// to prevent ordering problems during undo/redo.
	cpFR = ReplaceRangeFormatting(cchOld + cchEndEOP, cchNew + cchEndEOP,
						iFormat, publdr, &paeCF, &paePF, cchMove, cchPrevEOP,
						cchNextEOP, cchBackup, cchAdvance);
	if(cchEndEOP)
	{
		// If we added in the EOP we need to back up by the EOP so
		// that the invariants don't get annoyed and the richtext object
		// doesn't get out of sync.
		_rpCF.Move(-cchEndEOP);
		_rpPF.Move(-cchEndEOP);
	}
			
	if(cpFR < 0)
	{
		Tracef(TRCSEVERR, "ReplaceRangeFormatting(%ld, %ld, %ld) failed", GetCp(), cchOld, cchNew);
		cch = 0;
		goto Exit;
	}

	// As noted above in the call to ReplaceRangeFormatting, the anti-events
	// paeCF and paePF, if non-NULL, were generated by ReplaceRangeFormatting.
	// In order to solve ordering problems, the anti-event generated by this
	// method is actually a combo anti-event of text && formatting AE's.
	cch = _rpTX.ReplaceRange(cchOld, cchNew, pch, publdr, paeCF, paePF);
	if(cch != cchNew)
	{
		Tracef(TRCSEVERR, "_rpTX.ReplaceRange(%ld, %ld, ...) failed", cchOld, cchNew);

#ifndef NOFULLDEBUG
		// Boy, out of memory or something bad.  Dump our formatting and hope
		// for the best.
		//
		// FUTURE: (alexgo) degrade more gracefully than losing formatting
		// info.

		// Notify every interested party that they should dump their formatting
		if(pnm)
			pnm->NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

		// Tell document to dump its format runs
		ped->GetTxtStory()->DeleteFormatRuns();
#endif
		goto Exit;
	}
	AssertSz(!_rpPF.IsValid() || _rpPF.GetIch() || !GetCp() || _rpTX.IsAfterEOP(),
		"CRchTxtPtr::ReplaceRange: EOP not at end of PF run");
			
	// BUGBUG!! (alexgo) doesn't handle correctly the case where things fail
	// (due to out of memory or whatever).  See also notes in CTxtPtr::HandleReplaceRange
	// Undo.  The assert below is therefore somewhat bogus, but if it fires,
	// then our floating ranges are going to be in trouble until we fix
	// up the logic here.
	Assert(cch == cchNew);

Exit:

#ifdef DEBUG
	// Test invariant again before calling out to replace range notification.
	// In this way, we can catch bugs earlier. The invariant has its own
	// scope for convenience.
	if( 1 )
	{
		_TEST_INVARIANT_
	}
#endif

	if(ped->IsBiDi() && cpSave <= ped->GetCpFirstStrong() && (cchOld | cch))
	{
		// Remember whether formatting is valid before we set context direction
		BOOL fCFValidBeforeSetContextDirection = _rpCF.IsValid();
		
		// Need to check the direction of the control if the input characters
		// control the direction.
		ped->SetContextDirection();

		// Did SetContextDirection make the formatting valid?
		if (!fCFValidBeforeSetContextDirection && _rpCF.IsValid())
		{
			// Our invariant is that cps should be equal if formatting is valid
			// so make it so!
			_rpCF.BindToCp(GetCp());
		}
	}

	if(pnm)
	{
		BOOL fTxtCellShrink = (cOldRuns > _rpTX.Count());
		NOTIFY_DATA notifyData;

		if (fTxtCellShrink)
		{
			// Setup NOTIFY_DATA
			notifyData.id = NOTIFY_DATA_TEXT_ID;
			notifyData.dwFlags = TN_TX_CELL_SHRINK;
			notifyData.pData = NULL;
		}
		pnm->NotifyPostReplaceRange((ITxNotify *)this, cpSave, cchOld, cch,
			cpFormatMin, cpFormatMax, 
			fTxtCellShrink ? &notifyData : NULL);
	}

	ped->GetCallMgr()->SetChangeEvent(CN_TEXTCHANGED);

	if(pcchMove)						// Only return non0 cchMove if para
	{									//  direction changed, i.e., it's
		*pcchMove = fParaDirChange		//  a "BOOL" with a useful value,
				  ? cchMove : 0;		//  namely the count of chars with
	}									//  changed direction

	if (ped->IsComplexScript())
	{
		if (dwFlags & RR_ITMZ_NONE || (ped->IsStreaming() && (!pch || *pch != WCH_EMBEDDING)))
			ped->_fItemizePending = TRUE;
		else
			ItemizeReplaceRange(cchNew, fParaDirChange? cchMove : 0, publdr);
	}
	return cch;
}

/*
 *	CRchTxtPtr::InitRunPtrs()
 *
 *	@mfunc
 *		Initialize Run Ptrs of this rich-text ptr to correspond to
 *		document given by ped and to cp given by cp.
 */
void CRchTxtPtr::InitRunPtrs()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::InitRunPtrs");
	AssertSz(GetPed(), "RTP::InitRunPtrs: illegal GetPed()");

	LONG		cp = GetCp();
	CTxtStory *	pStory = GetPed()->GetTxtStory();
	LONG		cchText = pStory->GetTextLength();
												// If there's RichData,
	if(pStory->_pCFRuns)						//  initialize format-run ptrs
	{
		_rpCF.SetRunArray((CRunArray *)pStory->_pCFRuns);
		_rpCF.BindToCp(cp, cchText);
	}
	if(IsRich() && pStory->_pPFRuns)
	{
		_rpPF.SetRunArray((CRunArray *)pStory->_pPFRuns);
		_rpPF.BindToCp(cp, cchText);
	}
}

/*
 *	CRchTxtPtr::SetRunPtrs(cp, cpFrom)
 *
 *	@mfunc set Run Ptrs of this rich-text ptr to correspond to cp
 *
 *	@rdesc
 *			TRUE unless cp is outside of doc (in which case RunPtrs are
 *			set to nearest document end).
 */
void CRchTxtPtr::SetRunPtrs(
	LONG cp,				// @parm character position to move RunPtrs to
	LONG cpFrom)			// @parm cp to start with
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetRunPtrs");

	if(cpFrom && 2*cp >= cpFrom)
	{
		_rpCF.Move(cp - cpFrom);
		_rpPF.Move(cp - cpFrom);
	}
	else
	{
		LONG cchText = GetTextLength();
		_rpCF.BindToCp(cp, cchText);
		_rpPF.BindToCp(cp, cchText);
	}
}

/*
 *	CRchTxtPtr::ExpandRangeFormatting(cchRange,	cchMove, &cchAdvance)
 *
 *	@mfunc
 *		In BiDi scenario, it's possible that updating a character affects the
 *		level of the others. Such case should only happen when number is involved.
 *
 *		Example: (AN)"11:30" changing '3' to 'x' will change the level of
 *		colon from 2 to 1. Accordingly return cch back to safe itemization
 *
 *	@rdesc
 *		cch back to safe itemization
 */
LONG CRchTxtPtr::ExpandRangeFormatting(
	LONG	cchRange,		// in: original length
	LONG	cchMove,		// in: number of chars moved after replacement
	LONG &	cchAdvance)		// out: extra chars added to range after expanding
{
	LONG	cchBackup = 0;
	
	cchAdvance = 0;

	if (_rpCF.IsValid())
	{
   		CTxtPtr		tp(_rpTX);
		if (!IsRich())
		{
			cchBackup = tp.FindEOP(tomBackward);
			tp.Move(-cchBackup + cchRange);
			cchAdvance = tp.FindEOP(tomForward);
		}
		else
		{
			CFormatRunPtr	rp(_rpCF);
			LONG			cp = GetCp();
	
			if (cchMove < 0)
			{
				// <cchMove> count of chars to be moved down to next paragraph
				cchBackup = cchMove;
			}
			else if (cchMove > 0)
			{
				// <cchMove> count of chars to be moved up to previous paragraph
				cchAdvance = cchMove;
			}
				
			// Advancing/Backing up 2 adjacent runs seems to be sufficient for now.
			if (cchBackup == 0)
			{
				rp.AdjustBackward();
				cchBackup = -rp.GetIch();
				if (rp.PrevRun())
					cchBackup -= rp.GetCchLeft();
				rp.Move(-cchBackup);		// Restore position
			}
			// Move run pointer to end of range
			rp.Move(cchRange);
			tp.SetCp(cp + cchRange);
			if (cchAdvance == 0 && !tp.IsAtEOP())
			{
				rp.AdjustForward();

				cchAdvance += rp.GetCchLeft();
				if (rp.NextRun())
					cchAdvance += rp.GetCchLeft();
			}
		}
	}
	return cchBackup;
}


/*
 *	CRchTxtPtr::ItemizeReplaceRange(cchUpdate, cchMove, publdr, fUnicodeBidi)
 *
 *	@mfunc
 *		Find out the exact range to be itemized after calling :ReplaceRange
 *
 *	@rdesc
 *		result from ItemizeRuns.
 *		Guarantee *this* pointer wont move.
 */
BOOL CRchTxtPtr::ItemizeReplaceRange(
	LONG			cchUpdate,
	LONG			cchMove,		// Count of chars moved after replacing
	IUndoBuilder*	publdr,			//  (they need reitemizing)
	BOOL			fUnicodeBidi)
{
    BOOL	fr = FALSE;

	if (GetPed()->IsComplexScript())
	{
		Assert (cchUpdate >= 0);	// the range after ReplaceRange must be degenerate

		CTxtPtr	tp(_rpTX);
		LONG 	cp = GetCp();
		LONG	cpStart, cpEnd;
        BOOL    fNonUnicodeBidiRecurse = FALSE;
		BOOL	fUseCtxLevel = FALSE;

		tp.Move(-cchUpdate);
		if (cchUpdate > 0 && GetPed()->IsRich() && fUnicodeBidi)
        {
			cpStart = cpEnd = cp;
			cpStart -= cchUpdate;

			if (GetPed()->IsBiDi())
			{
				// Fix for 7094 : Don't look at the incoming text for clues
				// fUseCtxLevel = TRUE;

				// Recurse with non-BiDi, so the run preceding/succeeding this chunk get updated
				fNonUnicodeBidiRecurse = TRUE;
			}
		}
		else
		{
			tp.FindWhiteSpaceBound(cchUpdate, cpStart, cpEnd,
								!GetPed()->IsRich() ? FWS_BOUNDTOPARA : 0);
		}

		if (cchMove < 0)
		{
			// <cchMove> number of text -before- the replaced range
			// moves down to the next paragraph.
			cpStart = max(cp - cchUpdate + cchMove, 0);
		}
		else if (cchMove > 0)
		{
			// <cchMove> number of text -after- the replaced range
			// moves up to the previous paragraph.
			cpEnd = min(cp + cchMove, GetPed()->GetTextLength());
		}

		{
			CTxtRange	rg(*this, 0);

			rg.Set(cpEnd, cpEnd - cpStart);

			fr = rg.ItemizeRuns(publdr, fUnicodeBidi, fUseCtxLevel);			

			// set pointer back to original cp
	
			// We cant use copy operator here since itemization changes format run.
			// It would cause invariant failure in _rpCF.
			cp -= rg.GetCp();
			_rpCF = rg._rpCF;
			_rpCF.Move(cp);
	
			// ItemizeRuns invalidates rg._rpPF so that the paraformat run becomes valid
			// and we need to advance it to the current cp.
			_rpPF = rg._rpPF;
			_rpPF.Move(cp);

			// Perf note: We dont want the range to be around when we recurse
			// since a range is a notification sink.
		}

		// Run itemization to the same range, this time forces it to be non-Bidi.
		if (fr && fNonUnicodeBidiRecurse)
			fr = ItemizeReplaceRange(cchUpdate, 0, publdr, FALSE);
	}
	return fr;
}


/*
 *	CRchTxtPtr::ReplaceRangeFormatting(cchOld, cchNew, iFormat, publdr,
 *									   ppaeCF, ppaePF, cchMove, cchPrevEOP,
 *									   cchNextEOP, cchSaveBefore, cchSaveAfter)
 *	@mfunc
 *		Replace character and paragraph formatting at this text pointer
 *		using CCharFormat with index iFormat
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@devnote
 *		Moves _rpCF and _rpPF to end of replaced text and moves format arrays.
 *		CCharFormat for iFormat is fully configured, i.e., no NINCHes
 */
LONG CRchTxtPtr::ReplaceRangeFormatting(
	LONG		cchOld,		  //@parm Length of range to replace
	LONG		cchNew,		  //@parm Length of replacement text
	LONG		iFormat,	  //@parm Char format to use
	IUndoBuilder *publdr,	  //@parm UndoBuilder to receive antievents
	IAntiEvent **ppaeCF,	  //@parm Where to return 'extra' CF anti-events
	IAntiEvent **ppaePF,	  //@parm Where to return extra PF anti-events
	LONG		cchMove,	  //@parm cch to move between PF runs
	LONG		cchPrevEOP,	  //@parm cch from _cp back to prev EOP
	LONG		cchNextEOP,	  //@parm cch from _cp up to next EOP
	LONG		cchSaveBefore,//@parm cch backup for BiDi
	LONG		cchSaveAfter) //@parm cch advance for BiDi
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRangeFormatting");

	LONG				cp = GetCp();				
	LONG				cchText = GetTextLength() + cchNew - cchOld;
	LONG				iRunMerge	= 0;
	ICharFormatCache *	pcfc = GetCharFormatCache();
	IParaFormatCache *	ppfc = GetParaFormatCache();

	AssertSz(cchOld >= 0,
		"CRchTxtPtr::ReplaceRangeFormatting: Illegal cchOld");

	if(_rpCF.IsValid())
	{
		iRunMerge = _rpCF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		Assert (cchSaveBefore <= 0 && cchSaveAfter >= 0);
		if(cchOld + cchSaveAfter - cchSaveBefore > 0)
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				// Include previous cchSaveBefore chars
				_rpCF.Move(cchSaveBefore);
				*ppaeCF = gAEDispenser.CreateReplaceFormattingAE(GetPed(),
							cp + cchSaveBefore, _rpCF, cchSaveAfter + cchOld - cchSaveBefore,
							pcfc, CharFormat);
				// Restore _rpCF (we just want to save value not delete it)
				_rpCF.Move(-cchSaveBefore);
			}
			if(cchOld)							// Delete/modify CF runs <-->
				_rpCF.Delete(cchOld, pcfc, 0);	//  to cchOld chars
		}
		// If we deleted all of text in story, don't bother adding a new
		// run.	Else insert/modify CF runs corresponding to cchNew chars
		//
		// In a plain-text control, there is no final EOP; hence the test
		// for equality.
		if(cchNew > 1 || cchNew && cchOld <= GetTextLength())
			_rpCF.InsertFormat(cchNew, iFormat, pcfc);

		if((cchOld || cchNew) && _rpCF.IsValid())// Deleting all text
		{										//  invalidates _rpCF
			_rpCF.AdjustForward();
			_rpCF.MergeRuns(iRunMerge, pcfc);
			_rpCF.BindToCp(cp + cchNew, cchText);
		}
	}

	if(_rpPF.IsValid())
	{
		_rpPF.AdjustForward();					// Be absolutely sure that
												//  PF runs end with EOPs
		iRunMerge = _rpPF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		if(cchOld)								// Delete cchOld from PF runs
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				CFormatRunPtr rp(_rpPF);

				rp.Move(cchPrevEOP);
				*ppaePF = gAEDispenser.CreateReplaceFormattingAE(GetPed(),
								cp + cchPrevEOP, rp, cchNextEOP - cchPrevEOP,
								ppfc, ParaFormat);
			}
		    _rpPF.Delete(cchOld, ppfc, cchMove);
		}

		if(_rpPF.IsValid())						// Deleting all text
		{										//  invalidates _rpPF
			_rpPF.AdjustForward();
			_rpPF.GetRun(0)->_cch += cchNew;	// Insert cchNew into current
			_rpPF._ich	+= cchNew;				//  PF run
			if(cchOld || cchNew)
			{
				_rpPF.MergeRuns(iRunMerge, ppfc);
				_rpPF.BindToCp(cp + cchNew, cchText);
			}
		}
	}
	return cchNew;
}

/*
 *	CRchTxtPtr::ExtendFormattingCRLF()
 *	
 *	@mfunc
 *		Use the same CCharFormat and CParaFormat indices for the EOP at
 *		this text ptr as those immediately preceding it.
 *
 *	@devnote
 *		Leaves this text ptr's format ptrs at run you get from AdjustBackward
 *		since this run ends up including the new text.
 */	
void CRchTxtPtr::ExtendFormattingCRLF()
{
	LONG		cch = GetTextLength() - GetPed()->GetAdjustedTextLength();
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

	_rpCF.AdjustFormatting(cch, GetCharFormatCache());
	if(_rpPF.IsValid())
	{
		_rpPF.AdjustBackward();
		if(!InTable())
			_rpPF.AdjustFormatting(cch, GetParaFormatCache());
		_rpPF.AdjustForward();
	}

	if(pnm)
	{
		// We assume that Cch is positive (or zero) here
		Assert(cch >= 0);
		pnm->NotifyPostReplaceRange((ITxNotify *)this, CP_INFINITE, 0, 0,
				GetCp(), GetCp() + cch);
	}
}

/*
 *	CRchTxtPtr::IsRich()
 *	
 *	@mfunc
 *		Determine whether rich-text operation is operable
 *	
 *	@rdesc
 *		TRUE if associated CTxtEdit::_fRich = 1, i.e., control is allowed
 *		to be rich.
 */
BOOL CRchTxtPtr::IsRich()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::IsRich");

	return GetPed()->IsRich();
}

/*
 *	CRchTxtPtr::Check_rpCF()
 *	
 *	@mfunc
 *		enable _rpCF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpCF is enabled
 */
BOOL CRchTxtPtr::Check_rpCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpCF");

	if(_rpCF.IsValid())
		return TRUE;

	if(!_rpCF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pCFRuns)))
	{
		return FALSE;
	}

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	//  that
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 *	CRchTxtPtr::Check_rpPF()
 *	
 *	@mfunc
 *		enable _rpPF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpPF is enabled
 */
BOOL CRchTxtPtr::Check_rpPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpPF");

	if(_rpPF.IsValid())
		return TRUE;

	if(!IsRich())
		return FALSE;

	if(!_rpPF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pPFRuns)))
	{
		return FALSE;
	}

	if (IsParaRTL())
		_rpPF.GetRun(0)->_level._value = 1;		// Set default paragraph base level

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	// of the change.
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 * CRchTxtPtr::FindWordBreak(action, cpMost)
 *
 *	@mfunc
 *		Same as CTxtPtr::FindWordBreak(), but moves the whole rich text ptr
 *
 *	@rdesc
 *		cch this rich text ptr is moved
 */
LONG CRchTxtPtr::FindWordBreak(
	INT		action,		//@parm Kind of word break to find
	LONG	cpMost)		//@parm Limiting character position
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindWordBreak");

	LONG cch = _rpTX.FindWordBreak(action, cpMost);
	_rpCF.Move(cch);
	_rpPF.Move(cch);

	return cch;
}

/*
 *	CRchTxtPtr::BindToCp(dwNewCp)
 *
 *	@mfunc
 *		Set cp to new value and recalculate that new position.
 */
void CRchTxtPtr::BindToCp(
	LONG cp)			// @parm new cp for rich text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::BindToCp");

	_rpTX.BindToCp(cp);				// Recalculate cp for plain text

	// Use the InitRunPtrs routine so that the run pointers will get
	// re-initialized and rebound with the correct run array.  The
	// run array formerly used (if any at all) is not necessarily valid
	// when this function is called.

	InitRunPtrs();

	// Do invariant testing at end because this fixes up the rich text
	// pointer in the face of backing store changes.
	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::CheckFormatRuns ()
 *
 *	@mfunc
 *		Check the format runs against what's in CTxtStory.  If
 *		different, forces a rebind to <p cp>
 */
void CRchTxtPtr::CheckFormatRuns()
{
	CTxtStory *pStory = GetPed()->GetTxtStory();

	if (pStory->GetCFRuns() != (CFormatRuns *)_rpCF._pRuns ||
		pStory->GetPFRuns() != (CFormatRuns *)_rpPF._pRuns)
	{
		InitRunPtrs();
	}

	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::ChangeCase(cch, Type, publdr)
 *	
 *	@mfunc
 *		Change case of cch chars starting at this text ptr according to Type,
 *		which has the possible values:
 *
 *		tomSentenceCase	= 0: capitalize first letter of each sentence
 *		tomLowerCase	= 1: change all letters to lower case
 *		tomUpperCase	= 2: change all letters to upper case
 *		tomTitleCase	= 3: capitalize the first letter of each word
 *		tomToggleCase	= 4: toggle the case of each letter
 *	
 *	@rdesc
 *		TRUE iff a change occurred
 *
 *	@devnote
 *		Since this routine only changes the case of characters, it has no
 *		effect on rich-text formatting.  However it is part of the CRchTxtPtr
 *		class in order to notify the display of changes.  CTxtRanges are also
 *		notified just in case the text blocks are modified.
 */
BOOL CRchTxtPtr::ChangeCase (
	LONG		  cch,			//@parm # chars to change case for
	LONG		  Type,			//@parm Type of change case command
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive anti-event
								//  	for any replacements
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ChangeCase");
	_TEST_INVARIANT_

#define	BUFFERLEN	256

	LONG	cchChunk, cchFirst, cchGet, cchLast, cchRep;
	LONG	cpSave = GetCp();
	BOOL	fAlpha, fToUpper, fUpper;			// Flags controling case change
	BOOL	fChange = FALSE;					// No change yet
	BOOL	fStart = TRUE;						// Start of Word/Sentence
	TCHAR *	pch;								// Ptr to walk rgCh with
	WORD *	pType;								// Ptr to walk rgType with
	WCHAR	rgCh[BUFFERLEN];					// Char buffer to work in
	WORD	rgType[BUFFERLEN];					// C1_TYPE array for rgCh

	if( GetCp() )
	{
		if( Type == tomSentenceCase )
			fStart = _rpTX.IsAtBOSentence();

		else if( Type == tomTitleCase )
		{
			// Check to see if we are at the beginning of
			// a word.  This is the case if the character preceding
			// our current position is white space.
			fStart = IsWhiteSpace(GetPrevChar());
		}
	}
	if(cpSave + cch > GetPed()->GetAdjustedTextLength())
		cch = GetPed()->GetAdjustedTextLength() - cpSave;

	// Handle pre-replace range notifications.  This method is very
	// useful for delayed rendering of data copied to the clipboard.
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
	if(pnm)
	{
		pnm->NotifyPreReplaceRange((ITxNotify *)this, cpSave, cch,
			cch, cpSave, cpSave + cch);
	}
	while(cch > 0)								// Do 'em all (or as many as
	{											//  in story)
		cchChunk = min(BUFFERLEN, cch);			// Get next bufferful
		cch -= cchChunk;						// Decrement the count
		cchGet = _rpTX.GetText(cchChunk, rgCh);	// Manipulate chars in buffer
		if(cchGet < cchChunk)					//  (for undo, need to use
		{										//  ReplaceRange())
			cch = 0;							// No more chars in story,
			if(!cchGet)							//  so we'll be done
				break;							// We're done already
			cchChunk = cchGet;					// Something in this chunk
		}

		W32->GetStringTypeEx(0, CT_CTYPE1, rgCh,// Find out whether chars are
						cchChunk, rgType);		//  UC, LC, or neither
		cchLast = 0;							// Default nothing to replace
		cchFirst = -1;
		for(pch = rgCh, pType = rgType;			// Process buffered chars
			cchChunk;
			cchChunk--, pch++, pType++)
		{
			fAlpha = *pType & (C1_UPPER | C1_LOWER); // Nonzero if UC or LC
			fUpper = (*pType & C1_UPPER) != 0;	// TRUE if UC
			fToUpper = fStart ? TRUE : fUpper;	// capitalize first letter of a
												// sentence
			switch(Type)
			{									// Decide whether to change
			case tomLowerCase:					//  case and determine start
				fToUpper = FALSE;				//  of word/sentence for title
				break;							//  and sentence cases

			case tomUpperCase:
				fToUpper = TRUE;
				break;

			case tomToggleCase:
				fToUpper = !fUpper;
				break;

			case tomSentenceCase:
				if(*pch == TEXT('.'))			// If sentence terminator,
					fStart = TRUE;				//  capitalize next alpha
				if(fAlpha)						// If this char is alpha, next
					fStart = FALSE;				//  char can't start a
				break;							//  sentence

			case tomTitleCase:					// If this char is alpha, next
				fStart = (fAlpha == 0);			//  char can't start a word
				break;
			default:
				return FALSE;
			}

			if(fAlpha && (fToUpper ^ fUpper))	// Only change case if it
			{									//  makes a difference (saves
				if(fToUpper)					//  on system calls and undos)
					CharUpperBuff(pch, 1);
				else
					CharLowerBuff(pch, 1);

				fChange = TRUE;					// Return value: change made
				if( cchFirst == -1 )			// Save cch of unchanged
					cchFirst = cchGet-cchChunk;	//  leading string
				cchLast = cchChunk - 1;			// Save cch of unchanged
			}									//  trailing string
		}
		if( cchFirst == -1 )
		{
			Assert(cchLast == 0);
			cchFirst = cchGet;
		}
		Move(cchFirst);							// Skip unchanged leading
		cchGet -= cchFirst + cchLast;			//  string. cchGet = cch of
												//  changed span.
		cchRep = _rpTX.ReplaceRange(cchGet, cchGet, rgCh + cchFirst, publdr, NULL, NULL);
		_rpCF.Move(cchRep);
		_rpPF.Move(cchRep);
		Assert(cchRep == cchGet);
		Move(cchLast);							// Skip unchanged trailing
	}											//  string
	if(pnm)
	{
		cch = GetCp() - cpSave;
		pnm->NotifyPostReplaceRange((ITxNotify *)this, cpSave, cch,
			cch, cpSave, GetCp());
	}
	return fChange;
}

// The following defines a mask for Units implemented by UnitCounter()
#define IMPL ((1 << tomCharacter)  + (1 << tomWord) + (1 << tomSentence) + \
			  (1 << tomParagraph)  + (1 << tomLine) + (1 << tomStory) +	\
			  (1 << tomCharFormat) + (1 << tomParaFormat) + (1 << tomObject) + \
			  (1 << tomPage)	   + (1 << tomCell))
 
/*
 *	CRchTxtPtr::UnitCounter (Unit, &cUnit, cchMax, fNotAtBOL)
 *
 *	@mfunc
 *		Helper function to count chars in <p cUnit> Units defined by <p Unit>
 *		<p cUnit> is a signed count.  If it extends beyond either end of the
 *		story, count up to that end and update <p cUnit> accordingly.  If
 *		<p cchMax> is nonzero, stop counting when the count exceeds <p cchMax>
 *		in magnitude.
 *
 *	@rdesc
 *		If unit is implemented, return cch corresponding to the units counted
 *		(up to a maximum magnitude of <p cchMax>) and update cUnit;
 *		else return tomForward to signal unit not implemented and cUnit = 0.
 *		If unit is implemented but unavailable, e.g., tomObject with no
 *		embedded objects, return tomBackward.
 *
 *	@devnote
 *		This is the basic engine used by the TOM CTxtRange::Move() and Index()
 *		methods.
 */
LONG CRchTxtPtr::UnitCounter (
	LONG	Unit,				//@parm Type of unit to count
	LONG &	cUnit,				//@parm Count of units to count chars for
	LONG	cchMax,				//@parm Maximum character count
	BOOL	fNotAtBOL)			//@parm TRUE if _fSel && _fCaretNotAtBOL
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CRchTxtPtr::UnitCounter");

	LONG	action;				// Gives direction and tomWord commands
	LONG	cch;				// Collects cch counted
	LONG	cchText = GetTextLength();
	LONG	cp = GetCp();
	LONG	iDir = cUnit > 0 ? 1 : -1;
	LONG	j;					// For-loop index
	CDisplay *pdp;				// Used for tomLine case

	// Valid attribute Units are high bit plus any combo of CFE_xxx. 
	// CFE_REVISED is most significant value currently defined.
	if(Unit > 0 && !((IMPL >> Unit) & 1) ||
	   Unit < 0 && (Unit & ~(2*CFM_REVISED - 1 + 0x80000000)))
	{
		return tomForward;						// Report invalid Unit
	}

	if(!cUnit)									// Nothing to count
		return 0;

	if(cchMax <= 0)
		cchMax = tomForward;					// No cch limit

	if(cUnit < 0)
		cchMax = min(cp, cchMax);				// Don't go before doc start

	else if(cchMax > cchText - cp)
		cchMax = cchText - cp;					// Don't go beyond doc end

	if(Unit < 0)
	{
		CCFRunPtr rp(*this);
		cch = rp.CountAttributes(cUnit, cchMax, cp, cchText, Unit);
		goto finish;
	}

	switch(Unit)
	{
	case tomCharacter:							// Smallest Unit
		cp += cUnit;							// Requested new cp
		ValidateCp(cp);							// Make sure it's OK
		cch = cUnit = cp - GetCp();				// How many cch, cUnits
		break;									//  actually moved

	case tomStory:								// Largest Unit
		cch = (cUnit > 0) ? cchText - cp : -cp;	// cch to start of story
		cUnit = cch ? iDir : 0;					// If already at end/start,
		break;									//  of story, no count

	case tomCharFormat:							// Constant CHARFORMAT
		cch = _rpCF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomParaFormat:							// Constant PARAFORMAT
		cch = _rpPF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomObject:
		if(!GetObjectCount())					// No objects: can't move, so
		{
			cUnit = 0;							//  set cUnit = 0 and
			return tomBackward;					//  signal Unit unavailable
		}
		cch = GetPed()->_pobjmgr->CountObjects(cUnit, GetCp());
		break;

	case tomCell:
		{
			CTxtRange rg(*this);
			cch = rg.CountCells(cUnit, cchMax);
		}
		break;

	case tomScreen:								// Could be supported 
		if(!GetPed()->IsInPageView())			//  in Normal View using 
			return tomBackward;					//  ITextSelection::Down()
		Unit = tomPage;							// In Page View, it's an alias

	case tomPage:
	case tomLine:
		pdp = GetPed()->_pdp;
		if(pdp)									// If this story has a display
		{										//  use a CLinePtr
			CLinePtr rp(pdp);
			//REVIEW (keithcu) This should be fixed. We can't trust the client to pass
			//down an optimal cchMax. For best results, we should have a CountRuns and CountPages
			//recalc as needed when moving down through the document.
			pdp->WaitForRecalc(min(cp + cchMax, cchText), -1);
			rp.SetCp(cp, FALSE);
			fNotAtBOL = fNotAtBOL && rp.GetLineIndex() &&
						(Unit == tomLine || rp->_fFirstOnPage);
			cch = (Unit == tomLine || !cUnit || !rp.IsValid())
				? rp.CountRuns (cUnit, cchMax, cp, cchText)
				: rp.CountPages(cUnit, cchMax, cp, cchText);

			if (cch == tomBackward)
				return tomBackward;
			
			if(fNotAtBOL && cUnit < 0)
				cUnit++;						// Keep on same line/page as selection
			break;
		}										
		if(Unit == tomPage)
		{										// No display: no pagination
			cUnit = 0;
			return tomBackward;					
		}										// For tomLine, fall thru to
												//  treat as tomPara
	default:									// tp dependent cases
	  {											// Block to contain tp() which
		CTxtPtr tp(_rpTX);						//  takes time to construct

		if (cUnit < 0)							// Counting backward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDLEFT : tomBackward;
		}
		else									// Counting forward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDRIGHT : tomForward;
		}
	
		for (cch = 0, j = cUnit; j && abs(cch) < cchMax; j -= iDir)
		{
			cp = tp.GetCp();					// Save starting cp for
			switch (Unit)						//  calculating cch for this
			{									//  Unit
			case tomWord:
				tp.FindWordBreak(action);
				break;
	
			case tomSentence:
				tp.FindBOSentence(action);
				break;
		
			case tomLine:						// Story has no line array:
			case tomParagraph:					//  treat as tomParagraph
				tp.FindEOP(action);
				break;
		
			default:
				cUnit = 0;
				return tomForward;				// Return error
			}
			if(tp.GetCp() - cp == 0)			// No count:
				break;							//  don't decrement cUnit
			cch += tp.GetCp() - cp;
		}
		cUnit -= j;								// Discount any runs not
	  }											//  counted if |cch| >= cchMax
	}

finish:
	if(abs(cch) > cchMax)						// Keep cch within requested
	{											//  limit
		cch = cch > 0 ? cchMax : -cchMax;
		if(Unit == tomCharacter)
			cUnit = cch;
	}		

	Move(cch);									// Move to new position
	return cch;									// Total cch counted
}

/*
 *	Notes on RichEdit 1.0 mode:
 *
 *	CF_UNICODETEXT should not be used in RichEdit 1.0 mode.  \uN should use
 *	the alternative.
 *
 *	CleanseAndReplaceRange() and the RTF reader need to ensure that any
 *	Unicode chars entered belong to a CharSet and stamp it accordingly.
 *	If no CharSet exists for the character, then blank should be used.
 */

/*
 *	CRchTxtPtr::GetCachFromCch(cch)
 *
 *	@mfunc
 *		Return count of A chars corresponding to cch W chars starting at
 *		this text ptr.  On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of A chars between this text ptr and cp
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCachFromCch(
	LONG cch)		//@parm Count of chars to check
{
	BYTE		 iCharRep;
	LONG		 cach = 0;				// No ach counted yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cch > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		iCharRep = pCF->_iCharRep;
		if (!IsFECharRep(iCharRep) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cch);
			cach  += cchRun;			// SBCS run or DBCS stored as
			cch   -= cchRun;			//  one byte per char
			Move(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cch > 0 && cchValid--; cch1++)
		{
			cch--;
			ch = *pch++;
			if(IN_RANGE(128, ch, 0xFFF0) &&
				(iCharRep != SHIFTJIS_INDEX || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach++;
			}
		}
		cach += cch1;
		Move(cch1);
	}
	return cach;
}

/*
 *	CRchTxtPtr::GetCchFromCach(cach)
 *
 *	@mfunc
 *		Return count of W chars corresponding to cach A chars starting at this
 *		text ptr. On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of W chars corresponding to cach A chars starting at this tp.
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCchFromCach(
	LONG cach)		//@parm Count of ach's starting at this text ptr
{
	BYTE		 iCharRep;
	LONG		 cch = 0;				// No ch's yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cach > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		iCharRep = pCF->_iCharRep;
		if (!IsFECharRep(iCharRep) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cach);	// SBCS run or DBCS stored as
			cach -= cchRun;				//  one byte per char
			cch  += cchRun;
			Move(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cach > 0 && cchValid--; cch1++)
		{
			cach--;
			ch = *pch++;
			if(IN_RANGE(128, ch, 0xFFF0) &&
				(iCharRep != SHIFTJIS_INDEX || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach--;
			}
		}
		cch += cch1;
		Move(cch1);
	}
	return cch;
}

/*
 *	CRchTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CRchTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Zombie");

	_rpTX.Zombie();
	_rpCF.SetToNull();
	_rpPF.SetToNull();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtfread.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFREAD.CPP - RichEdit RTF reader (w/o objects) |
 *
 *		This file contains the nonobject code of RichEdit RTF reader.
 *		See rtfread2.cpp for embedded-object code.
 *
 *	Authors:<nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0 w/o objects:  Murray Sargent
 *		Lots of enhancements/maintenance: Brad Olenick
 *
 *	@devnote
 *		sz's in the RTF*.cpp and RTF*.h files usually refer to a LPSTRs,
 *		not LPWSTRs.
 *
 *	@todo
 *		1. Unrecognized RTF. Also some recognized won't round trip <nl>
 *		2. In font.c, add overstrike for CFE_DELETED and underscore for
 *			CFE_REVISED.  Would also be good to change color for CF.bRevAuthor
 *
 *	Copyright (c) 1995-2002, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "_util.h"
#include "_font.h"
#include "_disp.h"

ASSERTDATA

/*
 *		Global Variables
 */

#define	PFM_ALLRTF		(PFM_ALL2 | PFM_COLLAPSED | PFM_OUTLINELEVEL | PFM_BOX)

// for object attachment placeholder list
#define cobPosInitial 8
#define cobPosChunk 8

#if CFE_SMALLCAPS != 0x40 || CFE_ALLCAPS != 0x80 || CFE_HIDDEN != 0x100 \
 || CFE_OUTLINE != 0x200  || CFE_SHADOW != 0x400
#error "Need to change RTF char effect conversion routines
#endif

// for RTF tag coverage testing
#if defined(DEBUG) && !defined(NOFULLDEBUG)
#define TESTPARSERCOVERAGE() \
	{ \
		if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0)) \
		{ \
			TestParserCoverage(); \
		} \
	}
#define PARSERCOVERAGE_CASE() \
	{ \
		if(_fTestingParserCoverage) \
		{ \
			return ecNoError; \
		} \
	}
#define PARSERCOVERAGE_DEFAULT() \
	{ \
		if(_fTestingParserCoverage) \
		{ \
			return ecStackOverflow; /* some bogus error */ \
		} \
	}
#else
#define TESTPARSERCOVERAGE()
#define PARSERCOVERAGE_CASE()
#define PARSERCOVERAGE_DEFAULT()
#endif

static WCHAR szRowEnd[] = {ENDFIELD, CR, 0};
static WCHAR szRowStart[]	= {STARTFIELD, CR, 0};
WCHAR pchSeparateField[] = {SEPARATOR, 'F'};
WCHAR pchStartField[]	= {STARTFIELD, 'F'};

// FF's should not have paragraph number prepended to them
inline BOOL CharGetsNumbering(WORD ch) { return ch != FF; }

// V-GUYB: PWord Converter requires loss notification.
#ifdef REPORT_LOSSAGE
typedef struct
{
    IStream *pstm;
    BOOL     bFirstCallback;
    LPVOID  *ppwdPWData;
    BOOL     bLoss;
} LOST_COOKIE;
#endif


//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFGetFromStream (
	RTFREADOLESTREAM *OLEStream,	//@parm OleStream
	void FAR *		  pvBuffer,		//@parm Buffer to read 
	DWORD			  cb)			//@parm Bytes to read
{
	return OLEStream->Reader->ReadData ((BYTE *)pvBuffer, cb);
}

DWORD CALLBACK RTFGetBinaryDataFromStream (
	RTFREADOLESTREAM *OLEStream,	//@parm OleStream
	void FAR *		  pvBuffer,		//@parm Buffer to read 
	DWORD			  cb)			//@parm Bytes to read
{
	return OLEStream->Reader->ReadBinaryData ((BYTE *)pvBuffer, cb);
}


//============================ STATE Structure =================================
/*
 *	STATE::AddPF(PF, lDocType, dwMask, dwMask2)
 *
 *	@mfunc
 *		If the PF contains new info, this info is applied to the PF for the
 *		state.  If this state was sharing a PF with a previous state, a new
 *		PF is created for the state, and the new info is applied to it.
 *
 *	@rdesc
 *		TRUE unless needed new PF and couldn't allocate it 
 */
BOOL STATE::AddPF(
	const CParaFormat &PF,	//@parm Current RTFRead _PF
	LONG lDocType,			//@parm	Default doc type to use if no prev state
	DWORD dwMask,			//@parm Mask to use
	DWORD dwMask2)			//@parm Mask to use
{
	// Create a new PF if:  
	//	1.  The state doesn't have one yet
	//	2.  The state has one, but it is shared by the previous state and
	//		there are PF deltas to apply to the state's PF
	if(!pPF || dwMask && pstatePrev && pPF == pstatePrev->pPF)
	{
		Assert(!pstatePrev || pPF);

		pPF = new CParaFormat;
		if(!pPF)
			return FALSE;

		// Give the new PF some initial values - either from the previous
		// state's PF or by CParaFormat initialization
		if(pstatePrev)
		{
			// Copy the PF from the previous state
			*pPF = *pstatePrev->pPF;
			dwMaskPF = pstatePrev->dwMaskPF;
		}
		else
		{
			// We've just created a new PF for the state - there is no
			// previous state to copy from.  Use default values.
			pPF->InitDefault(lDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
			dwMaskPF = PFM_ALLRTF;
			dwMaskPF2 = PFM2_TABLEROWSHIFTED;
		}
	}

	// Apply the new PF deltas to the state's PF
	if(dwMask)
	{
		if(dwMask & PFM_TABSTOPS)				// Don't change _iTabs here
		{
			pPF->_bTabCount = PF._bTabCount;
			dwMask &= ~PFM_TABSTOPS;
		}
		pPF->Apply(&PF, dwMask, dwMaskPF2);
	}

	return TRUE;
}

/*
 *	STATE::DeletePF()
 *
 *	@mfunc
 *		If the state's PF is not shared by the previous state, the PF for this
 *		state is deleted.
 */
void STATE::DeletePF()
{
	if(pPF && (!pstatePrev || pPF != pstatePrev->pPF))
		delete pPF;

	pPF = NULL;
}

/*
 *	STATE::SetCodePage(CodePage)
 *
 *	@mfunc
 *		If current nCodePage is CP_UTF8, use it for all conversions (yes, even
 *		for SYMBOL_CHARSET). Else use CodePage.
 */
void STATE::SetCodePage(
	LONG CodePage)
{
	if(nCodePage != CP_UTF8)
		nCodePage = CodePage;
}

//============================ CRTFRead Class ==================================
/*
 *	CRTFRead::CRTFRead(prg, pes, dwFlags)
 *
 *	@mfunc
 *		Constructor for RTF reader
 */
CRTFRead::CRTFRead (
	CTxtRange *		prg,			//@parm CTxtRange to read into
	EDITSTREAM *	pes,			//@parm Edit stream to read from
	DWORD			dwFlags			//@parm Read flags
)
	: CRTFConverter(prg, pes, dwFlags, TRUE)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::CRTFRead");

	Assert(prg->GetCch() == 0);

	//TODO(BradO):  We should examine the member data in the constructor
	//	and determine which data we want initialized on construction and
	//	which at the beginning of every read (in CRTFRead::ReadRtf()).

	_sDefaultFont		= -1;				// No \deff n control word yet
	_sDefaultLanguage	= INVALID_LANGUAGE;
	_sDefaultLanguageFE = INVALID_LANGUAGE;
	_sDefaultTabWidth	= 0;
	_sDefaultBiDiFont	= -1;
	_dwMaskCF			= 0;				// No char format changes yet
	_dwMaskCF2			= 0;
	_dwMaskPF			= 0;				// No char format changes yet
	_dwMaskPF2			= 0;				// No char format changes yet
	_fSeenFontTable		= FALSE;			// No \fonttbl yet
	_fCharSet			= FALSE;			// No \fcharset yet
	_fNon0CharSet		= FALSE;			// No nonANSI_CHARSET \fcharset yet
	_dwFlagsUnion		= 0;				// No flags yet
	_fNotifyLowFiRTF	= (_ped->_dwEventMask & ENM_LOWFIRTF) != 0;
	_fBody				= FALSE;			// Wait till something's inserted
	_pes->dwError		= 0;				// No error yet
	_cchUsedNumText		= 0;				// No numbering text yet
	_cTab				= 0;
	_pstateStackTop		= NULL;
	_pstateLast			= NULL;
	_szText				=
	_pchRTFBuffer		=					// No input buffer yet
	_pchRTFCurrent		=
	_pchRTFEnd			= NULL;
	_prtfObject			= NULL;
	_pcpObPos			= NULL;
	_bTabLeader			= 0;
	_bTabType			= 0;
	_bShapeNameIndex	= 0;
	_pobj				= 0;
	_fSymbolField		= FALSE;
	_fMac				= FALSE;
	_fNo_iTabsTable		= FALSE;
	_fRTLRow			= FALSE;
	_dwRowResolveFlags	= 0;
	_bTableLevelIP		= 0;
	_iTabsLevel1		= -1;
	InitializeTableRowParms();				// Initialize table parms

	// Does story size exceed the maximum text size? Be very careful to
	// use unsigned comparisons here since _cchMax has to be unsigned
	// (EM_LIMITTEXT allows 0xFFFFFFFF to be a large positive maximum
	// value). I.e., don't use signed arithmetic.
	DWORD cchAdj = _ped->GetAdjustedTextLength(); 
	_cchMax = _ped->TxGetMaxLength();

	if(_cchMax > cchAdj)
		_cchMax = _cchMax - cchAdj;			// Room left
	else
		_cchMax = 0;						// No room left

	ZeroMemory(_rgStyles, sizeof(_rgStyles)); // No style levels yet

	_iCharRepBiDi = 0;
	if(_ped->IsBiDi())
	{
		_iCharRepBiDi = ARABIC_INDEX;		// Default Arabic charset

		BYTE		  iCharRep;
		CFormatRunPtr rpCF(prg->_rpCF);

		// Look backward in text, trying to find a RTL CharRep.
		// NB: \fN with an RTL charset updates _iCharRepBiDi.
		do
		{
			iCharRep = _ped->GetCharFormat(rpCF.GetFormat())->_iCharRep;
			if(IsRTLCharRep(iCharRep))
			{
				_iCharRepBiDi = iCharRep;
				break;
			}
		} while (rpCF.PrevRun());
	}
	
	// Initialize OleStream
	RTFReadOLEStream.Reader = this;
	RTFReadOLEStream.lpstbl->Get = (DWORD (CALLBACK*)(LPOLESTREAM, void *, DWORD))
							   RTFGetFromStream;
	RTFReadOLEStream.lpstbl->Put = NULL;

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	_fTestingParserCoverage = FALSE;
	_prtflg = NULL;

	if(GetProfileIntA("RICHEDIT DEBUG", "RTFLOG", 0))
	{
		_prtflg = new CRTFLog;
		if(_prtflg && !_prtflg->FInit())
		{
			delete _prtflg;
			_prtflg = NULL;
		}
		AssertSz(_prtflg, "CRTFRead::CRTFRead:  Error creating RTF log");
	}
#endif // DEBUG
}

/*
 *	CRTFRead::HandleStartGroup()
 *	
 *	@mfunc
 *		Handle start of new group. Alloc and push new state onto state
 *		stack
 *
 *	@rdesc
 *		EC					The error code
 */
EC CRTFRead::HandleStartGroup()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleStartGroup");

	STATE *	pstate	   = _pstateStackTop;
	STATE *	pstateNext = NULL;

	if(pstate)									// At least one STATE already
	{											//  allocated
		Apply_CF();								// Apply any collected char
		// Note (igorzv) we don't Apply_PF() here so as not to change para 
		// properties before we run into \par i.e. not to use paragraph 
		// properties if we copy only one word from paragraph. We can use an
		// assertion here that neither we nor Word use end of group for
		// restoring paragraph properties. So everything will be OK with stack
		pstate->iCF = (SHORT)_prg->Get_iCF();	// Save current CF
		pstate = pstate->pstateNext;			// Use previously allocated
		if(pstate)								//  STATE frame if it exists
			pstateNext = pstate->pstateNext;	// It does; save its forward
	}											//  link for restoration below

	if(!pstate)									// No new STATE yet: alloc one
	{
		pstate = new STATE();
		if(!pstate)								// Couldn't alloc new STATE
			goto memerror;

		_pstateLast = pstate;					// Update ptr to last STATE
	}											//  alloc'd

	STATE *pstateGetsPF;

	// Apply the accumulated PF delta's to the old current state or, if there
	//	is no current state, to the newly created state.
	pstateGetsPF = _pstateStackTop ? _pstateStackTop : pstate;
	if(!pstateGetsPF->AddPF(_PF, _bDocType, _dwMaskPF, _dwMaskPF2))
		goto memerror;

	_dwMaskPF = _dwMaskPF2 = 0; 				// _PF contains delta's from
												//  *_pstateStackTop->pPF
	if(_pstateStackTop)							// There's a previous STATE
	{
		*pstate = *_pstateStackTop;				// Copy current state info
		// N.B.  This will cause the current and previous state to share
		// 	the same PF.  PF delta's are accumulated in _PF.  A new PF
		// 	is created for _pstateStackTop when the _PF deltas are applied.

		_pstateStackTop->pstateNext = pstate;
	}
	else										// Setup default for first state
	{
		pstate->nCodePage = IsUTF8 ? CP_UTF8 : _nCodePage;

		for(LONG i = ARRAY_SIZE(pstate->rgDefFont); i--; )
			pstate->rgDefFont[i].sHandle = -1;			// Default undefined associate
	}

	pstate->pstatePrev = _pstateStackTop;		// Link STATEs both ways
	pstate->pstateNext = pstateNext;
	_pstateStackTop = pstate;					// Push stack

done:
	TRACEERRSZSC("HandleStartGroup()", -_ecParseError);
	return _ecParseError;

memerror:
	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecStackOverflow;
	goto done;
}

/*
 *	CRTFRead::HandleEndGroup()
 *
 *	@mfunc
 *		Handle end of new group
 *
 *	@rdesc
 *		EC					The error code
 */
EC CRTFRead::HandleEndGroup()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndGroup");

	STATE *	pstate = _pstateStackTop;
	STATE *	pstatePrev;

	Assert(_PF._iTabs == -1);

	if(!pstate)									// No stack to pop
	{
		_ecParseError = ecStackUnderflow;
		goto done;
	}

	_pstateStackTop =							// Pop stack
	pstatePrev		= pstate->pstatePrev;

	if(!pstatePrev)
	{
		Assert(pstate->pPF);

		// We're ending the parse.  Copy the final PF into _PF so that 
		// subsequent calls to Apply_PF will have a PF to apply.
		_PF = *pstate->pPF;
//TODO honwch		_dwMaskPF = pstate->dwMaskPF;
		_PF._iTabs = -1;						// Force recache
		_PF._wEffects &= ~PFE_TABLE;
	}

	// Adjust the PF for the new _pstateStackTop and delete unused PF's.
	if(pstate->sDest == destParaNumbering || pstate->sDest == destParaNumText)
	{
		if(pstatePrev && pstate->pPF != pstatePrev->pPF)
		{
			// Bleed the PF of the current state into the previous state for
			// paragraph numbering groups
			Assert(pstatePrev->pPF);
			pstatePrev->DeletePF();
			pstatePrev->pPF = pstate->pPF;
			pstate->pPF = NULL;
		}
		else
			pstate->DeletePF();
		// N.B.  Here, we retain the _PF diffs since they apply to the
		// enclosing group along with the PF of the group we are leaving
	}
	else
	{
		// We're popping the state, so delete its PF and discard the _PF diffs
		Assert(pstate->pPF);
		pstate->DeletePF();

		// If !pstatePrev, we're ending the parse, in which case the _PF
		// structure contains final PF (so don't toast it).
		if(pstatePrev)
			_dwMaskPF = _dwMaskPF2 = 0;
	}

	if(pstatePrev)
	{
		LONG i;
		_dwMaskCF = _dwMaskCF2 = 0;				// Discard any CF deltas

		switch(pstate->sDest)
		{
		case destParaNumbering:
			// {\pn ...}
			pstatePrev->sIndentNumbering = pstate->sIndentNumbering;
			pstatePrev->fBullet = pstate->fBullet;
			break;

		case destObject:
			// Clear our object flags just in case we have corrupt RTF
			if(_fNeedPres)
			{
				_fNeedPres = FALSE;
				_fNeedIcon = FALSE;
				_pobj = NULL;
			}
			break;

		case destFontTable:
			if(pstatePrev->sDest == destFontTable)
			{
				// Leaving subgroup within \fonttbl group
				break;
			}

			// Leaving {\fonttbl...} group
			_fSeenFontTable = TRUE;

			// Default font should now be defined, so select it (this
			// creates CF deltas).
			SetPlain(pstate);

			if(_sDefaultFont != -1)
			{
				pstate->rgDefFont[DEFFONT_LTRCH].sHandle = _sDefaultFont;

				Assert(pstate->pstatePrev);
				if (pstate->pstatePrev)
				{
					pstate->pstatePrev->rgDefFont[DEFFONT_LTRCH].sHandle = _sDefaultFont;
					Assert(pstate->pstatePrev->pstatePrev == NULL);
				}
			}

			if(_sDefaultBiDiFont != -1)
			{
				// Validate default BiDi font since Word 2000 may choose
				// a nonBiDi font
				i = _fonts.Count();
				TEXTFONT *ptf = _fonts.Elem(0);
				for(; i-- && _sDefaultBiDiFont != ptf->sHandle; ptf++)
					;

				if(i < 0 || !IsRTLCharRep(ptf->iCharRep))
				{
					_sDefaultBiDiFont = -1;

					// Bad DefaultBiDiFont, find the first good bidi font
					i = _fonts.Count();
					ptf	= _fonts.Elem(0);
					for (; i--; ptf++)
					{
						if (IsRTLCharRep(ptf->iCharRep))
						{
							_sDefaultBiDiFont = ptf->sHandle;
							break;
						}
					}
				}

				if(_sDefaultBiDiFont != -1)
				{
					pstate->rgDefFont[DEFFONT_RTLCH].sHandle = _sDefaultBiDiFont;

					Assert(pstate->pstatePrev);
					if (pstate->pstatePrev)
					{
						pstate->pstatePrev->rgDefFont[DEFFONT_RTLCH].sHandle = _sDefaultBiDiFont;
						Assert(pstate->pstatePrev->pstatePrev == NULL);
					}
				}
			}

			// Ensure that a document-level codepage has been determined and
			// then scan the font names and retry the conversion to Unicode,
			// if necessary.
			if(_nCodePage == INVALID_CODEPAGE)
			{
				// We haven't determined a document-level codepage
				// from the \ansicpgN tag, nor from the font table
				// \fcharsetN and \cpgN values.  As a last resort,
				// let's use the \deflangN and \deflangfeN tags
				LANGID langid;

				if(_sDefaultLanguageFE != INVALID_LANGUAGE)
					langid = _sDefaultLanguageFE;

				else if(_sDefaultLanguage != INVALID_LANGUAGE &&
						_sDefaultLanguage != sLanguageEnglishUS)
				{
					// _sDefaultLanguage == sLanguageEnglishUS is inreliable
					// in the absence of \deflangfeN.  Many FE RTF writers
					// write \deflang1033 (sLanguageEnglishUS).
					langid = _sDefaultLanguage;
				}
				else if(_dwFlags & SFF_SELECTION)
				{
					// For copy/paste case, if nothing available, try the system 
					// default langid.  This is to fix FE Excel95 problem.		
					langid = GetSystemDefaultLangID();
				}
				else 
					goto NoLanguageInfo;

				_nCodePage = CodePageFromCharRep(CharRepFromLID(langid));
			}

NoLanguageInfo:
			if(_nCodePage == INVALID_CODEPAGE)
				break;

			// Fixup misconverted font face names
			for(i = 0; i < _fonts.Count(); i++)
			{
				TEXTFONT *ptf = _fonts.Elem(i);

				if (ptf->sCodePage == INVALID_CODEPAGE ||
					ptf->sCodePage == CP_SYMBOL)
				{
					if(ptf->fNameIsDBCS)
					{
						char szaTemp[LF_FACESIZE];
						BOOL fMissingCodePage;

						// Unconvert misconverted face name
						SideAssert(WCTMB(ptf->sCodePage, 0, 
											ptf->szName, -1,
											szaTemp, sizeof(szaTemp),
											NULL, NULL, &fMissingCodePage) > 0);
						Assert(ptf->sCodePage == CP_SYMBOL || 
									fMissingCodePage);

						// Reconvert face name using new codepage info
						SideAssert(MBTWC(_nCodePage, 0,
									szaTemp, -1,
									ptf->szName, sizeof(ptf->szName),
									&fMissingCodePage) > 0);

						if(!fMissingCodePage)
							ptf->fNameIsDBCS = FALSE;
					}
				}
			}
			break;
		}
		_prg->Set_iCF(pstatePrev->iCF);			// Restore previous CharFormat
		ReleaseFormats(pstatePrev->iCF, -1);
	}

done:
	TRACEERRSZSC("HandleEndGroup()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldEndGroup()
 *
 *	@mfunc
 *		Handle end of \field
 */
//FUTURE (keithcu) If I knew the first thing about RTF, I'd cleanup the symbol handling.
void CRTFRead::HandleFieldEndGroup()
{
	STATE *	pstate = _pstateStackTop;

	if (!IN_RANGE(destField, pstate->sDest, destFieldInstruction) ||
		pstate->sDest != destField && !_ecParseError)
	{
		return;
	}

	// For SYMBOLS
	if(_fSymbolField)
	{
		_fSymbolField = FALSE;
		return;
	}

	// Walk backwards, removing the STARTFIELD and SEPARATOR character.
	// Make the instruction field hidden, and mark the whole range
	// with CFE_LINK | CFE_LINKPROTECTED so that our automatic URL
	// detection code doesn't get in the way and remove this stuff.
	// If it is not a hyperlink field, delete fldinst.
	CTxtRange rg(*_prg);
	long	  cchInst = -2, cchResult = -2;
	WCHAR	  ch, chNext = 0;
	LONG	  cpSave = _prg->GetCp();

	rg.SetIgnoreFormatUpdate(TRUE);

	// Find boundary between instruction and result field
	while(!IN_RANGE(STARTFIELD, (ch = rg._rpTX.GetChar()), SEPARATOR) || chNext != 'F')
	{
		if(!rg.Move(-1, FALSE))
			return;							// Nothing to fixup
		cchResult++;
		chNext = ch;
	}

	BOOL fBackSlash = FALSE;
	if (ch == SEPARATOR)
	{
		rg.Move(2, TRUE);
		rg.ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);

		chNext = 0;
		while((ch = rg.CRchTxtPtr::GetChar()) != STARTFIELD || chNext != 'F')
		{
			if(ch == BSLASH)
				fBackSlash = TRUE;				// Need backslash pass
			if(!rg.Move(-1, FALSE))
				return;							// Nothing to fix up
			cchInst++;
			chNext = ch;
		}
	}
	else									//No field result
	{
		cchInst = cchResult;
		cchResult = 0;
	}

	rg.Move(_ecParseError ? tomForward : 2, TRUE);
	rg.ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);
	if(_ecParseError)
		return;

	// If it's a hyperlink field, set properties, else, delete fldinst
	CTxtPtr tp(rg._rpTX);
	if(tp.FindText(rg.GetCp() + cchInst, FR_DOWN, L"HYPERLINK", 9) != -1)
	{
		while((ch = tp.GetChar()) == ' ' || ch == '\"')
			tp.Move(1);
		ch = tp.GetPrevChar();

		if(ch == '\"' && fBackSlash)		// Word quadruples backslash, so
		{									//  need to delete every other one
			LONG cp0 = rg.GetCp();			// Save cp at start of instruction
			LONG cp1 = tp.GetCp();			// Save cp at start	of URL
			LONG cpMax = cp0 + cchInst;		// Max cp for the instruction

			rg.SetCp(cp1, FALSE);
			while(rg.GetCp() < cpMax)
			{
				ch = rg._rpTX.GetChar();
				if(ch == '\"')
					break;
				if(ch == BSLASH)
				{
					if (!rg.Move(1, TRUE))
						break;

					ch = rg._rpTX.GetChar();
					if(ch == '\"')
						break;
					if(ch == BSLASH)
					{
						cchInst--;
						rg.ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);
					}
				}

				if (!rg.Move(1, FALSE))
					break;
			}
			rg.SetCp(cp0, FALSE);			// Restore rg and tp
			tp = rg._rpTX;					// Rebind tp, since deletions may
			tp.SetCp(cp1);					//  change plain-text arrays
		}
		CCharFormat CF;
		DWORD		dwMask, dwMask2;
		LONG		cch1 = 0;
		CTxtPtr		tp1(_prg->_rpTX);

		tp1.Move(-cchResult);				// Point at start of link result
		for(LONG cch = cchResult; cch; cch--)
		{
			DWORD ch1 = tp.GetChar();
			if(ch1 != tp1.GetChar())
				break;
			if(ch1 == ' ')
				cch1 = 1;
			tp.Move(1);						// This could be much
			tp1.Move(1);					//  faster if it matters
		}
		if(!cch && tp.GetChar() == ch)		// Perfect match, so delete
		{									//  instruction and use	built-in
			WCHAR chLeftBracket = '<';		//  RichEdit URLs. Store autocolor
			rg.Move(cchInst, TRUE);			//  and no underlining
			rg.ReplaceRange(cch1, &chLeftBracket, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);
			CF._dwEffects = CFE_LINK | CFE_AUTOCOLOR;
			CF._crTextColor = 0;			// Won't be used but will be stored
			dwMask = CFM_LINK | CFM_COLOR | CFM_UNDERLINE;
			dwMask2 = 0;
			if(cch1)
			{
				WCHAR chRightBracket = '>';
				_prg->ReplaceRange(cch1, &chRightBracket, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);
			}
		}
		else
		{
			rg.Move(cchInst, TRUE);			// Set properties on instruction
			CF._dwEffects = CFE_HIDDEN | CFE_LINK | CFE_LINKPROTECTED ;
			rg.SetCharFormat(&CF, 0, 0, CFM_LINK | CFM_HIDDEN, CFM2_LINKPROTECTED);
			dwMask = CFM_LINK;
			dwMask2 = CFM2_LINKPROTECTED;
		}
		rg.Set(rg.GetCp(), -cchResult);		// Set properties on result
		rg.SetCharFormat(&CF, 0, 0, dwMask, dwMask2);
	}
	else
	{
		_iKeyword = i_field;				// Might be nice to have field name
		if((tp.GetChar() | 0x20) == 'e')	// Only fire notification for EQ fields
		{
			tp.Move(1);
			if((tp.GetChar() | 0x20) == 'q')
			{
				CheckNotifyLowFiRTF(TRUE);
				if(HandleEq(rg, tp) == ecNoError)
					return;
			}
		}
		rg.Move(cchInst, TRUE);
		rg.ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_LP_CHECK);
	}
	if(_cpThisPara > rg.GetCp())			  // Field result had \par's, so
		_cpThisPara -= cpSave - _prg->GetCp();//  subtract cch deleted
}

/*
 *	CRTFRead::SelectCurrentFont(iFont)
 *
 *	@mfunc
 *		Set active font to that with index <p iFont>. Take into account
 *		bad font numbers.
 */
void CRTFRead::SelectCurrentFont(
	INT iFont)		//@parm Font handle of font to select
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SelectCurrentFont");

	LONG		i		= _fonts.Count();
	STATE *		pstate	= _pstateStackTop;
	TEXTFONT *	ptf		= _fonts.Elem(0);

	AssertSz(i,	"CRTFRead::SelectCurrentFont: bad font collection");
	
	for(; i-- && iFont != ptf->sHandle; ptf++)	// Search for font with handle
		;										//  iFont

	// Font handle not found: use default, which is valid
	//  since \rtf copied _prg's
	if(i < 0)									
		ptf = _fonts.Elem(0);
												
	BOOL fDefFontFromSystem = (i == (LONG)_fonts.Count() - 1 || i < 0) &&
								!_fReadDefFont;

	_CF._iFont		= GetFontNameIndex(ptf->szName);
	_dwMaskCF2		|=  CFM2_FACENAMEISDBCS;
	_CF._dwEffects	&= ~CFE_FACENAMEISDBCS;
	if(ptf->fNameIsDBCS)
		_CF._dwEffects |= CFE_FACENAMEISDBCS;

	if(pstate->sDest != destFontTable)
	{
		_CF._iCharRep			= ptf->iCharRep;
		_CF._bPitchAndFamily	= ptf->bPitchAndFamily;
		_dwMaskCF				|= CFM_FACE | CFM_CHARSET;
		if (IsRTLCharRep(_CF._iCharRep) && ptf->sCodePage == 1252)
			ptf->sCodePage = (SHORT)CodePageFromCharRep(_CF._iCharRep);	// Fix sCodePage to match charset
	}

	if (_ped->Get10Mode() && !_fSeenFontTable && 
		_nCodePage == INVALID_CODEPAGE && ptf->sCodePage == 1252)
	{
		if (W32->IsFECodePage(GetACP()))
			_nCodePage = GetACP();
	}

	// Ensure that the state's codepage is not supplied by the system.
	// That is, if we are using the codepage info from the default font,
	// be sure that the default font info was read from the RTF file.
	pstate->SetCodePage((fDefFontFromSystem && _nCodePage != INVALID_CODEPAGE) || 
		ptf->sCodePage == INVALID_CODEPAGE 
						? _nCodePage : ptf->sCodePage);
	pstate->ptf = ptf;
}

/*
 *	CRTFRead::SetPlain(pstate)
 *
 *	@mfunc
 *		Setup _CF for \plain
 */
void CRTFRead::SetPlain(
	STATE *pstate)
{
	ZeroMemory(&_CF, sizeof(CCharFormat));

	_dwMaskCF	= CFM_ALL2;
	_dwMaskCF2	= CFM2_LINKPROTECTED;
	if(_dwFlags & SFF_SELECTION && _prg->GetCp() == _cpFirst &&	!_fCharSet)
	{
		// Let NT 4.0 CharMap use insertion point size
		_CF._yHeight = _ped->GetCharFormat(_prg->Get_iFormat())->_yHeight;
	}
	else
		_CF._yHeight = PointsToFontHeight(yDefaultFontSize);

	_CF._dwEffects	= CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR; // Set default effects
	if(_sDefaultLanguage == INVALID_LANGUAGE)
		_dwMaskCF &= ~CFM_LCID;
	else
		_CF._lcid = MAKELCID((WORD)_sDefaultLanguage, SORT_DEFAULT);

	_CF._bUnderlineType = CFU_UNDERLINE;
	SelectCurrentFont(_sDefaultFont);
}

/*
 *	CRTFRead::ReadFontName(pstate, iAllASCII)
 *
 *	@mfunc
 *		read font name _szText into <p pstate>->ptf->szName and deal with
 *		tagged fonts
 */
void CRTFRead::ReadFontName(
	STATE *	pstate,			//@parm state whose font name is to be read into
	int iAllASCII)			//@parm indicates that _szText is all ASCII chars
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadFontName");

	if (pstate->ptf)
	{
		INT		cchName = LF_FACESIZE - 1;
		WCHAR *	pchDst = pstate->ptf->szName;
		char  * pachName =  (char *)_szText ;
		
		// Append additional text from _szText to TEXTFONT::szName

		// We need to append here since some RTF writers decide
		// to break up a font name with other RTF groups
		while(*pchDst && cchName > 0)
		{
			pchDst++;
			cchName--;
		}
		if(!cchName)						// Probably illegal file
		{									//  e.g., extra {
			_ecParseError = ecFontTableOverflow;
			return;
		}
		INT cchLimit = cchName;
		BOOL	fTaggedName = FALSE;
		while (*pachName &&
			   *pachName != ';' &&
			   cchLimit)		// Remove semicolons
		{
			pachName++;
			cchLimit--;

			if (*pachName == '(')
				fTaggedName = TRUE;
		}
		*pachName = '\0';

		// Use the codepage of the font in all cases except where the font uses
		// the symbol charset (and the codepage has been mapped from the charset)
		// and UTF-8 isn't being used
		LONG nCodePage = pstate->nCodePage != CP_SYMBOL 
					   ? pstate->nCodePage : _nCodePage;

		BOOL fMissingCodePage;
		Assert(!IsUTF8 || nCodePage == CP_UTF8);
		INT cch = MBTWC(nCodePage, 0, 
						(char *)_szText, -1, 
						pchDst, cchName, &fMissingCodePage);

		if(cch > 0 && fMissingCodePage && iAllASCII == CONTAINS_NONASCII)
			pstate->ptf->fNameIsDBCS = TRUE;
		else if(pstate->ptf->iCharRep == DEFAULT_INDEX && 
				W32->IsFECodePage(nCodePage) && 
				GetTrailBytesCount(*_szText, nCodePage))
			pstate->ptf->iCharRep = CharRepFromCodePage(nCodePage);	// Fix up  charset


		// Make sure destination is null terminated
		if(cch > 0)
			pchDst[cch] = 0;

		// Fall through even if MBTWC <= 0, since we may be appending text to an
		// existing font name.

		if(pstate->ptf == _fonts.Elem(0))		// If it's the default font,
			SelectCurrentFont(_sDefaultFont);	//  update _CF accordingly

		WCHAR *	szNormalName;

		if(pstate->ptf->iCharRep && pstate->fRealFontName)
		{
			// if we don't know about this font don't use the real name
			if(!FindTaggedFont(pstate->ptf->szName,
							   pstate->ptf->iCharRep, &szNormalName))
			{
				pstate->fRealFontName = FALSE;
				pstate->ptf->szName[0] = 0;
			}
		}
		else if(IsTaggedFont(pstate->ptf->szName,
							&pstate->ptf->iCharRep, &szNormalName))
		{
			wcscpy(pstate->ptf->szName, szNormalName);
			pstate->ptf->sCodePage = (SHORT)CodePageFromCharRep(pstate->ptf->iCharRep);
			pstate->SetCodePage(pstate->ptf->sCodePage);
		}
		else if(fTaggedName && !fMissingCodePage)
		{
			HDC hDC = W32->GetScreenDC();
			if (!W32->IsFontAvail( hDC, 0, 0, NULL, pstate->ptf->szName))
			{
				// Fix up tagged name by removing characters after the ' ('
				INT i = 0;
				WCHAR	*pwchTag = pstate->ptf->szName;

				while (pwchTag[i] && pwchTag[i] != L'(')	// Search for '('
					i++;

				if(pwchTag[i] && i > 0)
				{
					while (i > 0 && pwchTag[i-1] == 0x20)	// Remove spaces before the '('
						i--;
					pwchTag[i] = 0;
				}
			}
		}
	}
}

/*
 *	CRTFRead::GetColor (dwMask)
 *
 *	@mfunc
 *		Store the autocolor or autobackcolor effect bit and return the
 *		COLORREF for color _iParam
 *
 *	@rdesc
 *		COLORREF for color _iParam
 *
 *	@devnote
 *		If the entry in _colors corresponds to tomAutoColor, gets the value
 *		RGB(0,0,0) (since no \red, \green, and \blue fields are used), but
 *		isn't used by the RichEdit engine.  Entry 1 corresponds to the first
 *		explicit entry in the \colortbl and is usually RGB(0,0,0). The _colors
 *		table is built by HandleToken() when it handles the token tokenText
 *		for text consisting of a ';' for a destination destColorTable.
 */
COLORREF CRTFRead::GetColor(
	DWORD dwMask)		//@parm Color mask bit
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColor");

	if(_iParam < 0 || _iParam >= _colors.Count())	// Illegal _iParam
		return RGB(0,0,0);

	COLORREF Color = *_colors.Elem(_iParam);

	if(dwMask)
	{
		_dwMaskCF	  |= dwMask;				// Turn on appropriate mask bit
		_CF._dwEffects &= ~dwMask;				// auto(back)color off: color is to be used

		if(Color == tomAutoColor)
		{
			_CF._dwEffects |= dwMask;			// auto(back)color on				
			Color = RGB(0,0,0);
		}
	}
	return Color;
}

/*
 *	CRTFRead::GetStandardColorIndex ()
 *
 *	@mfunc
 *		Return the color index into the standard 16-entry Word \colortbl
 *		corresponding to the color index _iParam for the current \colortbl
 *
 *	@rdesc
 *		Standard color index corresponding to the color associated with _iParam
 */
LONG CRTFRead::GetStandardColorIndex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColorIndex");

	if(_iParam < 0 || _iParam >= _colors.Count())	// Illegal _iParam:
		return 0;									//  use autocolor

	COLORREF Color = *_colors.Elem(_iParam);

	for(LONG i = 0; i < 16; i++)
	{
		if(Color == g_Colors[i])
			return i + 1;
	}
	return 0;									// Not there: use autocolor
}

/*
 *	CRTFRead::GetCellColorIndex ()
 *
 *	@mfunc
 *		Return the color index into the standard 16-entry Word \colortbl
 *		corresponding to the color index _iParam for the current \colortbl.
 *		If color isn't found, use _crCellCustom1 or _crCellCustom2.
 *
 *	@rdesc
 *		Standard or custom color index corresponding to the color associated
 *		with _iParam
 */
LONG CRTFRead::GetCellColorIndex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColorIndex");

	LONG i = GetStandardColorIndex();					// 16 standard colors (1 - 16)
	if(i || _iParam >= _colors.Count() || _iParam < 0)	//  plus autocolor (0)
		return i;

	COLORREF Color = *_colors.Elem(_iParam);// Not there: try using custom colors
	if(!_crCellCustom1 || Color == _crCellCustom1)
	{
		_crCellCustom1 = Color;				// First custom cr 
		return 17;
	}

	if(!_crCellCustom2 || Color == _crCellCustom2)	
	{
		_crCellCustom2 = Color;				// Second custom cr
		return 18;
	}
	return 0;								// No custom cr available	
}

/*
 *	CRTFRead::HandleEq(&rg, &tp)
 *
 *	@mfunc
 *		Handle Word EQ field
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFRead::HandleEq(
	CTxtRange & rg,		//@parm Range to use
	CTxtPtr	&	tp)		//@parm TxtPtr to use
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEq");

#if 0
	while(tp.GetCp() < _prg->GetCp())
	{
	}
#endif
	return ecGeneralFailure;	// Not yet implemented, but don't set _ecParseError 
}

/*
 *	CRTFRead::HandleCell()
 *
 *	@mfunc
 *		Handle \cell command
 *
 *	@rdesc
 *		EC			The error code
 */
void CRTFRead::HandleCell()
{
	if(!_bTableLevel)
	{
		if(!_fStartRow)
			return;
		DelimitRow(szRowStart);				// \cell directly follows \row
	}
	if(_bTableLevel + _bTableLevelIP > MAXTABLENEST)
	{
		_iCell++;
		HandleChar(TAB);
		return;
	}
	LONG	   cCell = _cCell;
	CTabs	*  pTabs = NULL;
	CELLPARMS *pCellParms = NULL;

	if(_bTableLevel == 1 && _iTabsLevel1 >= 0 && !_fNo_iTabsTable)
	{
		pTabs = GetTabsCache()->Elem(_iTabsLevel1);
		pCellParms = (CELLPARMS *)(pTabs->_prgxTabs);
		cCell = pTabs->_cTab/(CELL_EXTRA + 1);
	}
	if(!cCell)								// _rgxCell has no cell defs
	{
		if(_iTabsTable < 0)					// No cells defined yet
		{
			_iCell++;						// Count cells inserted
			HandleEndOfPara();				// Insert cell delimiter
			return;
		}
		// Use previous table defs
		Assert(_bTableLevel == 1 && !_fNo_iTabsTable);

		pTabs = GetTabsCache()->Elem(_iTabsTable);
		cCell = pTabs->_cTab/(CELL_EXTRA + 1);
	}
	if(_iCell < cCell)						// Don't add more cells than
	{										//  defined, since Word crashes
		if(pCellParms && IsLowCell(pCellParms[_iCell].uCell))
			HandleChar(NOTACHAR);			// Signal pseudo cell (\clvmrg)
		_iCell++;							// Count cells inserted
		HandleEndOfPara();					// Insert cell delimiter
	}
}

/*
 *	CRTFRead::HandleCellx(iParam)
 *
 *	@mfunc
 *		Handle \cell command
 *
 *	@rdesc
 *		EC			The error code
 */
void CRTFRead::HandleCellx(
	LONG iParam)
{
	if(!_fCellxOK)							// Missing \trowd
	{
		_ecParseError = ecUnexpectedToken;
		return;
	}
	if(_cCell < MAX_TABLE_CELLS)			// Save cell right boundaries
	{
		if(!_cCell)
		{									// Save border info
			_wBorders = _PF._wBorders;
			_wBorderSpace = _PF._wBorderSpace;
			_wBorderWidth = _PF._wBorderWidth;
			_xCellPrev = _xRowOffset;
		}
		CELLPARMS *pCellParms = (CELLPARMS *)&_rgxCell[0];
		// Store cell widths instead of right boundaries relative to \trleftN
		LONG i = iParam - _xCellPrev;
		i = max(i, 0);
		i = min(i, 1440*22);
		pCellParms[_cCell].uCell = i + (_bCellFlags << 24);
		pCellParms[_cCell].dxBrdrWidths = _dwCellBrdrWdths;
		pCellParms[_cCell].dwColors = _dwCellColors;
		pCellParms[_cCell].bShading = (BYTE)min(200, _dwShading);
		_dwCellColors = 0;					// Default autocolor for next cell
		_dwShading = 0;
		_xCellPrev = iParam;
		_cCell++;
		_dwCellBrdrWdths = 0;
		_bCellFlags = 0;
	}
}

/*
 *	CRTFRead::HandleChar(ch)
 *
 *	@mfunc
 *		Handle single Unicode character <p ch>
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFRead::HandleChar(
	WCHAR ch)			//@parm char token to be handled
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleChar");

	if(!_ped->_pdp->IsMultiLine() && IsASCIIEOP(ch))
		_ecParseError = ecTruncateAtCRLF;
 	else
	{
		AssertNr(ch <= 0x7F || ch > 0xFF || FTokIsSymbol(ch));
		_dwMaskCF2		|=  CFM2_RUNISDBCS;
		_CF._dwEffects	&= ~CFE_RUNISDBCS;
		AddText(&ch, 1, CharGetsNumbering(ch));
	}

	TRACEERRSZSC("HandleChar()", - _ecParseError);

	return _ecParseError;
}

/*
 *	CRTFRead::HandleEndOfPara()
 *
 *	@mfunc
 *		Insert EOP and apply current paraformat
 *
 *	@rdesc
 *		EC	the error code
 */
EC CRTFRead::HandleEndOfPara()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndOfPara");

	if(!_ped->_pdp->IsMultiLine())			// No EOPs permitted in single-
	{										//  line controls
		Apply_PF();							// Apply any paragraph formatting
		_ecParseError = ecTruncateAtCRLF;	// Cause RTF reader to finish up
		return ecTruncateAtCRLF;
	}

	Apply_CF();								// Apply _CF and save iCF, since
	LONG iFormat = _prg->Get_iCF();			//  it gets changed if processing
											//  CFE2_RUNISDBCS chars
	EC ec;
	
	if(IN_RANGE(tokenCell, _token, tokenNestCell) || _token == tokenRow)
		ec = HandleChar((unsigned)CELL);
	else
		ec = _ped->fUseCRLF()				// If RichEdit 1.0 compatibility
		   ? HandleText(szaCRLF, ALL_ASCII)	//  mode, use CRLF; else CR or VT
		   : HandleChar((unsigned)(_token == tokenLineBreak ? VT : 
								   _token == tokenPage ? FF : CR));
	if(ec == ecNoError)
	{
		Apply_PF();
		_cpThisPara = _prg->GetCp();		// New para starts after CRLF
	}
	_prg->Set_iCF(iFormat);					// Restore iFormat if changed
	ReleaseFormats(iFormat, -1);			// Release iFormat (AddRef'd by
											//  Get_iCF())
	return _ecParseError;
}

/*
 *	CRTFRead::HandleText(szText, iAllASCII)
 *
 *	@mfunc
 *		Handle the string of Ansi characters <p szText>
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFRead::HandleText(
	BYTE * szText,			//@parm string to be handled
	int iAllASCII,			//@parm enum indicating if string is all ASCII chars
	LONG	cchText)		//@parm size of szText in bytes
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleText");

	LONG		cch;
	BOOL        fStateChng = FALSE;
	WCHAR *		pch;
	STATE *		pstate = _pstateStackTop;
	TEXTFONT *	ptf = pstate->ptf;

	struct TEXTFONTSAVE : TEXTFONT
	{
		TEXTFONTSAVE(TEXTFONT *ptf)
		{
			if (ptf)
			{
				iCharRep		= ptf->iCharRep;
				sCodePage		= ptf->sCodePage;
				fCpgFromSystem	= ptf->fCpgFromSystem;
			}
		}
	};

	BOOL fAdjustPtf = FALSE;

	if(IN_RANGE(DEFFONT_LTRCH, pstate->iDefFont, DEFFONT_RTLCH))
	{
		// CharSet resolution based on directional control words
		BOOL frtlch = pstate->iDefFont == DEFFONT_RTLCH;
		if(_CF._iCharRep == DEFAULT_INDEX)
		{
			_CF._iCharRep = (BYTE)(frtlch ? _iCharRepBiDi : ANSI_INDEX);
			_dwMaskCF |= CFM_CHARSET;
			fAdjustPtf = TRUE;
		}
		else
		{
			BOOL fBiDiCharRep = IsRTLCharRep(_CF._iCharRep);

			// If direction token doesn't correspond to current charset
			if(fBiDiCharRep ^ frtlch)
			{
				_dwMaskCF |= CFM_CHARSET;
				fAdjustPtf = TRUE;
				if(!fBiDiCharRep)				// Wasn't BiDi, but is now
					SelectCurrentFont(_sDefaultBiDiFont);
				_CF._iCharRep = (BYTE)(frtlch ? _iCharRepBiDi : ANSI_INDEX);
			}
			else if (fBiDiCharRep && ptf && !W32->IsBiDiCodePage(ptf->sCodePage))
				fAdjustPtf = TRUE;
		}
	}
	else if(_ped->IsBiDi() && _CF._iCharRep == DEFAULT_INDEX)
	{
		_CF._iCharRep = ANSI_INDEX;
		_dwMaskCF |= CFM_CHARSET;
		fAdjustPtf = TRUE;
	}
	if (fAdjustPtf && ptf)
	{
		ptf->sCodePage = (SHORT)CodePageFromCharRep(_CF._iCharRep);
		pstate->SetCodePage(ptf->sCodePage);
	}

	TEXTFONTSAVE	tfSave(ptf);

	// TODO: what if szText cuts off in middle of DBCS?

	if(!*szText)
		goto CleanUp;

	if (cchText != -1 && _cchUnicode < cchText)
	{
		// Re-allocate a bigger buffer
		_szUnicode = (WCHAR *)PvReAlloc(_szUnicode, (cchText + 1) * sizeof(WCHAR));
		if(!_szUnicode)					// Re-allocate space for Unicode conversions
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			goto CleanUp;
		}
		_cchUnicode = cchText + 1;
	}

	if(iAllASCII == ALL_ASCII || pstate->nCodePage == CP_SYMBOL)
	{
		// Don't use MBTWC() in cases where text contains
		// only ASCII chars (which don't require conversion)
		for(cch = 0, pch = _szUnicode; *szText; cch++)
		{
			Assert(*szText <= 0x7F || pstate->nCodePage == CP_SYMBOL);
			*pch++ = (WCHAR)*szText++;
		}
		*pch = 0;

		_dwMaskCF2		|=  CFM2_RUNISDBCS;
		_CF._dwEffects	&= ~CFE_RUNISDBCS;

		// Fall through to AddText at end of HandleText()
	}
	else
	{
		BOOL fMissingCodePage;

		// Run of text contains bytes > 0x7F.
		// Ensure that we have the correct codepage with which to interpret 
		// these (possibly DBCS) bytes.

		if(ptf && ptf->sCodePage == INVALID_CODEPAGE && !ptf->fCpgFromSystem)
		{
			if(_dwFlags & SF_USECODEPAGE)
			{
				_CF._iCharRep = CharRepFromCodePage(_nCodePage);
				_dwMaskCF |= CFM_CHARSET;
			}

			// Determine codepage from the font name
			else if(CpgInfoFromFaceName(pstate->ptf))
			{
				fStateChng = TRUE;
				SelectCurrentFont(pstate->ptf->sHandle);
				Assert(ptf->sCodePage != INVALID_CODEPAGE && ptf->fCpgFromSystem);
			}
			else
			{
				// Here, we were not able to determine a cpg/charset value
				// from the font name.  We have two choices: (1) either choose
				// some fallback value like 1252/0 or (2) rely on the 
				// document-level cpg value.
				//
				// I think choosing the document-level cpg value will give
				// us the best results.  In FE cases, it will likely err
				// on the side of tagging too many runs as CFE2_RUNISDBCS, but
				// that is safer than using a western cpg and potentially missing
				// runs which should be CFE2_RUNISDBCS.
			}
		}

		Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);

		if (pstate->nCodePage == INVALID_CODEPAGE && ptf)
			pstate->nCodePage = ptf->sCodePage;

		cch = MBTWC(pstate->nCodePage, 0,
					(char *)szText,	-1, 
					_szUnicode, _cchUnicode, &fMissingCodePage);

		AssertSz(cch > 0, "CRTFRead::HandleText():  MBTWC implementation changed"
							" such that it returned a value <= 0");

		if(!fMissingCodePage || !W32->IsFECodePage(pstate->nCodePage))
		{
			// Use result of MBTWC if:
			//	(1) we converted some chars and did the conversion with the codepage
			//		provided.
			//	(2) we converted some chars but couldn't use the codepage provided,
			//		but the codepage is invalid.  Since the codepage is invalid,
			//		we can't do anything more sophisticated with the text before
			//		adding to the backing store

			cch--;  // don't want char count to including terminating NULL

			_dwMaskCF2		|=  CFM2_RUNISDBCS;
			_CF._dwEffects	&= ~CFE_RUNISDBCS;
			if(pstate->nCodePage == INVALID_CODEPAGE)
				_CF._dwEffects |= CFE_RUNISDBCS;

			// fall through to AddText at end of HandleText()
		}
		else
		{
			// Conversion to Unicode failed.  Break up the string of
			// text into runs of ASCII and non-ASCII characters.

			// FUTURE(BradO):  Here, I am saving dwMask and restoring it before
			//		each AddText.  I'm not sure this is neccessary.  When I have
			//		the time, I should revisit this save/restoring and 
			//		determine that it is indeed neccessary.

			BOOL fPrevIsASCII = ((*szText <= 0x7F) ? TRUE : FALSE);
			BOOL fCurrentIsASCII = FALSE;
			BOOL fLastChunk = FALSE;
			DWORD dwMaskSave = _dwMaskCF;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
			CCharFormat CFSave = _CF;
#endif

			pch = _szUnicode;
			cch = 0;

			// (!*szText && *pch) is the case where we do the AddText for the
			//	last chunk of text
			while(*szText || fLastChunk)
			{
				// fCurrentIsASCII assumes that no byte <= 0x7F is a 
				//	DBCS lead-byte
				if(fLastChunk ||
					(fPrevIsASCII != (fCurrentIsASCII = (*szText <= 0x7F))))
				{
					_dwMaskCF = dwMaskSave;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
					_CF = CFSave;
#endif
					*pch = 0;

					_dwMaskCF2		|= CFM2_RUNISDBCS;
					_CF._dwEffects	|= CFE_RUNISDBCS;
					if(fPrevIsASCII)
						_CF._dwEffects &= ~CFE_RUNISDBCS;

					Assert(cch);
					pch = _szUnicode;

					AddText(pch, cch, TRUE);

					cch = 0;
					fPrevIsASCII = fCurrentIsASCII;

					// My assumption in saving _dwMaskCF is that the remainder
					// of the _CF is unchanged by AddText.  This assert verifies
					// this assumption.
					AssertSz(!CompareMemory(&CFSave._iCharRep, &_CF._iCharRep,
						sizeof(CCharFormat) - sizeof(DWORD)) &&
						!((CFSave._dwEffects ^ _CF._dwEffects) & ~CFE_RUNISDBCS),
						"CRTFRead::HandleText():  AddText has been changed "
						"and now alters the _CF structure.");

					if(fLastChunk)			// Last chunk of text was AddText'd
						break;
				}

				// Not the last chunk of text.
				Assert(*szText);

				// Advance szText pointer
				if (!fCurrentIsASCII && *(szText + 1) && 
					GetTrailBytesCount(*szText, pstate->nCodePage))
				{
					// Current byte is a lead-byte of a DBCS character
					*pch++ = *szText++;
					++cch;
				}
				*pch++ = *szText++;
				++cch;

				// Must do an AddText for the last chunk of text
				if(!*szText || cch >= _cchUnicode - 1)
					fLastChunk = TRUE;
			}
			goto CleanUp;
		}
	}

	if(cch > 0)
	{
		if(!_cCell || _iCell < _cCell)
			AddText(_szUnicode, cch, TRUE);
		if(fStateChng && ptf)
		{
			ptf->iCharRep		= tfSave.iCharRep;
			ptf->sCodePage		= tfSave.sCodePage;
			ptf->fCpgFromSystem	= tfSave.fCpgFromSystem;
			SelectCurrentFont(ptf->sHandle);
		}
	}

CleanUp:
	TRACEERRSZSC("HandleText()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleUN(pstate)
 *
 *	@mfunc
 *		Handle run of Unicode characters given by \uN control words
 */
void CRTFRead::HandleUN(
	STATE *pstate)
{
	char	ach = 0;
	LONG	cch = 0;
	DWORD	ch;								// Treat as unsigned quantity
	WCHAR *	pch = _szUnicode;

	_dwMaskCF2		|=  CFM2_RUNISDBCS;
	_CF._dwEffects	&= ~CFE_RUNISDBCS;

	do
	{
		if(_iParam < 0)
			_iParam = (WORD)_iParam;
		ch = _iParam;
		if(pstate->ptf && pstate->ptf->iCharRep == SYMBOL_INDEX)
		{
			if(IN_RANGE(0xF000, ch, 0xF0FF))// Compensate for converters
				ch -= 0xF000;				//  that write symbol codes
											//  up high
			else if(ch > 255)				// Whoops, RTF is using con-					
			{								//  verted value for symbol:
				char ach;					//  convert back
				WCHAR wch = ch;				// Avoid endian problems
				WCTMB(1252, 0, &wch, 1, &ach, 1, NULL, NULL, NULL);
				ch = (BYTE)ach;				// Review: use CP_ACP??
			}
		}
		if(IN_RANGE(0x10000, ch, 0x10FFFF))	// Higher-plane char:
		{									//  Store as Unicode surrogate
			ch -= 0x10000;					//  pair
			*pch++ = 0xD800 + (ch >> 10);
			ch = 0xDC00 + (ch & 0x3FF);
			cch++;
		}
		if(!IN_RANGE(STARTFIELD, ch, NOTACHAR) && // Don't insert 0xFFF9 - 0xFFFF
		   (!IN_RANGE(0xDC00, ch, 0xDFFF) ||	  //  or lone trail surrogate
		    IN_RANGE(0xD800, cch ? *(pch - 1) : _prg->GetPrevChar(), 0xDBFF)))
		{
			*pch++ = ch;
			cch++;
		}
		for(LONG i = pstate->cbSkipForUnicodeMax; i--; )
			GetCharEx();					// Eat the \uc N chars
		ach = GetChar();					// Get next char
		while(IsASCIIEOP(ach))
		{
			ach = GetChar();
			if (_ecParseError != ecNoError)
				return;
		}
		if(ach != BSLASH)					// Not followed by \, so
		{									//  not by \uN either
			UngetChar();					// Put back BSLASH
			break;
		}
		ach = GetChar();
		if((ach | ' ') != 'u')
		{
			UngetChar(2);					// Not \u; put back \x
			break;
		}
		GetParam(GetChar());				// \u so try for _iParam = N
		if(!_fParam)						// No \uN; put back \u
		{
			UngetChar(2);
			break;
		}
	} while(cch < _cchUnicode - 2 && _iParam);

	AddText(_szUnicode, cch, TRUE, TRUE);
}

/*
 *	CRTFRead::HandleNumber()
 *
 *	@mfunc
 *		Insert the number _iParam as text. Useful as a workaround for
 *		Word RTF that leaves out the blank between \ltrch and a number.
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::HandleNumber()
{
	if(!_fParam)							// Nothing to do
		return _ecParseError;

	LONG	n = _iParam;
	BYTE   *pch = _szText;

	if(n < 0)
	{
		n = -n;
		*pch++ = '-';
	}
	for(LONG d = 1; d < n; d *= 10)			// d = smallest power of 10 > n
		;
	if(d > n)
		d /= 10;							// d = largest power of 10 < n

	while(d)
	{
		*pch++ = (WORD)(n/d + '0');			// Store digit
		n = n % d;							// Setup remainder
		d /= 10;
	}
	*pch = 0;
	_token = tokenASCIIText;
	HandleTextToken(_pstateStackTop);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleTextToken(pstate)
 *
 *	@mfunc
 *		Handle tokenText
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFRead::HandleTextToken(
	STATE *pstate)
{
	COLORREF *pclrf;

	switch (pstate->sDest)
	{
	case destColorTable:
		pclrf = _colors.Add(1, NULL);
		if(!pclrf)
			goto OutOfRAM;

		*pclrf = _fGetColorYet ? 
			RGB(pstate->bRed, pstate->bGreen, pstate->bBlue) : tomAutoColor;

		// Prepare for next color table entry
		pstate->bRed =
		pstate->bGreen =
		pstate->bBlue = 0;
		_fGetColorYet = FALSE;				// in case more "empty" color
		break;

	case destFontTable:
		if(!pstate->fRealFontName)
		{
			ReadFontName(pstate, _token == tokenASCIIText 
									? ALL_ASCII : CONTAINS_NONASCII);
		}
		break;

	case destRealFontName:
	{
		STATE * const pstatePrev = pstate->pstatePrev;

		if(pstatePrev && pstatePrev->sDest == destFontTable)
		{
			// Mark previous state so that tagged font name will be ignored
			// AROO: Do this before calling ReadFontName so that
			// AROO: it doesn't try to match font name
			pstatePrev->fRealFontName = TRUE;
			ReadFontName(pstatePrev, 
					_token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
		}
		break;
	}

	case destFieldInstruction:
		HandleFieldInstruction();
		break;

	case destObjectClass:
		if(StrAlloc(&_prtfObject->szClass, _szText))
			goto OutOfRAM;
		break;

	case destObjectName:
		if(StrAlloc(&_prtfObject->szName, _szText))
			goto OutOfRAM;
		break;

	case destStyleSheet:
		// _szText has style name, e.g., "heading 1"
		if(W32->ASCIICompareI(_szText, (unsigned char *)"heading", 7))
		{
			DWORD dwT = (unsigned)(_szText[8] - '0');
			if(dwT < NSTYLES)
				_rgStyles[dwT] = (BYTE)_Style;
		}
		break;

	case destShapeName:
		if(pstate->fBackground)
		{
			TOKEN token = TokenFindKeyword(_szText, rgShapeKeyword, cShapeKeywords);
			_bShapeNameIndex = (token != tokenUnknownKeyword) ? (BYTE)token : 0;
		}
		break;

	case destShapeValue:
		if(_bShapeNameIndex)
		{
			CDocInfo *pDocInfo = _ped->GetDocInfoNC();
			BYTE *pch = _szText;
			BOOL fNegative = FALSE;

			if(*pch == '-')
			{
				fNegative = TRUE;
				pch++;
			}
			for(_iParam = 0; IsDigit(*pch); pch++)
				_iParam = _iParam*10 + *pch - '0';

			if(fNegative)
				_iParam = -_iParam;

			switch(_bShapeNameIndex)
			{
				case shapeFillBackColor:
				case shapeFillColor:
				{
					if(_iParam > 0xFFFFFF)
						_iParam = 0;
					if(_bShapeNameIndex == shapeFillColor)
						pDocInfo->_crColor = (COLORREF)_iParam;
					else
						pDocInfo->_crBackColor = (COLORREF)_iParam;
					if(pDocInfo->_nFillType == -1)
						pDocInfo->_nFillType = 0;
					break;
				}
				case shapeFillType:
					// DEBUGGG: more general _nFillType commented out for now
					// pDocInfo->_nFillType	= _iParam;
					if(pDocInfo->_nFillType)
 						CheckNotifyLowFiRTF(TRUE);
					pDocInfo->_crColor		= RGB(255, 255, 255);
					pDocInfo->_crBackColor	= RGB(255, 255, 255);
					break;

				case shapeFillAngle:
					pDocInfo->_sFillAngle = HIWORD(_iParam);
					break;

				case shapeFillFocus:
					pDocInfo->_bFillFocus = _iParam;
					break;
			}
		}
		break;

	case destNestTableProps:
		_ecParseError = ecUnexpectedToken;
		break;

	case destDocumentArea:
	case destFollowingPunct:
	case destLeadingPunct:
		break;

// This has been changed now.  We will store the Punct strings as
// raw text strings.  So, we don't have to convert them.
// This code is keep here just in case we want to change back.
#if 0
	case destDocumentArea:
		if (_tokenLast != tokenFollowingPunct &&
			_tokenLast != tokenLeadingPunct)
		{
			break;
		}										// Else fall thru to
												//  destFollowingPunct
	case destFollowingPunct:
	case destLeadingPunct:
		// TODO(BradO):  Consider some kind of merging heuristic when
		//	we paste FE RTF (for lead and follow chars, that is).
		if(!(_dwFlags & SFF_SELECTION))
		{
			int cwch = MBTWC(INVALID_CODEPAGE, 0,
									(char *)_szText, -1,
									NULL, 0,
									NULL);
			Assert(cwch);
			WCHAR *pwchBuf = (WCHAR *)PvAlloc(cwch * sizeof(WCHAR), GMEM_ZEROINIT);

			if(!pwchBuf)
				goto OutOfRAM;

			SideAssert(MBTWC(INVALID_CODEPAGE, 0,
								(char *)_szText, -1,
								pwchBuf, cwch,
								NULL) > 0);

			if(pstate->sDest == destFollowingPunct)
				_ped->SetFollowingPunct(pwchBuf);
			else
			{
				Assert(pstate->sDest == destLeadingPunct);
				_ped->SetLeadingPunct(pwchBuf);
			}
			FreePv(pwchBuf);
		}
		break;
#endif

	default:
		if(!IsLowMergedCell())
			HandleText(_szText, _token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
	}
	return _ecParseError;

OutOfRAM:
	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;
	return _ecParseError;
}

/*
 *	CRTFRead::AddText(pch, cch, fNumber, fUN)
 *	
 *	@mfunc
 *		Add <p cch> chars of the string <p pch> to the range _prg
 *
 *	@rdesc
 *		error code placed in _ecParseError
 */
EC CRTFRead::AddText(
	WCHAR *	pch,		//@parm Text to add
	LONG	cch,		//@parm Count of chars to add
	BOOL	fNumber,	//@parm Indicates whether or not to prepend numbering
	BOOL	fUN)		//@parm TRUE means caller is \uN handler
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::AddText");

	LONG			cchAdded;
	LONG			cchT;
	STATE *	const	pstate = _pstateStackTop;
	WCHAR *			szDest;
	LONG			cchMove;

	// AROO: No saving state before this point (other than pstate)
	// AROO: This would screw recursion below

	//AssertSz(pstate, "CRTFRead::AddText: no state");

	if((DWORD)cch > _cchMax)
	{
		cch = (LONG)_cchMax;
		_ecParseError = ecTextMax;
		if(*pch == STARTFIELD)
			return ecTextMax;				// Don't enter partial startfield
	}

	if(!cch)
		return _ecParseError;

	if(_fStartRow)
		DelimitRow(szRowStart);

	// FUTURE(BradO):  This strategy for \pntext is prone to bugs, I believe.
	// The recursive call to AddText to add the \pntext will trounce the 
	// accumulated _CF diffs associated with the text for which AddText is
	// called.  I believe we should save and restore _CF before and after
	// the recursive call to AddText below.  Also, it isn't sufficient to
	// accumulate bits of \pntext as below, since each bit might be formatted
	// with different _CF properties.  Instead, we should accumulate a mini-doc
	// complete with multiple text, char and para runs (or some stripped down
	// version of this strategy).

	if(pstate && pstate->sDest == destParaNumText && pch != szRowStart)
	{
		szDest = _szNumText + _cchUsedNumText;
		cch = min(cch, cchMaxNumText - 1 - _cchUsedNumText);
		if(cch > 0)
		{
			MoveMemory((BYTE *)szDest, (BYTE *)pch, cch*2);
			szDest[cch] = TEXT('\0');		// HandleText() takes sz
			_cchUsedNumText += cch;
		}
		return ecNoError;
	}

	if(pstate && _cchUsedNumText && fNumber)		// Some \pntext available
	{
		// Bug 3496 - The fNumber flag is an ugly hack to work around RTF 
		//	commonly written by Word.  Often, to separate a numbered list
		// 	by page breaks, Word will write:
		//		<NUMBERING INFO> \page <PARAGRAPH TEXT>
		// 	The paragraph numbering should precede the paragraph text rather
		//	than the page break.  The fNumber flag is set to FALSE when the
		//	the text being added should not be prepended with the para-numbering,
		//	as is the case with \page (mapped to FF).

		cchT = _cchUsedNumText;
		_cchUsedNumText = 0;				// Prevent infinite recursion

		if(!pstate->fBullet)
		{
			// If there are any _CF diffs to be injected, they will be trounced
			// by this recursive call (see FUTURE comment above).

			// Since we didn't save _CF data from calls to AddText with
			// pstate->sDest == destParaNumText, we have no way of setting up
			// CFE2_RUNISDBCS and CFM2_RUNISDBCS (see FUTURE comment above).

			AddText(_szNumText, cchT, FALSE);
		}
		else if(_PF.IsListNumbered() && _szNumText[cchT - 1] == TAB)
		{
			AssertSz(cchT >= 1, "Invalid numbered text count");

			if (cchT > 1)
			{
				WCHAR ch = _szNumText[cchT - 2];

				_wNumberingStyle = (_wNumberingStyle & ~0x300)
					 | (ch == '.' ? PFNS_PERIOD : 
						ch != ')' ? PFNS_PLAIN  :
						_szNumText[0] == '(' ? PFNS_PARENS : PFNS_PAREN);
			}
			else
			{
				// There is only a tab so we will assume they meant to
				// skip numbering.
				_wNumberingStyle = PFNS_NONUMBER;
			}
		}
	}

	Apply_CF();								// Apply formatting changes in _CF

	// CTxtRange::ReplaceRange will change the character formatting
	// and possibly adjust the _rpCF forward if the current char
	// formatting includes protection.  The changes affected by 
	// CTxtRange::ReplaceRange are necessary only for non-streaming 
	// input, so we save state before and restore it after the call 
	// to CTxtRange::ReplaceRange

	LONG	iFormatSave = _prg->Get_iCF();	// Save state
	QWORD	qwFlags = GetCharFlags(pch, cch);

	if(fUN &&								// \uN generated string
		(!pstate->ptf || pstate->ptf->sCodePage == INVALID_CODEPAGE || qwFlags & FOTHER ||
		 (qwFlags & GetFontSignatureFromFace(_ped->GetCharFormat(iFormatSave)->_iFont)) != qwFlags &&
		  (!(qwFlags & (FARABIC | FHEBREW)) || _fNon0CharSet)))
	{
	 	// No charset info for \uN or current charset doesn't support char
		cchAdded = _prg->CleanseAndReplaceRange(cch, pch, FALSE, NULL, pch);
	}
	else
	{
		cchAdded = _prg->ReplaceRange(cch, pch, NULL, SELRR_IGNORE, &cchMove,
						RR_NO_LP_CHECK);

		for(cchT = cch - 1; cchT; cchT--)
			qwFlags |= GetCharFlags(++pch, cchT);// Note if ComplexScript

		_ped->OrCharFlags(qwFlags);
	}
	_fBody = TRUE;
	_prg->Set_iCF(iFormatSave);				// Restore state 
	ReleaseFormats(iFormatSave, -1);
	Assert(!_prg->GetCch());

	if(cchAdded != cch)
	{
		Tracef(TRCSEVERR, "AddText(): Only added %d out of %d", cchAdded, cch);
		_ecParseError = ecGeneralFailure;
		if(cchAdded <= 0)
			return _ecParseError;
	}
	_cchMax -= cchAdded;

	return _ecParseError;
}

/*
 *	CRTFRead::Apply_CF()
 *	
 *	@mfunc
 *		Apply character formatting changes collected in _CF
 */
void CRTFRead::Apply_CF()
{
	// If any CF changes, update range's _iFormat
	if(_dwMaskCF || _dwMaskCF2)		
	{
		AssertSz(_prg->GetCch() == 0,
			"CRTFRead::Apply_CF: nondegenerate range");

		_prg->SetCharFormat(&_CF, 0, NULL, _dwMaskCF, _dwMaskCF2);
		_dwMaskCF = 0;							
		_dwMaskCF2 = 0;
	}
}

/*
 *	CRTFRead::Apply_PF()
 *	
 *	@mfunc
 *		Apply paragraph format given by _PF
 *
 *	@rdesc
 *		if table row delimiter with nonzero cell count, PF::_iTabs; else -1
 */
SHORT CRTFRead::Apply_PF()
{
	LONG		 cp		 = _prg->GetCp();
	DWORD		 dwMask  = _dwMaskPF;
	DWORD		 dwMask2 = _dwMaskPF2;
	SHORT		 iTabs	 = -1;
	CParaFormat *pPF	 = &_PF;

	if(_pstateStackTop)
	{
		Assert(_pstateStackTop->pPF);

		// Add PF diffs to *_pstateStackTop->pPF
		if(!_pstateStackTop->AddPF(_PF, _bDocType, _dwMaskPF, _dwMaskPF2))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			return -1;
		}
		_dwMaskPF = _dwMaskPF2 = 0;  // _PF contains delta's from *_pstateStackTop->pPF

		pPF	   = _pstateStackTop->pPF;
		dwMask = _pstateStackTop->dwMaskPF;
		Assert(dwMask == PFM_ALLRTF);
		if(pPF->_wNumbering)
		{
			pPF->_wNumberingTab	  = _pstateStackTop->sIndentNumbering;
			pPF->_wNumberingStyle = _wNumberingStyle;
		}

		if(_bTableLevelIP + _bTableLevel)
		{
			pPF->_wEffects |= PFE_TABLE;
			dwMask |= PFM_TABLE;
			pPF->_bTableLevel = min(_bTableLevel + _bTableLevelIP, MAXTABLENEST);
		}
	}
	if(dwMask & PFM_TABSTOPS)
	{
		LONG cTab = _cTab;
		BOOL fIsTableRowDelimiter = pPF->IsTableRowDelimiter();
		const LONG *prgxTabs = &_rgxCell[0];

		if(fIsTableRowDelimiter)
		{
			dwMask2 = PFM2_ALLOWTRDCHANGE;
			if(!_cCell)
			{
				if(_iTabsTable >= 0)		// No cells defined here;
				{							// Use previous table defs
					Assert(_bTableLevel == 1 && !_fNo_iTabsTable);
					CTabs *pTabs = GetTabsCache()->Elem(_iTabsTable);
					_cCell = pTabs->_cTab/(CELL_EXTRA + 1);
					prgxTabs = pTabs->_prgxTabs;
				}
				else if(_prg->_rpTX.IsAfterTRD(ENDFIELD) && _iCell)
				{
					LONG x = 2000;			// Bad RTF: no \cellx's. Def 'em
					for(LONG i = 1; i <= _iCell; i++)
					{
						HandleCellx(x);
						x += 2000;
					}
				}
			}
			cTab = _cCell;
		}
		// Caching a tabs array AddRefs the corresponding cached tabs entry.
		// Be absolutely sure to release the entry before exiting the routine
		// that caches it (see GetTabsCache()->Release at end of this function).
		pPF->_bTabCount = cTab;
		if(fIsTableRowDelimiter)
			cTab *= CELL_EXTRA + 1;
		pPF->_iTabs = GetTabsCache()->Cache(prgxTabs, cTab);
		if(fIsTableRowDelimiter && _bTableLevel == 1)
		{
			iTabs = pPF->_iTabs;
			if(!_fNo_iTabsTable)
				_iTabsTable = pPF->_iTabs;
		}
		AssertSz(!cTab || pPF->_iTabs >= 0,
			"CRTFRead::Apply_PF: illegal pPF->_iTabs");
	}

	LONG fCell = (_prg->GetPrevChar() == CELL);
	LONG fIsAfterTRD = _prg->_rpTX.IsAfterTRD(0);

	if(fCell || fIsAfterTRD)				// Deal with table delimiters
	{										//  in hidden text and with
		_prg->_rpCF.AdjustBackward();		//  custom colors
		if(_prg->IsHidden())				
		{									// Turn off hidden text
			CCharFormat CF;
			CF._dwEffects = 0;				

			_prg->Set(cp, fCell ? 1 : 2);
			_prg->SetCharFormat(&CF, 0, NULL, CFM_HIDDEN, 0);
			CheckNotifyLowFiRTF(TRUE);
			_CF._dwEffects |= CFE_HIDDEN;	// Restore CFE_HIDDEN
			_dwMaskCF |= CFM_HIDDEN;
		}
		_prg->_rpCF.AdjustForward();
		if(fIsAfterTRD && _crCellCustom1)
		{
			pPF->_crCustom1 = _crCellCustom1;
			dwMask |= PFM_SHADING;
			if(_crCellCustom2)
			{
				pPF->_crCustom2 = _crCellCustom2;
				dwMask |= PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE;
			}
		}
	}

	if(dwMask)
	{
		_prg->Set(cp, cp - _cpThisPara);	// Select back to _cpThisPara
		_prg->SetParaFormat(pPF, NULL, dwMask, dwMask2);
	}
	_prg->Set(cp, 0);						// Restore _prg to an IP
	GetTabsCache()->Release(pPF->_iTabs);
	pPF->_iTabs = -1;
	return iTabs;
}

/*
 *	CRTFRead::StoreDestination(pstate, dest)
 *
 *	@mfunc
 *		Store STATE destination if processing the first control word of a group
 *
 *	@rdesc
 *		TRUE iff destination stored
 */
BOOL CRTFRead::StoreDestination(
	STATE *	pstate,
	LONG	dest)
{
	if(pstate && _f1stControlWord)
	{
		pstate->sDest = (SHORT)dest;
		return TRUE;
	}
	return FALSE;
}

/*
 *	CRTFRead::SetBorderParm(&Parm, Value)
 *
 *	@mfunc
 *		Set the border pen width in half points for the current border
 *		(_bBorder)
 */
void CRTFRead::SetBorderParm(
	WORD&	Parm,
	LONG	Value)
{
	Assert(_bBorder <= 3);

	Value = min(Value, 15);
	Value = max(Value, 0);
	Parm &= ~(0xF << 4*_bBorder);
	Parm |= Value << 4*_bBorder;
	_dwMaskPF |= PFM_BORDER;
}

/*
 *	CRTFRead::HandleToken()
 *
 *	@mfunc
 *		Grand switch board that handles all tokens. Switches on _token
 *
 *	@rdesc
 *		EC		The error code
 *
 *	@comm
 *		Token values are chosen contiguously (see tokens.h and tokens.c) to
 *		encourage the compiler to use a jump table.  The lite-RTF keywords
 *		come first, so that	an optimized OLE-free version works well.  Some
 *		groups of keyword tokens are ordered so as to simplify the code, e.g,
 *		those for font family names, CF effects, and paragraph alignment.
 */
EC CRTFRead::HandleToken()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleToken");

	BOOL				f1stControlWord = FALSE;// Default not 1st control word of current group
	DWORD				dwT;					// Temporary DWORD
	LONG				dy, i;
	LONG				iParam = _iParam;
	const CCharFormat *	pCF;
	STATE *				pstate = _pstateStackTop;
	TEXTFONT *			ptf;
	WORD				wT;						// Temporary WORD

	if(!pstate && _token != tokenStartGroup ||
	   IN_RANGE(tokenPicFirst, _token, tokenObjLast) && !_prtfObject)
	{
abort:	_ecParseError = ecAbort;
		return ecAbort;
	}
	switch (_token)
	{
	case tokenURtf:								// \urtf N - Preferred RE format
		PARSERCOVERAGE_CASE();					// Currently we ignore the N
		_dwFlags &= 0xFFFF;						// Kill possible codepage
		_dwFlags |= SF_USECODEPAGE | (CP_UTF8 << 16); // Save bit for Asserts
		pstate->SetCodePage(CP_UTF8);
		goto rtf;

	case tokenPocketWord:						// \pwd N - Pocket Word
		_dwFlags |= SFF_PWD;

	case tokenRtf:								// \rtf N - Backward compatible
		PARSERCOVERAGE_CASE();
rtf:	if(pstate->pstatePrev)
			goto abort;							// Can't handle nested rtf
		pstate->sDest = destRTF;
		Assert(pstate->nCodePage == INVALID_CODEPAGE ||
			   pstate->nCodePage == (int)(_dwFlags >> 16) &&
					(_dwFlags & SF_USECODEPAGE));

		if(!_fonts.Count() && !_fonts.Add(1, NULL))	// If can't add a font,
			goto OutOfRAM;						//  report the bad news
		_sDefaultFont = 0;						// Set up valid default font
		ptf = _fonts.Elem(0);
		pstate->ptf			  = ptf;			// Get char set, pitch, family
		pCF					  = _prg->GetCF();	//  from current range font
		ptf->iCharRep		  = pCF->_iCharRep;	// These are guaranteed OK
		ptf->bPitchAndFamily  = pCF->_bPitchAndFamily;
		ptf->sCodePage		  = (SHORT)CodePageFromCharRep(pCF->_iCharRep);
		wcscpy(ptf->szName, GetFontName(pCF->_iFont));
		ptf->fNameIsDBCS = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;
		pstate->cbSkipForUnicodeMax = iUnicodeCChDefault;
		break;

	case tokenViewKind:							// \viewkind N
		if(!(_dwFlags & SFF_SELECTION) && IsUTF8)// RTF applies to document:
			_ped->SetViewKind(iParam);			// For now, only do for \urtf
		break;									//  (need to work some more
												//  on OutlineView)
	case tokenViewScale:						// \viewscale N
		if(_dwFlags & SFF_PERSISTVIEWSCALE &&
			!(_dwFlags & SFF_SELECTION))			// RTF applies to document:
			_ped->SetViewScale(iParam);
		break;

	case tokenCharacterDefault:					// \plain
		PARSERCOVERAGE_CASE();
		SetPlain(pstate);
		break;

	case tokenCharSetAnsi:						// \ansi
		PARSERCOVERAGE_CASE();
		_iCharRep = ANSI_INDEX;
		break;

	case tokenMac:								// \mac
		_fMac = TRUE;
		break;

	case tokenDefaultLanguage:					// \deflang
		PARSERCOVERAGE_CASE();
		_sDefaultLanguage = (SHORT)iParam;
		break;

	case tokenDefaultLanguageFE:				// \deflangfe
		PARSERCOVERAGE_CASE();
		_sDefaultLanguageFE = (SHORT)iParam;
		break;

	case tokenDefaultTabWidth:					// \deftab
		PARSERCOVERAGE_CASE();
		_sDefaultTabWidth = (SHORT)iParam;
		break;


//--------------------------- Font Control Words -------------------------------

	case tokenDefaultFont:						// \deff N
		PARSERCOVERAGE_CASE();
		if(iParam >= 0)
		{
			if(!_fonts.Count() && !_fonts.Add(1, NULL))	// If can't add a font,
				goto OutOfRAM;							//  report the bad news
			_fonts.Elem(0)->sHandle = _sDefaultFont = (SHORT)iParam;
		}
		TRACEERRSZSC("tokenDefaultFont: Negative value", iParam);
		break;

	case tokenDefaultBiDiFont:					// \adeff N
		PARSERCOVERAGE_CASE();
		if(iParam >=0 && _fonts.Count() == 1)
		{
			if(!_fonts.Add(1, NULL))				
				goto OutOfRAM;						
			_fonts.Elem(1)->sHandle = _sDefaultBiDiFont = (SHORT)iParam;
		}
		TRACEERRSZSC("tokenDefaultBiDiFont: Negative value", iParam);
		break;

	case tokenFontTable:						// \fonttbl
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destFontTable);
		pstate->ptf = NULL;
		break;

	case tokenFontFamilyBidi:					// \fbidi
	case tokenFontFamilyTechnical:				// \ftech
	case tokenFontFamilyDecorative:				// \fdecor
	case tokenFontFamilyScript:					// \fscript
	case tokenFontFamilyModern:					// \fmodern
	case tokenFontFamilySwiss:					// \fswiss
	case tokenFontFamilyRoman:					// \froman
	case tokenFontFamilyDefault:				// \fnil
		PARSERCOVERAGE_CASE();
		AssertSz(tokenFontFamilyRoman - tokenFontFamilyDefault == 1,
			"CRTFRead::HandleToken: invalid token definition"); 

		if(pstate->ptf)
		{
			pstate->ptf->bPitchAndFamily
				= (BYTE)((_token - tokenFontFamilyDefault) << 4
						 | (pstate->ptf->bPitchAndFamily & 0xF));

			// Setup SYMBOL_CHARSET charset for \ftech if there isn't any charset info
			if(tokenFontFamilyTechnical == _token && pstate->ptf->iCharRep == DEFAULT_INDEX)
				pstate->ptf->iCharRep = SYMBOL_INDEX;
		}
		break;

	case tokenPitch:							// \fprq
		PARSERCOVERAGE_CASE();
		if(pstate->ptf)
			pstate->ptf->bPitchAndFamily
				= (BYTE)(iParam | (pstate->ptf->bPitchAndFamily & 0xF0));
		break;

	case tokenAnsiCodePage:						// \ansicpg
		PARSERCOVERAGE_CASE();
#if !defined(NOFULLDEBUG) && defined(DEBUG)
		if(_fSeenFontTable && _nCodePage == INVALID_CODEPAGE)
			TRACEWARNSZ("CRTFRead::HandleToken():  Found an \ansicpgN tag after "
							"the font table.  Should have code to fix-up "
							"converted font names and document text.");
#endif
		if(!(_dwFlags & SF_USECODEPAGE))
		{
			_nCodePage = iParam;
			pstate->SetCodePage(iParam);
		}
		Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);
		break;

	case tokenCodePage:							// \cpg
		PARSERCOVERAGE_CASE();
		pstate->SetCodePage(iParam);
		if(pstate->sDest == destFontTable && pstate->ptf)
		{
			pstate->ptf->sCodePage = (SHORT)iParam;
			pstate->ptf->iCharRep = CharRepFromCodePage(iParam);

			// If a document-level code page has not been specified,
			// grab this from the first font table entry containing a 
			// \fcharsetN or \cpgN
			if(_nCodePage == INVALID_CODEPAGE)
				_nCodePage = iParam;
		}
		break;

	case tokenCharSet:							// \fcharset N
		PARSERCOVERAGE_CASE();
		if(pstate->ptf)
		{
			pstate->ptf->iCharRep = CharRepFromCharSet((BYTE)iParam);
			pstate->ptf->sCodePage = (SHORT)CodePageFromCharRep(pstate->ptf->iCharRep);
			pstate->SetCodePage(pstate->ptf->sCodePage);

			// If a document-level code page has not been specified,
			// grab this from the first font table entry containing a 
			// \fcharsetN or \cpgN
			if (pstate->nCodePage != CP_SYMBOL && 
				_nCodePage == INVALID_CODEPAGE)
			{
				_nCodePage = pstate->nCodePage;
			}
			if(IsRTLCharSet(iParam))
			{
				if(_sDefaultBiDiFont == -1)
					_sDefaultBiDiFont = pstate->ptf->sHandle;

				if(!IsRTLCharRep(_iCharRepBiDi))
					_iCharRepBiDi = pstate->ptf->iCharRep;
			}
			_fCharSet = TRUE;
			if(iParam)
				_fNon0CharSet = TRUE;			// Not HTML converter
		}
		break;

	case tokenRealFontName:						// \fname
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destRealFontName);
		break;

	case tokenAssocFontSelect:					// \af N
		PARSERCOVERAGE_CASE();					
		pstate->rgDefFont[pstate->iDefFont].sHandle = iParam;
		iParam = 0;								// Fall thru to \afs N to 0 sSize

	case tokenAssocFontSize:					// \afs N
		PARSERCOVERAGE_CASE();
		pstate->rgDefFont[pstate->iDefFont].sSize = iParam;
		break;

	case tokenFontSelect:						// \f N
		PARSERCOVERAGE_CASE();
		if(iParam == -1)						// Can't handle this bizarre choice
			goto skip_group;

		if(pstate->sDest == destFontTable)		// Building font table
		{
			if(iParam == _sDefaultFont)
			{
				_fReadDefFont = TRUE;
				ptf = _fonts.Elem(0);
			}
			else if(iParam == _sDefaultBiDiFont)
				ptf = _fonts.Elem(1);

			else if(!(ptf =_fonts.Add(1,NULL)))	// Make room in font table for
			{									//  font to be parsed
OutOfRAM:
				_ped->GetCallMgr()->SetOutOfMemory();
				_ecParseError = ecNoMemory;
				break;
			}
			pstate->ptf		= ptf;
			ptf->sHandle	= (SHORT)iParam;	// Save handle
			ptf->szName[0]	= '\0';				// Start with null string
			ptf->bPitchAndFamily = 0;
			ptf->fNameIsDBCS = FALSE;
			ptf->sCodePage	= INVALID_CODEPAGE;
			ptf->fCpgFromSystem = FALSE;
			ptf->iCharRep = DEFAULT_INDEX;
		}
		else if(_fonts.Count() && pstate->sDest != destStyleSheet)	// Font switch in text
		{
			SHORT idx = DEFFONT_LTRCH;

			SelectCurrentFont(iParam);
			if(IsRTLCharRep(pstate->ptf->iCharRep))
			{
				_iCharRepBiDi = pstate->ptf->iCharRep;
				idx = DEFFONT_RTLCH;
				if(pstate->iDefFont == DEFFONT_LTRCH)
					pstate->iDefFont = DEFFONT_RTLCH;
			}
			pstate->rgDefFont[idx].sHandle = iParam;
			pstate->rgDefFont[idx].sSize = 0;
		}
		break;

	case tokenDBChars:							// \dbch
	case tokenHIChars:							// \hich
	case tokenLOChars:							// \loch
	case tokenRToLChars:						// \rtlch
	case tokenLToRChars:						// \ltrch
		pstate->iDefFont = _token - tokenLToRChars + DEFFONT_LTRCH;
		if(!IN_RANGE(DEFFONT_LTRCH, pstate->iDefFont, DEFFONT_RTLCH))
			break;
		i = pstate->rgDefFont[pstate->iDefFont].sHandle;
		if(i == -1)
			break;
		SelectCurrentFont(i);
		HandleNumber();							// Fix Word \ltrchN bug
		iParam = pstate->rgDefFont[pstate->iDefFont].sSize;
		if(!iParam)
			break;								// No \afs N value specified
												// Fall thru to \fs N
	case tokenFontSize:							// \fs N
		PARSERCOVERAGE_CASE();
		pstate->rgDefFont[pstate->iDefFont].sSize = iParam;
		_CF._yHeight = PointsToFontHeight(iParam);	// Convert font size in
		_dwMaskCF |= CFM_SIZE;					//  half points to logical
		break; 									//  units

	// NOTE: \*\fontemb and \*\fontfile are discarded. The font mapper will
	//		 have to do the best it can given font name, family, and pitch.
	//		 Embedded fonts are particularly nasty because legal use should
	//		 only support read-only which parser cannot enforce.

	case tokenLanguage:							// \lang N
		PARSERCOVERAGE_CASE();
		_CF._lcid = MAKELCID(iParam, SORT_DEFAULT);
		_dwMaskCF |= CFM_LCID;

        if(W32->IsBiDiLcid(_CF._lcid))
		{
            _iCharRepBiDi = CharRepFromLID(iParam);
			if(pstate->iDefFont == DEFFONT_LTRCH)	// Workaround Word 10 bug	
				pstate->iDefFont = DEFFONT_RTLCH;
		}
		break;


//-------------------------- Color Control Words ------------------------------

	case tokenColorTable:						// \colortbl
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destColorTable);
		_fGetColorYet = FALSE;
		break;

	case tokenColorRed:							// \red
		PARSERCOVERAGE_CASE();
		pstate->bRed = (BYTE)iParam;
		_fGetColorYet = TRUE;
		break;

	case tokenColorGreen:						// \green
		PARSERCOVERAGE_CASE();
		pstate->bGreen = (BYTE)iParam;
		_fGetColorYet = TRUE;
		break;

	case tokenColorBlue:						// \blue
		PARSERCOVERAGE_CASE();
		pstate->bBlue = (BYTE)iParam;
		_fGetColorYet = TRUE;
		break;

	case tokenColorForeground:					// \cf
		PARSERCOVERAGE_CASE();
		_CF._crTextColor = GetColor(CFM_COLOR);
		break;

	case tokenColorBackground:					// \highlight
		PARSERCOVERAGE_CASE();
		_CF._crBackColor = GetColor(CFM_BACKCOLOR);
		break;

	case tokenExpand:							// \expndtw N
		PARSERCOVERAGE_CASE();
		_CF._sSpacing = (SHORT) iParam;
		_dwMaskCF |= CFM_SPACING;
		break;

	case tokenCharStyle:						// \cs N
		PARSERCOVERAGE_CASE();
 		/*	FUTURE (alexgo): we may want to support character styles
		in some future version.
		_CF._sStyle = (SHORT)iParam;
		_dwMaskCF |= CFM_STYLE;  */

		if(pstate->sDest == destStyleSheet)
			goto skip_group;
		break;			   

	case tokenAnimText:							// \animtext N
		PARSERCOVERAGE_CASE();
		_CF._bAnimation = (BYTE)iParam;
		_dwMaskCF |= CFM_ANIMATION;
		CheckNotifyLowFiRTF(TRUE);
		break;

	case tokenKerning:							// \kerning N
		PARSERCOVERAGE_CASE();
		_CF._wKerning = (WORD)(10 * iParam);	// Convert to twips
		_dwMaskCF |= CFM_KERNING;
		break;

	case tokenHorzInVert:						// \horzvert N
		PARSERCOVERAGE_CASE();
		CheckNotifyLowFiRTF(TRUE);
		break;

	case tokenFollowingPunct:					// \*\fchars
		PARSERCOVERAGE_CASE();
		if(StoreDestination(pstate, destFollowingPunct))
		{
			char *pwchBuf=NULL;
			if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
			{
				if (_ped->SetFollowingPunct(pwchBuf) != NOERROR)	// Store this buffer inside doc
					FreePv(pwchBuf);
			}
			else if (pwchBuf)
				FreePv(pwchBuf);
		}
		break;

	case tokenLeadingPunct:						// \*\lchars
		PARSERCOVERAGE_CASE();
		if(StoreDestination(pstate, destLeadingPunct))
		{			
			char *pwchBuf=NULL;
			if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
			{
				if (_ped->SetLeadingPunct(pwchBuf) != NOERROR)	// Store this buffer inside doc	
					FreePv(pwchBuf);
			}
			else if (pwchBuf)
				FreePv(pwchBuf);
		}
		break;

	case tokenDocumentArea:						// \info
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destDocumentArea);
		break;

	case tokenVerticalRender:					// \vertdoc
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("Vertical" );
		if (!(_dwFlags & SFF_SELECTION))
			HandleSTextFlow(1);
		break;

	case tokenSTextFlow:						// \stextflow N
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("STextFlow" );
		if (!(_dwFlags & SFF_SELECTION) && !_ped->Get10Mode())
			HandleSTextFlow(iParam);
		break;

#ifdef FE
	USHORT		usPunct;						// Used for FE word breaking

	case tokenNoOverflow:						// \nooverflow
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("No Overflow");
		usPunct = ~WBF_OVERFLOW;
		goto setBrkOp;

	case tokenNoWordBreak:						// \nocwrap
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("No Word Break" );
		usPunct = ~WBF_WORDBREAK;
		goto setBrkOp;

	case tokenNoWordWrap:						// \nowwrap
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("No Word Word Wrap" );
		usPunct = ~WBF_WORDWRAP;

setBrkOp:
		if(!(_dwFlags & fRTFFE))
		{
			usPunct &= UsVGetBreakOption(_ped->lpPunctObj);
			UsVSetBreakOption(_ped->lpPunctObj, usPunct);
		}
		break;

	case tokenHorizontalRender:					// \horzdoc
		PARSERCOVERAGE_CASE();
		TRACEINFOSZ("Horizontal" );
		if(pstate->sDest == destDocumentArea && !(_dwFlags & fRTFFE))
			_ped->fModeDefer = FALSE;
		break;

#endif
//-------------------- Character Format Control Words -----------------------------

	case tokenUnderlineThickLongDash:			// \ulthldash		[18]
	case tokenUnderlineThickDotted:				// \ulthd			[17]
	case tokenUnderlineThickDashDotDot:			// \ulthdashdd		[16]
	case tokenUnderlineThickDashDot:			// \ulthdashd		[15]
	case tokenUnderlineThickDash:				// \ulthdash		[14]
	case tokenUnderlineLongDash:				// \ulldash			[13]
	case tokenUnderlineHeavyWave:				// \ulhwave			[12]
	case tokenUnderlineDoubleWave:				// \ululdbwave		[11]
	case tokenUnderlineHairline:				// \ulhair			[10]
	case tokenUnderlineThick:					// \ulth			[9]
	case tokenUnderlineDouble:					// \uldb			[3]
	case tokenUnderlineWord:					// \ulw				[2]
//		CheckNotifyLowFiRTF();

	case tokenUnderlineWave:					// \ulwave			[8]
	case tokenUnderlineDashDotDotted:			// \uldashdd		[7]
	case tokenUnderlineDashDotted:				// \uldashd			[6]
	case tokenUnderlineDash:					// \uldash			[5]
	case tokenUnderlineDotted:					// \uld				[4]
		PARSERCOVERAGE_CASE();
		_CF._bUnderlineType = (BYTE)(_token - tokenUnderlineWord + 2);
		_token = tokenUnderline;				// CRenderer::RenderUnderline()
		goto under;								//  reveals which of these are
												//  rendered specially
	case tokenUnderline:						// \ul			[Effect 4]
		PARSERCOVERAGE_CASE();					//  (see handleCF)
		_CF._bUnderlineType = CFU_UNDERLINE;
under:	_dwMaskCF |= CFM_UNDERLINETYPE;
		goto handleCF;

	case tokenDeleted:							// \deleted
		PARSERCOVERAGE_CASE();
		_dwMaskCF2 = CFM2_DELETED;				 
		dwT = CFE_DELETED;
		goto hndlCF;

	// These effects are turned on if their control word parameter is missing
	// or nonzero. They are turned off if the parameter is zero. This
	// behavior is usually identified by an asterisk (*) in the RTF spec.
	// The code uses fact that CFE_xxx = CFM_xxx
	case tokenImprint:							// \impr			[1000]
	case tokenEmboss:							// \embo			 [800]
 	case tokenShadow:							// \shad			 [400]
	case tokenOutline:							// \outl			 [200]
	case tokenSmallCaps:						// \scaps			  [40]
		CheckNotifyLowFiRTF();

handleCF:
	case tokenRevised:							// \revised			[4000]
	case tokenDisabled:							// \disabled		[2000]
	case tokenHiddenText:						// \v				 [100]
	case tokenCaps:								// \caps			  [80]
	case tokenLink:								// \link			  [20]
	case tokenProtect:							// \protect			  [10]
	case tokenStrikeOut:						// \strike			   [8]
	case tokenItalic:							// \i				   [2]
	case tokenBold:								// \b				   [1]
		PARSERCOVERAGE_CASE();
		dwT = 1 << (_token - tokenBold);		// Generate effect mask
		_dwMaskCF |= dwT;						
hndlCF:	_CF._dwEffects &= ~dwT;					// Default attribute off
		if(!_fParam || _iParam)					// Effect is on
			_CF._dwEffects |= dwT;				// In either case, the effect
		break;									//  is defined

	case tokenStopUnderline:					// \ulnone
		PARSERCOVERAGE_CASE();
		_CF._dwEffects &= ~CFE_UNDERLINE;		// Kill all underlining
		_dwMaskCF	   |=  CFM_UNDERLINE;
		break;

	case tokenRevAuthor:						// \revauth N
		PARSERCOVERAGE_CASE();
		/* FUTURE: (alexgo) this doesn't work well now since we don't support
		revision tables.  We may want to support this better in the future. 
		So what we do now is the 1.0 technique of using a color for the
		author */
		if(iParam > 0)
		{
			_CF._dwEffects &= ~CFE_AUTOCOLOR;
			_dwMaskCF |= CFM_COLOR;
			_CF._crTextColor = rgcrRevisions[(iParam - 1) & REVMASK];
		}
		break;

	case tokenUp:								// \up
		PARSERCOVERAGE_CASE();
		dy = 10;
		goto StoreOffset;

	case tokenDown:								// \down
		PARSERCOVERAGE_CASE();
		dy = -10;

StoreOffset:
		if(!_fParam)
			iParam = dyDefaultSuperscript;
		_CF._yOffset = iParam * dy;				// Half points->twips
		_dwMaskCF |= CFM_OFFSET;
		break;

	case tokenSuperscript:						// \super
		PARSERCOVERAGE_CASE();
	     dwT = CFE_SUPERSCRIPT; 
		 goto SetSubSuperScript;

	case tokenSubscript:						// \sub
		PARSERCOVERAGE_CASE();
		 dwT = CFE_SUBSCRIPT;
		 goto SetSubSuperScript;

	case tokenNoSuperSub:						// \nosupersub
		PARSERCOVERAGE_CASE();
		 dwT = 0;
SetSubSuperScript:
		 _dwMaskCF	   |=  (CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
		 _CF._dwEffects &= ~(CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
		 _CF._dwEffects |= dwT;
		 break;



//--------------------- Paragraph Control Words -----------------------------

	case tokenStyleSheet:						// \stylesheet
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destStyleSheet);
		_Style = 0;								// Default normal style
		break;

	case tokenTabBar:							// \tb
		PARSERCOVERAGE_CASE();
		_bTabType = PFT_BAR;					// Fall thru to \tx

	case tokenTabPosition:						// \tx
		PARSERCOVERAGE_CASE();
		if(_cTab < MAX_TAB_STOPS && (unsigned)iParam < 0x1000000)
		{
			_rgxCell[_cTab++] = GetTabPos(iParam)
				+ (_bTabType << 24) + (_bTabLeader << 28);
			_dwMaskPF |= PFM_TABSTOPS;
		}
		_cCell = 0;								// Invalidate _rgxCell array
		break;									//  for table purposes

	case tokenDecimalTab:						// \tqdec
	case tokenFlushRightTab:					// \tqr
	case tokenCenterTab:						// \tqc
		PARSERCOVERAGE_CASE();
		_bTabType = (BYTE)(_token - tokenCenterTab + PFT_CENTER);
		break;

	case tokenTabLeaderEqual:					// \tleq
	case tokenTabLeaderThick:					// \tlth
	case tokenTabLeaderUnderline:				// \tlul
	case tokenTabLeaderHyphen:					// \tlhyph
		CheckNotifyLowFiRTF();
	case tokenTabLeaderDots:					// \tldot
		PARSERCOVERAGE_CASE();
		_bTabLeader = (BYTE)(_token - tokenTabLeaderDots + PFTL_DOTS);
		break;

	// The following need to be kept in sync with PFE_xxx
	case tokenRToLPara:							// \rtlpar
		_ped->OrCharFlags(FRTL);

	case tokenCollapsed:						// \collapsed
	case tokenSideBySide:						// \sbys
	case tokenHyphPar:							// \hyphpar
	case tokenNoWidCtlPar:						// \nowidctlpar
	case tokenNoLineNumber:						// \noline
	case tokenPageBreakBefore:					// \pagebb
	case tokenKeepNext:							// \keepn
	case tokenKeep:								// \keep
		PARSERCOVERAGE_CASE();
		wT = (WORD)(1 << (_token - tokenRToLPara));
		_PF._wEffects |= wT;
		_dwMaskPF |= (wT << 16);
		break;

	case tokenLToRPara:							// \ltrpar
		PARSERCOVERAGE_CASE();
		_PF._wEffects &= ~PFE_RTLPARA;
		_dwMaskPF |= PFM_RTLPARA;
		break;

	case tokenLineSpacing:						// \sl N
		PARSERCOVERAGE_CASE();
		_PF._dyLineSpacing = abs(iParam);
		_PF._bLineSpacingRule					// Handle nonmultiple rules 
				= (BYTE)(!iParam || iParam == 1000
				? 0 : (iParam > 0) ? tomLineSpaceAtLeast
				    : tomLineSpaceExactly);		// \slmult can change (has to
		_dwMaskPF |= PFM_LINESPACING;			//  follow if it appears)
		break;

	case tokenDropCapLines:						// \dropcapliN
		if(_PF._bLineSpacingRule == tomLineSpaceExactly)	// Don't chop off
			_PF._bLineSpacingRule = tomLineSpaceAtLeast;	//  drop cap
		_fBody = TRUE;
		break;

	case tokenLineSpacingRule:					// \slmult N
		PARSERCOVERAGE_CASE();					
		if(iParam)
		{										// It's multiple line spacing
			_PF._bLineSpacingRule = tomLineSpaceMultiple;
			_PF._dyLineSpacing /= 12;			// RE line spacing multiple is
			_dwMaskPF |= PFM_LINESPACING;		//  given in 20ths of a line,
		}										//  while RTF uses 240ths	
		break;

	case tokenSpaceBefore:						// \sb N
		PARSERCOVERAGE_CASE();
		_PF._dySpaceBefore = iParam;
		_dwMaskPF |= PFM_SPACEBEFORE;
		break;

	case tokenSpaceAfter:						// \sa N
		PARSERCOVERAGE_CASE();
		_PF._dySpaceAfter = iParam;
		_dwMaskPF |= PFM_SPACEAFTER;
		break;

	case tokenStyle:							// \s N
		PARSERCOVERAGE_CASE();
		_Style = iParam;						// Save it in case in StyleSheet
		if(pstate->sDest != destStyleSheet)
		{										// Select possible heading level
			_PF._sStyle = STYLE_NORMAL;			// Default Normal style
			_PF._bOutlineLevel |= 1;

			for(i = 0; i < NSTYLES && iParam != _rgStyles[i]; i++)
				;								// Check for heading style
			if(i < NSTYLES)						// Found one
			{
				_PF._sStyle = (SHORT)(-i - 1);	// Store desired heading level
				_PF._bOutlineLevel = (BYTE)(2*(i-1));// Update outline level for
			}									//  nonheading styles
			_dwMaskPF |= PFM_ALLRTF;
		}
		break;

	case tokenIndentFirst:						// \fi N
		PARSERCOVERAGE_CASE();
		_PF._dxStartIndent += _PF._dxOffset		// Cancel current offset
							+ iParam;			//  and add in new one
		_PF._dxOffset = -iParam;				// Offset for all but 1st line
												//  = -RTF_FirstLineIndent
		_dwMaskPF |= (PFM_STARTINDENT | PFM_OFFSET);
		break;						

	case tokenIndentLeft:						// \li N
	case tokenIndentRight:						// \ri N
		PARSERCOVERAGE_CASE();
		// AymanA: For RtL para indents has to be flipped.
		Assert(PFE_RTLPARA == 0x0001);
		if((_token == tokenIndentLeft) ^ (_PF.IsRtlPara()))
		{
			_PF._dxStartIndent = iParam - _PF._dxOffset;
			_dwMaskPF |= PFM_STARTINDENT;
		}
		else
		{
			_PF._dxRightIndent = iParam;
			_dwMaskPF |= PFM_RIGHTINDENT;
		}
		break;

	case tokenAlignLeft:						// \ql
	case tokenAlignRight:						// \qr
	case tokenAlignCenter:						// \qc
	case tokenAlignJustify:						// \qj
		PARSERCOVERAGE_CASE();
		_PF._bAlignment = (WORD)(_token - tokenAlignLeft + PFA_LEFT);
		_dwMaskPF |= PFM_ALIGNMENT;
		break;

	case tokenBorderOutside:					// \brdrbar
	case tokenBorderBetween:					// \brdrbtw
	case tokenBorderShadow:						// \brdrsh
		PARSERCOVERAGE_CASE();
		_PF._dwBorderColor |= 1 << (_token - tokenBorderShadow + 20);
		_dwBorderColors = _PF._dwBorderColor;
		break;

	// Paragraph and cell border segments
	case tokenBox:								// \box
		PARSERCOVERAGE_CASE();
		CheckNotifyLowFiRTF();
		_PF._wEffects |= PFE_BOX;
		_dwMaskPF	 |= PFM_BOX;
		_bBorder = 0;							// Store parms as if for
		break;									//  \brdrt

	case tokenBorderBottom:						// \brdrb
	case tokenBorderRight:						// \brdrr
	case tokenBorderTop:						// \brdrt
		if((rgKeyword[_iKeyword].szKeyword[0] | 0x20) != 't')
			CheckNotifyLowFiRTF();
	case tokenBorderLeft:						// \brdrl

	case tokenCellBorderBottom:					// \clbrdrb
	case tokenCellBorderRight:					// \clbrdrr
	case tokenCellBorderTop:					// \clbrdrt
	case tokenCellBorderLeft:					// \clbrdrl
		PARSERCOVERAGE_CASE();
		_bBorder = (BYTE)(_token - tokenBorderLeft);
		break;

	// Paragraph border styles
	case tokenBorderTriple:						// \brdrtriple
	case tokenBorderDoubleThick:				// \brdrth
	case tokenBorderSingleThick:				// \brdrs
	case tokenBorderHairline:					// \brdrhair
	case tokenBorderDot:						// \brdrdot
	case tokenBorderDouble:						// \brdrdb
	case tokenBorderDashSmall:					// \brdrdashsm
	case tokenBorderDash:						// \brdrdash
		PARSERCOVERAGE_CASE();
		if(_bBorder < 4)						// Only for paragraphs
			SetBorderParm(_PF._wBorders, _token - tokenBorderDash);
		break;

	case tokenBorderColor:						// \brdrcf
		PARSERCOVERAGE_CASE();
		if(_bBorder < 4)						// Only for paragraphs
		{
			iParam = GetStandardColorIndex();
			_PF._dwBorderColor &= ~(0x1F << (5*_bBorder));
			_PF._dwBorderColor |= iParam << (5*_bBorder);
			_dwBorderColors = _PF._dwBorderColor;
		}
		else									// Cell borders
			_dwCellColors |= GetCellColorIndex() << (5*(_bBorder - 4));
		break;

	case tokenBorderWidth:						// \brdrw
		PARSERCOVERAGE_CASE();					// Store width in half pts
												// iParam is in twips
		if(_bBorder < 4)						// Paragraphs
		{
			iParam = TwipsToQuarterPoints(iParam);		
			SetBorderParm(_PF._wBorderWidth, iParam);
		}
		else									// Table cells
		{
			iParam = CheckTwips(iParam);		
			_dwCellBrdrWdths |= iParam << 8*(_bBorder - 4);
		}
		break;

	case tokenBorderSpace:						// \brsp
		PARSERCOVERAGE_CASE();					// Space is in pts
		if(_bBorder < 4)						// Only for paragraphs
			SetBorderParm(_PF._wBorderSpace, iParam/20);// iParam is in twips
		break;

	// Paragraph shading
	case tokenBckgrndVert:						// \bgvert
	case tokenBckgrndHoriz:						// \bghoriz
	case tokenBckgrndFwdDiag:					// \bgfdiag
	case tokenBckgrndDrkVert:	   				// \bgdkvert
	case tokenBckgrndDrkHoriz:					// \bgdkhoriz
	case tokenBckgrndDrkFwdDiag:				// \bgdkfdiag
	case tokenBckgrndDrkDiagCross:				// \bgdkdcross
	case tokenBckgrndDrkCross:					// \bgdkcross
	case tokenBckgrndDrkBckDiag:				// \bgdkbdiag
	case tokenBckgrndDiagCross:					// \bgdcross
	case tokenBckgrndCross:						// \bgcross
	case tokenBckgrndBckDiag:					// \bgbdiag
		PARSERCOVERAGE_CASE();
		_PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xFFC0)
						| (_token - tokenBckgrndBckDiag + 1));
		_dwMaskPF |= PFM_SHADING;
		break;

	case tokenColorBckgrndPat:					// \cbpat
		PARSERCOVERAGE_CASE();
		iParam = GetStandardColorIndex();
		_PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0x07FF) | (iParam << 11));
		_dwMaskPF |= PFM_SHADING;
		break;

	case tokenColorForgrndPat:					// \cfpat
		PARSERCOVERAGE_CASE();
		iParam = GetStandardColorIndex();
		_PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xF83F) | (iParam << 6));
		_dwMaskPF |= PFM_SHADING;
		break;

	case tokenShading:							// \shading
		PARSERCOVERAGE_CASE();
		_PF._wShadingWeight = (WORD)iParam;
		_dwMaskPF |= PFM_SHADING;
		break;

	// Paragraph numbering
	case tokenParaNum:							// \pn
		PARSERCOVERAGE_CASE();
		if(StoreDestination(pstate, destParaNumbering))
		{
			pstate->fBullet = FALSE;
			_PF._wNumberingStart = 1;
			_dwMaskPF |= PFM_NUMBERINGSTART;
		}
		break;

	case tokenParaNumIndent:					// \pnindent N
		PARSERCOVERAGE_CASE();
		if(pstate->sDest == destParaNumbering)
			pstate->sIndentNumbering = (SHORT)iParam;
		break;

	case tokenParaNumStart:						// \pnstart N
		PARSERCOVERAGE_CASE();
		if(pstate->sDest == destParaNumbering)
		{
			_PF._wNumberingStart = (WORD)iParam;
			_dwMaskPF |= PFM_NUMBERINGSTART;
		}
		break;

	case tokenParaNumCont:						// \pnlvlcont
		PARSERCOVERAGE_CASE();					
		_prg->_rpPF.AdjustBackward();			// Maintain numbering mode
		_PF._wNumbering = _prg->GetPF()->_wNumbering;
		_prg->_rpPF.AdjustForward();
		_wNumberingStyle = PFNS_NONUMBER;		// Signal no number
		_dwMaskPF |= PFM_NUMBERING;				// Note: can be new para with
		pstate->fBullet = TRUE;					//  its own indents
		break;

	case tokenParaNumBody:						// \pnlvlbody
		PARSERCOVERAGE_CASE();
		_wNumberingStyle = PFNS_PAREN;
		_token = tokenParaNumDecimal;			// Default to decimal
		goto setnum;
		
	case tokenParaNumBullet:					// \pnlvlblt
		_wNumberingStyle = 0;					// Reset numbering styles
		goto setnum;

	case tokenParaNumDecimal:					// \pndec
	case tokenParaNumLCLetter:					// \pnlcltr
	case tokenParaNumUCLetter:					// \pnucltr
	case tokenParaNumLCRoman:					// \pnlcrm
	case tokenParaNumUCRoman:					// \pnucrm
		PARSERCOVERAGE_CASE();
		if(_PF._wNumbering == PFN_BULLET && pstate->fBullet)
			break;								// Ignore above for bullets

setnum:	if(pstate->sDest == destParaNumbering)
		{
			_PF._wNumbering = (WORD)(PFN_BULLET + _token - tokenParaNumBullet);
			_dwMaskPF |= PFM_NUMBERING;
			pstate->fBullet	= TRUE;				// We do bullets, so don't
		}										//  output the \pntext group
		break;

	case tokenParaNumText:						// \pntext
		PARSERCOVERAGE_CASE();
		// Throw away previously read paragraph numbering and use
		//	the most recently read to apply to next run of text.
		StoreDestination(pstate, destParaNumText);
		_cchUsedNumText = 0;
		break;

	case tokenParaNumAlignCenter:				// \pnqc
	case tokenParaNumAlignRight:				// \pnqr
		PARSERCOVERAGE_CASE();
		_wNumberingStyle = (_wNumberingStyle & ~3) | _token - tokenParaNumAlignCenter + 1;
		break;

	case tokenPictureQuickDraw:					// \macpict
	case tokenPictureOS2Metafile:				// \pmmetafile
		CheckNotifyLowFiRTF(TRUE);

	case tokenParaNumAfter:						// \pntxta
	case tokenParaNumBefore:					// \pntxtb
		PARSERCOVERAGE_CASE();

skip_group:
		if(!SkipToEndOfGroup())
		{
			// During \fonttbl processing, we may hit unknown destinations,
			// e.g., \panose, that cause the HandleEndGroup to select the
			// default font, which may not be defined yet.  So,	we change
			// sDest to avoid this problem.
			if(pstate->sDest == destFontTable || pstate->sDest == destStyleSheet)
				pstate->sDest = destNULL;
			HandleEndGroup();
		}
		break;

	// Tables
	case tokenInTable:							// \intbl
		PARSERCOVERAGE_CASE();
		if(pstate->sDest != destRTF && pstate->sDest != destFieldResult &&
		   pstate->sDest != destParaNumText)
		{
			_ecParseError = ecUnexpectedToken;
			break;
		}
		if(!_iCell && !_bTableLevel)
			DelimitRow(szRowStart);				// Start row	
		break;

	case tokenNestCell:							// \nestcell
	case tokenCell:								// \cell
		PARSERCOVERAGE_CASE();
		HandleCell();
		break;

	case tokenRowHeight:						// \trrh N
		PARSERCOVERAGE_CASE();
		_dyRow = iParam;
		break;									
												
	case tokenCellHalfGap:						// \trgaph N
		PARSERCOVERAGE_CASE();					// Save half space between
		if((unsigned)iParam > 255)				// Illegal value: use default
			iParam = 108;
		_dxCell = iParam;						//  cells to add to tabs
		break;									// Roundtrip value at end of
												//  tab array
	case tokenCellX:							// \cellx N
		PARSERCOVERAGE_CASE();
		HandleCellx(iParam);
		break;

	case tokenRowDefault:						// \trowd
		PARSERCOVERAGE_CASE();
		if(_ped->fUsePassword() || pstate->sDest == destParaNumText)
		{
			_ecParseError = ecUnexpectedToken;
			break;
		}
		// Insert a newline if we are inserting a table behind characters in the 
		// same line.  This follows the Word9 model.
		if (_cpFirst == _prg->GetCp() && _cpThisPara != _cpFirst)
		{
			EC ec  = _ped->fUseCRLF()			// If RichEdit 1.0 compatibility
				? HandleText(szaCRLF, ALL_ASCII)//  mode, use CRLF; else CR
				: HandleChar((unsigned)(CR));
			if(ec == ecNoError)
				_cpThisPara = _prg->GetCp();	// New para starts after CRLF
		}

		_cCell = 0;								// No cell right boundaries
		_dxCell = 0;							//  or half gap defined yet
		_xRowOffset = 0;
		_dwCellBrdrWdths = 0;
		_dyRow = 0;								// No row height yet
		_wBorderWidth	= 0;					// No borders yet
		_dwBorderColors	= 0;					// No colors yet
		_dwCellColors	= 0;					// No colors yet
		_dwShading = 0;							// No shading yet
		_bAlignment = PFA_LEFT;
		_iTabsTable = -1;						// No cell widths yet
		_bCellFlags = 0;						// No cell vert merge
		_crCellCustom1 = 0;
		_crCellCustom2 = 0;
		_fRTLRow = FALSE;
		_fStartRow = FALSE;
		_fCellxOK = TRUE;
		break;

	case tokenRowLeft:							// \trleft N
		PARSERCOVERAGE_CASE();
		_xRowOffset = iParam;
		break;
												
	case tokenRowAlignCenter:					// \trqc
	case tokenRowAlignRight:					// \trqr
		PARSERCOVERAGE_CASE();
		_bAlignment = (WORD)(_token - tokenRowAlignRight + PFA_RIGHT);
		break;

	case tokenRToLRow:							// \rtlrow
		_fRTLRow = TRUE;
		break;

	case tokenNestRow:							// \nestrow
		_fNo_iTabsTable = TRUE;
		goto row;

	case tokenRow:								// \row
		PARSERCOVERAGE_CASE();
		_iTabsLevel1 = -1;
row:
		if(!_bTableLevel)						// Ignore \row and \nestrow if not in table
			break;
		while(_iCell < _cCell)					// If not enuf cells, add
			HandleCell();						//  them since Word crashes
		DelimitRow(szRowEnd);
		if(_fNo_iTabsTable && !_bTableLevel)	// New nested table format
			InitializeTableRowParms();			//  used so reset _cCell
		break;									//  (new values will be given)

	case tokenCellBackColor:					// \clcbpat N
		_dwCellColors |= GetCellColorIndex() << 4*5;
		break;

	case tokenCellForeColor:					// \clcfpat N
		_dwCellColors |= GetCellColorIndex() << 5*5;
		break;

	case tokenCellShading:						// \clshdng N
		_dwShading = iParam/50;					// Store in .5 per cents
		break;									// (N is in .01 per cent)

	case tokenCellAlignBottom:					// \clvertalb
	case tokenCellAlignCenter:					// \clvertalc
		PARSERCOVERAGE_CASE();
		_bCellFlags |= _token - tokenCellAlignCenter + 1;
		break;

	case tokenCellMergeDown:					// \clvmgf
		_bCellFlags |= fTopCell >> 24;
		break;

	case tokenCellMergeUp:						// \clvmrg
		_bCellFlags |= fLowCell >> 24;
		break;

	case tokenCellTopBotRLVert:					// \cltxtbrlv
		PARSERCOVERAGE_CASE();
		_bCellFlags |= fVerticalCell >> 24;
		break;

	case tokenCellLRTB:							// \cltxlrtb
		break;									// This is the default
												//  so don't fire LowFiRTF
	case tokenTableLevel:						// \itap N
		PARSERCOVERAGE_CASE();					// Set table level
		if(pstate->fShape)						// Bogus shape RTF
			break;
		AssertSz(iParam >= _bTableLevel,
			"CRTFRead::HandleToken: illegal itap N");
		if(iParam)
		{
			if(pstate->sDest != destRTF && pstate->sDest != destFieldResult || iParam > 127)
				goto abort;
			_iTabsTable = -1;					// Previous cell widths invalid
			_cCell = 0;
			while(iParam > _bTableLevel)
				DelimitRow(szRowStart);			// Insert enuf table row headers
		}
		_fNo_iTabsTable = TRUE;
		break;

	case tokenNestTableProps:					// \nesttableprops
		StoreDestination(pstate, destNestTableProps);
		break;									// Control word is recognized

	case tokenNoNestTables:						// \nonesttables
		goto skip_group;						// Ignore info for nesttable
												//  unaware readers
	case tokenPage:								// \page
		// FUTURE: we want to be smarter about handling FF. But for
		// now we ignore it for bulletted and number paragraphs
		// and RE 1.0 mode.
		if (_PF._wNumbering != 0 || _ped->Get10Mode())
			break;

		// Intentional fall thru to EOP
	case tokenEndParagraph:						// \par
	case tokenLineBreak:						// \line
		PARSERCOVERAGE_CASE();
		HandleEndOfPara();
		break;								

	case tokenParagraphDefault:					// \pard
		PARSERCOVERAGE_CASE();
		if(pstate->sDest != destParaNumText)	// Ignore if \pn destination
			Pard(pstate);
		break;
												
	case tokenEndSection:						// \sect
		CheckNotifyLowFiRTF();					// Fall thru to \sectd

	case tokenSectionDefault:					// \sectd
		PARSERCOVERAGE_CASE();
		Pard(pstate);
		break;

	case tokenBackground:						// \background
		 if(_dwFlags & SFF_SELECTION)			// If pasting a selection,
			goto skip_group;					//  skip background
		pstate->fBackground = TRUE;				// Enable background. NB:
		break;									//  InitBackground() already called


//----------------------- Field and Group Control Words --------------------------------
	case tokenField:							// \field
		PARSERCOVERAGE_CASE();

		if (pstate->sDest == destDocumentArea ||
			pstate->sDest == destLeadingPunct ||
			pstate->sDest == destFollowingPunct)
		{
			// We're not equipped to handle symbols in these destinations, and
			// we don't want the fields added accidentally to document text.
			goto skip_group;
		}
		StoreDestination(pstate, destField);
		break;

	case tokenFieldResult:						// \fldrslt
		PARSERCOVERAGE_CASE();

		if(_fSymbolField)
			goto skip_group;

		if(StoreDestination(pstate, destFieldResult))
			AddText(pchSeparateField, 2, FALSE);
		break;

	case tokenFieldInstruction:					// \fldinst
		PARSERCOVERAGE_CASE();
		if(_f1stControlWord && AddText(pchStartField, 2, FALSE) == ecNoError)
			pstate->sDest = destFieldInstruction;
		break;

	case tokenStartGroup:						// Save current state by
		PARSERCOVERAGE_CASE();					//  pushing it onto stack
		HandleStartGroup();
		if (_fNoRTFtoken)
		{
			// Hack Alert !!!!! For 1.0 compatibility set up to allow no \rtf token.
			_fNoRTFtoken = FALSE;
			pstate = _pstateStackTop;
			goto rtf;
		}
		f1stControlWord = TRUE;					// Signal 1st control word of group
		break;

	case tokenEndGroup:
		PARSERCOVERAGE_CASE();
		HandleFieldEndGroup();					// Special end group handling for \field
		HandleEndGroup();						// Restore save state by
		break;									//  popping stack

	case tokenOptionalDestination:				// \* (see case tokenUnknown)
		PARSERCOVERAGE_CASE();
		f1stControlWord = _f1stControlWord;		// Maintain current _f1stControlWord state 
		break;

	case tokenNullDestination:					// Found a destination whose group
		PARSERCOVERAGE_CASE();					//  should be skipped
        // tokenNullDestination triggers a loss notification here for...
        //      Footer related tokens - "footer", "footerf", "footerl", "footerr", 
        //                              "footnote", "ftncn", "ftnsep",  "ftnsepc"
        //      Header related tokens - "header", "headerf", "headerl", "headerr"
        //      Table of contents     - "tc"
        //      Index entries         - "xe"

		CheckNotifyLowFiRTF();
		// V-GUYB: PWord Converter requires loss notification.
		#ifdef REPORT_LOSSAGE
        if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
        {
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
		#endif // REPORT_LOSSAGE
		
		goto skip_group;

	case tokenUnknownKeyword:
		PARSERCOVERAGE_CASE();
		if(_tokenLast == tokenOptionalDestination)
			goto skip_group;
		break;


//-------------------------- Text Control Words --------------------------------

	case tokenUnicode:							// \u N
		PARSERCOVERAGE_CASE();
		HandleUN(pstate);
		break;

	case tokenUnicodeCharByteCount:				// \uc N
		PARSERCOVERAGE_CASE();
		if(IN_RANGE(0, iParam, 2))
			pstate->cbSkipForUnicodeMax = iParam;
		break;

	case tokenText:								// Lexer concludes tokenText
	case tokenASCIIText:
		PARSERCOVERAGE_CASE();
		HandleTextToken(pstate);
		break;

	// \ltrmark, \rtlmark, \zwj, and \zwnj are translated directly into
	// their Unicode values. \ltrmark and \rtlmark cause no further
	// processing here because we assume that the current font has the
	// CharSet needed to identify the direction.
	case tokenLToRDocument:						// \ltrdoc
		PARSERCOVERAGE_CASE();
		_bDocType = DT_LTRDOC;
		break;

	case tokenRToLDocument:						// \rtldoc
		PARSERCOVERAGE_CASE();
		_bDocType = DT_RTLDOC;
		_ped->OrCharFlags(FRTL);
		break;


//--------------------------Shape Control Words---------------------------------

	case tokenShape:							// \shp
		if(!pstate->fBackground)
			CheckNotifyLowFiRTF(TRUE);
		pstate->fShape = TRUE;
		_dwFlagsShape = 0;
		break;

	case tokenShapeName:						// \sn name
		pstate->sDest = destShapeName;
		break;

	case tokenShapeValue:						// \sv value
		pstate->sDest = destShapeValue;
		break;

	case tokenShapeWrap:						// \shpwr N
		if(iParam == 2)
			_dwFlagsShape |= REO_WRAPTEXTAROUND;
		break;

	case tokenPositionRight:					// \posxr
		_dwFlagsShape |= REO_ALIGNTORIGHT;
		break;


//------------------------- Object Control Words --------------------------------

	case tokenObject:							// \object
		PARSERCOVERAGE_CASE();
		// V-GUYB: PWord Converter requires loss notification.
		#ifdef REPORT_LOSSAGE
       	if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
       	{
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
		#endif // REPORT_LOSSAGE
		
		// Assume that the object failed to load until proven otherwise
		// 	by RTFRead::ObjectReadFromEditStream
	  	// This works for both:
		//	- an empty \objdata tag
		//	- a non-existent \objdata tag
		_fFailedPrevObj = TRUE;

	case tokenPicture:							// \pict
		PARSERCOVERAGE_CASE();

		FreeRtfObject();
		if (IN_RANGE(destColorTable, _pstateStackTop->sDest, destPicture))
		{										// Don't want new pict\object if
			_ecParseError = ecUnexpectedToken;	//	current state can't handle it. 
			break;
		}

		if(!StoreDestination(pstate, _token == tokenPicture ? destPicture : destObject))
			break;

		_prtfObject = (RTFOBJECT *) PvAlloc(sizeof(RTFOBJECT), GMEM_ZEROINIT);
		if(!_prtfObject)
			goto OutOfRAM;
		_prtfObject->xScale = _prtfObject->yScale = 100;
		_prtfObject->cBitsPerPixel = 1;
		_prtfObject->cColorPlanes = 1;
		_prtfObject->szClass = NULL;
		_prtfObject->szName = NULL;
		_prtfObject->sType = -1;
		break;

	case tokenObjectEBookImage:
		// Added by VikramM for E-Book
		//
		_prtfObject->sType = ROT_EBookImage;
		break;

	case tokenObjectEmbedded:					// \objemb
	case tokenObjectLink:						// \objlink
	case tokenObjectAutoLink:					// \objautlink
		PARSERCOVERAGE_CASE();
		_prtfObject->sType = (SHORT)(_token - tokenObjectEmbedded + ROT_Embedded);
		break;

	case tokenObjectMacSubscriber:				// \objsub
	case tokenObjectMacPublisher:				// \objpub
	case tokenObjectMacICEmbedder:
		PARSERCOVERAGE_CASE();
		_prtfObject->sType = ROT_MacEdition;
		break;

	case tokenWidth:							// \picw N or \objw N
		PARSERCOVERAGE_CASE();
		_prtfObject->xExt = iParam;
		break;

	case tokenHeight:							// \pic N or \objh N
		PARSERCOVERAGE_CASE();
		_prtfObject->yExt = iParam;
		break;

	case tokenObjectSetSize:					// \objsetsize
		PARSERCOVERAGE_CASE();
		_prtfObject->fSetSize = TRUE;
		break;

	case tokenScaleX:							// \picscalex N or \objscalex N
		PARSERCOVERAGE_CASE();
		_prtfObject->xScale = iParam;
		break;

	case tokenScaleY:							// \picscaley N or \objscaley N
		PARSERCOVERAGE_CASE();
		_prtfObject->yScale = iParam;
		break;

	case tokenCropLeft:							// \piccropl or \objcropl
 	case tokenCropTop:							// \piccropt or \objcropt
	case tokenCropRight:						// \piccropr or \objcropr
	case tokenCropBottom:						// \piccropb or \objcropb
		PARSERCOVERAGE_CASE();
		*((LONG *)&_prtfObject->rectCrop
			+ (_token - tokenCropLeft)) = iParam;
		break;

	case tokenObjectClass:						// \objclass
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destObjectClass);
		break;

	case tokenObjectName:						// \objname
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destObjectName);
		break;

	case tokenObjectResult:						// \result
		PARSERCOVERAGE_CASE();
		if(_fMac ||								// If it's Mac stuff, we don't
		   _prtfObject->sType==ROT_MacEdition ||//  understand the data, or if
		   _fFailedPrevObj || _fNeedPres)		//  we need an obj presentation,
		{
			pstate->sDest = destRTF;			//  use the object results
			break;
		}
		goto skip_group;

	case tokenObjectData:						// \objdata
		PARSERCOVERAGE_CASE();
		StoreDestination(pstate, destObjectData);
		if(_prtfObject->sType==ROT_MacEdition)	// It's Mac stuff so just
			goto skip_group;					//  throw away the data
		break;

	case tokenPictureWindowsMetafile:			// \wmetafile
#ifdef NOMETAFILES
		goto skip_group;
#endif NOMETAFILES

	case tokenPngBlip:							// \pngblip
	case tokenJpegBlip:							// \jpegblip
	case tokenPictureWindowsDIB:				// \dibitmap N
	case tokenPictureWindowsBitmap:				// \wbitmap N
		PARSERCOVERAGE_CASE();
		_prtfObject->sType = (SHORT)(_token - tokenPictureWindowsBitmap + ROT_Bitmap);
		_prtfObject->sPictureType = (SHORT)iParam;
		break;

	case tokenBitmapBitsPerPixel:				// \wbmbitspixel N
		PARSERCOVERAGE_CASE();
		_prtfObject->cBitsPerPixel = (SHORT)iParam;
		break;

	case tokenBitmapNumPlanes:					// \wbmplanes N
		PARSERCOVERAGE_CASE();
		_prtfObject->cColorPlanes = (SHORT)iParam;
		break;

	case tokenBitmapWidthBytes:					// \wbmwidthbytes N
		PARSERCOVERAGE_CASE();
		_prtfObject->cBytesPerLine = (SHORT)iParam;
		break;

	case tokenDesiredWidth:						// \picwgoal N
		PARSERCOVERAGE_CASE();
		_prtfObject->xExtGoal = (SHORT)iParam;
		break;

	case tokenDesiredHeight:					// \pichgoal N
		PARSERCOVERAGE_CASE();
		_prtfObject->yExtGoal = (SHORT)iParam;
		break;

	case tokenBinaryData:						// \bin N
		PARSERCOVERAGE_CASE();

		// Update OleGet function
		RTFReadOLEStream.lpstbl->Get = 
				(DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
					   RTFGetBinaryDataFromStream;
		_cbBinLeft = iParam;					// Set data length
		switch (pstate->sDest)
		{
			case destObjectData:
				_fFailedPrevObj = !ObjectReadFromEditStream();
				break;

			case destPicture:
				StaticObjectReadFromEditStream(iParam);
				break;

			default:
				AssertSz(FALSE, "Binary data hit but don't know where to put it");
		}
		// Restore OleGet function
		RTFReadOLEStream.lpstbl->Get = 
				(DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
					RTFGetFromStream;
		break;

	case tokenObjectDataValue:
		PARSERCOVERAGE_CASE();
		if(_prtfObject->sType != ROT_EBookImage) // Added by VikramM for E-Book
		{
			// Normal processing
			_fFailedPrevObj = !ObjectReadFromEditStream();
		}
		else
		{
			// Do the Ebook Image callback here and set the _prtfObject size here
			// Don't need to read the image data at this point, we just want to 
			// do a callback at a later point to have the E-Book shell render the image
			_fFailedPrevObj = !ObjectReadEBookImageInfoFromEditStream();
		}
		goto EndOfObjectStream;
	
	case tokenPictureDataValue:
		PARSERCOVERAGE_CASE();
		StaticObjectReadFromEditStream();
EndOfObjectStream:
		if(!SkipToEndOfGroup())
			HandleEndGroup();
		break;			

	case tokenObjectPlaceholder:
		PARSERCOVERAGE_CASE();
		if(_ped->GetEventMask() & ENM_OBJECTPOSITIONS) 
		{
			if(!_pcpObPos)
			{
				_pcpObPos = (LONG *)PvAlloc(sizeof(ULONG) * cobPosInitial, GMEM_ZEROINIT);
				if(!_pcpObPos)
				{
					_ecParseError = ecNoMemory;
					break;
				}
				_cobPosFree = cobPosInitial;
				_cobPos = 0;
			}
			if(_cobPosFree-- <= 0)
			{
				const int cobPosNew = _cobPos + cobPosChunk;
				LPVOID pv;

				pv = PvReAlloc(_pcpObPos, sizeof(ULONG) * cobPosNew);
				if(!pv)
				{
					_ecParseError = ecNoMemory;
					break;
				}
				_pcpObPos = (LONG *)pv;
				_cobPosFree = cobPosChunk - 1;
			}
			_pcpObPos[_cobPos++] = _prg->GetCp();
		}
		break;

	default:
		PARSERCOVERAGE_DEFAULT();
		if(pstate->sDest != destFieldInstruction &&	// Values outside token
		   (DWORD)(_token - tokenMin) >				//  range are treated
				(DWORD)(tokenMax - tokenMin))		//  as Unicode chars
		{
			// 1.0 mode doesn't use Unicode bullets nor smart quotes
			if (_ped->Get10Mode() && IN_RANGE(LQUOTE, _token, RDBLQUOTE))
			{
				if (_token == LQUOTE || _token == RQUOTE)
					_token = L'\'';
				else if (_token == LDBLQUOTE || _token == RDBLQUOTE)
					_token = L'\"';
			}

			if(!IsLowMergedCell())
				HandleChar(_token);
		}
		#if defined(DEBUG) && !defined(NOFULLDEBUG)
		else
		{
			if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0))
			{
				CHAR *pszKeyword = PszKeywordFromToken(_token);
				CHAR szBuf[256];

				sprintf(szBuf, "CRTFRead::HandleToken():  Token not processed - token = %d, %s%s%s",
							_token,
							"keyword = ", 
							pszKeyword ? "\\" : "<unknown>", 
							pszKeyword ? pszKeyword : "");

				AssertSz(0, szBuf);
			}
		}
		#endif
	}

	TRACEERRSZSC("HandleToken()", - _ecParseError);
	_f1stControlWord = f1stControlWord;		// Update 1st control word status
	return _ecParseError;
}

/*
 *	CRTFRead::IsLowMergedCell()
 *
 *	@mfunc
 *		Return TRUE iff _prg is currently in a low merged table cell. Note
 *		that RichEdit can't insert any text into a low merged cell, but
 *		Word's RTF sometimes attempts to, e.g., {\listtext...} ignored
 *		by Word can be (erroneously) emitted for insertion into these cells.
 *		Hence we discard such insertions.
 *
 *	@rdesc
 *		Return TRUE iff _prg is currently in a low merged table cell
 */
BOOL CRTFRead::IsLowMergedCell()
{
	if(!_bTableLevel)
		return FALSE;

	CELLPARMS *pCellParms = (CELLPARMS *)&_rgxCell[0];

	return IsLowCell(pCellParms[_iCell].uCell);
}

/*
 *	CRTFRead::Pard(pstate)
 *
 *	@mfunc
 *		Reset paragraph and pstate properties to default values
 */
void CRTFRead::Pard(
	STATE *pstate)
{
	if(IN_RANGE(destColorTable, pstate->sDest, destPicture))
	{
		 _ecParseError = ecAbort;
		 return;
	}
	BYTE bT = _PF._bOutlineLevel;			// Save outline level
	_PF.InitDefault(_bDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
											// Reset para formatting
	pstate->fBullet = FALSE;
	pstate->sIndentNumbering = 0;
	_cTab			= 0;					// No tabs defined
	_bTabLeader		= 0;
	_bTabType		= 0;
	_bBorder		= 0;
	_fStartRow = FALSE;
	_PF._bOutlineLevel = (BYTE)(bT | 1);
	_dwMaskPF		= PFM_ALLRTF;
	_dwMaskPF2		= PFM2_TABLEROWSHIFTED;
}

/*
 *	CRTFRead::DelimitRow(szRowDelimiter)
 *
 *	@mfunc
 *		Insert start-of-row or end-of-row paragraph with current table
 *		properties
 */
void CRTFRead::DelimitRow(
	WCHAR *szRowDelimiter)	//@parm Delimit text to insert
{
	if(!_ped->_pdp->IsMultiLine())			// No tables in single line
	{										//  controls
		_ecParseError = ecTruncateAtCRLF;
		return;
	}

	_fCellxOK = FALSE;
	_fStartRow = FALSE;
	LONG nTableIndex = _bTableLevel;
	if(szRowDelimiter == szRowEnd)
	{
		if(!_iCell)							// Bad RTF: \row with no \cell,
			HandleCell();					// so fake one
		nTableIndex--;
	}
	if(nTableIndex + _bTableLevelIP >= MAXTABLENEST)
	{
		if(szRowDelimiter == szRowEnd)		// Maintain _bTableLevel
			_bTableLevel--;
		else
			_bTableLevel++;
		_token = tokenEndParagraph;
		HandleEndOfPara();
		return;
	}
	if(szRowDelimiter == szRowStart && _prg->GetCp() && !_prg->_rpTX.IsAfterEOP())
	{
		_token = tokenEndParagraph;
		HandleEndOfPara();
	}
	Assert(_pstateStackTop && _pstateStackTop->pPF);

	// Add _PF diffs to *_pstateStackTop->pPF
	if(!_pstateStackTop->AddPF(_PF, _bDocType, _dwMaskPF, _dwMaskPF2))
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		_ecParseError = ecNoMemory;
		return;
	}

	DWORD dwMaskPF	  = _pstateStackTop->dwMaskPF;	// Save PF for restoration
	DWORD dwMaskPF2   = _pstateStackTop->dwMaskPF2;	// Save PF for restoration
	SHORT iTabs		  = -1;
	CParaFormat PF	  = *_pstateStackTop->pPF;		//  on return

	_PF.InitDefault(_fRTLRow ? PFE_RTLPARA : 0);
	_dwMaskPF = PFM_ALLRTF;
	_dwMaskPF2 = 0; 
	if(_wBorderWidth)						// Store any border info
	{
		_PF._dwBorderColor = _dwBorderColors;
		_PF._wBorders	   = _wBorders;
		_PF._wBorderSpace  = _wBorderSpace;
		_PF._wBorderWidth  = _wBorderWidth;
		_dwMaskPF |= PFM_BORDER;
	}

	_PF._bAlignment	   = _bAlignment;		// Row alignment (no cell align)
	_PF._dxStartIndent = _xRowOffset;		// \trleft N
	_PF._dxOffset	   = max(_dxCell, 10);	// \trgaph N
	_PF._dyLineSpacing = _dyRow;			// \trrh N
	_PF._wEffects	   |= PFE_TABLE | PFE_TABLEROWDELIMITER;				

	BOOL fHidden = _ped->GetCharFormat(_prg->Get_iFormat())->_dwEffects & CFE_HIDDEN;
	_prg->_rpCF.AdjustBackward();
	if(_prg->IsHidden())
	{
		CCharFormat CF;
		CF._dwEffects = 0;					// Don't hide EOP preceding TRD				
		_prg->BackupCRLF(CSC_NORMAL, TRUE);
		_prg->SetCharFormat(&CF, 0, NULL, CFM_HIDDEN, 0);
		CheckNotifyLowFiRTF(TRUE);
		_prg->AdvanceCRLF(CSC_NORMAL, FALSE);
	}
	_prg->_rpCF.AdjustForward();

	AssertSz(!_prg->GetCp() || IsEOP(_prg->GetPrevChar()),
		"CRTFRead::DelimitRow: no EOP precedes TRD");

	if(AddText(szRowDelimiter, 2, FALSE) != ecNoError)
		goto cleanup;

	if(!_bTableLevel && _PF._dxStartIndent < 50)// Move neg shifted table right
	{										// (handles common default Word table)
		_PF._wEffects |= PFE_TABLEROWSHIFTED;
		_dwMaskPF2 |= PFM2_TABLEROWSHIFTED;
		_PF._dxStartIndent += _dxCell + 50;	// 50 gives room for left border
	}
	if(szRowDelimiter == szRowStart)
		_bTableLevel++;
											
	_PF._bTableLevel = _bTableLevel + _bTableLevelIP;
	iTabs = Apply_PF();
	if(szRowDelimiter == szRowStart)
	{
		if(_bTableLevel == 1)
			_iTabsLevel1 = iTabs;
		_rgTableState[nTableIndex]._iCell = _iCell;
		_rgTableState[nTableIndex]._cCell = _cCell;

		if(_token == tokenTableLevel)
			_cCell = 0;
		_iCell = 0;

		if(!_cCell)							// Cache if need to recompute row PF
			_dwRowResolveFlags |= 1 << _bTableLevel; 
	}
	else
	{
		Assert(szRowDelimiter == szRowEnd);
		DWORD dwMask = 1 << _bTableLevel;
		if(_dwRowResolveFlags & dwMask)
		{									// Copy iPF over to corresponding
			CPFRunPtr rpPF(*_prg);			//  row header
			rpPF.ResolveRowStartPF();
			_dwRowResolveFlags &= (dwMask - 1);
											// Insert NOTACHARs for cells
			LONG	   cp = _prg->GetCp();	//  vert merged with cells above
			LONG	   j = _cCell - 1;		
			CELLPARMS *pCellParms = (CELLPARMS *)&_rgxCell[0];
			WCHAR	   szNOTACHAR[1] = {NOTACHAR};

			_prg->Move(-2, FALSE); 			// Move before row-end delimiter
			for(LONG i = _cCell; i--;)		//  and CELL mark
			{
				if(IsLowCell(pCellParms[i].uCell))
				{
					if(i != j)
						_prg->Move(tomCell, i - j, NULL);
					if(_prg->GetPrevChar() == CELL)
						_prg->Move(-1, FALSE);	// Backspace over CELL mark
					Assert(_prg->_rpTX.GetChar() == CELL);

					if(_prg->_rpTX.GetPrevChar() == NOTACHAR)
						_prg->Move(-1, FALSE);
					else
					{
						_prg->ReplaceRange(1, szNOTACHAR, NULL, SELRR_IGNORE, NULL, 0);
						_prg->Move(-2, FALSE);	// Backspace over NOTACHAR CELL combo
						cp++;
					}
					j = i - 1;
				}
			}
			_prg->SetCp(cp, FALSE);			// Reposition rg after end-row delim
			Assert(_prg->_rpTX.IsAfterTRD(ENDFIELD));
		}
		_bTableLevel--;						// End of current row
		_iCell = _rgTableState[nTableIndex]._iCell;
		_cCell = _rgTableState[nTableIndex]._cCell;

		if(!_bTableLevel)
			_fStartRow = TRUE;				// Tell AddText to start new row
	}										//  unless \pard terminates it
	_cpThisPara = _prg->GetCp();			// New para starts after CRLF

cleanup:
	_PF = PF;
	_dwMaskPF  = dwMaskPF;
	_dwMaskPF2 = dwMaskPF2;

	if(fHidden)								// Restore hidden property
	{
		_CF._dwEffects |= CFE_HIDDEN;
		_dwMaskCF |= CFM_HIDDEN;
	}

	Assert(!(_PF._wEffects & PFE_TABLEROWDELIMITER));
}

/*
 *	CRTFRead::InitializeTableRowParms()
 *
 *	@mfunc
 *		Initialize table parms to no table state
 */
void CRTFRead::InitializeTableRowParms()
{
	// Initialize table parms
	_cCell				= 0;				// No table cells yet
	_iCell				= 0;
	_fCellxOK			= FALSE;
	_fStartRow			= FALSE;
	_wBorderWidth		= 0;
	_bAlignment			= PFA_LEFT;
	_xRowOffset			= 0;
	_dxCell				= 0;
	_dyRow				= 0;
	_iTabsTable			= -1;
}

/*
 *	CRTFRead::ReadRtf()
 *
 *	@mfunc
 *		The range _prg is replaced by RTF data resulting from parsing the
 *		input stream _pes.  The CRTFRead object assumes that the range is
 *		already degenerate (caller has to delete the range contents, if
 *		any, before calling this routine).  Currently any info not used
 *		or supported by RICHEDIT is	thrown away.
 *
 *	@rdesc
 *		Number of chars inserted into text.  0 means none were inserted
 *		OR an error occurred.
 */
LONG CRTFRead::ReadRtf()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadRtf");

	LONG		cpFirst;
	LONG		cpFirstInPara;
	CTxtRange *	prg = _prg;
	STATE *		pstate;

	cpFirst = _cpFirst = prg->GetCp();

	if (!_cchMax)
	{
		// At text limit already, forget it.
		_ecParseError = ecTextMax;
		goto Quit;			
	}

	if(!InitLex())
		goto Quit;

	TESTPARSERCOVERAGE();

	AssertSz(!prg->GetCch(),
		"CRTFRead::ReadRtf: range must be deleted");

	if(!(_dwFlags & SFF_SELECTION))
	{
		// SFF_SELECTION is set if any kind of paste is being done, i.e.,
		// not just that using the selection.  If it isn't set, data is
		// being streamed in and we allow this to reset the doc params
		if(_ped->InitDocInfo() != NOERROR)
		{
			_ecParseError = ecNoMemory;
			goto Quit;
		}
	}

	prg->SetIgnoreFormatUpdate(TRUE);

	_szUnicode = (WCHAR *)PvAlloc(cachTextMax * sizeof(WCHAR), GMEM_ZEROINIT);
	if(!_szUnicode)					// Allocate space for Unicode conversions
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		_ecParseError = ecNoMemory;
		goto CleanUp;
	}
	_cchUnicode = cachTextMax;

	// Initialize per-read variables
	_nCodePage = (_dwFlags & SF_USECODEPAGE)
			   ? (_dwFlags >> 16) : INVALID_CODEPAGE;

	// Populate _PF with initial paragraph formatting properties
	_PF = *prg->GetPF();
	_dwMaskPF  = PFM_ALLRTF;			// Setup initial MaskPF
	_PF._iTabs = -1;					// In case it's not -1
	if(_PF.IsTableRowDelimiter())		// Do _not_ insert with this property!
	{
		if(prg->_rpTX.IsAtTRD(ENDFIELD))
		{
			prg->AdvanceCRLF(CSC_NORMAL, FALSE);// Bypass table row-end delimiter
			cpFirst = prg->GetCp();		// Update value
			_PF = *prg->GetPF();		// Might still be row-start delimiter
			_PF._iTabs = -1;
			Assert(!prg->_rpTX.IsAtTRD(ENDFIELD));
		}
		if(prg->_rpTX.IsAtTRD(STARTFIELD))
		{
			// REVIEW: this if can probably be omitted now since the caller calls
			// DeleteWithTRDCheck()
			_ecParseError = ecGeneralFailure;
			goto CleanUp;
		}
	}
	_bTableLevelIP = _PF._bTableLevel;	// Save table level of insertion pt
	AssertSz(_bTableLevelIP >= 0, "CRTFRead::ReadRtf: illegal table level");

	// V-GUYB: PWord Converter requires loss notification.
	#ifdef REPORT_LOSSAGE
    if(!(_dwFlags & SFF_SELECTION))			// SFF_SELECTION is set if any 
    {										//  kind of paste is being done
        ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = FALSE;
    }
	#endif // REPORT_LOSSAGE

	// Valid RTF files start with "{\rtf", "{urtf", or "{\pwd"
	GetChar();								// Fill input buffer							
	UngetChar();							// Put char back
	if(!IsRTF((char *)_pchRTFCurrent, _pchRTFEnd - _pchRTFCurrent))	// Is it RTF?
	{										// No
		if (_ped->Get10Mode())
			_fNoRTFtoken = TRUE;
		else
		{
			_ecParseError = ecUnexpectedToken;	// Signal bad file
			goto CleanUp;
		}
	}

	// If initial cp follows EOP, use it for _cpThisPara.  Else
	// search for start of para containing the initial cp.
	_cpThisPara = prg->GetCp();
	if(!prg->_rpTX.IsAfterEOP())
	{
		CTxtPtr	tp(prg->_rpTX);
		tp.FindEOP(tomBackward);
		_cpThisPara	= tp.GetCp();
	}
	cpFirstInPara = _cpThisPara;			// Backup to start of para before
											//  parsing
	while ( TokenGetToken() != tokenEOF &&	// Process tokens
			_token != tokenError		&&
			!HandleToken()				&&
			_pstateStackTop )
		;

	if(_ecParseError == ecAbort)			// Really vile error: delete anything
	{										//  that was inserted
		prg->Set(prg->GetCp(), prg->GetCp() - cpFirst);
		prg->ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL,
						  RR_NO_LP_CHECK | RR_NO_TRD_CHECK | RR_NO_CHECK_TABLE_SEL);
		goto CleanUp;
	}
	if(_bTableLevel)						// Whoops! still in middle of table
	{
		LONG cpEnd = prg->GetCp();
		while(prg->GetCp() > _cpFirst)		// Move back into text that has
		{									//  table formatting
			prg->_rpPF.AdjustBackward();	// Get preceding level
			prg->Move(-prg->_rpPF.GetIch(), FALSE);// Move back to start of run
			if(prg->GetPF()->_bTableLevel > _bTableLevelIP)
				break;						// Found table formatting
		}
		LONG cpMin = prg->GetCp();
		if(cpMin > _cpFirst)				// Find beginning of row
			prg->FindRow(&cpMin, NULL, _bTableLevelIP + 1);
		cpMin = max(cpMin, _cpFirst);
		prg->Set(cpEnd, cpEnd - cpMin);		// Delete row
		prg->ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL,
					RR_NO_LP_CHECK | RR_NO_TRD_CHECK | RR_NO_CHECK_TABLE_SEL);
#ifdef DEBUG
		prg->_rpTX.MoveGapToEndOfBlock();
#endif
	}
	_cCell = _iCell = 0;

	prg->SetIgnoreFormatUpdate(FALSE);		// Enable range _iFormat updates
	prg->Update_iFormat(-1); 				// Update _iFormat to CF 
											//  at current active end
	if(!(_dwFlags & SFF_SELECTION))			// RTF applies to document:
	{										//  update CDocInfo
		// Apply char and para formatting of
		//  final text run to final CR
		if (prg->GetCp() == _ped->GetAdjustedTextLength() &&
			!(_dwMaskPF & (PFM_TABLEROWDELIMITER | PFM_TABLE)))
		{
			// REVIEW: we need to think about what para properties should
			// be transferred here. E.g., borders were being transferred
			// incorrectly
			_dwMaskPF &= ~(PFM_BORDER | PFM_SHADING);
			Apply_PF();
			prg->ExtendFormattingCRLF();
		}

		// Update the per-document information from the RTF read
		CDocInfo *pDocInfo = _ped->GetDocInfoNC();

		if(!pDocInfo)
		{
			Assert(FALSE);						// Should be allocated by
			_ecParseError = ecNoMemory;			//  earlier call in this function
			goto CleanUp;
		}

		if (ecNoError == _ecParseError)			// If range end EOP wasn't
			prg->DeleteTerminatingEOP(NULL);	// deleted and	new	text
												//  ends with an EOP, delete that EOP
		pDocInfo->_wCpg = (WORD)(_nCodePage == INVALID_CODEPAGE ? 
										tomInvalidCpg : _nCodePage);
		if (pDocInfo->_wCpg == CP_UTF8)
			pDocInfo->_wCpg = 1252;

		_ped->SetDefaultLCID(_sDefaultLanguage == INVALID_LANGUAGE ?
								tomInvalidLCID : 
								MAKELCID(_sDefaultLanguage, SORT_DEFAULT));

		_ped->SetDefaultLCIDFE(_sDefaultLanguageFE == INVALID_LANGUAGE ?
								tomInvalidLCID :
								MAKELCID(_sDefaultLanguageFE, SORT_DEFAULT));

		_ped->SetDefaultTabStop(TWIPS_TO_FPPTS(_sDefaultTabWidth));
		_ped->SetDocumentType(_bDocType);
	}

	if(_ped->IsComplexScript() && prg->GetCp() > cpFirstInPara)
	{
		Assert(!prg->GetCch());
		LONG	cpSave = prg->GetCp();
		LONG	cpLastInPara = cpSave;
		
		if(_ped->IsBiDi() && !prg->_rpTX.IsAtEOP())
		{
			CTxtPtr	tp(prg->_rpTX);
			tp.FindEOP(tomForward);
			cpLastInPara = tp.GetCp();
			prg->Move(cpLastInPara - cpSave, FALSE);
		}
		// Itemize from the start of paragraph to be inserted till the end of 
		// paragraph inserting. We need to cover all affected paragraphs because
		// paragraphs we're playing could possibly in conflict direction. Think 
		// about the case that the range covers one LTR para and one RTL para, then
		// the inserting text covers one RTL and one LTR. Both paragraphs' direction
		// could have been changed after this insertion.
		prg->ItemizeReplaceRange(cpLastInPara - cpFirstInPara, 0, NULL,
								 _ped->IsBiDi() && !_fNon0CharSet);
		if (cpLastInPara != cpSave)
			prg->SetCp(cpSave, FALSE);
	}

CleanUp:
	FreeRtfObject();

	pstate = _pstateStackTop;
	if(pstate)									// Illegal RTF file. Release
	{											//  unreleased format indices
		if(ecNoError == _ecParseError)			// It's only an overflow if no
			_ecParseError = ecStackOverflow;	//  other error has occurred

		if(_ecParseError != ecAbort)
			HandleFieldEndGroup();				// Cleanup possible partial field
		while(pstate->pstatePrev)
		{
			pstate = pstate->pstatePrev;
			ReleaseFormats(pstate->iCF, -1);
		}
	}

	pstate = _pstateLast;
	if(pstate)
	{
		while(pstate->pstatePrev)				// Free all but first STATE
		{
			pstate->DeletePF();
			pstate = pstate->pstatePrev;
			FreePv(pstate->pstateNext);
		}
		pstate->DeletePF();
	}
	Assert(_PF._iTabs == -1);
	FreePv(pstate);								// Free first STATE
	FreePv(_szUnicode);

Quit:
	DeinitLex();

	if(_pcpObPos)
	{
		if((_ped->GetEventMask() & ENM_OBJECTPOSITIONS) && _cobPos > 0)
		{
			OBJECTPOSITIONS obpos;

			obpos.cObjectCount = _cobPos;
			obpos.pcpPositions = _pcpObPos;

			if (_ped->Get10Mode())
			{
				LONG *pcpPositions = _pcpObPos;

				for (LONG i = 0; i < _cobPos; i++, pcpPositions++)
					*pcpPositions = _ped->GetAcpFromCp(*pcpPositions);
			}
			_ped->TxNotify(EN_OBJECTPOSITIONS, &obpos);
		}

		FreePv(_pcpObPos);
		_pcpObPos = NULL;
	}

// transcribed from winerror.h
#define ERROR_HANDLE_EOF     38L

	// FUTURE(BradO):  We should devise a direct mapping from our error codes
	//					to Win32 error codes.  In particular our clients are
	//					not expecting the error code produced by:
	//						_pes->dwError = (DWORD) -(LONG) _ecParseError;
	if(_ecParseError)
	{
		AssertSz(_ecParseError >= 0,
			"Parse error is negative");

		if(_ecParseError == ecTextMax)
		{
			_ped->GetCallMgr()->SetMaxText();
			_pes->dwError = (DWORD)STG_E_MEDIUMFULL;
		}
		if(_ecParseError == ecUnexpectedEOF)
			_pes->dwError = (DWORD)HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

		if(!_pes->dwError && _ecParseError != ecTruncateAtCRLF)
			_pes->dwError = (DWORD) -(LONG) _ecParseError;

#if defined(DEBUG)
		TRACEERRSZSC("CchParse_", _pes->dwError);
		if(ecNoError < _ecParseError && _ecParseError < ecLastError)
			Tracef(TRCSEVERR, "Parse error: %s", rgszParseError[_ecParseError]);
#endif
	}
	if(cpFirst > _cpFirst && prg->GetCp() == cpFirst)
	{
		prg->SetCp(_cpFirst, FALSE);	// Restore prg cp, since nothing inserted
		return 0;
	}
	return prg->GetCp() - cpFirst;
}


/*
 *	CRTFRead::CpgInfoFromFaceName()
 *
 *	@mfunc
 *		This routine fills in the TEXTFONT::bCharSet and TEXTFONT::nCodePage
 *		members of the TEXTFONT structure by querying the system for the
 *		metrics of the font described by TEXTFONT::szName.
 *
 *	@rdesc
 *		A flag indicating whether the charset and codepage were successfully
 *		determined.
 */
BOOL CRTFRead::CpgInfoFromFaceName(
	TEXTFONT *ptf)
{
	// FUTURE(BradO): This code is a condensed version of a more sophisticated
	// algorithm we use in font.cpp to second-guess the font-mapper.
	// We should factor out the code from font.cpp for use here as well.

	// Indicates that we've tried to obtain the cpg info from the system,
	// so that after a failure we don't re-call this routine.	
	ptf->fCpgFromSystem = TRUE;

	if(ptf->fNameIsDBCS)
	{
		// If fNameIsDBCS, we have high-ANSI characters in the facename, and
		// no codepage with which to interpret them.  The facename is gibberish,
		// so don't waste time calling the system to match it.
		return FALSE;
	}

	HDC hdc = _ped->TxGetDC();
	if(!hdc)
		return FALSE;

	LOGFONT	   lf = {0};
	TEXTMETRIC tm;

	wcscpy(lf.lfFaceName, ptf->szName);
	lf.lfCharSet = CharSetFromCharRep(CharRepFromCodePage(GetSystemDefaultCodePage()));

	if(!GetTextMetrics(hdc, lf, tm) || tm.tmCharSet != lf.lfCharSet)
	{
		lf.lfCharSet = DEFAULT_CHARSET;		// Doesn't match default sys
		GetTextMetrics(hdc, lf, tm);	//  charset, so see what
	}										//  DEFAULT_CHARSET gives
	_ped->TxReleaseDC(hdc);

	if(tm.tmCharSet != DEFAULT_CHARSET)		// Got something, so use it
	{
		ptf->iCharRep  = CharRepFromCharSet(tm.tmCharSet);
		ptf->sCodePage = (SHORT)CodePageFromCharRep(ptf->iCharRep);
		return TRUE;
	}

	return FALSE;
}

// Including a source file, but we only want to compile this code for debug purposes
#if defined(DEBUG)
#include "rtflog.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtfread2.cpp ===
/*
 *	rtfread2.cpp
 *
 *	Description:
 *		This file contains the object functions for RichEdit RTF reader
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	* NOTE:
 *	*	All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *	*	noted as a szW.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#include "_rtfread.h"
#include "_coleobj.h"
//#include "_nlsprcs.h"
#include "_disp.h"
#include "_dxfrobj.h"

const char szFontsel[]="\\f";

ASSERTDATA


/*
 *	CRTFRead::HandleFieldInstruction()
 *
 *	@mfunc
 *		Handle field instruction
 *
 *	@rdesc
 *		EC		The error code
 */
extern WCHAR pchStartField[];
EC CRTFRead::HandleFieldInstruction()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");
	BYTE *pch, *pch1;

	for(pch1 = _szText; *pch1 == ' '; pch1++)	// Bypass any leading blanks
		;
	for(pch = pch1; *pch && *pch != ' '; pch++)
		;

	if(W32->ASCIICompareI(pch1, (BYTE *) "SYMBOL", 6))
	{
		//Remove the start field character added when we saw the \fldinst
		CTxtRange rg(*_prg);

		rg.Move(-2, TRUE);
		Assert(rg.CRchTxtPtr::GetChar() == STARTFIELD);
		rg.Delete(0, SELRR_IGNORE);

		BYTE szSymbol[2] = {0,0};
		HandleFieldSymbolInstruction(pch, szSymbol);	//  SYMBOL
		HandleText(szSymbol, CONTAINS_NONASCII);

		_fSymbolField = TRUE;
	}
	else
		HandleText(pch1, CONTAINS_NONASCII);

	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolInstruction(pch)
 *
 *	@mfunc
 *		Handle specific  symbol field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote 
 *		FUTURE: the two whiles below can be combined into one fairly easily;
 *		Look at the definitions of IsXDigit() and IsDigit() and introduce
 *		a variable flag as well as a variable base multiplier (= 10 or 16).
 *		There were comments saying that we should parse font and font size from
 *		fldrslt, but I don't know why. Field instruction seems to and should contain
 *		all relevant data.
 */
EC CRTFRead::HandleFieldSymbolInstruction(
	BYTE *pch,		//@parm Pointer to SYMBOL field instruction
	BYTE *szSymbol)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");

	BYTE	ch;
	BYTE	chSymbol = 0;
	const char *pchFontsel = szFontsel;

	while (*pch == ' ')						// Eat spaces
		++pch;
											// Collect symbol char's code 
	if (*pch == '0' &&						//  which may be in decimal
 		(*++pch | ' ') == 'x')				//  or hex
	{										// It's in hex
		ch = *++pch;
	   	while (ch && IsXDigit(ch))
	   	{
			chSymbol <<= 4;
			chSymbol += (ch <= '9') ? ch - '0' : (ch & 0x4f) - 'A' + 10;
			ch = *pch++;
	   	}
	}
	else									// Decimal
	{
	   ch = *pch;
	   while (ch && IsDigit(ch))
	   {
			chSymbol *= 10;
			chSymbol += ch - '0' ;
			ch = *++pch;
	   }
	}

	szSymbol[0] = chSymbol;

	// now check for the \\f "Facename" construct 
	// and deal with it

	while (*pch == ' ')						// Eat spaces
		++pch;

	while (*pch && *pch == *pchFontsel)		// Make sure *pch is a \f
	{										
		++pch;
		++pchFontsel;
	}
	if	(! (*pchFontsel) )
	{
		_ecParseError = HandleFieldSymbolFont(pch);	//  \\f "Facename"
	}

	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolFont(pch)
 *
 *	@mfunc
 *		Handle the \\f "Facename" instruction in the SYMBOL field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote WARNING: may change _szText
 */
EC CRTFRead::HandleFieldSymbolFont(
	BYTE *pch)		//@parm Ptr to symbol field
{
	SHORT iFont = _fonts.Count();
	TEXTFONT tf;
	TEXTFONT *ptf = &tf;

	_pstateStackTop->ptf = &tf;
	// ReadFontName tries to append
	tf.szName[0] = '\0';

	// skip the initial blanks and quotes
	while (*pch && (*pch == ' ' || *pch == '\"'))
		++pch;

	// DONT WORRY, we'll get it back to normal
	// ReadFontName depends on _szText, so we need to alter it and then restore
	// it's just too bad we have to do it ...
	BYTE* szTextBAK = _szText;
	BOOL fAllAscii = TRUE;

	_szText = pch;

	// transform the trailing quote into ';'
	while (*pch)
	{
		if (*pch == '\"')
		{
			*pch = ';';
			break;
		}

		if(*pch > 0x7f)
			fAllAscii = FALSE;

		++pch;
	}

	// NOW we can read the font name!!
	ReadFontName(_pstateStackTop, fAllAscii ? ALL_ASCII : CONTAINS_NONASCII);

	// Try to find this face name in the font table
	BOOL fFontFound = FALSE;
	for (SHORT i = 0; i < iFont; ++i)
	{
		TEXTFONT *ptfTab = _fonts.Elem(i);
		if (0 == wcscmp(ptf->szName, ptfTab->szName))
		{
			fFontFound = TRUE;
			i = ptfTab->sHandle;
			break;
		}
	}

	// did we find the face name?
	if (!fFontFound)
	{
		Assert(i == iFont);
		i+= RESERVED_FONT_HANDLES;

		// Make room in font table for
		//  font to be inserted
		if (!(ptf =_fonts.Add(1,NULL)))
		{									
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			goto exit;
		}

		// repeating inits from tokenFontSelect
		ptf->sHandle	= i;				// Save handle
		wcscpy(ptf->szName, tf.szName); 
		ptf->bPitchAndFamily = 0;
		ptf->fNameIsDBCS = FALSE;
		ptf->sCodePage = (SHORT)_nCodePage;
		ptf->iCharRep = DEFAULT_INDEX;		// SYMBOL_INDEX ??
	}

	SelectCurrentFont(i);
	
exit:
	// needs to go back to normal
	_szText = szTextBAK;

	return _ecParseError;
}

/*
 *	CRTFRead::ReadData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read in object data. This must be called only after all initial
 *		object header info has been read.
 *
 *	@rdesc
 *		LONG	count of bytes read in
 */
LONG CRTFRead::ReadData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadData");

	BYTE bChar0, bChar1;
	LONG cbLeft = cbBuffer;

	while (cbLeft && (bChar0 = GetHexSkipCRLF()) < 16 && 
					 (bChar1 = GetHexSkipCRLF()) < 16 &&
					 _ecParseError == ecNoError)
	{	
		*pbBuffer++ = bChar0 << 4 | bChar1;
		cbLeft--;
	}							   
	return cbBuffer - cbLeft ; 
}

/*
 *	CRTFRead::ReadBinaryData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read cbBuffer bytes into pbBuffer
 *
 *	@rdesc
 *		Count of bytes read in
 */
LONG CRTFRead::ReadBinaryData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadBinaryData");

	LONG cbLeft = min(_cbBinLeft, cbBuffer);

	cbBuffer = cbLeft;

	for (; cbLeft > 0 && _ecParseError == ecNoError ; cbLeft--)
		*pbBuffer++ = GetChar();

	_cbBinLeft -= cbBuffer - cbLeft; 

	return cbBuffer - cbLeft ;
}

/*
 *	CRTFRead::SkipBinaryData(cbSkip)
 *
 *	@mfunc
 *		Skip cbSkip bytes in input streamd
 *
 *	@rdesc
 *		LONG	count of bytes skipped
 */
LONG CRTFRead::SkipBinaryData(
	LONG cbSkip)	//@parm Count of bytes to skip
{
	BYTE rgb[1024];

	_cbBinLeft = cbSkip;

	while(ReadBinaryData(rgb, sizeof(rgb)) > 0 && _ecParseError == ecNoError) 
		;
	return cbSkip;
}

/*
 *	CRTFRead::ReadRawText(pszRawText)
 *
 *	@mfunc
 *		Read in raw text until }.  A buffer is allocated to save the text.
 *		The caller is responsible to free the buffer later.
 *
 *	@rdesc
 *		LONG	count of bytes read
 */
LONG CRTFRead::ReadRawText(
	char	**pszRawText)	//@parm Address of the buffer containing the raw text
{
	LONG	cch=0;
	char	*szRawTextStart = NULL;
	char	*szRawText = NULL;
	char	chLast=0;
	char	ch;
	short	cRBrace=0;
	LONG	cchBuffer = 0;
	bool	fNeedBuffer = (pszRawText != NULL);

	if (fNeedBuffer)
	{
		*pszRawText = NULL;
		cchBuffer = 128;
		szRawText = szRawTextStart = (char *)PvAlloc(128, GMEM_ZEROINIT);

		if(!szRawTextStart)
		{
			_ecParseError = ecNoMemory;
			return 0;
		}
	}

	while (_ecParseError == ecNoError)
	{
		ch = GetChar();
		
		if (ch == 0)		
			break;			// error case

		if (ch == LF || ch == CR)
			continue;		// Ignore noise characters

		if (ch == '}' && chLast != '\\')
		{
			if (!cRBrace)
			{
				// Done
				UngetChar();

				if (fNeedBuffer)
					*szRawText = '\0';

				break;
			}
			cRBrace--;	// count the RBrace so we will ignore the matching pair of LBrace
		}

		if (ch == '{' && chLast != '\\')
			cRBrace++;

		chLast = ch;
		cch++;

		if (fNeedBuffer)
		{
			*szRawText = ch;
			
			if (cch == cchBuffer)
			{
				// Re-alloc a bigger buffer
				char *pNewBuff = (char *)PvReAlloc(szRawTextStart, cchBuffer + 64);
				
				if (!pNewBuff)
				{				
					_ecParseError = ecNoMemory;
					break;
				}
				
				cchBuffer += 64;
				szRawTextStart = pNewBuff;
				szRawText = szRawTextStart + cch;
			}
			else
				szRawText++;
		}
	}
	
	if (fNeedBuffer)
	{
		if (_ecParseError == ecNoError)
			*pszRawText = szRawTextStart;
		else
			FreePv(szRawTextStart);
	}
	return cch;
}

/*
 *	CRTFRead::StrAlloc(ppsz, sz)
 *
 *	@mfunc
 *		Set up a pointer to a newly allocated space to hold a string
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::StrAlloc(
	WCHAR ** ppsz,	//@parm Ptr to ptr to string that needs allocation
	BYTE *	 sz)	//@parm String to be copied into allocated space
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::StrAlloc");

	int Length =  strlen((CHAR *)sz)+1 ;

	*ppsz = (WCHAR *) PvAlloc((Length + 1)*sizeof(WCHAR), GMEM_ZEROINIT);
	if (!*ppsz)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		_ecParseError = ecNoMemory;
		goto Quit;
	}
	MultiByteToWideChar(CP_ACP,0,(char *)sz,-1,*ppsz,Length) ;

Quit:
	return _ecParseError;
}

/*
 *	CRTFRead::FreeRtfObject()
 *
 *	@mfunc
 *		Cleans up memory used by prtfobject
 */
void CRTFRead::FreeRtfObject()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FreeRtfObject");

	if (_prtfObject)
	{
		FreePv(_prtfObject->szClass);
		FreePv(_prtfObject->szName);
		FreePv(_prtfObject);
		_prtfObject = NULL;
	}
}

/*
 *	CRTFRead::ObjectReadSiteFlags(preobj)
 *
 *	@mfunc
 *		Read dwFlags and dwUser bytes from a container specific stream
 *
 *	@rdesc
 *		BOOL	TRUE if successfully read the bytes
 */
BOOL CRTFRead::ObjectReadSiteFlags(
	REOBJECT * preobj)	//@parm REOBJ from where to copy flags. This preobj is
						//		then later put out in a site
{
	return (::ObjectReadSiteFlags(preobj) == NOERROR);
}

/*
 *	ObjectReadEBookImageInfoFromEditStream()
 *
 *	@mfunc
 *		Reads in information about the EBook Image
 *		At this point we don't read in the actual data
 *		We just get info about the dimensions of the data
 *
 *	Added
 *		VikramM - esp. for e-books
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFRead::ObjectReadEBookImageInfoFromEditStream()
{
	HRESULT hr = E_FAIL;
	BOOL fRet = FALSE;
	REOBJECT reobj = { 0 };
	COleObject * pObj = NULL;
	LPARAM EBookID = 0;
	SIZE size;
	DWORD dwFlags;

	CObjectMgr *ObjectMgr = _ped->GetObjectMgr();
	if (! ObjectMgr)
	   goto Cleanup;

	if(!_prtfObject->szName)
		goto Cleanup;

	// eBooks implies advanced layout, ensure the bit is on
	_ped->OnSetTypographyOptions(TO_ADVANCEDLAYOUT, TO_ADVANCEDLAYOUT);

	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = _prg->GetCp();

	// Read the object size from here. The size is in Device Units
    if(!_ped->fInHost2() || (_ped->GetHost())->TxEBookLoadImage(_prtfObject->szName, &EBookID, &size,&dwFlags) != S_OK )
		goto Cleanup;

    // For objects, xExt and yExt need to be in Twips .. 
	_prtfObject->xExt = size.cx; 
	_prtfObject->yExt = size.cy;
	{
		CRchTxtPtr rtp(_ped, 0);
		CDisplay * pdp = _ped->_pdp;
		reobj.sizel.cx = pdp->DUtoHimetricU(_prtfObject->xExt) * _prtfObject->xScale / 100;
		reobj.sizel.cy = pdp->DVtoHimetricV(_prtfObject->yExt) * _prtfObject->yScale / 100;
	}
	// what does this do ??
	reobj.dvaspect = DVASPECT_CONTENT;		// OLE 1 forces DVASPECT_CONTENT
	reobj.dwFlags &= ~REO_BLANK;
	reobj.dwFlags |= dwFlags; //Ebook Float Flags
	pObj = new COleObject(_ped);
	if(!pObj)
		goto Cleanup;

	pObj->SetEBookImageID(EBookID);
	pObj->IsEbookImage(TRUE);
	pObj->SetEBookImageSizeDP(size);
	reobj.polesite = pObj;

#ifndef NOINKOBJECT
    if(IsEqualCLSID(reobj.clsid, CLSID_Ink))
		Apply_CF();
	else
#endif
	_prg->Set_iCF(-1);	
	if(hr = ObjectMgr->InsertObject(_prg, &reobj, NULL))
		goto Cleanup;

	fRet = TRUE;

Cleanup:
	// InsertObject AddRefs the object, so we need to release it
	SafeReleaseAndNULL((IUnknown**)&pObj);
	return fRet;
}

/*
 *	CRTFRead::ObjectReadFromStream()
 *
 *	@mfunc
 *		Reads an OLE object from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFRead::ObjectReadFromEditStream()
{
	BOOL			fRet = FALSE;
	HRESULT			hr;
	CObjectMgr *	pObjectMgr = _ped->GetObjectMgr();
	LPOLECACHE		polecache = NULL;
	LPRICHEDITOLECALLBACK  precall=NULL;
	LPENUMSTATDATA	penumstatdata = NULL;
	REOBJECT		reobj = { 0 };
	STATDATA		statdata;

	if(!pObjectMgr)
	   goto Cleanup;
	
	precall = pObjectMgr->GetRECallback();

	// If no IRichEditOleCallback exists, then fail
	if (!precall)
		goto Cleanup;

//	AssertSz(_prtfObject->szClass,"ObFReadFromEditstream: reading unknown class");

	if (_prtfObject->szClass)
		CLSIDFromProgID(_prtfObject->szClass, &reobj.clsid);

	// Get storage for the object from the application
	if (precall->GetNewStorage(&reobj.pstg))
		goto Cleanup;

	hr = OleConvertOLESTREAMToIStorage((LPOLESTREAM) &RTFReadOLEStream, reobj.pstg, NULL);
	if (FAILED(hr))					   
		goto Cleanup;		  

	// Create another object site for the new object
	_ped->GetClientSite(&reobj.polesite) ;
	if(!reobj.polesite)
		goto Cleanup;

	if(OleLoad(reobj.pstg, IID_IOleObject, reobj.polesite, (LPVOID *)&reobj.poleobj))
	{
		if(!reobj.polesite->Release())		// OleLoad() may AddRef reobj.polesite
			reobj.polesite = NULL;
		goto Cleanup;
	}

	CLSID	clsid;

	// Get the actual clsid from the object
	if (reobj.poleobj->GetUserClassID(&clsid) == NOERROR)
		reobj.clsid = clsid;
	
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = _prg->GetCp();
	reobj.sizel.cx = HimetricFromTwips(_prtfObject->xExt)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = HimetricFromTwips(_prtfObject->yExt)
						* _prtfObject->yScale / 100;

	// Read any container flags which may have been previously saved
	if (!ObjectReadSiteFlags(&reobj))
		reobj.dwFlags = REO_RESIZABLE;		// If no flags, make best guess	

	reobj.dvaspect = DVASPECT_CONTENT;		// OLE 1 forces DVASPECT_CONTENT

	// Ask the cache if it knows what to display
	if (!reobj.poleobj->QueryInterface(IID_IOleCache, (void**)&polecache) &&
		!polecache->EnumCache(&penumstatdata))
	{
		// Go look for the best cached presentation CF_METAFILEPICT
		while (penumstatdata->Next(1, &statdata, NULL) == S_OK)
		{
			if (statdata.formatetc.cfFormat == CF_METAFILEPICT)
			{
				LPDATAOBJECT pdataobj = NULL;
				STGMEDIUM med;
				BOOL fUpdate;

				ZeroMemory(&med, sizeof(STGMEDIUM));
                if (!polecache->QueryInterface(IID_IDataObject, (void**)&pdataobj) &&
					!pdataobj->GetData(&statdata.formatetc, &med))
                {
					HANDLE	hGlobal = med.hGlobal;

					if( FIsIconMetafilePict(hGlobal) )
				    {
					    OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect,
							DVASPECT_ICON, med.hGlobal, TRUE, FALSE, NULL, &fUpdate);
				    }
				}
				ReleaseStgMedium(&med);
				if (pdataobj)
					pdataobj->Release();
				break;
			}
		}
		polecache->Release();
		penumstatdata->Release();
	}

	// EVIL HACK ALERT.  This code is borrowed from RichEdit 1.0; Word generates
	// bogus objects, so we need to compensate.

	if( reobj.dvaspect == DVASPECT_CONTENT )
	{
		IStream *pstm = NULL;
		BYTE bT;
		BOOL fUpdate;

		if (!reobj.pstg->OpenStream(OLESTR("\3ObjInfo"), 0, STGM_READ |
									   STGM_SHARE_EXCLUSIVE, 0, &pstm) &&
		   !pstm->Read(&bT, sizeof(BYTE), NULL) &&
		   (bT & 0x40))
		{
		   _fNeedIcon = TRUE;
		   _fNeedPres = TRUE;
		   _pobj = (COleObject *)reobj.polesite;
		   OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect, DVASPECT_ICON,
									   NULL, TRUE, FALSE, NULL, &fUpdate);
		}
		if( pstm )
			pstm->Release();
   }

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

#ifndef NOINKOBJECT
    if(IsEqualCLSID(reobj.clsid, CLSID_Ink))
		Apply_CF();
	else
#endif
	_prg->Set_iCF(-1);	
	hr = pObjectMgr->InsertObject(_prg, &reobj, NULL);
	if(hr)
		goto Cleanup;

	// EVIL HACK ALERT!!  Word doesn't give us objects with presenation
	// caches; as a result, we can't draw them!  In order to get around this,
	// we check to see if there is a presentation cache (via the same way
	// RE 1.0 did) using a GetExtent call.  If that fails, we'll just use
	// the presentation stored in the RTF.  
	//
	// COMPATIBILITY ISSUE: RE 1.0, instead of using the presentation stored
	// in RTF, would instead call IOleObject::Update.  There are two _big_
	// drawbacks to this approach: 1. it's incredibly expensive (potentially,
	// MANY SECONDS per object), and 2. it doesn't work if the object server
	// is not installed on the machine.

	SIZE sizeltemp;

	if( reobj.poleobj->GetExtent(reobj.dvaspect, &sizeltemp) != NOERROR )
	{
		_fNeedPres = TRUE;
		_pobj = (COleObject *)reobj.polesite;
	}

	fRet = TRUE;

Cleanup:
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite) reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();

	return fRet;
}

/*
 *	ObHBuildMetafilePict(prtfobject, hBits)
 *
 *	@func
 *		Build a METAFILEPICT from RTFOBJECT and the raw data.
 *
 *	@rdesc
 *		HGLOBAL		Handle to a METAFILEPICT
 */
HGLOBAL ObHBuildMetafilePict(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
#ifndef NOMETAFILES
	ULONG	cbBits;
	HGLOBAL	hmfp = NULL;
	LPBYTE	pbBits;
	LPMETAFILEPICT pmfp = NULL;
	SCODE	sc = E_OUTOFMEMORY;

	// Allocate the METAFILEPICT structure
    hmfp = GlobalAlloc(GHND, sizeof(METAFILEPICT));
	if (!hmfp)
		goto Cleanup;

	// Lock it down
	pmfp = (LPMETAFILEPICT) GlobalLock(hmfp);
	if (!pmfp)
		goto Cleanup;

	// Put in the header information
	pmfp->mm = prtfobject->sPictureType;
	pmfp->xExt = prtfobject->xExt;
	pmfp->yExt = prtfobject->yExt;

	// Set the metafile bits
	pbBits = (LPBYTE) GlobalLock(hBits);
	cbBits = GlobalSize(hBits);
	pmfp->hMF = SetMetaFileBitsEx(cbBits, pbBits);
	
	// We can throw away the data now since we don't need it anymore
	GlobalUnlock(hBits);
	GlobalFree(hBits);

	if (!pmfp->hMF)
		goto Cleanup;
	GlobalUnlock(hmfp);
	sc = S_OK;

Cleanup:
	if (sc && hmfp)
	{
		if (pmfp)
		{
		    if (pmfp->hMF)
		        ::DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);
		hmfp = NULL;
	}
	TRACEERRSZSC("ObHBuildMetafilePict", sc);
	return hmfp;
#else
	return NULL;
#endif
}

/*
 *	ObHBuildBitmap(prtfobject, hBits)
 *
 *	@func
 *		Build a BITMAP from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a BITMAP
 */
HGLOBAL ObHBuildBitmap(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	HBITMAP hbm = NULL;
	LPVOID	pvBits = GlobalLock(hBits);

	if(pvBits)
	{
		hbm = CreateBitmap(prtfobject->xExt, prtfobject->yExt,
						prtfobject->cColorPlanes, prtfobject->cBitsPerPixel,
						pvBits);
	}
	GlobalUnlock(hBits);
	GlobalFree(hBits);
	return hbm;
}

/*
 *	ObHBuildDib(prtfobject, hBits)
 *
 *	@func
 *		Build a DIB from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a DIB
 */
HGLOBAL ObHBuildDib(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	// Apparently DIB's are just a binary dump
	return hBits;
}

/*
 *	CRTFRead::StaticObjectReadFromEditstream(cb)
 *
 *	@mfunc
 *		Reads a picture from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
#define cbBufferMax	16384
#define cbBufferStep 1024
#define cbBufferMin 1024

BOOL CRTFRead::StaticObjectReadFromEditStream(
	int cb)		//@parm Count of bytes to read
{
	LONG		cbBuffer;
	LONG		cbRead;
	DWORD		dwAdvf;
	DWORD		dwConn;
	BOOL		fBackground = _pstateStackTop && _pstateStackTop->fBackground;
	FORMATETC	formatetc;
	BOOL		fRet = FALSE;
	HGLOBAL		hBits = NULL;
	HRESULT		hr = E_FAIL;
	LPBYTE		pbBuffer = NULL;
	CDocInfo *	pDocInfo = _ped->GetDocInfoNC();
	CObjectMgr *pObjectMgr = _ped->GetObjectMgr();
	LPOLECACHE	polecache = NULL;
	LPPERSISTSTORAGE pperstg = NULL;
	LPRICHEDITOLECALLBACK  precall;
	LPSTREAM	pstm = NULL;
	REOBJECT	reobj = { 0 };
	STGMEDIUM	stgmedium;
	HGLOBAL (*pfnBuildPict)(RTFOBJECT *, HGLOBAL) = NULL;

	if(!pObjectMgr)
	   goto Cleanup;
	
	// precall may end up being null (e.g. Windows CE).
	precall = pObjectMgr->GetRECallback();

	// Initialize various data structures
	formatetc.ptd = NULL;
	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.lindex = -1;
	formatetc.tymed = TYMED_NULL;
	switch (_prtfObject->sType)
	{
	case ROT_Metafile:
		reobj.clsid = CLSID_StaticMetafile;
		formatetc.cfFormat = CF_METAFILEPICT;
		formatetc.tymed = TYMED_MFPICT;
		pfnBuildPict = ObHBuildMetafilePict;
		break;

	case ROT_Bitmap:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_BITMAP;
		formatetc.tymed = TYMED_GDI;
		pfnBuildPict = ObHBuildBitmap;
		break;

	case ROT_DIB:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_DIB;
		formatetc.tymed = TYMED_HGLOBAL;
		pfnBuildPict = ObHBuildDib;
		break;

	case ROT_PNG:
	case ROT_JPEG:
		// We convert these types of pictures to a bitmap
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_BITMAP;
		formatetc.tymed = TYMED_GDI;
		break;
	}

	reobj.sizel.cx = (LONG) HimetricFromTwips(_prtfObject->xExtGoal)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = (LONG) HimetricFromTwips(_prtfObject->yExtGoal)
						* _prtfObject->yScale / 100;
	stgmedium.tymed = formatetc.tymed;
	stgmedium.pUnkForRelease = NULL;

	if (precall)
	{
		if( !_fNeedPres )
		{
			// Get storage for the object from the application
			if (precall->GetNewStorage(&reobj.pstg))
				goto Cleanup;
		}
		// Let's create a stream on HGLOBAL
		if (hr = CreateStreamOnHGlobal(NULL, FALSE, &pstm))
			goto Cleanup;

		// Allocate a buffer, preferably a big one
		for (cbBuffer = cbBufferMax;
			 cbBuffer >= cbBufferMin;
			cbBuffer -= cbBufferStep)
		{
			pbBuffer = (unsigned char *)PvAlloc(cbBuffer, 0);
			if (pbBuffer)
				break;
		}
	}
	else
	{
		cbBuffer = cb;
		if(!cb)
		{
			// This means we didn't understand the picture type; so just
			// skip it without failing.
			fRet = TRUE;
			goto Cleanup;
		}															  
		hBits = GlobalAlloc(GMEM_FIXED, cb);
		pbBuffer = (BYTE *) GlobalLock(hBits);
	}
		
	if (!pbBuffer)
		goto Cleanup;
	
	// Copy the data from RTF into our HGLOBAL
	while ((cbRead = RTFReadOLEStream.lpstbl->Get(&RTFReadOLEStream,pbBuffer,cbBuffer)) > 0)
	{
		if(pstm)
		{
			hr = pstm->Write(pbBuffer, cbRead, NULL);
			if(hr != NOERROR)
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: Write", GetScode(hr));
				goto Cleanup;
			}
		}
	}

	if (hBits)
	{
		Assert(!precall);
		GlobalUnlock(hBits);
		pbBuffer = NULL;					// To avoid free below
	}

	if (pstm && (hr = GetHGlobalFromStream(pstm, &hBits)))
	{
		TRACEERRSZSC("ObFReadStaticFromEditstream: no hglobal from stm", GetScode(hr));
		goto Cleanup;
	}

	if(pDocInfo && fBackground)
	{
		pDocInfo->_bPicFormat = (BYTE)_prtfObject->sType;
		pDocInfo->_bPicFormatParm = (BYTE)_prtfObject->sPictureType;
		pDocInfo->_xExt		= _prtfObject->xExt;
		pDocInfo->_yExt		= _prtfObject->yExt;
		pDocInfo->_xScale	= _prtfObject->xScale;
		pDocInfo->_yScale	= _prtfObject->yScale;
		pDocInfo->_xExtGoal = _prtfObject->xExtGoal;
		pDocInfo->_yExtGoal = _prtfObject->yExtGoal;
		pDocInfo->_xExtPict	= _prtfObject->xExtPict;
		pDocInfo->_yExtPict	= _prtfObject->yExtPict;
		pDocInfo->_rcCrop	= _prtfObject->rectCrop;
		pDocInfo->_hdata	= hBits;
	}

	// Build the picture
	if(_prtfObject->sType == ROT_JPEG || _prtfObject->sType == ROT_PNG)
	{
		HBITMAP hbmp = W32->GetPictureBitmap(pstm);
		if (!hbmp)
		{
			hr = E_FAIL;
			goto Cleanup;
		}
		stgmedium.hGlobal = hbmp;
	}
	else if( pfnBuildPict )
		stgmedium.hGlobal = pfnBuildPict(_prtfObject, hBits);
	else
	{
		// This means we didn't understand the picture type; so just
		// skip it without failing.
		fRet = TRUE;
		goto Cleanup;
	}

	if( precall )
	{
		if(!stgmedium.hGlobal)
			goto Cleanup;

		if( !_fNeedPres )
		{
			// Create the default handler
			hr = OleCreateDefaultHandler(reobj.clsid, NULL, IID_IOleObject, (void **)&reobj.poleobj);
			if (hr)
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: no def handler", GetScode(hr));
				goto Cleanup;
			}

			// Get the IPersistStorage and initialize it
			if ((hr = reobj.poleobj->QueryInterface(IID_IPersistStorage,(void **)&pperstg)) ||
				(hr = pperstg->InitNew(reobj.pstg)))
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: InitNew", GetScode(hr));
				goto Cleanup;
			}
			dwAdvf = ADVF_PRIMEFIRST;
		}
		else
		{
			Assert(_pobj);
			_pobj->GetIUnknown()->QueryInterface(IID_IOleObject, (void **)&(reobj.poleobj));
			dwAdvf = ADVF_NODATA;
			formatetc.dwAspect = _fNeedIcon ? DVASPECT_ICON : DVASPECT_CONTENT;
		}

		// Get the IOleCache and put the picture data there
		if (hr = reobj.poleobj->QueryInterface(IID_IOleCache,(void **)&polecache))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: QI: IOleCache", GetScode(hr));
			goto Cleanup;
		}

		if (FAILED(hr = polecache->Cache(&formatetc, dwAdvf, &dwConn)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: Cache", GetScode(hr));
			goto Cleanup;
		}

		if (hr = polecache->SetData(&formatetc, &stgmedium,	TRUE))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetData", GetScode(hr));
			goto Cleanup;
		}
	}

	if( !_fNeedPres )
	{
		// Create another object site for the new object
		_ped->GetClientSite(&reobj.polesite);
		if (!reobj.polesite )
			goto Cleanup;

		// Set the client site
		if (reobj.poleobj && (hr = reobj.poleobj->SetClientSite(reobj.polesite)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetClientSite", GetScode(hr));
			goto Cleanup;
		}
		else if (!reobj.poleobj)
		{
			if(_prtfObject->sType == ROT_DIB)
			{
				// Windows CE static object Save the data and mark it.
				COleObject *pobj = (COleObject *)reobj.polesite;
				COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
				pobj->SetHdata(hBits);
				pimageinfo->xScale = _prtfObject->xScale;
				pimageinfo->yScale = _prtfObject->yScale;
				pimageinfo->xExtGoal = _prtfObject->xExtGoal;
				pimageinfo->yExtGoal = _prtfObject->yExtGoal;
				pimageinfo->cBytesPerLine = _prtfObject->cBytesPerLine;
				pobj->SetImageInfo(pimageinfo);
			}
			else
				goto Cleanup;		// There has been a mistake
		}

		// Put object into the edit control
		reobj.cbStruct = sizeof(REOBJECT);
		reobj.cp = _prg->GetCp();
		reobj.dvaspect = DVASPECT_CONTENT;
		reobj.dwFlags = fBackground ? REO_RESIZABLE | REO_USEASBACKGROUND
									: REO_RESIZABLE;
		// Since we are loading an object, it shouldn't be blank
		reobj.dwFlags &= ~REO_BLANK;
		if(_pstateStackTop->fShape && _ped->fUseObjectWrapping())
			reobj.dwFlags |= _dwFlagsShape;

#ifndef NOINKOBJECT
    if(IsEqualCLSID(reobj.clsid, CLSID_Ink))
		Apply_CF();
	else
#endif
		_prg->Set_iCF(-1);	
		hr = pObjectMgr->InsertObject(_prg, &reobj, NULL);
		if(hr)
			goto Cleanup;
	}
	else
	{
		// The new presentation may have a different idea about how big the
		// object is supposed to be.  Make sure the object stays the correct
		// size.
		_pobj->ResetSize((SIZEUV&)reobj.sizel);
	}
	fRet = TRUE;

Cleanup:
	// Do not display backgrounds.
	if(pDocInfo && fBackground)
			pDocInfo->_nFillType=-1;

	if (polecache)		polecache->Release()	;
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite)	reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();
	if (pperstg)		pperstg->Release();
	if (pstm)			pstm->Release();
	FreePv(pbBuffer);

	_fNeedIcon = FALSE;
	_fNeedPres = FALSE;
	_pobj = NULL;

	return fRet;
}

/*
 *	CRTFRead::HandleSTextFlow(mode)
 *
 *	@mfunc
 *		Handle STextFlow setting.
 */
void CRTFRead::HandleSTextFlow(
	int mode)		//@parm TextFlow mode
{
	static BYTE bTFlow[9] =	// Rotate		@Font 
	{	0,					//	0			0   
		tflowSW | 0x80,		// 270			1
		tflowNE,			//	90			0
		tflowSW,			// 270			0
		0x80,				//	0			1
		0,					//	?
		tflowNE | 0x80,		//	90			1
		tflowWN | 0x80,		// 180			1
		tflowWN				// 180			0
	};

	if (IN_RANGE(0, mode, 8))
	{
		_ped->_fUseAtFont = bTFlow[mode] >> 7;
		_ped->_pdp->SetTflow(bTFlow[mode] & 0x03);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtflex.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTFLEX.CPP - RichEdit RTF reader lexical analyzer |
 *
 *		This file contains the implementation of the lexical analyzer part of
 *		the RTF reader.
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPWSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "hash.h"
#include "tokens.cpp"

ASSERTDATA

// Array used by character classification macros to speed classification
// of chars residing in two or more discontiguous ranges, e.g., alphanumeric
// or hex.  The alphabetics used in RTF control words are lower-case ASCII.
// *** DO NOT DBCS rgbCharClass[] ***

#define	fCS		fCT + fSP
#define fSB		fBL + fSP
#define fHD		fHX + fDG
#define	fHU		fHX + fUC
#define	fHL		fHX + fLC

const BYTE rgbCharClass[256] =
{
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCS,fCS,fCS,fCS,fCS,fCT,fCT,
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT,
	fSB,fPN,fPN,fPN,fPN,fPN,fPN,fPN, fPN,fPN,fPN,fPN,fPN,fPN,fPN,fPN,
	fHD,fHD,fHD,fHD,fHD,fHD,fHD,fHD, fHD,fHD,fPN,fPN,fPN,fPN,fPN,fPN,

	fPN,fHU,fHU,fHU,fHU,fHU,fHU,fUC, fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC,
	fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC, fUC,fUC,fUC,fPN,fPN,fPN,fPN,fPN,
	fPN,fHL,fHL,fHL,fHL,fHL,fHL,fLC, fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC,
	fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC, fLC,fLC,fLC,fPN,fPN,fPN,fPN,fPN,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
};

// Specifies the number of bytes we can safely "UngetChar"
// before possibly underflowing the buffer.
const int cbBackupMax = 4;

// Bug2298 - I found an RTF writer which emits uppercase RTF keywords,
// 			so I had to change IsLCAscii to IsAlphaChar for use in scanning
//			for RTF keywords.
inline BOOL IsAlphaChar(BYTE b)
{
	return IN_RANGE('a', b | 0x20, 'z');
}

/*
 *	IsRTF(pstr, cb)
 *
 *	@func
 *		Return FALSE if cb < 7 or pstr is NULL or if pstr doesn't start
 *		with "{\rtf"N or "{\urtf"N, where N is an	ASCII number. cb gives
 *		the minimum length of pstr unless pstr is NULL-terminated, in which
 *		case the null terminator marks the end of the string.
 *
 *	@rdesc
 *		TRUE if pstr points at a valid start of RTF data
 */
BOOL IsRTF(
	char *pstr,		//@parm String to check
	LONG  cb)		//@parm Min byte count if string isn't null terminated
{
	if(!pstr || cb < 7 || *pstr++ != '{' || *pstr++ != '\\')
		return FALSE;					// Quick out for most common cases

	if(*pstr == 'u')					// Bypass u of possible urtf
		pstr++;

	return !CompareMemory("rtf", pstr, 3) && !IsAlphaChar((BYTE)pstr[3]);
}

/*
 *	CRTFRead::InitLex()
 *
 *	@mfunc
 *		Initialize the lexical analyzer. Reset the variables. if reading in
 *		from resource file, sort the keyword list (). Uses global hinstRE
 *		from the RichEdit to find out where its resources are.  Note: in
 *		RichEdit 2.0, currently the resource option is not supported.
 *
 *	@rdesc
 *		TRUE				If lexical analyzer was initialized
 */
BOOL CRTFRead::InitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::InitLex");

	AssertSz(cKeywords == i_TokenIndexMax,
		"Keyword index enumeration is incompatible with rgKeyword[]");
	Assert(!_szText && !_pchRTFBuffer);

	// Allocate our buffers with an extra byte for szText so that hex
	// conversion doesn't have to worry about running off the end if the
	// first char is NULL
	if ((_szText	   = (BYTE *)PvAlloc(cachTextMax + 1, GMEM_ZEROINIT)) &&
		(_pchRTFBuffer = (BYTE *)PvAlloc(cachBufferMost, GMEM_ZEROINIT)))
	{
		return TRUE;					// Signal that lexer is initialized
	}

	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecLexInitFailed;
	return FALSE;
}

/*
 *	CRTFRead::DeinitLex()
 *
 *	@mfunc
 *		Shut down lexical analyzer
 */
void CRTFRead::DeinitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::DeinitLex");

#ifdef KEYWORD_RESOURCE
	if (hglbKeywords)
	{
		FreeResource(hglbKeywords);
		hglbKeywords = NULL;
		rgKeyword = NULL;
	}
#endif

	FreePv(_szText);
	FreePv(_pchRTFBuffer);
}

/*
 *	CRTFRead::GetChar()
 *	
 *	@mfunc
 *		Get next char, filling buffer as needed
 *	
 *	@rdesc
 *		BYTE			nonzero char value if success; else 0
 */
BYTE CRTFRead::GetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetChar");

	if (_pchRTFCurrent == _pchRTFEnd && !FillBuffer())
	{
		_ecParseError = ecUnexpectedEOF;
		return 0;
	}
	return *_pchRTFCurrent++;
}

/*
 *	CRTFRead::GetCharEx()
 *	
 *	@mfunc
 *		Get next char including escaped chars of form \'xx
 *	
 *	@rdesc
 *		BYTE	nonzero char value if success; else 0
 */
BYTE CRTFRead::GetCharEx()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetCharEx");

	BYTE ach;
	
	do
		ach = GetChar();
	while (ach == CR || ach == LF);			// Ignore CRLFs

	if(ach == BSLASH)
	{
		if(GetChar() == '\'')
		{
			// Convert hex to char and store result in _token
			if(TokenGetHex() != tokenError)
				return (BYTE)_token;
			_ecParseError = ecUnexpectedChar;
		}
		UngetChar();
	}
	return ach;
}

/*
 *	CRTFRead::FillBuffer()
 *
 *	@mfunc
 *		Fill RTF buffer & return != 0 if successful
 *
 *	@rdesc
 *		LONG			# chars read
 *
 *	@comm
 *		This routine doesn't bother copying anything down if
 *		pchRTFCurrent <lt> pchRTFEnd so anything not read yet is lost.
 *		The only exception to this is that it always copies down the
 *		last two bytes read so that UngetChar() will work. ReadData()
 *		actually counts on this behavior, so if you change it, change
 *		ReadData() accordingly.
 */
LONG CRTFRead::FillBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FillBuffer");

	LONG cchRead;

	if (!_pchRTFCurrent)				
	{									
		// No data yet, nothing for backup
		// Leave cbBackupMax NULL chars so backup
		// area of buffer doesn't contain garbage.

		for(int i = 0; i < cbBackupMax; i++)
		{
			_pchRTFBuffer[i] = 0;
		}
	}
	else
	{
		Assert(_pchRTFCurrent == _pchRTFEnd);

		// Copy most recently read chars in case
		//  we need to back up

		int cbBackup = min((UINT) cbBackupMax, DiffPtrs(_pchRTFCurrent, &_pchRTFBuffer[cbBackupMax])); 
		int i;

		for(i = -1; i >= -cbBackup; i--)
			_pchRTFBuffer[cbBackupMax + i] = _pchRTFCurrent[i];

		if(cbBackup < cbBackupMax)
		{
			// NULL before the first valid character in the backup buffer
			_pchRTFBuffer[cbBackupMax + i] = 0;
		}
	}
	_pchRTFCurrent = &_pchRTFBuffer[cbBackupMax];

	// Fill buffer with as much as we can take given our starting offset
	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  _pchRTFCurrent,
									  cachBufferMost - cbBackupMax,
									  &cchRead);
	if (_pes->dwError)
	{
		TRACEERRSZSC("RTFLEX: GetChar()", _pes->dwError);
		_ecParseError = ecGeneralFailure;
		return 0;
	}

	_pchRTFEnd = &_pchRTFBuffer[cbBackupMax + cchRead];		// Point the end

#if defined(DEBUG)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = cchRead;
		DWORD cbWritten = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFCurrent;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten,
						NULL) && 
						(pbToWrite += cbWritten,
						(cbLeftToWrite -= cbWritten)));
	}
#endif

	return cchRead;
}

/*
 *	CRTFRead::UngetChar()
 *
 *	@mfunc
 *		Bump our file pointer back one char
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	if (_pchRTFCurrent == _pchRTFBuffer || !_pchRTFCurrent)
	{
		Assert(0);
		_ecParseError = ecUnGetCharFailed;
		return FALSE;
	}

	--_pchRTFCurrent;
	return TRUE;
}

/*
 *	CRTFRead::UngetChar(cch)
 *
 *	@mfunc
 *		Bump our file pointer back 'cch' chars
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar(
	UINT cch)		//@parm cch to put back in buffer
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	AssertSz(cch <= cbBackupMax, "CRTFRead::UngetChar():  Number of UngetChar's "
								"exceeds size of backup buffer.");
	while(cch-- > 0)
	{
		if(!UngetChar())
			return FALSE;
	}
	return TRUE;
}

/*
 *	CRTFRead::GetHex()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 */
BYTE CRTFRead::GetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHex");

	BYTE ch = GetChar();

	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::GetHexSkipCRLF()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 *
 *	@devnote
 *		Keep this in sync with GetHex above.
 */
BYTE CRTFRead::GetHexSkipCRLF()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHexSkipCRLF");

	BYTE ch = GetChar();

	// Skip \r \n
	while(ch == CR || ch == LF)
		ch = GetChar(); 

	// Rest is same as CRTFRead::GetHex()
	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::TokenGetHex()
 *
 *	@mfunc
 *		Get an 8 bit character saved as a 2 hex digit value
 *
 *	@rdesc
 *		TOKEN			value of hex number read in
 */
TOKEN CRTFRead::TokenGetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetHex");

	_token = tokenError;					// Default error

	BYTE bChar0 = GetHex();					// Get hexadigit
	if(bChar0 < 16)							// It's valid
	{
		BYTE bChar1 = GetHex();				// Get next hexadigit
		if(bChar1 < 16)						// It's valid too
			_token = (WORD)(bChar0 << 4 | bChar1);
		else
			UngetChar();					// Invalid: put back 1st hexadigit
	}
	return _token;
}

/*
 *	CRTFRead::SkipToEndOfGroup()
 *
 *	@mfunc
 *		Skip to end of current group
 *
 *	@rdesc
 *		EC				An error code
 */
EC CRTFRead::SkipToEndOfGroup()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SkipToEndOfGroup");

	INT		nDepth = 1;
	BYTE	ach;

	while(TRUE)
	{
		ach = GetChar();
		switch(ach)
		{
			case BSLASH:
			{
				BYTE achNext = GetChar();

				// EOF: goto done; else ignore NULLs
				if(!achNext && _ecParseError == ecUnexpectedEOF)
					goto done;

				if(achNext == 'b' && UngetChar() && 
					TokenGetKeyword() == tokenBinaryData)
				{
					// We've encountered the \binN tag in the RTF we want
					//	to skip.  _iParam contains N from \binN once the 
					// 	tag is parsed by TokenGetKeyword()
					SkipBinaryData(_iParam);
				}
				break;
			}

			case LBRACE:
				nDepth++;
				break;

			case RBRACE:
				if (--nDepth <= 0)
					goto done;
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;

			default:
				// Detect Lead bytes here.
				int cTrailBytes = GetTrailBytesCount(ach, _nCodePage);
				if (cTrailBytes)
				{
					for (int i = 0; i < cTrailBytes; i++)
					{
						ach = GetChar();
						if(ach == 0 && _ecParseError == ecUnexpectedEOF)
							goto done;			
					}
				}
				break;
		}
	} 

	Assert(!_ecParseError);
	_ecParseError = ecUnexpectedEOF;

done:
	return _ecParseError;
}

/*
 *	CRTFRead::TokenFindKeyword(szKeyword, prgKeyword, cKeyword)
 *
 *	@mfunc
 *		Find keyword <p szKeyword> and return its token value
 *
 *	@rdesc
 *		TOKEN			token number of keyword
 */
TOKEN CRTFRead::TokenFindKeyword(
	BYTE *		   szKeyword,	//@parm Keyword to find
	const KEYWORD *prgKeyword,	//@parm Keyword array to use
	LONG		   cKeyword)	//@parm Count of keywords
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenFindKeyword");

	INT				iMax;
	INT				iMid;
	INT				iMin;
	INT				nComp;
	BYTE *			pchCandidate;
	BYTE *			pchKeyword;
	const KEYWORD *	pk;

	AssertSz(szKeyword[0],
		"CRTFRead::TokenFindKeyword: null keyword");

	_iKeyword = 0;
#ifdef RTF_HASHCACHE
	if ( _rtfHashInited )
	{
		// Hash is 23% faster than the following binary search on finds
		//  and 55% faster on misses: For 97 words stored in a 257 cache.
		//  Performance numbers will change when the total stored goes up.
		pk = HashKeyword_Fetch ( (CHAR *) szKeyword );
	}
	else
#endif
	{
		iMin = 0;
		iMax = cKeyword - 1;
		pk = NULL;
		do
		{
			iMid		 = (iMin + iMax) / 2;
			pchCandidate = (BYTE *)prgKeyword[iMid].szKeyword;
			pchKeyword	 = szKeyword;
			while (!(nComp = (*pchKeyword | 0x20) - (*pchCandidate | 0x20))	// Be sure to match
				&& *pchKeyword)											//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
			if (nComp < 0)
				iMax = iMid - 1;
			else if (nComp)
				iMin = iMid + 1;
			else
			{
				pk = &prgKeyword[iMid];
				_iKeyword = iMid;				// Save keyword index
				break;
			}
		} while (iMin <= iMax);
	}

	if(pk)
	{
		_token = pk->token;
		
		// Log the RTF keyword scan to aid in tracking RTF tag coverage
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(NOFULLDEBUG)
		if(_prtflg) 
		{
#ifdef RTF_HASCACHE
			_prtflg->AddAt(szKeyword); 
#else
			_prtflg->AddAt((size_t)iMid);
#endif
		}
#endif
	}
	else
	{										// No match: place to take
		_token = tokenUnknownKeyword;		//  care of unrecognized RTF
		if(_fNotifyLowFiRTF)
		{
			iMin = 0;						// Use binary search as above
			iMax = crgszUnrecognizedRTF - 1;
			do
			{
				iMid		 = (iMin + iMax) / 2;
				pchCandidate = (BYTE *)rgszUnrecognizedRTF[iMid];
				pchKeyword	 = szKeyword;
				while (!(nComp = (*pchKeyword | 0x20) - (*pchCandidate | 0x20))
					&& *pchKeyword)
				{
					pchKeyword++;
					pchCandidate++;
				}
				if (nComp < 0)
					iMax = iMid - 1;
				else if (nComp && *pchCandidate)
					iMin = iMid + 1;
				else						// Found keyword
				{
					_iKeyword = -iMid - 1;
					CheckNotifyLowFiRTF();
					break;
				}
			} while (iMin <= iMax);
		}
	}
	return _token;				 			
}

/*
 *	CRTFRead::CheckNotifyLowFiRTF()
 *
 *	@mfunc
 *		If LowFi RTF notifications are enabled, send notification for the
 *		keyword with index _iKeyword to client and turn off the notifications
 *		for the rest of this read.
 */
void CRTFRead::CheckNotifyLowFiRTF(
	BOOL fEnable)
{
	if(_fNotifyLowFiRTF && (_fBody || fEnable))
	{
		char *pach = _iKeyword >= 0
				   ? (char *)rgKeyword[_iKeyword].szKeyword
				   : (char *)rgszUnrecognizedRTF[-_iKeyword - 1];
		_ped->HandleLowFiRTF(pach);
		_fNotifyLowFiRTF = FALSE;
	}
}

/*
 *	CRTFRead::TokenGetKeyword()
 *
 *	@mfunc
 *		Collect a keyword and its parameter. Return token's keyword
 *
 *	@rdesc
 *		TOKEN				token number of keyword
 *
 *	@comm
 *		Most RTF control words (keywords) consist of a span of lower-case
 *		ASCII letters possibly followed by a span of decimal digits. Other
 *		control words consist of a single character that isn't LC ASCII. No
 *		control words contain upper-case characters.
 */
TOKEN CRTFRead::TokenGetKeyword()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetKeyword");

	BYTE		ach = GetChar();
	BYTE		*pach;
	BYTE		szKeyword[cachKeywordMax];
	BYTE		*pachEnd = szKeyword + cachKeywordMax - 1;

	if(!IsAlphaChar(ach))						// Not alpha, i.e.,
	{											//  single char
		if (ach == '\'')						// Most common case needs
		{										//  special treatment
			// Convert hex to char and store result in _token
			if(TokenGetHex() == tokenError)
			{							
				_ecParseError = ecUnexpectedChar;
				goto TokenError;
			}
			if((_token == CR || _token == LF) && FInDocTextDest())
			{
				// Add raw CR or LF in the byte stream as a \par
				return tokenEndParagraph;
			}
		}
		else
		{	
			// Check for other known symbols
			const BYTE *pachSym = szSymbolKeywords;
			
			while(ach != *pachSym && *pachSym)
				pachSym++;
			if(*pachSym)						// Found one
			{
				_token = tokenSymbol[pachSym - szSymbolKeywords];
				if(_token > 0x7F)				// Token or larger Unicode
					return _token;				//  value
			}
			else if (!ach)						// No more input chars
				goto TokenError;
			else								// Code for unrecognized RTF
				_token = ach;					// We'll just insert it for now 
		}
		_token = TokenGetText((BYTE)_token);
		return _token; 
	}

	szKeyword[0] = ach;							// Collect keyword that starts
	pach = szKeyword + 1;						// 	with Alpha
	while (IsAlphaChar(ach = GetChar()))
	{
		if (pach < pachEnd)
			*pach++ = ach;
	}
	*pach = '\0';								// Terminate keyword
	GetParam(ach);								// Get keyword N in _iParam
	if (!_ecParseError)							// Find and return keyword
		return TokenFindKeyword(szKeyword, rgKeyword, cKeywords);

TokenError:
	TRACEERRSZSC("TokenGetKeyword()", _ecParseError);
	return _token = tokenError;
}

/*
 *	CRTFRead::GetParam(ach)
 *
 *	@mfunc
 *		Get any numeric parameter following a keyword, storing the result
 *		in _iParam and setting _fParam = TRUE iff a number is found.
 */
void CRTFRead::GetParam(
	char ach)				// @parm First char of 8-bit text string
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetText");
	_fParam = FALSE;							// Clear parameter
	_iParam = 0;

	if(IsDigit(ach) || ach == '-')			// Collect parameter
	{
		BOOL fNegativeParam = TRUE;

		_fParam = TRUE;
		if(ach != '-')
		{
			_iParam = ach - '0';			// Get parameter value
			fNegativeParam = FALSE;
		}

		while (IsDigit(ach = GetChar()))
			_iParam = _iParam*10 + ach - '0';			

		if (fNegativeParam)
			_iParam = -_iParam;
	}
	if(ach != ' ')
		UngetChar();						//  If not ' ', unget char
}

/*
 *	CRTFRead::TokenGetText(ach)
 *
 *	@mfunc
 *		Collect a string of text starting with the char <p ach> and treat as a
 *		single token. The string ends when a LBRACE, RBRACE, or single '\\' is found.
 *
 *	@devnote
 *		We peek past the '\\' for \\'xx, which we decode and keep on going;
 *		else we return in a state where the next character is the '\\'.
 *
 *	@rdesc
 *		TOKEN			Token number of next token (tokenText or tokenError)
 */
TOKEN CRTFRead::TokenGetText(
	BYTE ach)				// @parm First char of 8-bit text string
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetText");

	BYTE *	pach = _szText;
	SHORT	cachText = 0;
	LONG	CodePage = _pstateStackTop->nCodePage;
	BOOL	fAllASCII = TRUE;
	int		cTrailBytesNeeded = 0;

	_token = tokenError;						// Default error

	// FUTURE(BradO):  This 'goto' into a while loop is pretty weak.
	//	Restructure this 'while' loop such that the 'goto' is removed.

	// Add character passed into routine
	goto add;

	// If cTrailBytesNeeded is non-zero, we need to get all the trail bytes.  Otherwise,
	// a string end in the middle of a DBC or UTF-8 will cause bad display/print problem
	// - 5 to allow extra space for up to 4 bytes for UTF-8 and Null char
	while (cachText < cachTextMax - 5 || cTrailBytesNeeded)
	{
		ach = GetChar();
		switch (ach)
		{
			case BSLASH:
			{
				// FUTURE(BradO):  This code looks ALOT like TokenGetKeyword.
				//	We should combine the two into a common routine.

				BYTE achNext;

				// Get char after BSLASH
				achNext = GetChar();
				if(!achNext)
					goto error;
	
				if(achNext == '\'')					// Handle most frequent
				{									//  case here
					if(TokenGetHex() == tokenError)
					{
						if(cTrailBytesNeeded)
						{
							// The trail-byte must be a raw BSLASH.
							// Unget the single-quote.

							if(!UngetChar())
								goto error;
							// fall through to add BSLASH
						}
						else
						{
							_ecParseError = ecUnexpectedChar;
							goto error;
						}
					}
					else
					{
						ach = (BYTE)_token;
						if (cTrailBytesNeeded == 0 && (ach == CR || ach == LF) &&
							FInDocTextDest())
						{
							// Here, we have a raw CR or LF in document text.  
							// Unget the whole lot of characters and bail out.  
							// TokenGetKeyword will convert this CR or LF into
							// a \par.

							if(!UngetChar(4))
								goto error;
							goto done;
						}
					}
					goto add;
				}

				// Check next byte against list of RTF symbol
				// NOTE:- we need to check for RTF symbol even if we
				// are expecting a trail byte.  According to the rtf spec,
				// we cannot just take this backslash as trail byte.
				// HWC 9/97

				const BYTE *pachSymbol = szSymbolKeywords;			
				while(achNext != *pachSymbol && *pachSymbol)	
					pachSymbol++;

				TOKEN tokenTmp;

				if (*pachSymbol && 
					(tokenTmp = tokenSymbol[pachSymbol - szSymbolKeywords])
						 <= 0x7F)
				{
					ach = (BYTE)tokenTmp;
					goto add;
				}

				// In either of the last two cases below, we will want
				// to unget the byte following the BSLASH
				if(!UngetChar())
					goto error;

				if(cTrailBytesNeeded && !IsAlphaChar(achNext))
				{
					// In this situation, either this BSLASH begins the next 
					// RTF keyword or it is a raw BSLASH which is the trail 
					// byte for a DBCS character.

					// I think a fair assumption here is that if an alphanum
					// follows the BSLASH, that the BSLASH begins the next
					// RTF keyword.

					// add the raw BSLASH
					goto add;					
				}

				// Here, my guess is that the BSLASH begins the next RTF 
				// keyword, so unget the BSLASH
			    if(!UngetChar())
					goto error;					

				goto done;
			}

			case LBRACE:						// End of text string
			case RBRACE:
				if(cTrailBytesNeeded)
				{
					// Previous char was a lead-byte of a DBCS pair or UTF-8, which
					// makes this char a raw trail-byte.
					goto add;
				}

				if(!UngetChar())				// Unget delimeter
					goto error;
				goto done;

			case LF:							// Throw away noise chars
			case CR:
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;
				ach = ' ';						// Replace NULL by blank

			default:							// Collect chars
add:
				*pach++ = ach;
				++cachText;
				if(ach > 0x7F)
					fAllASCII = FALSE;
	
				// Check if we are expecting more trail bytes
				if (cTrailBytesNeeded)
					cTrailBytesNeeded--;
				else
					cTrailBytesNeeded = GetTrailBytesCount(ach, CodePage);
				Assert(cTrailBytesNeeded >= 0);
		}
	}

done:
	_token = (WORD)(fAllASCII ? tokenASCIIText : tokenText);
	*pach = '\0';								// Terminate token string

error:
	return _token;
}
 
/*
 *	CRTFRead::TokenGetToken()
 *
 *	@mfunc
 *		This function reads in next token from input stream
 *
 *	@rdesc
 *		TOKEN				token number of next token
 */
TOKEN CRTFRead::TokenGetToken()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetToken");

	BYTE		ach;

	_tokenLast	= _token;					// Used by \* destinations and FE
	_token = tokenEOF;						// Default end-of-file

SkipNoise:
	ach = GetChar();
	switch (ach)
	{
	case CR:
	case LF:
		goto SkipNoise;

	case LBRACE:
		_token = tokenStartGroup;
		break;

	case RBRACE:
		_token = tokenEndGroup;
		break;

	case BSLASH:
		_token = TokenGetKeyword();
		break;

	case 0:									
		if(_ecParseError == ecUnexpectedEOF)
			break;
		ach = ' ';							// Replace NULL by blank
											// Fall thru to default
	default:
		if( !_pstateStackTop )
		{
			TRACEWARNSZ("Unexpected token in rtf file");
			Assert(_token == tokenEOF);
			if (_ped->Get10Mode())
				_ecParseError = ecUnexpectedToken;	// Signal bad file
		}
		else if (_pstateStackTop->sDest == destObjectData || 
				 _pstateStackTop->sDest == destPicture )
		// not text but data
		{
			_token = (WORD)(tokenObjectDataValue + _pstateStackTop->sDest
							- destObjectData);
			UngetChar();
		}
		else
			_token = TokenGetText(ach);
	}
	return _token;
}

#define FINDOCTEXTDEST 	((1 << destRTF)   | \
						 (1 << destField) | \
						 (1 << destFieldResult) | (1 << destFieldInstruction) | \
						 (1 << destParaNumText) | (1 << destParaNumbering)	  | \
						 (1 << destNULL))
/*
 *	CRTFRead::FInDocTextDest()
 *
 *	@mfunc
 *		Returns a BOOL indicating if the current destination is one in which
 *		we would encounter document text.
 *
 *	@rdesc
 *		BOOL	indicates the current destination may contain document text.
 */
BOOL CRTFRead::FInDocTextDest() const
{
	AssertSz(_pstateStackTop->sDest < destMAX,
		"CRTFRead::FInDocTextDest(): New destination encountered - update enum in _rtfread.h");

	return (FINDOCTEXTDEST & (1 << _pstateStackTop->sDest)) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtflog.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFLOG.CPP - RichEdit RTF log
 *
 *		Contains the code for the RTFLog class which can be used 
 *		to log the number of times RTF tags are read by the RTF reader
 *		for use in coverage testing. TODO: Implement RTF tag logging for the Mac
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtflog.h"
#include "tokens.h"

extern INT cKeywords;
extern const KEYWORD rgKeyword[];


#if defined(DEBUG) && !defined(NOFULLDEBUG)
/*
 *	CRTFRead::TestParserCoverage()
 *
 *	@mfunc
 *		A debug routine used to test the coverage of HandleToken.  The routine
 *		puts the routine into a debug mode and then determines:
 *
 *			1.  Dead tokens - (T & !S & !P)
 *				Here, token:
 *					a) is defined in token.h  (T)
 *					b) does not have a corresponding keyword (not scanned)  (!S)
 *					c) is not processed by HandleToken  (!P)
 *			2.  Tokens that are parsed but not scanned - (T & !S & P)
 *				Here, token:
 *					a) is defined in token.h  (T)
 *					b) does not have a corresponding keyword (not scanned)  (!S}
 *					c) is processed by HandleToken  (P)
 *			3.  Tokens that are scanned but not parsed - (T & S & !P)
 *				Here, token:
 *					a) is defined in token.h  (T)
 *					b) does have a corresponding keyword (is scanned)  (S)
 *					c) is not processed by HandleToken  (!P)
 */
void CRTFRead::TestParserCoverage()
{
	int i;
	char *rgpszKeyword[tokenMax - tokenMin];
	BOOL rgfParsed[tokenMax - tokenMin];
	char szBuf[256];

	// Put HandleToken in debug mode
	_fTestingParserCoverage = TRUE;

	// Gather info about tokens/keywords
	for(i = 0; i < tokenMax - tokenMin; i++)
	{
		_token = (TOKEN)(i + tokenMin);
		rgpszKeyword[i] = PszKeywordFromToken(_token);
		rgfParsed[i] = HandleToken() == ecNoError;
	}

	// Reset HandleToken to non-debug mode
	_fTestingParserCoverage = FALSE;

	// Should coverage check include those we know will fail test, but
	// which we've examined and know why they fail?
	BOOL fExcuseCheckedToks = TRUE;

	if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGESTRICT", 0))
		fExcuseCheckedToks = FALSE;

	// (T & !S & !P)  (1. above)
	for(i = 0; i < tokenMax - tokenMin; i++)
	{
	  	if(rgpszKeyword[i] || rgfParsed[i]) 
			continue;

		TOKEN tok = (TOKEN)(i + tokenMin);

		// Token does not correspond to a keyword, but still may be scanned
		// check list of individual symbols which are scanned
		if(FTokIsSymbol(tok))
			continue;

		// Check list of tokens which have been checked and fail
		// the sanity check for some known reason (see FTokFailsCoverageTest def'n)
		if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
			continue;

		sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token neither scanned nor parsed - token = %d", tok);
		AssertSz(0, szBuf);
	}

	// (T & !S & P)  (2. above)
	for(i = 0; i < tokenMax - tokenMin; i++)
	{
		if(rgpszKeyword[i] || !rgfParsed[i])
			continue;

		TOKEN tok = (TOKEN)(i + tokenMin);

		// Token does not correspond to a keyword, but still may be scanned
		// check list of individual symbols which are scanned
		if(FTokIsSymbol(tok))
			continue;

		// Check list of tokens which have been checked and fail
		// the sanity check for some known reason (see FTokFailsCoverageTest def'n)
		if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
			continue;

		sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token parsed but not scanned - token = %d", tok);
		AssertSz(0, szBuf);
	}

	// (T & S & !P)  (3. above)
	for(i = 0; i < tokenMax - tokenMin; i++)
	{
		if(!rgpszKeyword[i] || rgfParsed[i])
			continue;

		TOKEN tok = (TOKEN)(i + tokenMin);

		// Check list of tokens which have been checked and fail
		// the sanity check for some known reason (see FTokFailsCoverageTest def'n)
		if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
			continue;

		sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token scanned but not parsed - token = %d, tag = \\%s", tok, rgpszKeyword[i]);
		AssertSz(0, szBuf);
	}
}

/*
 *	CRTFRead::PszKeywordFromToken()
 *
 *	@mfunc
 *		Searches the array of keywords and returns the keyword
 *		string corresponding to the token supplied
 *
 *	@rdesc
 *		returns a pointer to the keyword string if one exists
 *		and NULL otherwise
 */
CHAR *CRTFRead::PszKeywordFromToken(TOKEN token)
{
	for(int i = 0; i < cKeywords; i++)
	{
		if(rgKeyword[i].token == token) 
			return rgKeyword[i].szKeyword;
	}
	return NULL;
}

/*
 *	CRTFRead::FTokIsSymbol(TOKEN tok)
 *
 *	@mfunc
 *		Returns a BOOL indicating whether the token, tok, corresponds to an RTF symbol
 *		(that is, one of a list of single characters that are scanned in the
 *		RTF reader)
 *
 *	@rdesc
 *		BOOL - 	indicates whether the token corresponds to an RTF symbol
 */
BOOL CRTFRead::FTokIsSymbol(TOKEN tok)
{
	const BYTE *pbSymbol = NULL;

	extern const BYTE szSymbolKeywords[];
	extern const TOKEN tokenSymbol[];

	// check list of individual symbols which are scanned
	for(pbSymbol = szSymbolKeywords; *pbSymbol; pbSymbol++)
	{
		if(tokenSymbol[pbSymbol - szSymbolKeywords] == tok)
			return TRUE;
	}
	return FALSE;
}

/*
 *	CRTFRead::FTokFailsCoverageTest(TOKEN tok)
 *
 *	@mfunc
 *		Returns a BOOL indicating whether the token, tok, is known to fail the
 *		RTF parser coverage test.  These tokens are those that have been checked 
 *		and either:
 *			1) have been implemented correctly, but just elude the coverage test
 *			2) have yet to be implemented, and have been recognized as such
 *
 *	@rdesc
 *		BOOL - 	indicates whether the token has been checked and fails the
 *				the parser coverage test for some known reason
 */
BOOL CRTFRead::FTokFailsCoverageTest(TOKEN tok)
{
	switch(tok)
	{
	// (T & !S & !P)  (1. in TestParserCoverage)
		// these really aren't tokens per se, but signal ending conditions for the parse
		case tokenError:
		case tokenEOF:

	// (T & !S & P)  (2. in TestParserCoverage)
		// emitted by scanner, but don't correspond to recognized RTF keyword
		case tokenUnknownKeyword:
		case tokenText:
		case tokenASCIIText:

		// recognized directly (before the scanner is called)
		case tokenStartGroup:
		case tokenEndGroup:

		// recognized using context information (before the scanner is called)
		case tokenObjectDataValue:
		case tokenPictureDataValue:

	// (T & S & !P)  (3. in TestParserCoverage)
		// None

			return TRUE;
	}

	return FALSE;
}
#endif // DEBUG

/*
 *	CRTFLog::CRTFLog()
 *	
 *	@mfunc
 *		Constructor - 
 *			1.  Opens a file mapping to log hit counts, creating
 *					the backing file if neccessary
 *			2.  Map a view of the file mapping into memory
 *			3.  Register a windows message for change notifications
 *
 */
CRTFLog::CRTFLog() : _rgdwHits(NULL), _hfm(NULL), _hfile(NULL)
{
#ifndef NOFULLDEBUG
	const char cstrMappingName[] = "RTFLOG";
	const char cstrWM[] = "RTFLOGWM";
	const int cbMappingSize = sizeof(ELEMENT) * ISize();

	BOOL fNewFile = FALSE;

	// Check for existing file mapping
	if(!(_hfm = OpenFileMappingA(FILE_MAP_ALL_ACCESS,
								TRUE,
								cstrMappingName)))
	{
		// No existing file mapping
		// Get the file with which to create the file mapping
		// first, attempt to open an existing file
		if(!(_hfile = CreateFileA(LpcstrLogFilename(),
								GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL)))
		{
			// No existing file, attempt to create new
			if(!(_hfile = CreateFileA(LpcstrLogFilename(),
										GENERIC_READ | GENERIC_WRITE,
										0,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL)))
			{
				return;
			}
			fNewFile = TRUE;
		}

		_hfm = CreateFileMappingA(_hfile, NULL, PAGE_READWRITE,	0,
								  cbMappingSize, cstrMappingName);
		if(!_hfm)
			return;
	}

	LPVOID lpv = MapViewOfFile(_hfm, FILE_MAP_ALL_ACCESS, 0, 0,	cbMappingSize);
	if(!lpv)
		return;

	// Register windows message for change notifications
	SideAssert(_uMsg = RegisterWindowMessageA(cstrWM));

	// Memory-mapped file is now mapped to _rgdwHits
	_rgdwHits = (PELEMENT)lpv;

	// Zero the memory-mapped file if we created it new
	// (Win95 gives us a new file w/ garbage in it for some reason)
	if(fNewFile)
		Reset();
#endif	
}


/*
 *	CRTFLog::Reset()
 *	
 *	@mfunc
 *		Resets the hitcount of each element in the log to 0
 *
 */
void CRTFLog::Reset()
{
	if(!FInit())
		return;

	for(INDEX i = 0; i < ISize(); i++)
		(*this)[i] = 0;

	// notify clients of change
	ChangeNotifyAll();
}

/*
 *	CRTFLog::UGetWindowMsg
 *
 *	@mdesc
 *		Returns the window message id used for change notifications
 *
 *	@rdesc
 *		UINT		window message id
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
UINT CRTFLog::UGetWindowMsg() const
{
	AssertSz(FInit(), "CRTFLog::UGetWindowMsg():  CRTFLog not initialized properly");

	return _uMsg;
}

/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (l-value)
 *
 *	@rdesc
 *		ELEMENT &			reference to element i of log
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i)
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}

/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (r-value)
 *
 *	@rdesc
 *		const ELEMENT &	reference to element i of log
 *		
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
const CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i) const
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}


/*
 *	CRTFLog::LpcstrLogFilename()
 *	
 *	@mfunc
 *		Returns name of file to be used for log
 *
 *	@rdesc
 *		LPCSTR		pointer to static buffer containing file name
 */
LPCSTR CRTFLog::LpcstrLogFilename() const
{
	static char szBuf[MAX_PATH] = "";
#ifndef NOFULLDEBUG
	const char cstrLogFilename[] = "RTFLOG";
	if(!szBuf[0])
	{
		DWORD cchLength;
		char szBuf2[MAX_PATH];

		SideAssert(cchLength = GetTempPathA(MAX_PATH, szBuf2));

		// append trailing backslash if neccessary
		if(szBuf2[cchLength - 1] != '\\')
		{
			szBuf2[cchLength] = '\\';
			szBuf2[cchLength + 1] = 0;
		}

		wsprintfA(szBuf, "%s%s", szBuf2, cstrLogFilename);
	}
#endif
	return szBuf;
}


/*
 *	CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF keyword, lpcstrKeyword
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(strcmp(lpcstrKeyword, rgKeyword[i].szKeyword) == 0)
			break;
	}

	if(i == ISize())
		return FALSE;

	if(piIndex)
		*piIndex = i;

	return TRUE;
}


/*
 *	CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF token, token
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(token == rgKeyword[i].token)
			break;
	}

	if(i == ISize())
		return FALSE;

	if(piIndex)
		*piIndex = i;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtfwrit.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFWRIT.CPP - RichEdit RTF Writer (w/o objects) |
 *
 *		This file contains the implementation of the RTF writer
 *		for the RichEdit control, except for embedded objects,
 *		which are handled mostly in rtfwrit2.cpp
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *		Lots of enhancements: Brad Olenick <nl>
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfwrit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_font.h"
#include "_dispml.h"
#include "_version.h"

ASSERTDATA

extern const KEYWORD rgKeyword[];

//========================= Global String Constants ==================================

BYTE iCharRepANSI = ANSI_INDEX;				// ToDo: make more general

#ifdef DEBUG
// Quick way to find out what went wrong: rgszParseError[ecParseError]
//
CHAR *	rgszParseError[] =
{
	"No error",
	"Can't convert to Unicode",				// FF
	"Color table overflow",					// FE
	"Expecting '\\rtf'",					// FD
	"Expecting '{'",						// FC
	"Font table overflow",					// FB
	"General failure",						// FA
	"Keyword too long",						// F9
	"Lexical analyzer initialize failed",	// F8
	"No memory",							// F7
	"Parser is busy",						// F6
	"PutChar() function failed",			// F5
	"Stack overflow",						// F4
	"Stack underflow",						// F3
	"Unexpected character",					// F2
	"Unexpected end of file",				// F1
	"Unexpected token",						// F0
	"UnGetChar() function failed",			// EF
	"Maximum text length reached",			// EE
	"Streaming out object failed",			// ED
	"Streaming in object failed",			// EC
	"Truncated at CR or LF",				// EB
	"Format-cache failure",					// EA
	"UTF8 not used since not all Unicode",	// E9
	NULL									// End of list marker
};

CHAR * szDest[] =
{
	"RTF",
	"Color Table",
	"Font Table",
	"Binary",
	"Object",
	"Object Class",
	"Object Name",
	"Object Data",
	"Field",
	"Field Result",
	"Field Instruction",
	"Symbol",
	"Paragraph Numbering",
	"Picture"
};

#endif

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
//	CWF_STR CWF_VAL   CWF_GRP  CWF_AST     CWF_GRV	  CWF_SVAL
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s", "{\\%s%d", "\\%s%hd"
};

// Special control-word formats
static const CHAR szBeginFontEntryFmt[]	= "{\\f%d\\%s";
static const CHAR szBulletGroup[]		= "{\\pntext\\f%d\\'B7\\tab}";
static const CHAR szBulletFmt[]			= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d{\\pntxtb\\'B7}}";
static const CHAR szBeginNumberGroup[]	= "{\\pntext\\f%d ";
static const CHAR szEndNumberGroup[]	= "\\tab}";
static const CHAR szBeginNumberFmt[]	= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d\\pnstart%d";
static const CHAR szpntxtb[]			= "{\\pntxtb(}";
static const CHAR szpntxta[]			= "{\\pntxta%c}";
static const CHAR szColorEntryFmt[]		= "\\red%d\\green%d\\blue%d;";
static const CHAR szEndFontEntry[]		= ";}";
extern const CHAR szEndGroupCRLF[]		= "}\r\n";
static const CHAR szEscape2CharFmt[]	= "\\'%02x\\'%02x";
static const CHAR szLiteralCharFmt[]	= "\\%c";
static const CHAR szPar[]				= "\\par\r\n";
static const CHAR szPar10[]				= "\r\n\\par ";
static const CHAR szObjPosHolder[] 		= "\\objattph\\'20";
static const CHAR szDefaultFont[]		= "\\deff0";
static const CHAR szHorzdocGroup[]		= "{\\horzdoc}";
static const CHAR szNormalStyle[]		= "{ Normal;}";
static const CHAR szHeadingStyle[]		= "{\\s%d heading %d;}";
static const CHAR szEndNestRow[]		= "{\\*\\nesttableprops";
static const CHAR szNestRow[]			= "\\nestrow}{\\nonesttables\\par}\r\n";
static const CHAR szNestedWidthFmt[]	= "\\trpaddl%d\\trpaddr%d\\trpaddfl3\\trpaddfr3\r\n";
static const CHAR szFieldStart[]		= "{\\field{\\*\\fldinst{";
static const CHAR szHyperlink[]			= "HYPERLINK \"";
static const CHAR szFieldResult[]		= "\"}}{\\fldrslt{";

#define szEscapeCharFmt		&szEscape2CharFmt[6]

// Arrays of RTF control-word indices. NOTE: if any index is greater than 255,
// the corresponding array must be changed to a WORD array. The compiler
// issues a warning in such cases

const BYTE rgiszTerminators[] =
{
	i_cell, 0, i_tab, 0, i_line, i_page, i_nestcell
};

// Keep these indices in sync with the special character values in _common.h
const WORD rgiszSpecial[] =
{
	i_enspace,				// 0x2002
	i_emspace,				// 0x2003
	0,						// 0x2004
	0,						// 0x2005
	0,						// 0x2006
	0,						// 0x2007
	0,						// 0x2008
	0,						// 0x2009
	0,						// 0x200A
	0,						// 0x200B
	i_zwnj,					// 0x200C
	i_zwj,					// 0x200D
	i_ltrmark,				// 0x200E
	i_rtlmark,				// 0x200F
	0,						// 0x2010
	0,						// 0x2011
	0,						// 0x2012
	i_endash,				// 0x2013
	i_emdash,				// 0x2014
	0,						// 0x2015
	0,						// 0x2016
	0,						// 0x2017
	i_lquote, 				// 0x2018
	i_rquote,				// 0x2019
	0,						// 0x201A
	0,						// 0x201B
	i_ldblquote, 			// 0x201C
	i_rdblquote,			// 0x201D
	0,						// 0x201E
	0,						// 0x201F
	0,						// 0x2020
	0,						// 0x2021
	i_bullet				// 0x2022
};

const WORD rgiszEffects[] =							
{													// Effects keywords
	i_deleted, i_revised, i_disabled, i_impr, 		// Ordered max CFE_xx to
	i_embo, i_shad, i_outl, i_v, i_caps, i_scaps, 	//  min CFE_xx (cept i_deleted)
	i_lnkd, i_protect, i_strike, i_ul, i_i,	i_b		// (see WriteCharFormat())
};													

#define CEFFECTS	ARRAY_SIZE(rgiszEffects)

const BYTE rgiszPFEffects[] =						// PF effects keywords
{													// Ordered max PFE_xx to
	i_collapsed, i_sbys, i_hyphpar, i_nowidctlpar,	//  min PFE_xx
	i_noline, i_pagebb, i_keepn, i_keep, i_rtlpar
};													// (see WriteParaFormat())

#define CPFEFFECTS	ARRAY_SIZE(rgiszPFEffects)

const WORD rgiszUnderlines[] =
{
	i_ulnone, i_ul, i_ulw, i_uldb, i_uld,			// Std Word underlines
	i_uldash, i_uldashd, i_uldashdd, i_ulwave, i_ulth, i_ulhair,
	i_ululdbwave, i_ulhwave, i_ulldash, i_ulthdash, i_ulthdashd,
	i_ulthdashdd, i_ulthd, i_ulthldash
};

#define CUNDERLINES	ARRAY_SIZE(rgiszUnderlines)

const BYTE rgiszFamily[] =							// Font family RTF name
{													//  keywords in order of
	i_fnil, i_froman, i_fswiss, i_fmodern,			//  bPitchAndFamily
	i_fscript, i_fdecor, i_ftech, i_fbidi
};

#define CFAMILIES ARRAY_SIZE(rgiszFamily)

const BYTE rgiszAlignment[] =						// Alignment keywords
{													// Keep in sync with
	i_ql, i_qr,	i_qc, i_qj							//  alignment constants
};

const BYTE rgiszTabAlign[] =						// Tab alignment keywords
{													// Keep in sync with tab
	i_tqc, i_tqr, i_tqdec							//  alignment constants
};

const BYTE rgiszTabLead[] =							// Tab leader keywords
{													// Keep in sync with tab
	i_tldot, i_tlhyph, i_tlul, i_tlth, i_tleq		//  leader constants
};

const BYTE rgiszNumberStyle[] =						// Numbering style keywords
{													// Keep in sync with TOM
	i_pndec, i_pnlcltr, i_pnucltr,					//  values
	i_pnlcrm, i_pnucrm					
};

const WORD rgiszBorders[] =							// Border combination keywords
{													
	i_box,
	  i_brdrl,   i_brdrt,   i_brdrr,   i_brdrb,
	i_trbrdrl, i_trbrdrt, i_trbrdrr, i_trbrdrb,
	i_clbrdrl, i_clbrdrt, i_clbrdrr, i_clbrdrb
};

const BYTE rgiszBorderStyles[] =					// Border style keywords
{													
	i_brdrdash, i_brdrdashsm, i_brdrdb, i_brdrdot,
	i_brdrhair, i_brdrs, i_brdrth, i_brdrtriple
};
#define CBORDERSTYLES ARRAY_SIZE(rgiszBorderStyles)

const BYTE rgiszBorderEffects[] =					// Border effect keywords
{													
	i_brdrbar, i_brdrbtw, i_brdrsh					// Reverse order from bits
};

const BYTE rgiszShadingStyles[] =					// Shading style keywords
{													
	i_bgbdiag, i_bgcross, i_bgdcross, i_bgdkbdiag,
	i_bgdkcross, i_bgdkdcross, i_bgdkfdiag, i_bgdkhoriz,
	i_bgdkvert, i_bgfdiag, i_bghoriz, i_bgvert 
};
#define CSHADINGSTYLES ARRAY_SIZE(rgiszShadingStyles)

// RGB with 2 bits per color type (in BGR order)
const COLORREF g_Colors[] =
{
	RGB(  0,   0,   0),	// \red0\green0\blue0
	RGB(  0,   0, 255),	// \red0\green0\blue255
	RGB(  0, 255, 255),	// \red0\green255\blue255
	RGB(  0, 255,   0),	// \red0\green255\blue0
	RGB(255,   0, 255),	// \red255\green0\blue255
	RGB(255,   0,   0),	// \red255\green0\blue0
	RGB(255, 255,   0),	// \red255\green255\blue0
	RGB(255, 255, 255),	// \red255\green255\blue255
	RGB(  0,   0, 128),	// \red0\green0\blue128
	RGB(  0, 128, 128),	// \red0\green128\blue128
	RGB(  0, 128,   0),	// \red0\green128\blue0
	RGB(128,   0, 128),	// \red128\green0\blue128
	RGB(128,   0,   0),	// \red128\green0\blue0
	RGB(128, 128,   0),	// \red128\green128\blue0
	RGB(128, 128, 128),	// \red128\green128\blue128
	RGB(192, 192, 192),	// \red192\green192\blue192
};

static BYTE rgcCell[MAXTABLENEST];	// Used to track proper table-row syntax
static BYTE rgiCell[MAXTABLENEST];

/*
 *	CRTFWrite::MapsToRTFKeywordW(wch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		BOOL			TRUE if char maps to RTF keyword
 *
 *	@devnote
 *		Make inline since ship build only references it once
 */
inline BOOL CRTFWrite::MapsToRTFKeywordW(
	WCHAR wch)
{
	return (!_fNCRForNonASCII || wch == BSLASH) && (
		IN_RANGE(CELL, wch, SOFTHYPHEN) &&				// 7-AD
		(
			wch <= CR && wch != 8 && (wch != FF || !_ped->Get10Mode()) ||
			wch == BSLASH		||
			IN_RANGE(LBRACE, wch, RBRACE) && wch != '|'	||
			wch >= NBSPACE && (wch == NBSPACE || wch == SOFTHYPHEN)
		) ||
		IN_RANGE(ENSPACE, wch, BULLET) &&				// 2002-2022
		(
			IN_RANGE(ENSPACE, wch, EMSPACE)		||		// 2002-2003
			IN_RANGE(LTRMARK, wch, NBHYPHEN) &&			// 200E, 200F, 2011
				wch != 0x2010					||
			IN_RANGE(ENDASH, wch, EMDASH)		||		// 2013-2014
			IN_RANGE(LQUOTE, wch, RQUOTE)		||		// 2018-2019
			IN_RANGE(LDBLQUOTE, wch, RDBLQUOTE) ||		// 201C-201D
			wch == BULLET								// 2022
		));
}

/*
 *	CRTFWrite::MapsToRTFKeywordA(ch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		TRUE if char maps to RTF keyword
 *
 *	@devnote
 *		Make inline since ship build only references it once
 */
inline BOOL CRTFWrite::MapsToRTFKeywordA(
	char ch)
{
	return IN_RANGE(TAB, ch, CR) && (ch != FF || !_ped->Get10Mode()) ||
		ch == CELL ||
		ch == BSLASH ||
		ch == LBRACE || 
		ch == RBRACE;
}

/*
 *	CRTFWrite::MapToRTFKeyword(pv, cch, iCharEncoding, fQuadBackSlash)
 *
 *	@mfunc
 *		Examines the first character in the string pointed to by pv and
 *		writes out the corresponding RTF keyword.  In situations where
 *		the first and subsequent characters map to a single keyword, we
 *		return the number of additional characters used in the mapping.
 *
 *	@rdesc
 *		int		indicates the number of additional characters used when
 *				the mapping to an RTF keyword involves > 1 characters.
 */
int CRTFWrite::MapToRTFKeyword(
	void *	pv,				//@parm ptr to ansi or Unicode string
	int		cch,			//@parm string count
	int		iCharEncoding,	//@parm MAPTOKWD_ANSI or MAPTOKWD_UNICODE
	BOOL	fQuadBackSlash)	//@parm If TRUE, write 4 \ for each \ 
{
	Assert(iCharEncoding == MAPTOKWD_ANSI || iCharEncoding == MAPTOKWD_UNICODE);

	WCHAR ch = ((iCharEncoding == MAPTOKWD_ANSI) ? *(char *)pv : *(WCHAR *)pv);
	int cchRet = 0;

	Assert((iCharEncoding == MAPTOKWD_ANSI) ? MapsToRTFKeywordA(ch) : MapsToRTFKeywordW(ch));

	switch(ch)
	{
		case BULLET:
		case EMDASH:
		case EMSPACE:
		case ENDASH:
		case ENSPACE:
		case LDBLQUOTE:
		case LTRMARK:
		case LQUOTE:
		case RDBLQUOTE:
		case RQUOTE:
		case RTLMARK:
			Assert(ch > 0xFF);

			if(iCharEncoding != MAPTOKWD_ANSI)
			{
				AssertSz(rgiszSpecial[ch - ENSPACE] != 0,
					"CRTFWrite::WriteText(): rgiszSpecial out-of-sync");
				PutCtrlWord(CWF_STR, rgiszSpecial[ch - ENSPACE]);
			}
			break;

		case CELL:
			if(!_bTableLevel)
				goto lf;
			Assert(_iCell < _cCell);
			_iCell++;
			if(_bTableLevel > 1)			// Setup to write \nestcell
				ch += 6;					//  instead of \cell
											// Fall thru to TAB, FF, VT
		case TAB:
		case FF:
		case VT:
			Assert(TAB == CELL + 2);
			PutCtrlWord(CWF_STR, rgiszTerminators[ch - CELL]);
			break;

		case CR:
		{
			if(cch)						// 1 or more chars follow CR in pch
			{
				WCHAR ch1;
				WCHAR ch2 = 0;

				if(iCharEncoding == MAPTOKWD_ANSI)
				{
					char *pch = (char *)pv;
					ch1 = pch[1];
					if(cch > 1)
						ch2 = pch[2];
				}
				else
				{
					WCHAR *pch = (WCHAR *)pv;
					ch1 = pch[1];
					if(cch > 1)
						ch2 = pch[2];
				}
				if(ch1 == CR && ch2 == LF)
				{
					// Translate CRCRLF	to a blank (represents soft line break)
					// Maybe don't want to do in 10 Mode??
					PutChar(' ');
					cchRet = 2;
					break;
				}
				if(ch1 == LF)			// Ignore LF after CR
				{
					cchRet = 1;
					cch--;
				}
			}
		}								// Fall thru to LF (EOP) case

lf:
		case LF:
			PutPar();
			if(_fBullet)
			{
				if(cch > 0)
				{
					if(!_nNumber) 
						printF(szBulletGroup, _symbolFont);

					else if(!_pPF->IsNumberSuppressed())
					{
						WCHAR szNumber[CCHMAXNUMTOSTR];
						_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
						printF(szBeginNumberGroup, _nFont);
						WritePcData(szNumber, _cpg, FALSE);
						printF(szEndNumberGroup);
					}
				}
				else
					_fBulletPending = TRUE;
			}
			break;

		case SOFTHYPHEN:
			ch = '-';
			goto printFLiteral;

		case BSLASH:
			if(fQuadBackSlash)
				printF(szLiteralCharFmt, ch);
											// Fall thru to printFLiteral
		case LBRACE:
		case RBRACE:
printFLiteral:
			printF(szLiteralCharFmt, ch);
			break;

		case NBSPACE:
			ch = '~';
			goto printFLiteral;

		case NBHYPHEN:
			ch = '_';
			goto printFLiteral;
	}
	return cchRet;
}


//======================== CRTFConverter Base Class ==================================

/*
 *	CRTFConverter::CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter constructor
 */
CRTFConverter::CRTFConverter(
	CTxtRange *		prg,			//@parm CTxtRange for transfer
	EDITSTREAM *	pes,			//@parm Edit stream for transfer
	DWORD			dwFlags,		//@parm Converter flags
	BOOL 			fRead)			//@parm Initialization for a reader or writer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFConverter::CRTFConverter");

	AssertSz(prg && pes && pes->pfnCallback,
		"CRTFWrite::CRTFWrite: Bad RichEdit");

	_prg			= prg;
	_pes			= pes;
	_ped			= prg->GetPed();
	_dwFlags		= dwFlags;
	_ecParseError	= ecNoError;
	_bTableLevel	= 0;

	if(!_ctfi)
		ReadFontSubInfo();

#if defined(DEBUG)
	_hfileCapture = NULL;

#if !defined(NOFULLDEBUG)
	if(GetProfileIntA("RICHEDIT DEBUG", "RTFCAPTURE", 0))
	{
		char szTempPath[MAX_PATH] = "\0";
		const char cszRTFReadCaptureFile[] = "CaptureRead.rtf";
		const char cszRTFWriteCaptureFile[] = "CaptureWrite.rtf";
		DWORD cchLength;
		
		SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

		// append trailing backslash if neccessary
		if(szTempPath[cchLength - 1] != '\\')
		{
			szTempPath[cchLength] = '\\';
			szTempPath[cchLength + 1] = 0;
		}

		strcat(szTempPath, fRead ? cszRTFReadCaptureFile : 
									cszRTFWriteCaptureFile);
		
		SideAssert(_hfileCapture = CreateFileA(szTempPath,
											GENERIC_WRITE,
											FILE_SHARE_READ,
											NULL,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL,
											NULL));
	}
#endif // !defined(NOFULLDEBUG)

#endif // defined(DEBUG)
}



//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFPutToStream (
	RTFWRITEOLESTREAM *	OLEStream,	//@parm OLESTREAM
	const void *		pvBuffer,	//@parm Buffer to  write
	DWORD				cb)			//@parm Bytes to write
{
	return OLEStream->Writer->WriteData ((BYTE *)pvBuffer, cb);
}



//============================ CRTFWrite Class ==================================

/*
 *	CRTFWrite::CRTFWrite()
 *
 *	@mfunc
 *		RTF writer constructor
 */
CRTFWrite::CRTFWrite(
	CTxtRange *		prg,			//@parm CTxtRange to write
	EDITSTREAM *	pes,			//@parm Edit stream to write to
	DWORD			dwFlags)		//@parm Write flags
	: CRTFConverter(prg, pes, dwFlags, FALSE)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CRTFWrite");

	ZeroMemory(&_CF, sizeof(CCharFormat));	// Setup "previous" CF with RTF
	_CF._dwEffects	= CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR;//  Font info is given 
	_CF._yHeight	= -32768;				//  by first font in range
											//  [see end of LookupFont()]
	Assert(_ped);
	_ped->GetDefaultLCID(&_CF._lcid);

	// init OleStream
	RTFWriteOLEStream.Writer = this;
	RTFWriteOLEStream.lpstbl->Put = (DWORD (CALLBACK* )(LPOLESTREAM, const void FAR*, DWORD))
							   RTFPutToStream;
	RTFWriteOLEStream.lpstbl->Get = NULL;

	_fIncludeObjects = TRUE;
	if((dwFlags & SF_RTFNOOBJS) == SF_RTFNOOBJS)
		_fIncludeObjects = FALSE;

	_fNCRForNonASCII = (dwFlags & SF_NCRFORNONASCII) != 0;
	_fNeedDelimeter = FALSE;
	_nHeadingStyle = 0;					// No headings found
	_nNumber = 0;						// No paragraph numbering yet
	_pPF = NULL;
	_pbAnsiBuffer = NULL;
	_fFieldResult = FALSE;
}											

/*
 *	CRTFWrite::FlushBuffer()
 *
 *	@mfunc
 *		Flushes output buffer
 *
 *	@rdesc
 *		BOOL			TRUE if successful
 */
BOOL CRTFWrite::FlushBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::FlushBuffer");

	LONG cchWritten;

	if (!_cchBufferOut)
		return TRUE;

#ifdef DEBUG_PASTE
	if (FromTag(tagRTFAsText))
	{
		CHAR *	pchEnd	= &_pchRTFBuffer[_cchBufferOut];
		CHAR	chT		= *pchEnd;

		*pchEnd = 0;
		TraceString(_pchRTFBuffer);
		*pchEnd = chT;
	}
#endif

	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  (unsigned char *)_pchRTFBuffer,
									  _cchBufferOut,	&cchWritten);

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = _cchBufferOut;
		DWORD cbWritten2 = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFBuffer;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten2,
						NULL) && 
						(pbToWrite += cbWritten2,
						(cbLeftToWrite -= cbWritten2)));
	}
#endif

	if (_pes->dwError)
	{
		_ecParseError = ecPutCharFailed; 
		return FALSE;
	}
	AssertSz(cchWritten == _cchBufferOut,
		"CRTFW::FlushBuffer: incomplete write");

	_cchOut		  += _cchBufferOut;
	_pchRTFEnd	  = _pchRTFBuffer;					// Reset buffer
	_cchBufferOut = 0;

	return TRUE;
}

/*
 *	CRTFWrite::PutChar(ch)
 *
 *	@mfunc
 *		Put out the character <p ch>
 *
 *	@rdesc
 *		BOOL	TRUE if successful
 */
BOOL CRTFWrite::PutChar(
	CHAR ch)				//@parm char to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutChar");

	CheckDelimiter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if char won't fit
	if (_cchBufferOut + 1 >= cachBufferMost && !FlushBuffer())
		return FALSE;

	*_pchRTFEnd++ = ch;						// Store character in buffer
	++_cchBufferOut;	
	return TRUE;
}

/*
 *	CRTFWrite::PutPar()
 *
 *	@mfunc
 *		Write \r\n\par for 1.0 emulation and \par\r\n for 2.0 and later
 */
void CRTFWrite::PutPar()
{
	if (_ped->Get10Mode())
		Puts(szPar10, sizeof(szPar10) - 1);
	else
		Puts(szPar, sizeof(szPar) - 1);
}

/*
 *	CRTFWrite::CheckInTable(prtp)
 *
 *	@mfunc
 *		So long as *prtp points at table-row delimiters, write relevant table
 *		row info.
 *
 *	@rdesc
 *		1 if successful
 *		0 if failed to output all relevant stuff
 */
BOOL CRTFWrite::CheckInTable(
	CRchTxtPtr *prtp,			//@parm rtp at start of text to write
	LONG *		pcch)			//@parm Remaining cch to write
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CheckInTable");

	while(*pcch)
	{
		const CParaFormat *pPF = prtp->GetPF();
		if(!pPF->IsTableRowDelimiter())
			break;
		_pPF = pPF;							// Update last _pPF

		CTxtPtr tp(prtp->_rpTX);

		WCHAR ch  = tp.GetChar();
		WCHAR ch1 = tp.NextChar();

		if(ch != ENDFIELD && ch != STARTFIELD || ch1 != CR)
		{
			AssertSz(FALSE,	"CRTFWrite::CheckInTable: illegal table delimeter");
			return FALSE;
		}
		*pcch -= prtp->Move(2);				// Bypass row start or end
		Assert(*pcch >= 0);

		if(ch == ENDFIELD)					// End of row
		{
			AssertSz(_bTableLevel + _bTableLevelIP == pPF->_bTableLevel,
				"CRTFWrite::CheckInTable: invalid table level");
			_bTableLevel--;					// Decrement table nesting level
			_cCell = rgcCell[_bTableLevel];	// Restore _cCell for outer level 
			_iCell = rgiCell[_bTableLevel];	// Restore _iCell for outer level 
			if(_bTableLevel > 0)			// Nested row:
			{								//  write {\*\nesttableprops...}
				if(!Puts(szEndNestRow, sizeof(szEndNestRow) - 1))
					return FALSE;
			}
			else							// Outermost row
			{
				AssertSz(_bTableLevel == 0, "CRTFWrite::CheckInTable: invalid table level");
				if(!_fRowHasNesting)
				{
					if(!PutCtrlWord(CWF_STR, i_row))
						return FALSE;		// \trowd... goes at start of row
					continue;				//  so skip	ahead
				}
			}
		}									
		else								
		{									// Start of row
			_fRowHasNesting = FALSE;
			AssertSz(_bTableLevel < MAXTABLENEST, "CRTFWrite::CheckInTable: Need larger table nesting");
			rgcCell[_bTableLevel] = _cCell;	// Save current _cCell
			rgiCell[_bTableLevel] = _iCell;	// Save current _iCell
			_iCell = 0;						// Start with first cell
			_cCell = pPF->_bTabCount;
			_bTableLevel++;					// Increment table nesting level
			AssertSz(_bTableLevel + _bTableLevelIP == pPF->_bTableLevel,
				"CRTFWrite::CheckInTable: invalid table level");
			if(_bTableLevel > 1)			// Nested table.  
			{
				_fRowHasNesting = TRUE;		// \trowd...
				continue;					//  goes at end of row, so skip
			}								//  ahead
		}									

		LONG  cTab = pPF->_bTabCount;
		DWORD Colors;
		LONG  dul = 0;
		LONG  h	   = pPF->_dxOffset;		// \trgaph N
		LONG  i, j;
		LONG  icrb, icrf;
		LONG  k	   = pPF->_bAlignment;
		LONG  x	   = pPF->_dxStartIndent;	// Possibly shifted \trleft N
		LONG  z	   = pPF->_dyLineSpacing;	// Possible \trrh N
		DWORD uCell, Widths;
		const CELLPARMS *prgCellParms = pPF->GetCellParms();

		if(pPF->_wEffects & PFE_TABLEROWSHIFTED)// Move shifted table row left
			x -= h + 50;
											
		if (!PutCtrlWord(CWF_STR, i_trowd) || // Reset table properties
			pPF->_wEffects & PFE_RTLPARA && !PutCtrlWord(CWF_STR, i_rtlrow) ||
			h && !PutCtrlWord(CWF_VAL, i_trgaph, h) ||
			x && !PutCtrlWord(CWF_VAL, i_trleft, x) ||
			IN_RANGE(PFA_RIGHT, k, PFA_CENTER) &&
			!PutCtrlWord(CWF_STR, k == PFA_RIGHT ? i_trqr : i_trqc) ||
			z && !PutCtrlWord(CWF_VAL, i_trrh, z))
		{
			return FALSE;					// Signal output failed
		}
		PutBorders(TRUE);

		if(_bTableLevel > 0 && h && !printF(szNestedWidthFmt, h, h))
			return FALSE;

		for(i = 0; i < cTab; i++)
		{
			uCell = prgCellParms->uCell;
			dul += GetCellWidth(uCell);
			icrb = prgCellParms->GetColorIndexBackgound();
			icrf = prgCellParms->GetColorIndexForegound();
			if (IsTopCell(uCell) && !PutCtrlWord(CWF_STR, i_clvmgf) ||
				IsLowCell(uCell) && !PutCtrlWord(CWF_STR, i_clvmrg) ||
				GetCellVertAlign(uCell) && !PutCtrlWord(CWF_STR,
				 IsCellVertAlignCenter(uCell) ? i_clvertalc : i_clvertalb)  ||
				IsVerticalCell(uCell) && !PutCtrlWord(CWF_STR, i_cltxtbrlv) ||
				icrf &&
				 !PutCtrlWord(CWF_VAL, i_clcfpat, TranslateColorIndex(icrf, pPF)) ||
				icrb &&
				 !PutCtrlWord(CWF_VAL, i_clcbpat, TranslateColorIndex(icrb, pPF)) ||
				prgCellParms->bShading &&
				 !PutCtrlWord(CWF_VAL, i_clshdng, prgCellParms->bShading*50))
			{
				return FALSE;
			}
			Colors = prgCellParms->dwColors;
			Widths = prgCellParms->dxBrdrWidths;
			prgCellParms++;
			if(Widths)
			{
				for(j = 0; j < 4; j++, Widths >>= 8, Colors >>= 5)
				{
					LONG w = Widths & 0xFF;
					LONG c = TranslateColorIndex(Colors, pPF);
					if(w && (!PutCtrlWord(CWF_STR, rgiszBorders[j + 9]) ||
						!PutCtrlWord(CWF_VAL, i_brdrw, w) ||
						!PutCtrlWord(CWF_STR, i_brdrs) ||
						c && !PutCtrlWord(CWF_VAL, i_brdrcf, c)))
					{
						return FALSE;		// Signal output failed
					}
				}
				CheckDelimiter();
			}
			x += GetCellWidth(uCell);		// Translate from widths to offsets
			if(!PutCtrlWord(CWF_VAL, i_cellx, x))
				return FALSE;				// Signal output failed
		}
		if(ch == ENDFIELD)					// End of row
		{
			if(_bTableLevel)				// Nested row
			{
				if(!Puts(szNestRow, sizeof(szNestRow) - 1))
					return FALSE;
			}
			else if(_fRowHasNesting && !PutCtrlWord(CWF_STR, i_row))
				return FALSE;
		}
	}
	return TRUE;
}

/*
 *	CRTFWrite::PutBorders(fInTable)
 *
 *	@mfunc
 *		If any borders are defined, output their control words
 *
 *	@rdesc
 *		error code
 */
EC CRTFWrite::PutBorders(
	BOOL fInTable)
{
	DWORD Widths = _pPF->_wBorderWidth;
	BOOL  fBox	 = _pPF->_wEffects & PFE_BOX;

	if(Widths || fBox)
	{
		DWORD Colors = _pPF->_dwBorderColor;
		DWORD dwEffects = Colors >> 20;
		LONG  i = 1, iMax = 4;					// NonBox for loop limits
		LONG  j, k;
		DWORD Spaces = _pPF->_wBorderSpace;
		DWORD Styles = _pPF->_wBorders;

		if(fBox)
			i = iMax = 0;						// For box, only write one set

		for( ; i <= iMax; i++, Spaces >>= 4, Styles >>= 4, Widths >>= 4, Colors >>= 5)
		{
			if(!(Widths & 0xF) && !fBox)		// No width, so no border
				continue;

			j = TWIPS_PER_POINT*(Spaces & 0xF);
			k = Colors & 0x1F;
			if (!PutCtrlWord(CWF_STR, rgiszBorders[i + 4*fInTable])		||
				!PutCtrlWord(CWF_STR, rgiszBorderStyles[Styles & 0xF])	||
				!PutCtrlWord(CWF_VAL, i_brdrw, 5*(Widths & 0xF))		||
				k &&
				!PutCtrlWord(CWF_VAL, i_brdrcf, LookupColor(g_Colors[k-1]) + 1) ||
				j && !PutCtrlWord(CWF_VAL, i_brsp, j))
			{
				break;
			}
			for(j = 3; j--; dwEffects >>= 1)		// Output border effects
			{
				if (dwEffects & 1 &&
					!PutCtrlWord(CWF_STR, rgiszBorderEffects[j]))
				{
					break;
				}				
			}
			CheckDelimiter();						// Output a ' '
		}
	}
	return _ecParseError;
}

/*
 *	CRTFWrite::Puts(sz, cb)
 *
 *	@mfunc
 *		Put out the string <p sz>
 *	
 *	@rdesc
 *		BOOL				TRUE if successful
 */
BOOL CRTFWrite::Puts(
	CHAR const * sz,
	LONG cb)		//@parm String to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::Puts");

	if(*sz == '\\' || *sz == '{' || *sz == ' ')
		_fNeedDelimeter = FALSE;

	CheckDelimiter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if string won't fit
	if (_cchBufferOut + cb >= cachBufferMost && !FlushBuffer())
		return FALSE;

	if (cb >= cachBufferMost)			// If buffer still can't handle string,
	{									//   we have to write string directly
		LONG	cbWritten;

#ifdef DEBUG_PASTE
		if (FromTag(tagRTFAsText))
			TraceString(sz);
#endif
		_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
										(LPBYTE) sz, cb, &cbWritten);
		_cchOut += cbWritten;

#if defined(DEBUG) && !defined(NOFULLDEBUG)
		if(_hfileCapture)
		{
			DWORD cbLeftToWrite = cb;
			DWORD cbWritten2 = 0;
			BYTE *pbToWrite = (BYTE *)sz;
		
			while(WriteFile(_hfileCapture,
							pbToWrite,
							cbLeftToWrite,
							&cbWritten2,
							NULL) && 
							(pbToWrite += cbWritten2,
							(cbLeftToWrite -= cbWritten2)));
		}
#endif

		if (_pes->dwError)
		{
			_ecParseError = ecPutCharFailed;
			return FALSE;
		}
		AssertSz(cbWritten == cb,
			"CRTFW::Puts: incomplete write");
	}
	else
	{
		CopyMemory(_pchRTFEnd, sz, cb);		// Put string into buffer for later
		_pchRTFEnd += cb;							//  output
		_cchBufferOut += cb;
	}

	return TRUE;
}

/*
 *	CRTFWrite::PutCtrlWord(iFormat, iCtrl, iValue)
 *
 *	@mfunc
 *		Put control word with rgKeyword[] index <p iCtrl> and value <p iValue>
 *		using format rgszCtrlWordFormat[<p iFormat>]
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@devnote
 *		Sets _fNeedDelimeter to flag that next char output must be a control
 *		word delimeter, i.e., not alphanumeric (see PutChar()).
 */
BOOL CRTFWrite::PutCtrlWord(
	LONG iFormat,			//@parm Format index into rgszCtrlWordFormat
	LONG iCtrl,				//@parm Index into Keyword array
	LONG iValue)			//@parm Control-word parameter value. If missing,
{							//		 0 is assumed
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutCtrlWord");

	BOOL	bRet;
	CHAR	szT[60];
	LONG    cb;

	if(iFormat == CWF_SVAL)					// Use a SHORT to get 16-bit signed
	{										//  values for 32768 thru 65535
		SHORT sValue = iValue;				// Make this endian independent
		cb = sprintf(szT,
			  (char *)rgszCtrlWordFormat[CWF_SVAL],
			  rgKeyword[iCtrl].szKeyword, sValue);
	}
	else
	{
		cb = sprintf(szT,
			  (char *)rgszCtrlWordFormat[iFormat],
			  rgKeyword[iCtrl].szKeyword, iValue);
	}
	_fNeedDelimeter = FALSE;
	bRet = Puts(szT, cb);
	_fNeedDelimeter = TRUE;					// Ensure next char isn't
											//  alphanumeric
	return bRet;
}

/*
 *	CRTFWrite::printF(szFmt, ...)
 *
 *	@mfunc
 *		Provide formatted output
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL _cdecl CRTFWrite::printF(
	CONST CHAR * szFmt,		//@parm Format string for printf()
	...)					//@parmvar Parameter list
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::printF");
	va_list	marker;
	CHAR	szT[60];

	va_start(marker, szFmt);
	int cb = W32->WvsprintfA(60, szT, szFmt, marker);
	va_end(marker);

	return Puts(szT, cb);
}

/*
 *	CRTFWrite::WritePcData(szData, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out the string <p szData> as #PCDATA where any special chars
 *		are protected by leading '\\'.
 *
 *	@rdesc
 *		EC (_ecParseError)
 */
EC CRTFWrite::WritePcData(
	const WCHAR * szData,	//@parm #PCDATA string to write
	INT  nCodePage,			//@parm code page default value CP_ACP
	BOOL fIsDBCS)			//@parm szData is a DBCS string stuffed into Unicode buffer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePcData");

	BYTE		ch;
	BOOL		fMissingCodePage;
	BOOL		fMultiByte;
	const BYTE *pch;
	const char *pchToDBCSDefault = NULL;
	BOOL *		pfUsedDefault = NULL;

	if(IsUTF8)
		nCodePage = CP_UTF8;

	if(!*szData)
		return _ecParseError;

	int	DataSize = wcslen(szData) + 1;
	int BufferSize = DataSize * 3;
	char *pBuffer = (char *)PvAlloc(BufferSize, GMEM_ZEROINIT);
	if(!pBuffer)
		return ecNoMemory;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	// When WCTMB fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char	chToDBCSDefault = 0;
	BOOL		fUsedDefault;

	pchToDBCSDefault = &chToDBCSDefault;
	pfUsedDefault	 = &fUsedDefault;
#endif

	int cchRet = WCTMB(fIsDBCS ? INVALID_CODEPAGE : nCodePage, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
	Assert(cchRet > 0);

	if(!fIsDBCS && fMissingCodePage && nCodePage != CP_ACP)
	{
		// Here, the system could not convert the Unicode string because the
		// code page is not installed on the system.  Fallback to CP_ACP.

		cchRet = WCTMB(CP_ACP, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
		Assert(cchRet > 0);

		nCodePage = CP_ACP;
	}

	AssertSz(!fUsedDefault, "CRTFWrite::WritePcData():  Found character in "
							"control text which cannot be converted from "
							"Unicode");
	if(cchRet <= 0)
	{
		_ecParseError = ecCantUnicode;
		goto CleanUp;
	}

	BufferSize = cchRet;

	fMultiByte = (BufferSize > DataSize) || fIsDBCS || fMissingCodePage;
	pch = (BYTE *)pBuffer;
	ch = *pch;
	
	// If _fNeedDelimeter, may need	to PutChar(' ')
	CheckDelimiter();
									
	while (!_ecParseError && (ch = *pch++))
	{
		if(fMultiByte && *pch && nCodePage != CP_UTF8 && GetTrailBytesCount(ch, nCodePage))
			printF(szEscape2CharFmt, ch, *pch++);					// Output DBC pair
		else
		{
			if(ch == LBRACE || ch == RBRACE || ch == BSLASH)
				printF(szLiteralCharFmt, ch);

			else if(ch < 32 || ch == ';' || ch > 127)
				printF(szEscapeCharFmt, ch);

			else
				PutChar(ch);
		}
	}

CleanUp:
	FreePv(pBuffer); 
	return _ecParseError;
}

/*
 *	CRTFWrite::TranslateColorIndex (icr, pPF)
 *
 *	@mfunc
 *		Returns CRTFWrite::_colors[] index corresponding to backing-store
 *		color index icr
 *
 *	@rdesc
 *		_colors[] index corresponding to backing-store color index icr
 */
LONG CRTFWrite::TranslateColorIndex(
	LONG  icr,				//@parm Color index
	const CParaFormat *pPF)	//@parm CF for two custom colors
{
	icr &= 0x1F;							// Kill possible higher-order bits

	if(!IN_RANGE(1, icr, 18))
		return 0;							// Autocolor

	if(IN_RANGE(1, icr, 16))				// One of standard 16 colors
		return LookupColor(g_Colors[icr - 1]) + 1;

	return LookupColor((icr == 17) ? pPF->_crCustom1 : pPF->_crCustom2) + 1;
}

/*
 *	CRTFWrite::LookupColor(cr)
 *
 *	@mfunc
 *		Return color-table index for color referred to by <p cr>.
 *		If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		LONG			Index into colortable
 *		<lt> 0			on error
 */
LONG CRTFWrite::LookupColor(
	COLORREF cr)		//@parm colorref to look for
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupColor");

	LONG		Count = _colors.Count();
	LONG		iclrf;
	COLORREF *	pclrf;

	for(iclrf = 0; iclrf < Count; iclrf++)		// Look for color
		if(_colors.GetAt(iclrf) == cr)
		 	return iclrf;

	pclrf = _colors.Add(1, NULL);				// If we couldn't find it,
	if(!pclrf)									//  add it to color table
		return -1;
	*pclrf = cr;

	return iclrf;
}

/*
 *	CRTFWrite::LookupFont(pCF)
 *
 *	@mfunc
 *		Returns index into font table for font referred to by
 *		CCharFormat *<p pCF>. If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		SHORT		Index into fonttable
 *		<lt> 0		on error
 */
LONG CRTFWrite::LookupFont(
	CCharFormat const * pCF)	//@parm CCharFormat holding font name
{								//		 to look up
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupFont");

	LONG		Count = _fonts.Count();
	LONG		itf;
	TEXTFONT *	ptf;
	
	for(itf = 0; itf < Count; itf++)
	{														// Look for font
		ptf = _fonts.Elem(itf);
		if (ptf->bPitchAndFamily == pCF->_bPitchAndFamily &&//  of same pitch,
			ptf->iCharRep		 == pCF->_iCharRep &&		//  char rep, and
			ptf->iFont			 == pCF->_iFont)			//  name
		{
			return itf;										// Found it
		}
	}
	ptf = _fonts.Add(1, NULL);								// Didn't find it:
	if(!ptf)												//  add to table
		return -1;

	ptf->bPitchAndFamily = pCF->_bPitchAndFamily;
	ptf->iCharRep		 = pCF->_iCharRep;
	ptf->sCodePage		 = (short)CodePageFromCharRep(pCF->_iCharRep);
	ptf->iFont			 = pCF->_iFont;
	ptf->fNameIsDBCS	 = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;

#if 0
	// Bug1523 - (BradO) I removed this section of code so that a /fN tag is always
	// emitted for the first run of text.  In theory, we should be able to
	// assume that the first run of text would carry the default font.
	// It turns out that when reading RTF, Word doesn't use anything predictable
	// for the font of the first run of text in the absence of an explicit /fN, 
	// thus, we have to explicitly emit a /fN tag for the first run of text.
	if(!Count)												// 0th font is
	{														//  default \deff0
		_CF.bPitchAndFamily	= pCF->bPitchAndFamily;			// Set "previous"
		_CF.bCharSet		= pCF->bCharSet;				//  CF accordingly
		wcscpy(_CF.szFaceName, pCF->szFaceName);
	}
#endif

	return itf;
}

/*
 *	CRTFWrite::BuildTables(&rtp, cch, &fNameIsDBCS)
 *
 *	@mfunc
 *		Build font and color tables for write range of length <p cch>
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFWrite::BuildTables(
	CRchTxtPtr &rtp,	//@parm rtp at cpMin of _prg
	LONG		cch,	//@parm # chars in write range
	BOOL& fNameIsDBCS)	//@parm OUT =TRUE if CFE_FACENAMEISDBCS run in range
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::BuildTables");

	LONG		cchTotal = cch;
	LONG		i;
	CCFRunPtr	rpCF(rtp);
	CPFRunPtr	rpPF(rtp);

	fNameIsDBCS = FALSE;

	while(cch > 0)
	{
		const CCharFormat *pCF = rpCF.GetCF();
		DWORD	dwEffects = pCF->_dwEffects;
		Assert(pCF);

		if(dwEffects & CFE_FACENAMEISDBCS)
			fNameIsDBCS = TRUE;

		if (dwEffects & (CFE_RUNISDBCS | CFE_FACENAMEISDBCS) &&
			_dwFlags & SF_USECODEPAGE && HIWORD(_dwFlags) == CP_UTF8)
		{											// Kill UTF8, since text
			_dwFlags &= 0xFFFF & ~SF_USECODEPAGE;	//  isn't all Unicode
		}

		// Look up character-format *pCF's font and color. If either isn't
		// found, it is added to appropriate table.  Don't lookup color
		// for CCharFormats with auto-color
		if (LookupFont(pCF) < 0 ||
			(!(dwEffects & CFE_AUTOCOLOR) && LookupColor(pCF->_crTextColor) < 0) ||
			(!(dwEffects & CFE_AUTOBACKCOLOR) && LookupColor(pCF->_crBackColor) < 0) ||
			( (dwEffects & CFE_LINK) &&	LookupColor(g_Colors[1]) < 0))
		{
			break;
		}
		if(!rpCF.IsValid())
			break;
		cch -= rpCF.GetCchLeft();
		rpCF.NextRun();
	}

	const CParaFormat *pPF;

	// Now look for bullets; if found, then we need to include
	// the "Symbol" font. Also check on border and shading colors

	cch = cchTotal;
	_symbolFont = 0;

	_bTableLevelIP = rtp.GetPF()->_bTableLevel;
	if(_bTableLevelIP && rtp._rpTX.IsAtTRD(STARTFIELD))
		_bTableLevelIP--;

	while(cch > 0)
	{
		pPF = rpPF.GetPF();
		if(!pPF)
			goto CacheError;
		
		if(pPF->_wNumbering == PFN_BULLET && !_symbolFont)
		{
			CCharFormat CF;

			// Be sure these choices agree with those in CMeasurer::GetCcsBullet()
			// and that LookupFont() doesn't access any other CF members.
			CF._iFont			= IFONT_SYMBOL;
			CF._iCharRep		= SYMBOL_INDEX;
			CF._bPitchAndFamily = FF_DONTCARE;

			// Save Font index for Symbol. Reset it to 0 if LookupFont
			// returns error.
			_symbolFont = LookupFont(&CF);
			_symbolFont = max(_symbolFont, 0);
		}
		
		WORD  Widths = pPF->_wBorderWidth;
		DWORD Colors = pPF->_dwBorderColor & 0xFFFFF;

		while(Widths && Colors)
		{
			i = Colors & 0x1F;
			if(i && (Widths & 0xF))
				LookupColor(g_Colors[i - 1]);

			Widths >>= 4;
			Colors >>= 5;
		}
		
		i = (pPF->_wShadingStyle >> 6) & 31;		// Shading forecolor
		if(i)
			LookupColor(g_Colors[i - 1]);
		i = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if(i)
			LookupColor(g_Colors[i - 1]);

		if(IsHeadingStyle(pPF->_sStyle) && pPF->_sStyle < _nHeadingStyle)
			_nHeadingStyle = pPF->_sStyle;

		if(pPF->IsTableRowDelimiter())
		{
			const CELLPARMS *prgCellParms = pPF->GetCellParms();
			for(LONG cCell = pPF->_bTabCount; cCell--; prgCellParms++)
			{
				for(DWORD dwColors = prgCellParms->dwColors; dwColors; dwColors >>= 5)
					TranslateColorIndex(dwColors, pPF);
			}
		}

		if(!rpPF.IsValid())
			break;
		
		cch -= rpPF.GetCchLeft();
		rpPF.NextRun();
	}	
	return _ecParseError;

CacheError:
	_ecParseError = ecFormatCache;
	return ecFormatCache;					// Access to CF/PF cache failed
}

/*
 *	CRTFWrite::WriteFontTable()
 *
 *	@mfunc
 *		Write out font table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteFontTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteFontTable");

	LONG			Count = _fonts.Count();
	int				itf;
	int				m;
	int				pitch;
	TEXTFONT *		ptf;
	char *			szFamily;
	const WCHAR *	szName;
	WCHAR *			szTaggedName;

	if(!Count || !PutCtrlWord(CWF_GRP, i_fonttbl))	// Start font table group
		goto CleanUp;

	for (itf = 0; itf < Count; itf++)
	{
		ptf = _fonts.Elem(itf);

//		if (ptf->sCodePage)
//			if (! PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage ) )
//				goto CleanUp;

		// Define font family
		m			 = ptf->bPitchAndFamily >> 4;
		szFamily	 = rgKeyword[rgiszFamily[m < CFAMILIES ? m : 0]].szKeyword;
		szName		 = GetFontName(ptf->iFont);
		szTaggedName = NULL;

		// Check to see if this is a tagged font
		if (!ptf->iCharRep ||
			!FindTaggedFont(szName, ptf->iCharRep, &szTaggedName))
		{
			szTaggedName = NULL;
		}

		pitch = ptf->bPitchAndFamily & 0xF;					// Write font
		if (!printF(szBeginFontEntryFmt, itf, szFamily))	//  entry, family,
			goto CleanUp;
		_fNeedDelimeter = TRUE;
		if (pitch && !PutCtrlWord(CWF_VAL, i_fprq, pitch))	//  and pitch
			goto CleanUp;

		if(!ptf->sCodePage && ptf->iCharRep)
			ptf->sCodePage = (short)CodePageFromCharRep(ptf->iCharRep);

		// Write charset. Win32 uses ANSI_CHARSET to mean the default Windows
		// character set, so find out what it really is

		extern BYTE iCharRepANSI;

		if(ptf->iCharRep != DEFAULT_INDEX)
		{
			BYTE iCharRep = ptf->iCharRep;
			BOOL fWroteCharSet = TRUE;

			if(iCharRep == PC437_INDEX || iCharRep >= NCHARSETS)
			{
				fWroteCharSet = FALSE;
				iCharRep = iCharRep >= NCHARSETS ? DEFAULT_INDEX : ANSI_INDEX;
			}
			if(!PutCtrlWord(CWF_VAL, i_fcharset, CharSetFromCharRep(iCharRep)))
				goto CleanUp;

			// Skip \cpgN output if we've already output a \fcharsetN tag.
			// This is to accomodate RE 1.0, which can't handle some \cpgN
			// tags properly. Specifically, when RE 1.0 parses the \cpgN tag
			// it looks up the corresponding charset value. Turns out its
			// codepage/charset table is incomplete so it maps some codepages
			// to charset 0, trouncing the previously read \fcharsetN value.
			if (fWroteCharSet)
				goto WroteCharSet;
		}

		if(ptf->sCodePage && !PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage))
			goto CleanUp;

WroteCharSet:
		if(szTaggedName)							
		{											
			// Have a tagged font:  write out group with real name followed by tagged name
			if(!PutCtrlWord(CWF_AST, i_fname) ||	
				WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||			
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1) ||
				WritePcData(szTaggedName, ptf->sCodePage, ptf->fNameIsDBCS) ||
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
			{
				goto CleanUp;
			}
		}
		else if(WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||
					!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
		// If non-tagged font just write name out
		{
			goto CleanUp;
		}
	}
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);							// End font table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteColorTable()
 *
 *	@mfunc
 *		Write out color table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteColorTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteColorTable");

	LONG		Count = _colors.Count();
	COLORREF	clrf;
	LONG		iclrf;

	if (!Count || !PutCtrlWord(CWF_GRP, i_colortbl)	// Start color table group
		|| !PutChar(';'))							//  with null first entry
	{
		goto CleanUp;
	}

	for(iclrf = 0; iclrf < Count; iclrf++)
	{
		clrf = _colors.GetAt(iclrf);
		if (!printF(szColorEntryFmt,
					GetRValue(clrf), GetGValue(clrf), GetBValue(clrf)))
			goto CleanUp;
	}

	Puts(szEndGroupCRLF,sizeof(szEndGroupCRLF) -1);		// End color table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteCharFormat(prtp, cch, nCodePage)
 *
 *	@mfunc
 *		Write deltas between CCharFormat <p pCF> and the previous CCharFormat
 *		given by _CF, and then set _CF = *<p pCF>.
 *
 *	@rdesc
 *		cch *prtp moved or < 0 if error
 *
 *	@devnote
 *		For optimal output, could write \\plain and use deltas relative to
 *		\\plain if this results in less output (typically only one change
 *		is made when CF changes, so less output results when compared to
 *		previous CF than when compared to \\plain).
 */
LONG CRTFWrite::WriteCharFormat(
	CRchTxtPtr *prtp,		//@parm Ptr to rich-text ptr at current cp
	LONG		cch,		//@parm Remaining cch to write
	LONG		nCodePage)	//@parm CodePage to use in writing hyperlinks
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteCharFormat");

	LONG	cp = prtp->GetCp();
	const CCharFormat * pCF = prtp->GetCF();
	DWORD	dwEffects = pCF->_dwEffects;			// Current effects
	DWORD	dwChanges = _CF._dwEffects;				// Previous effects (will be
	BOOL	fAutoURLDetect = (prtp->GetPed()->GetDetectURL() != 0);//  changed between them)
	BOOL	fFieldClosed = FALSE;
	BOOL	fPrecededByLink = FALSE;
	LONG	i;										
	LONG	iFormat;
	LONG	iValue;									// Control-word value
	LONG	i_sz;									// Temp ctrl string index
	LONG	yOffset = pCF->_yOffset;

	if(cp)
	{
		fPrecededByLink = dwChanges & CFE_LINK;
		if(cp == _prg->GetCp())
		{
			prtp->_rpCF.AdjustBackward();
			fPrecededByLink = prtp->GetCF()->_dwEffects & CFE_LINK;
			prtp->_rpCF.AdjustForward();
		}
	}
	if(_fFieldResult && fPrecededByLink && !(dwEffects & CFE_LINK))
	{												// End of hyperlink
		_fFieldResult = FALSE;
		if (_nFieldFont != -1 && !PutCtrlWord(CWF_VAL, i_f, _nFieldFont))
			return FALSE;
		if(!Puts("}}}", 3))							// Close \fldrslt and \field
			return -1;								// Error return
		fFieldClosed = TRUE;
	}
	BOOL fStartOfLink = !_fFieldResult && !fPrecededByLink && (dwEffects & CFE_LINK);

	if(fStartOfLink)
	{
		if(dwEffects & CFE_LINKPROTECTED)
			dwEffects &= ~CFE_HIDDEN;
		else if(!fAutoURLDetect)					// Only output our links for
			fStartOfLink = FALSE;					//  now (else have to validate
	}												//  client spec'd links)
	
	DWORD UType1 = _CF._bUnderlineType;				// Previous underline type
	if(UType1 >= CUNDERLINES)						// Special underlines are
		dwChanges &= ~CFE_UNDERLINE;				//  not written out, so
													//  claim they're not on
	DWORD UType2 = pCF->_bUnderlineType;			// Current underline type
	if(UType2 >= CUNDERLINES)						// _bUnderlineType for
		dwEffects &= ~CFE_UNDERLINE;				//  specials has non0
													//  high nibble
	COLORREF cr = pCF->_crTextColor;
	BOOL	 fSetLinkAttributes = FALSE;

	if((dwEffects & (CFE_LINK | CFE_LINKPROTECTED)) == CFE_LINK &&
	   !fStartOfLink && !_fFieldResult && fAutoURLDetect)
	{
		fSetLinkAttributes = TRUE;					// Incomplete AutoURL
		dwEffects |= CFE_UNDERLINE;					//  link. Give it blue &
		dwEffects &= ~CFE_AUTOCOLOR;				//  underline attributes
		cr = g_Colors[1];							// Blue
	}
	dwChanges ^= dwEffects;							// Now dwChanges is the
													//  diff between effects
	if (dwChanges & CFE_AUTOCOLOR ||				// Change in autocolor
		cr != _CF._crTextColor)						//  or text color
	{
		iValue = 0;									// Default autocolor
		if(!(dwEffects & CFE_AUTOCOLOR))			// Make that text color
			iValue = LookupColor(cr) + 1;
		if(!PutCtrlWord(CWF_VAL, i_cf, iValue))
			return -1;								// Error return
	}

	if (dwChanges & CFE_AUTOBACKCOLOR ||			// Change in autobackcolor
		pCF->_crBackColor != _CF._crBackColor)		//  or backcolor
	{
		iValue = 0;									// Default autobackcolor
		if(!(dwEffects & CFE_AUTOBACKCOLOR))		// Make that back color
			iValue = LookupColor(pCF->_crBackColor) + 1;
		if(!PutCtrlWord(CWF_VAL, i_highlight, iValue))
			return -1;								// Error return
	}

	if (pCF->_lcid		!= _CF._lcid &&
		!PutCtrlWord(CWF_VAL, i_lang, LANGIDFROMLCID((WORD)pCF->_lcid)) ||
		pCF->_sSpacing	!= _CF._sSpacing &&
		!PutCtrlWord(CWF_VAL, i_expndtw, pCF->_sSpacing)		||
		/* FUTURE (alexgo): This code is incorrect and we don't
		yet handle the Style table.  We may want to support this
		better in a future version.
		pCF->_sStyle	!= _CF._sStyle && pCF->_sStyle > 0  &&
		!PutCtrlWord(CWF_VAL, i_cs, pCF->_sStyle)			|| */
		pCF->_bAnimation	!= _CF._bAnimation &&
		!PutCtrlWord(CWF_VAL, i_animtext, pCF->_bAnimation)	||
		/* FUTURE (alexgo): this code doesn't work yet, as we don't
		output the revision table.  We may want to support this 
		better in a future version
		pCF->_bRevAuthor!= _CF._bRevAuthor &&
		!PutCtrlWord(CWF_VAL, i_revauth, pCF->_bRevAuthor)	|| */
		pCF->_wKerning	!= _CF._wKerning &&
		!PutCtrlWord(CWF_VAL, i_kerning, pCF->_wKerning/10) )
	{
		return -1;									// Error return
	}

	// Handle all underline types.  Special underline types (nonzero high
	// nibble in CCharFormat::_bUnderlineType) are considered to be no
	// underline and have their UType set equal to 0 above and underline
	// effect bits reset to 0.
	if ((dwChanges & CFM_UNDERLINE) ||
		(dwEffects & CFE_UNDERLINE)	&& UType1 != UType2)
	{
		dwChanges &= ~CFE_UNDERLINE;				// Suppress underline
		i = dwEffects & CFE_UNDERLINE ? UType2: 0;	//  action in next for()
		if(!PutCtrlWord(CWF_STR, rgiszUnderlines[i]))					
			return -1;								// Error return
	}
													// This must be before next stuff
	if(dwChanges & (CFM_SUBSCRIPT | CFM_SUPERSCRIPT))//  change in sub/sup status
	{													
	 	i_sz = dwEffects & CFE_SUPERSCRIPT ? i_super
	    	 : dwEffects & CFE_SUBSCRIPT   ? i_sub
	       	 : i_nosupersub;
     	if(!PutCtrlWord(CWF_STR, i_sz))
			return -1;								// Error return
	}

	if(dwChanges & CFE_DELETED)						// Insert deleted at high
	{												//  end of bit string
		dwChanges |= CFE_REVISED << 1;
		if(dwEffects & CFE_DELETED)
			dwEffects |= CFE_REVISED << 1;
	}

	dwChanges &= ((1 << CEFFECTS) - 1) & ~CFE_LINK;	// Output keywords for
	for(i = CEFFECTS;								//  effects that changed
		dwChanges && i--;							// rgszEffects[] contains
		dwChanges >>= 1, dwEffects >>= 1)			//  effect keywords in
	{												//  order max CFE_xx to
		if(dwChanges & 1)							//  min CFE-xx
		{											// Change from last call
			iValue = dwEffects & 1;					// If effect is off, write
			iFormat = iValue ? CWF_STR : CWF_VAL;	//  a 0; else no value
			if(!PutCtrlWord(iFormat, rgiszEffects[i], iValue))
				return -1;							// Error return
		}
	}

	if(yOffset != _CF._yOffset)						// Change in base line 
	{												// position 
		yOffset /= 10;								// Default going to up
		i_sz = i_up;
		iFormat = CWF_VAL;
		if(yOffset < 0)								// Make that down
		{
			i_sz = i_dn;
			yOffset = -yOffset;
		}
		if(!PutCtrlWord(iFormat, i_sz, yOffset))
			return -1;								// Error return
	}

	if (pCF->_bPitchAndFamily != _CF._bPitchAndFamily || // Change in font
		pCF->_iCharRep		  != _CF._iCharRep		  ||
		pCF->_iFont			  != _CF._iFont			  ||
		fFieldClosed)
	{
		iValue = LookupFont(pCF);
		if(iValue < 0 || !PutCtrlWord(CWF_VAL, i_f, iValue))
			return -1;							// Error return

		// RichEdit encodes the current direction in iCharRep, but Word likes
		// to know explicitly, so output the appropriate choice of \rtlch or
		// \ltrch if the direction changes
		BOOL fRTLCharRep = IsRTLCharRep(pCF->_iCharRep);

		if (fRTLCharRep != IsRTLCharRep(_CF._iCharRep) &&
			!PutCtrlWord(CWF_STR, fRTLCharRep ? i_rtlch : i_ltrch))
		{
			return -1;							// Error return
		}

		if (_fFieldResult && pCF->_iCharRep)	// Save non-Ansi font index during FieldResult.
			_nFieldFont = iValue;				// This is to make RE30 hyperlink code happy.
	}
	if(pCF->_yHeight != _CF._yHeight || fFieldClosed)// Change in font size
	{
		iValue = (pCF->_yHeight + (pCF->_yHeight > 0 ? 5 : -5))/10;
		if(!PutCtrlWord(CWF_VAL, i_fs, iValue))
			return -1;							// Error return
	}
	_CF = *pCF;									// Update previous CCharFormat
	if(!fStartOfLink)							// Not start of hyperlink
	{
		if(fSetLinkAttributes)
		{
			_CF._dwEffects	 = dwEffects;
			_CF._crTextColor = cr;
		}
		return 0;								// Normal return
	}

	// Start of hyperlink field: write out starting field info
	BOOL	 fQuadBackSlash = TRUE;				// Defaults for raw URL
	DWORD	 dwMask = CFE_LINK;
	CTxtPtr	 tp(prtp->_rpTX);

	if(pCF->_dwEffects & CFE_LINKPROTECTED)		// \fldinst info should be
	{											//  in backing store
		_CF._dwEffects &= ~CFE_HIDDEN;
		if(tp.FindText(tomForward, FR_DOWN, L"HYPERLINK", 9) == -1)
			return -1;							// Error return: no link
		unsigned ch;
		while((ch = tp.GetChar()) == ' ' || ch == '\"')
			tp.Move(1);
		ch = tp.GetPrevChar();
		if(ch != '\"')							// Not quoted, so don't need
			fQuadBackSlash = FALSE;				//  quad backslashes
		prtp->SetCp(tp.GetCp());				// Advance to start of URL
		dwMask = CFE_HIDDEN;					// URL terminated when text
	}											//  not hidden
	CFormatRunPtr rp(prtp->_rpCF);
	LONG		  cchLink = 0;
	while(_ped->GetCharFormat(rp.GetFormat())->_dwEffects & dwMask)
	{
		cchLink += rp.GetCchLeft();
		if(!rp.NextRun())
			break;
	}
	if(cch < cchLink)							// Link is only partially
		return 0;								//  selected, so don't
												//  write hyperlink field
	if(!Puts(szFieldStart, sizeof(szFieldStart) - 1) ||
	   !Puts(szHyperlink,  sizeof(szHyperlink) - 1))
	{
		return -1;								// Error return
	}

	// Write CFE_LINK field
	prtp->SetCp(tp.GetCp());
	LONG nCodePagePrev = nCodePage;
	while(cchLink > 0)
	{
		LONG cchCF = cchLink;					// For UTF-8, output whole
		if(!IsUTF8)								//  link at once. Else one
		{										//  CF run at a time
			cchCF = prtp->GetCchLeftRunCF();
			cchCF = min(cchCF, cchLink);
			const CCharFormat *pCF = prtp->GetCF();
			nCodePage = CodePageFromCharRep(pCF->_iCharRep);
			if(!nCodePage)
				nCodePage = 1252;
			if(nCodePage == CP_ACP && (_dwFlags & SF_USECODEPAGE))
				nCodePage = HIWORD(_dwFlags);
			if(nCodePage != nCodePagePrev)
			{
				iValue = LookupFont(pCF);
				if(iValue < 0 || !PutCtrlWord(CWF_VAL, i_f, iValue))
					return -1;							// Error return
				nCodePagePrev = nCodePage;
			}
		}
		while(cchCF > 0)
		{
			LONG cchChunk;
			const WCHAR *pch = prtp->_rpTX.GetPch(cchChunk);

			cchChunk = min(cchChunk, cchCF);
			cchChunk = min(cchChunk, cachBufferMost);
			if(WriteText(cchChunk, pch, nCodePage, FALSE, fQuadBackSlash))
				return -1;							// Error return
			prtp->Move(cchChunk);
			cchCF	-= cchChunk;
			cchLink -= cchChunk;
		}
	}
	i = 0;
	LONG cchMove = 0;
	if(dwMask == CFE_HIDDEN)					// Friendly URL
	{
		if(fQuadBackSlash)						// Bypass quote since it's
			i = 1;								//  already output
		cchMove = prtp->GetCp() - cp;			// Tell caller cch that prtp moved
	}
	else
		prtp->SetCp(cp);

	if(!Puts(szFieldResult + i, sizeof(szFieldResult) - i - 1) ||
	   dwMask == CFE_LINK &&					// RichEdit autoURL: use
		(!PutCtrlWord(CWF_STR, i_ul, 0) ||		//  underline & blue
		 !PutCtrlWord(CWF_VAL, i_cf, LookupColor(g_Colors[1]) + 1)))
	{
		return -1;  
	}
	_nFieldFont = -1;
	_fFieldResult = TRUE;						// Signal to look for end of
	return cchMove;								//  URL result field
}

/*
 *	CRTFWrite::WriteParaFormat(prtp, pcch)
 *
 *	@mfunc
 *		Write out attributes specified by the CParaFormat <p pPF> relative
 *		to para defaults (probably produces smaller output than relative to
 *		previous para format and let's you redefine tabs -- no RTF kill
 *		tab command	except \\pard)
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteParaFormat(
	CRchTxtPtr *prtp,	//@parm Ptr to rich-text ptr at current cp
	LONG *		pcch)	//@parm Remaining cch to write
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteParaFormat");

	Assert(_ped);

	//if(!_fRangeHasEOP)					// Don't write para info if
	//	return _ecParseError;				//  range has no EOPs

	if(!CheckInTable(prtp, pcch) || !*pcch)	// If table delimeter para, write
		return _ecParseError;				//  table info and advance prtp
											//  past 2-character delimeter
	const CParaFormat * pPFPrev = _pPF;
	const CParaFormat * pPF = _pPF = prtp->GetPF();
	LONG	c;					  				// Temporary count
	LONG	cTab = pPF->_bTabCount;
	DWORD	dwEffects;
	DWORD	dwRule	= pPF->_bLineSpacingRule;
	LONG	dy		= pPF->_dyLineSpacing;
	LONG	i_t, i, j, k;
	LONG	tabAlign, tabLead, tabPos;
	LONG	lDocDefaultTab = _ped->GetDefaultTab();
	const LONG *prgxTabs = NULL;

	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	AssertSz(cTab >= 0 && cTab <= MAX_TAB_STOPS,
		"CRTFW::WriteParaFormat: illegal cTabCount");

	// EVIL HACK ALERT! - Exchange's IMC keys on the \protect tag when it does
	//	its reply-ticking for mail being sent to Internet recipients.  
	//	Paragraphs following a \pard and containing a \protect tag are 
	//	reply-ticked, so we must ensure that each \pard in a protected range
	//	is followed by a \protect tag.

	if (_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_VAL, i_protect, 0) ||
		!PutCtrlWord(CWF_STR, i_pard) ||			// Reset para attributes
		_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_STR, i_protect))
	{
		goto CleanUp;
	}

	if (_bTableLevel && !PutCtrlWord(CWF_STR, i_intbl) || 
		_bTableLevel > 1 && !PutCtrlWord(CWF_VAL, i_itap, _bTableLevel) ||
		PutBorders(FALSE))
	{
		goto CleanUp;
	}

	if(pPF->_wShadingStyle)
	{
		i = pPF->_wShadingStyle & 15;				// Shading patterns
		j = (pPF->_wShadingStyle >> 6) & 31;		// Shading forecolor
		k = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if (i && i <= CSHADINGSTYLES &&
			!PutCtrlWord(CWF_STR, rgiszShadingStyles[i - 1]) ||
			j && !PutCtrlWord(CWF_VAL, i_cfpat, LookupColor(g_Colors[j-1]) + 1) ||
			k && !PutCtrlWord(CWF_VAL, i_cbpat, LookupColor(g_Colors[k-1]) + 1))
		{
			goto CleanUp;
		}
	}
	if(pPF->_wShadingWeight && !PutCtrlWord(CWF_VAL, i_shading, pPF->_wShadingWeight))
		goto CleanUp;

	// Paragraph numbering
	_fBullet = _fBulletPending = FALSE;
	_nNumber = pPF->UpdateNumber(_nNumber, pPFPrev);

	if(pPF->_wNumbering)							// Write numbering info
	{
		LONG iFont = _symbolFont;
		WORD wStyle = pPF->_wNumberingStyle & 0xF00;

		if(pPF->IsListNumbered())
		{
			const CCharFormat *pCF;
			WCHAR szNumber[CCHMAXNUMTOSTR];

			CTxtPtr		  rpTX(prtp->_rpTX);
			CFormatRunPtr rpCF(prtp->_rpCF);

			rpCF.Move(rpTX.FindEOP(tomForward));
			rpCF.AdjustBackward();
			pCF = _ped->GetCharFormat(rpCF.GetFormat());
			iFont = LookupFont(pCF);
			if(iFont < 0)
			{
				iFont = 0;
				TRACEERRORSZ("CWRTFW::WriteParaFormat: illegal bullet font");
			}
			_nFont = iFont;
			// TODO: make the following smarter, i.e., may need to increment
			// _nNumber instead of resetting it to 1.
			_cpg = CodePageFromCharRep(pCF->_iCharRep);

			i = 0;
			if(pPF->_wNumbering <= tomListNumberAsUCRoman)
				i = pPF->_wNumbering - tomListNumberAsArabic;

			WCHAR ch = (wStyle == PFNS_PARENS || wStyle == PFNS_PAREN) ? ')'
					 : (wStyle == PFNS_PERIOD) ? '.' : 0;
			if(wStyle != PFNS_NONUMBER)			  // Unless number suppressed
			{									  //  write \pntext group
				pPF->NumToStr(szNumber, _nNumber, fRtfWrite);
				if (!printF(szBeginNumberGroup, iFont) ||
					WritePcData(szNumber, _cpg, FALSE) ||	
					!printF(szEndNumberGroup))
				{
					goto CleanUp;
				}
			}
			j = pPF->_wNumberingStyle & 3;
			if (!printF(szBeginNumberFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "body",
						iFont, pPF->_wNumberingTab,
						pPF->_wNumberingStart)				||
				IN_RANGE(1, j, 2) && !PutCtrlWord(CWF_STR,
								j == 1 ? i_pnqc : i_pnqr)	||
				!PutCtrlWord(CWF_STR, rgiszNumberStyle[i])	||
				wStyle == PFNS_PARENS && !printF(szpntxtb)	||
				ch && !printF(szpntxta, ch)					||
				!printF(szEndGroupCRLF))
			{
				goto CleanUp;
			}
		}
		else
		{
			if (!printF(szBulletGroup, iFont) ||
				!printF(szBulletFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "blt",
						iFont, pPF->_wNumberingTab))
			{
				goto CleanUp;
			}
		}
		_fBullet = TRUE;
	}

	dwEffects = pPF->_wEffects & ((1 << CPFEFFECTS) - 1);
	if (_ped->IsBiDi() && !(dwEffects & PFE_RTLPARA) &&
		!PutCtrlWord(CWF_STR, i_ltrpar))		//ltrpar attribute
	{
		goto CleanUp;
	}

	for(c = CPFEFFECTS; dwEffects && c--;		// Output PARAFORMAT2 effects
		dwEffects >>= 1)	
	{
		// rgiszPFEffects[] contains PF effect keywords in the
		//  order max PFE_xx to min PFE-xx

		AssertSz(rgiszPFEffects[2] == i_hyphpar,
			"CRTFWrite::WriteParaFormat(): rgiszPFEffects is out-of-sync with PFE_XXX");
		// \hyphpar has opposite logic to our PFE_DONOTHYPHEN so we emit
		// \hyphpar0 to toggle the property off

		if (dwEffects & 1 &&
			!PutCtrlWord((c == 2) ? CWF_VAL : CWF_STR, rgiszPFEffects[c], 0))
		{
			goto CleanUp;
		}				
	}
	
	// Put out para indents. RTF first indent = -PF.dxOffset
	// RTF left indent = PF.dxStartIndent + PF.dxOffset

	if(IsHeadingStyle(pPF->_sStyle) && !PutCtrlWord(CWF_VAL, i_s, -pPF->_sStyle-1))
		goto CleanUp;
		
	if (pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, i_fi, -pPF->_dxOffset)	||
		pPF->_dxStartIndent + pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_ri : i_li, pPF->_dxStartIndent + pPF->_dxOffset) ||
		pPF->_dxRightIndent	  &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_li : i_ri, pPF->_dxRightIndent)	||
		pPF->_dySpaceBefore	  &&
		!PutCtrlWord(CWF_VAL, i_sb, pPF->_dySpaceBefore) ||
		pPF->_dySpaceAfter	  &&
		!PutCtrlWord(CWF_VAL, i_sa, pPF->_dySpaceAfter))
	{
		goto CleanUp;
	}

	if(dwRule)									// Special line spacing active
	{
		i = 0;									// Default "At Least" or
		if (dwRule == tomLineSpaceExactly)		//  "Exactly" line spacing
			dy = -abs(dy);						// Use negative for "Exactly"

		else if(dwRule == tomLineSpaceMultiple)	// RichEdit uses 20 units/line
		{										// RTF uses 240 units/line
			i++;
			dy *= 12;							
		}

		else if (dwRule != tomLineSpaceAtLeast && dy > 0)
		{
			i++;								// Multiple line spacing
			if (dwRule <= tomLineSpaceDouble)	// 240 units per line
				dy = 120 * (dwRule + 2);
		}
		if (!PutCtrlWord(CWF_VAL, i_sl, dy) ||
			!PutCtrlWord(CWF_VAL, i_slmult, i))
		{
			goto CleanUp;
		}
	}

	if (IN_RANGE(PFA_RIGHT, pPF->_bAlignment, PFA_JUSTIFY) &&
		!PutCtrlWord(CWF_STR, rgiszAlignment[pPF->_bAlignment - 1]))
	{
		goto CleanUp;
	}

	prgxTabs = pPF->GetTabs();
	for (i = 0; i < cTab; i++)
	{
		pPF->GetTab(i, &tabPos, &tabAlign, &tabLead, prgxTabs);
		AssertSz (tabAlign <= tomAlignBar && tabLead <= 5,
			"CRTFWrite::WriteParaFormat: illegal tab leader/alignment");

		i_t = i_tb;								// Default \tb (bar tab)
		if (tabAlign != tomAlignBar)			// It isn't a bar tab
		{
			i_t = i_tx;							// Use \tx for tabPos
			if (tabAlign &&						// Put nonleft alignment
				!PutCtrlWord(CWF_STR, rgiszTabAlign[tabAlign-1]))
			{
				goto CleanUp;
			}
		}
		if (tabLead &&							// Put nonzero tab leader
			!PutCtrlWord(CWF_STR, rgiszTabLead[tabLead-1]) ||
			!PutCtrlWord(CWF_VAL, i_t, tabPos))
		{
			goto CleanUp;
		}
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteText(cwch, lpcwstr, nCodePage, fIsDBCS, fQuadBackSlash)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  The Unicode text string is scanned for characters which
 *		map directly to RTF strings, and the surrounding chunks of Unicode are written
 *		by calling WriteTextChunk.
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFWrite::WriteText(
	LONG	cwch,			//@parm # chars in buffer
	LPCWSTR lpcwstr,		//@parm Pointer to text
	INT		nCodePage,		//@parm Code page to use to convert to DBCS
	BOOL	fIsDBCS,		//@parm If TRUE, lpcwstr is DBCS string stuffed into WSTR
	BOOL	fQuadBackSlash)	//@parm If TRUE, write 4 \ for each \ 
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteText");

	WCHAR *pwchScan;
	WCHAR *pwchStart;

	if(_fBulletPending)
	{
		_fBulletPending = FALSE;
		if(!_nNumber)
		{
			if(!printF(szBulletGroup, _symbolFont))
				goto CleanUp;
		}
		else if(!_pPF->IsNumberSuppressed())
		{
			WCHAR szNumber[CCHMAXNUMTOSTR];
			_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
			if (!printF(szBeginNumberGroup, _nFont) ||
				WritePcData(szNumber, _cpg, FALSE)	||
				!printF(szEndNumberGroup))
			{
				goto CleanUp;
			}
		}
	}

	pwchScan = const_cast<LPWSTR>(lpcwstr);
	pwchStart = pwchScan;
	if(_CF._iCharRep == SYMBOL_INDEX)
	{
		pwchScan += cwch;
		cwch = 0;
	}

	// Step through the Unicode buffer, weeding out characters that have  
	// known translations to RTF strings
	while(cwch-- > 0)
	{
		WCHAR	wch = *pwchScan;

		// If this is a string for which the MultiByteToUnicode conversion
		// failed, the buffer will be filled with ANSI bytes stuffed into
		// wchar's (one per).  In this case, we don't want to map trail bytes
		// to RTF strings.
		if(fIsDBCS && GetTrailBytesCount(wch, nCodePage) && nCodePage != CP_UTF8)
		{
			// If we have more characters in the buffer, then this is the
			// DBC pair.  Otherwise, treat it as single character.
			if(cwch > 0)
			{
				cwch--;
				pwchScan += 2;
				continue;
			}
		}

		// if the char is one for which there is an appropriate RTF string
		// write the preceding chars and output the RTF string

		if(!IN_RANGE(' ', wch, 'Z') &&
		   !IN_RANGE('a', wch, 'z') &&
		   !IN_RANGE(SOFTHYPHEN + 1, wch, ENSPACE - 1) &&
		   wch <= BULLET &&
		   MapsToRTFKeywordW(wch))
		{
			if (pwchScan != pwchStart &&
				WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, 
							   fIsDBCS, fQuadBackSlash))
			{
				goto CleanUp;
			}

			// Map the char(s) to the RTF string
			int cwchUsed = MapToRTFKeyword(pwchScan, cwch, MAPTOKWD_UNICODE, fQuadBackSlash);
			if(_ecParseError != ecNoError)	// Can happen if CELL encountered
				goto CleanUp;				//  for _bTableLevel = 0
											
			cwch -= cwchUsed;
			pwchScan += cwchUsed;

			// Start of next run of unprocessed chars is one past current char
			pwchStart = pwchScan + 1;
		}
		pwchScan++;
	}

	// Write last chunk
	if (pwchScan != pwchStart &&
		WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, fIsDBCS, fQuadBackSlash))
	{
		goto CleanUp;
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteTextChunk(cwch, lpcwstr, nCodePage, fIsDBCS, fQuadBackSlash)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  Unicode chars which cannot be converted to
 *		DBCS chars using the supplied codepage, <p nCodePage>, are written using the
 *		\u RTF tag.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteTextChunk(
	LONG	cwch,			//@parm # chars in buffer
	LPCWSTR lpcwstr,		//@parm Pointer to text
	INT		nCodePage,		//@parm Code page to use to convert to DBCS
	BOOL	fIsDBCS,		//@parm If TRUE, lpcwstr is DBCS string stuffed into WSTR
	BOOL	fQuadBackSlash)	//@parm If TRUE, write 4 \ for each \ 
{
	// FUTURE(BradO):  There is alot of commonality b/t this routine and
	//	WritePcData.  We should re-examine these routines and consider 
	//	combining them into a common routine.

	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteTextChunk");

	BYTE 	b;
	LONG	cbAnsi;
	UINT	ch;
	BOOL 	fMissingCodePage = FALSE;
	BOOL 	fUsedDefault = FALSE;

	// When WideCharToMultiByte fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char chToDBCSDefault = 0;

	// Allocate temp buffer for ANSI text we convert to
	LONG cbAnsiBufferSize = cachBufferMost * (nCodePage == CP_UTF8 ? 3 : MB_LEN_MAX);
	if (!_pbAnsiBuffer)
	{
		// If the code page was CP_UTF8, it will always be CP_UTF8 for this instance
		_pbAnsiBuffer = (BYTE *)PvAlloc(cbAnsiBufferSize, GMEM_FIXED);
		if (!_pbAnsiBuffer)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			return ecNoMemory;
		}
	}

	AssertSz(cwch <= cachBufferMost, "Too many chars for buffer");

	// Convert Unicode (or fIsDBCS) buffer to ANSI 
	if(fIsDBCS)
	{
		// Supply some bogus code page which will force direct conversion
		// from wchar to bytes (losing high byte of wchar).
		// Also, don't want to use default char replacement in this case.
		cbAnsi = WCTMB(INVALID_CODEPAGE, 0, lpcwstr, cwch, 
						(char *)_pbAnsiBuffer, cbAnsiBufferSize,
						NULL, NULL, NULL);
	}
	else
	{
		cbAnsi = WCTMB(nCodePage, 0, lpcwstr, cwch, 
						(char *)_pbAnsiBuffer, cbAnsiBufferSize,
						&chToDBCSDefault, &fUsedDefault,
						&fMissingCodePage);
	}
	Assert(cbAnsi > 0);

	BYTE *pbAnsi = _pbAnsiBuffer;
	BOOL  fMultiByte = (cbAnsi > cwch) || fIsDBCS || fMissingCodePage;

	while (!_ecParseError && cbAnsi-- > 0)
	{
		b = *pbAnsi;
		ch = *lpcwstr;

		// Compare ASCII chars to their Unicode counterparts to check
		// that we're in sync
		AssertSz(cwch <= 0 || ch > 127 || b == ch, 
			"CRTFWrite::WriteText: Unicode and DBCS strings out of sync");

		// If _fNCRForNonASCII, output the \uN tag for all nonASCII chars.
		// This is useful because many Unicode chars that aren't in the
		// target codepage are converted by WideCharToMultiByte() to some
		// "best match char" for the codepage, e.g., alpha (0x3B1) converts
		// to 'a' for cpg 1252.
		//
		// For NT 5, we use WC_NO_BEST_FIT_CHARS, which causes our regular
		// algorithm to output \uN values whenever the system cannot convert
		// a character correctly. This still requires readers that can handle
		// multicodepage RTF, which is problematic for some RTF-to-HTML
		// converters.
		if(MapsToRTFKeywordA(b))
		{
			int cchUsed = MapToRTFKeyword(pbAnsi, cbAnsi, MAPTOKWD_ANSI, fQuadBackSlash);
			cbAnsi -= cchUsed;
			pbAnsi += cchUsed;
			lpcwstr += cchUsed;
			cwch -= cchUsed;
		}
		else if(nCodePage == CP_UTF8)
		{
			PutChar(b);								// Output 1st byte in any
			if(b >= 0xC0)							//  case. At least 2-byte
			{										// At least 2-byte lead
				pbAnsi++;							//  byte, so output a
				Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
				cbAnsi--;							//  trail byte
				PutChar(*pbAnsi);
				if(b >= 0xE0)						// 3-byte lead byte, so
				{									//  output another trail
					pbAnsi++;						//  byte
					Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
					cbAnsi--;
					PutChar(*pbAnsi);
				}
			}
		}
		else
		{
			LONG cbChar = fMultiByte && cbAnsi && GetTrailBytesCount(b, nCodePage)
				   ? 2 : 1;
			if(ch >= 0x80 && !fIsDBCS && _fNCRForNonASCII && nCodePage != CP_SYMBOL)
			{									// Output /uN for nonASCII
				if(cbChar != _cbCharLast)
				{
					_cbCharLast = cbChar;		// cb to follow /uN
					if(!PutCtrlWord(CWF_VAL, i_uc, cbChar))
						return _ecParseError;
				}
				if(!PutCtrlWord(CWF_SVAL, i_u, ch))
					return _ecParseError;
				Assert(chToDBCSDefault != '?');
				if(fUsedDefault)				// Don't output another /uN
				{								//  below
					b = '?';
					_fNeedDelimeter = FALSE;
				}
			}
			if(cbChar == 2)
			{
				pbAnsi++;						// Output DBCS pair
				cbAnsi--;
				if(fIsDBCS)
				{
					lpcwstr++;
					cwch--;
				}
				printF(szEscape2CharFmt, b, *pbAnsi);
			}
			else 
			{
				if(b == chToDBCSDefault && fUsedDefault)
				{
					// WideCharToMultiByte() couldn't complete a conversion so it
					// used the default char we provided (0) used as a placeholder.
					// In this case we want to output the original Unicode char.
					if(!PutCtrlWord(CWF_SVAL, i_u, (cwch > 0 ? ch : TEXT('?'))))
						return _ecParseError;

					_fNeedDelimeter = FALSE;
					if(!PutChar('?'))
						return _ecParseError;
				}
				else if(!IN_RANGE(32, b, 127))
					printF(szEscapeCharFmt, b);

				else
					PutChar(b);
 			}
		}
		pbAnsi++;
		lpcwstr++;
		cwch--;
	}
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteInfo()
 *
 *	@mfunc
 *		Write out East Asia specific data.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteInfo()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteInfo");

	// TODO(BradO):  Ultimately it would be nice to set some kind of
	//	fRTFFE bit to determine whether to write \info stuff.  For now,
	//	we rely on the fact that lchars and fchars info actually exists
	//	to determine whether to write out the \info group.

	if(_fRangeHasEOP && !printF(RTF_GENINFO))
		return _ecParseError;

#ifdef UNDER_WORK
	if (!(_dwFlags & fRTFFE)	||					// Start doc area
		!PutCtrlWord(CWF_GRP, i_info)	||
		!printF("{\\horzdoc}"))
			goto CleanUp;

	// Write out punctuation character info

	CHAR	sz[PUNCT_MAX];
	if(UsVGetPunct(_ped->lpPunctObj, PC_FOLLOWING, sz, sizeof(sz))
					> PUNCT_MAX - 2)
		goto CleanUp;

	if(!Puts("{\\*\\fchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;
	
	if(UsVGetPunct(ped->lpPunctObj, PC_LEADING, sz, sizeof(sz)) > PUNCT_MAX+2)
		goto CleanUp;

	if(!Puts("{\\*\\lchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;

	Puts(szEndGroupCRLF);							// End info group

#endif

	LPSTR lpstrLeading = NULL;
	LPSTR lpstrFollowing = NULL;

	// If either succeeds (but evaluate both)
	if(((_ped->GetLeadingPunct(&lpstrLeading) == NOERROR) +
		(_ped->GetFollowingPunct(&lpstrFollowing) == NOERROR)) &&
		(lpstrLeading || lpstrFollowing))
	{
		if (!PutCtrlWord(CWF_GRP, i_info) ||
			!Puts(szHorzdocGroup, sizeof(szHorzdocGroup) - 1))
		{
			goto CleanUp;
		}
		if (lpstrLeading &&
			(!PutCtrlWord(CWF_AST, i_lchars) || 
			 !Puts(lpstrLeading, strlen(lpstrLeading)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		if (lpstrFollowing &&
			(!PutCtrlWord(CWF_AST, i_fchars) || 
			 !Puts(lpstrFollowing, strlen(lpstrFollowing)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);	// End info group
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteRtf()
 *
 *	@mfunc
 *		Write range _prg to output stream _pes.
 *
 *	@rdesc
 *		LONG	Number of chars inserted into text; 0 means none were
 *				inserted, OR an error occurred.
 */
LONG CRTFWrite::WriteRtf()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtf");

	LONG			cch, cchBuffer;
	LONG			cchCF, cchPF;
	LONG			cchT;
	LONG			cpMin, cpMost;
	DWORD			dwFlagsSave = _dwFlags;
	BOOL			fBackground;
	BOOL 			fOutputEndGroup;
	LONG			i, j;
	LONG			lDocDefaultTab;
	WCHAR *			pch;
	WCHAR *			pchBuffer;
	CTxtEdit *		ped = _ped;
	CDocInfo *		pDocInfo = ped->GetDocInfo();
	CRchTxtPtr		rtp(*_prg);
	WORD			wCodePage = CP_ACP;

	AssertSz(_prg && _pes, "CRTFW::WriteRtf: improper initialization");

	cch = _prg->GetRange(cpMin, cpMost);	// Get rtp = cpMin, cch > 0
	rtp.SetCp(cpMin);

	_fRangeHasEOP = _prg->fHasEOP();		// Maintained for Selection
	if(!_prg->IsSel())						// Validate range for RTF
	{										//  writing
		CTxtPtr tp(rtp._rpTX);

		_fRangeHasEOP = tp.IsAtEOP();
		if(!_fRangeHasEOP && tp.FindEOP(cch, NULL))
			_fRangeHasEOP = TRUE;
	}

	// Allocate buffers for text we pick up and for RTF output
	pchBuffer = (WCHAR *) PvAlloc(cachBufferMost * (sizeof(WCHAR) + 1) + 1,
								 GMEM_FIXED);	// Final 1 is for debug
	if(!pchBuffer)
	{
		fOutputEndGroup = FALSE;
		goto RAMError;
	}
	_pchRTFBuffer = (CHAR *)(pchBuffer + cachBufferMost);

	_pchRTFEnd = _pchRTFBuffer;				// Initialize RTF buffer ptr
	_cchBufferOut = 0;						//  and character count
	_cchOut = 0;							//  and character output

	// Determine the \ansicpgN value
	if(!pDocInfo)
	{
		fOutputEndGroup = TRUE;
		goto RAMError;
	}
	fBackground = !(_dwFlags & SFF_SELECTION) && pDocInfo->_nFillType != -1;

	while(rtp._rpTX.IsAtTRD(ENDFIELD))		// Bypass any row-end delimiters
		cch -= rtp.AdvanceCRLF();		

	BOOL fNameIsDBCS;
	if(BuildTables(rtp, cch, fNameIsDBCS))
		goto CleanUp;

	wCodePage = (_dwFlags & SF_USECODEPAGE)
			  ? HIWORD(_dwFlags) : pDocInfo->_wCpg;

	if (fNameIsDBCS && wCodePage == CP_UTF8)
	{
		// Cannot have UTF8 if we have any run containing broken DBCS.
		// Default back to regular rtf
		wCodePage = pDocInfo->_wCpg;
		_dwFlags &= ~SF_USECODEPAGE;
	}

	// Start RTF with \rtfN, \urtfN, or \pwdN group
	i =	(_dwFlags & SF_RTFVAL) >> 16;
	if (!PutCtrlWord(CWF_GRV,
			(wCodePage == CP_UTF8) ? i_urtf :
			(_dwFlags & SFF_PWD)   ? i_pwd  : i_rtf, i + 1) ||
		ped->IsBiDi() && !Puts("\\fbidis", 7) ||
		!PutCtrlWord(CWF_STR, i_ansi)) 
	{
		goto CleanUpNoEndGroup;
	}

	if (wCodePage != tomInvalidCpg && wCodePage != CP_ACP &&
		!PutCtrlWord(CWF_VAL, i_ansicpg, wCodePage == CP_UTF8 ? pDocInfo->_wCpg : wCodePage))
	{
		goto CleanUp;
	}

	if(!printF(szDefaultFont))
		goto CleanUp;

	LCID	lcid;
	LANGID	langid;

	if (ped->GetDefaultLCID(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflang, langid))
	{
		goto CleanUp;
	}

	if (ped->GetDefaultLCIDFE(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflangfe, langid))
	{
		goto CleanUp;
	}

	LONG	lDocType;
	ped->GetDocumentType(&lDocType);
	if (lDocType && ped->IsBiDi() &&
		!PutCtrlWord(CWF_STR, lDocType == DT_RTLDOC ? i_rtldoc : i_ltrdoc))
	{
		goto CleanUp;
	}

	lDocDefaultTab = pDocInfo->_dwDefaultTabStop;
	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	if (lDocDefaultTab != 720 && !PutCtrlWord(CWF_VAL, i_deftab, lDocDefaultTab) ||
		WriteFontTable() || WriteColorTable())
	{
		goto CleanUp;
	}

	if(_nHeadingStyle)
	{
		if(!PutCtrlWord(CWF_GRP, i_stylesheet) || !printF(szNormalStyle))
			goto CleanUp;
		
		for(i = 1; i < -_nHeadingStyle; i++)
		{
			if(!printF(szHeadingStyle, i, i))
				goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1); // End font table group
	}
	
	LRESULT lres;
	ped->GetViewKind(&lres);
	if(fBackground)
		lres = 5;							// Word Online view
	ped->GetViewScale(&j);
	if (WriteInfo() ||
		_fRangeHasEOP && !PutCtrlWord(CWF_VAL, i_viewkind, lres) ||
		(_dwFlags & SFF_PERSISTVIEWSCALE) && j != 100 &&
		!PutCtrlWord(CWF_VAL, i_viewscale, j))
	{
		goto CleanUp;
	}

	// Write Unicode character byte count for use by entire document (since
	// we don't use \plain's and since \ucN behaves as a char formatting tag,
	// we're safe outputting it only once).
	if(!PutCtrlWord(CWF_VAL, i_uc, iUnicodeCChDefault))
		goto CleanUp;

	// Write STextFlow for @font or textflow isn't tflowES
	if (ped->_fUseAtFont || ped->_pdp->GetTflow() != tflowES)
	{

#if tflowES != 0 || tflowSW != 1 || tflowWN != 2 || tflowNE != 3
#error "Wrong tflow values assumed"
#endif
		//							ES SW WN NE
		static BYTE rgbTextFlow[] = {0, 3, 8, 2,	// Normal fonts
									 4, 1, 7, 6};	// @ fonts
		j = ped->_pdp->GetTflow();
		if(ped->_fUseAtFont)
			j += 4;

		j = rgbTextFlow[j];
		if (j == 1 && !PutCtrlWord(CWF_STR, i_vertdoc))
			goto CleanUp;

		if(!PutCtrlWord(CWF_VAL, i_stextflow, j))
			goto CleanUp;
	}

	if(fBackground && WriteBackgroundInfo(pDocInfo))
		goto CleanUp;

	while (cch > 0)
	{
		// Get next run of chars with same para formatting
		if(WriteParaFormat(&rtp, &cch))		// Write paragraph formatting
			goto CleanUp;

		cchPF = rtp.GetCchLeftRunPF();
		cchPF = min(cchPF, cch);

		AssertSz(!cch || cchPF, "CRTFW::WriteRtf: Empty para format run!");

		while (cchPF > 0)
		{
			// Get next run of characters with same char formatting
			cchCF = rtp.GetCchLeftRunCF();
			cchCF = min(cchCF, cchPF);
			AssertSz(cchCF, "CRTFW::WriteRtf: Empty char format run!");

			const CCharFormat *	pCF = rtp.GetCF();
			INT nCodePage = CP_UTF8;
			if(!IsUTF8)
			{
				nCodePage = CodePageFromCharRep(pCF->_iCharRep);
				if(!nCodePage)
					nCodePage = 1252;
				if(nCodePage == CP_ACP && (_dwFlags & SF_USECODEPAGE))
					nCodePage = HIWORD(_dwFlags);
			}
			LONG cchMove = WriteCharFormat(&rtp, cch, nCodePage);// Write char attributes
			if(cchMove < 0)						// Error
				goto CleanUp;

			cch -= cchMove;						// In case writing friendly
			cchPF -= cchMove;					//  URL, cch > 0
			cchCF -= cchMove;

			while (cchCF > 0)
			{
				cchBuffer = min(cachBufferMost, cchCF);
				// FUTURE: since this routine only reads the backing store
				// and GetText only reads it, we can avoid allocating the
				// buffer and use CTxtPtr::GetPch() directly as in
				// CMeasurer::Measure()
				cchBuffer = rtp._rpTX.GetText(cchBuffer, pchBuffer);
				pch  = pchBuffer;
				cchT = cchBuffer;  
				if(cchT > 0)					
				{								
					WCHAR * pchWork = pch;
					LONG    cchWork = cchT;
					LONG	cchTWork;
					UINT	ch = 0;
					LONG	cp = rtp.GetCp();

					while (cchWork >0)
					{
						cchT = cchWork;
						pch = pchWork;
						while (cchWork > 0)		// Search for objects
						{
							ch = *pchWork++;
							if(ch >= WCH_EMBEDDING) 
								break;			// Will write out object
							cchWork--;			//  or ignore char
						}

						cchTWork = cchT - cchWork;
						if(cchTWork)			// Write text before object
						{							
							if(WriteText(cchTWork, pch, nCodePage, 
									(pCF->_dwEffects & CFE_RUNISDBCS), FALSE))
							{
								goto CleanUp;
							}
						}
						cp += cchTWork;
						if(cchWork > 0)			// There is an object or ignorable
						{
							if(ch == WCH_EMBEDDING)
							{
								if(_fIncludeObjects)
								{
									COleObject *pobj;

									Assert(ped->GetObjectMgr());

									pobj = ped->GetObjectMgr()->GetObjectFromCp(cp);
									if(!pobj)
										goto CleanUp;

									// First, commit the object to make sure the pres. 
									// caches, etc. are up-to-date.  Don't worry 
									// about errors here.
									pobj->SafeSaveObject();
									WriteObject(cp, pobj);
								}

								else if(!Puts(szObjPosHolder, sizeof(szObjPosHolder) - 1))
									goto CleanUp;
							}
							cp++;
							cchWork--;
						}
					}
				}
				rtp.Move(cchBuffer);
				cchCF	-= cchBuffer;
				cchPF	-= cchBuffer;
				cch		-= cchBuffer;
			}
		}
	}
	if(_dwFlags & SFF_WRITEXTRAPAR)
		PutPar();

CleanUp:
	if (_fFieldResult)
	{
		if (_nFieldFont != -1 && !PutCtrlWord(CWF_VAL, i_f, _nFieldFont))
			return FALSE;

		_fFieldResult = FALSE;
		if (!Puts("}}}", 3))
			return FALSE;
	}

	while(_bTableLevel > 0)	// Finish off incomplete row
	{
		AssertSz(!_prg->IsSel(), "CRTFWrite::WriteRtf: invalid selection");

		for(; _iCell < _cCell; _iCell++)
			PutCtrlWord(CWF_STR, _bTableLevel > 1 ? i_nestcell : i_cell);
		PutCtrlWord(CWF_STR, _bTableLevel > 1 ? i_nestrow : i_row);
		_bTableLevel--;
		_iCell = rgiCell[_bTableLevel];
		_cCell = rgcCell[_bTableLevel];
	}

	// End RTF group
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF));
	FlushBuffer();

CleanUpNoEndGroup:
	FreePv(pchBuffer);

	if(_ecParseError != ecNoError || dwFlagsSave != _dwFlags)
	{
		if(_ecParseError == ecNoError)
			_ecParseError = ecUTF8NotUsed;

		TRACEERRSZSC("CRTFW::WriteRtf()", _ecParseError);
		Tracef(TRCSEVERR, "Writing error: %s", rgszParseError[_ecParseError]);
		
		if(!_pes->dwError || ped->Get10Mode())			// Make error code OLE-like
			_pes->dwError = -abs(_ecParseError);
		_cchOut = 0;
	}
	return _cchOut;

RAMError:
	ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;

	if(fOutputEndGroup)
		goto CleanUp;

	goto CleanUpNoEndGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\select.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	SELECT.CPP -- Implement the CTxtSelection class |
 *	
 *		This module implements the internal CTxtSelection methods.
 *		See select2.c and range2.c for the ITextSelection methods
 *
 *	Authors: <nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent <nl>
 *
 *	@devnote
 *		The selection UI is one of the more intricate parts of an editor.
 *		One common area of confusion is the "ambiguous cp", that is,
 *		a cp at the beginning of one line, which is also the cp at the
 *		end of the previous line.  We control which location to use by
 *		the _fCaretNotAtBOL flag.  Specifically, the caret is OK at the
 *		beginning of the line (BOL) (_fCaretNotAtBOL = FALSE) except in
 *		three cases:
 *
 *			1) the user clicked at or past the end of a wrapped line,
 *			2) the user typed End key on a wrapped line,
 *			3) the active end of a nondegenerate selection is at the EOL.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_disp.h"
#include "_measure.h"
#include "_font.h"
#include "_rtfconv.h"
#include "_antievt.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

ASSERTDATA


// ======================= Invariant stuff and Constructors ======================================================

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtSelection::Invariant() const
{
	// FUTURE: maybe add some thoughtful asserts...

	static LONG	numTests = 0;
	numTests++;				// how many times we've been called
	
	if(IsInOutlineView() && _cch)
	{
		LONG cpMin, cpMost;					
		GetRange(cpMin, cpMost);

		CTxtPtr tp(_rpTX);					// Scan range for an EOP
		tp.SetCp(cpMin);

		// _fSelHasEop flag may be off when last cr selected so don't
		// assert in that case.
		if (GetPed()->GetAdjustedTextLength() != cpMost)
		{
			AssertSz((unsigned)(tp.FindEOP(cpMost - cpMin) != 0) == _fSelHasEOP,
				"Incorrect CTxtSelection::_fSelHasEOP");
		}
	}

	return CTxtRange::Invariant();
}
#endif

CTxtSelection::CTxtSelection(CDisplay * const pdp) :
				CTxtRange(pdp->GetPed())
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CTxtSelection");

	Assert(pdp);
	Assert(GetPed());

	_fSel	   = TRUE;					// This range is a selection
	_pdp	   = pdp;
	_hbmpCaret = NULL;
	_fEOP      = FALSE;					// Haven't typed a CR

	// Set show-selection flag to inverse of hide-selection flag in ped
	_fShowSelection = !GetPed()->fHideSelection();

	// When we are initialized we don't have a selection therefore,
	// we do want to show caret.
	_fShowCaret = TRUE;
}	

void SelectionNull(CTxtEdit *ped)
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "SelectionNull");

	if(ped)
		ped->SetSelectionToNull();
}
										

CTxtSelection::~CTxtSelection()
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::~CTxtSelection");

	DeleteCaretBitmap(FALSE);

	// Notify edit object that we are gone (if there's a nonNULL ped, i.e.,
	// if the selection isn't a zombie).
	SelectionNull(GetPed());
}

////////////////////////////////  Assignments  /////////////////////////////////////////


CRchTxtPtr& CTxtSelection::operator =(const CRchTxtPtr& rtp)
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rtp);
}

CTxtRange& CTxtSelection::operator =(const CTxtRange &rg)
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rg);
}

//////////////////////  Update caret & selection mechanism  ///////////////////////////////

/*
 *	CTxtSelection::Update(fScrollIntoView)
 *
 *	@mfunc
 *		Update selection and/or caret on screen. As a side
 *		effect, this methods ends deferring updates.
 *
 *	@rdesc
 *		TRUE if success, FALSE otherwise
 */
BOOL CTxtSelection::Update (
	BOOL fScrollIntoView)		//@parm TRUE if should scroll caret into view
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Update");

	LONG cch;
	LONG cchSave = _cch;
	LONG cchText = GetTextLength();
	LONG cp, cpMin, cpMost;
	LONG cpSave = GetCp();
	BOOL fMoveBack = _fMoveBack;
	CTxtEdit *ped = GetPed();

	_fUpdatedFromCp0 = FALSE;
	if(!ped->fInplaceActive() || ped->IsStreaming())
	{
		// Nothing to do while inactive or streaming in text or RTF data
		return TRUE;
	}

	if(!_cch)							// Update _cpAnchor, etc.
	{
		while(GetPF()->IsTableRowDelimiter() && _rpTX.GetChar() != ENDFIELD)
		{
			if(_fMoveBack)
			{
				if(!BackupCRLF(CSC_NORMAL, FALSE))	// Don't leave at table row start
					_fMoveBack = FALSE;
			}
			else
				AdvanceCRLF(CSC_NORMAL, FALSE);	// Bypass table row start
		}
		UpdateForAutoWord();
	}
	if(_cch && (_nSelExpandLevel || _fSelExpandCell))
	{
		BOOL fInTable = GetPF()->InTable();
		if(!fInTable)
		{
			CFormatRunPtr rp(_rpPF);
			rp.Move(-_cch);
			fInTable = (ped->GetParaFormat(rp.GetFormat()))->InTable();
		}
		if(fInTable)
		{
			if(_nSelExpandLevel)
				FindRow(&cpMin, &cpMost, _nSelExpandLevel);
			else
				FindCell(&cpMin, &cpMost);
			Set(cpMost, cpMost - cpMin);
			if(!_fSelExpandCell)
				_nSelExpandLevel = 0;
		}
	}
	if(GetPF()->InTable())						// Don't leave IP in cell
	{											//  that's vertically merged
		if(fMoveBack)							//  with cell above
		{
			while(GetPrevChar() == NOTACHAR)
			{									// Move before NOTACHAR and
				Move(-2, _cch);					//  either CELL or TRD's CR 					
				if(CRchTxtPtr::GetChar() != CELL)
				{								
					Assert(GetPrevChar() == STARTFIELD);
					Move(-3, _cch);				// Move before TRD START and
					break;						//  preceding TRD END
				}
			}
		}
		else
			while(CRchTxtPtr::GetChar() == NOTACHAR)
				Move(2, _cch);					// Move past NOTACHAR CELL
	}
				
	if(IsInOutlineView() && !ped->IsMouseDown() && _rpPF.IsValid())
	{
		CPFRunPtr rp(*this);

		cp = GetCp();
		GetRange(cpMin, cpMost);
		if(_cch && (cpMin || cpMost < cchText))
		{
			LONG *pcpMin  = &cpMin;
			LONG *pcpMost = &cpMost;

			// If selection contains an EOP, expand to para boundaries
			if(_fSelHasEOP)
			{
				if(_fMoveBack ^ (_cch < 0))	// Decreasing selection
				{							//  size: move active end
					if(_fMoveBack)			
						pcpMost = NULL;		//  to StartOf para
					else
						pcpMin = NULL;		//  to EndOf para				
				}
				Expander(tomParagraph, TRUE, NULL, pcpMin, pcpMost);
			}

			LONG cpMinSave  = cpMin;		// Save initial cp's to see if		
			LONG cpMostSave = cpMost;		//  we need to Set() below

			// The following handles selection expansion correctly, but
			// not compression; need logic like that preceding Expander()
			rp.Move(cpMin - cp);			// Start at cpMin
			if(rp.IsCollapsed())
				cpMin += rp.FindExpandedBackward();
			rp.AdjustForward();

			BOOL fCpMinCollapsed = rp.IsCollapsed();
			rp.Move(cpMost - cpMin);		// Go to cpMost
			Assert(cpMost == rp.CalculateCp());
			if(rp.IsCollapsed())
				cpMost += rp.FindExpandedForward();

			if(fCpMinCollapsed || rp.IsCollapsed() && cpMost < cchText)
			{
				if(rp.IsCollapsed())
				{
					rp.Move(cpMin - cpMost);
					rp.AdjustForward();
					cpMost = cpMin;
				}
				else
					cpMin = cpMost;
			}							
			if(cpMin != cpMinSave || cpMost != cpMostSave)
				Set(cpMost, cpMost - cpMin);
		}
		if(!_cch && rp.IsCollapsed())		// Note: above may have collapsed
		{									//  selection...
			cch = fMoveBack ? rp.FindExpandedBackward() : 0;
			if(rp.IsCollapsed())
				cch = rp.FindExpanded();

			Move(cch, FALSE);
			rp.AdjustForward();
			if(cch <= 0 && rp.IsCollapsed() && _rpTX.IsAfterEOP())
				BackupCRLF(CSC_NORMAL, FALSE);
			_fCaretNotAtBOL = FALSE;
		}
	}

	// Don't let active end be in hidden text, unless selection is
	// nondegenerate with active end at cp 0 and other end unhidden.
	CCFRunPtr rp(*this);

	cp = GetCp();
	GetRange(cpMin, cpMost);
	if(_cch && (cpMin || cpMost < cchText))
	{
		rp.Move(cpMin - cp);				// Start at cpMin
		BOOL fHidden = cpMin && rp.IsInHidden();
		rp.Move(cpMost - cpMin);			// Go to cpMost

		if(fHidden)							// It's hidden, so collapse
			Collapser(tomEnd);				//  selection at End for treatment

		else if(rp.IsInHidden() &&			// cpMin OK, how about cpMost?
			cpMost < cchText)
		{									// Check both sides of edge
			Collapser(tomEnd);				//  collapse selection at end
		}								
	}
	if(!_cch && rp.IsInHidden())			// Note: above may have collapsed
	{										//  selection...
		cch = fMoveBack ? rp.FindUnhiddenBackward() : 0;
		if(!fMoveBack || rp.IsHidden())
			cch = rp.FindUnhidden();

		Move(cch, FALSE);
		_fCaretNotAtBOL = FALSE;
	}
	if((cchSave ^ _cch) < 0)				// Don't change active end
		FlipRange();

	if(!_cch && cchSave)					// Fixups changed nondegenerate
	{										//  selection to IP. Update
		Update_iFormat(-1);					//  _iFormat and _fCaretNotAtBOL
		_fCaretNotAtBOL = FALSE;
	}

	if(!_cch && _fCaretNotAtBOL				// For IP case, make sure it is on new line if
		&& _rpTX.IsAfterEOP())				//	IP after EOP
		_fCaretNotAtBOL = FALSE;

	_TEST_INVARIANT_

	CheckTableIP(TRUE);						// If IP bet TRED & CELL, ensure
											//  CELL displayed on own line
	// Recalc up to active end (caret)
	if(!_pdp->WaitForRecalc(GetCp(), -1))	// Line recalc failure
		Set(0, 0);							// Put caret at start of text 

	ShowCaret(ped->_fFocus);
	UpdateCaret(fScrollIntoView);			// Update Caret position, possibly
											//  scrolling it into view
	ped->TxShowCaret(FALSE);
	UpdateSelection();						// Show new selection
	ped->TxShowCaret(TRUE);

	if(!cpSave && GetCp() && !_cch)			// If insertion point & moved away
		_fUpdatedFromCp0 = TRUE;			//  from cp = 0, set flag so that
											//  nonUI inserts can go back to 0
	return TRUE;
}

/*
 *	CTxtSelection::CheckSynchCharSet(dwCharFlags)
 *
 *	@mfunc
 *		Check if the current keyboard matches the current font's charset;
 *		if not, call CheckChangeFont to find the right font
 *
 *	@rdesc
 *		Current keyboard codepage
 */
UINT CTxtSelection::CheckSynchCharSet(
	QWORD qwCharFlags)
{	
	CTxtEdit *ped	   = GetPed();
	LONG	  iFormat  = GetiFormat();
	const CCharFormat *pCF = ped->GetCharFormat(iFormat);
	BYTE	  iCharRep = pCF->_iCharRep;
	HKL		  hkl	   = GetKeyboardLayout(0xFFFFFFFF);	// Force refresh
	WORD	  wlidKbd  = LOWORD(hkl);
	BYTE	  iCharRepKbd = CharRepFromLID(wlidKbd);
	UINT	  uCodePageKbd = CodePageFromCharRep(iCharRepKbd);

	// If current font is not set correctly,
	// change to a font preferred by current keyboard.

	// To summarize the logic below:
	//		Check that lcidKbd is valid
	//		Check that current charset differs from current keyboard
	//		Check that current keyboard is legit in a single codepage control
	//		Check that current charset isn't SYMBOL, DEFAULT, or OEM
	if (wlidKbd && iCharRep != iCharRepKbd && 
		(!ped->_fSingleCodePage || iCharRepKbd == ANSI_INDEX ||
		 uCodePageKbd == (ped->_pDocInfo ?
								ped->_pDocInfo->_wCpg :
								GetSystemDefaultCodePage())) && 
		iCharRep != SYMBOL_INDEX &&	iCharRep != OEM_INDEX &&
		!(IsFECharRep(iCharRepKbd) && iCharRep == ANSI_INDEX))
	{
		CheckChangeFont(hkl, iCharRepKbd, iFormat, qwCharFlags);
	}
	return uCodePageKbd;
}

/*
 *	CTxtSelection::MatchKeyboardToPara()
 *
 *	@mfunc
 *		Match the keyboard to the current paragraph direction. If the paragraph
 *		is an RTL paragraph then the keyboard will be switched to an RTL
 *		keyboard, and vice versa.
 *
 *	@rdesc
 *		TRUE iff a keyboard was changed
 *
 *	@devnote
 *		We use the following tests when trying to find a keyboard to match the
 *		paragraph direction:
 *
 *		See if the current keyboard matches the direction of the paragraph.
 *
 *		Search backward from rtp looking for a charset that matches the
 *			direction of the paragraph.
 *
 *		Search forward from rtp looking for a charset that matches the
 *			direction of the paragraph.
 *
 *		See if the default charformat charset matches the direction of the
 *			paragraph.
 *
 *		See if there's only a single keyboard that matches the paragraph
 *			direction.
 *
 *		If all this fails, just leave the keyboard alone.
 */
BOOL CTxtSelection::MatchKeyboardToPara()
{
	CTxtEdit *ped = GetPed();
	if(!ped->IsBiDi() || !GetPed()->_fFocus || GetPed()->_fIMEInProgress)
		return FALSE;

	const CParaFormat *pPF = GetPF();
	if(pPF->IsTableRowDelimiter())
		return FALSE;

	BOOL fRTLPara = (pPF->_wEffects & PFE_RTLPARA) != 0;// Get paragraph direction

	if(W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))) == fRTLPara)
		return FALSE;

	// Current keyboard direction didn't match paragraph direction...
	BYTE				iCharRep;
	HKL					hkl = 0;
	const CCharFormat *	pCF;
	CFormatRunPtr		rpCF(_rpCF);

	// Look backward in text, trying to find a CharSet that matches
	// the paragraph direction.
	do
	{
		pCF = ped->GetCharFormat(rpCF.GetFormat());
		iCharRep = pCF->_iCharRep;
		if(IsRTLCharRep(iCharRep) == fRTLPara)
			hkl = W32->CheckChangeKeyboardLayout(iCharRep);
	} while (!hkl && rpCF.PrevRun());

	if(!hkl)
	{
		// Didn't find an appropriate charformat so reset run pointer
		// and look forward instead
		rpCF = _rpCF;
		while (!hkl && rpCF.NextRun())
		{
			pCF = ped->GetCharFormat(rpCF.GetFormat());
			iCharRep = pCF->_iCharRep;
			if(IsRTLCharRep(iCharRep) == fRTLPara)
				hkl = W32->CheckChangeKeyboardLayout(iCharRep);
		}
		if(!hkl)
		{
			// Still didn't find an appropriate charformat so see if
			// default charformat matches paragraph direction.
			pCF = ped->GetCharFormat(rpCF.GetFormat());
			iCharRep = pCF->_iCharRep;
			if(IsRTLCharRep(iCharRep) == fRTLPara)
				hkl = W32->CheckChangeKeyboardLayout(iCharRep);

			if(!hkl)
			{
				// If even that didn't work, walk through the list of
				// keyboards and grab the first one we come to that matches
				// the paragraph direction.
				pCF = NULL;
				hkl = W32->FindDirectionalKeyboard(fRTLPara);
			}
		}
	}

	if (hkl && ped->_fFocus && IsCaretShown())
	{
		CreateCaret();
		ped->TxShowCaret(TRUE);
	}

	return hkl ? TRUE : FALSE;
}

/*
 *	CTxtSelection::GetCaretPoint(&rcClient, pt, &rp, fBeforeCp)
 *
 *	@mfunc
 *		This routine determines where the caret should be positioned
 *		on screen.
 *		This routine is just a call to PointFromTp(), except for the Bidi
 *		case. In that case if we are told to retrieve formatting from the
 *		forward CP, we draw	the caret at the logical left edge of the CP.
 *		Else, we draw it at the logical right edge of the previous CP.
 *
 *	@rdesc
 *		TRUE if we didn't OOM.
 */
BOOL CTxtSelection::GetCaretPoint(
	RECTUV		&rcClient, 
	POINTUV		&pt, 
	CLinePtr	*prp,
	BOOL		fBeforeCp)
{
	CDispDim	dispdim;
	CRchTxtPtr	rtp(*this);
	UINT		taMode = TA_BASELINE | TA_LOGICAL;

	if(GetPed()->IsBiDi() && _rpCF.IsValid())
	{
		if(_fHomeOrEnd)					// Home/End
			taMode |= _fCaretNotAtBOL ? TA_ENDOFLINE : TA_STARTOFLINE;

		else if(!GetIchRunCF() || !GetCchLeftRunCF())
		{
			// In a Bidi context on a run boundary where the reverse level
			// changes, then we should respect the fBeforeCp flag.
			BYTE 	bLevelBwd, bLevelFwd;
			BOOL	fStart = FALSE;
			LONG	cp = rtp._rpTX.GetCp();
			CBiDiLevel level;

			bLevelBwd = bLevelFwd = rtp.IsParaRTL() ? 1 : 0;

			rtp._rpCF.AdjustBackward();
			if (cp)
				bLevelBwd = rtp._rpCF.GetLevel();

			rtp._rpCF.AdjustForward();
			if (cp != rtp._rpTX.GetTextLength())
			{
				bLevelFwd = rtp._rpCF.GetLevel(&level);
				fStart = level._fStart;
			}

			if((bLevelBwd != bLevelFwd || fStart) && !fBeforeCp && rtp.Move(-1))
			{
				// Direction change at cp, caret in prev CF run, and can
				// backspace to previous char: then get to the right of
				// previous char
				taMode |= TA_RIGHT;
				_fCaretNotAtBOL = !rtp._rpTX.IsAfterEOP();
			}
		}
	}
	if (_pdp->PointFromTp(rtp, &rcClient, _fCaretNotAtBOL, pt, prp, taMode, &dispdim) < 0)
		return FALSE;

	return TRUE;
}

/*
 *	CTxtSelection::UpdateCaret(fScrollIntoView, bForceCaret)
 *
 *	@mfunc
 *		This routine updates caret/selection active end on screen. 
 *		It figures its position, size, clipping, etc. It can optionally 
 *		scroll the caret into view.
 *
 *	@rdesc
 *		TRUE if view was scrolled, FALSE otherwise
 *
 *	@devnote
 *		The caret is actually shown on screen only if _fShowCaret is TRUE.
 */
BOOL CTxtSelection::UpdateCaret (
	BOOL fScrollIntoView,	//@parm If TRUE, scroll caret into view if we have
	BOOL bForceCaret)		// focus or if not and selection isn't hidden
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateCaret");
	_TEST_INVARIANT_

	if(_pdp->IsFrozen())				// If display is currently frozen
	{									//  save call for another time
		_pdp->SaveUpdateCaret(fScrollIntoView);
		return FALSE;
	}

	CTxtEdit *ped = GetPed();
	if(ped->IsStreaming())				// Don't bother doing anything if we
		return FALSE;					//  are loading in text or RTF data

	if(!ped->fInplaceActive())			// If not inplace active, set up
	{									//  for when focus is regained
		if(fScrollIntoView)
			ped->_fScrollCaretOnFocus = TRUE;
		return FALSE;
	}

	while(!_cch && _rpTX.IsAtTRD(STARTFIELD))
	{
		// Don't leave selection at start of a row; move it to start of first
		// cell. REVIEW: this restriction could be relaxed with some work, and
		// it would be nice to do so for ease of programmability. Specifically,
		// Whenever text would be inserted immediately before a table row,
		// one would be sure that doesn't become part of the table row-start
		// delimiter paragraph, i.e., is inserted in the previous paragraph
		// (if that one isn't a TRD para), or is inserted in its own paragraph.
		AdvanceCRLF(CSC_NORMAL, FALSE);
	}

	DWORD		dwScrollBars	= ped->TxGetScrollBars();
	BOOL		fAutoVScroll	= FALSE;
	BOOL		fAutoUScroll	= FALSE;
	BOOL		fBeforeCp		= _rpTX.IsAfterEOP();
	POINTUV		pt;
	CLinePtr 	rp(_pdp);
	RECTUV		rcClient;
	RECTUV		rcView;

	LONG		dupView, dvpView;
	LONG		upScroll			= _pdp->GetUpScroll();
	LONG		vpScroll			= _pdp->GetVpScroll();

	INT 		dvpAbove			= 0;	// Ascent of line above & beyond IP
	INT			dvpAscent;				// Ascent of IP
	INT 		dvpAscentLine;
	LONG		vpBase;					// Base of IP & line
	INT 		vpBelow			= 0;	// Descent of line below & beyond IP
	INT 		dvpDescent;				// Descent of IP
	INT 		dvpDescentLine;
	INT			vpSum;
	LONG		vpViewTop, vpViewBottom;

	if(ped->_fFocus && (_fShowCaret || bForceCaret))
	{
		_fShowCaret = TRUE;	// We're trying to force caret to display so set this flag to true

		if(!_fDualFontMode && !_fNoKeyboardUpdate && !_fIsChar && !_fHomeOrEnd)
		{
			// Avoid re-entrance to CheckChangeKeyboardLayout
			_fNoKeyboardUpdate = TRUE;	

			// If we're in "dual font" mode, charset change is only 
			// temporary and we don't want to change keyboard layout
			CheckChangeKeyboardLayout();

			if(!fBeforeCp && ped->IsBiDi() && _rpCF.IsValid() &&
			   (!_rpCF.GetIch() || !_rpCF.GetCchLeft()))
			{
				_rpCF.AdjustBackward();
				BOOL fRTLPrevRun = IsRTLCharRep(GetCF()->_iCharRep);
				_rpCF.AdjustForward();

				if (fRTLPrevRun != IsRTLCharRep(GetCF()->_iCharRep) &&
					fRTLPrevRun != W32->IsBiDiLcid(GetKeyboardLCID()))
				{
					fBeforeCp = TRUE;
				}
			}
			_fNoKeyboardUpdate = FALSE;
		}
	}

	// Get client rectangle once to save various callers getting it
	ped->TxGetClientRect(&rcClient);
	_pdp->GetViewRect(rcView, &rcClient);

	// View can be bigger than client rect because insets can be negative.
	// We don't want the caret to be any bigger than the client view otherwise
	// the caret will leave pixel dust on other windows.
	vpViewTop	= max(rcView.top, rcClient.top);
	vpViewBottom = min(rcView.bottom, rcClient.bottom);
	if(ped->IsInPageView())
	{
		LONG vpHeight = _pdp->GetCurrentPageHeight();
		if(vpHeight)
		{
			vpHeight += rcView.top;
			if(vpHeight < vpViewBottom)
				vpViewBottom = vpHeight;
		}
	}

	dupView = rcView.right - rcView.left;
	dvpView = vpViewBottom - vpViewTop;

	if(fScrollIntoView)
	{
		fAutoVScroll = (dwScrollBars & ES_AUTOVSCROLL) != 0;
		fAutoUScroll = (dwScrollBars & ES_AUTOHSCROLL) != 0;

		// If we're not forcing a scroll, only scroll if window has focus
		// or selection isn't hidden
        if (!ped->Get10Mode() || !GetForceScrollCaret())
			fScrollIntoView = ped->_fFocus || !ped->fHideSelection();
	}

	if(!fScrollIntoView && (fAutoVScroll || fAutoUScroll))
	{											// Would scroll but don't have
		ped->_fScrollCaretOnFocus = TRUE;		//  focus. Signal to scroll
		if (!ped->Get10Mode() || !GetAutoVScroll())
		    fAutoVScroll = fAutoUScroll = FALSE;	//  when we do get focus
	}
	SetAutoVScroll(FALSE);

	if (!_cch && IsInOutlineView() && IsCollapsed())
		goto not_visible;

	if (!GetCaretPoint(rcClient, pt, &rp, fBeforeCp))
		goto not_visible; 

	// HACK ALERT - Because plain-text multiline controls do not have the 
	// automatic EOP, we need to special case their processing here because 
	// if you are at the end of the document and last character is an EOP, 
	// you need to be on the next line in the display not the current line.

	if(CheckPlainTextFinalEOP())			// Terminated by an EOP
	{
		LONG Align = GetPF()->_bAlignment;
		LONG dvpHeight;

		pt.u = rcView.left;					// Default left
		if(Align == PFA_CENTER)
			pt.u = (rcView.left + rcView.right)/2;

		else if(Align == PFA_RIGHT)
			pt.u = rcView.right;

		pt.u -= upScroll;					// Absolute coordinate

		// Bump the y up a line. We get away with the calculation because 
		// the document is plain text so all lines have the same height. 
		// Also, note that the rp below is used only for height 
		// calculations, so it is perfectly valid for the same reason 
		// even though it is not actually pointing to the correct line. 
		// (I told you this is a hack.)
		dvpHeight = rp->GetHeight();
		pt.v += dvpHeight;

		// Apply hack to PageView case as well
		if (ped->IsInPageView())
			vpViewBottom += dvpHeight;
	}

	_upCaret = pt.u;
	vpBase   = pt.v;
	
	// Compute caret height, ascent, and descent
	dvpAscent = GetCaretHeight(&dvpDescent);
	dvpAscent -= dvpDescent;

	// Default to line empty case. Use what came back from the default 
	// calculation above.
	dvpDescentLine = dvpDescent;
	dvpAscentLine = dvpAscent;

	if(rp.IsValid())
	{
		if(rp->GetDescent() != -1)
		{
			// Line has been measured so we can use the line's values
			dvpDescentLine = rp->GetDescent();
			dvpAscentLine  = rp->GetHeight() - dvpDescentLine;
		}
	}

	if(dvpAscent + dvpDescent == 0)
	{
		dvpAscent = dvpAscentLine;
		dvpDescent = dvpDescentLine;
	}
	else
	{
		// This is a bit counter-intuitive at first.  Basically, even if
		// the caret should be large (e.g., due to a large font at the
		// insertion point), we can only make it as big as the line.  If
		// a character is inserted, then the line becomes bigger, and we
		// can make the caret the correct size.
		dvpAscent = min(dvpAscent, dvpAscentLine);
		dvpDescent = min(dvpDescent, dvpDescentLine);
	}

	if(fAutoVScroll)
	{
		Assert(dvpDescentLine >= dvpDescent);
		Assert(dvpAscentLine >= dvpAscent);

		vpBelow = dvpDescentLine - dvpDescent;
		dvpAbove = dvpAscentLine - dvpAscent;

		vpSum = dvpAscent;

		// Scroll as much as possible into view, giving priorities
		// primarily to IP and secondarily ascents
		if(vpSum > dvpView)
		{
			dvpAscent = dvpView;
			dvpDescent = 0;
			dvpAbove = 0;
			vpBelow = 0;
		}
		else if((vpSum += dvpDescent) > dvpView)
		{
			dvpDescent = dvpView - dvpAscent;
			dvpAbove = 0;
			vpBelow = 0;
		}
		else if((vpSum += dvpAbove) > dvpView)
		{
			dvpAbove = dvpView - (vpSum - dvpAbove);
			vpBelow = 0;
		}
		else if((vpSum += vpBelow) > dvpView)
			vpBelow = dvpView - (vpSum - vpBelow);
	}
	else
	{
		AssertSz(dvpAbove == 0, "dvpAbove non-zero");
		AssertSz(vpBelow == 0, "vpBelow non-zero");
	}

	// Update real caret x pos (constant during vertical moves)
	_upCaretReally = _upCaret - rcView.left + upScroll;
	if (!(dwScrollBars & ES_AUTOHSCROLL) &&			// Not auto UScrolling
		!_pdp->IsUScrollEnabled())					//  and no scrollbar
	{
		if (_upCaret < rcView.left) 					// Caret off left edge
			_upCaret = rcView.left;
		else if(_upCaret + GetCaretDelta() > rcView.right)// Caret off right edge
			_upCaret = rcView.right - duCaret;		// Back caret up to	
	}												//  exactly the right edge
	// From this point on we need a new caret
	_fCaretCreated = FALSE;
	if(ped->_fFocus)
		ped->TxShowCaret(FALSE);					// Hide old caret before
													//  making a new one
	if(vpBase + dvpDescent + vpBelow > vpViewTop &&
		vpBase - dvpAscent - dvpAbove < vpViewBottom)
	{
		if(vpBase - dvpAscent - dvpAbove < vpViewTop)		// Caret is partially
		{											//  visible
			if(fAutoVScroll)						// Top isn't visible
				goto scrollit;
			Assert(dvpAbove == 0);

			dvpAscent = vpBase - vpViewTop;				// Change ascent to amount
			if(vpBase < vpViewTop)					//  visible
			{										// Move base to top
				dvpDescent += dvpAscent;
				dvpAscent = 0;
				vpBase = vpViewTop;
			}
		}
		if(vpBase + dvpDescent + vpBelow > vpViewBottom)
		{
			if(fAutoVScroll)						// Bottom isn't visible
				goto scrollit;
			Assert(vpBelow == 0);

			dvpDescent = vpViewBottom - vpBase;			// Change descent to amount
			if(vpBase > vpViewBottom)					//  visible
			{										// Move base to bottom
				dvpAscent += dvpDescent;
				dvpDescent = 0;
				vpBase = vpViewBottom;
			}
		}

		// Anything still visible?
		if(dvpAscent <= 0 && dvpDescent <= 0)
			goto not_visible;

		// If left or right isn't visible, scroll or set non_visible
		if (_upCaret < rcView.left ||				 // Left isn't visible
			_upCaret + GetCaretDelta() > rcView.right)// Right isn't visible
		{
			if(fAutoUScroll)
				goto scrollit;
			goto not_visible;
		}

		_vpCaret = vpBase - dvpAscent;
		_dvpCaret = (INT) dvpAscent + dvpDescent;
	}
	else if(fAutoUScroll || fAutoVScroll)			// Caret isn't visible
		goto scrollit;								//  scroll it into view
	else
	{
not_visible:
		// Caret isn't visible, don't show it
		_upCaret = -32000;
		_vpCaret = -32000;
		_dvpCaret = 1;
	}

	// Now update caret for real on screen. We only want to show the caret
	// if it is in the view and there is no selection.
	if(ped->_fFocus && _fShowCaret)
	{
		CreateCaret();
		ped->TxShowCaret(TRUE);
	}
	return FALSE;

scrollit:
	if(fAutoVScroll)
	{
		// Scroll to top for cp = 0. This is important if the first line
		// contains object(s) taller than the client area is high.	The
		// resulting behavior agrees with the Word UI in all ways except in
		// Backspacing (deleting) the char at cp = 0 when it is followed by
		// other chars that preceed the large object.
		if(!GetCp())											
			vpScroll = 0;

		else if(ped->IsInPageView())
			vpScroll += vpBase - dvpAscent - dvpAbove;

		else if(vpBase - dvpAscent - dvpAbove < vpViewTop)			// Top invisible
			vpScroll -= vpViewTop - (vpBase - dvpAscent - dvpAbove);	// Make it so

		else if(vpBase + dvpDescent + vpBelow > vpViewBottom)		// Bottom invisible
		{
			vpScroll += vpBase + dvpDescent + vpBelow - vpViewBottom;	// Make it so

			// Don't do following special adjust if the current line is bigger
			// than the client area
			if(rp->GetHeight() < vpViewBottom - vpViewTop)
			{
				vpScroll = _pdp->AdjustToDisplayLastLine(vpBase + rp->GetHeight(), 
					vpScroll);
			}
		}
	}
	if(fAutoUScroll)
	{
		// We don't scroll in chunks since sytem edit control doesn't
		if(_upCaret < rcView.left)						// Left invisible
			upScroll -= rcView.left - _upCaret;			// Make it visible

		else if(_upCaret + GetCaretDelta() > rcView.right)// Right invisible
			upScroll += _upCaret + duCaret - rcView.left - dupView;// Make it visible
	}
	if(vpScroll != _pdp->GetVpScroll() || upScroll != _pdp->GetUpScroll())
	{
		if (_pdp->ScrollView(upScroll, vpScroll, FALSE, FALSE) == FALSE)
		{
			if(ped->_fFocus && _fShowCaret)
			{
				CreateCaret();
				ped->TxShowCaret(TRUE);
			}
			return FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtSelection::GetCaretHeight(pdvpDescent)
 *
 *	@mfunc
 *		Calculate the height of the caret
 *
 *	@rdesc
 *		Caret height, <lt> 0 if failed
 */
INT CTxtSelection::GetCaretHeight (
	INT *pdvpDescent) const		//@parm Out parm to receive caret descent
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetCaretHeight");
								// (undefined if the return value is <lt> 0)
	_TEST_INVARIANT_

	CLock lock;						// Uses global (shared) FontCache
	CTxtEdit *ped = GetPed();
	const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
	const CDevDesc *pdd = _pdp->GetDdRender();

 	HDC hdc = pdd->GetDC();
	if(!hdc)
		return -1;

	LONG yHeight = -1;
	LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
	CCcs *pccs = ped->GetCcs(pCF, dypInch);
	if(!pccs)
		goto ret;

	LONG yOffset, yAdjust;
	pccs->GetOffset(pCF, dypInch, &yOffset, &yAdjust);

	SHORT	yAdjustFE;
	yAdjustFE = pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
	if(pdvpDescent)
		*pdvpDescent = pccs->_yDescent + yAdjustFE - yAdjust - yOffset;

	yHeight = pccs->_yHeight + (yAdjustFE << 1);
		
	pccs->Release();
ret:
	pdd->ReleaseDC(hdc);
	return yHeight;
}

/*
 *	CTxtSelection::ShowCaret(fShow)
 *
 *	@mfunc
 *		Hide or show caret
 *
 *	@rdesc
 *		TRUE if caret was previously shown, FALSE if it was hidden
 */
BOOL CTxtSelection::ShowCaret (
	BOOL fShow)		//@parm TRUE for showing, FALSE for hiding
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowCaret");

	_TEST_INVARIANT_

	const BOOL fRet = _fShowCaret;

	if(fRet != fShow)
	{
		_fShowCaret = fShow;
		if(GetPed()->_fFocus || GetPed()->fInOurHost())
		{
			if(fShow && !_fCaretCreated)
				CreateCaret();
			GetPed()->TxShowCaret(fShow);
		}
	}
	return fRet;
}

/*
 *	CTxtSelection::IsCaretInView()
 *
 *	@mfunc
 *		Returns TRUE iff caret is inside visible view
 */
BOOL CTxtSelection::IsCaretInView() const
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::IsCaretInView");

	_TEST_INVARIANT_

	RECTUV rc;
	_pdp->GetViewRect(rc);
		
	return  (_upCaret + duCaret		 > rc.left) &&
			(_upCaret				 < rc.right) &&
		   	(_vpCaret + _dvpCaret > rc.top) &&
			(_vpCaret				 < rc.bottom);
}

/*
 *	CTxtSelection::IsCaretHorizontal()
 *
 *	@mfunc
 *		Returns TRUE iff caret is horizontal
 *		FUTURE murrays (keithcu) The selection needs to keep track
 *	of what layout the selection is in so it can answer these
 *	kinds of questions
 */
BOOL CTxtSelection::IsCaretHorizontal() const
{
	return !IsUVerticalTflow(_pdp->GetTflow());
}

/*
 *	CTxtSelection::CaretNotAtBOL()
 *
 *	@mfunc
 *		Returns TRUE iff caret is not allowed at BOL
 */
BOOL CTxtSelection::CaretNotAtBOL() const
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CaretNotAtBOL");

	_TEST_INVARIANT_

	return _cch ? (_cch > 0) : _fCaretNotAtBOL;
}

/*
 *	CTxtSelection::CheckTableIP(fShowCellLine)
 *
 *	@mfunc
 *		Open/close up display line if selection is an insertion point
 *		at a CELL mark preceded by table-row end delimiter for fOpenLine 
 *		= TRUE/FALSE, respectively
 */
void CTxtSelection::CheckTableIP(
	BOOL fShowCellLine)	//@parm Open/close up line for CELL if preceded by TRED
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckTableIP");

	if (!_cch && (fShowCellLine ^ _fShowCellLine) &&
		_rpTX.GetChar() == CELL && _rpTX.IsAfterTRD(ENDFIELD))
	{
		_fShowCellLine = fShowCellLine;
		_pdp->RecalcLine(GetCp());
	}
}

/*
 *	CTxtSelection::LineLength(pcp)
 *
 *	@mfunc
 *		get # unselected chars on lines touched by current selection
 *
 *	@rdesc
 *		said number of chars
 */
LONG CTxtSelection::LineLength(
	LONG *pcp) const
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::LineLength");

	_TEST_INVARIANT_

	LONG	 cch;
	CLinePtr rp(_pdp);

	if(!_cch)							// Insertion point
	{
		rp.SetCp(GetCp(), _fCaretNotAtBOL);
		cch = rp.GetAdjustedLineLength();
		*pcp = GetCp() - rp.GetIch();
	}
	else
	{
		LONG cpMin, cpMost, cchLast;
		GetRange(cpMin, cpMost);
		rp.SetCp(cpMin, FALSE);			// Selections can't start at EOL
		cch = rp.GetIch();
		*pcp = cpMin - cch;
		rp.SetCp(cpMost, TRUE);			// Selections can't end at BOL

		// Remove trailing EOP, if it exists and isn't already selected
		cchLast = rp.GetAdjustedLineLength() - rp.GetIch();
		if(cchLast > 0)
			cch += cchLast;
	}
	return cch;
}

/*
 *	CTxtSelection::ShowSelection(fShow)
 *
 *	@mfunc
 *		Update, hide or show selection on screen
 *
 *	@rdesc
 *		TRUE iff selection was previously shown
 */
BOOL CTxtSelection::ShowSelection (
	BOOL fShow)			//@parm TRUE for showing, FALSE for hiding
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowSelection");

	_TEST_INVARIANT_

	const BOOL fShowPrev = _fShowSelection;
	const BOOL fInplaceActive = GetPed()->fInplaceActive();
	LONG cpSelSave = _cpSel;
	LONG cchSelSave = _cchSel;

	// Sleep(1000);
	_fShowSelection = fShow;

	if(fShowPrev && !fShow)
	{
		if(cchSelSave)			// Hide old selection
		{
			// Set up selection before telling the display to update
			_cpSel = 0;
			_cchSel = 0;

			if(fInplaceActive)
				_pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
		}
	}
	else if(!fShowPrev && fShow)
	{
		if(_cch)								// Show new selection
		{
			// Set up selection before telling the display to update
			_cpSel = GetCp();
			_cchSel = _cch;

			if(fInplaceActive)
				_pdp->InvertRange(GetCp(), _cch, selSetHiLite);
		}
	}
	return fShowPrev;
}

/*
 *	CTxtSelection::UpdateSelection()
 *
 *	@mfunc
 *		Updates selection on screen 
 *
 *	Note:
 *		This method inverts the delta between old and new selections
 */
void CTxtSelection::UpdateSelection()
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateSelection");

	_TEST_INVARIANT_
	
	LONG	cp = GetCp();
	LONG	cpNA	= cp - _cch;
	LONG	cpSelNA = _cpSel - _cchSel;
	LONG 	cpMin, cpMost;
	LONG	cpMinSel = 0;
	LONG	cpMostSel = 0;
	CObjectMgr* pobjmgr = NULL;
	LONG	NumObjInSel = 0, NumObjInOldSel = 0;
	LONG	cpSelSave = _cpSel;
	LONG	cchSelSave = _cchSel;

	GetRange(cpMin, cpMost);

	//We need to know if there were objects is the previous and current
	//selections to determine how they should be selected.
	if(GetPed()->HasObjects())
	{
		pobjmgr = GetPed()->GetObjectMgr();
		if(pobjmgr)
		{
			CTxtRange	tr(GetPed(), _cpSel, _cchSel);

			tr.GetRange(cpMinSel, cpMostSel);
			NumObjInSel = pobjmgr->CountObjectsInRange(cpMin, cpMost);
			NumObjInOldSel = pobjmgr->CountObjectsInRange(cpMinSel, cpMostSel);
		}
	}

	//If the old selection contained a single object and nothing else
	//we need to notify the object manager that this is no longer the
	//case if the selection is changing.
	if (NumObjInOldSel && (abs(_cchSel) == 1) &&
		!(cpMin == cpMinSel && cpMost == cpMostSel))
	{
		if(pobjmgr)
			pobjmgr->HandleSingleSelect(GetPed(), cpMinSel, /* fHilite */ FALSE);
	}

	// Update selection data before the invert so the selection can be
	// painted by the render
	_cpSel  = GetCp();
	_cchSel = _cch;

	if(_fShowSelection)
	{
		if(!_cch || !cchSelSave ||				// Old/new selection missing,
			cpMost < min(cpSelSave, cpSelNA) ||	//  or new preceeds old,
			cpMin  > max(cpSelSave, cpSelNA))	//  or new follows old, so
		{										//  they don't intersect
			if(_cch)
				_pdp->InvertRange(cp, _cch, selSetHiLite);
			if(cchSelSave)
				_pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
		}
		else
		{
			if(cpNA != cpSelNA)					// Old & new dead ends differ
			{									// Invert text between them
				_pdp->InvertRange(cpNA, cpNA - cpSelNA, selUpdateNormal);
			}
			if(cp != cpSelSave)					// Old & new active ends differ
			{									// Invert text between them
				_pdp->InvertRange(cp, cp - cpSelSave, selUpdateHiLite);
			}
		}
	}

	// If new selection contains a single object and nothing else, we need
	// to notify object manager as long as it's not the same object.
	if (NumObjInSel && abs(_cch) == 1 &&
		(cpMin != cpMinSel || cpMost != cpMostSel))
	{
		if(pobjmgr)
			pobjmgr->HandleSingleSelect(GetPed(), cpMin, /* fHiLite */ TRUE);
	}
}

/*
 * 	CTxtSelection::SetSelection(cpFirst, cpMost)
 *
 *	@mfunc
 *		Set selection between two cp's
 *	
 *	@devnote
 *		<p cpFirst> and <p cpMost> must be greater than 0, but may extend
 *		past the current max cp.  In that case, the cp will be truncated to
 *		the max cp (at the end of the text).	
 */
void CTxtSelection::SetSelection (
	LONG cpMin,				//@parm Start of selection and dead end
	LONG cpMost)			//@parm End of selection and active end
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetSelection");

	_TEST_INVARIANT_
	CTxtEdit *ped = GetPed();

	StopGroupTyping();

    if(ped->HasObjects())
    {
        CObjectMgr* pobjmgr = GetPed()->GetObjectMgr();
        if(pobjmgr)
        {
			COleObject *pobjactive = pobjmgr->GetInPlaceActiveObject();
			if (pobjactive)
			{
				if (pobjactive != pobjmgr->GetObjectFromCp(cpMin) || cpMost - cpMin > 1)
					pobjactive->DeActivateObj();
			}
        }
    }

	_fCaretNotAtBOL = FALSE;			// Put caret for ambiguous cp at BOL
	Set(cpMost, cpMost - cpMin);		// Set() validates cpMin, cpMost

	if(GetPed()->fInplaceActive())				// Inplace active:
		Update(!ped->Get10Mode() ? TRUE : !ped->fHideSelection());	//  update selection now
	else
	{
		// Update selection data used for screen display so whenever we
		// get displayed the selection will be displayed.
		_cpSel  = GetCp();
		_cchSel = _cch;	

		if(!ped->fHideSelection())
		{
			// Selection isn't hidden so tell container to update display
			// when it feels like.
        	ped->TxInvalidate();
			ped->TxUpdateWindow();
		}
	}
	CancelModes();						// Cancel word selection mode
}

/*
 *	CTxtSelection::PointInSel(pt, prcClient, Hit)
 *
 *	@mfunc
 *		Figures whether a given point is within the selection
 *
 *	@rdesc
 *		TRUE if point inside selection, FALSE otherwise
 */
BOOL CTxtSelection::PointInSel (
	const POINTUV pt,		//@parm Point in containing window client coords
	RECTUV *prcClient,		//@parm Client rectangle can be NULL if active
	HITTEST		Hit) const	//@parm May be computer Hit value
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PointInSel");
	_TEST_INVARIANT_

	if(!_cch || Hit && Hit < HT_Text)	// Degenerate range (no selection):
		return FALSE;					//  mouse can't be in, or Hit not
										//  in text
	LONG cpActual;
	_pdp->CpFromPoint(pt, prcClient, NULL, NULL, FALSE, &Hit, NULL, &cpActual);

	if(Hit < HT_Text)
		return FALSE;

	LONG cpMin,  cpMost;
	GetRange(cpMin, cpMost);

	return cpActual >= cpMin && cpActual < cpMost;
}


//////////////////////////////////  Selection with the mouse  ///////////////////////////////////

/*
 * 	CTxtSelection::SetCaret(pt, fUpdate)
 *
 *	@mfunc
 *		Sets caret at a given point
 *
 *	@devnote
 *		In the plain-text case, placing the caret at the beginning of the
 *		line following the final EOP requires some extra code, since the
 *		underlying rich-text engine doesn't assign a line to a final EOP
 *		(plain-text doesn't currently have the rich-text final EOP).  We
 *		handle this by checking to see if the count of lines times the
 *		plain-text line height is below the actual y position.  If so, we
 *		move the cp to the end of the story.
 */
void CTxtSelection::SetCaret(
	const POINTUV pt,	//@parm Point of click
	BOOL fUpdate)		//@parm If TRUE, update the selection/caret
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCaret");

	_TEST_INVARIANT_

	LONG		cp, cpActual;
	CDispDim	dispdim;
	HITTEST		Hit;
    RECTUV		rcView;
	CLinePtr	rp(_pdp);
	CRchTxtPtr  rtp(GetPed());
	LONG		vp;

	StopGroupTyping();

	// Set caret at point
	if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, FALSE, &Hit, &dispdim, &cpActual) >= 0)
	{
		cp = rtp.GetCp();

		// If the resolved CP is greater than the cp we are above, then we
		// want to stay backwards.
		BOOL fBeforeCp = cp <= cpActual;

		// Set selection to the correct location.  If plain-text
		// multiline control, we need to check to see if pt.v is below
		// the last line of text.  If so and if the text ends with an EOP,
		// we need to set the cp at the end of the story and set up to
		// display the caret at the beginning of the line below the last
		// line of text
		if(!IsRich() && _pdp->IsMultiLine())		// Plain-text,
		{											//  multiline control
			_pdp->GetViewRect(rcView, NULL);		
			vp = pt.v + _pdp->GetVpScroll() - rcView.top;
													
			if(vp > _pdp->LineCount()*rp->GetHeight())	// Below last line of
			{										//  text
				rtp.Move(tomForward);				// Move rtp to end of text
				if(rtp._rpTX.IsAfterEOP())			// If text ends with an
				{									//  EOP, set up to move
					cp = rtp.GetCp();				//  selection there
					rp.Move(-rp.GetIch());			// Set rp._ich = 0 to
				}									//  set _fCaretNotAtBOL
			}										//  = FALSE to display
		}											//  caret at next BOL

		Set(cp, 0);
		if(GetPed()->IsBiDi())
		{
			if(!fBeforeCp)
				_rpCF.AdjustBackward();
			else
				_rpCF.AdjustForward();
			Set_iCF(_rpCF.GetFormat());
		}
		_fCaretNotAtBOL = rp.GetIch() != 0;	// Caret OK at BOL if click
		if(fUpdate)
			Update(TRUE);
		else
			UpdateForAutoWord();

		_SelMode = smNone;						// Cancel word selection mode
	}
}

/*
 * 	CTxtSelection::SelectWord(pt)
 *
 *	@mfunc
 *		Select word around a given point
 */
void CTxtSelection::SelectWord (
	const POINTUV pt)			//@parm Point of click
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectWord");

	_TEST_INVARIANT_

	// Get rp where the hit is
	if(_pdp->CpFromPoint(pt, NULL, this, NULL, FALSE) >= 0)
	{
		if(GetPF()->IsTableRowDelimiter())				// Select table row
		{
			_cch = 0;									// Start with IP at pt
			Expander(tomRow, TRUE, NULL, &_cpAnchorMin, &_cpAnchorMost);
		}
		else									
		{												// Select word at IP
			if(GetCp() == GetAdjustedTextLength())
			{											// Special case since
				LONG cpMax = GetTextLength();			//  FindWordBreak() can't
				Set(cpMax, cpMax - GetCp());			//  move forward in this case
			}												
			else								
			{
				_cch = 0;								// Start with IP at pt
				FindWordBreak(WB_MOVEWORDRIGHT, FALSE);	// Go to end of word
				FindWordBreak(WB_MOVEWORDLEFT, TRUE);	// Extend to start of word
			}
			GetRange(_cpAnchorMin, _cpAnchorMost);
			GetRange(_cpWordMin, _cpWordMost);

			if(!_fInAutoWordSel)
				_SelMode = smWord;

			// cpMost needs to be the active end
			if(_cch < 0)
				FlipRange();
		}
		Update(FALSE);
	}
}

/*
 * 	CTxtSelection::SelectUnit(pt, Unit)
 *
 *	@mfunc
 *		Select line/paragraph around a given point and enter 
 *		line/paragraph selection mode. In Outline View, convert
 *		SelectLine to SelectPara, and SelectPara to SelectPara
 *		along with all subordinates
 */
void CTxtSelection::SelectUnit (
	const POINTUV pt,	//@parm Point of click
	LONG		Unit)	//@parm tomLine or tomParagraph
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectPara");

	_TEST_INVARIANT_

	AssertSz(Unit == tomLine || Unit == tomParagraph,
		"CTxtSelection::SelectPara: Unit must equal tomLine/tomParagraph");

	LONG	 nHeading;
	CLinePtr rp(_pdp);

	// Get rp and selection active end where the hit is
	if(_pdp->CpFromPoint(pt, NULL, this, &rp, FALSE) >= 0)
	{
		LONG cchBackward, cchForward;
		BOOL fOutline = IsInOutlineView();

		if(Unit == tomLine && !fOutline)			// SelectLine
		{
			_cch = 0;								// Start with insertion
			cchBackward = -rp.GetIch();			//  point at pt
			cchForward  = rp->_cch;
			_SelMode = smLine;
		}
		else										// SelectParagraph
		{
			cchBackward = rp.FindParagraph(FALSE);	// Go to start of para
			cchForward  = rp.FindParagraph(TRUE);	// Extend to end of para
			_SelMode = smPara;
		}
		Move(cchBackward, FALSE);

		if(Unit == tomParagraph && fOutline)		// Move para in outline
		{											//  view
			rp.AdjustBackward();					// If heading, include
			nHeading = rp.GetHeading();				//  subordinate	paras
			if(nHeading)							
			{											
				for(; rp.NextRun(); cchForward += rp->_cch)
				{
					LONG n = rp.GetHeading();
					if(n && n <= nHeading)
						break;
				}
			}
		}
		Move(cchForward, TRUE);
		GetRange(_cpAnchorMin, _cpAnchorMost);
		Update(FALSE);
	}
}

/*
 * 	CTxtSelection::SelectAll()
 *
 *	@mfunc
 *		Select all text in story
 */
void CTxtSelection::SelectAll()
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectAll");

	_TEST_INVARIANT_

	StopGroupTyping();

	LONG cchText = GetTextLength();

	Set(cchText,  cchText);
	Update(FALSE);
}

/*
 * 	CTxtSelection::ExtendSelection(pt)
 *
 *	@mfunc
 *		Extend/Shrink selection (moves active end) to given point
 */
void CTxtSelection::ExtendSelection (
	const POINTUV pt)		//@parm Point to extend to
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ExtendSelection");

	_TEST_INVARIANT_

	LONG		cch;
	LONG		cchPrev = _cch;
	LONG		cp;
	LONG		cpMin, cpMost;
	BOOL		fAfterEOP;
	const BOOL	fWasInAutoWordSel = _fInAutoWordSel;
	HITTEST		hit;
	INT			iDir = 0;
	CTxtEdit *	ped = GetPed();
	CLinePtr	rp(_pdp);
	CRchTxtPtr	rtp(ped);

	StopGroupTyping();

	// Get rp and rtp at the point pt
	if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, TRUE, &hit) < 0 || hit == HT_RightOfText)
		return;

	// If we are in word, line, or paragraph select mode, we need to make
	// sure the active end is correct.  If we are extending backward from
	// the first Unit selected, we want the active end to be at cpMin. If
	// we are extending forward from the first Unit selected, we want the
	// active end to be at cpMost.
	if(_SelMode != smNone)
	{
		cch = _cpAnchorMost - _cpAnchorMin;
		GetRange(cpMin, cpMost);
		cp = rtp.GetCp();

		if(cp <= cpMin  && _cch > 0)			// If active end changes,
			Set(_cpAnchorMin, -cch);			//  select the original
												//  Unit (will be extended
		if(cp >= cpMost && _cch < 0)			//  below)
			Set(_cpAnchorMost, cch);
	}

	cch = rp.GetIch();
	if(_SelMode > smWord && cch == rp->_cch)	// If in line or para select
	{											//  modes and pt at EOL,
		rtp.Move(-cch);							//  make sure we stay on that
		rp.Move(-cch);							//  line
		cch = 0;
	}

	SetCp(rtp.GetCp(), TRUE);					// Move active end to pt
												// Caret OK at BOL _unless_
	_fCaretNotAtBOL = _cch > 0 || cch == rp->_cch;//  forward selection
												// Now adjust selection
	if(_SelMode == smLine)						//  depending on mode
	{											// Extend selection by line
		if(_cch >= 0)							// Active end at cpMost
			cch -= rp->_cch;					// Setup to add chars to EOL
		Move(-cch, TRUE);
	}
	else if(_SelMode == smPara)
		Move(rp.FindParagraph(_cch >= 0), TRUE);// Extend selection by para

	else
	{
		// If the sign of _cch has changed this means that the direction
		// of the selection is changing and we want to reset the auto
		// selection information.
		if((_cch ^ cchPrev) < 0)
		{
			_fAutoSelectAborted = FALSE;
			_cpWordMin  = _cpAnchorMin;
			_cpWordMost = _cpAnchorMost;
		}

		cp = rtp.GetCp();
		fAfterEOP = rtp._rpTX.IsAfterEOP();

		_fInAutoWordSel = _SelMode != smWord && GetPed()->TxGetAutoWordSel() 
			&& !_fAutoSelectAborted
			&& (cp < _cpWordMin || cp > _cpWordMost);
	
		if(_fInAutoWordSel && !fWasInAutoWordSel)
		{
			CTxtPtr txtptr(GetPed(), _cpAnchor);

			// Extend both ends dead to word boundaries
			ExtendToWordBreak(fAfterEOP,
				_cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT); 

			if(_cch < 0)
			{
				// Direction is left so update word border on left
				_cpWordPrev = _cpWordMin;
				_cpWordMin = GetCp();
			}
			else
			{
				// Direction is right so update word border on right
				_cpWordPrev = _cpWordMost;
				_cpWordMost = GetCp();
			}

			// If we are at start of a word already, we don't need to extend
			// selection in other direction
			if(!txtptr.IsAtBOWord() && txtptr.GetChar() != ' ')
			{
				FlipRange();
				Move(_cpAnchor - GetCp(), TRUE);// Extend from anchor

				FindWordBreak(_cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT, TRUE);

				if(_cch > 0)				// Direction is right so
					_cpWordMost = GetCp();	//  update word border on right
				else						// Direction is left so
					_cpWordMin = GetCp();	//  update word border on left
				FlipRange();
			}
		}
		else if(_fInAutoWordSel || _SelMode == smWord)
		{
			// Save direction
			iDir = cp <= _cpWordMin ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT;

			if(_SelMode == smWord)			// Extend selection by word
			{
				if(cp > _cpAnchorMost || cp < _cpAnchorMin)
					FindWordBreak(iDir, TRUE);
				else if(_cch <= 0)			// Maintain current active end
					Set(_cpAnchorMin, _cpAnchorMin - _cpAnchorMost);
				else
					Set(_cpAnchorMost, _cpAnchorMost - _cpAnchorMin);
			}
			else
				ExtendToWordBreak(fAfterEOP, iDir); 

			if(_fInAutoWordSel)
			{
				if(WB_MOVEWORDLEFT == iDir)
				{
					// Direction is left so update word border on left
					_cpWordPrev = _cpWordMin;
					_cpWordMin = GetCp();
				}
				else
				{
					// Direction is right so update word border on right
					_cpWordPrev = _cpWordMost;
					_cpWordMost = GetCp();
				}
			}
		}
		else if(fWasInAutoWordSel)
		{
			// If we are in between where the previous word ended and
			// the cp we auto selected to, then we want to stay in 
			// auto select mode.
			if(_cch < 0)
			{
				if(cp >= _cpWordMin && cp < _cpWordPrev)
				{
					// Set direction for end of word search
					iDir = WB_MOVEWORDLEFT;

					// Mark that we are still in auto select mode
					_fInAutoWordSel = TRUE;
				}
			}
			else if(cp <= _cpWordMost && cp >= _cpWordPrev)
			{
				// Mark that we are still in auto select mode
				_fInAutoWordSel = TRUE;

				// Set direction for end of word search
				iDir = WB_MOVEWORDRIGHT;
			}

			//We have to check to see if we are on the boundary between
			//words because we don't want to extend the selection until
			//we are actually beyond the current word.
			if(cp != _cpWordMost && cp != _cpWordMin)
			{
				if(_fInAutoWordSel)
				{
					// Auto selection still on so make sure we have the
					// entire word we are on selected
					ExtendToWordBreak(fAfterEOP, iDir); 
				}
				else
				{
					// FUTURE: Word has a behavior where it extends the
					// selection one word at a time unless you back up
					// and then start extending the selection again, in
					// which case it extends one char at a time.  We
					// follow this behavior.  However, Word will resume
					// extending a word at a time if you continue extending
					// for several words.  We just keep extending on char
					// at a time.  We might want to change this sometime.
	
					_fAutoSelectAborted = TRUE;
				}
			}
		}

		if(_fAutoSelectAborted)
		{
			// If we are in the range of a word we previously selected
			// we want to leave that selected. If we have moved back
			// a word we want to pop back an entire word. Otherwise,
			// leave the cp were it is.
			if(_cch < 0)
			{
				if(cp > _cpWordMin && cp < _cpWordPrev)
				{
					// In the range leave the range at the beginning of the word
					ExtendToWordBreak(fAfterEOP, WB_MOVEWORDLEFT); 
				}
				else if(cp >= _cpWordPrev)
				{
					AutoSelGoBackWord(&_cpWordMin, 
						WB_MOVEWORDRIGHT, WB_MOVEWORDLEFT);
				}
			}
			else if(cp < _cpWordMost && cp >= _cpWordPrev)
			{
				// In the range leave the range at the beginning of the word
				ExtendToWordBreak(fAfterEOP, WB_MOVEWORDRIGHT); 
			}
			else if(cp < _cpWordPrev)
			{			
				AutoSelGoBackWord(&_cpWordMost,
					WB_MOVEWORDLEFT, WB_MOVEWORDRIGHT);
			}
		}
	}
	// An OLE object cannot have an anchor point <b> inside </b> it,
	// but sometimes we'd like it to behave like a word. So, if
	// the direction changed, the object has to stay selected --
	// this is the "right thing" (kind of word selection mode)

	// If we had something selected and the direction changed
	if(cchPrev && (_cch ^ cchPrev) < 0)
	{	
		FlipRange();
		
		// See if an object was selected on the other end	 
		BOOL fObjectWasSelected = (_cch > 0	? _rpTX.GetChar() : GetPrevChar())
									== WCH_EMBEDDING;
		// If it was, we want it to stay selected		
		if(fObjectWasSelected)
			Move(_cch > 0 ? 1 : -1, TRUE);

		FlipRange();
	}
	Update(TRUE);
}

/*
 * 	CTxtSelection::ExtendToWordBreak (fAfterEOP, iAction)
 *
 *	@mfunc
 *		Moves active end of selection to the word break in the direction
 *		given by iDir unless fAfterEOP = TRUE.  When this is TRUE, the
 *		cursor just follows an EOP marker and selection should be suppressed.
 *		Otherwise moving the cursor to the left of the left margin would
 *		select the EOP on the line above, and moving the cursor to the
 *		right of the right margin would select the first word in the line
 *		below.
 */
void CTxtSelection::ExtendToWordBreak (
	BOOL fAfterEOP,		//@parm Cursor is after an EOP
	INT	 iAction)		//@parm Word break action (WB_MOVEWORDRIGHT/LEFT)
{
	if(!fAfterEOP)
		FindWordBreak(iAction, TRUE);
}

/*
 * 	CTxtSelection::CancelModes(fAutoWordSel)
 *
 *	@mfunc
 *		Cancel either all modes or Auto Select Word mode only
 */
void CTxtSelection::CancelModes (
	BOOL fAutoWordSel)		//@parm TRUE cancels Auto Select Word mode only
{							//	   FALSE cancels word, line and para sel mode
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CancelModes");
	_TEST_INVARIANT_

	if(fAutoWordSel)
	{
		if(_fInAutoWordSel)
		{
			_fInAutoWordSel = FALSE;
			_fAutoSelectAborted = FALSE;
		}
	}
	else
		_SelMode = smNone;	
}


///////////////////////////////////  Keyboard movements  ////////////////////////////////////

/*
 *	CTxtSelection::Left(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad left-arrow key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		Left/Right-arrow IPs can go to within one character (treating CRLF
 *		as a character) of EOL.  They can never be at the actual EOL, so
 *		_fCaretNotAtBOL is always FALSE for these cases.  This includes
 *		the case with a right-arrow collapsing a selection that goes to
 *		the EOL, i.e, the caret ends up at the next BOL.  Furthermore,
 *		these cases don't care whether the initial caret position is at
 *		the EOL or the BOL of the next line.  All other cursor keypad
 *		commands may care.
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Left (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Left");

	_TEST_INVARIANT_

	CancelModes();
	StopGroupTyping();

	if(!fExtend && _cch)						// Collapse selection to
	{											//  nearest whole Unit before
		LONG cp;								//  cpMin
		if(fCtrl)								
			Expander(tomWord, FALSE, NULL, &cp, NULL);
		Collapser(tomStart);					// Collapse to cpMin
	}
	else										// Not collapsing selection
	{
		if (!GetCp() ||							// Already at beginning of
			!BypassHiddenText(tomBackward, fExtend))//  story
		{										
			Beep();
			return FALSE;
		}
		if(IsInOutlineView() && (_fSelHasEOP ||	// If outline view with EOP
			fExtend && _rpTX.IsAfterEOP()))		//  now or will have after
		{										//  this command,
			return Up(FALSE, fExtend);			//  treat as up arrow
		}
		if(fCtrl)								// WordLeft
			FindWordBreak(WB_MOVEWORDLEFT, fExtend);
		else									// CharLeft
			BackupCRLF(CSC_SNAPTOCLUSTER, fExtend);
	}
	_fCaretNotAtBOL = FALSE;					// Caret always OK at BOL
	Update(TRUE);
	return TRUE;
}

/*
 *	CTxtSelection::Right(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad right-arrow key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		Right-arrow selection can go to the EOL, but the cp of the other
 *		end identifies whether the selection ends at the EOL or starts at
 *		the beginning of the next line.  Hence here and in general for
 *		selections, _fCaretNotAtBOL is not needed to resolve EOL/BOL
 *		ambiguities.  It should be set to FALSE to get the correct
 *		collapse character.  See also comments for Left() above.
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Right (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Right");

	_TEST_INVARIANT_

	CancelModes();
	StopGroupTyping();

	if(!fExtend && _cch)						// Collapse selection to
	{											//  nearest whole Unit after
		LONG cp;								//  cpMost
		if(fCtrl)								
			Expander(tomWord, FALSE, NULL, NULL, &cp);
		Collapser(tomEnd);
	}
	else										// Not collapsing selection
	{
		LONG cchText = fExtend ? GetTextLength() : GetAdjustedTextLength();
		if (GetCp() >= cchText ||				// Already at end of story
			!BypassHiddenText(tomForward, fExtend))
		{
			Beep();								// Tell the user
			return FALSE;
		}
		if(IsInOutlineView() && _fSelHasEOP)	// If outline view with EOP
			return Down(FALSE, fExtend);		// Treat as down arrow

		if(fCtrl)								// WordRight
			FindWordBreak(WB_MOVEWORDRIGHT, fExtend);
		else									// CharRight
			AdvanceCRLF(CSC_SNAPTOCLUSTER, fExtend);
	}
	_fCaretNotAtBOL = fExtend;					// If extending to EOL, need
	Update(TRUE);								//  TRUE to get _upCaretReally
	return TRUE;								//  at EOL
}

/*
 *	CTxtSelection::Up(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad up-arrow key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		Up arrow doesn't go to EOL regardless of _upCaretPosition (stays
 *		to left of EOL break character), so _fCaretNotAtBOL is always FALSE
 *		for Up arrow.  Ctrl-Up/Down arrows always end up at BOPs or the EOD.
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Up (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Up");

	_TEST_INVARIANT_

	LONG		cch;
	LONG		cchSave = _cch;					// Save starting position for
	LONG		cpSave = GetCp();				//  change check
	BOOL		fCollapse = _cch && !fExtend;	// Collapse nondegenerate sel
	BOOL		fPTNotAtEnd;
	POINTUV		pt;
	CLinePtr	rp(_pdp);
	LONG		upCaretReally = _upCaretReally;	// Save desired caret x pos

	CancelModes();
	StopGroupTyping();

	if(fCollapse)								// Collapse selection at cpMin
	{
		Collapser(tomTrue);
		_fCaretNotAtBOL = FALSE;				// Selections can't begin at
	}											//  EOL

	if(_pdp->PointFromTp(*this, NULL, _fCaretNotAtBOL, pt, &rp, 0, NULL) < 0)
		return FALSE;

	if(fCtrl)									// Move to beginning of para
	{
		if (!fCollapse && 						// If no selection collapsed
			rp > 0 && !rp.GetIch())				//  and are at BOL,
		{										//  backup to prev BOL to make
			rp.PrevRun();						//  sure we move to prev. para
			Move(-rp->_cch, fExtend);
		}
		Move(rp.FindParagraph(FALSE), fExtend);	// Go to beginning of para
		_fCaretNotAtBOL = FALSE;				// Caret always OK at BOL
	}
	else										// Move up a line
	{											// If on first line, can't
		Assert(rp >= 0);						//  go up
		if(InTable())
		{
			WCHAR	ch;
			LONG	cpRowStart;
			CTxtRange rg(*this);				// Need rg for rg.FindRow()

			rg.Move(-rp.GetIch(), fExtend);		// Move to beginning of line
			rp.SetIch(0);

			LONG cpBOL = rg.GetCp();			// Save current cp for check
			while(1)							// While previous char is
			{									//  CELL or start of row,
				cch = 0;						//  move to start of row
				do								
				{						  		// Look at previous char &
					cch = rg.BackupCRLF(CSC_NORMAL, fExtend);//  save cch moved
					ch = rg._rpTX.GetChar();	
				}								// Backup over span of table
				while(rg.GetCp() && ch == STARTFIELD);//  row starts
				if(ch != CELL)
				{
					if(cch < 0 && ch != STARTFIELD)
						rg.AdvanceCRLF(CSC_NORMAL, fExtend);// Prev char not CELL 
					break;						//  or row start: move past it
				}
				rg.FindRow(&cpRowStart, NULL);	// Backup to start of
				rg.SetCp(cpRowStart, fExtend);	//  current table row
			}
			if(rg.GetCp() < cpBOL)				// Moved back
			{
				CLinePtr rp0(_pdp);				// Move rp to new position
				rp0.SetCp(rg.GetCp(), FALSE, 1);
				rp = rp0;						
			}
			if(rp > 0)							// Row above exists, so move
				SetCp(rg.GetCp(), fExtend);		//  selection to start of row
		}

		fPTNotAtEnd = !CheckPlainTextFinalEOP();// Always TRUE for rich text
		if(rp == 0 && fPTNotAtEnd)				// Can't move up
			UpdateCaret(TRUE);					// Be sure caret in view
		else
		{
			BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
			if(fSelHasEOPInOV && _cch > 0)
			{
				rp.AdjustBackward();
				cch = rp->_cch;
				rp.Move(-cch);					// Go to start of line
				Assert(!rp.GetIch());			
				cch -= rp.FindParagraph(FALSE);	// Ensure start of para in
			}									//  case of word wrap
			else
			{
				cch = 0;
				if(fPTNotAtEnd)
				{
					cch = rp.GetIch();
					rp--;
				}
				cch += rp->_cch;
			}
			Move(-cch, fExtend);				// Move to previous BOL
			if(fSelHasEOPInOV && !_fSelHasEOP)	// If sel had EOP but doesn't
			{									//  after Move, must be IP
				Assert(!_cch);					// Suppress restore of
				upCaretReally = -1;				//  _upCaretReally
			}										
			else if(!SetUpPosition(upCaretReally,// Set this cp corresponding
							rp, TRUE, fExtend))	//  to upCaretReally here, but
			{									//	 agree on Down()
				Set(cpSave, cchSave);			// Failed: restore selection
			}
		}									 	
	}

	if(GetCp() == cpSave && _cch == cchSave)
	{
		// Continue to select to the beginning of the first line
		// This is what 1.0 is doing
		if(fExtend)
			return Home(fCtrl, TRUE);

		_upCaretReally = upCaretReally;
		Beep();									// Nothing changed, so beep
		return FALSE;
	}

	Update(TRUE);								// Update and then restore
	if(!_cch && !fCtrl && upCaretReally >= 0)	//  _upCaretReally conditionally
		_upCaretReally = upCaretReally;			// Need to use _cch instead of
												//  cchSave in case of collapse
	return TRUE;
}

/*
 *	CTxtSelection::Down(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad down-arrow key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		Down arrow can go to the EOL if the _upCaretPosition (set by
 *		horizontal motions) is past the end of the line, so
 *		_fCaretNotAtBOL needs to be TRUE for this case.
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Down (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Down");

	_TEST_INVARIANT_

	LONG		cch;
	LONG		cchSave = _cch;					// Save starting position for
	LONG		cpSave = GetCp();				//  change check
	BOOL		fCollapse = _cch && !fExtend;	// Collapse nondegenerate sel
	POINTUV		pt;
	CLinePtr	rp(_pdp);
	LONG		upCaretReally = _upCaretReally;	// Save _upCaretReally

	CancelModes();
	StopGroupTyping();

	if(fCollapse)								// Collapse at cpMost
	{
		Collapser(tomEnd);
		_fCaretNotAtBOL = TRUE;					// Selections can't end at BOL
	}

	LONG ili = _pdp->PointFromTp(*this, NULL, _fCaretNotAtBOL, pt, &rp, 0, NULL);
	if(ili < 0)
		return FALSE;

	if(fCtrl)									// Move to next para
	{
		Move(rp.FindParagraph(TRUE), fExtend);	// Go to end of para
		if(IsInOutlineView() && !BypassHiddenText(tomForward, fExtend))
			SetCp(cpSave, fExtend);
		else
			_fCaretNotAtBOL = FALSE;			// Next para is never at EOL
	}
	else if(_pdp->WaitForRecalcIli(ili + 1))	// Go to next line
	{
		BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
		if(fSelHasEOPInOV && _cch < 0)
			cch = rp.FindParagraph(TRUE);
		else
		{
			cch = rp.GetCchLeft();				// Move selection to end
			rp.NextRun();						//  of current line
		}
		Move(cch, fExtend);
		while(GetPrevChar() == CELL)			// Went past cell end: 
		{										//  goto end of row
			LONG cpRowEnd;
			do
			{
				FindRow(NULL, &cpRowEnd);
				SetCp(cpRowEnd, fExtend);
			}
			while(_rpTX.GetChar() == CELL);		// Table at end of cell

			CLinePtr rp0(_pdp);
			rp0.SetCp(cpRowEnd, _fCaretNotAtBOL, 1);
			rp = rp0;
		}
		if(fSelHasEOPInOV && !_fSelHasEOP)		// If sel had EOP but doesn't
		{										//  after Move, must be IP  
			Assert(!_cch);						// Suppress restore of
			upCaretReally = -1;					//  _upCaretReally
		}										
		else if(!SetUpPosition(upCaretReally,	// Set *this to cp <--> x
						rp, FALSE, fExtend))
		{										// Failed: restore selection
			Set(cpSave, cchSave);				
		}
	}
	else if(!fExtend)	  						// No more lines to pass
		// && _pdp->GetVScroll() + _pdp->GetDvpView() < _pdp->GetHeight())
	{
		if (!IsRich() && _pdp->IsMultiLine() &&	// Plain-text, multiline
			!_fCaretNotAtBOL)					//  control	with caret OK
		{										//  at BOL
			cch = Move(rp.GetCchLeft(), fExtend);// Move selection to end
			if(!_rpTX.IsAfterEOP())				// If control doesn't end
				Move(-cch, fExtend);			//  with EOP, go back
		}
		UpdateCaret(TRUE);						// Be sure caret in view
	}

	if(GetCp() == cpSave && _cch == cchSave)
	{
		// Continue to select to the end of the lastline
		// This is what 1.0 is doing.
		if(fExtend)
			return End(fCtrl, TRUE);

		_upCaretReally = upCaretReally;
 		Beep();									// Nothing changed, so beep
		return FALSE;
	}

	Update(TRUE);								// Update and then
	if(!_cch && !fCtrl && upCaretReally >= 0)	//  restore _upCaretReally
		_upCaretReally = upCaretReally;			// Need to use _cch instead of
	return TRUE;								//  cchSave in case of collapse
}

/*
 *	CTxtSelection::SetUpPosition(upCaret, rp, fBottomLine, fExtend)
 *
 *	@mfunc
 *		Put this text ptr at cp nearest to xCaret.  If xCaret is in right
 *		margin, we put caret either at EOL (for lines with no para mark),
 *		or just before para mark
 *
 *	@rdesc
 *		TRUE iff could create measurer
 */
BOOL CTxtSelection::SetUpPosition(
	LONG	  upCaret,		//@parm Desired horizontal coordinate
	CLinePtr& rp,			//@parm Line ptr identifying line to check
	BOOL	  fBottomLine,	//@parm TRUE if use bottom line of nested display
	BOOL	  fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetUpPosition");

	_TEST_INVARIANT_

	LONG cch = 0;

	if(IsInOutlineView())
	{
		BOOL fSelHasEOP = _fSelHasEOP;
		rp.AdjustForward();
		_fCaretNotAtBOL = FALSE;				// Leave at start of line
		while(rp->_fCollapsed)
		{
			if(_fMoveBack)
			{
				if(!rp.PrevRun())				// No more uncollapsed text
					return FALSE;				//  before current cp
				cch -= rp->_cch;
			}
			else
			{
				cch += rp->_cch;
				if(!rp.NextRun())				// No more uncollapsed text
					return FALSE;				//  after current cp
				if(fExtend && _cch > 0)
					_fCaretNotAtBOL = TRUE;		// Leave at end of line
			}
		}
		if(cch)
			Move(cch, fExtend);
		if(fSelHasEOP)
			return TRUE;
	}

	POINTUV pt;
	UINT  talign = TA_BASELINE;

	if(fBottomLine)
	{
		if(rp->IsNestedLayout())
			talign = TA_TOP | TA_CELLTOP;
		else
			fBottomLine = FALSE;
	}

	if(_pdp->PointFromTp(*this, NULL, FALSE, pt, NULL, talign, NULL) < 0)
		return FALSE;

	if(fBottomLine)
		pt.v += rp->GetHeight() - 3;

	HITTEST hit;
	RECTUV rcView;
	_pdp->GetViewRect(rcView, NULL);

	if(!upCaret && _rpTX.IsAtTRD(STARTFIELD))
	{
		// At table row start at position before row: move over to get into
		// first cell. This solves some of the up/down-arrow errors for
		// upCaret = 0, but the caret still won't move for some nested table
		// scenarios (the needed upCaret measurement is more complicated than
		// that given here).
		LONG dupInch = MulDiv(_pdp->GetDxpInch(), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
		LONG dup = MulDiv(GetPF()->_dxOffset, dupInch, LX_PER_INCH);
		CTxtPtr tp(_rpTX);
		while(tp.IsAtTRD(STARTFIELD))
		{
			upCaret += dup;
			tp.AdvanceCRLF(FALSE);
		}
	}

	pt.u = upCaret + rcView.left;
	LONG cp = _pdp->CpFromPoint(pt, NULL, NULL, &rp, FALSE, &hit, NULL, NULL);
	if(cp < 0)
		return FALSE;							// If failed, restore sel

	SetCp(cp, fExtend);
	_fCaretNotAtBOL = rp.GetIch() != 0;	
	return TRUE;
}

/*
 *	CTxtSelection::GetUpCaretReally()
 *
 *	@mfunc
 *		Get _upCaretReally - horizontal scrolling + left margin
 *
 *	@rdesc
 *		x caret really
 */
LONG CTxtSelection::GetUpCaretReally()
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetUpCaretReally");

	_TEST_INVARIANT_

	RECTUV rcView;

	_pdp->GetViewRect(rcView);

	return _upCaretReally - _pdp->GetUpScroll() + rcView.left;
}

/*
 *	CTxtSelection::Home(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad Home key is supposed to do
 *
 *	@rdesc
 *			TRUE iff movement occurred
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Home (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Home");

	_TEST_INVARIANT_

	const LONG	cchSave = _cch;
	const LONG	cpSave  = GetCp();

	CancelModes();
	StopGroupTyping();

	if(fCtrl) 									// Move to start of document
		SetCp(0, fExtend);
	else
	{
		CLinePtr rp(_pdp);

		if(_cch && !fExtend)					// Collapse at cpMin
		{
			Collapser(tomStart);
			_fCaretNotAtBOL = FALSE;			// Selections can't start at
		}										//  EOL

		rp.SetCp(GetCp(), _fCaretNotAtBOL, 2);	// Define line ptr for
		Move(-rp.GetIch(), fExtend);			//  current state. Now BOL
	}
	_fCaretNotAtBOL = FALSE;					// Caret always goes to BOL
	_fHomeOrEnd = TRUE;
	
	if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
	{
		Beep();									// No change, so beep
		_fHomeOrEnd = FALSE;
		return FALSE;
	}

	Update(TRUE);
	_fHomeOrEnd = FALSE;
	_fUpdatedFromCp0 = FALSE;					// UI commands don't set this
	return TRUE;
}

/*
 *	CTxtSelection::End(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad End key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		On lines without paragraph marks (EOP), End can go all the way
 *		to the EOL.  Since this character position (cp) is the same as
 *		that for the start of the next line, we need _fCaretNotAtBOL to
 *		distinguish between the two possible caret positions.
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::End (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::End");

	_TEST_INVARIANT_

	LONG		cch;
	const LONG	cchSave = _cch;
	const LONG	cpSave  = GetCp();
	CLinePtr	rp(_pdp);
	
	CancelModes();
	StopGroupTyping();

	if(fCtrl)									// Move to end of document
	{
		SetCp(GetTextLength(), fExtend);
		_fCaretNotAtBOL = FALSE;
		goto Exit;
	}
	else if(!fExtend && _cch)					// Collapse at cpMost
	{
		Collapser(tomEnd);
		_fCaretNotAtBOL = TRUE;					// Selections can't end at BOL
	}

	rp.SetCp(GetCp(), _fCaretNotAtBOL, 2);		// Initialize line ptr on
												//  on innermost line
	cch = rp.GetCchLeft();						// Default target pos in line
	if(!Move(cch, fExtend))						// Move active end to EOL
		goto Exit;								// Failed (at end of story)

	if(!fExtend && rp->_cchEOP && _rpTX.IsAfterEOP())// Not extending & have
		cch += BackupCRLF(CSC_NORMAL, FALSE);	//  EOP so backup before EOP
	_fCaretNotAtBOL = cch != 0;					// Decide ambiguous caret pos
												//  by whether at BOL
Exit:
	if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
	{
		Beep();									// No change, so Beep
		return FALSE;
	}

	_fHomeOrEnd = TRUE;
	Update(TRUE);
	_fHomeOrEnd = FALSE;
	return TRUE;
}

/*
 *	CTxtSelection::PageUp(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad PgUp key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageUp (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageUp");

	_TEST_INVARIANT_

	const LONG	cchSave = _cch;
	const LONG	cpSave  = GetCp();
	LONG		upCaretReally = _upCaretReally;
	
	CancelModes();
	StopGroupTyping();

	if(_cch && !fExtend)						// Collapse selection
	{
		Collapser(tomStart);
		_fCaretNotAtBOL = FALSE;
	}

	if(fCtrl)									// Ctrl-PgUp: move to top
	{											//  of visible view for
		SetCp(_pdp->IsMultiLine()				//  multiline but top of
			? _pdp->GetFirstVisibleCp() : 0, fExtend);	//  text for SL
		_fCaretNotAtBOL = FALSE;
	}
	else if(_pdp->GetFirstVisibleCp() == 0)		// PgUp in top Pg: move to
	{											//  start of document
		SetCp(0, fExtend);
		_fCaretNotAtBOL = FALSE;
	}
	else										// PgUp with scrolling to go
	{											// Scroll up one windowful
		ScrollWindowful(SB_PAGEUP, fExtend);	//  leaving caret at same
	}											//  position in window

	if(GetCp() == cpSave && _cch == cchSave)	// Beep if no change
	{
		Beep();
		return FALSE;
	}

	Update(TRUE);
	if(GetCp())									// Maintain x offset on page
		_upCaretReally = upCaretReally;			//  up/down
	_fUpdatedFromCp0 = FALSE;					// UI commands don't set this
	return TRUE;
}

/*
 *	CTxtSelection::PageDown(fCtrl, fExtend)
 *
 *	@mfunc
 *		do what cursor-keypad PgDn key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@devnote
 *		fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageDown (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	BOOL fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageDown");

	_TEST_INVARIANT_

	const LONG	cchSave			= _cch;
	LONG		cpMostVisible;
	const LONG	cpSave			= GetCp();
	POINTUV		pt;
	CLinePtr	rp(_pdp);
	LONG		upCaretReally	= _upCaretReally;

	CancelModes();
	StopGroupTyping();
		
	if(_cch && !fExtend)						// Collapse selection
	{
		Collapser(tomStart);
		_fCaretNotAtBOL = TRUE;
	}

	_pdp->GetCliVisible(&cpMostVisible, fCtrl);		
	
	if(fCtrl)									// Move to end of last
	{											//  entirely visible line
		RECTUV rcView;

		SetCp(cpMostVisible, fExtend);

		if(_pdp->PointFromTp(*this, NULL, TRUE, pt, &rp, TA_TOP) < 0)
			return FALSE;

		_fCaretNotAtBOL = TRUE;

		_pdp->GetViewRect(rcView);

		if(rp > 0 && pt.v + rp->GetHeight() > rcView.bottom)
		{
			Move(-rp->_cch, fExtend);
			rp--;
		}

		if(!fExtend && !rp.GetCchLeft() && rp->_cchEOP)
		{
			BackupCRLF(CSC_NORMAL, FALSE);		// After backing up over EOP,
			_fCaretNotAtBOL = FALSE;			//  caret can't be at EOL
		}
	}
	else if(cpMostVisible == GetTextLength())
	{											// Move to end of text
		SetCp(GetTextLength(), fExtend);
		_fCaretNotAtBOL = !_rpTX.IsAfterEOP();
	}
	else if(!ScrollWindowful(SB_PAGEDOWN, fExtend))// Scroll down 1 windowful
		return FALSE;

	if(GetCp() == cpSave && _cch == cchSave)	// Beep if no change
	{
		Beep();
		return FALSE;
	}

	Update(TRUE);
	_upCaretReally = upCaretReally;
	return TRUE;
}

/*
 *	CTxtSelection::ScrollWindowful(wparam, fExtend)
 *
 *	@mfunc
 *		Sroll up or down a windowful
 *
 *	@rdesc
 *		TRUE iff movement occurred
 */
BOOL CTxtSelection::ScrollWindowful (
	WPARAM wparam,		//@parm SB_PAGEDOWN or SB_PAGEUP
	BOOL   fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ScrollWindowful");

	_TEST_INVARIANT_
												// Scroll windowful
	POINTUV pt;									//  leaving caret at same
	CLinePtr rp(_pdp);							//  point on screen
	LONG cpFirstVisible = _pdp->GetFirstVisibleCp();
	LONG cpLastVisible;
	LONG cpMin;
	LONG cpMost;

	GetRange(cpMin, cpMost);

	// Get last character in the view
	_pdp->GetCliVisible(&cpLastVisible, TRUE);

	// Is active end in visible area of control?
	if((cpMin < cpFirstVisible && _cch <= 0) || (cpMost > cpLastVisible && _cch >= 0))
	{
		// Not in view - we need to calculate a new range for selection
		SetCp(cpFirstVisible, fExtend);

		// Real caret postion is now at beginning of line
		_upCaretReally = 0;
	}

	if(_pdp->PointFromTp(*this, NULL, _fCaretNotAtBOL, pt, &rp, TA_TOP) < 0)
		return FALSE;

	// The point is visible so use that
	pt.u = _upCaretReally;
	pt.v += rp->GetHeight() / 2;
	_pdp->VScroll(wparam, 0);

	if(fExtend)
	{
		// Disable auto word select -- if we have to use ExtendSelection()
		// for non-mouse operations, let's try to get rid of its side-effects
		BOOL fInAutoWordSel = _fInAutoWordSel;
		_fInAutoWordSel = FALSE;
		ExtendSelection(pt);
		_fInAutoWordSel = fInAutoWordSel;
	}
	else
		SetCaret(pt, FALSE);

	return TRUE;
}

//////////////////////////// Keyboard support /////////////////////////////////

/*
 *	CTxtSelection::CheckChangeKeyboardLayout()
 *
 *	@mfunc
 *		Change keyboard for new font, or font at new character position.
 *
 *	@comm
 *		Using only the currently loaded KBs, locate one that will support
 *		the insertion points font. This is called anytime a character format
 *		change occurs, or the insert font (caret position) changes.
 *
 *	@devnote
 *		The current KB is preferred. If a previous association
 *		was made, see if the KB is still loaded in the system and if so use
 *		it. Otherwise, locate a suitable KB, preferring KB's that have
 *		the same charset ID as their default, preferred charset. If no match
 *		can be made then nothing changes.
 */
void CTxtSelection::CheckChangeKeyboardLayout ()
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeKeyboardLayout");

	CTxtEdit * const ped = GetPed();				// Document context

	if (ped && ped->_fFocus && !ped->fUseUIFont() &&// If ped, focus, not UIFont,
		ped->IsAutoKeyboard() &&					//  autokeyboard, 
		!ped->_fIMEInProgress &&					//  not in IME composition,
		ped->GetAdjustedTextLength() &&				//  not empty control, and
		_rpTX.GetPrevChar() != WCH_EMBEDDING)			//  not an object, then
	{												//  check kbd change
		LONG	iFormat = GetiFormat();
		const CCharFormat *pCF = ped->GetCharFormat(iFormat);
		BYTE	iCharRep = pCF->_iCharRep;

		if (!IsFECharRep(iCharRep) &&
			(iCharRep != ANSI_INDEX || !IsFELCID((WORD)GetKeyboardLayout(0))) &&
			!fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
		{
			// Don't do auto-kbd inside FE or single-codepage ASCII font.
			W32->CheckChangeKeyboardLayout(iCharRep);
		}
	}
}

/*
 *	CTxtSelection::CheckChangeFont (hkl, cpg, iSelFormat, qwCharFlags)
 *
 *	@mfunc
 *		Change font for new keyboard layout.
 *
 *	@comm
 *		If no previous preferred font has been associated with this KB, then
 *		locate a font in the document suitable for this KB.
 *
 *	@rdesc
 *		TRUE iff suitable font is found
 *
 *	@devnote
 *		This routine is called via WM_INPUTLANGCHANGEREQUEST message
 *		(a keyboard layout switch). This routine can also be called
 *		from WM_INPUTLANGCHANGE, but we are called more, and so this
 *		is less efficient.
 *
 *		Exact match is done via charset ID bitmask. If a match was previously
 *		made, use it. A user can force the insertion font to be associated
 *		to a keyboard if the control key is held through the KB changing
 *		process. The association is broken when another KB associates to
 *		the font. If no match can be made then nothing changes.
 */
bool CTxtSelection::CheckChangeFont (
	const HKL 	hkl,			//@parm Keyboard Layout to go
	UINT 		iCharRep,		//@parm Character repertoire to use
	LONG 		iSelFormat,		//@parm Format to use for selection case
	QWORD		qwCharFlags)	//@parm 0 if called from WM_INPUTLANGCHANGE/WM_INPUTLANGCHANGEREQUEST
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeFont");
	CTxtEdit * const ped = GetPed();

	if (!ped->IsAutoFont() ||			// EXIT if auto font is turned off
		_cch && !qwCharFlags)			//  or if kbd change with nondegenerate
		return true;					//  selection (WM_INPUTLANGCHANGEREQUEST)
										
	// Set new format using current format and new KB info.
	LONG			   iCurrentFormat = _cch ? iSelFormat : _iFormat;
	const CCharFormat *pCF = ped->GetCharFormat(iCurrentFormat);
	CCharFormat		   CF = *pCF;
	WORD			   wLangID = LOWORD(hkl);

	CF._lcid	 = wLangID;
	CF._iCharRep = iCharRep;

	if (pCF->_lcid == wLangID && iCharRep == pCF->_iCharRep)
	{
		if (ped->_fFocus && IsCaretShown())
		{
			CreateCaret();
			ped->TxShowCaret(TRUE);
		}
		return true;
	}

	CCFRunPtr 	rp(*this);
	int			iMatchFont = MATCH_FONT_SIG;
	
	// If current is a primary US or UK kbd. We allow matching ASCII fonts
	if ((!qwCharFlags || qwCharFlags & FASCII) &&
		PRIMARYLANGID(wLangID) == LANG_ENGLISH && 
		IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(wLangID), SUBLANG_ENGLISH_UK) && 
		wLangID == HIWORD((DWORD_PTR)hkl))
	{
		iMatchFont |= MATCH_ASCII;
	}

	if (rp.GetPreferredFontInfo(
			iCharRep,
			CF._iCharRep,
			CF._iFont,
			CF._yHeight,
			CF._bPitchAndFamily,
			iCurrentFormat,
			iMatchFont))
	{
		if(IsFECharRep(iCharRep) || iCharRep == THAI_INDEX || IsBiDiCharRep(iCharRep))
			ped->OrCharFlags(FontSigFromCharRep(iCharRep));

		if (!_cch)
		{
			SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_LCID | CFM_SIZE, CFM2_NOCHARSETCHECK);
			if(ped->IsComplexScript())
				UpdateCaret(FALSE);
		}
		else
		{
			// Create a format and use it for the selection			
			LONG	iCF;
			ICharFormatCache *pf = GetCharFormatCache();

			pf->Cache(&CF, &iCF);

#ifndef NOLINESERVICES
			if (g_pols)
				g_pols->DestroyLine(NULL);
#endif
			Set_iCF(iCF);
			pf->Release(iCF);							// pf->Cache AddRef it
			_fUseiFormat = TRUE;
		}
		return true;
	}
	return false;
}


//////////////////////////// PutChar, Delete, Replace  //////////////////////////////////
/*
 *	CTxtSelection::PutChar(ch, dwFlags, publdr)
 *
 *	@mfunc
 *		Insert or overtype a character
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL CTxtSelection::PutChar (
	DWORD		ch,			//@parm Char to put
	DWORD		dwFlags,	//@parm Overtype mode and whether keyboard input
	IUndoBuilder *publdr,	//@parm If non-NULL, where to put anti-events
	LCID		lcid)		//@parm If nonzero, lcid to use for char
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PutChar");

	_TEST_INVARIANT_

	BOOL	  fOver = dwFlags & 1;
	CTxtEdit *ped = GetPed();
	CFreezeDisplay	fd(GetPed()->_pdp);

	if(ch == TAB && GetPF()->InTable() && !(dwFlags & KBD_CTRL))
	{
		LONG cchSave = _cch;
		LONG cpMin, cpMost;
		LONG cpSave = GetCp();
		LONG Delta;
		BOOL fMoveBack = (GetKeyboardFlags() & SHIFT) != 0;

		do
		{
			if(!fMoveBack)							// TAB w/o Shift key: select
			{										//  contents of next cell
				if(!_rpTX.IsAtTRD(ENDFIELD))
				{
					if(GetPrevChar() == CELL)		// Handle empty cell case
						Move(1, FALSE);
					EndOf(tomCell, FALSE, &Delta);
				}
				if(_rpTX.IsAtTRD(ENDFIELD))
				{
					AdvanceCRLF(CSC_NORMAL, FALSE);	// Bypass end-of-row delimiter
					if(!_rpTX.IsAtTRD(STARTFIELD))	// Tabbed past end of table:
					{
						Move(-2, FALSE);			// Backup before table-row end
						return InsertTableRow(GetPF(), publdr, TRUE);
					}
					AdvanceCRLF(CSC_NORMAL, FALSE);	// Bypass start-of-row delimiter
				}
			}
			else									// Shift+TAB: select contents
			{										//  of previous cell
				if(_cch || !_rpTX.IsAtTRD(ENDFIELD))
				{
					FindCell(&cpMin, NULL);			// StartOf() w/o Update()'s
					SetCp(cpMin, FALSE);
				}
				if(GetPrevChar() == CELL)				
					Move(-1, FALSE);				// Backspace over previous CELL
				else
				{
					if(!_rpTX.IsAfterTRD(ENDFIELD))
					{
						Assert(_rpTX.IsAfterTRD(STARTFIELD));
						BackupCRLF(CSC_NORMAL, FALSE);
						if(!_rpTX.IsAfterTRD(ENDFIELD))
						{
							Set(cpSave, cchSave);	// Restore selection
							Beep();					// Tell user illegal key
							return FALSE;
						}
					}
					Move(-3, FALSE);				// Backspace over row-end
				}									//  delimiter and CELL
			}
			if(!InTable())
				break;
			FindCell(&cpMin, &cpMost);
			Assert(cpMost > cpMin);
			cpMost--;								// Don't select the CELL mark
			Set(cpMost, cpMost - cpMin);
		}
		while(cpMost == cpMin + 1 && _rpTX.GetPrevChar() == NOTACHAR);

		Update(TRUE);
		return TRUE;
	}

	if(_nSelExpandLevel)
	{
		Collapser(tomStart);
		while(_rpTX.IsAtTRD(STARTFIELD))
			AdvanceCRLF(CSC_NORMAL, FALSE);
		LONG cpMin, cpMost;
		FindCell(&cpMin, &cpMost);
		Set(cpMin, cpMin - cpMost + 1);
	}

	// EOPs might be entered by ITextSelection::TypeText()
	if(IsEOP(ch))
		return _pdp->IsMultiLine()			// EOP isn't allowed in
			? InsertEOP(publdr, ch) : FALSE;//  single line controls

	if(publdr)
	{
		publdr->SetNameID(UID_TYPING);
		publdr->StartGroupTyping();
	}

	// FUTURE: a Unicode lead surrogate needs to have a trail surrogate, i.e.,
	// two 16-bit chars. A more thorough check would worry about this.
	if ((DWORD)GetTextLength() >= ped->TxGetMaxLength() &&
		((_cch == -1 || !_cch && fOver) && _rpTX.IsAtEOP() ||
		 _cch == 1 && _rpTX.IsAfterEOP()))
	{
		// Can't overtype a CR, so need to insert new char but no room
		ped->GetCallMgr()->SetMaxText();
		return FALSE;
	}	
	if((!fOver || !_cch && GetCp() == GetTextLength()) &&
		!CheckTextLength(1))						// Return if we can't
	{												//  add even 1 more char
		return FALSE;								
	}

	// The following if statement implements Word95's "Smart Quote" feature.
	// To build this in, we still need an API to turn it on and off.  This
	// could be EM_SETSMARTQUOTES with wparam turning the feature on or off.
	// murrays. NB: this needs localization for French, German, and many
	// other languages (unless system can provide open/close chars given
	// an LCID).

	if((ch == '\'' || ch == '"') &&					// Smart quotes
		SmartQuotesEnabled() &&
		PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
	{
		LONG	cp = GetCpMin();					// Open vs close depends
		CTxtPtr tp(ped, cp - 1);					//  on char preceding
													//  selection cpMin
		ch = (ch == '"') ? RDBLQUOTE : RQUOTE;		// Default close quote
													//  or apostrophe. If at
		WCHAR chp = tp.GetChar();
		if(!cp || IsWhiteSpace(chp) || chp == '(')	//  BOStory or preceded
			ch--;									//  by whitespace, use
	}												//  open quote/apos

	WCHAR str[2];									// Might need to insert
	LONG  cch = 1;									//  Unicode surrogate pair
 	str[0] = (WCHAR)ch;								// Default single code

	if(ch > 65535)									// Higher-plane char or
	{												//  invalid
		if(ch > 0x10FFFF)
			return FALSE;							// Invalid (above plane 17)
		ch -= 0x10000;								// Higher-plane char:
		str[0] = 0xD800 + (ch >> 10);				//  convert to surrogate pair
		str[1] = 0xDC00 + (ch & 0x3FF);
		cch = 2;
	}

	// Some languages, e.g., Thai and Vietnamese, require verifying the input
	// sequence order before submitting it to the backing store.

	BOOL	fBaseChar = TRUE;						// Assume ch is a base consonant
	if(!IsInputSequenceValid(str, cch, fOver, &fBaseChar))
	{
		SetDualFontMode(FALSE);						// Ignore bad sequence
		return FALSE;
	}

	DWORD iCharRepDefault = ped->GetCharFormat(-1)->_iCharRep;
	QWORD qw = GetCharFlags(str, cch, iCharRepDefault);
    ped->OrCharFlags(qw, publdr);

	// BEFORE we do "dual-font", we sync the keyboard and current font's
	// (_iFormat) charset if it hasn't been done.
	const CCharFormat *pCFCurrent = NULL;
	CCharFormat CF = *ped->GetCharFormat(GetiFormat());
	BYTE iCharRep = CF._iCharRep;
	BOOL fRestoreCF = FALSE;

	if(ped->IsAutoFont())
	{
		UINT uKbdcpg = 0;
		BOOL fFEKbd = FALSE;
		
		if(!(ped->_fIMEInProgress) && !(ped->Get10Mode() && iCharRep == MAC_INDEX))
			uKbdcpg = CheckSynchCharSet(qw);

		if (fUseUIFont() && ch <= 0x0FF)
		{	
			// For UIFont, we need to format ANSI characters
			// so we will not have different formats between typing and
			// WM_SETTEXT.			
			if (!ped->_fIMEInProgress && qw == FHILATIN1)
			{
				// Use Ansi font if based font or current font is FE.
				if(IsFECharRep(iCharRepDefault) || IsFECharRep(iCharRep))
					SetupDualFont();				// Use Ansi font for HiAnsi	
			}
			else if (qw & FASCII && (GetCharRepMask(TRUE) & FASCII) == FASCII)
			{
				CCharFormat CFDefault = *ped->GetCharFormat(-1);
				if (IsRich() && IsBiDiCharRep(CFDefault._iCharRep) &&
					!W32->IsBiDiCodePage(uKbdcpg))
				{
					CFDefault._iCharRep = ANSI_INDEX;
				}
				SetCharFormat(&CFDefault, SCF_NOKBUPDATE, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
						 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK | CFM2_HOLDITEMIZE);

				_fUseiFormat = FALSE;
				pCFCurrent = &CF;
				fRestoreCF = ped->_fIMEInProgress;
			}
		}
		else if(!fUseUIFont()    && iCharRep != ANSI_INDEX && 
				(ped->_fDualFont && iCharRep != SYMBOL_INDEX && 
				(((fFEKbd = (ped->_fIMEInProgress || W32->IsFECodePage(uKbdcpg))) && ch < 127 && IsASCIIAlpha(ch)) ||
				 (!fFEKbd && IsFECharRep(ped->GetCharFormat(GetiFormat())->_iCharRep) && ch < 127))
				|| ped->_fHbrCaps))
		{
			SetupDualFont();
			pCFCurrent = &CF;
			fRestoreCF = ped->_fIMEInProgress;
		}
	}

	// = Indic/Thai overtyping convention =
	//
	// The deal is that we will overwrite the cluster if ch is a cluster-start char
	// otherwise we just insert. This new convention was proposed by SA Office2000.
	//
	//                     Abc.Def.Ghi
	// Typing X at D       Abc.X.Ghi
	// Typing y and z      Abc.Xyz.Ghi

	if(fOver && fBaseChar)
	{												// If nothing selected and
		if(!_cch && !_rpTX.IsAtEOP())				//  not at EOP char, try
		{											//  to select char at IP
			LONG iFormatSave = Get_iCF();			// Remember char's format
			
			AdvanceCRLF(CSC_SNAPTOCLUSTER, TRUE);
			ReplaceRange(0, NULL, publdr,
				SELRR_REMEMBERENDIP);				// Delete this character.
			ReleaseFormats(_iFormat, -1);
			_iFormat = iFormatSave;					// Restore char's format.
		}
	}
	else if(_SelMode == smWord && ch != TAB && _cch)// Replace word selection
	{
		// The code below wants the active end to be at the end of the
		// word.  Make sure this is so.

		// FUTURE: (alexgo, andreib), _cch will only be less than zero
		// in certain weird timing situations where we get a mouse move
		// message in between the double click and mouse up messages.
		// we should rethink how we process messages && the ordering thereof.
		if(_cch < 0)
			FlipRange();
													// Leave word break chars
		CTxtPtr tp(_rpTX);							//  at end of selection
		Assert(_cch > 0);

		tp.Move(-1);
		if(tp.GetCp() && tp.FindWordBreak(WB_ISDELIMITER))// Delimiter at sel end
			FindWordBreak(WB_LEFTBREAK, TRUE);		// Backspace over it, etc.
	}

	_fIsChar = TRUE;								// Tell CDisplay::UpdateView
	_fDontUpdateFmt = TRUE;							//  we're PuttingChar()
	LONG iFormat = GetiFormat();					// Save current value
	LONG cchSave = _cch;
	LONG cpSave = GetCp();

	if(AdjustEndEOP(NEWCHARS) && publdr)			// Remember what sel was
		HandleSelectionAEInfo(ped, publdr, cpSave,	//  for undo
			cchSave,GetCp(), _cch, SELAE_MERGE);
	if(!_cch)
		Set_iCF(iFormat);
	_fDontUpdateFmt = FALSE;

	if(ped->_fUpperCase)
		CharUpperBuff(str, cch);
	else if(ped->_fLowerCase)
		CharLowerBuff(str, cch);

	if(!_cch)
	{
		if(iCharRep == DEFAULT_INDEX)
		{
			CCharFormat CFTemp;

			if (qw & FFE)		// Find a better charset for FE char
				CFTemp._iCharRep = MatchFECharRep(qw, GetFontSignatureFromFace(CF._iFont));
			else			
				CFTemp._iCharRep = W32->CharRepFromFontSig(qw);

			SetCharFormat(&CFTemp, SCF_NOKBUPDATE, NULL, CFM_CHARSET, CFM2_NOCHARSETCHECK); 
		}
		else if(iCharRep == SYMBOL_INDEX && dwFlags & KBD_CHAR && ch > 255)
		{
			UINT cpg = CodePageFromCharRep(GetKeyboardCharRep(0));	// If 125x, convert char
			if(IN_RANGE(1250, cpg, 1257))		//  back to ANSI for storing
			{									//  SYMBOL_CHARSET chars
				BYTE ach;
				WCTMB(cpg, 0, str, cch, (char *)&ach, 1, NULL, NULL, NULL);
				ch = ach;
			}
		}
	}

	if(lcid && !_fDualFontMode)
	{
		WORD uKbdcpg = PRIMARYLANGID(lcid);
		if (!(ped->_fIMEInProgress
			|| IsFELCID(uKbdcpg) && ch < 127
			|| ped->_fHbrCaps))
		{
			const CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);
			if(uKbdcpg != PRIMARYLANGID(pCF->_lcid) && !IsFECharRep(pCF->_iCharRep))
			{
				CCharFormat CFTemp;
				CFTemp._lcid = lcid;
				SetCharFormat(&CFTemp, SCF_NOKBUPDATE, NULL, CFM_LCID, 0); 
			}
		}
	}

	if(dwFlags & KBD_CHAR || iCharRep == SYMBOL_INDEX)
		ReplaceRange(cch, str, publdr, SELRR_REMEMBERRANGE, NULL, RR_UNHIDE);
	else
		CleanseAndReplaceRange(cch, str, TRUE, publdr, NULL, NULL, RR_UNHIDE);

	_rpPF.AdjustBackward();
	if(GetPF()->IsTableRowDelimiter())			// Inserted char into TRD
		InsertEOP(publdr, 0);					// Insert new EOP with
	_rpPF.AdjustForward();						//  nonTRD paraformat

	_fIsChar = FALSE;

	// Restore font for Hebrew CAPS. Note that FE font is not restored
	// (is handled by IME).
	if(pCFCurrent && (W32->UsingHebrewKeyboard() || fRestoreCF))
		SetCharFormat(pCFCurrent, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, CFM2_NOCHARSETCHECK); 
	
	else if(iFormat != Get_iFormat())
		CheckChangeKeyboardLayout();

	SetDualFontMode(FALSE);

	// Autocorrect 
	if (!(dwFlags & KBD_NOAUTOCORRECT) && ped->_pDocInfo &&
		ped->_pDocInfo->_pfnAutoCorrect)
	{
		ped->AutoCorrect(this, ch, publdr);
	}
	if (!_pdp->IsFrozen())
		CheckUpdateWindow();						// Need to update display
													//  for pending chars.
	return TRUE;									
}													

/*
 *	CTxtSelection::CheckUpdateWindow()
 *
 *	@mfunc
 *		If it's time to update the window, after pending-typed characters,
 *		do so now. This is needed because WM_PAINT has a lower priority
 *		than WM_CHAR.
 */
void CTxtSelection::CheckUpdateWindow()
{
	DWORD ticks = GetTickCount();
	DWORD delta = ticks - _ticksPending;

	if(!_ticksPending)
		_ticksPending = ticks;
	else if(delta >= ticksPendingUpdate)
		GetPed()->TxUpdateWindow();
}

/*
 *	CTxtSelection::InsertTableRow(pPF, publdr, fFixCellBorders)
 *
 *	@mfunc
 *		Insert empty table row with parameters given by pPF
 *
 *	@rdesc
 *		Count of CELL and NOTACHAR chars inserted if successful; else 0
 */
LONG CTxtSelection::InsertTableRow (
	const CParaFormat *pPF,	//@parm CParaFormat to use for delimiters
	IUndoBuilder *publdr,	//@parm If non-NULL, where to put anti-events
	BOOL fFixCellBorders)	//@parm TRUE if this row should have bottom = top cell brdrs
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::InsertTableRow");

	_cch = 0;
	AssertSz(!fFixCellBorders || _rpTX.IsAtTRD(ENDFIELD),
		"CTxtSelection::InsertTableRow: illegal selection cp");

	LONG	  cpSave = GetCp();
	CTxtRange rg(*this);				// Use rg to get sel undo right

	if(fFixCellBorders)
		StopGroupTyping();

	LONG cchCells = rg.InsertTableRow(pPF, publdr);
	if(!cchCells)
		return 0;

	if(!fFixCellBorders)
	{
		SetCp(rg.GetCp(), FALSE);
		return cchCells;
	}

	// Make cell bottom borders of now next-to-last row have same widths
	// as the corresponding top borders
	LONG		cpMin;
	CParaFormat PF = *GetPF();
	CELLPARMS	rgCellParms[MAX_TABLE_CELLS];
	const CELLPARMS *prgCellParms = PF.GetCellParms();

	for(LONG i = 0; i < PF._bTabCount; i++)
	{
		rgCellParms[i] = prgCellParms[i];
		rgCellParms[i].SetBrdrWidthBottom(prgCellParms[i].GetBrdrWidthTop());
	}
	PF._iTabs = GetTabsCache()->Cache((LONG *)&rgCellParms[0],
					(CELL_EXTRA + 1)*PF._bTabCount);
	rg.Set(GetCp(), -2);
	rg.SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	rg.FindRow(&cpMin, NULL, PF._bTableLevel);
	rg.Set(cpMin, -2);
	rg.SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	GetTabsCache()->Release(PF._iTabs);
	Move(4, FALSE);					// 1st cell of new row
	if(publdr)
		HandleSelectionAEInfo(GetPed(), publdr,
			cpSave, 0, GetCp(), 0, SELAE_MERGE);
	Update(TRUE);
	return cchCells;
}

/*
 *	CTxtSelection::InsertEOP(publdr, ch)
 *
 *	@mfunc
 *		Insert EOP character(s)
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL CTxtSelection::InsertEOP (
	IUndoBuilder *publdr,	//@parm If non-NULL, where to put anti-events
	WCHAR		  ch)		//@parm Possible EOP char
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::InsertEOP");

	_TEST_INVARIANT_

	LONG	cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
	DWORD	dwFlags = RR_NO_TRD_CHECK | RR_UNHIDE | RR_UNLINK;
	BOOL	fResult = FALSE;
	BOOL	fShift = (ch == VT);
	const CParaFormat *pPF = CRchTxtPtr::GetPF();	// Get paragraph format
	BOOL	fInTable = pPF->InTable();
	BOOL	fNumbering = pPF->_wNumbering;
	WCHAR	szEOP[] = {CR, LF, 0};
	CTxtEdit *ped = GetPed();

	if(ch && (GetPed()->fUseCRLF() || IN_RANGE(VT, ch, FF)))
	{
		if(ch == VT)
		{
			CTxtPtr tp(_rpTX);				// Don't allow VT after table
			if(_cch > 0)					//  row delimiter, since TRDs
				tp.Move(-_cch);				//  have special nonparagraph
			if(tp.IsAfterTRD(0))			//  properties.
				ch = CR;
			dwFlags = RR_NO_TRD_CHECK | RR_UNHIDE;
		}
		szEOP[0] = ch;
		cchEOP = 1;
	}

	_fEOP = TRUE;

	// The user hit Enter: do 1 of 4 things: 
	//
	// 1) If at start of doc (or at start of cell at start of doc), insert
	//    a nontable paragraph in front of table
	// 2) If following a row terminator, insert an empty row with same
	//    properties as the row terminator
	// 3) Insert a paragraph mark
	// 4) If two Enters in a row before an EOP, turn off numbering

	if(_rpTX.IsAtTRD(ENDFIELD))
	{
		AssertSz(pPF->IsTableRowDelimiter(),
			"CTxtSelection::InsertEOP: invalid paraformat");
		return InsertTableRow(pPF, publdr, TRUE);
	}

	if(publdr)
	{
		publdr->StartGroupTyping();
		publdr->SetNameID(UID_TYPING);
	}

	if(fInTable && _rpTX.IsAtStartOfCell() && !fShift)
	{
		Move(-2, FALSE);
		if(GetCp() && !_rpTX.IsAtStartOfCell())
			Move(2, FALSE);
	}
	if(!GetCch())
	{
		LONG iFormat = _iFormat;
		dwFlags |= RR_NO_CHECK_TABLE_SEL;
		if(CheckLinkProtection(dwFlags, iFormat))
			Set_iCF(iFormat);

		if(fNumbering && _rpTX.IsAfterEOP() && _rpTX.IsAtEOP())
		{
			// Two enters in a row turn off numbering
			CParaFormat PF;
			PF._wNumbering = 0;
			PF._dxOffset = 0;
			SetParaFormat(&PF, publdr, PFM_NUMBERING | PFM_OFFSET, PFM2_PARAFORMAT);
		}
	}
	if(CheckTextLength(cchEOP))				// If cchEOP chars can fit...
	{
		CFreezeDisplay 	fd(GetPed()->_pdp);
		LONG iFormatSave = Get_iCF();		// Save CharFormat before EOP
											// Get_iCF() does AddRefFormat()
		if(fNumbering)						// Bullet paragraph: EOP has
		{									//  desired bullet CharFormat
			CFormatRunPtr rpCF(_rpCF);		// Get run pointers for locating
			CTxtPtr		  rpTX(_rpTX);		//  EOP CharFormat

			rpCF.Move(rpTX.FindEOP(tomForward));
			rpCF.AdjustBackward();
			Set_iCF(rpCF.GetFormat());		// Set _iFormat to EOP CharFormat
		}

		// Put in appropriate EOP mark
		fResult = ReplaceRange(cchEOP, szEOP, publdr,
							   SELRR_REMEMBERRANGE, NULL, dwFlags);

		if (ped->_pDocInfo && ped->_pDocInfo->_pfnAutoCorrect)
			ped->AutoCorrect(this, ch == 0 ? CR : ch, publdr);

		_rpPF.AdjustBackward();
		if(GetPF()->IsTableRowDelimiter())	// EOP just inserted before table
		{									//  row
			Move(-cchEOP, FALSE);			// Backup before EOP
			CTxtRange rg(*this);			// Use clone so don't change undo
			rg.Set(GetCp(), -cchEOP);		// Select EOP just inserted
			CParaFormat PF = *GetPed()->GetParaFormat(-1);
			PF._wEffects &= ~PFE_TABLE;		// Default not in table
			PF._bTableLevel = GetPF()->_bTableLevel - 1;
			if(PF._bTableLevel)
				PF._wEffects |= PFE_TABLE;	// It's in a table
			Assert(PF._bTableLevel >= 0);
			rg.SetParaFormat(&PF, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);
		}
		else
			_rpPF.AdjustForward();

		Set_iCF(iFormatSave);				// Restore _iFormat if changed
		ReleaseFormats(iFormatSave, -1);	// Release iFormatSave
	}

	return fResult;
}

/*
 *	CTxtSelection::DeleteWithTRDCheck(publdr. selaemode, pcchMove, dwFlags)
 *
 *	@mfunc
 *		Delete text in this range, inserting an EOP in place of the text
 *		if the range ends at a table-row start delimiter
 *
 *	@rdesc
 *		Count of new characters added
 *
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtSelection::DeleteWithTRDCheck (
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode,	//@parm Controls how selection antievents are to be generated.
	LONG *			pcchMove,	//@parm number of chars moved after replace
	DWORD			dwFlags)	//@parm ReplaceRange flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

	if(IsUpdatedFromCp0())
	{
		SetCp(0, FALSE);
		_fUpdatedFromCp0 = FALSE;
	}
	return CTxtRange::DeleteWithTRDCheck(publdr, selaemode, pcchMove, dwFlags);
}

/*
 *	CTxtSelection::Delete(fCtrl, publdr)
 *
 *	@mfunc
 *		Delete the selection. If fCtrl is true, this method deletes from
 *		min of selection to end of word
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL CTxtSelection::Delete (
	DWORD fCtrl,			//@parm If TRUE, Ctrl key depressed
	IUndoBuilder *publdr)	//@parm if non-NULL, where to put anti-events
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Delete");

	_TEST_INVARIANT_

	SELRR	mode = SELRR_REMEMBERRANGE;

	AssertSz(!GetPed()->TxGetReadOnly(), "CTxtSelection::Delete(): read only");

	if(!_cch)
		BypassHiddenText(tomForward, FALSE);

	if(publdr)
	{
		publdr->StopGroupTyping();
		publdr->SetNameID(UID_DELETE);
	}

	if(fCtrl)
	{										// Delete to word end from cpMin
		Collapser(tomStart);				//  (won't necessarily repaint,
		FindWordBreak(WB_MOVEWORDRIGHT, TRUE);//  since won't delete it)
	}

	if(!_cch)								// No selection
	{										// Try to select char at IP
		mode = SELRR_REMEMBERCPMIN;
		if(_rpTX.GetChar() == CELL ||		// Don't try to delete CELL mark
		   !AdvanceCRLF(CSC_SNAPTOCLUSTER, TRUE))
		{									// End of text, nothing to delete
			Beep();							// Only executed in plain text,
			return FALSE;					//  since else there's always 
		}									//  a final EOP to select
		_fMoveBack = TRUE;					// Convince Update_iFormat() to
		_fUseiFormat = TRUE;				//  use forward format
	}
	if(AdjustEndEOP(NONEWCHARS) && !_cch)
		Update(FALSE);
	else
		ReplaceRange(0, NULL, publdr, mode);	// Delete selection
	return TRUE;
}

/*
 *	CTxtSelection::BackSpace(fCtrl, publdr)
 *
 *	@mfunc
 *		do what keyboard BackSpace key is supposed to do
 *
 *	@rdesc
 *		TRUE iff movement occurred
 *
 *	@comm
 *		This routine should probably use the Move methods, i.e., it's
 *		logical, not directional
 *
 *	@devnote
 *		_fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Backspace (
	BOOL fCtrl,		//@parm TRUE iff Ctrl key is pressed (or being simulated)
	IUndoBuilder *publdr)	//@parm If not-NULL, where to put the antievents
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Backspace");

	_TEST_INVARIANT_

	SELRR mode = _cch ? SELRR_REMEMBERRANGE : SELRR_REMEMBERENDIP;

	AssertSz(!GetPed()->TxGetReadOnly(),
		"CTxtSelection::Backspace(): read only");

	_fCaretNotAtBOL = FALSE;
	if(publdr)
	{
		publdr->SetNameID(UID_TYPING);
		if(_cch || fCtrl)
			publdr->StopGroupTyping();
	}

	if(fCtrl)								// Delete word left
	{
		if(!GetCpMin())						// Beginning of story:
		{									//  no word to delete
			Beep();
			return FALSE;
		}
		Collapser(tomStart);				// First collapse to cpMin
	}
	if(!_cch)								// Empty selection
	{										// Try to select previous char
		unsigned ch = _rpTX.GetPrevChar();
		if (ch == CELL || ch == CR &&		// Don't delete CELL mark
				_rpTX.IsAfterTRD(0) ||		//  or table-row delimiter
			!BypassHiddenText(tomBackward, FALSE) ||
		    (fCtrl ? !FindWordBreak(WB_MOVEWORDLEFT, TRUE) :
					!BackupCRLF(CSC_NOMULTICHARBACKUP, TRUE)))
		{									// Nothing to delete
			Beep();
			return FALSE;
		}
		if(publdr && !fCtrl)
			publdr->StartGroupTyping();
	}
	ReplaceRange(0, NULL, publdr, mode);	// Delete selection

	return TRUE;
}

/*
 *	CTxtSelection::ReplaceRange(cchNew, pch, publdr, SELRRMode, pcchMove, dwFlags)
 *
 *	@mfunc
 *		Replace selected text by new given text and update screen according
 *		to _fShowCaret and _fShowSelection
 *
 *	@rdesc
 *		length of text inserted
 */
LONG CTxtSelection::ReplaceRange (
	LONG cchNew,			//@parm Length of replacing text or -1 to request
							// <p pch> sz length
	const WCHAR *pch,		//@parm Replacing text
	IUndoBuilder *publdr,	//@parm If non-NULL, where to put anti-events
	SELRR SELRRMode,		//@parm what to do about selection anti-events.
	LONG*	pcchMove,		//@parm number of chars moved after replacing
	DWORD	dwFlags)		//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ReplaceRange");

	_TEST_INVARIANT_

	LONG		cchNewSave;
	LONG		cchText		= GetTextLength();
	LONG		cpMin, cpMost;
	LONG		cpSave;
	BOOL		fDeleteAll	= FALSE;
	BOOL		fHeading	= FALSE;
	const BOOL	fUpdateView = _fShowSelection;

	CancelModes();

	if(cchNew < 0)
		cchNew = wcslen(pch);

	if(!_cch && !cchNew)						// Nothing to do
		return 0;

	if(!GetPed()->IsStreaming())				// If not pasting,
	{
		if(_cch != cchText && cchNew &&
		   (IsInOutlineView() && IsCollapsed() ||
			IsHidden() && !(dwFlags & RR_UNHIDE)))
		{										// Don't insert into collapsed
			Beep();								//  or hidden region (should
			return 0;							//  only happen if whole story
		}										//  collapsed or hidden)
		if(!(dwFlags & RR_NO_CHECK_TABLE_SEL))
			CheckTableSelection(FALSE, TRUE, NULL, 0);
	}
	GetPed()->GetCallMgr()->SetSelectionChanged();
	dwFlags |= RR_NO_LP_CHECK;					// Check is done by
												//  CheckTableSelection()
	GetRange(cpMin, cpMost);
	if(cpMin  > min(_cpSel, _cpSel + _cchSel) ||// If new sel doesn't
	   cpMost < max(_cpSel, _cpSel + _cchSel))	//  contain all of old
    {                                           //  sel, remove old sel
        ShowSelection(FALSE);
        _fShowCaret = TRUE;     
    }

	_fCaretNotAtBOL = FALSE;
	_fShowSelection = FALSE;					// Suppress the flashies
	
	// If we are streaming in text or RTF data, don't bother with incremental
	// recalcs.  The data transfer engine will take care of a final recalc
	if(!GetPed()->IsStreaming())
	{
		// Do this before calling ReplaceRange() so that UpdateView() works
		// AROO !!!	Do this before replacing the text or the format ranges!!!
		if(!_pdp->WaitForRecalc(cpMin, -1))
		{
			Tracef(TRCSEVERR, "WaitForRecalc(%ld) failed", cpMin);
			cchNew = 0;							// Nothing inserted
			goto err;
		}
	}

	if(publdr)
	{
		Assert(SELRRMode != SELRR_IGNORE);

		// Use selection AntiEvent mode to determine what to do for undo
		LONG cp = cpMin;
		LONG cch = 0;

		if(SELRRMode == SELRR_REMEMBERRANGE)
		{
			cp = GetCp();
			cch = _cch;
		}
		else if(SELRRMode == SELRR_REMEMBERENDIP)
			cp = cpMost;

		else
			Assert(SELRRMode == SELRR_REMEMBERCPMIN);

		HandleSelectionAEInfo(GetPed(), publdr, cp, cch, cpMin + cchNew, 
			0, SELAE_MERGE);
	}
			
	if(_cch == cchText && !cchNew && !(dwFlags & RR_NEW_CHARS))	// For delete all, set
	{											//  up to choose Normal
		fDeleteAll = TRUE;						//  or Heading 1
		FlipRange();
		fHeading = IsInOutlineView() && IsHeadingStyle(GetPF()->_sStyle);
	}

	cpSave		= cpMin;
	cchNewSave	= cchNew;
	cchNew		= CTxtRange::ReplaceRange(cchNew, pch, publdr, SELRR_IGNORE, pcchMove, dwFlags);
    _cchSel     = 0;							// No displayed selection
    _cpSel      = GetCp();						
	cchText		= GetTextLength();				// Update total text length
	_fShowSelection = fUpdateView;

	if(cchNew != cchNewSave)
	{
		Tracef(TRCSEVERR, "CRchTxtPtr::ReplaceRange(%ld, %ld, %ld) failed", GetCp(), cpMost - cpMin, cchNew);
		goto err;
	}

	if(fDeleteAll)								// When all text is deleted
    {											//  use Normal style unless
        CParaFormat PF;							//  in Outline View and first
        PF._sStyle = fHeading ? STYLE_HEADING_1 : STYLE_NORMAL;
        SetParaStyle(&PF, NULL, PFM_STYLE);		//  para was a heading
		if(GetPed()->IsBiDi())
		{
			if(GetPed()->_fFocus && !GetPed()->_fIMEInProgress)
			{
				MatchKeyboardToPara();
				CheckSynchCharSet(0);
			}
		}
		else
			Update_iFormat(-1);
    }

	// Only update caret if inplace active
	if(GetPed()->fInplaceActive())
		UpdateCaret(fUpdateView);				// May need to scroll
	else										// Update caret when we get
		GetPed()->_fScrollCaretOnFocus = TRUE;	//  focus again

	return cchNew;

err:
	TRACEERRSZSC("CTxtSelection::ReplaceRange()", E_FAIL);
	Tracef(TRCSEVERR, "CTxtSelection::ReplaceRange(%ld, %ld)", cpMost - cpMin, cchNew);
	Tracef(TRCSEVERR, "cchText %ld", cchText);

	return cchNew;
}

/*
 *	CTxtSelection::GetPF()
 *	
 *	@mfunc
 *		Return ptr to CParaFormat at active end of this selection. If no PF
 *		runs are allocated, then return ptr to default format.  If active
 *		end is at cpMost of a nondegenerate selection, use the PF of the
 *		previous char (last char in selection). 
 *	
 *	@rdesc
 *		Ptr to CParaFormat at active end of this selection
 */
const CParaFormat* CTxtSelection::GetPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtSelection::GetPF");

	if(_cch > 0)
		_rpPF.AdjustBackward();

	const CParaFormat* pPF = GetPed()->GetParaFormat(_rpPF.GetFormat());

	if(_cch > 0)
		_rpPF.AdjustForward();

	return pPF;
}

/*
 *	CTxtSelection::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2)
 *	
 *	@mfunc
 *		apply CCharFormat *pCF to this selection.  If range is an IP
 *		and fApplyToWord is TRUE, then apply CCharFormat to word surrounding
 *		this insertion point
 *
 *	@rdesc
 *		HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetCharFormat (
	const CCharFormat *pCF,	//@parm Ptr to CCharFormat to fill with results
	DWORD		  flags,	//@parm If SCF_WORD and selection is an IP,
							//		use enclosing word
	IUndoBuilder *publdr, 	//@parm Undo context
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCharFormat");

	HRESULT hr = 0;
	LONG	iFormat = _iFormat;

	if(publdr)
		publdr->StopGroupTyping();

	/*
	 * The code below applies character formatting to a double-clicked
	 * selection the way Word does it, that is, not applying the formatting to
	 * the last character in the selection if that character is a blank. 
	 *
	 * See also the corresponding code in CTxtRange::GetCharFormat().
	 */

	CCharFormat CF;
	LONG		cpMin, cpMost;
	LONG		cch = GetRange(cpMin, cpMost);;
	BOOL	    fCheckKeyboard = (flags & SCF_NOKBUPDATE) == 0;

	if(_SelMode == smWord && (flags & SCF_USEUIRULES) && cch)
	{	
		// In word select mode, don't include final blank in SetCharFormat
		CTxtPtr tpLast(GetPed(), cpMost - 1);
		if(tpLast.GetChar() == ' ')			// Selection ends with a blank:
		{									
			cpMost--;						// Setup end point to end at last
			cch--;							//  char in selection
			fCheckKeyboard = FALSE;
			flags &= ~SCF_WORD;
		}
	}

	BYTE iCharRep = pCF->_iCharRep;

	// Smart SB/DB Font Apply Feature
	if (cch && IsRich() &&					// > 0 chars in rich text
		!GetPed()->_fSingleCodePage &&		// Not in single cp mode
		(dwMask & CFM_FACE))                // font change
	{
        if (!(dwMask & CFM_CHARSET) || iCharRep == DEFAULT_INDEX)
		{
			CF = *pCF;
			CF._iCharRep = GetFirstAvailCharRep(GetFontSignatureFromFace(CF._iFont));
			pCF = &CF;
		}
		dwMask2 |= CFM2_MATCHFONT;			// Signal to match font charsets
	}
	// Selection is being set to a charformat
	if(_cch && IsRich())
		GetPed()->SetfSelChangeCharFormat();

	if(_cch && cch < abs(_cch))
	{
		CTxtRange rg(*this);
		rg.Set(cpMin, -cch);				// Use smaller cch
		hr = rg.SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);
	}
	else
		hr = CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);

	if(fCheckKeyboard && (dwMask & CFM_CHARSET) && _iFormat != iFormat)
		CheckChangeKeyboardLayout();

	_fIsChar = TRUE;
	UpdateCaret(!GetPed()->fHideSelection());
	_fIsChar = FALSE;
	return hr;
}

/*
 *	CTxtSelection::SetParaFormat(pPF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		apply CParaFormat *pPF to this selection.
 *
 *	@rdesc
 *		HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetParaFormat (
	const CParaFormat* pPF,	//@parm ptr to CParaFormat to apply
	IUndoBuilder *publdr,	//@parm Undo context for this operation
	DWORD		  dwMask,	//@parm Mask to use
	DWORD		  dwMask2)	//@parm Mask for internal flags
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetParaFormat");

	CFreezeDisplay	fd(GetPed()->_pdp);

	if(publdr)
		publdr->StopGroupTyping();

	// Apply the format
	HRESULT hr = CTxtRange::SetParaFormat(pPF, publdr, dwMask, dwMask2);

    UpdateCaret(!GetPed()->Get10Mode() || IsCaretInView());
	return hr;
}

/*
 *	CTxtSelection::SetSelectionInfo (pselchg)
 *
 *	@mfunc	Fills out data members in a SELCHANGE structure
 */
void CTxtSelection::SetSelectionInfo(
	SELCHANGE *pselchg)		//@parm SELCHANGE structure to use
{
	LONG cpMin, cpMost;
	LONG cch = GetRange(cpMin, cpMost);;

	pselchg->chrg.cpMin  = cpMin;
	pselchg->chrg.cpMost = cpMost;
	pselchg->seltyp		 = SEL_EMPTY;

	// OR in the following selection type flags if active:
	//
	// SEL_EMPTY:		insertion point
	// SEL_TEXT:		at least one character selected
	// SEL_MULTICHAR:	more than one character selected
	// SEL_OBJECT:		at least one object selected
	// SEL_MULTIOJBECT:	more than one object selected
	//
	// Note that the flags are OR'ed together.
	if(cch)
	{
		LONG cObjects = GetObjectCount();			// Total object count
		if(cObjects)								// There are objects:
		{											//  get count in range
			CObjectMgr *pobjmgr = GetPed()->GetObjectMgr();
			Assert(pobjmgr);

			cObjects = pobjmgr->CountObjectsInRange(cpMin, cpMost);
			if(cObjects > 0)
			{
				pselchg->seltyp |= SEL_OBJECT;
				if(cObjects > 1)
					pselchg->seltyp |= SEL_MULTIOBJECT;
			}
		}

		cch -= cObjects;
		AssertSz(cch >= 0, "objects are overruning the selection");

		if(cch > 0)
		{
			pselchg->seltyp |= SEL_TEXT;
			if(cch > 1)
				pselchg->seltyp |= SEL_MULTICHAR;
		}
	}
}

/*
 *	CTxtSelection::UpdateForAutoWord ()
 *
 *	@mfunc	Update state to prepare for auto word selection
 *
 *	@rdesc	void
 */
void CTxtSelection::UpdateForAutoWord()
{
	AssertSz(!_cch,
		"CTxtSelection::UpdateForAutoWord: Selection isn't degenerate");

	// If enabled, prepare Auto Word Sel
	if(GetPed()->TxGetAutoWordSel())	
	{									
		CTxtPtr tp(_rpTX);

		// Move anchor to new location
		_cpAnchor = GetCp();

		// Remember that FindWordBreak moves tp's cp
		// (aren't side effects wonderful?
		tp.FindWordBreak(WB_MOVEWORDRIGHT);
		_cpAnchorMost =_cpWordMost = tp.GetCp();

		tp.FindWordBreak(WB_MOVEWORDLEFT);
		_cpAnchorMin = _cpWordMin = tp.GetCp();

		_fAutoSelectAborted = FALSE;
	}
}

/*
 *	CTxtSelection::AutoSelGoBackWord(pcpToUpdate, iDirToPrevWord, iDirToNextWord)
 *
 *	@mfunc	Backup a word in auto word selection
 */
void CTxtSelection::AutoSelGoBackWord(
	LONG *	pcpToUpdate,	//@parm end of word selection to update
	int		iDirToPrevWord,	//@parm direction to next word
	int		iDirToNextWord)	//@parm direction to previous word
{
	if (GetCp() >= _cpAnchorMin &&
		GetCp() <= _cpAnchorMost)
	{
		// We are back in the first word. Here we want to pop
		// back to a selection anchored by the original selection

		Set(GetCp(), GetCp() - _cpAnchor);
		_fAutoSelectAborted = FALSE;
		_cpWordMin  = _cpAnchorMin;
		_cpWordMost = _cpAnchorMost;
	}
	else
	{
		// pop back a word
		*pcpToUpdate = _cpWordPrev;

		CTxtPtr tp(_rpTX);

		_cpWordPrev = GetCp() + tp.FindWordBreak(iDirToPrevWord);
		FindWordBreak(iDirToNextWord, TRUE);
	}
}

/*
 *	CTxtSelection::InitClickForAutWordSel (pt)
 *
 *	@mfunc	Init auto selection for click with shift key down
 *
 *	@rdesc	void
 */
void CTxtSelection::InitClickForAutWordSel(
	const POINTUV pt)		//@parm Point of click
{
	// If enabled, prepare Auto Word Sel
	if(GetPed()->TxGetAutoWordSel())	
	{
		// If auto word selection is occuring we want to pretend
		// that the click is really part of extending the selection.
		// Therefore, we want the auto word select data to look as
		// if the user had been extending the selection via the
		// mouse all along. So we set the word borders to the
		// word that would have been previously selected.

		// Need this for finding word breaks
		CRchTxtPtr	rtp(GetPed());
		LONG cpClick = _pdp->CpFromPoint(pt, NULL, &rtp, NULL, TRUE);
		int iDir = -1;

		if(cpClick < 0)
		{
			// If this fails what can we do? Prentend it didn't happen!
			// We can do this because it will only make the UI act a 
			// little funny and chances are the user won't even notice.
			return;
		}

		// Assume click is within anchor word
		_cpWordMost = _cpAnchorMost;
		_cpWordMin = _cpAnchorMin;

		if(cpClick > _cpAnchorMost)
		{
			// Click is after anchor word, so set cpMost appropriately
			iDir = WB_MOVEWORDLEFT;
			rtp.FindWordBreak(WB_MOVEWORDLEFT);
			_cpWordMost = rtp.GetCp();
		}
		// Click is before the anchor word
		else if(cpClick < _cpAnchorMost)
		{
			// Click is before  anchor word, so set cpMin appropriately.
			iDir = WB_MOVEWORDRIGHT;
			rtp.FindWordBreak(WB_MOVEWORDRIGHT);
			_cpWordMin = rtp.GetCp();
		}

		if(iDir != -1)
		{
			rtp.FindWordBreak(iDir);
			_cpWordPrev = rtp.GetCp();
		}
	}
}

/*
 *	CTxtSelection::CreateCaret ()
 *
 *	@mfunc	Create a caret
 *
 *	@devnote
 *		The caret is characterized by a height (_dvpCaret), a keyboard
 *		direction (if BiDi), a width (1 to 8, since OS can't handle carets
 *		larger than 8 pixels), and an italic state.  One could cache this
 *		info thereby avoiding computing the caret on every keystroke.
 */
void CTxtSelection::CreateCaret()
{
	CTxtEdit *		ped	 = GetPed();
	const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
	DWORD			dwCaretType = 0;
	BOOL			fItalic;
	LONG			y = min(_dvpCaret, 512);

	y = max(0, y);
	
	fItalic = pCF->_dwEffects & CFE_ITALIC && _dvpCaret > 15; //9 pt/15 pixels looks bad

	// Caret shape reflects current charset
	if(ped->IsComplexScript() && IsComplexKbdInstalled())
	{
		// Custom carets aren't italicized

		LCID	lcid = GetKeyboardLCID();

#ifdef	FANCY_CARET
		fItalic = 0;
		dwCaretType = CARET_CUSTOM;
#endif

		if (W32->IsBiDiLcid(lcid))
		{
			dwCaretType = CARET_CUSTOM | CARET_BIDI;
			fItalic = 0;
		}
#ifdef	FANCY_CARET
		else if (PRIMARYLANGID(lcid) == LANG_THAI)
			dwCaretType = CARET_CUSTOM | CARET_THAI;

		else if (W32->IsIndicLcid(lcid))
			dwCaretType = CARET_CUSTOM | CARET_INDIC;
#endif
	}

	//REVIEW (keithcu) Vertical text can't do complex scripts or italic carets (yet?)
	if (ped->_pdp->GetTflow() != tflowES)
	{
		fItalic = 0;
		dwCaretType = 0;
	}

	INT dx = duCaret;	
	DWORD dwCaretInfo = (_dvpCaret << 16) | (dx << 8) | (dwCaretType << 4) |
						(fItalic << 1) | !_cch;

#ifndef NOFEPROCESSING
	if (ped->_fKoreanBlockCaret)
	{
		// Support Korean block caret during Kor IME composition
		// Basically, we want to create a caret using the width and height of the 
		// character at current cp.
		CDisplay *	pdp = ped->_pdp;
		LONG		cpMin, cpMost;
		POINTUV		ptStart, ptEnd;

		GetRange(cpMin, cpMost);

		CRchTxtPtr rtp(ped, cpMin);

		// REVIEW: generalize PointFromTp to return both values (so one call)
		if (pdp->PointFromTp(rtp, NULL, FALSE, ptStart, NULL, TA_TOP+TA_LEFT) != -1 &&
			pdp->PointFromTp(rtp, NULL, FALSE, ptEnd, NULL, TA_BOTTOM+TA_RIGHT) != -1)
		{
			// Destroy whatever caret bitmap we had previously
			DeleteCaretBitmap(TRUE);

			LONG	iCharWidth = abs(ptEnd.u - ptStart.u);
			LONG	iCharHeight = abs(ptEnd.v - ptStart.v);

			// REVIEW: honwch do we need to SetCaretPos for all Tflows
			if (IsCaretHorizontal())
				ped->TxCreateCaret(0, iCharWidth, iCharHeight);
			else
				ped->TxCreateCaret(0, iCharHeight, iCharWidth);

			switch (_pdp->GetTflow())
			{
				case tflowES:
					ped->TxSetCaretPos(ptStart.u, ptStart.v);
					break;

				case tflowSW:
					ped->TxSetCaretPos(ptStart.u, ptEnd.v);
					break;
				
				case tflowWN:
					ped->TxSetCaretPos(ptEnd.u, ptEnd.v);
					break;

				case tflowNE:
					ped->TxSetCaretPos(ptEnd.u, ptStart.v);
					break;

			}

			_fCaretCreated = TRUE;
			
		}
		return;
	}
#endif

	// We always create the caret bitmap on the fly since it
	// may be of arbitrary size
	if (dwCaretInfo != _dwCaretInfo)
	{
		_dwCaretInfo = dwCaretInfo;					// Update caret info

		// Destroy whatever caret bitmap we had previously
		DeleteCaretBitmap(FALSE);

		if (y && y == _dvpCaret && (_cch || fItalic || dwCaretType))
		{
			LONG dy = 4;							// Assign value to suppress
			LONG i;									//  compiler warning
			WORD rgCaretBitMap[512];
			WORD wBits = 0x0020;
	
			if(_cch)								// Create blank bitmap if
			{										//  selection is nondegenerate
				y = 1;								//  (allows others to query
				wBits = 0;							//  OS where caret is)
				fItalic = FALSE;
			}
			if(fItalic)
			{
				i = (5*y)/16 - 1;					// System caret can't be wider
				i = min(i, 7);						//  than 8 bits
				wBits = 1 << i;						// Make larger italic carets
				dy = y/7;							//  more vertical. Ideal is
				dy = max(dy, 4);					//  usually up 4 over 1, but
			}										//  if bigger go up 5 over 1...
			for(i = y; i--; )						
			{
				rgCaretBitMap[i] = wBits;
				if(fItalic && !(i % dy))
					wBits /= 2;
			}
	
			if(!fItalic && !_cch && dwCaretType)
			{
#ifdef	FANCY_CARET
				dwCaretType &= ~CARET_CUSTOM;
	
				// Create an appropriate shape
				switch (dwCaretType)
				{
					case CARET_BIDI:
						// BiDi is a caret with a little triangle on top (flag shape pointing left)
						rgCaretBitMap[0] = 0x00E0;
						rgCaretBitMap[1] = 0x0060;
						break;
					case CARET_THAI:
						// Thai is an L-like shape (same as system edit control)
						rgCaretBitMap[y-2] = 0x0030;
						rgCaretBitMap[y-1] = 0x0038;
						break;
					case CARET_INDIC:
						// Indic is a T-like shape
						rgCaretBitMap[0] = 0x00F8;
						rgCaretBitMap[1] = 0x0070;
						break;
					default:
						if (ped->IsBiDi())
						{
							// Non-BiDi caret in BiDi document (flag shape pointing right)
							rgCaretBitMap[0] = 0x0038;
							rgCaretBitMap[1] = 0x0030;
						}
				}
#else			
				// No fancy caret, we only setup CARET_BIDI case
				rgCaretBitMap[0] = 0x00E0;
				rgCaretBitMap[1] = 0x0060;

#endif
			}
			_hbmpCaret = (HBITMAP)CreateBitmap(8, y, 1, 1, rgCaretBitMap);			
		}
	}

	if (IsCaretHorizontal())
		ped->TxCreateCaret(_hbmpCaret, dx, _dvpCaret);
	else
		ped->TxCreateCaret(_hbmpCaret, _dvpCaret, dx);

	_fCaretCreated = TRUE;

	LONG xShift = _hbmpCaret ? 2 : 0;
	if(fItalic)
	{
		// TODO: figure out better shift algorithm. Use CCcs::_xOverhang?
		if(pCF->_iFont == IFONT_TMSNEWRMN)
			xShift = 4;
		xShift += y/16;
	}
	xShift = _upCaret - xShift;

	if (_pdp->GetTflow() == tflowSW || _pdp->GetTflow() == tflowWN)
		ped->TxSetCaretPos(xShift, _vpCaret + _dvpCaret);
	else
		ped->TxSetCaretPos(xShift, _vpCaret);

}

/*
 *	CTxtSelection::DeleteCaretBitmap (fReset)
 *
 *	@mfunc	DeleteCaretBitmap
 */
void CTxtSelection::DeleteCaretBitmap(
	BOOL fReset)
{
	if(_hbmpCaret)
	{
		DestroyCaret();
		DeleteObject((void *)_hbmpCaret);
		_hbmpCaret = NULL;
	}
	if(fReset)
		_dwCaretInfo = 0;
}

/*
 *	CTxtSelection::SetDelayedSelectionRange	(cp, cch)
 *
 *	@mfunc	sets the selection range such that it won't take effect until
 *			the control is "stable"
 */
void CTxtSelection::SetDelayedSelectionRange(
	LONG	cp,			//@parm Active end
	LONG	cch)		//@parm Signed extension
{
	CSelPhaseAdjuster *pspa;

	pspa = (CSelPhaseAdjuster *)GetPed()->GetCallMgr()->GetComponent(
						COMP_SELPHASEADJUSTER);
	Assert(pspa);
	pspa->CacheRange(cp, cch);
}

/*
 *	CTxtSelection::CheckPlainTextFinalEOP ()
 *
 *	@mfunc
 *		returns TRUE if this is a plain-text, multiline control with caret
 *		allowed at BOL and the selection at the end of the story following
 *		and EOP
 *
 *	@rdesc
 *		TRUE if all of the conditions above are met
 */
BOOL CTxtSelection::CheckPlainTextFinalEOP()
{
	return !IsRich() && _pdp->IsMultiLine() &&		// Plain-text, multiline
		   !_fCaretNotAtBOL &&						//  with caret OK at BOL,
		   GetCp() == GetTextLength() &&			//  & cp at end of story
		   _rpTX.IsAfterEOP();
}

/*
 *	CTxtSelection::StopGroupTyping()
 *
 *	@mfunc
 *		Tell undo manager to stop group typing
 */
void CTxtSelection::StopGroupTyping()
{
	IUndoMgr * pundo = GetPed()->GetUndoMgr();

	CheckTableIP(FALSE);
	if(pundo)
		pundo->StopGroupTyping();
}

/*
 *	CTxtSelection::SetupDualFont()
 *
 *	@mfunc	checks to see if dual font support is necessary; in this case,
 *			switching to an English font if English text is entered into
 *			an FE run
 *	@rdesc
 *		A pointer to the current CharFormat if the font has to be changed.
 */
void CTxtSelection::SetupDualFont()
{
	CTxtEdit *	ped = GetPed();
	CCharFormat CF;

	CF._iCharRep = ANSI_INDEX;
	CCFRunPtr	rp(*this);

	if (rp.GetPreferredFontInfo(
			ANSI_INDEX,
			CF._iCharRep,
			CF._iFont,
			CF._yHeight,
			CF._bPitchAndFamily,
			_iFormat,
			IGNORE_CURRENT_FONT))
	{
		if (!_cch)
			SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0); 
		else
		{
			// For selection, we need to set the character format at cpMin+1
			// and use the format for the selection.
			CTxtRange rg(ped, GetCpMin() + 1, 0);
			rg.SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0); 			
			Set_iCF(rg.Get_iCF());
			GetCharFormatCache()->Release(_iFormat);	// rg.Get_iCF() AddRefs it	
			_fUseiFormat = TRUE;
		}

		SetDualFontMode(TRUE);
	}
}

//
//	CSelPhaseAdjuster methods
//

/* 
 *	CSelPhaseAdjuster::CSelPhaseAdjuster (ped)
 *
 *	@mfunc	constructor
 */
CSelPhaseAdjuster::CSelPhaseAdjuster(
	CTxtEdit *ped)		//@parm the edit context
{
	_cp = _cch = -1;
	_ped = ped;	
	_ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this, 
							COMP_SELPHASEADJUSTER);
}

/* 
 *	CSelPhaseAdjuster::~CSelPhaseAdjuster()
 *
 *	@mfunc	destructor
 */
CSelPhaseAdjuster::~CSelPhaseAdjuster()
{
	// Save some indirections
	CTxtEdit *ped = _ped;

	if(_cp != -1)
	{
		ped->GetSel()->SetSelection(_cp - _cch, _cp);

		// If the selection is updated, then we invalidate the
		// entire display because the old selection can still
		// appear otherwise because the part of the screen that
		// it was on is not updated.
		if(ped->fInplaceActive())
		{
			// Tell entire client rectangle to update.
			// FUTURE: The smaller we make this the better.
			ped->TxInvalidate();
		}
	}
	ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);
}

/* 
 *	CSelPhaseAdjuster::CacheRange(cp, cch)
 *
 *	@mfunc	tells this class the selection range to remember
 */
void CSelPhaseAdjuster::CacheRange(
	LONG	cp,			//@parm Active end to remember
	LONG	cch)		//@parm Signed extension to remember
{
	_cp		= cp;
	_cch	= cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\rtfwrit2.cpp ===
/*
 *	rtfwrit2.cpp
 *
 *	Description:
 *		This file contains the embedded-object implementation of the RTF
 *		writer for the RICHEDIT subsystem.
 *
 *	Authors:
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"


#include "_rtfwrit.h"
#include "_coleobj.h"

ASSERTDATA

extern const CHAR szEndGroupCRLF[];

#define	WHITE	RGB(255, 255, 255)

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.
#if defined(CONVERT2BPP) 

#define PWDV1_BPP   2

typedef struct 
{
    BITMAPINFOHEADER bmih;
    RGBQUAD          colors[4];
}
BMI2BPP;

const BYTE ColorTable2bpp[] = 
{
    0x00, 0x00, 0x00, 0x00, 
    0x55, 0x55, 0x55, 0x00, 
    0xAA, 0xAA, 0xAA, 0x00, 
    0xFF, 0xFF, 0xFF, 0x00
};
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

static const CHAR szShapeLeadIn[]	= "{\\shp{\\*\\shpinst\r\n";
static const CHAR szShapeFillBlip[]	= "{\\sp{\\sn fillBlip}{\\sv ";
static const CHAR szShapeParm[]		= "{\\sp{\\sn %s}{\\sv %d}}\r\n";
static const CHAR szHexDigits[]		= "0123456789abcdef";
static const CHAR szLineBreak[]		= "\r\n";

const BYTE ObjectKeyWordIndexes [] =
{
	i_objw, i_objh, i_objscalex, i_objscaley, i_objcropl, i_objcropt, i_objcropr, i_objcropb
} ;

const BYTE PictureKeyWordIndexes [] =
{
	i_picw, i_pich, i_picscalex, i_picscaley, i_piccropl, i_piccropt, i_piccropr, i_piccropb
} ;

// TODO join with rtfwrit.cpp

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s"
};

static const WORD IndexROT[] =
{
	i_wbitmap,
	i_wmetafile,
	i_dibitmap,
	i_jpegblip,
	i_pngblip,
	i_objemb,
	i_objlink,
	i_objautlink
};


TFI *CRTFConverter::_rgtfi = NULL;				// @cmember Ptr to 1st font substitute record
INT CRTFConverter::_ctfi = 0;				    // @cmember Count of font substitute records
WCHAR *CRTFConverter::_pchFontSubInfo = NULL;	// @cmember Font name info


// internal table to insert charset into _rgtfi under winNT
typedef		struct
{
	WCHAR*	szLocaleName;
	BYTE	iCharRep;
} NTCSENTRY;

const NTCSENTRY	mpszcs[] =
{
	{ TEXT("cyr"),		204 },		// All lower case so we don't have to waste time
	{ TEXT("ce"),		238 },		// doing a tolower below - Exchange2 800
	{ TEXT("greek"),	161 },
	{ NULL,				0 }			// sentinel
};
#define		cszcs	ARRAY_SIZE(mpszcs)


/* 
 *  RemoveAdditionalSpace (sz)
 *
 *  @func 
 *		Remove first and last space from the string 
 *		Only one space will remain between words
 */
void RemoveAdditionalSpace(
	WCHAR *sz)		//@parm Character string to remove space from
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "RemoveAdditionalSpace");

	WCHAR *szSource = sz;
	WCHAR *szDestination = sz;

	while(*szSource == TEXT(' ') || *szSource == TAB)
		*szSource++;

	while(*szSource)
	{	 
		if(*szSource != TEXT(' ') && *szSource != TAB)
			*szDestination++ = *szSource++;
		else
		{
			*szDestination++ = TEXT(' ');
			szSource++;
			while(*szSource == TEXT(' ') || *szSource == TAB)
				*szSource++;
	 	}
	}
	*szDestination = TEXT('\0');
}

/*
 *	CRTFConverter::FreeFontSubInfo()
 * 
 *	@mfunc	release any allocated memory for font substitutions
 */
void CRTFConverter::FreeFontSubInfo()
{
	FreePv(_pchFontSubInfo);
	FreePv(_rgtfi);
	_pchFontSubInfo = NULL;
	_rgtfi = NULL;
}

/*
 *	CRTFConverter::ReadFontSubInfo()
 *
 *	@mfunc				  
 *		Read the table of Font Substitutes and parse out the tagged fonts
 *
 *	@rdesc
 *		BOOL  TRUE	if OK
 */
void CRTFConverter::ReadFontSubInfo()
{
#ifndef NOFONTSUBINFO 
	CLock clock;
	int cchBuffer = 600;	// Approximately the amount used by NT

	int cch;
	static const WCHAR szFontSubSection[] = TEXT("FontSubstitutes");
	WCHAR *pchTMax;

	if(_ctfi)
		return;

	AssertSz(!_rgtfi, "CRTFConverter::ReadFontSubInfo():  Who donated the rgtfi?");

	_pchFontSubInfo = (WCHAR *)PvAlloc(cchBuffer * sizeof(WCHAR), GMEM_FIXED);
	if(!_pchFontSubInfo)
		goto Cleanup;

next_try:
	cch = GetProfileSection(szFontSubSection, _pchFontSubInfo, cchBuffer);
	if(cch >= cchBuffer - 2)				// GetProfileSection() magic number 2
	{							
		const INT cchT = cchBuffer * 2;		// Didn't fit, double the buffer size

		if(cchT < cchBuffer)				// >32k 
			goto Cleanup;

		cchBuffer = cchT;
		_pchFontSubInfo = (WCHAR *)PvReAlloc(_pchFontSubInfo, cchT * sizeof(WCHAR));
		if(!_pchFontSubInfo)
			goto Cleanup;
		goto next_try;
	}
	else if(!cch)
		*_pchFontSubInfo = 0;

	else									// Fits, now resize _pchFontSubInfo
		_pchFontSubInfo = (WCHAR*) PvReAlloc(_pchFontSubInfo, (cch) * sizeof(WCHAR));

	_ctfi = 12;								// A preliminary guess

	_rgtfi = (TFI *)PvAlloc(_ctfi * sizeof(TFI), GMEM_FIXED);
	if(_rgtfi)
	{
		TFI *	ptfi = &_rgtfi[0];;
		WCHAR *	pchT = _pchFontSubInfo;
		pchTMax = _pchFontSubInfo + cch;

		WCHAR *	szTaggedName;
		WCHAR *	szNonTaggedName;
		BOOL	fGotTaggedCharSet;
		BOOL	fGotNonTaggedCharSet;
		BYTE	iCharRepTagged;
		BYTE	iCharRepNonTagged;
		PARSEFONTNAME iParseLeft;
		PARSEFONTNAME iParseRight;

		// Parse the entries. We are interested in the following strings:
		//
		// <tagged font name> = <nontagged font name>
		//		(where <nontagged font name> = <tagged font name> - <tag>
		// <font1 name>,<font1 charset> = <font2 name>
		// <tagged font name> = <nontagged font name>,<nontagged font charset>
		//		(where <nontagged font charset> = <tag>)
		// <font1 name>,<font1 charset> = <font2 name>,<font2 charset>
		//		(where <font1 charset> == <font2 charset>)

		iParseLeft = iParseRight = PFN_SUCCESS;

		while(pchT < pchTMax && iParseLeft != PFN_EOF
							&& iParseRight != PFN_EOF)
		{
			fGotTaggedCharSet = FALSE;
			fGotNonTaggedCharSet = FALSE;

			if((iParseLeft = ParseFontName(pchT,
							pchTMax,
							TEXT('='),
							&szTaggedName, 
							iCharRepTagged, 
							fGotTaggedCharSet, 
							&pchT)) == PFN_SUCCESS &&
				(iParseRight = ParseFontName(pchT, 
							pchTMax,
							TEXT('\0'),
							&szNonTaggedName, 
							iCharRepNonTagged, 
							fGotNonTaggedCharSet, 
							&pchT)) == PFN_SUCCESS)
			{
				Assert(szTaggedName && szNonTaggedName);

				BYTE iCharRep;
				if(!fGotTaggedCharSet)
				{
					if(!FontSubstitute(szTaggedName, szNonTaggedName, &iCharRep))
						continue;
				}
				else
					iCharRep = iCharRepTagged;

				if(fGotNonTaggedCharSet && iCharRep != iCharRepNonTagged)
					continue;

				// We have a legitimate tagged/nontagged pair, so save it.
				ptfi->szTaggedName = szTaggedName;
				ptfi->szNormalName = szNonTaggedName;
				ptfi->iCharRep = iCharRep;
				ptfi++;

    			if(DiffPtrs(ptfi, &_rgtfi[0]) >= (UINT)_ctfi)
				{
					// allocate some more
					_rgtfi = (TFI *)PvReAlloc(_rgtfi, (_ctfi + cszcs) * sizeof(TFI));
					if(!_rgtfi)
						goto Cleanup;
					ptfi = _rgtfi + _ctfi;
					_ctfi += cszcs;
				}
			}
		}
		_ctfi = DiffPtrs(ptfi, &_rgtfi[0]);
		if(_ctfi)
			return;
	}

Cleanup:
	if(_pchFontSubInfo)
	{
		FreePv(_pchFontSubInfo);
		_pchFontSubInfo = NULL;
	}
	if(_rgtfi)
	{
		FreePv(_rgtfi);
		_rgtfi = NULL;
	}
	_ctfi = 0;
	return;
#endif // NOFONTSUBINFO
}

/*
 *	CRTFConverter::ParseFontName(pchBuf, pchBufMax, chDelimiter, pszName,
 *								 &iCharRep, &fSetCharSet, ppchBufNew)
 *
 *	@mfunc
 *		Parses from the input buffer, pchBuf, a string of the form:
 *			{WS}*<font_name>{WS}*[,{WS}*<char_set>{WS}*]
 *		and sets:
 *			pszName = <font_name>
 *			bCharSet = <char_set>
 *			fSetCharSet = (bCharSet set by proc) ? TRUE : FALSE
 *			ppchBufNew = pointer to point in pchBuf after parsed font name
 *
 *	@rdesc
 *		BOOL  TRUE	if OK
 */
CRTFConverter::PARSEFONTNAME CRTFConverter::ParseFontName(
	WCHAR *	pchBuf,				//@parm IN: buffer
	WCHAR *	pchBufMax,			//@parm IN: last char in buffer
	WCHAR	chDelimiter,		//@parm IN:	char which delimits font name
	WCHAR **pszName,			//@parm OUT: parsed font name
	BYTE &	iCharRep,			//@parm OUT: parsed font character repertoire
	BOOL &	fSetCharSet,		//@parm OUT: char set parsed?
	WCHAR **ppchBufNew) const	//@parm OUT: ptr to next font name in input buffer
{
	PARSEFONTNAME iRet = PFN_SUCCESS;

	Assert(pchBuf && pchBufMax >= pchBuf && pszName && ppchBufNew);

	fSetCharSet = FALSE;
	*pszName = pchBuf;
	
	if(pchBuf > pchBufMax)
		return PFN_EOF;

	while(*pchBuf && *pchBuf != TEXT(',') && *pchBuf != chDelimiter)
	{
		pchBuf++;
		if(pchBuf > pchBufMax)
			return PFN_EOF;
	}

	WCHAR chTemp = *pchBuf;
	*pchBuf = TEXT('\0');
	RemoveAdditionalSpace(*pszName);

	if(chTemp == TEXT(','))
	{
		WCHAR *szCharSet = ++pchBuf;

		while(*pchBuf && *pchBuf != chDelimiter)
		{
			pchBuf++;
			if(pchBuf > pchBufMax)
				return PFN_EOF;
		}

		chTemp = *pchBuf;

		if(chTemp != chDelimiter)
			goto UnexpectedChar;

		*pchBuf = TEXT('\0');
		RemoveAdditionalSpace(szCharSet);

		BYTE bCharSet = 0;
		while(*szCharSet >= TEXT('0') && *szCharSet <= TEXT('9'))
		{
			bCharSet *= 10;
			bCharSet += *szCharSet++ - TEXT('0');
		}
		iCharRep = CharRepFromCharSet(bCharSet);
		fSetCharSet = TRUE;
		// iRet = PFN_SUCCESS;	(done above)
	}
	else if(chTemp == chDelimiter)
	{
		// fSetCharSet = FALSE;	(done above)
		// iRet = PFN_SUCCESS;	(done above)
	}
	else // chTemp == 0
	{
UnexpectedChar:
		Assert(!chTemp);
		// fSetCharSet = FALSE; (done above)
		iRet = PFN_FAIL;
	}

	// We had to at least get a font name out of this
	if(!**pszName)
		iRet = PFN_FAIL;

	// Advance past the delimiter (or NULL char if malformed buffer)
	Assert(chTemp == chDelimiter || iRet != PFN_SUCCESS && chTemp == TEXT('\0'));
	pchBuf++;
	*ppchBufNew = pchBuf;

	return iRet;
}

/*
 *	CRTFConverter::FontSubstitute(szTaggedName, szNormalName, pbCharSet)
 *
 *	@mfunc
 *		Verify that szTaggedName is szNormalName plus char set tag 
 *		If yes than write corresponding charSet tp pbCharSet
 *
 *	@rdesc
 *		BOOL
 */
BOOL CRTFConverter::FontSubstitute(
	WCHAR *szTaggedName,	//@parm Name with tag
	WCHAR *szNormalName,	//@parm Name without tag
	BYTE * piCharRep) 		//@parm Where to write charset
{
	const NTCSENTRY *pszcs = mpszcs;

	Assert(szTaggedName && szNormalName && piCharRep && *szTaggedName);

	// Ensure same name, except for prefix
	while(*szNormalName == *szTaggedName)
	{
		*szNormalName++;
		*szTaggedName++;
	}
	
	// Verify that we have reached the end of szNormalName
	while(*szNormalName)
	{
		if(*szNormalName != TEXT(' ') && *szNormalName != TAB)
			return FALSE;
		szNormalName++;
	}

	szTaggedName++;
	while(pszcs->iCharRep)
	{
		if(!lstrcmpi(szTaggedName, pszcs->szLocaleName))
		{ 
			*piCharRep = pszcs->iCharRep;
			return TRUE;
		}
		pszcs++;
	}

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	char szBuf[MAX_PATH];
    char szTag[256];
	
	WideCharToMultiByte(CP_ACP, 0, szTaggedName, -1, szTag, sizeof(szTag), 
							NULL, NULL);

	sprintf(szBuf, "CRTFConverter::FontSubstitute():  Unrecognized tag found at"
					" end of tagged font name - \"%s\" (Raid this asap)", szTag);
	
	TRACEWARNSZ(szBuf);
#endif

	return FALSE;
}

/*
 *	CRTFConverter::FindTaggedFont(*szNormalName, bCharSet, ppchTaggedName)
 *
 *	@mfunc												   
 *		Find font name may be with additional special tag corresponding to
 *		szNormalName & bCharSet
 *
 *	@rdesc
 *		BOOL	TRUE if find
 */
BOOL CRTFConverter::FindTaggedFont(
	const WCHAR *szNormalName,		//@parm Font name in RTF
	BYTE 		 iCharRep, 			//@parm RTF charset
	WCHAR **	 ppchTaggedName)	//@parm Where to write tagged name
{
	if(!_rgtfi)
		return FALSE;

	for(int itfi = 0; itfi < _ctfi; itfi++)
	{
		if(_rgtfi[itfi].iCharRep == iCharRep &&
			!lstrcmpi(szNormalName, _rgtfi[itfi].szNormalName))
		{
			*ppchTaggedName = _rgtfi[itfi].szTaggedName;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	CRTFConverter::IsTaggedFont(szName, piCharRep, ppchNormalName)
 *
 *	@mfunc												   
 *		Figure out is szName font name with additional tag corresponding to pbCharSet
 *		If no charset specified, still try to match	 and return the correct charset
 *
 *	@rdesc
 *		BOOL			TRUE if is
 */
BOOL CRTFConverter::IsTaggedFont(
	const WCHAR *szName,			//@parm Font name in RTF
	BYTE *		 piCharRep, 		//@parm RTF charset
	WCHAR **	 ppchNormalName)	//@parm Where to write normal name
{
	if(!_rgtfi)
		return FALSE;

	for(int itfi = 0; itfi < _ctfi; itfi++)
	{
		if((*piCharRep <= 1 || _rgtfi[itfi].iCharRep == *piCharRep) &&
			!lstrcmpi(szName, _rgtfi[itfi].szTaggedName))
		{
			*piCharRep = _rgtfi[itfi].iCharRep;
			*ppchNormalName = _rgtfi[itfi].szNormalName;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	CRTFWrite::WriteData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Write out object data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	@rdesc
 *		LONG	count of bytes written out
 */
LONG CRTFWrite::WriteData(
	BYTE *	pbBuffer,	//@parm Point to write buffer 
	LONG	cbBuffer)	//@parm Count of bytes to write out
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;						// Put out hex value of byte
		PutChar(szHexDigits[bT >> 4]);			// Store high nibble
		PutChar(szHexDigits[bT & 15]);		// Store low nibble

		// Every 78 chars and at end of group, drop a line
		if (!(++cb % 39) || (cb == cbBuffer)) 
			Puts(szLineBreak, sizeof(szLineBreak) - 1);
	}
	return cb;
}

/*
 *	CRTFWrite::WriteBinData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Write out object binary data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	@rdesc
 *		LONG	count of bytes written out
 */
LONG CRTFWrite::WriteBinData(
	BYTE *	pbBuffer,	//@parm Point to write buffer 
	LONG	cbBuffer)	//@parm Count of bytes to write out
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;
		if (!PutChar(bT))
			break;
		cb++;
	}
	return cb;
}

/*
 *	CRTFWrite::WriteRtfObject(prtfObject, fPicture)
 *
 *	@mfunc
 *		Writes out an picture or object header's render information
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote
 *		Eventually use keywords from rtf input list rather than partially
 *		creating them on the fly
 */
EC CRTFWrite::WriteRtfObject(
	RTFOBJECT & rtfObject,	//@parm Object header info
	BOOL		fPicture)	//@parm TRUE if this is a header for a picture/object
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtfObject");

	LONG		i;
	LONG *		pDim = &rtfObject.xExt;
	const BYTE *pKeyWordIndex = ObjectKeyWordIndexes;

	if(fPicture)
	{
		pKeyWordIndex = PictureKeyWordIndexes;
		if(rtfObject.sType == ROT_Metafile)
			pDim = &rtfObject.xExtPict;
	}

	//Extents, e.g., \picw,\pich
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim)
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}

	// Scaling, e.g., \picscalex, \picscaley
	pDim = &rtfObject.xScale;
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim && *pDim != 100)
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}
	// Cropping, e.g., \piccropl, \piccropt, piccropr, \piccropb
	pDim = &rtfObject.rectCrop.left;
	for(i = 4; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim)
		   	PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}
	// Write goal sizes
	if(fPicture)
	{
		if (rtfObject.xExtGoal)
			PutCtrlWord (CWF_VAL, i_picwgoal, rtfObject.xExtGoal);

		if (rtfObject.yExtGoal)
			PutCtrlWord (CWF_VAL, i_pichgoal, rtfObject.yExtGoal);
	}
	return _ecParseError;
}

/*
 *	CRTFWrite::WritePicture(&rtfObject)
 *
 *	@func
 *		Writes out a picture's header as well as the object's data.
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFWrite::WritePicture(
	RTFOBJECT & rtfObject)	//@parm Object header info
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	_ecParseError = ecStreamOutObj;

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write what kind of picture this is. Default JPEG or PNG
	LONG iFormat = CWF_STR;
	LONG sType = rtfObject.sType;

	if(sType != ROT_JPEG && sType != ROT_PNG)
	{
		sType = ROT_Metafile;
		iFormat = CWF_VAL;
	}
	PutCtrlWord(iFormat, IndexROT[sType], rtfObject.sPictureType);

	// Write picture render details
	WriteRtfObject(rtfObject, TRUE);

	// Start picture data
	Puts(szLineBreak, sizeof(szLineBreak) - 1);

	// Write out the data
	if ((UINT) WriteData(rtfObject.pbResult, rtfObject.cbResult) != rtfObject.cbResult)
	   goto CleanUp;

	_ecParseError = ecNoError;

CleanUp:
	PutChar(chEndGroup);					// End picture data
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteDib(&rtfObject)
 *
 *	@mfunc
 *		Writes out an DIB primarily for Win CE
 *
 *	@rdesc
 *			EC		The error code
 *
 *	@devnote
 *		*** Writes only dibs ***
 */
EC CRTFWrite::WriteDib(
	RTFOBJECT & rtfObject)		//@parm Object header info
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	LPBITMAPINFO pbmi = (LPBITMAPINFO) rtfObject.pbResult;

	_ecParseError = ecStreamOutObj;

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.

    // Store the original values so we can restore them on exit.
	LPBYTE  pbResult = rtfObject.pbResult;
	ULONG   cbResult = rtfObject.cbResult;
    HGLOBAL hMem2bpp = 0;

#if defined(CONVERT2BPP) 

    // Pictures must be saved as 2bpp if saving to PWord V1 format.
	if((_dwFlags & SFF_PWD) && ((_dwFlags & SFF_RTFVAL) >> 16 == 0))
    {
        if(pbmi->bmiHeader.biBitCount > PWDV1_BPP)
        {
            HWND         hWnd;
            HDC          hdc, hdcSrc, hdcDst;
            HBITMAP      hdibSrc, hdibDst; 
            LPBYTE       pbDibSrc, pbDibDst;
            BMI2BPP      bmi2bpp = {0};
            int          iOffset, nBytes;

            // First get a dc with the source dib in it.
            hWnd   = GetDesktopWindow();
            hdc    = GetDC(hWnd);
	        hdcSrc = CreateCompatibleDC(hdc);

            // Using CreateDIBSection below ensures that the working dibs and dcs will get a
            // bpp of the appropriate dib, not a bpp based on the bpp of the device display.
            if((hdibSrc = CreateDIBSection(hdcSrc, pbmi, DIB_RGB_COLORS, (void**)&pbDibSrc, NULL, 0)))
            {
                SelectObject(hdcSrc, hdibSrc);

                // Get an offset to the source bits
                iOffset = sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * (1<<pbmi->bmiHeader.biBitCount));
                memcpy(pbDibSrc, &rtfObject.pbResult[iOffset], rtfObject.cbResult - iOffset);

                // Build up a BITMAPINFO appropriate for a 2bpp dib
                bmi2bpp.bmih = pbmi->bmiHeader;
                bmi2bpp.bmih.biBitCount = PWDV1_BPP;

                // Add the 4 color color-table
                memcpy(bmi2bpp.colors, (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                // Create the new dib
    	        hdcDst = CreateCompatibleDC(hdc);

            	if((hdibDst = CreateDIBSection(hdcDst, (BITMAPINFO*)&bmi2bpp, DIB_RGB_COLORS, (void**)&pbDibDst, NULL, 0)))
                {
                    SelectObject(hdcDst, hdibDst);

                    // Blit the > 2bpp dib into the 2bpp dib and let the system do the color mapping.
                    BitBlt(hdcDst, 0, 0, bmi2bpp.bmih.biWidth, bmi2bpp.bmih.biHeight, hdcSrc, 0, 0, SRCCOPY);

                    // Calculate the new bytes per line for the 2bpp dib.
                    rtfObject.cBytesPerLine = (((bmi2bpp.bmih.biWidth * PWDV1_BPP) + 31) & ~31) / 8; // DWORD boundary.

                    // Get the new size of the 2bpp byte array
                    nBytes = rtfObject.cBytesPerLine * bmi2bpp.bmih.biHeight;

                    // Get total size of 2bpp dib, (including header and 4 color color-table)
                    cbResult = sizeof(bmi2bpp) + nBytes;

                    // Don't change the input pbResult as that is the internal representation of 
                    // the dib. This conversion to 2bpp is only for writing to the output file.
                    if((hMem2bpp = GlobalAlloc(GMEM_FIXED, cbResult)))
                    {
                        if((pbResult = (LPBYTE)GlobalLock(hMem2bpp)))
                        {
                            // Copy in the dib header.
                            memcpy(pbResult, &bmi2bpp.bmih, sizeof(BITMAPINFOHEADER));

                            // Copy in the 4 color color-table.
                            memcpy(&pbResult[sizeof(BITMAPINFOHEADER)], (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                            // Now copy in the byte array.
                            memcpy(&pbResult[sizeof(bmi2bpp)], pbDibDst, nBytes);
                    	    _ecParseError = ecNoError;
                        }
                    }
                    DeleteObject(hdibDst);
                }
                DeleteDC(hdcDst);
                DeleteObject(hdibSrc);
            }
            DeleteDC(hdcSrc);
            ReleaseDC(hWnd, hdc);
            if(_ecParseError != ecNoError)
                goto CleanUp;
        }
    }
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write that this is dib 
	PutCtrlWord( CWF_VAL, i_dibitmap,rtfObject.sPictureType );

	// V-GUYB:
    // rtfObject.*Scale is not updated as the user stretches the picture, 
    // so don't use those here. But rtfObject.*Ext has been set up in the 
    // calling routine to account for the current site dimensions.
	PutCtrlWord( CWF_VAL, i_picscalex, (rtfObject.xExt * 100) /  rtfObject.xExtGoal);
	PutCtrlWord( CWF_VAL, i_picscaley, (rtfObject.yExt * 100) /  rtfObject.yExtGoal);

	// Write picture render details
	PutCtrlWord( CWF_VAL, i_picw, pbmi->bmiHeader.biWidth );
	PutCtrlWord( CWF_VAL, i_pich, pbmi->bmiHeader.biHeight );
	PutCtrlWord( CWF_VAL, i_picwgoal, rtfObject.xExtGoal );
	PutCtrlWord( CWF_VAL, i_pichgoal, rtfObject.yExtGoal );
	PutCtrlWord( CWF_VAL, i_wbmbitspixel, pbmi->bmiHeader.biBitCount );
	PutCtrlWord( CWF_VAL, i_wbmplanes, pbmi->bmiHeader.biPlanes );
	PutCtrlWord( CWF_VAL, i_wbmwidthbytes, rtfObject.cBytesPerLine );

	// Write out the data
	PutCtrlWord( CWF_VAL, i_bin, cbResult );
	if ((UINT) WriteBinData( pbResult, cbResult ) != cbResult)
	{
		// This "recovery" action needs to be rethought.  There is no way
		// the reader will be able to get back in synch.
	   goto CleanUp;
	}
	_ecParseError = ecNoError;

CleanUp:
    // Did we lock or allocate some temporary space for a 2bpp dib?
    if(rtfObject.pbResult != pbResult)
        GlobalUnlock(pbResult);		// Yes, so unlock it now

    if(hMem2bpp)
        GlobalFree(hMem2bpp);

    // Restore original values.
  	rtfObject.pbResult = pbResult;
    rtfObject.cbResult = cbResult;

	PutChar(chEndGroup);					// End picture data

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteObject(cp, pobj)
 *
 *	@mfunc
 *		Writes out an object's header as well as the object's data.
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFWrite::WriteObject(
	LONG		cp,		//@parm Object char position 
	COleObject *pobj)	//@parm Object
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteObject");

	RTFOBJECT	rtfObject;
	REOBJECT	reObject = {sizeof(REOBJECT), cp} ;

	Assert(pobj);

	if (pobj->GetObjectData(&reObject, REO_GETOBJ_POLESITE 
						| REO_GETOBJ_PSTG | REO_GETOBJ_POLEOBJ))	// todo fix Release
	{
		TRACEERRORSZ("Error geting object ");
	}

	GetRtfObject(reObject, rtfObject);

	HGLOBAL hdata = pobj->GetHdata();
	if (hdata)
	{
		COleObject::ImageInfo *pimageinfo = pobj->GetImageInfo();
		rtfObject.pbResult = (LPBYTE) GlobalLock( hdata );
		rtfObject.cbResult = GlobalSize( hdata );
		rtfObject.sType = ROT_DIB;
		rtfObject.xExt = (SHORT) TwipsFromHimetric( reObject.sizel.cx );
		rtfObject.yExt = (SHORT) TwipsFromHimetric( reObject.sizel.cy );
		rtfObject.xScale = pimageinfo->xScale;
		rtfObject.yScale = pimageinfo->yScale;
		rtfObject.xExtGoal = pimageinfo->xExtGoal;
		rtfObject.yExtGoal = pimageinfo->yExtGoal;
		rtfObject.cBytesPerLine = pimageinfo->cBytesPerLine;
		WriteDib(rtfObject);
		GlobalUnlock( rtfObject.pbResult );

		// Make sure to release otherwise the object won't go away
		if (reObject.pstg)	reObject.pstg->Release();
		if (reObject.polesite) reObject.polesite->Release();
		if (reObject.poleobj) reObject.poleobj->Release();

		return _ecParseError;
	}

	switch(rtfObject.sType)					// Handle pictures in our own
	{										//  special way
	case ROT_Embedded:
	case ROT_Link:
	case ROT_AutoLink:
		break;

	case ROT_Metafile:
	case ROT_DIB:
	case ROT_Bitmap:
		 WritePicture(rtfObject);
		 goto CleanUpNoEndGroup; 

#ifdef DEBUG
	default:
		AssertSz(FALSE, "CRTFW::WriteObject: Unknown ROT");
		break;
#endif DEBUG
	}

	// Start and write object group
	PutCtrlWord( CWF_GRP, i_object );
	PutCtrlWord( CWF_STR, IndexROT[rtfObject.sType] );
//	PutCtrlWord(CWF_STR, i_objupdate);		// TODO may be it needs more smart decision 

	if (rtfObject.szClass)  				// Write object class
	{
		PutCtrlWord(CWF_AST, i_objclass); 
		WritePcData(rtfObject.szClass);
		PutChar(chEndGroup);
	}

	if (rtfObject.szName)					// Write object name
	{
		PutCtrlWord(CWF_AST, i_objname); 
		WritePcData(rtfObject.szName);
		PutChar( chEndGroup );
	}

	if (rtfObject.fSetSize)					// Write object sizing options
		PutCtrlWord(CWF_STR, i_objsetsize);

	WriteRtfObject( rtfObject, FALSE ) ;			// Write object render info
	PutCtrlWord( CWF_AST, i_objdata ) ;				//  info, start object
	Puts( szLineBreak, sizeof(szLineBreak) - 1);	//  data group

	if (!ObjectWriteToEditstream( reObject, rtfObject ))
	{
		TRACEERRORSZ("Error writing object data");
		if (!_ecParseError)
			_ecParseError = ecStreamOutObj;
		PutChar( chEndGroup );						// End object data
		goto CleanUp;
	}

	PutChar( chEndGroup );							// End object data

	PutCtrlWord( CWF_GRP, i_result );				// Start results group
	WritePicture( rtfObject );			 			// Write results group
	PutChar( chEndGroup ); 							// End results group

CleanUp:
	PutChar( chEndGroup );						    // End object group

CleanUpNoEndGroup:
	if (reObject.pstg)	reObject.pstg->Release();
	if (reObject.polesite) reObject.polesite->Release();
	if (reObject.poleobj) reObject.poleobj->Release();
	if (rtfObject.pbResult)
	{
		HGLOBAL hmem;

		hmem = GlobalHandle( rtfObject.pbResult );
		GlobalUnlock( hmem );
		GlobalFree( hmem );
	}
	if (rtfObject.szClass)
		CoTaskMemFree( rtfObject.szClass );

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteBackgroundInfo(pDocInfo)
 *
 *	@mfunc
 *		Write out screen background data if a background is enabled.
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFWrite::WriteBackgroundInfo(
	CDocInfo *pDocInfo)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteInfo");

	if (!PutCtrlWord(CWF_AST, i_background))
		goto CleanUp2;

	if (!Puts(szShapeLeadIn, sizeof(szShapeLeadIn) - 1) ||
		!PutShapeParm(i_filltype, pDocInfo->_nFillType) ||
		pDocInfo->_sFillAngle && !PutShapeParm(i_fillangle, pDocInfo->_sFillAngle << 16) ||
		pDocInfo->_crColor != WHITE && !PutShapeParm(i_fillcolor, pDocInfo->_crColor) ||
		pDocInfo->_crBackColor != WHITE && !PutShapeParm(i_fillbackcolor, pDocInfo->_crBackColor) ||
		!PutShapeParm(i_fillfocus, pDocInfo->_bFillFocus))
	{
		goto CleanUp;
	}
	if(pDocInfo->_bPicFormat != 0xFF)
	{
		RTFOBJECT rtfObject;
		// Blank out the full structure
		ZeroMemory(&rtfObject, sizeof(RTFOBJECT));

		// Build the header
		if(pDocInfo->_hdata)
		{
			rtfObject.pbResult	= (LPBYTE) GlobalLock(pDocInfo->_hdata);
			rtfObject.cbResult	= GlobalSize(pDocInfo->_hdata);
		}
		rtfObject.xExt			= pDocInfo->_xExt;
		rtfObject.yExt			= pDocInfo->_yExt;
		rtfObject.xScale		= pDocInfo->_xScale;
		rtfObject.yScale		= pDocInfo->_yScale;
		rtfObject.xExtGoal		= pDocInfo->_xExtGoal;
		rtfObject.yExtGoal		= pDocInfo->_yExtGoal;
		rtfObject.xExtPict		= pDocInfo->_xExtPict;
		rtfObject.yExtPict		= pDocInfo->_yExtPict;
		rtfObject.rectCrop		= pDocInfo->_rcCrop;
		rtfObject.sType			= pDocInfo->_bPicFormat;
		rtfObject.sPictureType	= pDocInfo->_bPicFormatParm;
		if(Puts(szShapeFillBlip, sizeof(szShapeFillBlip) - 1))
		{
			WritePicture(rtfObject);
			PutChar(chEndGroup);			// Close {\sv {\pict...}}
			PutChar(chEndGroup);			// Close {\sp{\sn...}{\sv...}}
		}
		if(pDocInfo->_hdata)
			GlobalUnlock(pDocInfo->_hdata);
	}

CleanUp:
	PutChar(chEndGroup);					// Close {\*\shpinst...}
	PutChar(chEndGroup);					// Close {\shp...}

CleanUp2:
	Puts(szEndGroupCRLF, 3);				// Close {\*\background...}
	return _ecParseError;
}

/*
 *	CRTFWrite::PutShapeParm(iCtrl, iValue)
 *
 *	@mfunc
 *		Put control word with rgShapeKeyword[] index <p iCtrl> and value <p iValue>
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL CRTFWrite::PutShapeParm(
	LONG iCtrl,				//@parm Index into rgShapeKeyword array
	LONG iValue)			//@parm Control-word parameter value. If missing,
{							//		 0 is assumed
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutShapeParm");

	CHAR szT[60];

	LONG cb = sprintf(szT, (char *)szShapeParm, rgShapeKeyword[iCtrl].szKeyword, iValue);
	return Puts(szT, cb);
}

/*
 *	CRTFWrite::GetRtfObjectMetafilePict	(hmfp, &rtfobject, &sizelGoal)
 *
 *	@mfunc
 *		Gets information about an metafile into a structure.
 *
 *	@rdesc
 *		BOOL	TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObjectMetafilePict(
	HGLOBAL		hmfp,		//@parm The object data 
	RTFOBJECT &	rtfobject, 	//@parm	Where to put the info
	SIZEL &		sizelGoal)	//@parm
{
#ifndef NOMETAFILES
	BOOL fSuccess = FALSE;
	LPMETAFILEPICT pmfp = (LPMETAFILEPICT)GlobalLock(hmfp);
	HGLOBAL	hmem = NULL;
	ULONG cb;

	if (!pmfp)
		goto Cleanup;

	// Build the header
	rtfobject.sPictureType = (SHORT) pmfp->mm;
	rtfobject.xExtPict = (SHORT) pmfp->xExt;
	rtfobject.yExtPict = (SHORT) pmfp->yExt;
	rtfobject.xExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cx);
	rtfobject.yExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cy);

	// Find out how much room we'll need
	cb = GetMetaFileBitsEx(pmfp->hMF, 0, NULL);
	if (!cb)
		goto Cleanup;

	// Allocate that space
    hmem = GlobalAlloc(GHND, cb);
	if (!hmem)
		goto Cleanup;

	rtfobject.pbResult = (LPBYTE)GlobalLock(hmem);
	if (!rtfobject.pbResult)
	{
		GlobalFree(hmem);
		goto Cleanup;
	}

	// Get the data
	rtfobject.cbResult = (ULONG) GetMetaFileBitsEx(pmfp->hMF, (UINT) cb,
													rtfobject.pbResult);
	if (rtfobject.cbResult != cb)
	{
		rtfobject.pbResult = NULL;
		GlobalFree(hmem);
		goto Cleanup;
	}
	fSuccess = TRUE;

Cleanup:
	GlobalUnlock(hmfp);
	return fSuccess;
#else
	return FALSE;
#endif
}

/*
 *	CRTFWrite::GetRtfObject (&reobject, &rtfobject)
 *
 *	@mfunc			   
 *		Gets information about an RTF object into a structure.
 *
 *	@rdesc
 *		BOOL	TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObject(
	REOBJECT &reobject,		//@parm Information from GetObject 
	RTFOBJECT &rtfobject)	//@parm Where to put info. Strings are read only
							//		and are owned by the object subsystem
{
	BOOL fSuccess = FALSE;
	BOOL fNoOleServer = FALSE;
	const BOOL fStatic = !!(reobject.dwFlags & REO_STATIC);
	SIZEL sizelObj = reobject.sizel;
	//COMPATIBILITY:  RICHED10 code had a frame size.  Do we need something similiar.
	LPTSTR szProgId;

	// Blank out the full structure
	ZeroMemory(&rtfobject, sizeof(RTFOBJECT));

	// If object has no storage it cannot be written.
	if (!reobject.pstg)
		return FALSE;

	// If we don't have the progID for a real OLE object, get it now
	if (!fStatic )
	{
		rtfobject.szClass = NULL;
		// We need a ProgID to put into the RTF stream.
		//$ REVIEW: MAC This call is incorrect for the Mac.  It may not matter though
		//          if ole support in RichEdit is not needed for the Mac.
		if (ProgIDFromCLSID(reobject.clsid, &szProgId))
			fNoOleServer = TRUE;
		else
			rtfobject.szClass = szProgId;
	}

#ifndef NOMETAFILES
	HGLOBAL hmfp = OleStdGetMetafilePictFromOleObject(reobject.poleobj,
										reobject.dvaspect, &sizelObj, NULL);
	if (hmfp)
	{
		LPMETAFILEPICT pmfp = NULL;

		fSuccess = GetRtfObjectMetafilePict(hmfp, rtfobject, sizelObj);
		if (pmfp = (LPMETAFILEPICT)GlobalLock(hmfp))
		{
			if (pmfp->hMF)
				DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);

		// If we don't have Server and we can't get metafile, forget it.
		if (!fSuccess && fNoOleServer)
			return fSuccess;
	}
#endif

	if (!fStatic)
	{
		// Fill in specific fields
		rtfobject.sType = fNoOleServer ? ROT_Metafile : ROT_Embedded;	//$ FUTURE: set for links
		rtfobject.xExt = (SHORT) TwipsFromHimetric(sizelObj.cx);
		rtfobject.yExt = (SHORT) TwipsFromHimetric(sizelObj.cy);

		// fSuccess set TRUE even if we couldn't retrieve a metafile
		// because we don't need a metafile in the non-static case;
		// it's just nice to have one
		fSuccess = TRUE;
	}
	rtfobject.fSetSize = 0;			//$ REVIEW: Hmmm
	return fSuccess;
}

/*
 *	CRTFWrite::ObjectWriteToEditstream (&reObject, &rtfobject)
 *
 *	@mfunc
 *		Writes an OLE object data to the RTF output stream.
 *
 *	@rdesc
 *		BOOL	TRUE on success, FALSE on failure.
 */
BOOL CRTFWrite::ObjectWriteToEditstream(
	REOBJECT &reObject,		//@parm Info from GetObject 
	RTFOBJECT &rtfobject)	//@parm Where to get icon data
{
	HRESULT hr = 0;

	// Force the object to update its storage				  //// ????
	// Not necessary.  Already done in WriteRtf
	// reObject.polesite->SaveObject();

	// If the object is iconic we do some special magic
	if (reObject.dvaspect == DVASPECT_ICON)
	{
		HANDLE	hGlobal;
		STGMEDIUM med;

		// Force the presentation to be the iconic view.
		med.tymed = TYMED_HGLOBAL;
		hGlobal = GlobalHandle(rtfobject.pbResult);
		med.hGlobal = hGlobal;
		hr = OleConvertIStorageToOLESTREAMEx(reObject.pstg,
											CF_METAFILEPICT,
											rtfobject.xExtPict,
											rtfobject.yExtPict,
											rtfobject.cbResult, &med,
											(LPOLESTREAM) &RTFWriteOLEStream);
	}
	else
	{
		// Do the standard conversion
		hr = OleConvertIStorageToOLESTREAM(reObject.pstg, (LPOLESTREAM) &RTFWriteOLEStream);
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\runptr.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module RUNPTR.C -- Text run and run pointer class |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commented and Cleaned up.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_runptr.h"
#include "_text.h"

ASSERTDATA

//
//	Invariant stuff
//
#define DEBUG_CLASSNAME	CRunPtrBase

#include "_invar.h"

// ===========================  CRunPtrBase class  ==================================================

#ifdef DEBUG
/*
 *	CRunPtrBase::Invariant()
 *
 *	@mfunc
 *		Debug-only function that validates the internal state consistency
 *		for CRunPtrBase
 *
 *	@rdesc
 *		TRUE always (failures assert)
 */
BOOL CRunPtrBase::Invariant() const
{
	if(!IsValid())
	{
		Assert(_iRun == 0 && _ich >= 0);		// CLinePtr can have _ich > 0
	}
	else
	{
		Assert(_iRun < _pRuns->Count());
		LONG cch = _pRuns->Elem(_iRun)->_cch;
		Assert((DWORD)_ich <= (DWORD)cch);
	}
	return TRUE;
}

/*
 *	CRunPtrBase::ValidatePtr(pRun)
 *
 *	@mfunc
 *		Debug-only validation method that asserts if pRun doesn't point
 *		to a valid text run
 */
void CRunPtrBase::ValidatePtr(void *pRun) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::ValidatePtr");

	AssertSz(IsValid() && pRun >= _pRuns->Elem(0) &&
			 pRun <= _pRuns->Elem(Count() - 1),
		"CRunPtr::ValidatePtr: illegal ptr");
}

/*
 *	CRunPtrBase::CalcTextLength()
 *
 *	@mfunc
 *		Calculate length of text by summing text runs accessible by this
 *		run ptr
 *
 *	@rdesc
 *		length of text so calculated, or -1 if failed
 */
LONG CRunPtrBase::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CalcTextLength");
    AssertSz(_pRuns,
		"CTxtPtr::CalcTextLength() - Invalid operation on single run CRunPtr");

	LONG i = Count();
	if(!i)
		return 0;

	LONG	 cb = _pRuns->Size();
	LONG	 cchText = 0;
	CTxtRun *pRun = _pRuns->Elem(0);

	while(i--)
	{
		cchText += pRun->_cch;
		pRun = (CTxtRun *)((BYTE *)pRun + cb);
	}
	return cchText;
}

#endif

/*
 *	CRunPtrBase::GetCchLeft()
 *
 *	@mfunc
 *		Calculate count of chars left in run starting at current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		Count of chars so calculated
 */
LONG CRunPtrBase::GetCchLeft() const	
{
	return GetRun(0)->_cch - GetIch();
}								

/*
 *	CRunPtrBase::CRunPtrBase(pRuns)
 *
 *	@mfunc		constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunArray *pRuns)		//@parm	The Run array for the run ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	_pRuns = pRuns; 
	_iRun = 0; 
	_ich = 0; 

	//make sure everything has been initialized
	Assert(sizeof(CRunPtrBase) == (sizeof(_pRuns) + sizeof(_iRun) 
		+ sizeof(_ich)));
}

/*
 *	CRunPtrBase::CRunPtrBase(rp)
 *
 *	Copy Constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunPtrBase& rp)			//@parm	Other run pointer to initialize from
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	*this = rp;
}

/* 
 *	CRunPtrBase::SetRun(iRun, ich)
 *
 *	@mfunc
 *		Sets this run ptr to the given run.  If it does not
 *		exist, then we set ourselves to the closest valid run
 *
 *	@rdesc
 *		TRUE if moved to iRun
 */
BOOL CRunPtrBase::SetRun(
	LONG iRun,					//@parm Run index to use 
	LONG ich)					//@parm Char index within run to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetRun");

	_TEST_INVARIANT_

	BOOL	 bRet = TRUE;
	LONG	 count = Count();

	// Set the run

	if(!IsValid())						// No runs instantiated:
		return FALSE;					//  leave this rp alone

	if(iRun >= count)					// Validate iRun
	{
		bRet = FALSE;
		iRun = count - 1;				// If (!count), negative iRun 
	}									//  is handled by following if
	if(iRun < 0)
	{
		bRet = FALSE;
		iRun = 0;
	}
	_iRun = iRun;

	// Set the offset
	_ich = ich;
	CTxtRun *pRun = _pRuns->Elem(iRun);
	_ich = min(ich, pRun->_cch);

	return bRet;
}
												
/*
 *	CRunPtrBase::NextRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the next text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::NextRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::NextRun");

	_TEST_INVARIANT_

 	if(_pRuns && _iRun < Count() - 1)
	{
		++_iRun;
		_ich = 0;
		return TRUE;
	}
	return FALSE;
}

/*
 *	CRunPtrBase::PrevRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the previous text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::PrevRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::PrevRun");

	_TEST_INVARIANT_

	if(_pRuns)
	{
		_ich = 0;
		if(_iRun > 0)
		{
			_iRun--;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	CRunPtrBase::GetRun(cRun)
 *
 *	@mfunc
 *		Get address of the TxtRun that is cRun runs away from the run
 *		pointed to by this RunPtr
 *
 *	@rdesc
 *		ptr to the CTxtRun cRun's away
 */
CTxtRun* CRunPtrBase::GetRun(
	LONG cRun) const	//@parm signed count of runs to reach target CTxtRun
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetRun");

	_TEST_INVARIANT_
	Assert(IsValid());						// Common problem...
	return _pRuns->Elem(_iRun + cRun);
}

/*
 *	CRunPtrBase::CalculateCp()
 *
 *	@mfunc
 *		Get cp of this RunPtr
 *
 *	@rdesc
 *		cp of this RunPtr
 *
 *	@devnote
 *		May be computationally expensive if there are many elements
 *		in the array (we have to run through them all to sum cch's.
 *		Used by TOM collections and Move commands, so needs to be fast.
 */
LONG CRunPtrBase::CalculateCp () const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetCp");

	_TEST_INVARIANT_

	Assert(IsValid());

	LONG cb = _pRuns->Size();
	LONG cp	 = _ich;			// Correct result if _iRun = 0
	LONG iRun = _iRun;

	if(!iRun)
		return cp;

	CTxtRun *pRun = GetRun(0);

	while(iRun--)
	{
		Assert(pRun);		
		pRun = (CTxtRun *)((BYTE *)pRun - cb);
		cp += pRun->_cch;
	}
	return cp;
}

/*
 *	CRunPtrBase::BindToCp(cp, cchText)
 *
 *	@mfunc
 *		Set this RunPtr to correspond to a cp.
 *
 *	@rdesc
 *		the cp actually set to
 */
LONG CRunPtrBase::BindToCp(
	LONG cp,			//@parm Character position to move this RunPtr to
	LONG cchText)		//@parm cch in story or 0
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::BindToCp");

	if(cp > cchText/2 && _pRuns)	// Start from end of story
	{
		_iRun = Count() - 1;
		if(_iRun >= 0)
		{
			_ich = _pRuns->Elem(_iRun)->_cch;
			return cchText + Move(cp - cchText);
		}
	}
	_iRun = 0;
	_ich = 0;
	return Move(cp);
}

/*
 *	CRunPtrBase::Move(cch)
 *
 *	@mfunc
 *		Move this RunPtr by (signed) cch chars.  If it lands on the
 *		end of a run, it automatically goes to the start of the next run
 *		(if one exists). 
 *
 *	@rdesc
 *		Count of characters actually moved
 */
LONG CRunPtrBase::Move(
	LONG cch)			//@parm signed count of chars to move this RunPtr by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::Move");

	if(!cch || !IsValid())
		return cch;

	LONG cchSave = cch;

	if(cch < 0)
		while(cch < 0)
		{
			if(-cch <= _ich)
			{
				_ich += cch;					// Target is in this run
				cch = 0;
				break;
			}
			// Otherwise, we need to go to previous run. First add count
			// of chars from start of current run to current postion.
			cch += _ich;
			if(_iRun <= 0)						// Already in first run
			{
				_iRun = 0;
				_ich = 0;						// Move to run beginning
				break;
			}
			_ich = _pRuns->Elem(--_iRun)->_cch;	// Move to previous run
		}
	else
	{
		LONG	 cchRun;
		CTxtRun *pRun = GetRun(0);

		while(cch > 0)							// Move forward
		{
			cchRun = pRun->_cch;
			_ich += cch;

			if(_ich < cchRun)					// Target is in this run
			{
				cch = 0;						// Signal countdown completed
				break;							// (if _ich = cchRun, go to
			}									//  next run)	

			cch = _ich - cchRun;				// Move to next run
			if(++_iRun >= Count())				// Ran past end, back up to
			{									//  end of story
				--_iRun;
				Assert(_iRun == Count() - 1);
				Assert(_pRuns->Elem(_iRun)->_cch == cchRun);
				_ich = cchRun;
				break;
			}
			_ich = 0;							// Start at new BOL
			pRun = (CTxtRun *)((BYTE *)pRun + _pRuns->Size());
		}
	}

	// NB! we check the invariant at the end to handle the case where
	// we are updating the cp for a floating range (i.e., we know that
	// the cp is invalid, so we fix it up).  So we have to check for
	// validity *after* the fixup.
	_TEST_INVARIANT_

	return cchSave - cch;						// Return TRUE if countdown
}												// completed

/*
 *	CRunPtrBase::CountRuns(&cRun, cchMax, cp, cchText)
 *
 *	@mfunc
 *		Count characters up to <p cRun> runs away or <p cchMax> chars,
 *		whichever comes first. If the target run and <p cchMax> are both
 *		beyond the corresponding end of the document, count up thru the
 *		closest run (0 or Count() - 1).  The direction of counting is
 *		determined by the sign of <p cRun>.  To count without being limited
 *		by <p cchMax>, set it equal to tomForward. An initial partial
 *		run counts as a run, i.e., if cRun > 0 and _ich < cch in current
 *		run or if cRun < 0 and _ich > 0, that counts as a run.
 *
 *	@rdesc
 *		Return the signed cch counted and set <p cRun> equal to count of runs
 *		actually counted.  If no runs are allocated, the text is treated as
 *		a single run.  If <p cRun> = 0, -_ich is returned. If <p cRun> <gt> 0
 *		and this run ptr points to the end of the last run, no change is made
 *		and 0 is returned.
 *
 *	@devnote
 *		The maximum count capability is included to be able to count units in
 *		a range.  The <p tp> argument is needed for getting the text length
 *		when no runs exist and <p cRun> selects forward counting.
 */
LONG CRunPtrBase::CountRuns (
	LONG &	cRun,			//@parm Count of runs to get cch for
	LONG	cchMax,			//@parm Maximum char count
	LONG	cp,				//@parm CRchTxtPtr::GetCp()
	LONG	cchText) const	//@parm Text length of associated story
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CountRuns");

	_TEST_INVARIANT_

	LONG cch;

	if(!cRun)								// Nothing to do
		return 0;

	// Simple special single-run case
	if(!IsValid())							// No runs instantiated: act as a
	{										//  single run
		if(cRun > 0)						// Count forward
		{
			cch	= cchText - cp;				// Partial count to end of run
			cRun = 1;						// No more than one run
		}
		else								// Count backward
		{
			cch = -cp;						// Partial count to start of run
			cRun = -1;						// No less than minus one run
		}			
		if(!cch)							// No partial run, so no runs
			cRun = 0;						//  counted
		return cch;
	}

	// General case for which runs are instantiated

	LONG		cb	 = _pRuns->Size();		// Size of text run element
	LONG		iDir;
	LONG		iRun = _iRun;				// Cache run index for current run
	LONG		j, k;						// Handy integers
	CTxtRun *	pRun = GetRun(0);			// Not NULL since runs exist

	if(cRun < 0)							// Try to count backward cRun runs
	{
		iDir = -1;
		cb	 = -cb;							// Byte count to previous element
		cch	 = _ich;						// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun++;							//  as a run: 1 less for for loop
		cRun = max(cRun, -iRun);			// Don't let for loop overshoot
	}
	else
	{										// Try to count forward cRun runs 
		Assert(cRun > 0);
		iDir = 1;
		cch	 = pRun->_cch - _ich;			// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun--;							//  as a run: 1 less for for loop
		k	 = Count() - iRun - 1;			// k = # runs following current run
		cRun = min(cRun, k);				// Don't let for loop overshoot
	}

	k	 = cch;								// Remember if initial cch != 0
	for(j = cRun; j && cch < cchMax; j -= iDir)
	{
		pRun = (CTxtRun *)((BYTE *)pRun + cb);	// Point at following run
		cch += pRun->_cch;					// Add in its count
	}
	if(k)									// Initial partial run counts as
		cRun += iDir;						//  a run
	cRun -= j;								// Discount any runs not counted
											//  if |cch| >= cchMax
	return iDir*cch;						// Return total cch bypassed
}

/*
 *	CRunPtrBase::FindRun (pcpMin, pcpMost, cpMin, cch)
 *
 *	@mfunc
 *		Set *<p pcpMin>  = closest run cpMin <lt>= range cpMin, and
 *		set *<p pcpMost> = closest run cpMost <gt>= range cpMost
 *
 *	@devnote
 *		This routine plays a role analogous to CTxtRange::FindParagraph
 *		(pcpMin, pcpMost), but needs extra arguments since this run ptr does
 *		not know the range cp's.  This run ptr is located at the range active
 *		end, which is determined by the range's signed length <p cch> in
 *		conjunction with <p cpMin>.
 */
void CRunPtrBase::FindRun (
	LONG *pcpMin,			//@parm Out parm for bounding-run cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-run cpMost
	LONG cpMin,				//@parm Range cpMin
	LONG cch,				//@parm Range signed length
	LONG cchText) const		//@parm Story length
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::FindRun");

	if(!IsValid())
	{
		if(pcpMin)						// Run is whole story
			*pcpMin = 0;
		if(pcpMost)
			*pcpMost = cchText;
		return;
	}

	BOOL fMove;								// Controls Move for pcpMost
	CRunPtrBase rp((CRunPtrBase&)(*this));	// Clone this runptr to keep it const

	rp.AdjustForward();						// Select forward run
	if(pcpMin)
	{										// If cch != 0, rp is sure to end up
		fMove = cch;						//  at cpMin, so pcpMost needs Move
		if(cch > 0)							// rp is at cpMost, so move it to
			rp.Move(-cch);					//  cpMin
		*pcpMin = cpMin - rp._ich;			// Subtract off offset in this run
	}
	else
		fMove = cch < 0;					// Need to move to get pcpMost

	if(pcpMost)
	{
		cch = abs(cch);
		if(fMove)							// Move to cpMost = cpMin + cch,
			rp.Move(cch);					//  i.e., range's cpMost
		if(cch)
			rp.AdjustBackward();		// Since nondegenerate range
		*pcpMost = cpMin + cch			// Add remaining cch in run to range's
				+ rp.GetCchLeft();		//  cpMost
	}
}

/*
 *	CRunPtrBase::AdjustBackward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the end of the first run.
 *
 *	@comm
 *		This function does nothing unless this run ptr points to the beginning
 *		or the end of a run.  This function may be needed in those cases
 *		because	a cp at the beginning of a run is identical to the cp for the
 *		end of the previous run (if it exists), i.e., such an "edge" cp is
 *		ambiguous, and you may need to be sure that this run ptr points to the
 *		end of the first run.
 *
 *		For example, consider a run that describes characters at cp's 0 to 10
 *		followed by a run that describes characters	at cp's 11 through 12. For
 *		a cp of 11, it is possible for the run ptr to be either at the *end*
 *		of the first run or at the *beginning* of the second run.	 
 *
 *	@rdesc 	nothing
 */
void CRunPtrBase::AdjustBackward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustBackward");

	_TEST_INVARIANT_

	if(!_ich && PrevRun())				// If at start of run that isn't
		_ich = _pRuns->Elem(_iRun)->_cch;	//  the first, go to end of
}											//  previous run

/*
 *	CRunPtrBase::AdjustForward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the start of the second
 *		run.
 *
 *	@rdesc
 *		nothing
 *	
 *	@xref
 *		<mf CRunPtrBase::AdjustBackward>
 */
void CRunPtrBase::AdjustForward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustForward");

	_TEST_INVARIANT_

	if(!IsValid())
		return;

	CTxtRun *pRun = _pRuns->Elem(_iRun);

	if(pRun->_cch == _ich)					// If at end of run, go to start
		NextRun();							//  of next run (if it exists)
}

/*
 *	CRunPtrBase::SetToNull()
 *
 *	@mfunc
 *		Sets all run pointer information to be NULL. This
 *		is designed to handle the response to clearing document runs
 *		such as when we convert from rich text to plain text.
 *
 *	@rdesc
 *		VOID
 */
void CRunPtrBase::SetToNull() 
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetToNull");

	_pRuns = NULL;
	_iRun = 0;
	_ich = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textnot.cpp ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	TextNot.cpp -- forwards notification to Message Filter
 *
 *	Purpose:  
 *
 *	Author:	<nl>
 *		1/12/99 honwch
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_edit.h"
#include "_textnot.h"	

/*
 *	CTextNotify::~CTextNotify()
 *
 *	@mfunc
 *		CTextNotify Destructor
 *	
 */
CTextNotify::~CTextNotify()
{
	CNotifyMgr *pnm;

	if (_ped && _pMsgFilterNotify)
	{
		// Remove from this object from the notification link
		_pMsgFilterNotify = NULL;

		pnm = _ped->GetNotifyMgr();
		if(pnm)	
			pnm->Remove(this);
		
		_ped = NULL;
	}
}

/*
 *	void CTextNotify::OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Forwards PreReplaceRange to Message Filter
 */
void CTextNotify::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	if (_ped && _ped->_pMsgFilter && _pMsgFilterNotify)
		_pMsgFilterNotify->OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData);
}

/*
 *	void CTextNotify::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Forwards OnPostReplaceRange to Message Filter
 */
void CTextNotify::OnPostReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	if (_ped && _ped->_pMsgFilter && _pMsgFilterNotify)
		_pMsgFilterNotify->OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData);
}

/*
 *	void CTextNotify::Add(pMsgFilterNotify)
 *
 *	@mfunc
 *		Setup Message Filter notification.  Need to add this object to Notifcation link
 *
 *	@rdesc
 *		FALSE if we cant get the Notification manager
 */
BOOL CTextNotify::Add(ITxNotify *pMsgFilterNotify)
{
	CNotifyMgr *pnm;

	if (!_ped)
		return FALSE;

	if (!_pMsgFilterNotify)
	{
		pnm = _ped->GetNotifyMgr();
		if(pnm)	
			pnm->Add(this);
		else
			return FALSE;		
	}
	
	_pMsgFilterNotify = pMsgFilterNotify;
	
	return TRUE;
}

/*
 *	void CTextNotify::Remove(pMsgFilterNotify)
 *
 *	@mfunc
 *		Remove Message Filter notification.  Remove this object from Notifcation link
 *
 *	@rdesc
 *		FALSE if we cant get the Notification manager
 */
BOOL CTextNotify::Remove(ITxNotify *pMsgFilterNotify)
{
	CNotifyMgr *pnm;

	if (!_ped)
		return FALSE;

	if (_pMsgFilterNotify == pMsgFilterNotify)
	{
		_pMsgFilterNotify = NULL;
		
		pnm = _ped->GetNotifyMgr();
		if(pnm)	
			pnm->Remove(this);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textsrv2.h ===
/*	@doc EXTERNAL
 *
 *	@module TEXTSRV2.H  Text Service Interface |
 *	
 *	Define new private interface between the Text Services component and the host
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 *      7/9/99  joseogl Split off from textserv,h because ITextHost2 is undocumented
 */

#ifndef _TEXTSRV2_H
#define _TEXTSRV2_H

EXTERN_C const IID IID_ITextHost2;

/*
 *	class ITextHost2
 *
 *	@class	An optional extension to ITextHost which provides functionality
 *			necessary to allow TextServices to embed OLE objects
 */
class ITextHost2 : public ITextHost
{
public:					//@cmember Is a double click in the message queue?
	virtual BOOL		TxIsDoubleClickPending() = 0; 
						//@cmember Get the overall window for this control	 
	virtual HRESULT		TxGetWindow(HWND *phwnd) = 0;
						//@cmember Set control window to foreground
	virtual HRESULT		TxSetForegroundWindow() = 0;
						//@cmember Set control window to foreground
	virtual HPALETTE	TxGetPalette() = 0;
						//@cmember Get FE flags
	virtual HRESULT		TxGetFEFlags(LONG *pFlags) = 0;
						//@cmember Routes the cursor change to the winhost
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) = 0;
						//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification() = 0;
						//@cmember Get Edit Style flags
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData) = 0;
						//@cmember Get Window Style bits
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle) = 0;

    virtual HRESULT TxEBookLoadImage( LPWSTR lpszName,	// name of image
									  LPARAM * pID,	    // E-Book supplied image ID
                                      SIZE * psize,    // returned size of image (pixels)
									 DWORD *pdwFlags)=0;// returned flags for Float

    virtual HRESULT TxEBookImageDraw(LPARAM ID,		      // id of image to draw
                                     HDC hdc,             // drawing HDC
                                     POINT *topLeft,      // top left corner of where to draw
                                     RECT  *prcRenderint, // parm pointer to render rectangle
                                     BOOL fSelected)=0;	  // TRUE if image is in selected state

	virtual HRESULT TxGetHorzExtent(LONG *plHorzExtent)=0;//@cmember Get Horizontal scroll extent
};

// Various flags for TxGetEditStyle data
#define TXES_ISDIALOG		1
#endif // _TEXTSRV2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textserv.h ===
/*	@doc EXTERNAL
 *
 *	@module TEXTSRV.H  Text Service Interface |
 *	
 *	Define interfaces between the Text Services component and the host
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 */

#ifndef _TEXTSERV_H
#define _TEXTSERV_H

EXTERN_C const IID IID_ITextServices;
EXTERN_C const IID IID_ITextHost;
EXTERN_C const IID IID_ITextHost2;

// Note: error code is first outside of range reserved for OLE.
#define S_MSG_KEY_IGNORED \
	MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x201)

// Enums used by property methods

/*
 *	TXTBACKSTYLE
 *
 *	@enum	Defines different background styles control
 */
enum TXTBACKSTYLE {
	TXTBACK_TRANSPARENT = 0,		//@emem	background should show through
	TXTBACK_OPAQUE,					//@emem	erase background
};


/*
 *	TXTHITRESULT
 *
 *	@enum	Defines different hitresults
 */
enum TXTHITRESULT {
	TXTHITRESULT_NOHIT	        = 0,	//@emem	no hit
	TXTHITRESULT_TRANSPARENT	= 1,	//@emem point is within the text's rectangle, but 
										//in a transparent region
	TXTHITRESULT_CLOSE	        = 2,	//@emem	point is close to the text
	TXTHITRESULT_HIT	        = 3		//@emem dead-on hit
};

/*
 *	TXTNATURALSIZE
 *
 *	@enum	useful values for TxGetNaturalSize.
 *
  *	@xref <mf CTxtEdit::TxGetNaturalSize>
 */
enum TXTNATURALSIZE {
	TXTNS_FITTOCONTENT2		= 0,		//@emem Get size that fits indented content
    TXTNS_FITTOCONTENT		= 1,		//@emem	Get size that fits content
    TXTNS_ROUNDTOLINE		= 2			//@emem Round to nearest whole line
};

/*
 *	TXTVIEW
 *
 *	@enum	useful values for TxDraw lViewId parameter
 *
  *	@xref <mf CTxtEdit::TxDraw>
 */
enum TXTVIEW { 
	TXTVIEW_ACTIVE = 0,
	TXTVIEW_INACTIVE = -1
};


/*
 *	CHANGETYPE
 *
 *	@enum	used for CHANGENOTIFY.dwChangeType; indicates what happened 
 *			for a particular change.
 */
enum CHANGETYPE
{
	CN_GENERIC		= 0,				//@emem Nothing special happened
	CN_TEXTCHANGED	= 1,				//@emem the text changed
	CN_NEWUNDO		= 2,				//@emem	A new undo action was added
	CN_NEWREDO		= 4					//@emem A new redo action was added
};

/* 
 *	@struct CHANGENOTIFY  |
 *
 *	passed during an EN_CHANGE notification; contains information about
 *	what actually happened for a change.
 */
struct CHANGENOTIFY {
	DWORD	dwChangeType;				//@field TEXT changed, etc
	void *	pvCookieData; 				//@field cookie for the undo action 
										// associated with the change.
};

// The TxGetPropertyBits and OnTxPropertyBitsChange methods can pass the following bits:

// NB!!! Do NOT rely on the ordering of these bits yet; the are subject
// to change.
#define TXTBIT_RICHTEXT			1		// rich-text control
#define TXTBIT_MULTILINE		2		// single vs multi-line control
#define TXTBIT_READONLY			4		// read only text
#define TXTBIT_SHOWACCELERATOR	8		// underline accelerator character
#define TXTBIT_USEPASSWORD		0x10	// use password char to display text
#define TXTBIT_HIDESELECTION	0x20	// show selection when inactive
#define TXTBIT_SAVESELECTION	0x40	// remember selection when inactive
#define TXTBIT_AUTOWORDSEL		0x80	// auto-word selection 
#define TXTBIT_VERTICAL			0x100	// vertical 
#define TXTBIT_SELBARCHANGE 	0x200	// notification that the selection bar width 
										// has changed.
										// FUTURE: move this bit to the end to
										// maintain the division between 
										// properties and notifications.
#define TXTBIT_WORDWRAP  		0x400	// if set, then multi-line controls
										// should wrap words to fit the available
										// display
#define	TXTBIT_ALLOWBEEP		0x800	// enable/disable beeping
#define TXTBIT_DISABLEDRAG      0x1000  // disable/enable dragging
#define TXTBIT_VIEWINSETCHANGE	0x2000	// the inset changed
#define TXTBIT_BACKSTYLECHANGE	0x4000 
#define TXTBIT_MAXLENGTHCHANGE	0x8000
#define TXTBIT_SCROLLBARCHANGE	0x10000
#define TXTBIT_CHARFORMATCHANGE 0x20000
#define TXTBIT_PARAFORMATCHANGE	0x40000
#define TXTBIT_EXTENTCHANGE		0x80000
#define TXTBIT_CLIENTRECTCHANGE	0x100000	// the client rectangle changed
#define TXTBIT_USECURRENTBKG	0x200000	// tells the renderer to use the current background
											// color rather than the system default for an entire line


/*
 *	ITextServices
 *	
 * 	@class	An interface extending Microsoft's Text Object Model to provide
 *			extra functionality for windowless operation.  In conjunction
 *			with ITextHost, ITextServices provides the means by which the
 *			the RichEdit control can be used *without* creating a window.
 *
 *	@base	public | IUnknown
 */
class ITextServices : public IUnknown
{
public:

	//@cmember Generic Send Message interface
	virtual HRESULT 	TxSendMessage(
							UINT msg, 
							WPARAM wparam, 
							LPARAM lparam,
							LRESULT *plresult) = 0;
	
	//@cmember Rendering
	virtual HRESULT		TxDraw(	
							DWORD dwDrawAspect,		
							LONG  lindex,			
							void * pvAspect,		 
							DVTARGETDEVICE * ptd,									
							HDC hdcDraw,			
							HDC hicTargetDev,		 
							LPCRECTL lprcBounds,	
							LPCRECTL lprcWBounds,	
               				LPRECT lprcUpdate,		
							BOOL (CALLBACK * pfnContinue) (DWORD), 
							DWORD dwContinue,
							LONG lViewId) = 0;	

	//@cmember Horizontal scrollbar support
	virtual HRESULT		TxGetHScroll(
							LONG *plMin, 
							LONG *plMax, 
							LONG *plPos, 
							LONG *plPage,
							BOOL * pfEnabled ) = 0;

   	//@cmember Horizontal scrollbar support
	virtual HRESULT		TxGetVScroll(
							LONG *plMin, 
							LONG *plMax, 
							LONG *plPos, 
							LONG *plPage, 
							BOOL * pfEnabled ) = 0;

	//@cmember Setcursor
	virtual HRESULT 	OnTxSetCursor(
							DWORD dwDrawAspect,		
							LONG  lindex,			
							void * pvAspect,		 
							DVTARGETDEVICE * ptd,									
							HDC hdcDraw,			
							HDC hicTargetDev,		 
							LPCRECT lprcClient, 
							INT x, 
							INT y) = 0;

	//@cmember Hit-test
	virtual HRESULT 	TxQueryHitPoint(
							DWORD dwDrawAspect,		
							LONG  lindex,			
							void * pvAspect,		 
							DVTARGETDEVICE * ptd,									
							HDC hdcDraw,			
							HDC hicTargetDev,		 
							LPCRECT lprcClient, 
							INT x, 
							INT y, 
							DWORD * pHitResult) = 0;

	//@cmember Inplace activate notification
	virtual HRESULT		OnTxInPlaceActivate(LPCRECT prcClient) = 0;

	//@cmember Inplace deactivate notification
	virtual HRESULT		OnTxInPlaceDeactivate() = 0;

	//@cmember UI activate notification
	virtual HRESULT		OnTxUIActivate() = 0;

	//@cmember UI deactivate notification
	virtual HRESULT		OnTxUIDeactivate() = 0;

	//@cmember Get text in control
	virtual HRESULT		TxGetText(BSTR *pbstrText) = 0;

	//@cmember Set text in control
	virtual HRESULT		TxSetText(LPCWSTR pszText) = 0;
	
	//@cmember Get x position of 
	virtual HRESULT		TxGetCurTargetX(LONG *) = 0;
	//@cmember Get baseline position
	virtual HRESULT		TxGetBaseLinePos(LONG *) = 0;

	//@cmember Get Size to fit / Natural size
	virtual HRESULT		TxGetNaturalSize(
							DWORD dwAspect,
							HDC hdcDraw,
							HDC hicTargetDev,
							DVTARGETDEVICE *ptd,
							DWORD dwMode, 	
							const SIZEL *psizelExtent,
							LONG *pwidth, 
							LONG *pheight) = 0;

	//@cmember Drag & drop
	virtual HRESULT		TxGetDropTarget( IDropTarget **ppDropTarget ) = 0;

	//@cmember Bulk bit property change notifications
	virtual HRESULT		OnTxPropertyBitsChange(DWORD dwMask, DWORD dwBits) = 0;

	//@cmember Fetch the cached drawing size (logical not physical)
	virtual	HRESULT		TxGetCachedSize(DWORD *pdwWidth, DWORD *pdwHeight)=0;
};


/*
 *	ITextHost
 *	
 * 	@class	Interface to be used by text services to obtain text host services
 *
 *	@base	public | IUnknown 
 */
class ITextHost : public IUnknown
{
public:

	//@cmember Get the DC for the host
	virtual HDC 		TxGetDC() = 0;

	//@cmember Release the DC gotten from the host
	virtual INT			TxReleaseDC(HDC hdc) = 0;
	
	//@cmember Show the scroll bar
	virtual BOOL 		TxShowScrollBar(INT fnBar, BOOL fShow) = 0;

	//@cmember Enable the scroll bar
	virtual BOOL 		TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags) = 0;

	//@cmember Set the scroll range
	virtual BOOL 		TxSetScrollRange(
							INT fnBar, 
							LONG nMinPos, 
							INT nMaxPos, 
							BOOL fRedraw) = 0;

	//@cmember Set the scroll position
	virtual BOOL 		TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw) = 0;

	//@cmember InvalidateRect
	virtual void		TxInvalidateRect(LPCRECT prc, BOOL fMode) = 0;

	//@cmember Send a WM_PAINT to the window
	virtual void 		TxViewChange(BOOL fUpdate) = 0;
	
	//@cmember Create the caret
	virtual BOOL		TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight) = 0;

	//@cmember Show the caret
	virtual BOOL		TxShowCaret(BOOL fShow) = 0;

	//@cmember Set the caret position
	virtual BOOL		TxSetCaretPos(INT x, INT y) = 0;

	//@cmember Create a timer with the specified timeout
	virtual BOOL 		TxSetTimer(UINT idTimer, UINT uTimeout) = 0;

	//@cmember Destroy a timer
	virtual void 		TxKillTimer(UINT idTimer) = 0;

	//@cmember Scroll the content of the specified window's client area
	virtual void		TxScrollWindowEx (
							INT dx, 
							INT dy, 
							LPCRECT lprcScroll, 
							LPCRECT lprcClip,
							HRGN hrgnUpdate, 
							LPRECT lprcUpdate, 
							UINT fuScroll) = 0;
	
	//@cmember Get mouse capture
	virtual void		TxSetCapture(BOOL fCapture) = 0;

	//@cmember Set the focus to the text window
	virtual void		TxSetFocus() = 0;

	//@cmember Establish a new cursor shape
	virtual void 	TxSetCursor(HCURSOR hcur, BOOL fText) = 0;

	//@cmember Converts screen coordinates of a specified point to the client coordinates 
	virtual BOOL 		TxScreenToClient (LPPOINT lppt) = 0;

	//@cmember Converts the client coordinates of a specified point to screen coordinates
	virtual BOOL		TxClientToScreen (LPPOINT lppt) = 0;

	//@cmember Request host to activate text services
	virtual HRESULT		TxActivate( LONG * plOldState ) = 0;

	//@cmember Request host to deactivate text services
   	virtual HRESULT		TxDeactivate( LONG lNewState ) = 0;

	//@cmember Retrieves the coordinates of a window's client area
	virtual HRESULT		TxGetClientRect(LPRECT prc) = 0;

	//@cmember Get the view rectangle relative to the inset
	virtual HRESULT		TxGetViewInset(LPRECT prc) = 0;

	//@cmember Get the default character format for the text
	virtual HRESULT 	TxGetCharFormat(const CHARFORMATW **ppCF ) = 0;

	//@cmember Get the default paragraph format for the text
	virtual HRESULT		TxGetParaFormat(const PARAFORMAT **ppPF) = 0;

	//@cmember Get the background color for the window
	virtual COLORREF	TxGetSysColor(int nIndex) = 0;

	//@cmember Get the background (either opaque or transparent)
	virtual HRESULT		TxGetBackStyle(TXTBACKSTYLE *pstyle) = 0;

	//@cmember Get the maximum length for the text
	virtual HRESULT		TxGetMaxLength(DWORD *plength) = 0;

	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT		TxGetScrollBars(DWORD *pdwScrollBar) = 0;

	//@cmember Get the character to display for password input
	virtual HRESULT		TxGetPasswordChar(TCHAR *pch) = 0;

	//@cmember Get the accelerator character
	virtual HRESULT		TxGetAcceleratorPos(LONG *pcp) = 0;

	//@cmember Get the native size
    virtual HRESULT		TxGetExtent(LPSIZEL lpExtent) = 0;
 
	//@cmember Notify host that default character format has changed
	virtual HRESULT 	OnTxCharFormatChange (const CHARFORMATW * pcf) = 0;

	//@cmember Notify host that default paragraph format has changed
	virtual HRESULT		OnTxParaFormatChange (const PARAFORMAT * ppf) = 0;

	//@cmember Bulk access to bit properties
	virtual HRESULT		TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits) = 0;

	//@cmember Notify host of events
	virtual HRESULT		TxNotify(DWORD iNotify, void *pv) = 0;

	// East Asia Methods for getting the Input Context
	virtual HIMC		TxImmGetContext() = 0;
	virtual void		TxImmReleaseContext( HIMC himc ) = 0;

	//@cmember Returns HIMETRIC size of the control bar.
	virtual HRESULT		TxGetSelectionBarWidth (LONG *lSelBarWidth) = 0;
};

//+-----------------------------------------------------------------------
// 	Factories
//------------------------------------------------------------------------

// Text Services factory
STDAPI CreateTextServices(
	IUnknown *punkOuter,
	ITextHost *pITextHost, 
	IUnknown **ppUnk);

typedef HRESULT (STDAPICALLTYPE * PCreateTextServices)(
	IUnknown *punkOuter,
	ITextHost *pITextHost, 
	IUnknown **ppUnk);

#endif // _TEXTSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textserv.cpp ===
/*
 *	@doc EXTERNAL
 *
 *	@module	TEXTSERV.CPP	-- Text Services Implementation |
 *	
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		8/1/95  ricksa  Created and documented
 *		10/95	murrays Further doc and simplifications
 *
 *	Documentation is generated straight from the code.  The following
 *	date/time stamp indicates the version of code from which the
 *	the documentation was generated.
 *
 *	$Header: /richedit/src/textserv.cpp 53    11/15/95 2:39p Ricksa $
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"
#include "_urlsup.h"
#include "_magelln.h"
#ifndef NOLINESERVICES
#include "_ols.h"
#endif
#include "_clasfyc.h"

#include "_tomfmt.h"

#ifndef OBJID_NATIVEOM
#define OBJID_NATIVEOM 0xFFFFFFF0
#endif

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#include "_dxfrobj.h"
#endif

#ifndef NOACCESSIBILITY
#include "oleacc.h"
#endif

// By turning on the PROFILE_TS compiler directive, you tell IceCap2.0
// to turn on profiling for only ITextServices API's.  Typically only
// used during profiling work.
//#define PROFILE_TS
#ifdef PROFILE_TS
#include <icapexp.h>

class CapProfile
{
public:
	CapProfile() { StartCAP(); }
	~CapProfile() { StopCAP(); }
};

#define START_PROFILING 	CapProfile capprf;
#else
#define	START_PROFILING
#endif //PROFILE_TS

ASSERTDATA

// Macros to get mouse coordinates out of a message
// need to cast to SHORT first for sign extension
#define	MOUSEX	((INT)(SHORT)LOWORD(lparam))	
#define	MOUSEY	((INT)(SHORT)HIWORD(lparam))	

LONG ValidateTextRange(TEXTRANGE *pstrg);

BOOL g_OLSBusy = 0;


// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// if there's an active object being dragged around, on WM_PAINT we always
// try to reposition it to there it should be. A not-so-well-behaved object
// my generate another WM_PAINT message in response to that, even if it actually
// did not move. So we limit our number of attempts to reposition it and reset
// this counter every time a mouse moves.
// The corresponding field is declared as :2, so don't try to bump it up
// without allocating more bits!!
#define MAX_ACTIVE_OBJ_POS_TRIES (3)

// Interchange horizontal and vertical commands
WORD InterchangeScrollCode(WORD wCode)
{
	switch(wCode)
	{
		case SB_BOTTOM:
			return SB_TOP;

		case SB_LINEDOWN:
			return SB_LINEUP;

		case SB_LINEUP:
			return SB_LINEDOWN;

		case SB_PAGEDOWN:
			return SB_PAGEUP;

		case SB_PAGEUP:
			return SB_PAGEDOWN;

		case SB_TOP:
			return SB_BOTTOM;

		default:
			return wCode;
	}
}


///////////////////////////// Helper Functions ///////////////////////////////////
/*
 *	BOOL CTxtEdit::LoadMsgFilter(msg, wparam, lparam)
 *
 *	@func
 *		Check if we should load the IME message filter
 *
 *	@rdesc
 *		TRUE - Load it
 *		FALSE - Don't load
 */
BOOL CTxtEdit::LoadMsgFilter(
	UINT	msg, 				//@parm	Message ID 
	WPARAM	wparam,				//@parm Message wparam
	LPARAM	lparam)				//@parm Message lparam
{
	//TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::LoadMsgFilter");

	// For the first ever message, we want to check if 
	// our client has created AIMM object for current thread
#ifndef NOFEPROCESSING
	if (!_fCheckAIMM)
	{
		DWORD	dwThreadId;
		DWORD	dwLoadActiveInput = 0;

		_fCheckAIMM = 1;

#ifndef NOPRIVATEMESSAGE
		if (!_f10Mode)											// Don't check if 1.0 mode
		{
			if (FindAtomA("_CTF_PROCESS_ATOM_"))				// Is process using Cicero?
				dwLoadActiveInput = SES_USECTF;

			if (FindAtomA("_AIMM12_PROCESS_ATOM_"))				// Is process using Aimm 1.2?
				dwLoadActiveInput = SES_USEAIMM12;				//	Yes, this will override SES_USECTF.
			else if (dwThreadId = GetCurrentThreadId())
			{
				char szBuf[20];
				sprintf(szBuf, "AIMM:%08x", dwThreadId);
				if (FindAtomA(szBuf))							// Is thread using Aimm 1.1?
					dwLoadActiveInput = SES_USEAIMM11;			//	Yes, load Aimm 1.1
			}

			if (!dwLoadActiveInput)								// Process is not using anything...
			{
				if (W32->fUseCTF()) 							// Ini file say use Cicero			
					dwLoadActiveInput = SES_USECTF;
				else if (W32->fUseAimm())						// Ini file say use Aimm 1.2
					dwLoadActiveInput = SES_USEAIMM12;
			}

			if (dwLoadActiveInput)
			{
				HWND	hWnd = NULL;

				TxGetWindow( &hWnd );

				if (hWnd)
				{
					if (_fInOurHost)
						PostMessage(hWnd, EM_SETUIM, dwLoadActiveInput, dwLoadActiveInput);
					else
					{
						LRESULT	lResult;
						TxSendMessage(EM_SETUIM, dwLoadActiveInput, dwLoadActiveInput, &lResult);
					}
				}
			}
		}
#endif
	}

	switch (msg)
	{
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			if ( (WORD) wparam == VK_PROCESSKEY )
				return TRUE;			
			break;

		case WM_INPUTLANGCHANGE:
			if (IsFELCID((WORD)(lparam)))
				return TRUE;
			break;

		case EM_SETEDITSTYLE:
			if ((lparam & (SES_USEAIMM | SES_NOIME | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING)) || 
				(wparam & (SES_USEAIMM | SES_NOIME | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING)))
				return TRUE;
			break;

		case EM_RECONVERSION:
		case WM_IME_NOTIFY:	
		case WM_IME_REQUEST:
		case WM_IME_STARTCOMPOSITION:
		case EM_GETIMEOPTIONS:
		case EM_SETIMEOPTIONS:
		case EM_SETIMECOLOR:
		case EM_GETIMECOLOR:
		case WM_IME_CHAR:
#ifndef NOPRIVATEMESSAGE
		case EM_SETUIM:
#endif
		case EM_SETIMEMODEBIAS:
		case EM_GETIMEMODEBIAS:
		case EM_GETCTFMODEBIAS:
		case EM_SETCTFMODEBIAS:
		case EM_GETCTFOPENSTATUS:
		case EM_SETCTFOPENSTATUS:
		case EM_GETIMECOMPTEXT:
		case EM_ISIME:
		case EM_GETIMEPROPERTY:
			return TRUE;

		case EM_SETLANGOPTIONS:
			if (lparam & (IMF_IMEALWAYSSENDNOTIFY | IMF_IMECANCELCOMPLETE))
				return TRUE;
			break;

		default:
			if (msg)
			{
				if (msg == MSIMEReconvertMsg || msg == MSIMEDocFeedMsg
					|| msg == MSIMEQueryPositionMsg)
					return TRUE;
			}
			break;
						
	}
#endif

	return FALSE;
}

/*
 *	CTxtEdit::FormatAndPrint (hdcDraw, hicTargetDev, ptd, lprcBounds,
 *							  lprcWBounds)
 *	@mfunc
 *		Format and Print data in control
 *
 *	@rdesc
 *		S_OK - everything worked
 *		E_FAIL - unexpected failure occurred
 */
HRESULT CTxtEdit::FormatAndPrint(
	HDC hdcDraw,			//@parm HDC to draw on
	HDC hicTargetDev,		//@parm Input information context if any
	DVTARGETDEVICE *ptd,	//@parm Device target information
	RECT *lprcBounds,		//@parm Rectangle to measure
	RECT *lprcWBounds)		//@parm Metafile information
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::FormatAndPrint");

	// Put client rectangle in format structure
	FORMATRANGE fr;
	fr.rc = *lprcBounds;

	// Get number of device units per inch
	LONG xPerInch;
	LONG yPerInch;

	if (NULL == lprcWBounds)
	{
		xPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSX);
		yPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSY);
	}
	else
	{
		//Forms ^3 draws using screen resolution, while OLE specifies HIMETRIC
		xPerInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		yPerInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		SetWindowOrgEx(hdcDraw, lprcWBounds->left, lprcWBounds->top, NULL);
		SetWindowExtEx(hdcDraw, lprcWBounds->right, lprcWBounds->bottom, NULL);
	}


	// Convert rectangle into TWIPS
	fr.rc.left = MulDiv(fr.rc.left, LX_PER_INCH, xPerInch);
	fr.rc.top = MulDiv(fr.rc.top, LY_PER_INCH, yPerInch);
	fr.rc.right = MulDiv(fr.rc.right, LX_PER_INCH, xPerInch);
	fr.rc.bottom = MulDiv(fr.rc.bottom, LY_PER_INCH, yPerInch);

	// Use message based printing code to do our printing for us
	fr.hdc = hdcDraw;
	fr.hdcTarget = hicTargetDev;
	fr.rcPage = fr.rc;
	fr.chrg.cpMin = _pdp->GetFirstVisibleCp();
	fr.chrg.cpMost = -1;

	// Assume this is all going to work
	HRESULT hr = S_OK;

	SPrintControl prtcon;
	prtcon._fDoPrint = TRUE;
	prtcon._fPrintFromDraw = TRUE;

	// Print control
	if(OnFormatRange(&fr, prtcon, TRUE) == -1)
	{
		// For some reason the control could not be printed
		hr = E_FAIL;
	}

	return hr;
}

/*
 *	CTxtEdit::SetText (pstr, flags, CodePage, publdr, plres)
 *
 *	@mfunc	Sets the text in the document, clearing out any existing text
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtEdit::SetText(
	LPCWSTR		  pstr,		//@parm	Text to set
	DWORD		  flags,	//@parm 0 or more ST_xxx's
	LONG		  CodePage,	//@parm CodePage
	IUndoBuilder *publdr,	//@parm Optional place to put undo events
	LRESULT	*	  plres)	//@parm Optional place to return cch added
{
	CCallMgr	callmgr(this);
	BOOL		fSel = flags & ST_SELECTION;
	BOOL		fSetTextMax = TRUE;
	CTxtRange 	rg(this, 0, -GetTextLength());	// Select whole story
	CTxtRange *	prg = &rg;
	LRESULT		lres = 0;
	CFreezeDisplay fd(_pdp);
	CCharFormat CF;
	BOOL		fSetCF = FALSE;
	BOOL		fInputString = FALSE;		// Initialize to no input string

	// NOTE: WM_SETTEXT is the only message using flags == ST_CHECKPROTECTION.
	// This is sent in via ANSIWndProc().  Do we need another flag to indicate 
	// WM_SETTEXT or is this check good enough?  This only affect 1.0 mode.
    BOOL        f10WM_SETTEXT = flags & ST_10WM_SETTEXT;

	if(plres)
		*plres = 0;

	if(fSel)					// Set selected text
	{
		if(!_psel)
		{
			Beep();
			return E_FAIL;
		}
		// Bug fix: 6498 - we need to know if scroll position is at bottom  
		// before inserting text
		if (Get10Mode())
		{
			LONG nMin, nMax, nPos, nPage;
			BOOL nEnable;
			TxGetVScroll(&nMin, &nMax, &nPos, &nPage, &nEnable);
			if (nEnable)
				_psel->SetAutoVScroll((nMax - nPage - 3) <= nPos);
		}
		prg = _psel;
	}
	else
	{
		_qwCharFlags &= FRTL | FDIGITSHAPE;	// No chars, so kill char flags
		if (!IsRich())
		{
			// Deleting all text from Plain text, we want to
			// go back to the -1 format
			prg->Set_iCF(-1);
			prg->SetUseiFormat(TRUE);
		}
		else
			_qwCharFlags |= FBELOWX40;		// For final EOP
	}

	if (flags & ST_CHECKPROTECTION &&
		IsProtectedRange(WM_SETTEXT, 0, (LPARAM)pstr, prg))
	{
		return E_ACCESSDENIED;
	}
	
    // 1.0 COMPATABILITY
    // 1.0 didn't scroll to selection if text is inserted via EM_REPLACESEL
    // and fHideSelection is FALSE;
	BOOL fUpdateCaret = !(Get10Mode() && (flags & ST_10REPLACESEL) &&
						fHideSelection() && !_psel->GetAutoVScroll());
	
	if(!(flags & ST_KEEPUNDO))
	{
		if(IsRich() && !fSel)
		{
			if (f10WM_SETTEXT)
			{
				// If pstr is empty string, retain format at end of current text.
				// If pstr is not empty string, retain format at cp = 1.
				// Note: prg->_rpCF is already at SetRun(0,0)
				CFormatRunPtr rp(prg->_rpCF);

				if (!pstr || *(LPBYTE)pstr == '\0')
				{
					LONG cchAdjusted = GetAdjustedTextLength() - 1;

					if (cchAdjusted > 0)
						rp.Move(cchAdjusted);
				}								
				
				CF = *(GetCharFormat(rp.GetFormat()));
				fSetCF = TRUE;
				
				prg->SetText(NULL);		// delete all the text first
			}

			// SetText causing all formatting to return to the default. We use
			// the notification system to remove the formatting. This is
			// particularly important for the final EOP which cannot be deleted.

			// Notify every interested party that they should dump their formatting
			_nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

			// Tell document to dump its format runs
			_story.DeleteFormatRuns();

			if (fSetCF)	
				prg->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);
		}

		publdr = NULL;
		if(_pundo)
			_pundo->ClearAll();

		if(_predo)
			_predo->ClearAll();

		// If we are re-entered, there may be anti-events higher up the
		// chain.  Grab the undo builder and clear things away if necessary.
		CGenUndoBuilder undobldr(this, 0);
		undobldr.Discard();
	}
	if(publdr)
		publdr->StopGroupTyping();

	// Need to reinit zoomin variables if entire text is being replaced
	if (!fSel)
		InitDocInfo();
	
	else if(_psel->GetCch())			// If insert into selection, need to
	{									//  insert an EOP if selection ends
		CPFRunPtr rp(*_psel);			//  at a table row delimiter
		if(_psel->GetCch() < 0)
			rp.Move(-_psel->GetCch());
		if(rp.IsTableRowDelimiter())
			_psel->InsertEOP(publdr, 0);
	}

	LONG lStreamFormat = IsRich() && IsRTF((LPSTR)pstr, 10) ? SF_RTF : 0;

	if(pstr && *(LPSTR)pstr && (CodePage != 1200 || lStreamFormat || *pstr < 128 && fSel && !*(pstr+1)))
	{
		LONG  cch = strlen((LPSTR)pstr);	// REMARK: little endian dependence
		DWORD ch = *(LPBYTE)pstr;			//  for CodePage = 1200 cases

		fInputString = TRUE;
		if(ch < 128 && fSel && cch == 1)
		{
			lres = 1;
			fSetTextMax = FALSE;
			TxSetMaxToMaxText(1);
			if(ch == CR)
				InsertEOP(0, FALSE, publdr);
			else
				_psel->PutChar(ch, 0, publdr);
		}
		else if(cch == 2 && ch == CR && *((LPSTR)pstr + 1) == LF)
		{
			lres = 2;
			fSetTextMax = FALSE;
			TxSetMaxToMaxText(2);
			InsertEOP(0, FALSE, publdr);
		}
		else
		{
			READHGLOBAL	rhg = {(LPSTR)pstr, cch};
			EDITSTREAM	es = {(DWORD_PTR)&rhg, S_OK, ReadHGlobal};	
			HCURSOR		hcur = NULL;

			// Want wait cursor to display sooner
			bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
			if(fSetCursor)
				hcur = TxSetCursor(LoadCursor(NULL, IDC_WAIT));

			if (CodePage <= 0)
			{
				if (Get10Mode())
				{
					LONG      iFormat  = _psel->GetiFormat();
					const CCharFormat *pCF = GetCharFormat(iFormat);

					CodePage = CodePageFromCharRep(pCF->_iCharRep);
				}
				else
					CodePage = (CodePage == 0) ? GetACP() : GetDefaultCodePage(EM_SETTEXTEX);
			}

			if(!lStreamFormat)
				lStreamFormat = SF_TEXT;
				
			lStreamFormat |= SF_USECODEPAGE | (CodePage << 16);

			if(fSel)
				lStreamFormat |= SFF_SELECTION;

			lres = _ldte.LoadFromEs(prg, lStreamFormat, &es, FALSE, publdr);
			if(fSetCursor)
				TxSetCursor(hcur);

			if(es.dwError != NOERROR)
				return (HRESULT)es.dwError;
		}
	}
	else
	{
		// 9052: Don't delete all if 4 (ST_NEWCHARS) is passed in EM_SETTEXTEX
		DWORD dwFlags = (flags & 4)
					  ? RR_ITMZ_UNICODEBIDI | RR_NEW_CHARS
					  : RR_ITMZ_UNICODEBIDI;

		if (CodePage != 1200 && pstr && !*(LPSTR)pstr)
			pstr = NULL;

		if(pstr && *pstr)
			fInputString = TRUE;
		lres = prg->CleanseAndReplaceRange(-1, pstr, FALSE, publdr, NULL, NULL, dwFlags);
	}

	if(!lres && fInputString)
	{
		// There was an input string but for some reason there was no update.
		return E_FAIL;
	}

	if (_fOutlineView)
	{
		// Outline view must have formatting.
		_psel->Check_rpPF();
	}

	
	if(_psel)
	{
		if(fSel)				
			_psel->Update(fUpdateCaret);
		else
		{
			// Setting the text means a new document so if there is a selection
			// turn it into an insertion point at the beginning of the document.
			_psel->ClearPrevSel();
			_psel->Set(0, 0);

			// Since the text is being completely replaced and all formatting
			// is being lost, let's go back to the default format for the
			// selection.
			if (!f10WM_SETTEXT)
				_psel->Set_iCF(-1);				
			else if (fSetCF)
				_psel->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);

			if(_fFocus || _psel->IsParaRTL())
			{
				// Update caret to reflect new postion
				_psel->UpdateCaret(fUpdateCaret);
			}
		}
	}

	// If we've replaced the entire document, the control isn't
	// really "modified" anymore.  This is necessary to match
	// the Windows MLE behavior.  However, since RichEdit 1.0
	// did _not_ do this (they left fModified to be TRUE), we
	// only do this for RichEdit 2.0 and later.

	if(!Get10Mode() && !publdr && !fSel)
		_fModified = FALSE;

	_fSaved = FALSE;						// ITextDocument isn't Saved

	// Adjust text limit if necessary
	if (fSetTextMax)
		TxSetMaxToMaxText();

	if(plres)
		*plres = fSel ? lres : 1;

	return S_OK;
}

/////////////////////////// ITextServices Methods ////////////////////////////////

// External IME Message Filter Interface factory
#ifndef NOFEPROCESSING
void CreateIMEMessageFilter(ITextMsgFilter **ppNewFilter);
#endif

/* 
 *	@doc EXTERNAL
 *
 *	CTxtEdit::TxSendMessage (msg, wparam, lparam, plresult)
 *
 *	@mfunc
 *		Used by window host to forward messages sent to its window to the 
 *		text services.
 *
 *	@rdesc
 *		NOERROR	Message was processed, and some action taken <nl>
 *		S_FALSE	Message was not processed.  Typically indicates that caller
 *				should process message, maybe by calling DefWindowProc <nl>
 *		S_MSG_KEYIGNORED Message processed, but no action was taken <nl>
 *		E_OUTOFMEMORY <nl>
 *
 *	@comm
 *		Note that two return values are passed back from this function.
 *		<p plresult> is the return value that should be passed back from a
 *		window proc.  However, in some cases, the returned LRESULT does not
 *		contain enough information.  For example, to implement cursoring
 *		around controls, it's useful to know if a keystroke (such as right
 *		arrow) was processed, but ignored (e.g. the caret is already at the
 *		rightmost position in the the text).  In these cases, extra
 *		information may be returned via the returned HRESULT.
 *
 *		WM_CHAR and WM_KEYDOWN should return S_MSG_KEYIGNORED when a key or
 *  	char has been recognized but had no effect given the current state,
 *		e.g., a VK_RIGHT key when the insertion point is already at the end of 
 *		the document). This is used by Forms3 to pass the key up the visual
 *  	hierarchy, so that for example, focus moves to the next control in the 
 *		TAB order. 
 *
 *		This includes the following cases:
 *
 *		1. Any key trying to move the insertion point beyond the end of the
 *		document; or before the begining of the document.
 *
 *		2. Any key trying to move the insertion point beyond the last line or
 *		before the first line.
 *
 *		3. Any insertion of character (WM_CHAR) that would move the insertion
 *		point past the maximum length of the control.
 */
HRESULT	CTxtEdit::TxSendMessage (
	UINT	msg, 		//@parm	Message id
	WPARAM	wparam, 	//@parm WPARAM from window's message
	LPARAM	lparam,		//@parm LPARAM from window's message
	LRESULT *plresult)	//@parm Where to put message's return LRESULT
{
	TRACEBEGINPARAM(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSendMessage", msg);

	CObjectMgr *pobjmgr;
	HRESULT		hr = NOERROR;
	LRESULT		lres = 0;
 	CCallMgr	callmgr(this);

 	if ( CW32System::_MSMouseRoller == msg )					// map Magellan msg.
	{
	    // map this message to WM_MOUSEWHEEL
	    // In these cases the driver doesn't set the key state properly so
	    // we have to do it ourselves
	    short zdelta = (short)(long)wparam;
	    short kstate = 0;
	    if (GetKeyboardFlag(CTRL, VK_CONTROL))
	        kstate |= MK_CONTROL;
	    if (GetKeyboardFlag(SHIFT, VK_SHIFT))
	        kstate |= MK_SHIFT;
	        
	    wparam = MAKELONG(kstate, zdelta);
		msg = WM_MOUSEWHEEL;
	}

#ifndef NOFEPROCESSING
	if (_pMsgFilter)
	{
PassMsg:
		hr = _pMsgFilter->HandleMessage(&msg, &wparam, &lparam, &lres);
		if (hr == S_OK)					// Message has been handled. 
		{
			if(plresult)
				*plresult = lres;

			return S_OK;
		}
		hr = S_OK;						// Reset
	}
	else if (LoadMsgFilter(msg, wparam, lparam))
	{
		HWND hwnd = NULL;
		if (_fInOurHost)
		{
			// If not in Forms^3 we can get the window from our host.
			// For Forms^3 we will use NULL for the desktop Window and pray
			TxGetWindow( &hwnd );
		}
		ITextMsgFilter *pNewFilter = NULL;

		CreateIMEMessageFilter(&pNewFilter);

		if (pNewFilter)
		{
			pNewFilter->AttachDocument( hwnd, (ITextDocument2 *) this, (ITextServices *) this );
			AttachMsgFilter(pNewFilter);
			goto PassMsg;
		}
	}
#endif

	START_PROFILING

	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	switch(msg)
	{
	case EM_CANPASTE:
		// we don't check for protection here, as RichEdit 1.0
		// doesn't
		lres = _ldte.CanPaste(NULL, (CLIPFORMAT) wparam, RECO_PASTE);
		break;

	case EM_CANUNDO:
		if(_pundo)
			lres = _pundo->CanUndo();
		break;

	case EM_CANREDO:
		if(_predo)
			lres = _predo->CanUndo();
		break;

	case EM_GETUNDONAME:
		if(_pundo)
			lres = _pundo->GetNameIDFromAE((void*)wparam);
		break;

	case EM_GETREDONAME:
		if(_predo)
			lres = _predo->GetNameIDFromAE((void*)wparam);
		break;

	case EM_STOPGROUPTYPING:
		if(_pundo)
		{
			// we'll only stop group typing iff wparam
			// is zero (meaning stop regardless) _or_ if
			// wparam matches the merge anti event.  
			//
			// This feature allows clients to say that only
			// a specific anti-event should close out it's
			// "fuzzy" state.  Note that currently, only the
			// merge anti-event has this fuzzy state.

			if(!wparam || (IAntiEvent *)wparam == _pundo->GetMergeAntiEvent())
				_pundo->StopGroupTyping();
		}
		break;

	case WM_UNICHAR:						// Unambiguous Unicode character
		if(wparam == NOTACHAR)
		{
			lres = TRUE;					// Tell caller we understand msg
			break;
		}									// Else fall thru to WM_CHAR

	case WM_CHAR:
        if(GetKeyboardFlags() & (ALTNUMPAD | HOTEURO))
		{
			if (GetKeyboardFlags() & ALTNUMPAD)
			{
				if (GetKeyboardFlags() & ALT0 &&
					GetCharFormat(-1)->_iCharRep == MAC_INDEX &&
					GetKeyboardCharRep(0) == ANSI_INDEX)
				{
					WCHAR ch;
					UnicodeFromMbcs(&ch, 1, (char *)&wparam, 1, 10000);
					wparam = ch;
					SetKeyPadNumber(ch);
					ResetKeyboardFlag(ALTNUMPAD | ALT0);
				}
#ifndef NOANSIWINDOWS
				else
				{
					CW32System::WM_CHAR_INFO wmci;
					wmci._fAccumulate = FALSE;
					W32->AnsiFilter(msg, wparam, lparam, (void *)&wmci);
				}
#endif
			}
			else						// (GetKeyboardFlags() & HOTEURO) case
			{
				// We have handled the Euro, just eat this WM_CHAR
				ResetKeyboardFlag(HOTEURO);
				break;
			}
		}								// Fall thru to WM_IME_CHAR

	case WM_IME_CHAR:					// 2 byte character, usually FE.
		lres = hr = OnTxChar((DWORD)wparam, (DWORD)lparam, publdr);
		ResetKeyboardFlag(HOTEURO);		
		break;

	case WM_USER + 39:					// For backward compat with NT 3.51
	case EM_CHARFROMPOS:
		hr = TxCharFromPos((LPPOINT)lparam, &lres);
		break;

#ifdef WM_INPUTLANGCHANGE
	case WM_INPUTLANGCHANGE:
		if (_fSingleCodePage)
		{
			// See if the charset for the specified keyboard is supported by
			// the single code page we support. If we don't have a _pDocInfo,
			// assume the code page is the system code page. We will always
			// support the ANSI charset, as all code pages contain at least
			// a large portion of this charset (the ASCII block).
			wparam = (!wparam || wparam == GetCharSet(_pDocInfo ?
						_pDocInfo->_wCpg : GetSystemDefaultCodePage()));
		}
		goto update_kbd;
	
	case WM_INPUTLANGCHANGEREQUEST:
		// If the SingleCodePage option is set, then we must have a
		// "good" code page to go to; if not, just eat this message.
		//
		// This will prevent folks from typing French and Greek
		// on the same edit control, which is useful for certain
		// kinds of backward compatibility scenarios.
		//
		// HACK ALERT!  the documentation on WM_INPUTLANGCHANGEREQUEST
		// is wrong.  It turns out that _only_ the low bit of wparam
		// indicates whether or not the new keyboard can be considered
		// as the same code page.

		if (_fSingleCodePage && !(wparam & 1))
		{
			// The lowest bit check is not reliable in some platforms e.g. Viet OSR2
			// since it doesnt allow English kbd to match system charset (bug #6365).

			wparam = PRIMARYLANGID(LOWORD(lparam)) == LANG_ENGLISH &&
					 IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(LOWORD(lparam)), SUBLANG_ENGLISH_UK);
		}

update_kbd:
		if(!_fSingleCodePage || (wparam & 1))
		{
			WORD	wKLCurrent = LOWORD(GetKeyboardLayout(0));

			// Update our idea of current keyboard layout
			W32->RefreshKeyboardLayout();

			if(GetKeyboardFlags() & CTRL && GetKeyboardFlags() & SHIFT)
				SetKeyboardFlag(LETAFTERSHIFT);

			if(	wKLCurrent == LOWORD(lparam) ||			// No change in keyboard				
				GetSel()->CheckChangeFont((HKL)lparam, CharRepFromLID(LOWORD(lparam))))
				hr = S_FALSE;	// cause default window to allow kb switch.	
		}
		break;
#endif

	case WM_CLEAR:
		OnClear(publdr);
		break;

	case WM_CONTEXTMENU:
		hr = OnContextMenu(lparam);
		break;

	case WM_COPY:
	case WM_CUT:
		lres = hr = CutOrCopySelection(msg, wparam, lparam, publdr);
		break;

	case WM_RENDERFORMAT:
		lres = hr = _ldte.RenderClipboardFormat(wparam);
		break;

	case WM_RENDERALLFORMATS:
		lres = hr = _ldte.RenderAllClipboardFormats();
		break;

	case WM_DESTROYCLIPBOARD:
		lres = hr = _ldte.DestroyClipboard();
		break;

	case EM_DISPLAYBAND:
		if (fInplaceActive())
		{
			{
				CLock lock;

				if (g_OLSBusy)
				{
					hr = OLE_E_INVALIDRECT;
					break; 
				}
			}
			OnDisplayBand((const RECT *) lparam, FALSE);
			lres = 1;
		}
		else
			hr = OLE_E_INVALIDRECT;
		break;

#ifdef WM_DROPFILES
	case WM_DROPFILES:
		OnDropFiles((HANDLE) wparam);
		break;
#endif

	case EM_EMPTYUNDOBUFFER:
		ClearUndo(publdr);
		break;

	case WM_ERASEBKGND:
		lres = 1;				// We handle background erase during painting
		break;

	case EM_EXGETSEL:						// Has cp output parameter
		OnExGetSel((CHARRANGE *)lparam);
		break;

	case EM_FINDTEXT:						// Has cp input/output parms
	case EM_FINDTEXTW:						// Has cp input/output parms
	case EM_FINDTEXTEX:						// Has cp input/output parms
	case EM_FINDTEXTEXW:					// Has cp input/output parms
		lres = OnFindText(msg, (DWORD)wparam, (FINDTEXTEX *)lparam);
		break;

	case EM_FINDWORDBREAK:					// Has cp input/output parms
		hr = TxFindWordBreak((INT)wparam, (LONG)lparam, &lres);
		break;

	case EM_FORMATRANGE:					// Has cp input/output parms
		if(fInplaceActive())
		{
			{
				CLock lock;

				if (g_OLSBusy)
				{
					hr = OLE_E_INVALIDRECT;
					break;
				}
			}
			SPrintControl prtcon;
			prtcon._fDoPrint = (wparam) ? TRUE : FALSE;
			lres = OnFormatRange((FORMATRANGE *) lparam, prtcon);

		}
		else
			hr = OLE_E_INVALIDRECT;
		break;

	case EM_GETTYPOGRAPHYOPTIONS:
		lres = _bTypography;
		break;

	case EM_GETBIDIOPTIONS:
		if((Get10Mode() || !wparam) && lparam && ((BIDIOPTIONS *)lparam)->cbSize == sizeof(BIDIOPTIONS))
		{
			((BIDIOPTIONS *)lparam)->wMask =
				BOM_NEUTRALOVERRIDE | BOM_CONTEXTREADING | BOM_CONTEXTALIGNMENT;
			((BIDIOPTIONS *)lparam)->wEffects =
				(_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
				(_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
				(_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);
		}
		break;

	case EM_GETCHARFORMAT:
		lres = OnGetCharFormat((CHARFORMAT2 *)lparam, wparam);
		break;

	case EM_GETCODEPAGE:
		lres = GetDefaultCodePage((UINT)wparam);
		break;

	case EM_GETFIRSTVISIBLELINE:
		if (fInplaceActive())
			lres = _pdp->GetFirstVisibleLine();
		else
			hr = OLE_E_INVALIDRECT;
		break;

	case EM_GETLIMITTEXT:					// Has cp output parameter (sort of)
		lres = TxGetMaxLength();			// Ignore unless testing screams
		break;							  

	case EM_GETLINE:
		if(fInplaceActive())
		{
			lres = _pdp->GetLineText((LONG)wparam, (TCHAR *)lparam,
								(LONG) (*(WORD *) lparam));
		}
		else
			hr = OLE_E_INVALIDRECT;
		break;

	case EM_GETLINECOUNT:
		hr = TxGetLineCount(&lres);
		break;

	case EM_GETMODIFY:				// RichEdit 1.0 returned -1 if _fModified
		lres = -(LONG)_fModified;	//  is TRUE (go figure). So for backward
		break;						//  compatibility, we do too :-(

	case EM_GETOLEINTERFACE:
		if(lparam)
		{
#ifndef NOFEPROCESSING
			if (wparam == 0x065737777)		// 'AIMM'
				W32->GetAimmObject((IUnknown **)(lparam));
			else
#endif
			{				
				*(IRichEditOle **)lparam = (IRichEditOle *)this;
				AddRef();				
			}
		} 
		lres = TRUE;
		break;

    case EM_GETSCROLLPOS:
        {
            POINT *point = (POINT *)lparam;
            point->x = _pdp->GetUpScroll();
			point->y = _pdp->GetVpScroll();
			point->y = _pdp->ConvertVPosToScrollPos(point->y);
            lres = 1;
        }
        break;

	case EM_SETOLECALLBACK:
		hr = E_FAIL;
		if(lparam)
		{
			pobjmgr = GetObjectMgr();
			if(pobjmgr)
			{
				pobjmgr->SetRECallback((IRichEditOleCallback *)lparam);
				lres = TRUE;
				hr = NOERROR;
			}
		}
		break;

	case EM_GETPAGE:
		lres = -1;					// Signal page not available
		if(_pdp)
		{
			LONG i;
			hr = _pdp->GetPage(&i, (DWORD)wparam, (CHARRANGE *)lparam);
			if(hr == NOERROR)
				lres = i;
		}
		break;

	case EM_GETPARAFORMAT:
		lres = OnGetParaFormat((PARAFORMAT2 *)lparam, wparam);
		break;

	case EM_GETSEL:							// Has cp output parameter
		lres = OnGetSel((LONG*)wparam, (LONG*)lparam);
		break;

	case EM_GETSELTEXT:
		lres = OnGetSelText((TCHAR *)lparam);
		break;

	case WM_GETTEXT:
		{
			GETTEXTEX gt;

			gt.cb = wparam * 2;
			gt.flags = GT_USECRLF;
			gt.codepage = 1200;
			gt.lpDefaultChar = NULL;
			gt.lpUsedDefChar = NULL;

			lres = GetTextEx(&gt, (TCHAR *)lparam);
		}
		break;

	case WM_GETTEXTLENGTH:					// Has cp output parameter
		{
			GETTEXTLENGTHEX gtl;

			gtl.flags = GTL_NUMCHARS | GTL_PRECISE | GTL_USECRLF;
			gtl.codepage = 1200;

			lres = GetTextLengthEx(&gtl);
		}
		break;
	
	case EM_GETTEXTEX:
		lres = GetTextEx((GETTEXTEX *)wparam, (TCHAR *)lparam);
		break;

	case EM_GETTEXTLENGTHEX:				// Has cp output parameter
		lres = GetTextLengthEx((GETTEXTLENGTHEX *)wparam);
		break;

	case EM_GETTEXTRANGE:					// Has cp input parameter
	{
		TEXTRANGE * const ptr = (TEXTRANGE *)lparam;
		LONG			  cch = ValidateTextRange(ptr);

		// Only copy if there's something to copy and destination is valid
		if(cch)
		{
			LONG cpMin  = GetCpFromAcp(ptr->chrg.cpMin);
			if(cch < 0)						// Get text character count
				cch = GetTextLength();		//  because caller wants it all
			else							 // + 1 is for terminating 0
				cch = GetCpFromAcp(ptr->chrg.cpMost) - cpMin + 1;

			if(!IsBadWritePtr(ptr->lpstrText, cch * sizeof(TCHAR)))
				lres = GetTextRange(cpMin, cch, ptr->lpstrText);
		}
	}
		break;

	case EM_GETVIEWKIND:
		GetViewKind(&lres);
		break;

#ifndef NOWORDBREAKPROC
	case EM_GETWORDBREAKPROC:
		// Client can only use either WordBreakProc or ExWordBreakProc
		// Return NULL if ExWordBreakProc is being used.
		if (!_fExWordBreakProc)		
			lres = (LRESULT) _pfnWB;
		break;

	case EM_GETWORDBREAKPROCEX:
		// Return ExWordBreakProc if it is being used.
		if (_fExWordBreakProc)		
			lres = (LRESULT) _pfnWB;
		break;
#endif

	case EM_GETZOOM:
		if(wparam && lparam)
		{
			*(unsigned *)wparam = GetZoomNumerator();
			*(unsigned *)lparam = GetZoomDenominator();
			lres = 1;
		}
		break;

	case EM_HIDESELECTION:
	    if (Get10Mode() && lparam)
	        _fHideSelection = !!wparam;

		if(!lparam || !_fFocus)
			lres = OnHideSelectionChange((BOOL)wparam);
		break;

	case WM_HSCROLL:
		if (IsUVerticalTflow(_pdp->GetTflow()))
		{
			WORD wCode = LOWORD(wparam);
			wCode = InterchangeScrollCode(wCode);
			LONG vpPos = HIWORD(wparam);

			//In vertical displays the scrollbar position needs to be swapped.
			if (_pdp->GetTflow() == tflowSW &&
				(wCode == SB_THUMBTRACK || wCode == SB_THUMBPOSITION))
			{
				LONG vpMax, vpPage;
				TxGetHScroll(NULL, &vpMax, NULL, &vpPage, NULL);
				vpPos = vpMax - vpPos - vpPage;
				vpPos = max(vpPos, 0);
			}

			hr = _pdp->VScroll(wCode, vpPos);
		}
		else
		{
			_pdp->UScroll(LOWORD(wparam), HIWORD(wparam));
			hr = 0;
		}
		break;

	case WM_KEYDOWN:
		hr = OnTxKeyDown((WORD) wparam, (DWORD) lparam, publdr);
		break;

	case WM_KEYUP:
		if(wparam == VK_APPS)
			HandleKbdContextMenu();
		else							// Else don't say we processed
			hr = S_FALSE;				//  message

		W32->_fLRMorRLM = 0;
		if(wparam == VK_CONTROL || wparam == VK_SHIFT)
		{
			// If a BiDi keyboard is installed, no strong-context behavior,
			// both a Ctrl and a Shift key are pressed, no letter has been
			// typed after the Ctrl and Shift keys have been pressed, and
			// ReadOnly/Protected tests allow, then the selected paragraphs
			// are set to RTL/LTR direction for the right/left Shift key,
			// respectively. The keyboard and caret are also matched to this
			// direction, and an alignment notification is sent.
			// ReadOnly/Protected tests is removed for backward compatibility.
			DWORD dwFlags = GetKeyboardFlags();

			if (IsBiDiKbdInstalled() &&
				!IsStrongContext(_nContextDir) &&
	 			!IsStrongContext(_nContextAlign) &&
	 			(dwFlags & CTRL) && (dwFlags & SHIFT) &&
				!(dwFlags & LETAFTERSHIFT) 
				/* && IsntProtectedOrReadOnly(WM_KEYUP, wparam, lparam) */ )
			{
				CParaFormat PF;
				PF._wEffects = (dwFlags & RSHIFT) ? PFE_RTLPARA : 0;

				OnSetParaFormat(0, &PF, publdr, PFM_RTLPARA, PFM2_PARAFORMAT);
				TxNotify(PF._wEffects ? EN_ALIGNRTL : EN_ALIGNLTR, 0);
			}
			if(wparam == VK_CONTROL)
				lparam = (HIWORD(lparam) & KF_EXTENDED) ? RCTRL : LCTRL;
			else
			{
				lparam = (LOBYTE(HIWORD(lparam)) == 0x36) ? RSHIFT : LSHIFT;
				if(GetKeyState(VK_SHIFT) >= 0)	// Ensure both shifts are off
					lparam = SHIFT;				//  (potential Win95 problem)
			}
			ResetKeyboardFlag(lparam | LETAFTERSHIFT | HOTEURO);
        }
        else if(wparam == VK_MENU)
            ResetKeyboardFlag((HIWORD(lparam) & KF_EXTENDED) ? (RALT | HOTEURO) : (LALT | HOTEURO));

		break;

	case WM_KILLFOCUS:
		lres = OnKillFocus();
		break;

	case WM_LBUTTONDBLCLK:
		hr = OnTxLButtonDblClk(MOUSEX, MOUSEY, (WORD) wparam);
		break;

	case WM_LBUTTONDOWN:
		if(_fEatLeftDown)
		{
			TxSetFocus();
			_fEatLeftDown = FALSE;
		}
		else
			hr = OnTxLButtonDown(MOUSEX, MOUSEY, (WORD) wparam);
		break;

	case WM_LBUTTONUP:
		hr = OnTxLButtonUp(MOUSEX, MOUSEY, (WORD) wparam, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
		break;

#if !defined(NOMAGELLAN)
	case WM_MBUTTONDBLCLK:						// Magellan zmouse scroll
	case WM_NCMBUTTONDOWN:						//  support commandeers middle
	case WM_MBUTTONDOWN:						//  button.
		OnTxMButtonDown(MOUSEX, MOUSEY, (WORD) wparam);	
		break;

	case WM_MBUTTONUP:
		OnTxMButtonUp(MOUSEX, MOUSEY, (WORD) wparam);
		break;

	case WM_MOUSEWHEEL:						// Magellan zmouse scroll n lines.
		lres = HandleMouseWheel(wparam, lparam);
		break;
#endif

	case EM_LINEFROMCHAR:					// Has cp input parameter
		lparam = wparam;					// Fall thru to EM_EXLINEFROMCHAR

	case EM_EXLINEFROMCHAR:					// Has cp input parameter
		hr = TxLineFromCp((LONG)lparam, &lres);
		break;

	case EM_LINEINDEX:						// Has cp output parameter
		hr = TxLineIndex((LONG)wparam, &lres);
		break;

	case EM_LINELENGTH:						// Has cp input/output parameters
		hr = TxLineLength((LONG)wparam, &lres);
		break;

	case EM_LINESCROLL:						// Has cp input parameter (cch)
	    // Documentation says the line to scroll to should be relative to the current top line.
	    // Richedit 2.0 based it on an absolute position.  We're breaking richedit 2.0 compatibility
	    // to go back to the documentation specification and to match what riched 1.0 originally
	    // did        
		hr	 = TxLineScroll((LONG)lparam, (LONG)wparam);// but not curr impl
		lres = _pdp->IsMultiLine();
		break;

#ifdef MA_ACTIVATE
	case WM_MOUSEACTIVATE:
		lres = MA_ACTIVATE;
		// If the window that currently has focus is part of our "application",
		// then don't eat the mouse click.  Otherwise, if it's from another
		// app, the user is probably trying to swap apps, so eat the mouse
		// down message and let our host app get a chance to come to the
		// foreground.
		if (!(IsChild((HWND)wparam, GetFocus()) ||
			(wparam && (HWND)wparam == GetFocus())))
		{
			_fEatLeftDown = TRUE;
		}
		hr = S_FALSE;		// pass WM_MOUSEACTIVATE message to DefWindProc
		break;
#endif

	case WM_MOUSEMOVE:
		// We reset the "number of tries to put an active object 
		//	in place" count here
		_cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
		hr = OnTxMouseMove(MOUSEX, MOUSEY, (WORD)wparam, publdr);
		break;

    case EM_OUTLINE:
    {
		CFreezeDisplay cfd(_pdp);

		if(wparam == EMO_GETVIEWMODE)
		{
			hr = GetViewKind(&lres);
			break;
		}

		CTxtSelection *	psel = GetSelNC();

		if(!_pdp->IsMultiLine() || !IsRich() || !psel)	// Control must be rich,
			break;									//  multiline and active
        
		if(wparam == EMO_ENTER || wparam == EMO_EXIT)
		{
			hr = SetViewKind(wparam == EMO_ENTER ? VM_OUTLINE : VM_NORMAL);
			lres = !hr;
			break;
		}

        if(!IsInOutlineView() || !IsntProtectedOrReadOnly(msg, wparam, lparam))
			break;

		CTxtRange rg(*psel);

		switch(wparam)
        {
            case EMO_PROMOTE:
				hr = rg.Promote(lparam, publdr);
				psel->Update_iFormat(-1);
				psel->Update(FALSE);
                break;

            case EMO_EXPAND:
				hr = rg.ExpandOutline((short)LOWORD(lparam),
									  HIWORD(lparam) == EMO_EXPANDDOCUMENT);
				break;

			case EMO_MOVESELECTION:
				hr = MoveSelection(lparam, publdr);
				psel->Update(TRUE);
				break;

			default:
//				TraceMessage("Unknown outline function received\r\n");
				break;
		};
		lres = !hr;
		_fModified = TRUE;
	}
		break;

	case WM_PASTE:
	case EM_PASTESPECIAL:
		if(IsntProtectedOrReadOnly(msg, wparam, lparam))
		{
			CTxtSelection *psel = GetSel();

			hr = PasteDataObjectToRange(NULL, psel, 
				(CLIPFORMAT) wparam, (REPASTESPECIAL *)lparam, publdr,
				PDOR_NONE);
		}
		break;

	case WM_USER + 38:					// For backward compat with NT 3.51
	case EM_POSFROMCHAR:				// Has cp input parameter
        // RichEdit 2.x used wparam instead of lparam for the cp and ignored
        // wparam, unlike RE 1.0 and the Win32 documentation (sigh!). We fix
        // this, but are compatible with RE 2.x for cp's whose values
		// correspond to invalid write ptr's.
		if(IsBadWritePtr((LPPOINT)wparam, sizeof(POINT)))	
		{										
			// Invalid write ptr, so assume incorrect RE 2.0 params
			// TODO: enable following Assert when msgtest gets updated
			//AssertSz(FALSE,
			//	"EM_POSFROMCHAR: wparam is illegal ptr, assuming cp value");
			POINT pt;
			hr = TxPosFromChar((LONG)wparam, &pt);
			lres = SUCCEEDED(hr) ? MAKELONG(pt.x, pt.y) : -1;
		}
		else
			hr = TxPosFromChar((LONG)lparam, (LPPOINT)wparam);
		break;

#ifndef NORBUTTON
	case WM_RBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
		// Give client a chance to handle these messages,
		// if we are over a link
		if(HandleLinkNotification(msg, wparam, lparam))
			break;

		if(msg == WM_RBUTTONUP)
			hr = OnTxRButtonUp(MOUSEX, MOUSEY, (WORD) wparam, RB_DEFAULT);

		else if( msg == WM_RBUTTONDOWN)
			hr = OnTxRButtonDown(MOUSEX, MOUSEY, (WORD) wparam);

		break;
#endif

	case EM_INSERTTABLE:
		lres = hr = OnInsertTable((TABLEROWPARMS *)wparam, (TABLECELLPARMS *)lparam, publdr);
		break;

	case EM_REPLACESEL:
		wparam = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO
						: ST_CHECKPROTECTION | ST_SELECTION;
		hr = SetText((LPTSTR)lparam, wparam, 1200, publdr, &lres);
		break;

	case EM_REQUESTRESIZE:
		hr = _pdp->RequestResize();
		break;

	case EM_SCROLL:
		// TxVScroll returns the number of lines scrolled;
		// this info should be returned in lres
		lres = _pdp->VScroll((WORD)wparam, 0);
		break;

	case EM_SCROLLCARET:
		OnScrollCaret();
		break;

	case EM_SELECTIONTYPE:
	{
		SELCHANGE selchg;

		GetSel()->SetSelectionInfo(&selchg);
		lres = selchg.seltyp;
	}
		break;

	case EM_SETTYPOGRAPHYOPTIONS:
		// Don't allow typography options for password & accelerator instances
		hr = OnSetTypographyOptions(wparam, lparam);
		lres = (hr == S_OK);
		break;

	case EM_SETBIDIOPTIONS:
		if((Get10Mode() || !wparam) && lparam && !IsRich())
		{
			WORD wMask = ((BIDIOPTIONS *)lparam)->wMask;
			WORD wEffects = (_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
							(_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
							(_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);

			wEffects &= ~wMask;
			wEffects |= (wMask & ((BIDIOPTIONS *)lparam)->wEffects);
			if (_fNeutralOverride != !!(wEffects & BOE_NEUTRALOVERRIDE))
			{
				_fNeutralOverride = !_fNeutralOverride;
				if (!_pdp->IsPrinter())				// Refresh display
				{
					_pdp->InvalidateRecalc();
					TxInvalidate();
				}
			}
			_nContextDir   = (WORD)((wEffects & BOE_CONTEXTREADING)   ? CTX_NEUTRAL : CTX_NONE);
			_nContextAlign = (WORD)((wEffects & BOE_CONTEXTALIGNMENT) ? CTX_NEUTRAL : CTX_NONE);
			if(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE)
			{
				SetContextDirection(TRUE);
				Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
			}
		}
		break;

	case WM_SETFOCUS:
		hr = OnSetFocus();
		break;

	case EM_SETFONTSIZE:
		lres = OnSetFontSize(LONG(wparam), (DWORD)lparam, publdr);
		break;

	case EM_SETMODIFY:
		_fModified = wparam != 0;

#ifdef	LATER
		if (!_fModified)
			ObFreezeFrames();
#endif						// LATER
		break;

    case EM_SETSCROLLPOS:
        {
            POINT *pPoint = (POINT*)lparam;
            _pdp->ScrollView(pPoint->x, pPoint->y, FALSE, TRUE);
            lres = 1;
        }
        break;
	
	case EM_EXSETSEL:
		// EM_EXSETSEL duplicates the functionality of the 32-bit EM_SETSEL
		// and exists purely for backward compatibility with Win16. We just
		// repackage the params and fall thru to EM_SETSEL
		wparam = (WPARAM)((CHARRANGE *)lparam)->cpMin;
		lparam = (LPARAM)((CHARRANGE *)lparam)->cpMost;

		// FALL-THROUGH to EM_SETSEL!!!

	case EM_SETSEL:
		lres = OnSetSel((LONG)wparam, (LONG)lparam);
		break;

	// INCREDIBLY EVIL HACK ALERT!!!!!  Win95's dialog manager doesn't even
	// pretend to be 32 bits despite the best attempts of our marketing dudes.
	// WM_USER + 1 is the old Win3.0 EM_SETSEL in which the selection range
	// was packed into the lparam.
	//
	// Sometimes (like tabbing through a dialog), Win95 will send us the 16
	// bit EM_SETSEL message, so process it here.
	case (WM_USER + 1):
		lres = OnSetSel(LOWORD(lparam), HIWORD(lparam));
		break;

	case EM_SETTARGETDEVICE:
		// Keep width sane so that LXtoDX works OK at least for displays
		// Note that 0x7fffff = 485 feet! This keeps LXtoDX working provided
		// _xPerInch < 257 (it's typically 96 for displays). For more
		// generality, we'd need to use 64-bit arithmetic (see LXtoDX).
		lparam = min(lparam, (LPARAM)0x7fffff); 
		lres = _pdp->SetMainTargetDC((HDC)wparam, (LONG)lparam);
		break;

	case EM_SETTEXTEX:
		hr = SetText((LPTSTR)lparam, ((SETTEXTEX *)wparam)->flags,
									 ((SETTEXTEX *)wparam)->codepage, publdr, &lres);
		break;

	case WM_SETTEXT:
		hr = SetText((LPTSTR)lparam, ST_CHECKPROTECTION, wparam ? wparam : 1200, publdr, &lres);
		break;

	case EM_SETVIEWKIND:
		hr = SetViewKind(wparam);
		break;

#ifndef NOWORDBREAKPROC
	case EM_SETWORDBREAKPROC:
	    _fExWordBreakProc = 0;
		_pfnWB = (EDITWORDBREAKPROC) lparam;
		break;

	case EM_SETWORDBREAKPROCEX:
	    // We don't support this API in 2.0 and greater because we pass
	    // UNICODE text to the callback function.  Therefore there
	    // are no benefits to this API.  Exists for 1.0 backward
	    // compatibility only.
	    if (Get10Mode())
	    {
    	    _fExWordBreakProc = 1;

			// This is a bit deceiving, but lparam is a EDITWORDBREAKPROCEX but the compiler
			// will generate an error if you try to type cast the l-value
    	    _pfnWB = (EDITWORDBREAKPROC) lparam;
	    }
	    break;
#endif    

	case WM_SYSCHAR:
		lres = hr = OnTxSysChar((WORD)wparam, (DWORD)lparam, publdr);
		if(hr == S_OK)
			break;
		goto def;

	case WM_SYSKEYUP:
		if(IN_RANGE(VK_SHIFT, wparam, VK_MENU))
			ResetKeyboardFlag(GetKbdFlags((WORD)wparam, (DWORD)lparam));

		if (IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)  ||
			wparam == VK_CLEAR || wparam == VK_INSERT ||
			IN_RANGE(VK_PRIOR, wparam, VK_DOWN))
		{
			// Collect AltNumPad number to word around NT 4 bug and
			// generalize to any Unicode value (in decimal, ugh!)
			const static BYTE VkeyNumbers[] = {VK_NUMPAD9, VK_NUMPAD3, VK_NUMPAD1,
				VK_NUMPAD7, VK_NUMPAD4, VK_NUMPAD8, VK_NUMPAD6, VK_NUMPAD2, 0, 0,
				0, 0, VK_NUMPAD0}; 
											// Flag Alt NumPad char typed to
			SetKeyboardFlag(ALTNUMPAD);		//  distinguish hiANSI from	lead
			if(!IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)) // byte in Win3.1 IME
			{								// Collect AltNumPad number
				if(wparam == VK_CLEAR)		// NumLock not active: translate	
					wparam = VK_NUMPAD5;	//  to digit codes
				else
					wparam = VkeyNumbers[wparam - VK_PRIOR];
			}
			DWORD dwNum = GetKeyPadNumber();
			if(!dwNum && wparam == VK_NUMPAD0)
				SetKeyboardFlag(ALT0);		// Flag that 0 is first digit
			SetKeyPadNumber(10*dwNum + wparam - VK_NUMPAD0);
		}									
		goto def;

	case WM_SYSKEYDOWN:
		if(OnTxSysKeyDown(wparam, lparam, publdr) == S_OK)
		{
			lres = TRUE;
			break;
		}
		goto def;

	case WM_TIMER:
		OnTxTimer((UINT)wparam);
		goto def;

	case EM_UNDO:
	case WM_UNDO:
		if (!_fReadOnly)
		{
			hr = PopAndExecuteAntiEvent(_pundo, (void*)wparam);
			if(hr == NOERROR)
				lres = TRUE;
		}
		break;

	case EM_REDO:
		if (!_fReadOnly)
		{
			hr = PopAndExecuteAntiEvent(_predo, (void*)wparam);
			if(hr == NOERROR)
				lres = TRUE;
		}
		break;

	case EM_SETUNDOLIMIT:
		lres = HandleSetUndoLimit((DWORD)wparam);
		break;

	case WM_VSCROLL:
		// TxVScroll returns the number of lines scrolled;
		// WM_VSCROLL doesn't care about that info however.
		Assert(lres == 0);
		Assert(hr == NOERROR);

		if (IsUVerticalTflow(_pdp->GetTflow()))
			_pdp->UScroll(LOWORD(wparam), HIWORD(wparam));
		else
			_pdp->VScroll(LOWORD(wparam), HIWORD(wparam));
		break;

	case EM_GETHYPHENATEINFO:
		{
			HYPHENATEINFO *phyphinfo = (HYPHENATEINFO*) wparam;
			if (phyphinfo->cbSize >= sizeof(HYPHENATEINFO))
			{			
				phyphinfo->pfnHyphenate = _pfnHyphenate;
				phyphinfo->dxHyphenateZone = _dulHyphenateZone;
			}
			else
				hr = E_INVALIDARG;
		}
		break;

	case EM_SETHYPHENATEINFO:
		{
			HYPHENATEINFO *phyphinfo = (HYPHENATEINFO*) wparam;
			if (phyphinfo->cbSize >= sizeof(HYPHENATEINFO))
			{	
				BOOL fRedraw = FALSE;
				if (phyphinfo->pfnHyphenate != _pfnHyphenate || 
					_pfnHyphenate && _dulHyphenateZone != phyphinfo->dxHyphenateZone)
					fRedraw = TRUE;

				_pfnHyphenate = phyphinfo->pfnHyphenate;
				_dulHyphenateZone = _pfnHyphenate ? phyphinfo->dxHyphenateZone : 0;
				if (fRedraw)
					_pdp->UpdateView();
			}
			else
				hr = E_INVALIDARG;
		}
		break;

	case EM_GETAUTOCORRECTPROC:
		{
			if (_pDocInfo)
				lres = (LRESULT) _pDocInfo->_pfnAutoCorrect;
		}
		break;

	case EM_SETAUTOCORRECTPROC:
		{
			CDocInfo *pDocInfo = GetDocInfo();
			if (pDocInfo)
				pDocInfo->_pfnAutoCorrect = (AutoCorrectProc) wparam;
			else;
				lres = TRUE;
		}
		break;

	// Old stuff that's no longer supported
	case EM_FMTLINES:				// Controls returning CRCRLFs for soft
									//  line breaks in EM_GETTEXT. Could
									//  implement
	case WM_GETFONT:				// Can support but have to hang onto a
									//  default HFONT. CCcs has an _hfont, but
									//  need to be sure default font is in
									//  cache at time of return
#ifdef EM_GETHANDLE
	case EM_GETHANDLE:				// Not supported by Win95 32-bit MLE either
	case EM_SETHANDLE:				// Not supported by Win95 32-bit MLE either
#endif

#ifdef DEBUG
		TRACEINFOSZ("Old message that is no longer supported.");
#endif
		break;

	case EM_SETTABSTOPS:
	{
		// this message only works for multi-line edit controls
		if(!_pdp->IsMultiLine())
			break;			
		
		// perform some validation checks
		Assert(lparam || !wparam);
		LPDWORD prgdwdlgCoord = (LPDWORD)lparam;
		if (wparam && (!prgdwdlgCoord || !(*prgdwdlgCoord)))
			break;
		AssertSz(wparam <= MAX_TAB_STOPS, "Tab stop count beyond maximum allowed");
		if (wparam > MAX_TAB_STOPS)
			wparam = MAX_TAB_STOPS;

		PARAFORMAT2 pf;
		ZeroMemory(&pf, sizeof(PARAFORMAT2));
		pf.cbSize = sizeof(PARAFORMAT2);		

		// contains the average width for the default font
		LONG lAvgWidth;

		//Average char width based on default font
		HDC hdc = _phost->TxGetDC();
		GetECDefaultHeightAndWidth(this, hdc, 1, 1,
			W32->GetYPerInchScreenDC(), &lAvgWidth, NULL, NULL);
		_phost->TxReleaseDC(hdc);

		Assert(lAvgWidth);

		// According to documentation wparam == 1 means the tab settings
		// will be set at incremental positions *prgdwdlgCoord and wparam == 0
		// the tab settings will be set at the default incremental position 32 (dialog coord)
		long lTab = (wparam) ? *prgdwdlgCoord : 32;
		long nCt = (wparam <= 1) ? MAX_TAB_STOPS : (signed)wparam;		
		for (int i = 0; i < nCt; i++)
		{
			long lval;
			lval = (wparam <= 1) ? ((i+1) * lTab) : *prgdwdlgCoord;
			pf.rgxTabs[i] = MulDiv(MulDiv(lval, lAvgWidth, 4), 1440, W32->GetXPerInchScreenDC());
			if((unsigned)pf.rgxTabs[i] > 0xFFFFFF)			// Keep in range
				pf.rgxTabs[i] = 0xFFFFFF;
			prgdwdlgCoord++;			
		}

		// Set the default paragraph formatting
		pf.cTabCount = nCt;
		pf.dwMask = PFM_TABSTOPS;
		CParaFormat PF;
		PF.Set(&pf);
		
		// Need to turn off group typing just like the selection would.
		if (publdr)
			publdr->StopGroupTyping();

		lres = OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_TABSTOPS, PFM2_PARAFORMAT);
		GetTabsCache()->Release(PF._iTabs);
		break;
	}		

	case EM_SETCHARFORMAT:
	{
		CHARFORMAT2 *pCF2	  = (CHARFORMAT2 *)lparam;
		UINT		 CodePage = 1200;
		DWORD		 dwMask	  = pCF2->dwMask;
		DWORD		 dwMask2  = 0;

		if(!IsValidCharFormatW(pCF2))
		{
			if(!IsValidCharFormatA((CHARFORMAT2A *)lparam))
				break;
			if(dwMask & CFM_FACE)			// Need to convert to Unicode
				CodePage = GetDefaultCodePage(EM_SETCHARFORMAT);
		}

		if(dwMask & CFM_CHARSET && CharRepFromCharSet(pCF2->bCharSet) < 0)
			dwMask &= ~CFM_CHARSET;

		if(wparam & (SCF_ASSOCIATEFONT | SCF_ASSOCIATEFONT2))
		{
			lres = OnSetAssociateFont(pCF2, (DWORD)wparam);
			break;
		}

		if(Get10Mode() && (dwMask & CFM_SIZE) && (pCF2->yHeight <= 0))
		{
			// 1.0 has a hack where if the height is being set and it is
			// negative, then the height field is ignored.
			dwMask &= ~CFM_SIZE;
		}

		if (pCF2->cbSize == sizeof(CHARFORMATW) ||
			pCF2->cbSize == sizeof(CHARFORMATA))
		{
			// Restrict specifications to CHARFORMAT parameters. If the
			// host isn't our Windows host, we allow this to include the
			// CHARFORMAT2 disabled effect, since Forms^3 wanted that effect
			// but wasn't willing to use CHARFORMAT2 (even tho they asked
			// for it...)
			dwMask &= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
			dwMask2 = CFM2_CHARFORMAT;		// Tell callees that CHARFORMAT
		}									//  was used

		CCharFormat CF;						// Transfer external CHARFORMAT(2)
		CF.Set(pCF2, CodePage);				//  parms to internal CCharFormat
		lres = OnSetCharFormat(wparam, &CF, publdr, dwMask, dwMask2);
		break;
	} 
	case WM_SETFONT:
		lres = OnSetFont((HFONT)wparam);
		break;

	case EM_SETPAGE:
		if(_pdp)
			hr = _pdp->SetPage(wparam);
		break;

	case EM_SETPARAFORMAT:
	{
		PARAFORMAT2 *pPF2 = (PARAFORMAT2 *)lparam;

		if(!IsValidParaFormat(pPF2))
			break;

		DWORD dwMask = pPF2->dwMask;

		// Two more things to validate: (1) We don't let an applications set
		// up tables and (2) Tabs coming from applications must be valid.
		if(dwMask & (PFM_TABLE | PFM_TABLEROWDELIMITER |
					 PFM_OUTLINELEVEL | PFM_COLLAPSED))
		{
			// Trying to set up a table or outline view
			break;
		}

		if ((dwMask & PFM_TABSTOPS) && (pPF2->cTabCount != 0))
		{
			// Make sure all submitted tabstops make sense.
			int iMax = min(MAX_TAB_STOPS, pPF2->cTabCount);

			for (int i = 0; i < iMax; i++)
			{
				// Make sure that tab stops make sense - make sure alignment
				// is valid.
				if (GetTabAlign(pPF2->rgxTabs[i]) > tomAlignBar)
				{
					// Invalid alignment.
					break;
				}
			}

			if (i != iMax)
			{
				// Found error in validation loop so we are done.
				break;
			}
		}

		DWORD dwMask2 = 0;
		if(pPF2->cbSize == sizeof(PARAFORMAT))
		{
			dwMask &= PFM_ALL;				// Restrict to PARAFORMAT parms
			dwMask2 = PFM2_PARAFORMAT;		// Tell callees that
		}									//  PARAFORMAT was used

		CParaFormat PF;						// Transfer external PARAFORMAT(2)
		PF.Set(pPF2);						//  parms to internal CParaFormat
		lres = OnSetParaFormat(wparam, &PF, publdr, dwMask, dwMask2);
		GetTabsCache()->Release(PF._iTabs);
		break;
	}

	case EM_SETZOOM:
		if ((unsigned)(wparam | lparam) < 65536 && (!(wparam | lparam) ||
			 (LONG)wparam < (lparam << 6) && lparam < (LONG)(wparam << 6)))
		{
			// Only get here if
			// 1) 0 <= wparam <= 65535 and 0 <= lparam <= 65535, and
			// 2) either wparam = lparam = 0 (which turns off zooming by this
			// message) or 1/64 < (zoom factor given by wparam/lparam) < 64.
			SetZoomNumerator(wparam);
			SetZoomDenominator(lparam);
			_pdp->UpdateView();
			lres = 1;
		}
		break;

	case EM_STREAMIN:
	case EM_STREAMOUT:
	{
		CTxtRange	rg(this, 0, -GetTextLength());
		CTxtRange *	prg = &rg;				// Default whole doc

		wparam = W32->ValidateStreamWparam(wparam);
		if(wparam & SFF_SELECTION)			// Save to current selection
		{
			prg = (CTxtRange *)GetSel();
			AssertSz(prg,
				"EM_STREAMIN/OUT: requested selection doesn't exist");
		}
		else if(msg == EM_STREAMIN)
		{
			// If we are not streaming into the selection, then we are
			// "loading" the entire file; this is not an undo-able operation,
			// so set the undo builder to NULL and get rid of the current
			// undo stacks
			publdr = NULL;
			ClearUndo(&undobldr);			

			// Clear away the file info if necessary
			if(!(wparam & SFF_KEEPDOCINFO))
				CloseFile(FALSE);            
		}	

		if(msg == EM_STREAMIN)
		{
			// If we are going to be loading an entire file, we only
			// want to check "normal' protection; we can ignore the 
			// fIsDBCS protection.  This does mean that somebody
			// can do an "insert file" and break apart a DBCS combo,
			// but we'll have to live with that.  Outlook uses 
			// RTF streaming in many different places, so the strong
			// fIsDBCS protection breaks them.
			if ((_dwEventMask & ENM_PROTECTED) &&
				prg->IsProtected(CHKPROT_EITHER) == PROTECTED_ASK &&  
				QueryUseProtection(prg, msg, wparam, lparam))
			{
				Beep();
				Assert(lres == 0);
				break;
			}

			// Freeze the display before loading
			CFreezeDisplay fd(_pdp);

			lres = _ldte.LoadFromEs(prg, wparam, (EDITSTREAM *)lparam,
									FALSE, publdr);

			if (_fOutlineView)
			{
				// Outline view must have formatting.
				_psel->Check_rpPF();
			}

			if (_fFocus)
			{
				// Update caret but delay till display is thawed and do so only
				// if we have the focus. If we do this all the time we get wierd
				// scrolling effects such as scrolling to the beginning of a
				// document when the focus is set. See bug #1649 for repro of
				// wierd effects.
				_pdp->SaveUpdateCaret(TRUE);
			}
		}
		else
			lres = _ldte.SaveToEs  (prg, wparam, (EDITSTREAM *)lparam);
		break;
	}

#ifdef WM_SYSCOLORCHANGE
	case WM_SYSCOLORCHANGE:
#ifndef NODRAFTMODE
		if (_fDraftMode)
		{
			W32->InitSysParams(TRUE);
			_pdp->InvalidateRecalc();
		}
#endif
		TxInvalidate();
		break;
#endif

	// debug stuff
#if defined(DEBUG) && !defined(NOFULLDEBUG)
	case EM_DBGPED:
		OnDumpPed();
		break;
#endif					// DEBUG

	case EM_SETEVENTMASK:
		lres = _dwEventMask;				// Set up to return value before
		_dwEventMask = (DWORD)lparam;		//  the change

		if (lparam & ENM_REQUESTRESIZE)
		{
			// We need to update the display just in case it changes.
			_pdp->UpdateView();
		}
		break;

	case EM_GETEVENTMASK:
		lres = _dwEventMask;
		break;

#ifdef EM_GETTHUMB
	case EM_GETTHUMB:
		LONG Pos;
		BOOL fIsEnabled;

		if (TxGetVScroll(NULL, NULL, &Pos, NULL, &fIsEnabled) == S_OK
			&& fIsEnabled)
		{
			lres = Pos;	
		}
		break;
#endif

	case EM_SETLANGOPTIONS:
		_fAutoFont			 = (lparam & IMF_AUTOFONT) != 0;
		_fAutoKeyboard		 = (lparam & IMF_AUTOKEYBOARD) != 0;
		_fAutoFontSizeAdjust = (lparam & IMF_AUTOFONTSIZEADJUST) != 0;
		_fDualFont			 = (lparam & IMF_DUALFONT) != 0;
		_fUIFont			 = (lparam & IMF_UIFONTS) != 0;
		lres = 1;
		break;

	case EM_GETLANGOPTIONS:
		if(_fAutoFont)
			lres |= IMF_AUTOFONT;
		if(_fAutoKeyboard)
			lres |= IMF_AUTOKEYBOARD;
		if(_fAutoFontSizeAdjust)
			lres |= IMF_AUTOFONTSIZEADJUST;
		if(_fDualFont)
			lres |= IMF_DUALFONT;
		if(_fUIFont)
			lres |= IMF_UIFONTS;
		break;
		
	case EM_SETEDITSTYLE:
		if (!Get10Mode())	// Not support in 1.0 mode
		{	
			BOOL fForceRepaint = FALSE;
			DWORD dwEditStyle = _dwEditStyle & ~lparam;	// Kill current flag values
			// Change following mask to give the largest SES_xxx defined)
			dwEditStyle |= wparam & lparam & (SES_CTFALLOWPROOFING*2 - 1);	// Or in new values

			// Certain bits aren't switchable
			dwEditStyle |= (_fSystemEditMode ? SES_EMULATESYSEDIT : 0);
			_dwEditStyle = dwEditStyle;
			
			// There are certain things which we won't allow user to reset, ie SES_EMULATESYSEDIT.
			// So reset everything and except for the SES_EMULATESYSEDIT
			if(dwEditStyle & SES_EMULATESYSEDIT)
			{
				if(SUCCEEDED(HandleSetTextMode(TM_SINGLELEVELUNDO | TM_PLAINTEXT)))
				{
					// SES_EMULATESYSEDIT implies SES_BEEPONMAXTEXT
					_fSystemEditBeep = TRUE;
				}
				else
					_fSystemEditMode = FALSE;
			}

#ifndef NODRAFTMODE
			// Repaint and recalc if draft mode is turned on or off
			if (lparam & SES_DRAFTMODE)
				fForceRepaint = TRUE;
#endif

			if (fForceRepaint || (lparam & SES_USEATFONT))
			{
				_pdp->InvalidateRecalc();
				TxInvalidate();
			}

			if(dwEditStyle & SES_BIDI)
                OrCharFlags(FRTL, publdr);
			
			_fLowerCase = !_fUpperCase && (dwEditStyle & SES_LOWERCASE);		
		}											// Fall thru to EM_GETEDITSTYLE
													//  to return _bEditStyle
	case EM_GETEDITSTYLE:
		if (!Get10Mode())			// Not support in 1.0 mode
			lres |= _dwEditStyle;	// Some EditStyles have been filled in Cmsgflt

		break;

	case EM_SETPAGEROTATE:		
		lres = HandleSetTextFlow(wparam);
		break;

	case EM_GETPAGEROTATE:
		lres = _pdp->GetTflow();
		break;

	case EM_SETTEXTMODE:
		// 1.0 mode does not supported EM_SETTEXTMODE
		if (!Get10Mode())
			lres = HandleSetTextMode(wparam);
		break;

	case EM_GETTEXTMODE:
		lres = IsRich() ? TM_RICHTEXT : TM_PLAINTEXT;

		lres |= (_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
			 ? TM_SINGLELEVELUNDO : TM_MULTILEVELUNDO;

		lres |= _fSingleCodePage ? TM_SINGLECODEPAGE : TM_MULTICODEPAGE;
		break;

	case EM_LIMITTEXT:
		lparam = wparam;
		// Intentionally fall through. These messages are duplicates. But
		// Win9x manages to convert wparam = 0x3FFFFFFF to 0xFFFFFFFF. No
		// such problem exists with EM_EXLIMITTEXT.

	case EM_EXLIMITTEXT:					// Has cp input parameter (sort of)
		if(!lparam)							// We ignore translation between
		{									//  acp and cp
			// 0 means set the control to the maximum size. However, because
			// 1.0 set this to 64K will keep this the same value so as not to
			// surprise anyone. Apps are free to set the value to be above 64K.
			lparam = (LPARAM)cResetTextMax;
		}
		if (Get10Mode())
		{
		    // 1.0 used a signed variable to hold the length of the string.  So
		    // if lparam is negative then just set lparam to zero to emulate
		    // 1.0 behavior
		    if ((LONG)lparam < 0)
		        lparam = 0;
		}
		_cchTextMost = (LONG)lparam;
		break;

	case EM_AUTOURLDETECT:
		if(lparam || (wparam | 1) != 1)
		{
			hr = lres = E_INVALIDARG;
			break;
		}
		if(wparam == TRUE && !_pdetecturl)
		{
			_pdetecturl = new CDetectURL(this);
			if(!_pdetecturl)
				hr = lres = E_OUTOFMEMORY;
		}
		else if(!wparam && _pdetecturl)
		{
			delete _pdetecturl;
			_pdetecturl = NULL;
		}
		break;

	case EM_GETAUTOURLDETECT:
		Assert(lres == 0 && hr == NOERROR);
		if(_pdetecturl)
			lres = TRUE;
		break;

	case WM_SIZE:
		// We reset the "number of tries to put an active object 
		// in place" count here
		_cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
		hr = S_FALSE;
		break;

	case WM_SETTINGCHANGE:
		// System parameters have changed.  We need to update them.
		// Note : Since we don't protect access to system parameters 
		// with locks, it may be possible for some instances to not
		// see the changes immediately
		lres = 0;
		W32->InitSysParams(TRUE);

#ifndef NODRAFTMODE
		if (_fDraftMode)
		{
			_pdp->InvalidateRecalc();
			TxInvalidate();
		}
#endif

#ifndef NOCOMPLEXSCRIPTS
		if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
                OrCharFlags(FRTL, publdr);
#endif

		break;

	case EM_CONVPOSITION:
		if (wparam)
			lres = GetCpFromAcp(lparam);
		else
			lres = GetAcpFromCp(lparam);
		break;

#ifndef NOPRIVATEMESSAGE
	case EM_INSERTOBJ:
		{
			// This message supports Cicero InsertEmbedded
			int	cpMin = ((CHARRANGE *)wparam)->cpMin;
			int cpMost = ((CHARRANGE *)wparam)->cpMost;
			CTxtRange	rg(this, cpMin, cpMin - cpMost);
			REPASTESPECIAL rps;		// @parm Special paste info
			rps.dwAspect = DVASPECT_CONTENT;

			hr = S_FALSE;
			if (!rg.WriteAccessDenied())
				hr = _ldte.CreateOleObjFromDataObj((IDataObject *)lparam, &rg, &rps, iEmbObj, publdr);
		}
		break;;

	case EM_SETCALLBACK:		// Setup message filter callback
		_pMsgCallBack = (CMsgCallBack *)lparam;
		break;

	case EM_SETUPNOTIFY:
		if (!_pMsgNotify)
			_pMsgNotify = new CTextNotify(this);

		if (_pMsgNotify)
		{
			if (wparam == 0)
				_pMsgNotify->Remove((ITxNotify *)lparam);
			else
				_pMsgNotify->Add((ITxNotify *)lparam);
		}

		break;

	case EM_GETDOCFLAGS:
		lres = 0;
		if (_fReadOnly)
			lres |= GDF_READONLY;

		if (_fOverstrike)
			lres |= GDF_OVERTYPE;

		if (_fSingleCodePage)
			lres |= GDF_SINGLECPG;

		if (_fRich)
			lres |= GDF_RICHTEXT;

		lres &= wparam;

		break;

	case EM_GETPARATXTFLOW:
		{
		CTxtPara *pTxtPara = (CTxtPara *)lparam;
		lres = pTxtPara->_PF.IsRtlPara();
		break;
		}

#endif

#ifndef NOACCESSIBILITY
	case WM_GETOBJECT:
		{
			IUnknown* punk = NULL;
			
			lres = 0;

			if (lparam == OBJID_NATIVEOM)
			{
				QueryInterface(IID_IUnknown, (void**)&punk);	// Need to expose Tom interdface
			}
			else if (lparam == OBJID_CLIENT && _fInOurHost)
			{
				HWND hwnd = NULL;

				TxGetWindow( &hwnd );
			
				if (hwnd)
					W32->CreateStdAccessibleProxyW(hwnd, L"RichEdit", OBJID_CLIENT, IID_IAccessible, (void**)&punk);
			}
			
			if (punk)
			{
				lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
				punk->Release();
			}
			break;
		}
#endif

	default:
def:	hr = S_FALSE;
		break;
	}

	if(plresult)
		*plresult = lres;

#ifndef NOFEPROCESSING
	if (hr == S_FALSE && _pMsgFilter && _pMsgCallBack)
	{
		HWND hWnd;

		TxGetWindow(&hWnd);
		hr = _pMsgCallBack->HandlePostMessage(hWnd, msg, wparam, lparam, plresult);
	}
#endif
	return hr;
}

/* 
 *	CTxtEdit::TxDraw (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *					  hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate,
 *					  pfnContinue, dwContinue)
 *
 *	@mfunc	Draws the text services object
 *
 *	@rdesc	HRESULT (typically S_OK).
 *
 *	@comm
 *
 *	This method renders the Text Services. It accepts the same parameters
 *	as the corresponding IViewObject::Draw method in OLE, with the extra 
 *	<p lprcUpdate > parameter. It can be used while the host is inactive
 *	or active (in-place).
 *
 *	If dwDrawAspect is DVASPECT_CONTENT, this method should render a screen
 *	image of the text content to the hdcDraw device context. The hicTargetDev
 *	and ptd parameters give information on the target device context if any
 *	(usually a printer). 
 *
 * 	The lprcClient parameter gives the rectangle to render to, also called 
 *	"client rectangle". This rectangle represents the position and extents
 *	of the entire image of the Text Services to be drawn. It is expressed in
 *	the logical coordinate system of hdcDraw. This parameter can only be NULL 
 *	if the control is active. In that case, Text Services should render the 
 *	in-place active view (which client rectangle can be obtained by calling 
 *	TxGetClientRect on the host).
 *
 *	The lprcUpdate parameter, if not NULL, gives the rectangle to update 
 *	inside that client rectangle. It is given in the logical coordinate system 
 *	of hdcDraw. If NULL, the entire client rectangle should be painted.
 *
 *	Text Services should render with the appropriate zooming factor, which
 *	can be obtained from the client rect and the native size given by 
 *	ITextHost::TxGetExtent. For more information, see ITextHost::TxGetExtent.
 *
 *	If the drawing aspect is DVASPECT_DOCPRINT, the TxDraw method can assume
 *	that it is rendering to the printer. In that case, hdcDraw is the printer
 *	device context. TxDraw should still render the lprcBounds rectangle, 
 * 	starting at the current scrolling position. TS can make optimization for 
 *	rendering to the printer (like not painting the background color if white)
 * 	and certain screen specific elements (such as the selection) should not be 
 *	rendered.
 *
 *	General comments on OLE hosts and TxDraw (and TxSetCursor, TxQueryHitPoint):
 *
 *	OLE hosts can call the TxDraw method at any time with any rendering DC or 
 *	client rectangle. All an inactive OLE object has on a permanent basis is 
 *	a himetric extent. It gets the rectangle in which to render only via the 
 *	IViewObject::Draw call and this rectangle is valid only for the scope of 
 *	that method. In fact, the same control can be rendered consecutively in 
 *	different rectangles and different DCs for example because it is displayed 
 *	simultaneously in different views on the screen.
 *
 *	The client rectangle and DC passed to TxDraw should normally not be cached.
 *	However, this would force Text Services to recalc lines for every single 
 *	draw, which would lead to terrible performance. So it is likely that Text 
 *	Services will actually cache some information computed for a specific 
 *	client rectangle and DC (such as the line breaks for example). On the 
 *	next call to TxDraw, however, the validity of the cached information 
 *	should be checked before it gets used, and updated information should be 
 *	regenerated if necessary.
 *
 *	When the control is in-place active, the problem is even more complex
 *	since TxDraw can still be called to render other views than the in-place 
 *	active one. In other words, the client rectangle passed to TxDraw may 
 *	not be the same as the active view one (passed to OnTxInPlaceActivate 
 *	and obtained via TxGetClientRect on the host).The the host specifies
 *	what view they wish to display based on the lViewId parameter. If the
 *	value for lViewId is TXTVIEW_ACTIVE, the view referred to is the inplace
 *	active view. TXTVIEW_INACTIVE means some other view such as a print 
 *	preview or even printing itself. It is important to note that 
 *	TXTVIEW_INACTIVE views may not have scroll bars.
 *	
 *	The same comments apply to TxSetCursor and TxQueryHitPoint, discussed
 *	in the following sections.
 */
HRESULT CTxtEdit::TxDraw(	
	DWORD	 dwDrawAspect,	//@parm Draw aspect
	LONG	 lindex,		//@parm Currently unused
	void *	 pvAspect,		//@parm Info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,	//@parm Info on target device								
	HDC		 hdcDraw,		//@parm	Rendering device context
	HDC		 hicTargetDev,	//@parm	Target information context
	LPCRECTL lprcBounds,	//@parm	Bounding (client) rectangle
	LPCRECTL lprcWBounds,	//@parm Clipping rect for metafiles
	LPRECT	 lprcUpdate,	//@parm	Dirty rectangle inside lprcBounds
	BOOL (CALLBACK * pfnContinue) (DWORD), //@parm Callback for interupting
							//		long display (currently unused)
	DWORD	 dwContinue,	//@parm	Parameter to pass to pfnContinue function
	LONG	 lViewId)		//@parm View identifier
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxDraw");

	HRESULT hr;

	// JMO : FUTURE : We should do something about reentrant draws sometime.
	// If we do that may procide a simpler fix for RAID bug 7212.

#if !defined(NOMAGELLAN)
	CMagellanBMPStateWrap bmpOff(*this, hdcDraw);
#endif

	CCallMgr callmgr(this);

	START_PROFILING

	{
		CLock lock;
		if (g_OLSBusy)
			return E_UNEXPECTED;
	}

	// If the display is frozen, don't let ourselves draw.  This is a pretty
	// hoaky re-entrancy check.
	// FUTURE (alexgo/ricksa): be better about this.
	if(TXTVIEW_ACTIVE == lViewId && _pdp->IsFrozen())
	{
		_pdp->SetNeedRedisplayOnThaw(TRUE);
		TRACEINFOSZ("Forcing a redisplay on thaw");
		return E_UNEXPECTED;
	}

	if(dwDrawAspect != DVASPECT_CONTENT && dwDrawAspect != DVASPECT_DOCPRINT)
	{
		// We don't support the aspect requested
		return DV_E_DVASPECT;
	}

	if(!lprcBounds && !_fInPlaceActive || hicTargetDev && !ptd)
	{
		// If we are not inplace active we must have a client rectangle
		return E_INVALIDARG;
	}

	HDC hicLocal = NULL;

	// Did they give us a ptd without a hic?
	if(!hicTargetDev && ptd)
	{
		// Create and information context for the device information
		// since it wasn't supplied.
		hicLocal = CreateIC(
			(TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
			(TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
			(TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
			(DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));
		if(!hicLocal)
			return E_FAIL;					   // Couldn't create it
	
		hicTargetDev = hicLocal;			
	}

	AssertSz(GetMapMode(hdcDraw) == MM_TEXT || GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE,
	 "RichEdit requires MM_TEXT.");	// REVIEW (keithcu) Clients do (and should) use MM_TEXT

	// Preallocate the memory so the set cannnot fail and we don't
	// have to use the heap. Note that all clean up is handled
	// outside of this object. Also note that we don't assign any
	// information here because we may not use this structure. If
	// recursion is happening we will use the top level structure.
	CDrawInfo di(this);

	_pdp->SetDrawInfo(
		&di, 
		dwDrawAspect,
		lindex,
		pvAspect,
		ptd,
		hicTargetDev);

	// We use our main display object if we are the active view (which is 
	// indicate by the supplied client rectangle) or if the object is 
	// inactive and the ptd is NULL. We assume that the ptd being NULL means
	// that the display request is for the screen and not for a print or
	// print preview.
	if(TXTVIEW_ACTIVE == lViewId || !ptd)
	{
		hr = S_FALSE;

		// The main display object draws active views and tries to draw
		// inactive views if the control is not active.
		if (!lprcWBounds && 
			( fInplaceActive() && TXTVIEW_ACTIVE   == lViewId ||
			 !fInplaceActive() && TXTVIEW_INACTIVE == lViewId))
		{
			hr = _pdp->Draw(hdcDraw, hicTargetDev,	// We aren't interruptable
				(RECT *)lprcBounds,					//  drawing to screen, so
				(RECT *)lprcWBounds,				//  why pretend?
				lprcUpdate,	NULL, 0);				
		}

		if(S_FALSE == hr)
		{
			// This is an inactive view for which the cached state
			// does not match the input request so we make a special
			// object to do the drawing.
			CDisplay *pdp = _pdp->Clone();
			if(pdp)
			{
				// Force recalc - this tells Draw to draw no matter what 
				pdp->InvalidateRecalc();
				hr = pdp->Draw(hdcDraw, hicTargetDev, // Do the draw
					(RECT *)lprcBounds,
					(RECT *)lprcWBounds,
					lprcUpdate, NULL, 0);	
			}
			delete pdp;
		}
	}
	else
	{
		// Make a copy so that we can update it
		RECT rcForPrint = *((RECT *)lprcBounds);

		// We want data both formatted and printed
		hr = FormatAndPrint(hdcDraw, hicTargetDev, ptd, &rcForPrint,
				(RECT*)lprcWBounds);

		struct SPrintControl prtcon;

		// This call to OnFormatRange simply cleans up printer object
		OnFormatRange(NULL, prtcon);
	}

	_pdp->ReleaseDrawInfo();

	if(hicLocal)						// Clean up information context
		DeleteDC(hicLocal);				//  if we created one
	
	// An active OLE object might have been dragged/scrolled away 
	// from where it belongs. We need to put it back.
	// The _cActiveObjPosTries guards us from an indefinite looop here
	// (OnReposition may post another paint message, and so on)
	// We only do this when we were notified of a position or size change
	COleObject* poleobjActive;
	if (HasObjects() && _cActiveObjPosTries &&
		(poleobjActive = GetObjectMgr()->GetInPlaceActiveObject()))
	{
		// Reduce number of tries
		_cActiveObjPosTries--; 

		// BUG FIX 6073
		// Only fetch the extent if the object view size or position
		// has changed
		// Get new object size (we might have resized it, 
		// and we don't want to lose that!!)
		if (poleobjActive->GetViewChanged())
		{
		    poleobjActive->FetchObjectExtents();
		    poleobjActive->ResetViewChanged();
		}

		// and put it there!!
		poleobjActive->OnReposition();
	}

	return hr;
}

/* 
 *	CTxtEdit::TxGetHScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *	@mfunc
 *		Get horizontal scroll bar state information
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetHScroll(
	LONG *plMin, 		//@parm Minimum scroll position	
	LONG *plMax, 		//@parm	Maximum scroll position
	LONG *plPos, 		//@parm	Current scroll position
	LONG *plPage,		//@parm	View width in pixels
	BOOL *pfEnabled)	//@parm	Whether horizonatl scrolling is enabled.
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetHScroll");

	START_PROFILING

	if(plMin) 
		*plMin = 0;

	if (IsUVerticalTflow(_pdp->GetTflow()))
	{
		if(plMax) 
			*plMax = _pdp->GetScrollRange(SB_VERT);

		if(plPage) 
			*plPage = _pdp->ConvertVPosToScrollPos(_pdp->GetDvpView());

		if(plPos) 
		{
			*plPos = _pdp->ConvertVPosToScrollPos(_pdp->GetVpScroll());
			if (_pdp->GetTflow() == tflowSW)
				*plPos = *plMax - *plPos - *plPage;
			*plPos = max(*plPos, 0);
		}

		if(pfEnabled) 
			*pfEnabled = _pdp->IsVScrollEnabled();
	}
	else
	{
		if(plMax) 
			*plMax = _pdp->GetScrollRange(SB_HORZ);

		if(plPos) 
			*plPos = _pdp->GetUpScroll();

		if(plPage) 
			*plPage = _pdp->GetDupView();

		// CDisplay::_fUScrollEnabled may be TRUE when not in-place active
		// because it has a dual meaning: 1) need Horiz scroll bars, and 2)
		// CDisplay::_upScroll is allowed for ES_AUTOHSCROLL even with no
		// horizontal scrollbar.  The latter can turn on _fUScrollEnabled when
		// the control is active and when the control goes inactive, it stays
		// on, so we say it's off to keep Forms^3 from displaying a horizontal
		// scroll bar. We probably should have two flags: _fUScrollEnabled and
		// _fUScrollbarEnabled, but for now, we stick with one.  No such problem
		// for vertical case, since vertical scrolling always uses a scrollbar.  
		if(pfEnabled) 
			*pfEnabled = _fInPlaceActive ? _pdp->IsUScrollEnabled() : 0;
	}
			 
	return S_OK;
}

/* 
 *	CTxtEdit::TxGetVScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *	@mfunc
 *		Get vertical scroll bar state information
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetVScroll(
	LONG *plMin, 		//@parm	Minimum scroll position
	LONG *plMax, 		//@parm	Maximum scroll position
	LONG *plPos, 		//@parm	Current scroll position
	LONG *plPage, 		//@parm Height of view in pixels
	BOOL *pfEnabled)	//@parm	Whether vertical scroll bar is enabled.
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetVScroll");

	if(plMin) 
		*plMin = 0;

	if (IsUVerticalTflow(_pdp->GetTflow()))
	{
		if(plMax) 
			*plMax = _pdp->GetScrollRange(SB_HORZ);

		if(plPos) 
			*plPos = _pdp->GetUpScroll();

		if(plPage) 
			*plPage = _pdp->GetDupView();

		if(pfEnabled) 
			*pfEnabled = _fInPlaceActive ? _pdp->IsUScrollEnabled() : 0;
	}
	else
	{
		if(plMax) 
			*plMax = _pdp->GetScrollRange(SB_VERT);

		if(plPos) 
			*plPos = _pdp->ConvertVPosToScrollPos(_pdp->GetVpScroll());

		if(plPage) 
			*plPage = _pdp->ConvertVPosToScrollPos(_pdp->GetDvpView());

		if(pfEnabled) 
			*pfEnabled = _pdp->IsVScrollEnabled();
	}
			 
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxSetCursor (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *							 hicTargetDev, lprcClient, x, y)
 *	@mfunc
 *		Notification for text services to set the cursor
 *
 *	@rdesc
 *		HRESULT = FAILED(RectChangeHelper()) ? E_INVALIDARG : S_OK
 *
 *	@comm
 *		Text Services may remeasure as a result of this call in
 *		order to determine the correct cursor.  The correct 
 *		cursor will be set via ITextHost::TxSetCursor 
 *
 *		More details:
 * 
 *		The lprcClient parameter is the client rectangle of the view of the 
 *		control over which the mouse cursor is. It is in device coordinates 
 *		of the containing window in the same way the WM_SIZE message is. This 
 *		may not be the view that was rendered last. Furthermore, if the control 
 *		is in-place active, this may not be the view currently being active. 
 *		As a consequence, Text Services should check this rectangle against 
 *		its current caches values and determine whether recalcing the lines 
 *		is necessary or not. The zoom factor should be included in this
 *		computation.
 *
 *		This method should only be called for screen views of the control. 
 *		Therefore the DC is not passed in but should be assumed to be a screen 
 *		DC.
 *
 *		The x and y parameters hold the cursor position in the same coordinate
 *		system as lprcClient, i.e., the client coordinates of the containing 
 *		window.
 */
//REVIEW (keithcu) Do people really pass rectangles different from those
//returned from TxGetClientRect? I'd be surprised if that happens, and if it did
//who cares if we display the wrong cursor??
HRESULT CTxtEdit::OnTxSetCursor (
	DWORD 	dwDrawAspect,	//@parm Draw aspect
	LONG  	lindex,			//@parm Currently unused
	void *	pvAspect,		//@parm Info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,	//@parm Info on target device								
	HDC	  	hdcDraw,		//@parm	Rendering device context
	HDC	  	hicTargetDev,	//@parm	Target information context
	LPCRECT lprcClient, 	//@parm Control's client rectangle	
	INT	  	x, 				//@parm	x position of cursor
	INT	  	y)				//@parm	y position of cursor
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxSetCursor");

	CCallMgr callmgr(this);
	BOOL	 fText = FALSE;
	HITTEST	 Hit;	
	RECT	 rcxyClient;
	BOOL	 fGotDC = FALSE;
	START_PROFILING

	if (_fInPlaceActive)
		TxGetClientRect(&rcxyClient);
	else if (lprcClient)
		rcxyClient = *lprcClient;
	else
		return E_INVALIDARG;

	if (!_pdp->IsValid())
	{
		HDC hdc = GetDC(NULL);
		_pdp->SetDC(hdc);
		fGotDC = TRUE;
	}

	// Set the cursor
	CTxtSelection * const psel = GetSel();
	HCURSOR	hcurNew = _hcurArrow;			// Default using system arrow
	POINT	ptxy = {x, y};
	POINTUV	pt;
	RECTUV	rcClient;
	BOOL	fInLink = FALSE;

	_pdp->RectuvFromRect(rcClient, rcxyClient);
	_pdp->PointuvFromPoint(pt, ptxy);

	if(PtInRect(&rcxyClient, ptxy))
	{
		// Find out what the cursor is pointing at
		_pdp->CpFromPoint(pt, &rcClient, NULL, NULL, FALSE, &Hit); 

		if(Hit == HT_LeftOfText)
			hcurNew = _hcurSelBar;

		// This is a bit strange, but RichEdit 1.0 does this--give client a
		// chance to handle cursor itself if we are over a link.
		else if(Hit == HT_Link)
		{
			if(HandleLinkNotification(WM_SETCURSOR, 0, MAKELPARAM(ptxy.x, ptxy.y), &fInLink))
			{
				return NOERROR;
			}
			hcurNew = _hcurHand;
		}
		else if(Hit != HT_Nothing && Hit != HT_OutlineSymbol && Hit != HT_BulletArea)
		{
			if(!psel || !psel->PointInSel(pt, &rcClient, Hit) || _fDisableDrag)
			{
				if (IsUVerticalTflow(_pdp->GetTflow()))
					hcurNew = (Hit == HT_Italic) ? _hcurVItalic : _hcurVIBeam;
				else
					hcurNew = (Hit == HT_Italic) ? _hcurItalic : _hcurIBeam;
				fText = TRUE;
			}

			// If we have an object manager and if there is a selected object,
			// check for hits on the frame handles.
			if(_pobjmgr)
			{
				COleObject *pobjselect = _pobjmgr->GetSingleSelect();
				if(pobjselect)
				{
					// Handle hits on frame handles.
					LPTSTR	idcur	= pobjselect->CheckForHandleHit(pt);
					HCURSOR hcurObj = W32->GetSizeCursor(idcur);
					if(hcurObj)
						hcurNew = hcurObj;
				}
			}
		}
	}
	_phost->TxSetCursor(hcurNew, fText);	// Tell host to set cursor

	if (fGotDC)
	{
		HDC hdc = _pdp->GetDC();
		::ReleaseDC(NULL, hdc);
		_pdp->SetDC(NULL);
	}

	return S_OK;
}

/* 
 *	CTxtEdit::TxQueryHitPoint (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *								hicTargetDev, lprcClient, x, y, pHitResult)
 *	@mfunc
 *		Returns whether point is within text services rectangle
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm	
 *		This method allows the host to implement transparent hit-testing
 *		on text. 
 *
 *		The lprcClient parameter is the client rectangle in device coordinates
 *		of the view on which hit testing is performed. 
 *
 *		The pt parameter hold the position of the cursor in the same 
 *		coordinate system as the lprcClient rectangle (the client
 *		coordinates of the containing window).
 *
 *		Same general comments about client rectangle and DC as for 
 *		TxSetCursor apply.
 *
 *		pHitResult returns one of the following values: <nl>
 *
 *		TXTHITRESULT_NOHIT		 Hit was outside client rectangle. <nl>
 *		TXTHITRESULT_HIT		 Point was inside client rectangle and over
 *								 either text or an opaque background.
 *		TXTHITRESULT_TRANSPARENT Point was inside client rectangle with a
 *								 transparent background and not over text.
 *		TXTHITRESULT_CLOSE		 Hit was close to an opaque area.
 *
 *		Refer to the Windowless OLE Control spec for more details on
 *		these return values and how they should be determined.
 */
HRESULT CTxtEdit::TxQueryHitPoint(
	DWORD 	dwDrawAspect,	//@parm Draw aspect
	LONG  	lindex,			//@parm Currently unused
	void *	pvAspect,		//@parm Info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,	//@parm Info on target device								
	HDC	  	hdcDraw,		//@parm	Rendering device context
	HDC	  	hicTargetDev,	//@parm	Target information context
	LPCRECT lprcClient, 	//@parm Control's client rectangle	
	INT	  	x, 				//@parm	x coordinate to check
	INT	  	y,				//@parm	y coordinate to check
	DWORD *	pHitResult)		//@parm	Result of hit test see TXTHITRESULT 
							//		enumeration for valid values
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxQueryHitPoint");

	RECTUV	 rcClient;
	RECT	 rcxyClient;
	CCallMgr callmgr(this);

  	START_PROFILING

	if (_fInPlaceActive)
		TxGetClientRect(&rcxyClient);
	else if (lprcClient)
		rcxyClient = *lprcClient;
	else
		return E_INVALIDARG;

	HRESULT hr;
	POINT	ptxy = {x, y};
	POINTUV pt;

	_pdp->PointuvFromPoint(pt, ptxy);
	_pdp->RectuvFromRect(rcClient, rcxyClient);

	if(!_fTransparent)
	{	
		*pHitResult = TXTHITRESULT_HIT;
		hr = S_OK;
	}
	else
		hr = _pdp->TransparentHitTest(hdcDraw, &rcxyClient, pt, pHitResult);

	return hr;
}

/* 
 *	CTxtEdit::OnTxInPlaceActivate (prcClient)
 *
 *	@mfunc
 *		Notifies text services that this control is inplace active
 *
 *	@rdesc	
 *		S_OK - successfully activated object <nl>
 *		E_FAIL - could not activate object due to error. <nl>
 *
 *	@comm
 *		When transitioning directly from a non-active state to the UI-active
 *		state, the host should call OnTxInPlaceActivate first and then 
 *		OnTxUIActivate. Similarly, when transitioning from the UI-active 
 *		state to a non active state, the host should call OnTxUIDeactivate
 *		first and then OnTxInPlaceDeactivate.
 *
 *		OnTxInPlaceActivate takes the client rectangle of the view being 
 *		activated as a parameter. This rectangle is given in client coordinate
 *		of the containing window. It is the same as would be obtained by 
 *		calling TxGetClientRect on the host.
 *
 *		UI-activation is different from getting the focus. To let Text 
 *		Services know that the control is getting or losing focus, the 
 *		host will send WM_SETFOCUS and WM_KILLFOCUS messages. Note that a 
 *		windowless host will pass NULL as the wParam (window that lost the 
 *		focus) for these messages.
 *
 *		As a reminder, inplace activation typically refers to an embedded
 *		object "running inplace" (for regular controls && embeddings, it
 *		would have a window to draw in, for example).  UI active means that
 *		an object currently has the 'editing focus'.  Specifically, things
 *		like menus and toolbars on the container may also contain elements
 *		from the UI active control/embedding.  There can only be one
 *		UI active control at any given time, while many can be inplace active
 *		at once.
 */
HRESULT CTxtEdit::OnTxInPlaceActivate(
	const RECT *prcClient)	//@parm Control's client rectangle
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceActivate");

	RECTUV rcView;
	HDC hdc;
	BOOL fSucceeded = TRUE;
	CCallMgr callmgr(this);
	RECTUV rcClient;

	START_PROFILING

	// Needs to set here for further TxGetDC() to work
	_fInPlaceActive = TRUE;

	// Set rendering DC to be the screen
	hdc = TxGetDC();
	if(!hdc)
		goto err;

	// Tell display that it is active
	_pdp->SetActiveFlag(TRUE);
	_pdp->SetDC(hdc);

//REVIEW (keithcu) I removed prcClient usage here because it appears that
//clients pass in wrong rectangles to OnTxInPlaceActivate. That is quite
//scary--do they pass in wrong rectangles to other places? (We could see
//weird results when not in-place active. If (as the comment says) the prcClient
//should be the same as what would be gotten from the host, we will now just fetch
//the value from the host rather than look at what is passed down.
#if 1
	prcClient = 0;
#else

	if (prcClient)
		_pdp->RectuvFromRect(rcClient, *prcClient);

	//Verify the rectangle passed in is the same as what we'd fetch from
	//getting it from the client
	#ifdef DEBUG
	{
		RECT rcDebug;
		TxGetClientRect(&rcDebug);
		AssertSz(rcDebug.right - rcDebug.left == prcClient->right - prcClient->left &&
			     rcDebug.bottom - rcDebug.top == prcClient->bottom - prcClient->top, 
				 "CLIENT BUG: Inconsistent rectangles between ITextServices::"
				 "OnTxInPlaceActivate(RECT*) and ITextHost::TxGetClientRect(RECT*)");
	}
	#endif
#endif

	// Compute view rect from passed in client rect
	_pdp->GetViewRect(rcView, prcClient ? &rcClient : 0);
	
	// Recalc/update view
	_pdp->RecalcView(rcView);

	// Get selection.  Otherwise, if SetFocus is called later without
	// selection, then the Selection state is not set correctly.
	GetSel();
	if(_pdp->GetDupView())
	{
		// Get selection if we can
		if(_psel)						// Set the caret
			_psel->Update(FALSE);
		else							// Couldn't create selection,
			fSucceeded = FALSE;			//  so fail activation
	}

	// Release the DC
	TxReleaseDC(hdc);
	_pdp->SetDC(NULL);

	// If getting the selection worked we are home free
	if(fSucceeded)
		return S_OK;

err:
	_fInPlaceActive = FALSE;
	return E_FAIL;
}

/* 
 *	CTxtEdit::OnTxInPlaceDeactivate()
 *
 *	@mfunc	Notifies text services that this is no longer in place active.
 *
 *	@rdesc	S_OK
 *
 *	@comm	See OnTxInPlaceActivate for a detailed description of
 *	activation/deactivation.
 *
 *	@xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxInPlaceDeactivate() 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceDeactivate");

	START_PROFILING

	// Get properties that affect whether we will discard the selection
	DWORD dwBits;

	// Tell display that it is not longer active
	_pdp->SetActiveFlag(FALSE);

	// Because we are inactive, this will tell any background recalc going
	// on to stop.
	_pdp->StepBackgroundRecalc();

	_phost->TxGetPropertyBits(TXTBIT_HIDESELECTION | TXTBIT_SAVESELECTION, 
		&dwBits);

	// If we don't want to save the selection and we want to hide it while
	// inactive, then we discard our selection
	if(!(dwBits & TXTBIT_SAVESELECTION) && (dwBits & TXTBIT_HIDESELECTION))
		DiscardSelection();

	_fInPlaceActive = FALSE;
	return S_OK;
}

/* 
 *	CTxtEdit::OnTxUIActivate()
 *
 *	@mfunc	Informs text services that the control is now UI active.
 *
 *	@rdesc	S_OK
 *
 *	@comm	See OnTxInPlaceActivate for a detailed description of
 *	activation/deactivation.
 *
 *	@xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 *
 */
HRESULT CTxtEdit::OnTxUIActivate() 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIActivate");

	return S_OK;
}

/* 
 *	CTxtEdit::OnTxUIDeactivate()
 *
 *	@mfunc	Informs text services that the control is now UI deactive.
 *
 *	@rdesc	S_OK
 *
 *	@comm	See OnTxInPlaceActivate for a detailed description of
 *	activation/deactivation.
 *
 *	@xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxUIDeactivate() 
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIDeactivate");

	return S_OK;
}

/* 
 *	CTxtEdit::TxGetText (pbstrText)
 *
 *	@mfunc	Returns all of the UNICODE plain text in the control as an 
 *			OLE BSTR.
 *
 *	@rdesc
 *		S_OK - Text successfully returned in the output argument <nl>
 *		E_INVALIDARG - invalid BSTR pointer passed in. <nl>
 *		E_OUTOFMEMORY - could not allocate memory for copy of the text <nl>
 *
 *	@comm	The caller takes ownership of the returned BSTR.  WM_GETTEXT
 *			and TOM ITextRange::GetText are alternate techniques for
 *			retrieving plain text data.
 *
 *			If there is no text in the control, no BSTR will be allocated
 *			and NULL will be returned.
 *
 *			The returned text will NOT necessarily be NULL terminated.
 */
HRESULT CTxtEdit::TxGetText(
	BSTR *pbstrText	)	//@parm	where to return an allocated BSTR
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetText");

	CTxtPtr		tp(this, 0);
	CCallMgr callmgr(this);

	START_PROFILING

	if(!pbstrText)
		return E_INVALIDARG;
	
	const LONG cch = GetTextLength();

	if(cch <= 0)
	{
		*pbstrText = 0;
		return S_OK;
	}
	*pbstrText = SysAllocStringLen(NULL, cch);
	if(!*pbstrText)
	{
		GetCallMgr()->SetOutOfMemory();
		return E_OUTOFMEMORY;
	}

	tp.GetText(cch, *pbstrText);
	return S_OK;
}

/*
 *  CTxtEdit::TxSetText (pszText)
 *
 *  @mfunc  Sets all of the text in the control
 *
 *  @rdesc
 *      S_OK - text was successfully set    <nl>
 *      E_FAIL - text could not be updated. <nl>
 *
 *  @comm
 *      This method should be used with care; it essentially re-initializes
 *      the text engine with some new data; any previous data and formatting
 *      information will be LOST, including undo information.
 *
 *      If previous data has been copied to the clipboard, that data will be
 *      rendered completely to the clipboard (via OleFlushClipboard) before
 *      it is discarded.
 *
 *      This method is NOT undo-able.
 *
 *      Two alternate approaches to setting text are WM_SETTEXT and TOM
 *      ITextRange::SetText.
 *
 *  @xref
 *      <mf CTxtRange::SetText>
 */
HRESULT CTxtEdit::TxSetText(
    LPCTSTR pszText)        //@parm String to replace the current text with
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSetText");

    START_PROFILING

    return SetText(pszText, ST_CHECKPROTECTION, 1200);
}

/* 
 *	CTxtEdit::TxGetCurTargetX (px)
 *
 *	@mfunc
 *		Get the target x position of the caret
 *
 *	@rdesc	
 *		HRESULT with possible values:
 *
 *		S_OK		 - x position of the caret returned <nl>
 *		E_FAIL		 - There is no selection <nl>
 *		E_INVALIDARG - Input argument is invalid <nl>
 *
 *	@comm
 *		This method is useful for implementing up-down cursoring
 *		through a conceptual vertical line.  To illustrate this feature,
 *		consider setting the insertion point at, say, column 20 in a
 *		text editor.  Now cursor up and down--notice that wherever possible,
 *		the editor tries to put the insertion point as close to column 20
 *		as it can for the current line.  Column 20 is thus the "target" column
 *		for the insertion point.
 *
 *		Users would like to have this same capability when cursoring through
 *		Forms; however, as other controls don't necessarily share the same
 *		notion of column position, the target caret position is expressed simply
 *		as an x-coordinate on the display (in *client* coordinates).
 */
HRESULT CTxtEdit::TxGetCurTargetX(
	LONG *px)			//@parm	the x location in client coordinates
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCurTargetX");

	START_PROFILING
	CTxtSelection *psel = GetSel();

	if(!psel)
		return E_FAIL;

	if(!px)
		return E_INVALIDARG;

	*px = psel->GetUpCaretReally();
	return S_OK;
}

/* 
 *	CTxtEdit::TxGetBaseLinePos(pBaseLinePos)
 *
 *	@mfunc	Get the base line position of the first visible line, in pixels, 
 *	relative the TS client rectangle. Needed for aligning controls on their
 *	baselines.
 *
 *	@rdesc	HRESULT = E_NOTIMPL
 */
HRESULT CTxtEdit::TxGetBaseLinePos(
	LONG *pBaseLinePos)		//@parm	Where to return baseline position
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetBaseLinePos");

	return E_NOTIMPL;
}

/* 
 *	CTxtEdit::TxGetNaturalSize (dwAspect, hdcDraw, hicTargetDev, ptd, dwMode,
 *								psizelExtent, pwidth, pheight)
 *
 *	@mfunc	Allow control to be resized so it fits content appropriately
 *
 *	@rdesc	S_OK			<nl>
 *			E_INVALIDARG	<nl>
 *			E_FAIL  Unable to determine correct size	<nl>
 *			E_OUTOFMEMORY	<nl>
 *
 *	@comm
 *
 *	The first 4 parameters are similar to equivalent parameters in
 *	TxDraw and give the same information. In the case TS needs to
 *	recalc lines, it should use these values the same ways as in
 *	TxDraw.
 *				
 *	<p pWidth> and <p pHeight> are IN/OUT parameters. The host passes the
 *	"tentative" width and height of the client rectangle for the text object 
 *	and Text Services will compare these values against its current cached 
 *	state, and if different should recalc lines. Then it will compute 
 *	and return the natural size. As spec-ed currently, the host can ask for 2
 *	different kinds of natural sizes:
 *
 *	TXTNS_FITTOCONTENT: the entire text should be formatted to the
 *	width that is passed in.Then Text Services return the height of
 * 	the entire text and the width of the widest line. Note that this
 *	option ignores any paragraph formatting such as centering and
 *	only returns the raw size for the text.
 *
 *	TXTNS_ROUNDTOLINE: returns the integral height of the number of lines that
 *	will fit in the input height rounded to the next full line boundary. 
 *					
 *	Note that passed and returned width and height correspond to
 *	the *client* rectangle in client units. 
 *
 *
 *	BACKGROUND
 *	Here is a quick description of the features mentioned above:
 *
 *	FITTOCONTEXT: Normally happens when the user double clicks one
 *	of the control grab handles. Sizes the control to the "optimal"
 *	size to fit the entire content. Should accomodate the height of
 *	the entire text and the width of the widest line.
 *
 *	ROUNDTOLINE (Integral height): if this property is set, when the 
 *	user resizes the control, it snaps to heights that allow an 
 *	integral number of lines to be displayed (no line will be clipped).
 */
HRESULT CTxtEdit::TxGetNaturalSize(
	DWORD	dwAspect,	//@parm	Aspect for drawing.  Values taken from OLE's
						//		DVASPECT enumeration
	HDC		hdcDraw,	//@parm	DC into which drawing would occur
	HDC	hicTargetDev,	//@parm DC for which text should be formatted, i.e.,
						//		for WYSIWYG
	DVTARGETDEVICE *ptd,//@parm	More info on the target device	
	DWORD	dwMode, 	//@parm	Type of fitting requested.  Either
						//		TXTNS_FITTOCONTENT or TXTNS_ROUNDTOLINE
	const SIZEL *psizelExtent,//@parm Size of extent to use for zooming
	LONG *	pwidth, 	//@parm	Width for such a fitting [in,out]
	LONG *	pheight)	//@parm Height for such a fitting [in,out]
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetNaturalSize");

	HRESULT hr;
	CCallMgr callmgr(this);

	START_PROFILING

	if(dwAspect != DVASPECT_CONTENT && dwAspect != DVASPECT_DOCPRINT)
	{
		// We don't support the aspect requested
		return DV_E_DVASPECT;
	}

	if (hicTargetDev && !ptd ||	!pwidth || !pheight ||
		!IN_RANGE(TXTNS_FITTOCONTENT2, dwMode, TXTNS_ROUNDTOLINE))
	{
		// Either and information context is provided without the device 
		// target or the mode is not valid or the width was not provided
		// or the height was not provided. In short, the input parameters
		// are not valid so tell the caller.
		return E_INVALIDARG;
	}

	if(!psizelExtent->cy)
	{
		// No extent for control, so just return 0
		*pwidth = 0;
		*pheight = 0;
		return S_OK;
	}

	HDC hicLocal = NULL;

	// Did they give us a ptd without a hic?
	if(!hicTargetDev && ptd)
	{
		// Create and information context for the device information
		// since it wasn't supplied.
		hicLocal = CreateIC(
			(TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
			(TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
			(TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
			(DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));

		if(!hicLocal)
			return E_FAIL;				// Couldn't create it

		hicTargetDev = hicLocal;			
	}

	// Convenient place to put height & width for converting them to
	// device units.
	POINT pt;
	pt.x = *pwidth;
	pt.y = *pheight;

	AssertSz(GetMapMode(hdcDraw) == MM_TEXT || GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE,
	 "RichEdit requires MM_TEXT.");	// REVIEW (keithcu) Clients do (and should) use MM_TEXT

	// Set the extent information needed for zooming
	_pdp->SetTempZoomDenominator(psizelExtent->cy);

	if(TXTNS_ROUNDTOLINE == dwMode)
	{
		// Round to fit simply calculates the 
		hr = _pdp->RoundToLine(hdcDraw, pt.x, &pt.y);
	}
	else
	{
		// Get natural size for entire presentation
		// Allocate memory for the draw information
		CDrawInfo di(this);

		// Set up the drawing parameters
		_pdp->SetDrawInfo(
			&di, 
			dwAspect,
			-1,
			NULL,
			ptd,
			hicTargetDev);

		// Set the Draw DC		 
		_pdp->SetDC(hdcDraw);

		// Tell display to figure size needed for this display
		hr = _pdp->GetNaturalSize(hdcDraw, hicTargetDev, dwMode, &pt.x,	&pt.y);

		_pdp->ResetDC();				// Restore state
		_pdp->ReleaseDrawInfo();
	}

	if(SUCCEEDED(hr))					// Set return values if this worked
	{
		*pwidth = pt.x;					// Update return values
		*pheight = pt.y;
	}

	if(hicLocal)						// Clean up info context
		DeleteDC(hicLocal);				//  if we created one
	
	_pdp->ResetTempZoomDenominator();	// Reset temporary zoom factor

	return hr;
}

/* 
 *	CTxtEdit::TxGetDropTarget (ppDropTarget)
 *
 *	@mfunc	Get the drop target for the text control
 *
 *	@rdesc	
 *		S_OK - Got drop target successfully <nl>
 *		E_OUTOFMEMORY - Could not create drop target <nl>
 *
 *	@comm
 *		The caller (host) is responsible for calling Register/Revoke
 *		DragDrop and for calling IUnknown::Release on the returned
 *		drop target when done. 
 */
HRESULT CTxtEdit::TxGetDropTarget(
	IDropTarget **ppDropTarget)	//@parm	Where to put pointer to drop target
{
#ifndef NODRAGDROP
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetDropTarget");

	HRESULT hr;
	CCallMgr callmgr(this);

	START_PROFILING

	hr = _ldte.GetDropTarget(ppDropTarget);
	if(hr == NOERROR)
		(*ppDropTarget)->AddRef();
	return hr;
#else
	return 0;
#endif
}

/* 
 *	CTxtEdit::OnTxPropertyBitsChange (dwMask, dwBits)
 *
 *	@mfunc	Set properties that can be represented by bits.
 *
 *	@rdesc	HRESULT
 *
 *	@comm	The following property bits are understood: <nl>
 *
 *		TXTBIT_RICHTEXT				<nl>		
 *		TXTBIT_MULTILINE			<nl>
 *		TXTBIT_READONLY				<nl>
 *		TXTBIT_SHOWACCELERATOR		<nl>
 *		TXTBIT_USEPASSWORD			<nl>
 *		TXTBIT_HIDESELECTION		<nl>
 *		TXTBIT_SAVESELECTION		<nl>
 *		TXTBIT_AUTOWORDSEL			<nl>
 *		TXTBIT_AUTOSIZE				<nl>
 *		TXTBIT_VERTICAL				<nl>
 *		TXTBIT_SELECTIONBAR			<nl>
 *		TXTBIT_WORDWRAP				<nl>
 *
 *		TXTBIT_CLIENTRECTCHANGE		<nl>
 *		TXTBIT_VIEWINSETCHANGE		<nl>
 * 		TXTBIT_BACKSTYLECHANGE		<nl>
 *		TXTBIT_MAXLENGTHCHANGE		<nl>
 *		TXTBIT_SCROLLBARCHANGE		<nl>
 *		TXTBIT_CHARFORMATCHANGE		<nl>
 *		TXTBIT_PARAFORMATCHANGE		<nl>
 *		TXTBIT_ALLOWBEEP			<nl>
 *		TXTBIT_EXTENTCHANGE			<nl>
 *
 *	A brief description of each property follows:
 *
 *
 *	Client rectangle (TXTBIT_CLIENTRECTCHANGE):
 *
 *	The rectangle the Text Services are responsible for painting
 *	and managing. The host will rely on the Text Services for painting 
 *	that area. Text Services must not paint or invalidate areas outside of 
 *	that rectangle.
 *
 *	The host will forward mouse messages to the Text Services whenever the 
 *	cursor is over this rectangle. 
 *
 *	This rectangle is expressed in client coordinates of the containing window.
 *
 *	IMPORTANT: this property cannot be queried from the host when it is 
 *	inactive. The TxGetClientRect method will fail if called at inactive time.
 *
 *
 *	View inset (TXTBIT_VIEWINSETCHANGE): 
 *
 *	This is the amount of space on each side between the client rectangle and 
 *	the view rectangle. The view rectangle (also called Formating rectangle) 
 *	is the rectangle the text should be formatted in. 
 *
 *	The view insets are is passed in a RECT structure but this is not really 
 *	a rectangle. It should be treated as 4 independent values to substract 
 *	on each side of the client rectangle to figure the view rectangle. 
 *
 *	The view insets are passed in himetrics so that they do not depend on 
 *	the client rectangle and the rendering DC.
 *
 *	View insets can be negative on either side of the client rectangle, 
 *	leading to a bigger view rectangle than the client rectangle. The text 
 *	should then be clipped to the client rectangle. If the view rectangle 
 *	is wider than the client rectangle, then the host may add a horizontal 
 *	scrollbar to the control. 
 *
 *	Single line Text Services ignore the right boundary of the view rectangle 
 *	when formatting text.
 *
 *	The view inset is available from the host at all times, active or 
 *	inactive.
 *
 *
 *	Backstyle (TXTBIT_BACKSTYLECHANGE):
 *
 *	The style of the background of the client rectangle. Can be either of 
 *	the following values: <nl>
 *		#define TXTBACK_TRANSPARENT		0 <nl>
 *		#define TXTBACK_SOLID			1 <nl>
 *
 *	Values for this property are similar to VB4 values for the same property.
 *
 *
 *	MaxLength (TXTBIT_MAXLENGTHCHANGE):
 *
 *	The maximum length the text can have. Text Services should reject 
 *	character insertion and  pasted text when this maximum is reached. 
 *	TxSetText however should still accept (and set) text longer than the 
 *	maximum length. This is because this method is used for binding and 
 *	it is critical to maintain the integrity of the data the control 
 *	is bound to.
 *
 *
 *	Scrollbar (TXTBIT_SCROLLBARCHANGE):
 *
 *	This property indicates which scollbar is present and whether scollbars 
 *	are hidden or disabled when scrolling is impossible. It also controls 
 *	auto-scrolling when the insertion point gets off the client rectangle.
 *
 * 	This is a DWORD where bits are layed out as in the system window style. 
 *	Possible bits are:
 *	WS_HSCROLL				// control has horizontal scrollbar <nl>
 *	WS_VSCROLL				// control has vertical scrollbar <nl>
 *	ES_AUTOVSCROLL			// auto-scroll horizontally <nl>
 *	ES_AUTOVSCROLL			// auto-scroll vertically <nl>
 *	ES_DISABLENOSCROLL		// scrollbar should be disabled when scrolling 
 *							   impossible <nl> 
 *
 *	Default CHARFORMAT (TXTBIT_CHARFORMATCHANGE):
 *
 *	The CHARFORMAT or CHARFORMAT2 used for default character-format runs,
 *	i.e., those not explicitly formatted via the selection or TOM methods.

 *
 *	Default PARAFORMAT (TXTBIT_PARAFORMATCHANGE):
 *
 *	The PARAFORMAT or PARAFORMAT2 used for default paragraph-format runs,
 *	i.e., those not explicitly formatted via the selection or TOM methods.
 *
 *
 *	TXTBIT_ALLOWBEEP:
 *
 *	TXTBIT_EXTENTCHANGE:
 *
 *
 *	TXTBIT_RICHTEXT: 
 *
 *	Whether the Text Services should be in Rich-Text mode or not.  This
 *	principally affects how editing commands are applied.  For example,
 *	applying bold to some text in a plain edit control makes all of the
 *	text bold, rather than just the selected text in a rich text control.
 *
 *	Note that if there is either undo state or the object has any text,
 *	the attempt to change this bit will be ignored.
 *
 *
 *	TXTBIT_MULTILINE:
 *
 *	If this property is FALSE, Text Services should not process the CR 
 *	key and truncate any incoming text containing hard line breaks just 
 *	before the first line break. It is OK to also truncate text set via 
 *	TxSetText (meaning, it is the responsibility of the host to not use a s
 *	single line control when bound to a multi-line field).
 *
 *	If this property is TRUE, Text Services should work in multiline mode. 
 *	The TXTBIT_WORDWRAP can be used to know whether to wrap the lines to 
 *	the view rectangle or clip them.
 *
 *
 *	TXTBIT_READONLY:
 *
 *	If this property is TRUE, Text Services should not accept any editing 
 *	change via the user interface. However, they should still accept 
 *	programmatic changes via EM_SETTEXT, EM_REPLACETEXT and TxSetText. 
 *
 *	In read only mode, the user should still be able to move the 
 *	insertion point, select text and carry out other non content modifying 
 *	operations such as Copy.
 * 
 *
 *	TXTBIT_SHOWACCELERATOR:
 *
 *	Refer to the "Accelerator" section for details about this property.
 *
 *
 *	TXTBIT_USEPASSWORD:
 *
 *	If this property is TRUE, the Text Services should show the entire 
 *	text using the character obtained by TxGetPasswordChar. 
 *
 *	The notification on this property may mean two different things:
 *	 The password character changed,
 *	 The password character was not used before and is used now 
 *	(or vice versa).
 *
 *
 *	TXTBIT_HIDESELECTION:
 *
 *	If this property is TRUE, Text Services should hide the selection 
 *	when the control is inactive. If it is FALSE, the selection, if any, 
 *	should still be displayed when the control is inactive. 
 *
 *	If TRUE, this property implies TXTBIT_SAVESELECTION = TRUE.
 *
 *
 *	TXTBIT_SAVESELECTION:
 *
 *	If this property is TRUE, Text Services should remember the 
 *	boundaries of the selection when the control goes inactive. If FALSE, 
 *	it is not necessary to remember the selection when the control goes 
 *	inactive. It can be reset to start = 0, length = 0 when the control 
 *	goes active again.
 *
 *	This property is used by hosts for which it is not necessary to 
 *	remember the selection when inactive. 
 *
 *
 *	TXTBIT_AUTOWORDSEL:
 *
 *	This property turns the AutoWordSelect feature on or off.
 *
 *
 *	TXTBIT_AUTOSIZE:
 *
 *	This property turns the AutoSize feature on or off. Refer to the 
 *	"AutoSize" section for more details.
 *
 *
 *	TXTBIT_VERTICAL:
 *
 *	This property turns on vertical writing. Used for FE support. 
 *	Details TBD.
 *
 *
 *	TXTBIT_WORDWRAP:
 *
 *	If this property is TRUE and MultiLine is also TRUE, then Text Services 
 *	should wrap the line to the view rectangle. If this property is FALSE, 
 *	the lines should not be wrapped but clipped. The right side of the 
 *	view rectangle should be ignored. 
 *
 *	If the MultiLine property is off, this property has no effect.
 *
 *
 * 	TXTBIT_LINESELECTION:
 *
 *	This property turns on or off the Line Selection feature. This feature 
 *	enable the user to select lines or paragraph by placing the mouse cursor 
 *	over a "line selection" area on the left of the control. The cursor is 
 *	displayed as a NE arrow in that area. If the Line Selection feature is 
 *	off, that area should not be shown.
 *
 */
HRESULT CTxtEdit::OnTxPropertyBitsChange(
	DWORD dwMask, 			//@parm	Bits representing properties to be changed
	DWORD dwBits)			//@parm	New values for bit properties
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxPropertyBitsChange");

	HRESULT hr = E_FAIL;
	DWORD dwLoopMask = dwMask;
	CCallMgr callmgr(this);

	START_PROFILING

	for (int i = 0; (i < MAX_PROPERTY_BITS) && (dwLoopMask != 0); 
		i++, dwLoopMask >>= 1)
	{
		if (dwLoopMask & 1)
		{
			hr = (this->*_fnpPropChg[i])((dwBits & (1 << i)) != 0);
			if (FAILED(hr))
				return hr;
		}			
	}
	return S_OK;
}

/*
 *	CTxtEdit::TxGetCachedSize (pdup, pdvp)
 *
 *	@mfunc
 *		Returns the cached drawing size (if any) that text services
 *		is using.  Typically, this will be the size of the last client
 *		rect used in TxDraw, TxSetCursor, etc., although it is not
 *		guaranteed to be.
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm
 *		This information is provided to allow the host to potentially
 *		perform various optimizations, amongst other things.
 */
HRESULT CTxtEdit::TxGetCachedSize(
	DWORD *pdupClient,	//@parm Where to put width (in client coords) 
	DWORD *pdvpClient)	//@parm Where to put height (in client coords)
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCachedSize");

	return _pdp->GetCachedSize((long*) pdupClient, (long*) pdvpClient);
}	

// Forward declaration of initialization helper.
// These really should be in some header file.  But which?
// Currently the definitions are in dxfrobj.cpp and font.cpp
void RegisterFETCs();
void InitFontCache();

/*
 *	CreateTextServices (punkOuter, phost, ppserv)
 *
 *	@func
 *		Create an instance of the RichEdit Engine.  This engine supports the
 *		ITextServices and Microsoft Text Object Model (TOM) interfaces.
 *
 *	@rdesc
 *		S_OK - New text services instance created successfully. <nl>
 *		E_INVALIDARG - An invalid argument was passed in. <nl>
 *		E_OUTOFMEMORY - Memory for text services object could not be allocated. <nl>
 *		E_FAIL - Text services could not be initialized
 *
 *	@comm
 *		Text Services may be created as a standard OLE aggregated object.
 *		Callers should follow standard OLE32 rules for dealing with
 *		aggregated objects and caching interface pointers obtained via
 *		QueryInterface from the private IUnknown.
 */
STDAPI CreateTextServices(
	IUnknown *punkOuter,	//@parm	Outer unknown, may be NULL
	ITextHost *phost, 		//@parm	Client's ITextHost implementation; must be
							//		valid
	IUnknown **ppUnk)		//@parm	Private IUnknown of text services engine
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CreateTextServices");

	static bool fOnce = FALSE;

	if (!fOnce) {
		CLock lock;
		fOnce = TRUE;
		W32->InitSysParams();
		W32->InitPreferredFontInfo();
		RegisterFETCs();					// Register new clipboard formats
		CreateFormatCaches();				// Create global format caches
		if ( !InitKinsokuClassify() )
		{
			// Init tables for classifying Unicode chars.
			return E_FAIL;
		}
		InitFontCache();
	}

	if(!ppUnk)
		return E_INVALIDARG;

	CTxtEdit *ped = new CTxtEdit((ITextHost2*)phost, punkOuter);
	if(!ped)
		return E_OUTOFMEMORY;

	if(ped->Init(NULL))
	{
		*ppUnk = ped->GetPrivateIUnknown();
		return S_OK;	
	}
	delete ped;
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\text.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module TEXT.C -- CTxtPtr implementation |
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95		alexgo	cleanup and reorganization (use run pointers now)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_text.h"
#include "_edit.h"
#include "_antievt.h"
#include "_clasfyc.h"
#include "_txtbrk.h"


ASSERTDATA

//-----------------------------Internal functions--------------------------------
// Text Block management
static void TxDivideInsertion(LONG cch, LONG ichBlock, LONG cchAfter,
			LONG *pcchFirst, LONG *pcchLast);

/*
 *	IsWhiteSpace(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char (see IsEOP() for definition),
 *		TAB or blank. This function is used in identifying sentence start
 *		and end.
 *
 *	@rdesc
 *		TRUE if ch is whitespace
 */  
BOOL IsWhiteSpace(unsigned ch)
{
	return ch == ' ' || IN_RANGE(CELL, ch, CR) || (ch | 1) == PS;
}

/*
 *	IsSentenceTerminator(ch)
 *
 *	@func
 *		Used to determine if ch is a standard sentence terminator character,
 *		namely, '?', '.', or '!'
 *
 *	@rdesc
 *		TRUE if ch is a question mark, period, or exclamation point.
 */  
BOOL IsSentenceTerminator(unsigned ch)
{
	return ch == '?' || ch == '.' || ch == '!';		// Std sentence delimiters
}


// ===========================  Invariant stuff  ==================================================

#define DEBUG_CLASSNAME CTxtPtr
#include "_invar.h"

// ===============================  CTxtPtr  ======================================================

#ifdef DEBUG

/*
 *	CTxtPtr::Invariant
 *
 *	@mfunc	invariant check
 */
BOOL CTxtPtr::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// Counts how many times we've been called

	// Make sure _cp is within range
	Assert(_cp >= 0);

	Update_pchCp();

	CRunPtrBase::Invariant();

	if(IsValid())
	{
		// We use less than or equals here so that we can be an insertion
		// point at the *end* of the currently existing text.
		Assert(_cp <= GetTextLength());

		// Make sure all the blocks are consistent...
		Assert(GetTextLength() == ((CTxtArray *)_pRuns)->Invariant());
		Assert(_cp == CRunPtrBase::CalculateCp());
	}
	else
	{
		Assert(_ich == 0);
	}

	return TRUE;
}

/*
 *	CTxtPtr::Update_pchCp ()
 *	
 *	@mfunc
 *		Define _pchCp to be ptr to text at _cp
 */
void CTxtPtr::Update_pchCp() const
{
	LONG cchValid;
	*(LONG_PTR *)&_pchCp = (LONG_PTR)GetPch(cchValid);
	if(!cchValid)
		*(LONG_PTR *)&_pchCp = (LONG_PTR)GetPchReverse(cchValid);
}
 
 /*
 *	CTxtPtr::MoveGapToEndOfBlock ()
 *	
 *	@mfunc
 *		Function to move buffer gap to current block end to aid in debugging
 */
void CTxtPtr::MoveGapToEndOfBlock () const
{
	CTxtBlk *ptb = GetRun(0);
	ptb->MoveGap(ptb->_cch);				// Move gaps to end of cur block
	Update_pchCp();
}

#endif	// DEBUG


/*
 *	CTxtPtr::CTxtPtr(ped, cp)
 *
 *	@mfunc	constructor
 */
CTxtPtr::CTxtPtr (
	CTxtEdit *ped,		//@parm	Ptr to CTxtEdit instance
	LONG	  cp)		//@parm cp to set the pointer to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	_ped = ped;
	_cp = 0;
	SetRunArray((CRunArray *) &ped->GetTxtStory()->_TxtArray);
	if(IsValid())
		_cp = BindToCp(cp);
}

/*
 *	CTxtPtr::CTxtPtr(&tp)
 *
 *	@mfunc	Copy Constructor
 */
CTxtPtr::CTxtPtr (
	const CTxtPtr &tp)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	// copy all the values over
	*this = tp;
}	

/*
 *	CTxtPtr::GetTextLength()
 *	
 *	@mfunc
 *		Return count of characters in the story pointed to by this
 *		text ptr.  Includes the story's final CR in the count
 *
 *	@rdesc
 *		cch for the story pointed to by this text ptr
 *
 *	@devnote
 *		This method returns 0 if the text ptr is a zombie, a state
 *		identified by _ped = NULL.
 */
LONG CTxtPtr::GetTextLength() const
{
	return _ped ? ((CTxtArray *)_pRuns)->_cchText : 0;
}

/*
 *	CTxtPtr::GetChar()
 *	
 *	@mfunc
 *		Return character at this text pointer, NULL if text pointer is at 
 *		end of text
 *
 *	@rdesc
 *		Character at this text ptr
 */
WCHAR CTxtPtr::GetChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetChar");

	LONG		 cchValid;
	const WCHAR *pch = GetPch(cchValid);

	return pch ? *pch : 0;
}  

/*
 *	CTxtPtr::GetPrevChar()
 *	
 *	@mfunc
 *		Return character just before this text pointer, NULL if text pointer 
 *		beginning of text
 *
 *	@rdesc
 *		Character just before this text ptr
 */
WCHAR CTxtPtr::GetPrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPrevChar");

	LONG		 cchValid;
	const WCHAR *pch = GetPchReverse(cchValid);

	return pch ? *(pch - 1) : 0;
}  

/*
 *	CTxtPtr::GetPch(&cchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValid is guaranteed to be at least 1
 */
const WCHAR * CTxtPtr::GetPch(
	LONG & 	cchValid) const	//@parm	Count of chars for which ptr is valid
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPch");
							//		returned pointer is valid
	LONG		ich = _ich;
	WCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValid = 0;						// Default nothing valid
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the next run or 
	// stay at the current run.
	if(_ich == ptb->_cch)
	{
		if(_iRun < Count() - 1)
		{
			// Set us to the next text block
			ptb = GetRun(1);
			ich = 0;
		}
		else							// At very end of text:
			return NULL;				//  just return NULL
	}
	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPch(): _ich bigger than block");

	pchBase = ptb->_pch + ich;

	// Check to see if we need to skip over gap.  Recall that
	// the gap may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want 
	// the active ich) is beyond the gap, then recompute pchBase
	// by adding in the size of the block.
	//
	// cchValid will then be the number of characters left in
	// the text block (or _cch - ich) 
  
	if(CbOfCch(ich) >= ptb->_ibGap)
	{
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;
		cchValid = ptb->_cch - ich;
	}
	else
	{
		// We're valid until the buffer gap (or see below).
		cchValid = CchOfCb(ptb->_ibGap) - ich;
	}

	AssertSz(cchValid > 0 && GetCp() + cchValid <= GetTextLength(),
		"CTxtPtr::GetPch: illegal cchValid");
	return pchBase;
}

/*
 *	CTxtPtr::GetPchReverse(&cchValidReverse, pcchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *		adjusted so that there are some characters valid *behind* the
 *		pointer.
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValidReverse is guaranteed to be at least 1
 */
const WCHAR * CTxtPtr::GetPchReverse(
	LONG & 	cchValidReverse,		//@parm	length for reverse 
	LONG *	pcchValid) const		//@parm length forward
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPchReverse");

	LONG		cchTemp;
	LONG		ich = _ich;
	WCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValidReverse = 0;				// Default no valid chars in run
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the previous run or 
	// stay at the current run.
	if(!_ich)
	{
		if(_iRun)
		{
			ptb = GetRun(-1);			// Go to next text block
			ich = ptb->_cch;
		}
		else							// At start of text:
			return NULL;				//  just return NULL
	}

	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPchReverse(): _ich bigger than block");

	pchBase = ptb->_pch + ich;

	// Check to see if we need to skip over gap.  Recall that
	// the game may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want 
	// the active ich) is at least one char past the gap, then recompute
	// pchBase by adding the size of the gap (so that it's after
	// the gap).  This differs from GetPch(), which works forward and
	// wants pchBase to include the gap size if ich is at the gap, let
	// alone one or more chars past it.
	//
	// Also figure out the count of valid characters.  It's
	// either the count of characters from the beginning of the 
	// text block, i.e. ich, or the count of characters from the
	// end of the buffer gap.

	cchValidReverse = ich;					// Default for ich <= gap offset
	cchTemp = ich - CchOfCb(ptb->_ibGap);	// Calculate displacement
	if(cchTemp > 0)							// Positive: pchBase is after gap
	{
		cchValidReverse = cchTemp;
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;	// Add in gap size
	}
	if(pcchValid)							// if client needs forward length
	{
		if(cchTemp > 0)
			cchTemp = ich - ptb->_cch;
		else
			cchTemp = -cchTemp;

		*pcchValid = cchTemp;
	}

	AssertSz(cchValidReverse > 0 && GetCp() - cchValidReverse >= 0,
		"CTxtPtr::GetPchReverse: illegal cchValidReverse");
	return pchBase;
}

/*
 *	CTxtPtr::GetCharFlagsInRange(cch, iCharRepDefault)
 *
 *	@mfunc
 *		return CharFlags for the range of chars starting at this text pointer
 *		for cch chars.
 *
 *	@rdesc
 *		CharFlags for the range of chars
 */
QWORD CTxtPtr::GetCharFlagsInRange(
	LONG cch,
	BYTE iCharRepDefault)
{
	QWORD qw = 0;
	QWORD qw0;
	WCHAR szch[10];

	cch = min(cch + 1, 10);
	cch = GetText(cch, szch);

	for(WCHAR *pch = szch; cch > 0; cch--, pch++)
	{
		qw0 = GetCharFlags(pch, cch, iCharRepDefault);
		if(qw0 & FSURROGATE)
		{
			cch--;
			pch++;
		}
		qw |= qw0;
	}
	return qw;
}

/*
 *	CTxtPtr::BindToCp(cp)
 *
 *	@mfunc
 *		set cached _cp = cp (or nearest valid value)
 *
 *	@rdesc
 *		_cp actually set
 *
 *	@comm
 *		This method overrides CRunPtrBase::BindToCp to keep _cp up to date
 *		correctly.
 *
 *	@devnote
 *		Do *not* call this method when high performance is needed; use
 *		Move() instead, which moves from 0 or from the cached
 *		_cp, depending on which is closer.
 */
LONG CTxtPtr::BindToCp(
	LONG	cp)			//@parm	char position to bind to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BindToCp");

	_cp = CRunPtrBase::BindToCp(cp, GetTextLength());

	// We want to be able to use this routine to fix up things so we don't
	// check invariants on entry.
	_TEST_INVARIANT_
	return _cp;
}

/*
 *	CTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		'efficiently' sets cp by advancing from current position or from 0,
 *		depending on which is closer
 *
 *	@rdesc
 *		cp actually set to
 */
LONG CTxtPtr::SetCp(
	LONG	cp)		//@parm char position to set to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::SetCp");

	Move(cp - _cp);
	return _cp;
}

/*
 *	CTxtPtr::Move(cch)
 *
 *	@mfunc
 *		Move cp by cch characters
 *
 *	@rdesc
 *		Actual number of characters Moved by
 *
 *	@comm
 *		We override CRunPtrBase::Move so that the cached _cp value
 *		can be correctly updated and so that the move can be made
 *		from the cached _cp or from 0, depending on which is closer.
 *
 *	@devnote
 *		It's also easy to bind at the end of the story. So an improved
 *		optimization would bind there if 2*(_cp + cch) > _cp + text length.
 */
LONG CTxtPtr::Move(
	LONG cch)			// @parm count of chars to move by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::Move");

	if(!IsValid())							// No runs yet, so don't go
		return 0;							//  anywhere

	const LONG	cpSave = _cp;				// Save entry _cp
	LONG		cp = cpSave + cch;			// Requested target cp (maybe < 0)

	if(cp < cpSave/2)						// Closer to 0 than cached cp
	{
		cp = max(cp, 0);					// Don't undershoot
		_cp = CRunPtrBase::BindToCp(cp);
	}
	else
		_cp += CRunPtrBase::Move(cch);	//  exist

	// NB! the invariant check needs to come at the end; we may be
	// moving 'this' text pointer in order to make it valid again
	// (for the floating range mechanism).

	_TEST_INVARIANT_
	return _cp - cpSave;					// cch this CTxtPtr moved
}

/*
 *	CTxtPtr::GetText(cch, pch)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, i.e., with no CR -> CRLF and WCH_EMBEDDING -> ' '
 *		translations.  For these translations, see CTxtPtr::GetPlainText()
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetText(
	LONG	cch, 			//@parm Count of characters to get
	WCHAR *	pch)			//@parm Buffer to copy the text into
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetText");

	LONG cchSave = cch;
	LONG cchValid;
	const WCHAR *pchRead;
	CTxtPtr tp(*this);

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);
		CopyMemory(pch, pchRead, cchValid*sizeof(WCHAR));
		pch += cchValid;
		cch -= cchValid;
		tp.Move(cchValid);
	}
	return cchSave - cch;
}

#ifndef NOCOMPLEXSCRIPTS
/*
 *	OverRideNeutralChar(ch)
 *	
 *	@mfunc
 *		Helper for overriding BiDi neutral character classification.
 *		Option is used in Access Expression Builder.
 *	
 *	@rdesc
 *		Modified character or unmodified input character
 */
WCHAR OverRideNeutralChar(WCHAR ch)
{
	if(ch < '!')
		return ch == CELL ? CR : ch;

	if(ch > '}')
		return ch;

	if (IN_RANGE('!', ch, '>'))
	{
		// True for !"#&'()*+,-./:;<=>
		if ((0x00000001 << (ch - TEXT(' '))) & 0x7C00FFCE)
			ch = 'a';
	}

	if (IN_RANGE('[', ch, '^') || ch == '{' ||  ch == '}')
	{
		// True for [/]^{}
		ch = 'a';
	}

	return ch;
}

/*
 *	CTxtPtr::GetTextForUsp(cch, pch, fNeutralOverride)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, with translation to fool Uniscribe classification
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetTextForUsp(
	LONG	cch, 			//@parm Count of characters to get
	WCHAR *	pch,				//@parm Buffer to copy the text into
	BOOL	fNeutralOverride)	//@parm Neutral override option
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetTextForUsp");

	LONG cchSave = cch;
	LONG cchValid;
	const WCHAR *pchRead;
	CTxtPtr tp(*this);
	int i;
	WCHAR xltchar;

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);

		if (!fNeutralOverride)
		{
			for (i = 0; i < cchValid; i++)
			{
				xltchar = pchRead[i];
				if(xltchar <= '$')
				{
					if(xltchar >= '#')
						xltchar = '@';
					if(xltchar == CELL)
						xltchar = CR;
				}
				pch[i] = xltchar;
			}
		}
		else
		{
			for (i = 0; i < cchValid; i++)
			{
				pch[i] = OverRideNeutralChar(pchRead[i]);
			}

		}

		pch += cchValid;
		cch -= cchValid;
		tp.Move(cchValid);
	}
	return cchSave - cch;
}
#endif

/*
 *	CTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize)
 *	
 *	@mfunc
 *		Copy up to cchBuff characters or up to cpMost, whichever comes
 *		first, translating lone CRs into CRLFs.  Move this text ptr just
 *		past the last character processed.  If fTextize, copy up to but
 *		not including the first WCH_EMBEDDING char. If not fTextize, 
 *		replace	WCH_EMBEDDING by a blank since RichEdit 1.0 does.
 *	
 *	@rdesc
 *		Count of characters copied
 *
 *  @comm
 *		An important feature is that this text ptr is moved just past the
 *		last char copied.  In this way, the caller can conveniently read
 *		out plain text in bufferfuls of up to cch chars, which is useful for
 *		stream I/O.  This routine won't copy the final CR even if cpMost
 *		is beyond it.
 */
LONG CTxtPtr::GetPlainText(
	LONG	cchBuff,		//@parm Buffer cch
	WCHAR *	pch,			//@parm Buffer to copy text into
	LONG	cpMost,			//@parm Largest cp to get
	BOOL	fTextize,		//@parm True if break on WCH_EMBEDDING
	BOOL	fUseCRLF)		//@parm If TRUE, CR or LF -> CRLF
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPlainText");

	LONG		 cch = cchBuff;				// Countdown counter
	LONG		 cchValid;					// Valid ptr cch
	LONG		 cchT;						// Temporary cch
	unsigned	 ch;						// Current char
	unsigned	 chPrev = 0;				// Previous char
	const WCHAR *pchRead;					// Backing-store ptr

	_TEST_INVARIANT_

	AdjustCRLF();							// Be sure we start on an EOP bdy

	if(_ped->Get10Mode())					// RE 1.0 delivers EOP chars as
		fUseCRLF = FALSE;					//  they appear in backing store

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);			// Don't write final CR
	if(GetCp() >= cpMost)
		return 0;

	while(cch > 0)							// While room in buffer
	{
		if(!(pchRead = GetPch(cchValid)))	// No more chars available
			break;							//  so we're out of here
		
		cchT = GetCp() + cchValid - cpMost;
		if(cchT > 0)						// Don't overshoot
		{
			cchValid -= cchT;
			if(cchValid <= 0)
				break;						// Nothing left before cpMost
		}

		for(cchT = 0; cch > 0 && cchT < cchValid; cchT++, cch--, chPrev = ch)
		{
			ch = *pch++ = *pchRead++;		// Copy next char (but don't
			if(IN_RANGE(CELL, ch, CR))		//  count it yet)
			{
				if(IsASCIIEOP(ch))			// LF, VT, FF, CR
				{
					if(!fUseCRLF || ch == FF)
						continue;
					if (ch == CR && chPrev == ENDFIELD &&
						cchValid - cchT > 1 &&
						*pchRead == STARTFIELD)
					{
						*(pch - 1) = ' ';	// New table row follows old:
						continue;			//  use only 1 CRLF
					}
					Move(cchT);				// Move up to CR
					if(cch < 2)				// No room for LF, so don't				
						goto done;			//  count CR either
											// Bypass EOP w/o worrying about
					cchT = AdvanceCRLF(FALSE);//  buffer gaps and blocks
					if(cchT > 2)			// Translate CRCRLF to ' '
					{						// Usually copied count exceeds
						Assert(cchT == 3);	//  internal count, but CRCRLFs
						*(pch - 1) = ' ';	//  reduce the relative increase:
					}						//  NB: error for EM_GETTEXTLENGTHEX
					else					// CRLF or lone CR
					{						// Store LF in both cases for
						*(pch - 1) = CR;	// Be sure it's a CR not a VT,
						*pch++ = LF;		// Windows. No LF for Mac
						cch--;				// One less for target buffer
					}
					cch--;					// CR (or ' ') copied
					cchT = 0;				// Don't Move() more below
					break;					// Go get new pchRead & cchValid
				}
				else if(ch == CELL)			// Use TAB for cell end markers
					*(pch - 1) = TAB;
			}
			else if(ch >= STARTFIELD)
			{								// Object lives here
				if(fTextize && ch == WCH_EMBEDDING)	// Break on WCH_EMBEDDING
				{
					Move(cchT);				// Move this text ptr up to
					goto done;				//  WCH_EMBEDDING and return
				}
				*(pch - 1) = ' ';			// Replace embedding char by ' '
			}								
		}
		Move(cchT);
	}

done:
	return cchBuff - cch;
}

/*
 *	CTxtPtr::AdvanceCRLF(fMulticharAdvance)
 *	
 *	@mfunc
 *		Move text pointer by one character, safely advancing
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 */
LONG CTxtPtr::AdvanceCRLF(
	BOOL	fMulticharAdvance)	//@parm If TRUE, advance over combining-mark sequences
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdvanceCRLF");

	_TEST_INVARIANT_

	LONG	cp;
	LONG	cpSave	= _cp;
	WCHAR	ch		= GetChar();		// Char on entry
	WCHAR	ch1		= NextChar();		// Advance to and get next char
	BOOL	fTwoCRs = FALSE;
	BOOL	fCombiningMark = FALSE;

	if(ch == CR)
	{
		if(ch1 == CR && _cp < GetTextLength()) 
		{
			fTwoCRs = TRUE;				// Need at least 3 chars to
			ch1 = NextChar();			//  have CRCRLF at end
		}
		if(ch1 == LF)
			Move(1);					// Bypass CRLF
		else if(fTwoCRs)
			Move(-1);					// Only bypass one CR of two

		AssertSz(_ped->fUseCRLF() || _cp == cpSave + 1,
			"CTxtPtr::AdvanceCRLF: EOP isn't a single char");
	}

		// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xD800, ch, 0xDBFF))	// Started on UTF-16 lead word
	{
		if (IN_RANGE(0xDC00, ch1, 0xDFFF))
			Move(1);					// Bypass UTF-16 trail word
		else
			AssertSz(FALSE, "CTxtPtr::AdvanceCRLF: illegal Unicode surrogate combo");
	}

	if (fMulticharAdvance)
	{
		while(IN_RANGE(0x300, ch1, 0x36F))	// Bypass combining diacritical marks
		{
			fCombiningMark = TRUE;
			cp = _cp;
			ch1 = NextChar();
			if (_cp == cp)
				break;
		}
	}

	if(IN_RANGE(STARTFIELD, ch, ENDFIELD))
		Move(1);					// Bypass field type

	LONG cch = _cp - cpSave;
	AssertSz(!cch || cch == 1 || fCombiningMark ||
			 cch == 2 && (IN_RANGE(0xD800, ch, 0xDBFF) ||
				IN_RANGE(STARTFIELD, ch, ENDFIELD)) ||
			 (_ped->fUseCRLF() && GetPrevChar() == LF &&
				(cch == 2 || cch == 3 && fTwoCRs)),
		"CTxtPtr::AdvanceCRLF(): Illegal multichar");

	return cch;				// # chars bypassed
}

/*
 *	CTxtPtr::NextChar()
 *	
 *	@mfunc
 *		Increment this text ptr and return char it points at
 *	
 *	@rdesc
 *		Next char
 */
WCHAR CTxtPtr::NextChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::NextChar");

	_TEST_INVARIANT_

 	Move(1);
	return GetChar();
}

/*
 *	CTxtPtr::PrevChar()
 *	
 *	@mfunc
 *		Decrement this text ptr and return char it points at
 *	
 *	@rdesc
 *		Previous char
 */
WCHAR CTxtPtr::PrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::PrevChar");

	_TEST_INVARIANT_

	return Move(-1) ? GetChar() : 0;
}

/*
 *	CTxtPtr::BackupCRLF(fMulticharBackup)
 *	
 *	@mfunc
 *		Backup text pointer by one character, safely backing up
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 *	@future
 *		Backup over Unicode combining marks
 */
LONG CTxtPtr::BackupCRLF(
	BOOL fMulticharBackup)	//@parm If TRUE, backup over combining-mark sequences
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BackupCRLF");

	_TEST_INVARIANT_

	LONG  cpSave = _cp;
	WCHAR ch	 = PrevChar();			// Moves to and get previous char

	if(fMulticharBackup)
	{									// Bypass combining diacritical marks
		while(IN_RANGE(0x300, ch, 0x36F))
			ch = PrevChar();
	}

	// Handle Unicode UTF-16 surrogates
	if(_cp && IN_RANGE(0xDC00, ch, 0xDFFF))
	{
		ch = PrevChar();
		if (!IN_RANGE(0xD800, ch, 0xDBFF))
		{
			AssertSz(FALSE, "CTxtPtr::BackupCRLF: illegal Unicode surrogate combo");
			ch = NextChar();
		}
	}

	if(ch == LF)					 	// Try to back up 1 char in any case
	{
		if(_cp && PrevChar() != CR)		// If LF, does prev char = CR?
			Move(1);					// No, leave tp at LF

		else if(_cp && !IsAfterTRD(0) &&// At CRLF. If not after TRD
			PrevChar() != CR)			//  and prev char != CR, leave
		{								//  at CRLF
			Move(1);					
		}
	}
	else if(IN_RANGE(STARTFIELD, GetPrevChar(), ENDFIELD))
		Move(-1);						// Bypass field type
	
	AssertSz( _cp == cpSave ||
			  ch == LF && GetChar() == CR ||
			  !(ch == LF || fMulticharBackup &&
							(IN_RANGE(0x300, ch, 0x36F) ||
							 IN_RANGE(0xDC00, ch, 0xDFFF) && IN_RANGE(0xD800, GetPrevChar(), 0xDBFF)) ),
			 "CTxtPtr::BackupCRLF(): Illegal multichar");

	return _cp - cpSave;				// - # chars this CTxtPtr moved
}

/*
 *	CTxtPtr::AdjustCRLF(iDir)
 *	
 *	@mfunc
 *		Adjust the position of this text pointer to the beginning of a CRLF
 *		or CRCRLF combination, if it is in the middle of such a combination.
 *		Move text pointer to the beginning/end (for iDir neg/pos) of a Unicode
 *		surrogate pair or a STARTFIELD/ENDFIELD pair if it is in the middle 
 *		of such a pair.
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 *	@future
 *		Adjust to beginning of sequence containing Unicode combining marks
 */
LONG CTxtPtr::AdjustCRLF(
	LONG iDir)		//@parm Move forward/backward for iDir = 1/-1, respectively
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdjustCpCRLF");

	_TEST_INVARIANT_

	UINT ch		= GetChar();
	LONG cpSave = _cp;

	if(!_cp)									// Alignment always correct
		return 0;								//  at cp 0

	iDir = iDir < 0 ? -1 : 1;

	// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xDC00, ch, 0xDFFF))			// Landed on UTF-16 trail word
	{
		AssertSz(IN_RANGE(0xD800, GetPrevChar(), 0xDBFF),
			"CTxtPtr::AdjustCRLF: illegal Unicode surrogate combo");
		return Move(iDir);						// Backup to UTF-16 lead word or
	}											//  move forward to next char

	UINT chPrev = GetPrevChar();

	if(IN_RANGE(STARTFIELD, chPrev, ENDFIELD) && chPrev != 0xFFFA)
		return Move(iDir);

	if(!IsASCIIEOP(ch) || IsAfterTRD(0))		// Early out
		return 0;

	if(ch == LF && chPrev == CR)				// Landed on LF preceded by CR:
		Move(-1);								//  move to CR for CRCRLF test

	// Leave as adjust-forward only behavior for RE 1.0 compatibility on
	// CRCRLF and CRLF
	if(GetChar() == CR)							// Land on a CR of CRLF or
	{											//  second CR of CRCRLF?
		CTxtPtr tp(*this);

		if(tp.NextChar() == LF)
		{
			tp.Move(-2);						// First CR of CRCRLF ?
			if(tp.GetChar() == CR)				// Yes or CRLF is at start of
				Move(-1);						//  story. Try to back up over
		}										//  CR (If at BOS, no effect)
	}
	return _cp - cpSave;
}

/*
 *	CTxtPtr::IsAtEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is at an end-of-paragraph mark
 *	
 *	@rdesc
 *		TRUE if at EOP
 *
 *	@devnote
 *		End of paragraph marks for RichEdit 1.0 and the MLE can be CRLF
 *		and CRCRLF.  For RichEdit 2.0, EOPs can also be CR, VT (0xB - Shift-
 *		Enter), and FF (0xC - page break or form feed).
 */
BOOL CTxtPtr::IsAtEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtEOP");

	_TEST_INVARIANT_

	unsigned ch = GetChar();

	if(IsASCIIEOP(ch))							// See if LF <= ch <= CR
	{											// Clone tp in case
		CTxtPtr tp(*this);						//  AdjustCpCRLF moves
		return !tp.AdjustCRLF();				// Return TRUE unless in
	}											//  middle of CRLF or CRCRLF
	return (ch | 1) == PS || ch == CELL;		// Allow Unicode 0x2028/9 also
}

/*
 *	CTxtPtr::IsAfterEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is just after an end-of-paragraph
 *		mark
 *	
 *	@rdesc
 *		TRUE iff text ptr follows an EOP mark
 */
BOOL CTxtPtr::IsAfterEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAfterEOP");

	_TEST_INVARIANT_

	if(IsASCIIEOP(GetChar()))
	{
		CTxtPtr tp(*this);					// If in middle of CRLF
		if(tp.AdjustCRLF())					//  or CRCRLF, return FALSE
			return FALSE;
	}
	return IsEOP(GetPrevChar());			// After EOP if after Unicode
}								   			//  PS or LF, VT, FF, CR, CELL

/*
 *	CTxtPtr::IsAtTRD(ch)
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is at a table row delimiter (ch CR).
 *		If ch = 0, then match both start and end delimiters.
 *	
 *	@rdesc
 *		TRUE iff text ptr is at a table row end delimiter
 */
BOOL CTxtPtr::IsAtTRD(
	WCHAR ch)	//@parm Table Row Delimiter
{
	LONG		 cchValid;
	const WCHAR *pch = GetPch(cchValid);

	if(cchValid < 1)
		return FALSE;

	WCHAR chNext;

	if(cchValid < 2)					// In case gap splits TRD
	{									//  (may happen after undo)
		CTxtPtr tp(*this);
		tp.Move(1);
		chNext = tp.GetChar();
	}
	else
		chNext = *(pch + 1);

	if(chNext != CR)
		return FALSE;

	if(ch)
	{
		AssertSz(ch == STARTFIELD || ch == ENDFIELD,
			"CTxtPtr::IsAtTRD: illegal argument");
		return *pch == ch;
	}
	ch = *pch;
	return ch == STARTFIELD || ch == ENDFIELD; 
}

/*
 *	CTxtPtr::IsAfterTRD(ch)
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer immediately follows a table row 
 *		start/end delimiter specified by ch (ch = STARTFIELD/ENDFIELD
 *		followed by CR).  If ch = 0, then match both start and end delims.
 *	
 *	@rdesc
 *		TRUE iff text ptr follows an table row start delimiter
 */
BOOL CTxtPtr::IsAfterTRD(
	WCHAR ch)	//@parm Table Row Delimiter
{
	LONG		 cchValid;
	const WCHAR *pch = GetPchReverse(cchValid);

	if(cchValid < 1 || *(pch - 1) != CR)
		return FALSE;

	WCHAR chPrev;

	if(cchValid < 2)					// In case gap splits TRD
	{									//  (may happen after undo)
		CTxtPtr tp(*this);
		tp.Move(-1);
		chPrev = tp.GetPrevChar();
	}
	else
		chPrev = *(pch - 2);

	if(ch)
	{
		AssertSz(ch == STARTFIELD || ch == ENDFIELD,
			"CTxtPtr::IsAfterTRD: illegal argument");
		return chPrev == ch;
	}
	return chPrev == STARTFIELD || chPrev == ENDFIELD; 
}

/*
 *	CTxtPtr::IsAtStartOfCell()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer immediately follows a table row 
 *		start delimiter (STARTFIELD CR) or any cell delimiter (CELL) except
 *		the last one in a row.
 *	
 *	@rdesc
 *		TRUE iff text ptr follows an table row start delimiter
 */
BOOL CTxtPtr::IsAtStartOfCell()
{
	LONG		 cchValid;
	const WCHAR *pch = GetPchReverse(cchValid);

	return cchValid && *(pch - 1) == CELL && !IsAtTRD(ENDFIELD) ||
		   cchValid >= 2 && *(pch - 1) == CR && *(pch - 2) == STARTFIELD;
}


// Needed for CTxtPtr::ReplaceRange() and InsertRange()
#if cchGapInitial < 1
#error "cchGapInitial must be at least one"
#endif

/*
 *	CTxtPtr::MoveWhile(cch, chFirst, chLast, fInRange)
 *	
 *	@mfunc
 *		Move this text ptr 1) to first char (fInRange ? in range : not in range)
 *		chFirst thru chLast or 2) cch chars, which ever comes first.  Return
 *		count of chars left in run on return. E.g., chFirst = 0, chLast = 0x7F
 *		and fInRange = TRUE	breaks on first nonASCII char.
 *	
 *	@rdesc
 *		cch left in run on return
 */
LONG CTxtPtr::MoveWhile(
	LONG  cchRun,	//@parm Max cch to check
	WCHAR chFirst,	//@parm First ch in range
	WCHAR chLast,	//@parm Last ch in range
	BOOL  fInRange)	//@parm break on non0/0 high byte for TRUE/FALSE
{
	LONG  cch;
	LONG  i;
	const WCHAR *pch;

	while(cchRun)
	{
		pch = GetPch(cch);
		cch = min(cch, cchRun);
		for(i = 0; i < cch; i++)
		{
			if(IN_RANGE(chFirst, *pch++, chLast) ^ fInRange)
			{
				Move(i);		// Advance to 1st char with 0/non0 masked
				return cchRun - i;	//  value
			}
		}
		cchRun -= cch;
		Move(cch);				// Advance to next txt bdy
	}
	return 0;
}

/*
 *	CTxtPtr::FindWordBreak(action, cpMost)
 *	
 *	@mfunc
 *		Find a word break and move this text pointer to it.
 *
 *	@rdesc
 *		Offset from cp of the word break
 */
LONG CTxtPtr::FindWordBreak(
	INT		action,		//@parm See TxWordBreakProc header
	LONG	cpMost)		//@parm Limiting character position
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

	_TEST_INVARIANT_

	const INT			breakBufSize = 10;
	LONG				bufferSize;
	LONG				cch;
	LONG				cchBuffer;
	LONG				cchChunk;
	LONG				cchText = GetTextLength();
	WCHAR				ch = GetChar();
	WCHAR				pchBreakBuf[breakBufSize];
	LONG				cpSave = _cp;				// For calculating break pt
	LONG				ichBreak;
	WCHAR *				pBuf;
	WCHAR const *		pch;
	LONG				t;							// Temp for abs() macro
	BOOL				b10ModeWordBreak = (_ped->Get10Mode() && _ped->_pfnWB);

	if(action == WB_CLASSIFY || action == WB_ISDELIMITER)
		return ch ? _ped->TxWordBreakProc(&ch, 0, CbOfCch(1), action, GetCp()) : 0;

	if(action & 1)									// Searching forward
	{												// Easiest to handle EOPs			
		if(action == WB_MOVEWORDRIGHT && IsEOP(ch))	//  explicitly (spanning
		{											//  a class can go too
			AdjustCRLF();							//  far). Go to end of
			AdvanceCRLF();							//  EOP "word"
			goto done;
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)cchText)			// Bounds check: get < 0
			cpMost = cchText;						//  as well as too big
		cch = cpMost - _cp;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf;						// Fill buffer forward

			// Grab the first character in reverse for fnWB that require 2
			// chars. Note, we play with _ich to get single char fnWB
			// to ignore this character.			 							
			pch = GetPchReverse(cchChunk);
			if ( !cchChunk ) pch = L" ";			// Any break char
			*pBuf++ = *pch;

//			*pBuf++ = (cchChunk ? *(pch - 1) : L' ');

			while ( cchBuffer )						// Finish filling
			{
				pch = GetPch(cchChunk);
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				Move(cchChunk);
				wcsncpy(pBuf, pch, cchChunk);
				pBuf += cchChunk;
				cchBuffer -= cchChunk;
			}
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, 1,		// Find the break
						CbOfCch(bufferSize+1), action, GetCp()-bufferSize, GetCp()-bufferSize) - 1;

			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == -1 && b10ModeWordBreak)
				ichBreak = 0;

			// Apparently, some fnWBs return ambiguous results						
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{
				// Ambiguous break pt?
				// Due to the imprecise nature of the word break proc spec,
				// we've reached an ambiguous condition where we don't know
				// if this is really a break, or just the end of the data.
				// By backing up or going forward by 2, we'll know for sure.
				// NOTE: we'll always be able to advance or go back by 2
				// because we guarantee that when !cch that we have
				// at least breakBufSize (16) characters in the data stream.
				if (ichBreak < bufferSize || !cch)
				{
					Move( ichBreak - bufferSize );
					break;
				}

				// Need to recalc break pt to disambiguate
				t = Move(ichBreak - bufferSize - 2);	// abs() is a
				cch += abs(t);						//  macro
			}
		}
	}
	else	// REVERSE - code dup based on EliK "streams" concept.
	{
		if(!_cp)									// Can't go anywhere
			return 0;

		if(action == WB_MOVEWORDLEFT)				// Easiest to handle EOPs			
		{											//  here
			if(IsASCIIEOP(ch) && AdjustCRLF())		// In middle of a CRLF or
				goto done;							//  CRCRLF "word"
			ch = PrevChar();						// Check if previous char
			if(IsEOP(ch))							//  is an EOP char
			{
				if(ch == LF)						// Backspace to start of
					AdjustCRLF();					//  CRLF and CRCRLF
				goto done;
			}
			Move(1);							// Move back to start char
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)_cp)				// Bounds check (also
			cpMost = _cp;							//  handles cpMost < 0)
		cch = cpMost;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf + cchBuffer;			// Fill from the end.

			// Grab the first character forward for fnWB that require 2 chars.
			// Note: we play with _ich to get single char fnWB to ignore this
			// character.
			pch = GetPch(cchChunk);
			if ( !cchChunk ) pch = L" ";			// Any break char
			*pBuf = *pch;

			while ( cchBuffer > 0 )					// Fill rest of buffer 
			{										//  before going in reverse
				pch = GetPchReverse(cchChunk );
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				Move(-cchChunk);
				pch -= cchChunk;
				pBuf -= cchChunk;
				wcsncpy(pBuf, pch, cchChunk);
				cchBuffer -= cchChunk;
			}
													// Get break left.
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, bufferSize,
							 CbOfCch(bufferSize+1), action, GetCp(), GetCp()+bufferSize);
			
			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == 0 && b10ModeWordBreak)
				ichBreak = bufferSize;

			// Apparently, some fnWBs return ambiguous results
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{										// Ambiguous break pt?
				// NOTE: when going in reverse, we have >= bufsize - 1
				//  because there is a break-after char (hyphen).
				if ( ichBreak > 0 || !cch )
				{
					Move(ichBreak);			// Move _cp to break point.
					break;
				}													
				cch += Move(2 + ichBreak);		// Need to recalc break pt
			}										//  to disambiguate.
		}
	}

done:
	return _cp - cpSave;							// Offset of where to break
}

/*
 *	CTxtPtr::TranslateRange(cch, CodePage, fSymbolCharSet, publdr)
 *
 *	@mfunc
 *		Translate a range of text at this text pointer to...
 *	
 *	@rdesc
 *		Count of new characters added (should be same as count replaced)
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CTxtPtr::TranslateRange(
	LONG		  cch,				//@parm length of range to translate
	UINT		  CodePage,			//@parm CodePage for MBTWC or WCTMB
	BOOL		  fSymbolCharSet,	//@parm Target charset
	IUndoBuilder *publdr)			//@parm Undo bldr to receive antievents
{
	CTempWcharBuf twcb;
	CTempCharBuf tcb;

	UINT	ch;
	BOOL	fAllASCII = TRUE;
	BOOL	fNoCodePage;
	BOOL	fUsedDef;	//@parm Out parm to receive whether default char used
	LONG	i;
	char *	pastr = tcb.GetBuf(cch);
	WCHAR *	pstr  = twcb.GetBuf(cch);
	WCHAR * pstrT = pstr;

	i = GetText(cch, pstr);
	Assert(i == cch);

	if(fSymbolCharSet)					// Target is SYMBOL_CHARSET
	{
		WCTMB(CodePage, 0, pstr, cch, pastr, cch, "\0", &fUsedDef,
			  &fNoCodePage, FALSE);
		if(fNoCodePage)
			return cch;
		for(; i && *pastr; i--)			// Break if conversion failed
		{								//  (NULL default char used)
			if(*pstr >= 128)
				fAllASCII = FALSE;
			*pstr++ = *(BYTE *)pastr++;
		}
		cch -= i;
		if(fAllASCII)
			return cch;
	}
	else								// Target isn't SYMBOL_CHARSET
	{
		while(i--)
		{
			ch = *pstr++;				// Source is SYMBOL_CHARSET, so
			*pastr++ = (char)ch;		//  all chars should be < 256
			if(ch >= 128)				// In any event, truncate to BYTE
				fAllASCII = FALSE;
		}								
		if(fAllASCII)					// All ASCII, so no conversion needed
			return cch;

		MBTWC(CodePage, 0, pastr - cch, cch, pstrT, cch, &fNoCodePage);
		if(fNoCodePage)
			return cch;
	}
	return ReplaceRange(cch, cch, pstrT, publdr, NULL, NULL);
}

/*
 *	CTxtPtr::ReplaceRange(cchOld, cchNew, *pch, publdr, paeCF, paePF)
 *	
 *	@mfunc
 *		replace a range of text at this text pointer.
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@comm	SideEffects: <nl>
 *		moves this text pointer to end of replaced text <nl>
 *		moves text block array <nl>
 */
LONG CTxtPtr::ReplaceRange(
	LONG cchOld, 				//@parm length of range to replace 
								// (<lt> 0 means to end of text)
	LONG cchNew, 				//@parm length of replacement text
	WCHAR const *pch, 			//@parm replacement text
	IUndoBuilder *publdr,		//@parm if non-NULL, where to put an 
								// anti-event for this action
	IAntiEvent *paeCF,			//@parm char format AE
	IAntiEvent *paePF )			//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::ReplaceRange");

	_TEST_INVARIANT_

	LONG cchAdded = 0;
	LONG cchInBlock;
	LONG cchNewInBlock;

	if(cchOld < 0)
		cchOld = GetTextLength() - _cp;

	if(publdr)
		HandleReplaceRangeUndo( cchOld, cchNew, publdr, paeCF, paePF);

	// Blocks involving replacement

	while(cchOld > 0 && cchNew > 0) 
	{	
		CTxtBlk *ptb = GetRun(0);

		// cchOld should never be nonzero if the text run is empty
		AssertSz(ptb,
			"CTxtPtr::Replace() - Pointer to text block is NULL !");

		ptb->MoveGap(_ich);
		cchInBlock = min(cchOld, ptb->_cch - _ich);
		if(cchInBlock > 0)
		{
			cchOld			-= cchInBlock;
			ptb->_cch		-= cchInBlock;
			((CTxtArray *)_pRuns)->_cchText	-= cchInBlock;
		}
		cchNewInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;

		// if there's room for a gap, leave one
		if(cchNewInBlock > cchGapInitial)
			cchNewInBlock -= cchGapInitial;

		if(cchNewInBlock > cchNew)
			cchNewInBlock = cchNew;

		if(cchNewInBlock > 0)
		{
			CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchNewInBlock));
			cchNew			-= cchNewInBlock;
			_cp				+= cchNewInBlock;
			_ich			+= cchNewInBlock;
			pch				+= cchNewInBlock;
			cchAdded		+= cchNewInBlock;
			ptb->_cch		+= cchNewInBlock;
			ptb->_ibGap		+= CbOfCch(cchNewInBlock);
			((CTxtArray *)_pRuns)->_cchText	+= cchNewInBlock;
		}
	   	if(_iRun >= Count() - 1 || !cchOld )
		   	break;

		// Go to next block
		_iRun++;
   		_ich = 0;
	}

	if(cchNew > 0)
		cchAdded += InsertRange(cchNew, pch);

	else if(cchOld > 0)
		DeleteRange(cchOld);
	
	return cchAdded;
}

/*
 *	CTxtPtr::HandleReplaceRangeUndo (cchOld, cchNew, publdr, paeCF, paePF)
 *
 *	@mfunc
 *		worker function for ReplaceRange.  Figures out what will happen in
 *		the replace range call and creates the appropriate anti-events
 *
 *	@devnote
 *		We first check to see if our replace range data can be merged into
 *		an existing anti-event.  If it can, then we just return.
 *		Otherwise, we copy the deleted characters into an allocated buffer
 *		and then create a ReplaceRange anti-event.
 *
 *		In order to handle ordering problems between formatting and text
 *		anti-events (that is, text needs to exist before formatting can
 *		be applied), we have any formatting anti-events passed to us first.
 */
void CTxtPtr::HandleReplaceRangeUndo( 
	LONG			cchOld, //@parm Count of characters to delete
	LONG			cchNew, //@parm Count of new characters to add
	IUndoBuilder *	publdr,	//@parm Undo builder to receive anti-event
	IAntiEvent *	paeCF,	//@parm char formatting AE
	IAntiEvent *	paePF )	//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::HandleReplaceRangeUndo");

	_TEST_INVARIANT_

	IAntiEvent *pae = publdr->GetTopAntiEvent();
	WCHAR *		pch = NULL;

	if(pae)
	{
		SimpleReplaceRange	sr;
		sr.cpMin = _cp;
		sr.cpMax = _cp + cchNew;
		sr.cchDel = cchOld;
	
		if(pae->MergeData(MD_SIMPLE_REPLACERANGE, &sr) == NOERROR)
		{
			// If the data was merged successfully, then we do
			// not need these anti-events
			if(paeCF)
				DestroyAEList(paeCF);

			if(paePF)
				DestroyAEList(paePF);

			// we've done everything we need to.  
			return;
		}
	}

	// Allocate a buffer and grab the soon-to-be deleted
	// text (if necessary)

	if( cchOld > 0 )
	{
		pch = new WCHAR[cchOld];
		if( pch )
			GetText(cchOld, pch);
		else
			cchOld = 0;
	}

	// The new range will exist from our current position plus
	// cchNew (because everything in cchOld gets deleted)

	pae = gAEDispenser.CreateReplaceRangeAE(_ped, _cp, _cp + cchNew, 
			cchOld, pch, paeCF, paePF);

	if( !pae )
		delete pch;

	if( pae )
		publdr->AddAntiEvent(pae);
}

/*
 *	CTxtPtr::InsertRange(cch, pch)
 *	
 *	@mfunc
 *		Insert a range of characters at this text pointer			
 *	
 *	@rdesc
 *		Count of characters successfully inserted
 *	
 *	@comm Side Effects: <nl>
 *		moves this text pointer to end of inserted text <nl>
 *		moves the text block array <nl>
 */
LONG CTxtPtr::InsertRange (
	LONG cch, 				//@parm length of text to insert
	WCHAR const *pch)		//@parm text to insert
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::InsertRange");

	_TEST_INVARIANT_

	LONG cchSave = cch;
	LONG cchInBlock;
	LONG cchFirst;
	LONG cchLast = 0;
	LONG ctbNew;
	CTxtBlk *ptb;
	
	// Ensure text array is allocated
	if(!Count())
	{
		LONG	cbSize = -1;

		// If we don't have any blocks, allocate first block to be big enuf
		// for the inserted text *only* if it's smaller than the normal block
		// size. This allows us to be used efficiently as a display engine
		// for small amounts of text.
		if(cch < CchOfCb(cbBlockInitial))
			cbSize = CbOfCch(cch);

		if(!((CTxtArray *)_pRuns)->AddBlock(0, cbSize))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
	}

	ptb = GetRun(0);
	cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	AssertSz(ptb->_cbBlock <= cbBlockMost, "block too big");

	// Try resizing without splitting...
	if(cch > cchInBlock &&
		cch <= cchInBlock + CchOfCb(cbBlockMost - ptb->_cbBlock))
	{
		if( !ptb->ResizeBlock(min(cbBlockMost,
				CbOfCch(ptb->_cch + cch + cchGapInitial))) )
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
		cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	}
	if(cch <= cchInBlock)
	{
		// All fits into block without any hassle
		ptb->MoveGap(_ich);
		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cch));
		_cp				+= cch;					// *this points at end of
		_ich			+= cch;					//  insertion
		ptb->_cch		+= cch;
		((CTxtArray *)_pRuns)->_cchText	+= cch;
		ptb->_ibGap		+= CbOfCch(cch);

		return cch;
	}

	// Won't all fit in this block, so figure out best division into blocks
	TxDivideInsertion(cch, _ich, ptb->_cch - _ich,&cchFirst, &cchLast);

	// Subtract cchLast up front so return value isn't negative
	// if SplitBlock() fails
	cch -= cchLast;	// Don't include last block in count for middle blocks

	// Split block containing insertion point
	// ***** moves _prgtb ***** //
	if(!((CTxtArray *)_pRuns)->SplitBlock(_iRun, _ich, cchFirst, cchLast,
		_ped->IsStreaming()))
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		goto done;
	}
	ptb = GetRun(0);			// Recompute ptb after (*_pRuns) moves

	// Copy into first block (first half of split)
	if(cchFirst > 0)
	{
		AssertSz(ptb->_ibGap == CbOfCch(_ich), "split first gap in wrong place");
		AssertSz(cchFirst <= CchOfCb(ptb->_cbBlock) - ptb->_cch, "split first not big enough");

		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchFirst));
		cch				-= cchFirst;
		pch				+= cchFirst;
		_ich			+= cchFirst;
		ptb->_cch		+= cchFirst;
		((CTxtArray *)_pRuns)->_cchText	+= cchFirst;
		ptb->_ibGap		+= CbOfCch(cchFirst);
	}

	// Copy into middle blocks
	// FUTURE: (jonmat) I increased the size for how large a split block
	// could be and this seems to increase the performance, we should test
	// the block size difference on a retail build, however. 5/15/1995
	ctbNew = cch / cchBlkInsertmGapI /* cchBlkInitmGapI */;
	if(ctbNew <= 0 && cch > 0)
		ctbNew = 1;
	for(; ctbNew > 0; ctbNew--)
	{
		cchInBlock = cch / ctbNew;
		AssertSz(cchInBlock > 0, "nothing to put into block");

		// ***** moves _prgtb ***** //
		if(!((CTxtArray *)_pRuns)->AddBlock(++_iRun, 
			CbOfCch(cchInBlock + cchGapInitial)))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			BindToCp(_cp);	//force a rebind;
			goto done;
		}
		// NOTE: next line intentionally advances ptb to next CTxtBlk

		ptb = GetRun(0);
		AssertSz(ptb->_ibGap == 0, "New block not added correctly");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchInBlock));
		cch				-= cchInBlock;
		pch				+= cchInBlock;
		_ich			= cchInBlock;
		ptb->_cch		= cchInBlock;
		((CTxtArray *)_pRuns)->_cchText	+= cchInBlock;
		ptb->_ibGap		= CbOfCch(cchInBlock);
	}
	AssertSz(cch == 0, "Didn't use up all text");

	// copy into last block (second half of split)
	if(cchLast > 0)
	{
		AssertSz(_iRun < Count()-1, "no last block");
		ptb = Elem(++_iRun);
		AssertSz(ptb->_ibGap == 0,	"split last gap in wrong place");
		AssertSz(cchLast <= CchOfCb(ptb->_cbBlock) - ptb->_cch,
									"split last not big enuf");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchLast));
		// don't subtract cchLast from cch; it's already been done
		_ich			= cchLast;
		ptb->_cch		+= cchLast;
		((CTxtArray *)_pRuns)->_cchText	+= cchLast;
		ptb->_ibGap		= CbOfCch(cchLast);
		cchLast = 0;						// Inserted all requested chars
	}

done:
	AssertSz(cch + cchLast >= 0, "we should have inserted some characters");
	AssertSz(cch + cchLast <= cchSave, "don't insert more than was asked for");

	cch = cchSave - cch - cchLast;			// # chars successfully inserted
	_cp += cch;

	AssertSz (GetTextLength() == 
				((CTxtArray *)_pRuns)->CalcTextLength(), 
				"CTxtPtr::InsertRange(): _pRuns->_cchText screwed up !");
	return cch;
}

/*
 *	TxDivideInsertion(cch, ichBlock, cchAfter, pcchFirst, pcchLast)
 *	
 *	@func
 *		Find best way to distribute an insertion	
 *	
 *	@rdesc
 *		nothing
 */
static void TxDivideInsertion(
	LONG cch, 				//@parm length of text to insert
	LONG ichBlock, 			//@parm offset within block to insert text
	LONG cchAfter,			//@parm length of text after insertion in block
	LONG *pcchFirst, 		//@parm exit: length of text to put in first block
	LONG *pcchLast)			//@parm exit: length of text to put in last block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "TxDivideInsertion");

	LONG cchFirst = max(0, cchBlkCombmGapI - ichBlock);
	LONG cchLast  = max(0, cchBlkCombmGapI - cchAfter);
	LONG cchPartial;
	LONG cchT;

	// Fill first and last blocks to min block size if possible

	cchFirst = min(cch, cchFirst);
	cch		-= cchFirst;
	cchLast = min(cch, cchLast);
	cch		-= cchLast;

	// How much is left over when we divide up the rest?
	cchPartial = cch % cchBlkInsertmGapI;
	if(cchPartial > 0)
	{
		// Fit as much as the leftover as possible in the first and last
		// w/o growing the first and last over cbBlockInitial
		cchT		= max(0, cchBlkInsertmGapI - ichBlock - cchFirst);
		cchT		= min(cchT, cchPartial);
		cchFirst	+= cchT;
		cch			-= cchT;
		cchPartial	-= cchT;
		if(cchPartial > 0)
		{
			cchT	= max(0, cchBlkInsertmGapI - cchAfter - cchLast);
			cchT	= min(cchT, cchPartial);
			cchLast	+= cchT;
		}
	}
	*pcchFirst = cchFirst;
	*pcchLast = cchLast;
}

/*
 *	CTxtPtr::DeleteRange(cch)
 *	
 *	@mfunc
 *		Delete cch characters starting at this text pointer		
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm Side Effects:	<nl>
 *		moves text block array
 */
void CTxtPtr::DeleteRange(
	LONG cch)		//@parm length of text to delete
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::DeleteRange");

	_TEST_INVARIANT_

	LONG		cchInBlock;
	LONG		ctbDel = 0;					// Default no blocks to delete
	LONG		itb;
	CTxtBlk *	ptb = GetRun(0);
	LONG		cOldRuns = Count();

	AssertSz(ptb,
		"CTxtPtr::DeleteRange: want to delete, but no text blocks");

	if (cch > GetTextLength() - _cp)	// Don't delete beyond end of story
		cch = GetTextLength() - _cp;

	((CTxtArray *)_pRuns)->_cchText -= cch;

	// remove from first block
	ptb->MoveGap(_ich);
	cchInBlock = min(cch, ptb->_cch - _ich);
	cch -= cchInBlock;
	ptb->_cch -= cchInBlock;

#ifdef DEBUG
	((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG


	for(itb = ptb->_cch ? _iRun + 1 : _iRun;
			cch && cch >= Elem(itb)->_cch; ctbDel++, itb++)
	{
		// More to go: scan for complete blocks to remove
		cch -= Elem(itb)->_cch;
	}

	if(ctbDel)
	{
		// ***** moves (*_pRuns) ***** //
		itb -= ctbDel;
		((CTxtArray *)_pRuns)->RemoveBlocks(itb, ctbDel);
	}

	// Remove from last block
	if(cch > 0)
	{
		ptb = Elem(itb);
		AssertSz(cch < ptb->_cch, "last block too small");
		ptb->MoveGap(0);
		ptb->_cch -= cch;
#ifdef DEBUG
		((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG

	}
	((CTxtArray *)_pRuns)->CombineBlocks(_iRun);

	if(cOldRuns > Count() || _iRun >= Count() || !Elem(_iRun)->_cch)
		BindToCp(_cp);					// Empty block: force tp rebind

	AssertSz (GetTextLength() == 
				((CTxtArray *)_pRuns)->CalcTextLength(), 
				"CTxtPtr::DeleteRange(): _pRuns->_cchText screwed up !");
}

/*
 *	CTxtPtr::FindText (cpLimit, dwFlags, pch, cch)
 *
 *	@mfunc
 *		Find the text string <p pch> of length <p cch> starting at this
 *		text pointer. If found, move this text pointer to the end of the
 *		matched string and return the cp of the first character of the matched
 *		string.  If not found, return -1 and don't change this text ptr.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 */
LONG CTxtPtr::FindText (
	LONG		 cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		 dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const WCHAR *pch,		//@parm Text to find
	LONG		 cch)		//@parm Length of text to find
{
	LONG cpFirst, cpLast;
	CTxtFinder tf;

	if(tf.FindText(*this, cpLimit, dwFlags, pch, cch, cpFirst, cpLast))
	{
		// Set text ptr to char just after last char in found string
		SetCp(cpLast + 1);

		// Return cp of first char in found string
		return cpFirst;
	}
	return -1;
}

/*
 *	CTxtPtr::FindOrSkipWhiteSpaces (cchMax, dwFlags, pdwResult)
 *	
 *	@mfunc
 *		Find a whitespace or a non-whitespace character (skip all whitespaces).
 *
 *	@rdesc
 *		Signed number of character this ptr was moved by the operation.
 *		In case of moving backward, the return position was already adjusted forward 
 *		so the caller doesnt need to.
 */
LONG CTxtPtr::FindOrSkipWhiteSpaces (
	LONG 		cchMax, 			//@parm Max signed count of char to search
	DWORD		dwFlags,			//@parm Input flags
	DWORD* 		pdwResult)			//@parm Flag set if found
{
	const WCHAR*	pch;
	CTxtPtr			tp(*this);
	LONG			iDir = cchMax < 0 ? -1 : 1;
	LONG			cpSave = _cp;
	LONG			cchChunk, cch = 0;
	DWORD			dwResult = 0;
	BOOL 			(*pfnIsWhite)(unsigned) = IsWhiteSpace;

	if (dwFlags & FWS_BOUNDTOPARA)
		pfnIsWhite = IsEOP;

	if (cchMax < 0)
		cchMax = -cchMax;

	while (cchMax > 0 && !dwResult)
	{
		pch = iDir > 0 ? tp.GetPch(cch) : tp.GetPchReverse(cch);

		if (!pch)
			break;						// No text available

		if (iDir < 0)
			pch--;						// Going backward, point at previous char

		cch = min(cch, cchMax);
	
		for(cchChunk = cch; cch > 0; cch--, pch += iDir)
		{
			if ((dwFlags & FWS_SKIP) ^ pfnIsWhite(*pch))
			{
				dwResult++;
				break;
			}
		}
		cchChunk -= cch;
		cchMax -= cchChunk;

		tp.Move(iDir * cchChunk);	// advance to next chunk
	}
	
	if (pdwResult)
		*pdwResult = dwResult;

	cch = tp.GetCp() - cpSave;

	if (dwFlags & FWS_MOVE)
		Move(cch);					// Auto advance if requested

	return cch;
}

/*
 *	CTxtPtr::FindWhiteSpaceBound (cchMin, cpStart, cpEnd, dwFlags)
 *	
 *	@mfunc
 *		Figure the smallest boundary that covers cchMin and limited by
 *		whitespaces (included CR/LF). This is how it works.
 *
 *      Text:           xxx  xxx  xxx  xxx  xxx
 *      cp + cchMin:             xxxxx
 *      Boundary:            xxxxxxxxxxxxx
 *
 *	@rdesc
 *		cch of white space characters
 */
LONG CTxtPtr::FindWhiteSpaceBound (
	LONG 		cchMin, 			// @parm Minimum char count to be covered
	LONG& 		cpStart, 			// @parm Boundary start
	LONG& 		cpEnd,				// @parm Boundary end
	DWORD		dwFlags)			// @parm Input flags
{
	CTxtPtr			tp(*this);
	LONG			cch	= tp.GetTextLength();
	LONG			cp	= _cp;

	Assert (cp + cchMin <= cch);

	cpStart = cpEnd	= cp;
	cpEnd	+= max(2, cchMin);			// make sure it covers minimum requirement.
	cpEnd	= min(cpEnd, cch);			// but not too many


	dwFlags &= FWS_BOUNDTOPARA;


	// Figure nearest upper bound
	//
	tp.SetCp(cpEnd);
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_MOVE);					// find a whitespaces
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_MOVE | FWS_SKIP);		// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_MOVE);				// find a whitespace


	// Figure nearest lower bound
	//
	tp.SetCp(cpStart);
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_MOVE);					// find a whitespace
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_MOVE | FWS_SKIP);		// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_MOVE);				// find a whitespace

	Assert (cpStart <= cpEnd && cpEnd - cpStart >= cchMin);
	
	return cpEnd - cpStart;
}


/*
 *	CTxtPtr::FindEOP(cchMax, pResults)
 *	
 *	@mfunc
 *		Find EOP mark in a range within cchMax chars from this text pointer
 *		and position *this after it.  If no EOP is found and cchMax is not
 *		enough to reach the start or end of the story, leave this text ptr
 *		alone and return 0.  If no EOP is found and cchMax is sufficient to
 *		reach the start or end of the story, position this text ptr at the
 *		beginning/end of document (BOD/EOD) for cchMax <lt>/<gt> 0,
 *		respectively, that is, BOD and EOD are treated as a BOP and an EOP,
 *		respectively.	
 *
 *	@rdesc
 *		Return cch this text ptr is moved. Return in *pResults whether a CELL
 *		or EOP was found.  The low byte gives the cch of the EOP if moving
 *		forward (else it's just 1).
 *
 *	@devnote
 *		This function assumes that this text ptr isn't in middle of a CRLF
 *		or CRCRLF (found only in RichEdit 1.0 compatibility mode).  Changing
 *		the for loop could speed up ITextRange MoveUntil/While substantially.
 */
LONG CTxtPtr::FindEOP (
	LONG  cchMax,		//@parm Max signed count of chars to search
	LONG *pResults)		//@parm Flags saying if EOP and CELL are found
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindEOP");

	LONG		cch = 0, cchStart;			// cch's for scans
	unsigned	ch;							// Current char
	LONG		cpSave	= _cp;				// Save _cp for returning delta
	LONG		iDir	= 1;				// Default forward motion
	const WCHAR*pch;						// Used to walk text chunks
	LONG		Results = 0;				// Nothing found yet
	CTxtPtr		tp(*this);					// tp to search text with

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;							// Backward motion
		cchMax = -cchMax;					// Make max count positive
		cch = tp.AdjustCRLF();				// If in middle of CRLF or
		if(!cch && IsAfterEOP())			//  CRCRLF, or follow any EOP,
			cch = tp.BackupCRLF();			//  backup before EOP
		cchMax += cch;
	}

	while(cchMax > 0)						// Scan until get out of search
	{										//  range or match an EOP
		pch = iDir > 0						// Point pch at contiguous text
			? tp.GetPch(cch)				//  chunk going forward or
			: tp.GetPchReverse(cch);		//  going backward

		if(!pch)							// No more text to search
			break;

		if(iDir < 0)						// Going backward, point at
			pch--;							//  previous char

		cch = min(cch, cchMax);				// Limit scan to cchMax chars
		for(cchStart = cch; cch; cch--)		// Scan chunk for EOP
		{
			ch = *pch;
			pch += iDir;
			if(IN_RANGE(CELL, ch, CR) && ch != TAB)
			{								// Note that EOP was found
				if(ch == CELL)
					Results |= FEOP_CELL;
				Results |= FEOP_EOP;
				break;
			}
		}
		cchStart -= cch;					// Get cch of chars passed by
		cchMax -= cchStart;					// Update cchMax

		AssertSz(iDir > 0 && GetCp() + cchStart <= GetTextLength() ||
				 iDir < 0 && GetCp() - cchStart >= 0,
			"CTxtPtr::FindEOP: illegal advance");

		tp.Move(iDir*cchStart);				// Update tp
		if(Results & FEOP_EOP)				// Found an EOP
			break;
	}										// Continue with next chunk

	LONG cp = tp.GetCp();

	if ((Results & FEOP_EOP) || !cp ||		// Found EOP or cp is at story
		cp == GetTextLength())				//  beginning or end
	{										
		SetCp(cp);							// Set _cp = tp._cp
		if(iDir > 0)						// Going forward, put ptr just
			Results = (Results & ~255) | AdvanceCRLF(FALSE);//  after EOP
											//  (going back already there)
	}										
	if(pResults)							// Report whether EOP and CELL
		*pResults = Results;				//  were found

	return _cp - cpSave;					// Return cch this tp moved
}

/*
 *	CTxtPtr::FindBOSentence(cch)
 *	
 *	@mfunc
 *		Find beginning of sentence in a range within cch chars from this text
 *		pointer and	position *this at it.  If no sentence beginning is found,
 *		position *this at beginning of document (BOD) for cch <lt> 0 and
 *		leave *this unchanged for cch >= 0.
 *
 *	@rdesc
 *		Count of chars moved *this moves
 *
 *	@comm 
 *		This routine defines a sentence as a character string that ends with
 *		period followed by at least one whitespace character or the EOD.  This
 *		should be replacable so that other kinds of sentence endings can be
 *		used.  This routine also matches initials like "M. " as sentences.
 *		We could eliminate those by requiring that sentences don't end with
 *		a word consisting of a single capital character.  Similarly, common
 *		abbreviations like "Mr." could be bypassed.  To allow a sentence to
 *		end with these "words", two blanks following a period could be used
 *		to mean an unconditional end of sentence.
 */
LONG CTxtPtr::FindBOSentence (
	LONG cch)			//@parm max signed count of chars to search
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindBOSentence");

	_TEST_INVARIANT_

	LONG	cchWhite = 0;						// No whitespace chars yet
	LONG	cp;
	LONG	cpSave	 = _cp;						// Save value for return
	BOOL	fST;								// TRUE if sent terminator
	LONG	iDir	 = cch > 0 ? 1 : -1;		// Move() increment
	CTxtPtr	tp(*this);							// tp to search with

	if(iDir > 0)								// If going forward in white
		while(IsWhiteSpace(tp.GetChar()) &&		//  space, backup to 1st non
				tp.Move(-1));					//  whitespace char (in case
												//  inside sentence ending)
	while(iDir > 0 || tp.Move(-1))				// Need to back up if finding
	{											//  backward
		for(fST = FALSE; cch; cch -= iDir)		// Find sentence terminator
		{
			fST = IsSentenceTerminator(tp.GetChar());
			if(fST || !tp.Move(iDir))
				break;
		}
		if(!fST)								// If FALSE, we	ran out of
			break;								//  chars

		while(IsWhiteSpace(tp.NextChar()) && cch)
		{										// Bypass a span of blank
			cchWhite++;							//  chars
			cch--;
		}

		if(cchWhite && (cch >= 0 || tp._cp < cpSave))// Matched new sentence
			break;								//  break

		if(cch < 0)								// Searching backward
		{
			tp.Move(-cchWhite - 1);				// Back up to terminator
			cch += cchWhite + 1;				// Fewer chars to search
		}
		cchWhite = 0;							// No whitespace yet for next
	}											//  iteration

	cp = tp._cp;
	if(cchWhite || !cp || cp == GetTextLength())// If sentence found or got
		SetCp(cp);								//  start/end of story, set
												//  _cp to tp's
	return _cp - cpSave;						// Tell caller cch moved
}

/*
 *	CTxtPtr::IsAtBOSentence()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a sentence (BOS) as
 *		defined in the description of the FindBOSentence(cch) routine
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a sentence
 */
BOOL CTxtPtr::IsAtBOSentence()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOSentence");

	if(!_cp)									// Beginning of story is an
		return TRUE;							//  unconditional beginning
												//  of sentence
	unsigned ch = GetChar();

	if (IsWhiteSpace(ch) ||						// Proper sentences don't
		IsSentenceTerminator(ch))				//  start with whitespace or
	{											//  sentence terminators
		return FALSE;
	}
												
	LONG	cchWhite;
	CTxtPtr tp(*this);							// tp to walk preceding chars

	for(cchWhite = 0;							// Backspace over possible
		IsWhiteSpace(ch = tp.PrevChar());		//  span of whitespace chars
		cchWhite++) ;

	return cchWhite && IsSentenceTerminator(ch);
}

/*
 *	CTxtPtr::IsAtBOWord()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a word, that is,
 *		_cp = 0 or the char at _cp is an EOP, or
 *		FindWordBreak(WB_MOVEWORDRIGHT) would break at _cp.
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a Word
 */
BOOL CTxtPtr::IsAtBOWord()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOWord");

	if(!_cp || IsAtEOP())					// Story beginning is also
		return TRUE;						//  a word beginning

	CTxtPtr tp(*this);
	tp.Move(-1);
	tp.FindWordBreak(WB_MOVEWORDRIGHT);
	return _cp == tp._cp;
}

/*
 *	CTxtPtr::FindExact(cchMax, pch)
 *	
 *	@mfunc
 *		Find exact text match for null-terminated string pch in a range
 *		starting at this text pointer. Position this just after matched
 *		string and return cp at start of string, i.e., same as FindText().
 *	
 *	@rdesc
 *		Return cp of first char in matched string and *this pointing at cp
 *		just following matched string.  Return -1 if no match
 *
 *	@comm
 *		Much faster than FindText, but still a simple search, i.e., could
 *		be improved.
 *
 *		FindText can delegate to this search for search strings in which
 *		each char can only match itself.
 */
LONG CTxtPtr::FindExact (
	LONG	cchMax,		//@parm signed max # of chars to search 
	WCHAR *	pch)		//@parm ptr to null-terminated string to find exactly
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindExact");

	_TEST_INVARIANT_

	LONG	cch, cchStart;
	LONG	cchValid;
	LONG	cchText = GetTextLength();
	LONG	cpMatch;
	LONG	iDir = 1;						// Default for forward search
	const WCHAR	*pc;
	CTxtPtr	tp(*this);						// tp to search text with

	if(!*pch)
		return -1;							// Signal null string not found

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;
		cchMax = -cchMax;					// Make count positive
	}

	while(cchMax > 0)
	{
		if(iDir > 0)
		{
			if(tp.GetCp() >= cchText)	// Can't go further
				break;
			pc  = tp.GetPch(cchValid);		// Characters we can search w/o
			cch = cchValid; 				//  encountering block end/gap,
		}									//  i.e., stay within text chunk
		else
		{
			if(!tp.GetCp())					// Can't back up any more
				break;
			tp.Move(-1);
			pc  = tp.GetPchReverse(cchValid);
			cch = cchValid + 1;
		}

		cch = min(cch, cchMax);
		if(!cch || !pc)
			break;							// No more text to search

		for(cchStart = cch;					// Find first char
			cch && *pch != *pc; cch--)		// Most execution time is spent
		{									//  in this loop going forward or
			pc += iDir;						//  backward. x86 rep scasb/scasw
		}									//  are faster

		cchStart -= cch;
		cchMax	 -= cchStart;				// Update cchMax
		tp.Move( iDir*(cchStart));			// Update tp

		if(cch && *pch == *pc)				// Matched first char
		{									// See if matches up to null
			cpMatch = tp.GetCp();			// Save cp of matched first char
			cch = cchMax;
			for(pc = pch;					// Try to match rest of string
				cch && *++pc==tp.NextChar();// Note: this match goes forward
				cch--) ;					//  for both values of iDir
			if(!cch)
				break;						// Not enuf chars for string

			if(!*pc)						// Matched null-terminated string
			{								//  *pch. Set this tp just after
				SetCp(tp.GetCp());			//  matched string and return cp
				return cpMatch;				//  at start
			}
			tp.SetCp(cpMatch + iDir);		// Move to char just following or
		}									//  preceding matched first char
	}										// Up-to-date tp: continue search

	return -1;								// Signal string not found
}

/*
 *	CTxtPtr::NextCharCount(&cch)
 *
 *	@mfunc
 *		Helper function for getting next char and decrementing abs(*pcch)
 *
 *	@rdesc
 *		Next char
 */
WCHAR CTxtPtr::NextCharCount (
	LONG& cch)					//@parm count to use and decrement
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPtr::NextCharCount");

	LONG	iDelta = (cch > 0) ? 1 : -1;

	if(!cch || !Move(iDelta))
		return 0;

	cch -= iDelta;							// Count down or up
	return GetChar();						// Return char at _cp
}

/*
 *	CTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::Zombie");

	_ped = NULL;
	_cp = 0;
	SetToNull();
}

/*
 *	CTxtIStream::CTxtIStream(tp, iDir)
 *
 *	@mfunc
 *		Creates from the textptr, <p tp>, a character input stream with which
 *		to retrieve characters starting from the cp of the <p tp> and proceeding 
 *		in the direction indicated by <p iDir>.
 */
CTxtIStream::CTxtIStream(
	const CTxtPtr &tp,
	int iDir
) : CTxtPtr(tp)
{
	_pfnGetChar = (iDir == DIR_FWD ? 
				   &CTxtIStream::GetNextChar : &CTxtIStream::GetPrevChar);
	_cch = 0;
	_pch = NULL;
}

/*
 * 	CTxtIStream::GetNextChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.
 *
 * 	@rdesc
 *		WCHAR	the next character in the character input stream
 *				0, if end of text stream
 */
WCHAR CTxtIStream::GetNextChar()
{
	if(!_cch)
		FillPchFwd();

	if(_cch)
	{
		_cch--; 
		return *_pch++; 
	} 
	return 0;
}

/*
 * 	CTxtIStream::GetPrevChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream, where the direction of the
 *		stream is reverse.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.  Here, _pch points to the end of a string
 *		containing _cch valid characters.
 *
 * 	@rdesc
 *		WCHAR	the next character in the character input stream (travelling backwards
 *				along the string pointed to by _pch)
 *				0, if end of text stream
 */
WCHAR CTxtIStream::GetPrevChar() 
{
	if(!_cch) 
		FillPchRev();

	if(_cch) 
	{
		_cch--; 
		return *(--_pch); 
	}
	return 0;
}


/*
 *	CTxtIStream::FillPchFwd()
 *
 *	@mfunc
 *		Gets the next run of characters and Moves the cp of this CTxtPtr (base
 *		class) just past the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to
 *		GetNextChar().
 */
void CTxtIStream::FillPchFwd() 
{
	_pch = GetPch(_cch); 
	Move(_cch); 
}

/*
 *	CTxtIStream::FillPchRev()
 *
 *	@mfunc
 *		Gets the run of characters preceding the one previously pointed to by _pch
 * 		and moves the cp of this CTxtPtr (base class) to the beginning of the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to 
 *		GetPrevChar().
 */
void CTxtIStream::FillPchRev()
{
	_pch = GetPchReverse(_cch);
	Move(-_cch);
}

/*
 *	CTxtFinder::FindText(tp, cpLimit, dwFlags, pchToFind, cchToFind, &cpFirst, &cpLast)
 *
 *	@mfunc
 *		Find the text string <p pchToFind> of length <p cchToFind> starting at
 *		this text pointer. If found, <p cpFirst> and <p cpLast> are set to the
 *		cp's of the first and last characters in the matched string (wrt tp).
 *		If not found, return FALSE.
 *	
 *	@rdesc
 *		TRUE	string matched.  First char at tp.GetCp() + cchOffFirst.
 *					Last char at tp.GetCp() + cchOffLast.
 *		FALSE	string not found.
 */
BOOL CTxtPtr::CTxtFinder::FindText (
	const CTxtPtr &tp,
	LONG		cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const WCHAR *pchToFind, //@parm Text to search for
	LONG cchToFind,			//@parm Count of chars to search for
	LONG &cpFirst,			//@parm If string found, returns cp (wrt tp) of first char
	LONG &cpLast)			//@parm If string found, returns cp (wrt tp) of last char 
{
	if(!cchToFind)
		return FALSE;

	_fSearchForward = dwFlags & FR_DOWN;

	// Calculate max number of chars we must search for pchToFind
	if(_fSearchForward)
	{
		const LONG cchText = tp.GetTextLength();
			
		if((DWORD)cpLimit > (DWORD)cchText)		// NB: catches cpLimit < 0 too
			cpLimit = cchText;

		_cchToSearch = cpLimit - tp.GetCp();
	}
	else
	{
		if((DWORD)cpLimit > (DWORD)tp.GetCp())	// NB: catches cpLimit < 0 too
			cpLimit = 0;

		_cchToSearch = tp.GetCp() - cpLimit;   
	}

	if(cchToFind > _cchToSearch)
	{
		// Not enough chars in requested direction within which 
		// to find string
		return FALSE;
	}

	const BOOL fWholeWord = dwFlags & FR_WHOLEWORD;

	_fIgnoreCase	 = !(dwFlags & FR_MATCHCASE);
	_fMatchAlefhamza = dwFlags & FR_MATCHALEFHAMZA;
	_fMatchKashida	 = dwFlags & FR_MATCHKASHIDA;
	_fMatchDiac		 = dwFlags & FR_MATCHDIAC;

	typedef LONG (CTxtPtr::CTxtFinder::*PFNMATCHSTRING)(WCHAR const *pchToFind, 
											LONG cchToFind,
											CTxtIStream &tistr);

	// Setup function pointer appropriate for this type of search
	CTxtEdit*	   ped = tp._ped;
	PFNMATCHSTRING pfnMatchString;

#define MATCHARABICSPECIALS	(FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC)
	// If match all Arabic special characters exactly, then use simpler
	// MatchString routine.  If ignore any and BiDi text exists, use
	// MatchStringBiDi.
	pfnMatchString = (ped->IsBiDi() &&
						(dwFlags & MATCHARABICSPECIALS) != MATCHARABICSPECIALS)
				   ? &CTxtFinder::MatchStringBiDi
				   : &CTxtFinder::MatchString;

	_iDirection = _fSearchForward ? 1 : -1;

	BOOL fFound = FALSE;
	WCHAR chFirst = _fSearchForward ? *pchToFind : pchToFind[cchToFind - 1];
	const WCHAR *pchRemaining = _fSearchForward ? 
		&pchToFind[1] : &pchToFind[cchToFind - 2];
	LONG cchRead;
	LONG cchReadToFirst = 0;
	LONG cchReadToLast;
	CTxtIStream tistr(tp, 
					  _fSearchForward ? CTxtIStream::DIR_FWD : CTxtIStream::DIR_REV);

	while((cchRead = FindChar(chFirst, tistr)) != -1)
	{
		cchReadToFirst += cchRead;

		if(cchToFind == 1)					// Only one char in string - we've matched it!
		{			
			if (_iDirection > 0)			// Searching forward
			{
				Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
				cpLast = cpFirst = tp.GetCp() + cchReadToFirst - 1;
			}
			else							// Searching backward
			{
				Assert(tp.GetCp() - cchReadToFirst >= 0);
				cpLast = cpFirst = tp.GetCp() - cchReadToFirst;
			}
			fFound = TRUE;
		}
		else 
		{
			// Check if this first char begins a match of string
			CTxtIStream tistrT(tistr);
			cchRead = (this->*pfnMatchString)(pchRemaining, cchToFind - 1, tistrT);
			if(cchRead != -1)
			{
				cchReadToLast = cchReadToFirst + cchRead;
			
				if (_iDirection > 0)			// Searching forward
				{					
					Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
					Assert(tp.GetCp() + cchReadToLast - 1 >= 0);

					cpFirst = tp.GetCp() + cchReadToFirst - 1;
					cpLast = tp.GetCp() + cchReadToLast - 1;
				}
				else							// Searching backward
				{					
					Assert(tp.GetCp() - cchReadToFirst >= 0);
					Assert(tp.GetCp() - cchReadToLast >= 0);

					cpFirst = tp.GetCp() - cchReadToFirst;
					cpLast = tp.GetCp() - cchReadToLast;
				}

				fFound = TRUE;
			}
		}
		
		if(fFound)
		{
			Assert(cpLast < tp.GetTextLength());
			
			if(!fWholeWord)
				break;
			
			// Check if matched string is whole word
			
			LONG cchT;
			LONG cpBefore = (_fSearchForward ? cpFirst : cpLast) - 1;
			LONG cpAfter  = (_fSearchForward ? cpLast : cpFirst) + 1;

			if((cpBefore < 0 ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpBefore).GetPch(cchT)),
					   0,
					   sizeof(WCHAR),
					   WB_CLASSIFY, cpBefore) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpBefore + 1))

				&&

			   (cpAfter >= tp.GetTextLength() ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpAfter).GetPch(cchT)),
					   0,
					   sizeof(WCHAR),
					   WB_CLASSIFY, cpAfter) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpAfter)))
			{
				break;
			}
			else
				fFound = FALSE;
		}
	}

	if(fFound && !_fSearchForward)
	{
		// For search backwards, first and last are juxtaposed
		LONG cpTemp = cpFirst;

		cpFirst = cpLast;
		cpLast = cpTemp;
	}
	return fFound;
}

/*
 *	CTxtPtr::CTxtFinder::CharCompMatchCase(ch1, ch2)
 *
 *	@func	Character comparison function sensitive to case according to parms 
 *			of current search.
 *
 *	@rdesc	TRUE iff characters are equal
 */
inline BOOL CTxtPtr::CTxtFinder::CharComp(
	WCHAR ch1,
	WCHAR ch2) const
{
    // We compare the characters ourselves if ignore case AND the character isn't a surrogate
    //
	return (_fIgnoreCase && !IN_RANGE(0xD800, ch1, 0xDFFF)) ? CharCompIgnoreCase(ch1, ch2) : (ch1 == ch2);
}

/*
 *	CTxtPtr::CTxtFinder::CharCompIgnoreCase(ch1, ch2)
 *
 *	@func	Character comparison function
 *
 *	@rdesc	TRUE iff characters are equal, ignoring case
 */
inline BOOL CTxtPtr::CTxtFinder::CharCompIgnoreCase(
	WCHAR ch1,
	WCHAR ch2) const
{
	return CompareString(LOCALE_USER_DEFAULT, 
						 NORM_IGNORECASE | NORM_IGNOREWIDTH,
						 &ch1, 1, &ch2, 1) == 2;
}

/*
 *	CTxtPtr::CTxtFinder::FindChar(ch, tistr)
 *
 *	@mfunc
 *		Steps through the characters returned from <p tistr> until a character is 
 *		found which matches ch or until _cchToSearch characters have been examined.
 *		If found, the return value indicates the number of chars read from <p tistr>.
 *		If not found, -1 is returned.
 *
 *	@rdesc
 *		-1,	if char not found
 * 		n, 	if char found.  n indicates number of chars read from <p tistr> 
 *				to find the char
 */
LONG CTxtPtr::CTxtFinder::FindChar(
	WCHAR ch,
	CTxtIStream &tistr)
{
	LONG cchSave = _cchToSearch;

	while(_cchToSearch)
	{
		_cchToSearch--;

		WCHAR chComp = tistr.GetChar();

		if(CharComp(ch, chComp) ||
		   (!_fMatchAlefhamza && IsAlef(ch) && IsAlef(chComp)))
		{
			return cchSave - _cchToSearch;
		}
	}
	return -1;
}

/*
 *	CTxtPtr::CTxtFinder::MatchString(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr> 
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchString(
	const WCHAR *pchToFind, 
	LONG cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchT = cchToFind;

	while(cchT--)
	{
		if(!CharComp(*pchToFind, tistr.GetChar()))
			return -1;

		pchToFind += _iDirection;
	}
	return cchToFind;
}

/*
 *	CTxtPtr::CTxtFinder::MatchStringBiDi(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *		Kashida, diacritics and Alefs are matched/not matched according
 *		to the type of search requested.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr> 
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchStringBiDi(
	const WCHAR *pchToFind, 
	LONG		 cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchRead = 0;

	while(cchToFind)
	{
		WCHAR chComp = tistr.GetChar();
		cchRead++;

		if(!CharComp(*pchToFind, chComp))
		{
			if (!_fMatchKashida && chComp == KASHIDA ||
				!_fMatchDiac && IsBiDiDiacritic(chComp))
			{
				continue;
			}
			if (!_fMatchAlefhamza &&
				IsAlef(*pchToFind) && IsAlef(chComp))
			{
				// Skip *pchToFind
			}
			else
				return -1;
		}
		pchToFind += _iDirection;
		cchToFind--;
	}
	return cchRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tokens.cpp ===
/*
 *		tokens.cpp
 *
 *		The sorted table of strings and token values
 *
 *		Note: if you insert new keywords, be sure to insert the corresponding
 *		i_keyword in the i_xxx enum in tokens.h.  This enum defines the
 *		indices used by RTFWrit to output RTF control words.
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[] =
{
	{"adeff",			tokenDefaultBiDiFont},
	{"af",				tokenAssocFontSelect},
	{"afs",				tokenAssocFontSize},
	{"animtext",		tokenAnimText},
	{"ansi",			tokenCharSetAnsi},
	{"ansicpg",			tokenAnsiCodePage},
	{"b",				tokenBold},
	{"background",		tokenBackground},
	{"bgbdiag",			tokenBckgrndBckDiag},
	{"bgcross",			tokenBckgrndCross},
	{"bgdcross",		tokenBckgrndDiagCross},
	{"bgdkbdiag",		tokenBckgrndDrkBckDiag},
	{"bgdkcross",		tokenBckgrndDrkCross},
	{"bgdkdcross",		tokenBckgrndDrkDiagCross},
	{"bgdkfdiag",		tokenBckgrndDrkFwdDiag},
	{"bgdkhoriz",		tokenBckgrndDrkHoriz},
	{"bgdkvert",		tokenBckgrndDrkVert},
	{"bgfdiag",			tokenBckgrndFwdDiag},
	{"bghoriz",			tokenBckgrndHoriz},
	{"bgvert",			tokenBckgrndVert},
	{"bin",				tokenBinaryData},
	{"blue",			tokenColorBlue},
	{"box",				tokenBox},
	{"brdrb",			tokenBorderBottom},
	{"brdrbar",			tokenBorderOutside},
	{"brdrbtw",			tokenBorderBetween},
	{"brdrcf",			tokenBorderColor},
	{"brdrdash",		tokenBorderDash},
	{"brdrdashsm",		tokenBorderDashSmall},
	{"brdrdb",			tokenBorderDouble},
	{"brdrdot",			tokenBorderDot},
	{"brdrhair",		tokenBorderHairline},
	{"brdrl",			tokenBorderLeft},
	{"brdrr",			tokenBorderRight},
	{"brdrs",			tokenBorderSingleThick},
	{"brdrsh",			tokenBorderShadow},
	{"brdrt",			tokenBorderTop},
	{"brdrth",			tokenBorderDoubleThick},
	{"brdrtriple",		tokenBorderTriple},
	{"brdrw",			tokenBorderWidth},
	{"brsp",			tokenBorderSpace},
	{"bullet",			BULLET},
	{"caps",			tokenCaps},
	{"cbpat",			tokenColorBckgrndPat},
	{"cell",			tokenCell},
	{"cellx",			tokenCellX},
	{"cf",				tokenColorForeground},
	{"cfpat",			tokenColorForgrndPat},
	{"clbrdrb",			tokenCellBorderBottom},
	{"clbrdrl",			tokenCellBorderLeft},
	{"clbrdrr",			tokenCellBorderRight},
	{"clbrdrt",			tokenCellBorderTop},
	{"clcbpat",			tokenCellBackColor},
	{"clcfpat",			tokenCellForeColor},
	{"clshdng",			tokenCellShading},
	{"cltxlrtb",		tokenCellLRTB},
	{"cltxtbrlv",		tokenCellTopBotRLVert},
	{"clvertalb",		tokenCellAlignBottom},
	{"clvertalc",		tokenCellAlignCenter},
	{"clvmgf",			tokenCellMergeDown},
	{"clvmrg",			tokenCellMergeUp},
	{"collapsed",		tokenCollapsed},
	{"colortbl",		tokenColorTable},
	{"cpg",				tokenCodePage},
	{"cs",				tokenCharStyle},
	{"dbch",			tokenDBChars},
	{"deff",			tokenDefaultFont},
	{"deflang",			tokenDefaultLanguage},
	{"deflangfe",		tokenDefaultLanguageFE},
	{"deftab",			tokenDefaultTabWidth},
	{"deleted",			tokenDeleted},
	{"dibitmap",		tokenPictureWindowsDIB},
	{"disabled",		tokenDisabled},
	{"dn",				tokenDown},
	{"dropcapli",		tokenDropCapLines},
	{"embo",			tokenEmboss},
	//FUTURE (keithcu) I enabled em-dash and did some of the work for em-space and en-space.
	//Remaining is that we should output em-space and en-space via their unicode equivalents
	//as Word doesn't understand more than 1 instance of em-dash in a file it seems. Also, our
	//old measurer doesn't handle whitespace other than 0x20 properly.
	{"emdash",			EMDASH},
	{"emspace",			' '},
	{"endash",			ENDASH},
	{"enspace",			' '},
	{"expndtw",			tokenExpand},
	{"f",				tokenFontSelect},
	{"fbidi",			tokenFontFamilyBidi},
	{"fchars",			tokenFollowingPunct},
	{"fcharset",		tokenCharSet},
	{"fdecor",			tokenFontFamilyDecorative},
	{"fi",				tokenIndentFirst},
	{"field",			tokenField},
	{"fldinst",			tokenFieldInstruction},
	{"fldrslt",			tokenFieldResult},
	{"fmodern",			tokenFontFamilyModern},
	{"fname",			tokenRealFontName},
	{"fnil",			tokenFontFamilyDefault},
	{"fonttbl",			tokenFontTable},
	{"footer",			tokenNullDestination},
	{"footerf",			tokenNullDestination},
	{"footerl",			tokenNullDestination},
	{"footerr",			tokenNullDestination},
	{"footnote",		tokenNullDestination},
	{"fprq",			tokenPitch},
	{"froman",			tokenFontFamilyRoman},
	{"fs",				tokenFontSize},
	{"fscript",			tokenFontFamilyScript},
	{"fswiss",			tokenFontFamilySwiss},
	{"ftech",			tokenFontFamilyTechnical},
	{"ftncn",			tokenNullDestination},
	{"ftnsep",			tokenNullDestination},
	{"ftnsepc",			tokenNullDestination},
	{"green",			tokenColorGreen},
	{"header",			tokenNullDestination},
	{"headerf",			tokenNullDestination},
	{"headerl",			tokenNullDestination},
	{"headerr",			tokenNullDestination},
	{"hich",			tokenHIChars},
	{"highlight",		tokenColorBackground},
	{"horzvert",		tokenHorzInVert},
	{"hyphpar",			tokenHyphPar},
	{"i",				tokenItalic},
	{"impr",			tokenImprint},
	{"info",			tokenDocumentArea},
	{"intbl",			tokenInTable},
	{"itap",			tokenTableLevel},
	{"jpegblip",		tokenJpegBlip},
	{"keep",			tokenKeep},
	{"keepn",			tokenKeepNext},
	{"kerning",			tokenKerning},
	{"lang",			tokenLanguage},
	{"lchars",			tokenLeadingPunct},
	{"ldblquote",		LDBLQUOTE},
	{"li",				tokenIndentLeft},
	{"line",			tokenLineBreak},
	{"lnkd",			tokenLink},
	{"loch",			tokenLOChars},
	{"lquote",			LQUOTE},
	{"ltrch",			tokenLToRChars},
	{"ltrdoc",			tokenLToRDocument},
	{"ltrmark",			LTRMARK},
	{"ltrpar",			tokenLToRPara},
	{"mac",				tokenMac},
	{"macpict",			tokenPictureQuickDraw},
	{"nestcell",		tokenNestCell},
	{"nestrow",			tokenNestRow},
	{"nesttableprops",	tokenNestTableProps},
	{"noline",			tokenNoLineNumber},
	{"nonesttables",	tokenNoNestTables},
	{"nosupersub",		tokenNoSuperSub},
	{"nowidctlpar", 	tokenNoWidCtlPar},  
	{"objattph",		tokenObjectPlaceholder},
	{"objautlink",		tokenObjectAutoLink},
	{"objclass",		tokenObjectClass},
	{"objcropb",		tokenCropBottom},
	{"objcropl",		tokenCropLeft},
	{"objcropr",		tokenCropRight},
	{"objcropt",		tokenCropTop},
	{"objdata",			tokenObjectData},
	{"objebookimage",	tokenObjectEBookImage},
	{"object",			tokenObject},
	{"objemb",			tokenObjectEmbedded},
	{"objh",			tokenHeight},
	{"objicemb",		tokenObjectMacICEmbedder},
	{"objlink",			tokenObjectLink},
	{"objname",			tokenObjectName},
	{"objpub",			tokenObjectMacPublisher},
	{"objscalex",		tokenScaleX},
	{"objscaley",		tokenScaleY},
	{"objsetsize",		tokenObjectSetSize},
	{"objsub",			tokenObjectMacSubscriber},
	{"objw",			tokenWidth},
	{"outl",			tokenOutline},
	{"page",			tokenPage},
	{"pagebb",			tokenPageBreakBefore},
	{"par",				tokenEndParagraph},
	{"pard",			tokenParagraphDefault},
	{"piccropb",		tokenCropBottom},
	{"piccropl",		tokenCropLeft},
	{"piccropr",		tokenCropRight},
	{"piccropt",		tokenCropTop},
	{"pich",			tokenHeight},
	{"pichgoal",		tokenDesiredHeight},
	{"picscalex",		tokenScaleX},
	{"picscaley",		tokenScaleY},
	{"pict",			tokenPicture},
	{"picw",			tokenWidth},
	{"picwgoal",		tokenDesiredWidth},
	{"plain",			tokenCharacterDefault},
	{"pmmetafile",		tokenPictureOS2Metafile},
	{"pn",				tokenParaNum},
	{"pndec",			tokenParaNumDecimal},
	{"pngblip",			tokenPngBlip},
	{"pnindent",		tokenParaNumIndent},
	{"pnlcltr",			tokenParaNumLCLetter},
	{"pnlcrm",			tokenParaNumLCRoman},
	{"pnlvlblt",		tokenParaNumBullet},
	{"pnlvlbody",		tokenParaNumBody},
	{"pnlvlcont",		tokenParaNumCont},
	{"pnqc",			tokenParaNumAlignCenter},
	{"pnqr",			tokenParaNumAlignRight},
	{"pnstart",			tokenParaNumStart},
	{"pntext",			tokenParaNumText},
	{"pntxta",			tokenParaNumAfter},
	{"pntxtb",			tokenParaNumBefore},
	{"pnucltr",			tokenParaNumUCLetter},
	{"pnucrm",			tokenParaNumUCRoman},
	{"posxr",			tokenPositionRight},
	{"protect",			tokenProtect},
	{"pwd",				tokenPocketWord},
	{"qc",				tokenAlignCenter},
	{"qj",				tokenAlignJustify},
	{"ql",				tokenAlignLeft},
	{"qr",				tokenAlignRight},
	{"rdblquote",		RDBLQUOTE},
	{"red",				tokenColorRed},
	{"result",			tokenObjectResult},
	{"revauth",			tokenRevAuthor},
	{"revised",			tokenRevised},
	{"ri",				tokenIndentRight},
	{"row",				tokenRow},
	{"rquote",			RQUOTE},
	{"rtf",				tokenRtf},
	{"rtlch",			tokenRToLChars},
	{"rtldoc",			tokenRToLDocument},
	{"rtlmark",			RTLMARK},
	{"rtlpar",			tokenRToLPara},
	{"rtlrow",			tokenRToLRow},
	{"s",				tokenStyle},
 	{"sa",				tokenSpaceAfter},
	{"sb",				tokenSpaceBefore},
	{"sbys",			tokenSideBySide},
	{"scaps",			tokenSmallCaps},
	{"sect",			tokenEndSection},
	{"sectd",			tokenSectionDefault},
	{"shad",			tokenShadow},
	{"shading",			tokenShading},
	{"shp",				tokenShape},
	{"shpinst",			tokenShapeInstructions},
	{"shpwr",			tokenShapeWrap},
	{"sl",				tokenLineSpacing},
	{"slmult",			tokenLineSpacingRule},
	{"sn",				tokenShapeName},
	{"stextflow",		tokenSTextFlow},
	{"strike",			tokenStrikeOut},
	{"stylesheet",		tokenStyleSheet},
	{"sub",				tokenSubscript},
	{"super",			tokenSuperscript},
	{"sv",				tokenShapeValue},
	{"tab",				9},
	{"tb",				tokenTabBar},
	{"tc",				tokenNullDestination},
	{"tldot",			tokenTabLeaderDots},
	{"tleq",			tokenTabLeaderEqual},
	{"tlhyph",			tokenTabLeaderHyphen},
	{"tlth",			tokenTabLeaderThick},
	{"tlul",			tokenTabLeaderUnderline},
	{"tqc",				tokenCenterTab},
	{"tqdec",			tokenDecimalTab},
	{"tqr",				tokenFlushRightTab},
	{"trbrdrb",			tokenBorderBottom},
	{"trbrdrl",			tokenBorderLeft},
	{"trbrdrr",			tokenBorderRight},
	{"trbrdrt",			tokenBorderTop},
	{"trgaph",			tokenCellHalfGap},
	{"trleft",			tokenRowLeft},
	{"trowd",			tokenRowDefault},
	{"trqc",			tokenRowAlignCenter},
	{"trqr",			tokenRowAlignRight},
	{"trrh",			tokenRowHeight},
	{"tx",				tokenTabPosition},
	{"u",				tokenUnicode},
	{"uc",				tokenUnicodeCharByteCount},
	{"ul",				tokenUnderline},
	{"uld",				tokenUnderlineDotted},
	{"uldash",			tokenUnderlineDash},
	{"uldashd",			tokenUnderlineDashDotted},
	{"uldashdd",		tokenUnderlineDashDotDotted},
	{"uldb",			tokenUnderlineDouble},
	{"ulhair",			tokenUnderlineHairline},
	{"ulhwave",			tokenUnderlineHeavyWave},
	{"ulldash",			tokenUnderlineLongDash},
	{"ulnone",			tokenStopUnderline},
	{"ulth",			tokenUnderlineThick},
	{"ulthd",			tokenUnderlineThickDotted},
	{"ulthdash",		tokenUnderlineThickDash},
	{"ulthdashd",		tokenUnderlineThickDashDot},
	{"ulthdashdd",		tokenUnderlineThickDashDotDot},
	{"ulthldash",		tokenUnderlineThickLongDash},
	{"ululdbwave",		tokenUnderlineDoubleWave},
	{"ulw",				tokenUnderlineWord},
	{"ulwave",			tokenUnderlineWave},
	{"up",				tokenUp},
	{"urtf",			tokenURtf},
	{"v",				tokenHiddenText},
	{"vertdoc",			tokenVerticalRender},
	{"viewkind",		tokenViewKind},
	{"viewscale",		tokenViewScale},
	{"wbitmap",			tokenPictureWindowsBitmap},
	{"wbmbitspixel",	tokenBitmapBitsPerPixel},
	{"wbmplanes",		tokenBitmapNumPlanes},
	{"wbmwidthbytes",	tokenBitmapWidthBytes},
	{"wmetafile",		tokenPictureWindowsMetafile},
	{"xe",				tokenNullDestination},
	{"zwj",				ZWJ},
	{"zwnj",			ZWNJ}
};

INT cKeywords = ARRAY_SIZE(rgKeyword);

extern const KEYWORD rgShapeKeyword[] =
{
	{"fillAngle",		shapeFillAngle},
	{"fillBackColor",	shapeFillBackColor},
	{"fillColor",		shapeFillColor},
	{"fillFocus",		shapeFillFocus},
	{"fillType",		shapeFillType}
};

INT cShapeKeywords = ARRAY_SIZE(rgShapeKeyword);

extern const char *rgszUnrecognizedRTF[] =	// When get one of these, fire
{											//  LoFiRTF notification if enabled
	"abs",
	"aftn",									// Catch \aftnbj, \aftncn, etc.
	"animtext",
	"annotation",
//	"bkmk",									// Catch \bkmkpub, \bkmkstart, etc.
	"cldg",
	"cltx",
	"charscalex",
	"chbg",									// Catch \chbgbdiag, \chbgcross, etc.
	"chcbpat",
	"chcfpat",
	"chshdng",
	"do",
	"dropcap",
	"file",
	"fontemb",
	"formfield",
	"linkself",
	"obj",									// Catch \objxxx not found above
	"pgbrdr",
//	"pic",
	"revtbl",
	"striked",
	"tdfrmt",
	"twoinone"
//	"tp"
//	"tr"
};

INT crgszUnrecognizedRTF = ARRAY_SIZE(rgszUnrecognizedRTF);


extern const BYTE  szSymbolKeywords[] = "*:{}\\_|\r\n-~";

extern const TOKEN tokenSymbol[] =				// Keep in same order as szSymbolKeywords
{
	tokenOptionalDestination,		// *
	tokenIndexSubentry,				// :
	'{',							// {
	'}',							// }
	'\\',							// BSLASH
	NBHYPHEN,						// _ (nonbreaking hyphen)
	tokenFormulaCharacter,			// |
	tokenEndParagraph,				// CR
	tokenEndParagraph,				// LF
	SOFTHYPHEN,						// - (optional hyphen)
	NBSPACE							// ~ (nonbreaking space)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tomfmt.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomfmt.cpp - Implement the CTxtFont and CTxtPara Classes |
 *	
 *		This module contains the implementation of the TOM ITextFont and
 *		ITextPara interfaces
 *
 *	History: <nl>
 *		11/8/95 - MurrayS: created
 *		5/96	- MurrayS: added zombie protection
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_tomfmt.h"
#include "_font.h"

ASSERTDATA

#define tomFloatUndefined	((float)(int)tomUndefined)

// Alignment translation vectors
const BYTE g_rgREtoTOMAlign[] =				// RichEdit to TOM
{
	// TODO: generalize TOM to handle new LineServices options
	tomAlignLeft, tomAlignLeft, tomAlignRight, tomAlignCenter, tomAlignJustify,
	tomAlignInterLetter, tomAlignScaled, tomAlignGlyphs, tomAlignSnapGrid
};

const BYTE g_rgTOMtoREAlign[] =				// TOM to RichEdit
{
	PFA_LEFT, PFA_CENTER, PFA_RIGHT, PFA_FULL_INTERWORD,
	PFA_FULL_INTERLETTER, PFA_FULL_SCALED, PFA_FULL_GLYPHS,
	PFA_SNAP_GRID
};

/*
 *	QueryInterface(riid, riid1, punk, ppv, fZombie)
 *
 *	@func
 *		QueryInterface punk for the ref IDs riid1, IID_IDispatch, and
 *		IID_IUnknown
 *
 *	@rdesc
 *		HRESULT = (!ppv) ? E_INVALIDARG :
 *				  (interface found) ? NOERROR : E_NOINTERFACE
 */
HRESULT QueryInterface (
	REFIID	  riid,		//@parm Reference to requested interface ID
	REFIID	  riid1,	//@parm Query for this, IDispatch, IUnknown
	IUnknown *punk,		//@parm Interface to query
	void **	  ppv,		//@parm Out parm to receive interface ptr
	BOOL	  fZombie)	//@parm If true, return CO_E_RELEASED
{
	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(fZombie)							// Check for range zombie
		return CO_E_RELEASED;

	Assert(punk);

	if( IsEqualIID(riid, IID_IUnknown)   ||
		IsEqualIID(riid, IID_IDispatch)  ||
		IsEqualIID(riid, riid1) )
	{
		*ppv = punk;
		punk->AddRef();
		return NOERROR;
	}
	return E_NOINTERFACE;
}

//------------------------------- CTxtFont -------------------------------------

/*
 *	CTxtFont::CTxtFont(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFont::CTxtFont(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask);		// We assume that object is zeroed (new'd)
}


//------------------------- CTxtFont IUnknown Methods -------------------------------------

/*	CTxtFont::IUnknown methods
 *
 *		See tomDoc.cpp for comments
 */
STDMETHODIMP CTxtFont::QueryInterface (REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::QueryInterface");

	return ::QueryInterface(riid, IID_ITextFont, this, ppv, IsZombie());
}

STDMETHODIMP_(ULONG) CTxtFont::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtFont::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtFont IDispatch Methods -------------------------------------

/*
 *	CTxtFont::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtFont::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtFont::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoFont, ppTypeInfo);
}

/*
 *	CTxtFont::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextFont methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtFont::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;

	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoFont->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}


//--------------------------- ITextFont Methods -------------------------------------

/*
 *	ITextFont::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		font can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::CanChange");

	return CTxtFormat::CanChange(pbCanChange, CharFormat);
}

/*
 *	ITextFont::GetAllCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the AllCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAllCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAllCaps");

	return EffectGetter(pValue, CFM_ALLCAPS);
}

/*
 *	ITextFont::GetAnimation(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the animation type as defined
 *		in the table below.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAnimation (
	long *pValue)		//@parm Out parm to receive animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAnimation");

	return GetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, pValue);
}

/*
 *	ITextFont::GetBackColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the background color.  The
 *		value is a Win32 COLORREF.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBackColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBackColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOBACKCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crBackColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetBold(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the bold state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBold (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBold");

	return EffectGetter(pValue, CFM_BOLD);
}

/*
 *	ITextFont::GetDuplicate(ITextFont **ppFont) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this character
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppFont) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::GetDuplicate (
	ITextFont **ppFont)		//@parm Out parm to receive font clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetDuplicate");

	if(!ppFont)
		return E_INVALIDARG;

	*ppFont = NULL;

	if(IsZombie())
		return CO_E_RELEASED;

	CTxtFont *pFont = new CTxtFont(NULL);
	if(!pFont)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	pFont->_CF		= _CF;
	pFont->_dwMask  = _dwMask;
	*ppFont = pFont;
	return NOERROR;
}

/*
 *	ITextFont::GetEmboss(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the embossed state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEmboss (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEmboss");

	return EffectGetter(pValue, CFM_EMBOSS);
}

/*
 *	ITextFont::GetForeColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the foreground color.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetForeColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetForeColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crTextColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetHidden(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the hidden state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetHidden (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetHidden");

	return EffectGetter(pValue, CFM_HIDDEN);
}

/*
 *	ITextFont::GetEngrave(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the imprint state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEngrave (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEngrave");

	return EffectGetter(pValue, CFM_IMPRINT);
}

/*
 *	ITextFont::GetItalic(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the italic state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetItalic (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetItalic");

	return EffectGetter(pValue, CFM_ITALIC);
}

/*
 *	ITextFont::GetKerning(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		A kerning size of 0 turns off kerning, but an arbitrarily small
 *		value turns it on, e.g., 1.0, which is too small to see, let alone
 *		kern!
 */
STDMETHODIMP CTxtFont::GetKerning (
	float *pValue)		//@parm Out parm to receive minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetKerning");

	return GetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetLanguageID(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the language ID (more
 *		generally LCID).
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetLanguageID (
	long *pValue)		//@parm Out parm to receive LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetLanguageID");

	if (!pValue)
		return E_INVALIDARG;

	if ((*pValue & 0xF0000000) == tomCharset) 
	{
		UpdateFormat();

		// Special case to get CharSet and PitchAndFamily
		*pValue = (_CF._bPitchAndFamily << 8) + CharSetFromCharRep(_CF._iCharRep);
		return NOERROR;
	}
	return GetParameter((long *)&_CF._lcid, CFM_LCID, 4, pValue);
}

/*
 *	ITextFont::GetName(BSTR *pbstr) 
 *
 *	@mfunc
 *		Property get method that gets the font name.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : 
 *				  (can allocate bstr) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::GetName (
	BSTR *pbstr)	//@parm Out parm to receive font name bstr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetName");

	if(!pbstr)
		return E_INVALIDARG;

	*pbstr = NULL;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	if(hr != NOERROR)						// Attached to zombied range
		return hr;

	*pbstr = SysAllocString(GetFontName(_CF._iFont));

	return *pbstr ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextFont::GetOutline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the outline state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetOutline (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetOutline");

	return EffectGetter(pValue, CFM_OUTLINE);
}

/*
 *	ITextFont::GetPosition(float *pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT =  (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetPosition (
	float *pValue)		//@parm Out parm to receive relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetPosition");

	return GetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, (long *)pValue);
}

/*
 *	ITextFont::GetProtected(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the protected state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetProtected (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetProtected");

	return EffectGetter(pValue, CFM_PROTECTED);
}

/*
 *	ITextFont::GetShadow(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the shadow state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetShadow (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetShadow");

	return EffectGetter(pValue, CFM_SHADOW);
}

/*
 *	ITextFont::GetSize(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font size, which is given
 *		in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSize (
	float *pValue)		//@parm Out parm to receive font size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSize");

	return GetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, (long *)pValue);
}

/*
 *	ITextFont::GetSmallCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the SmallCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSmallCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSmallCaps");

	return EffectGetter(pValue, CFM_SMALLCAPS);
}

/*
 *	ITextFont::GetSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSpacing (
	float *pValue)		//@parm Out parm to receive intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSpacing");

	return GetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetStrikeThrough(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the strikeout state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetStrikeThrough (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStrikeThrough");

	return EffectGetter(pValue, CFM_STRIKEOUT);
}

/*
 *	ITextFont::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character style handle for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetStyle (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStyle");

	return GetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, pValue);
}

/*
 *	ITextFont::GetSubscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the subscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSubscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSubscript");

	return EffectGetter(pValue, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::GetSuperscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the superscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSuperscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSuperscript");

	return EffectGetter(pValue, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::GetUnderline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the underline style.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetUnderline (
	long *pValue)		//@parm Out parm to receive underline style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetUnderline");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*pValue = 0;							// Default no underline

	if(!(_dwMask & CFM_UNDERLINE))			// It's a NINCH
		*pValue = tomUndefined;

	else if(_CF._dwEffects & CFM_UNDERLINE)
		*pValue = (LONG)_CF._bUnderlineType ? (LONG)_CF._bUnderlineType : tomTrue;

	return hr;
}

/*
 *	ITextFont::GetWeight(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetWeight (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetWeight");

	return GetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, pValue);
}

/*
 *	ITextFont::IsEqual(ITextFont * pFont, long * pB) 
 *
 *	@mfunc
 *		Method that sets *<p pB> = tomTrue if this text font has the
 *		same properties as *<p pFont>.  For this to be true, *<p pFont> has to
 *		belong to the same TOM engine as the present one. The IsEqual()
 *		method should ignore entries for which either font object has a
 *		tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This implementation assumes that all properties are defined and that
 *		pFont belongs to RichEdit.  It would be nice to generalize this so
 *		that undefined properties are ignored in the comparison and so that
 *		pFont could belong to a different TOM engine.  This would help in
 *		using RichEdit Find dialogs to search for rich text in Word using
 *		TOM.
 */
STDMETHODIMP CTxtFont::IsEqual (
	ITextFont *	pFont,		//@parm ITextFont to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pFont))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _CFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtFont *pF = (CTxtFont *)pFont;
	hr = pF->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	// Ignore differences in CharSet, since TOM thinks all CharSets are Unicode!
	DWORD dwIgnore = (DWORD)(~CFM_CHARSET);

	if(!(_CF._dwEffects & CFE_UNDERLINE))	// If not underlining, ignore
		dwIgnore &= ~CFM_UNDERLINETYPE;		//  differences in underline type

	DWORD dwMask = pF->_dwMask & dwIgnore;

	if((_dwMask ^ dwMask) & dwIgnore)		// The masks have to be the same
		return S_FALSE;						//  for equality

	if(dwMask & _CF.Delta(&(pF->_CF),FALSE))// Any difference?
		return S_FALSE;						// Yes. *pB set equal to tomFalse above

	if(pB)
		*pB = tomTrue;

	return NOERROR;
}			

/*
 *	ITextFont::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the character formatting to the default
 *		values to 1) those defined by the RTF \plain control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Reset");

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_CF = *_prg->GetPed()->GetCharFormat(-1);
			FormatSetter(CFM_ALL2);
		}
		else
			_CF.InitDefault(0);
		_dwMask = CFM_ALL2;
	}
	else if(Value == tomApplyTmp)
	{
		_fApplyLater = 1;
		_fApplyToTmp = 1;

		// Reset all temp. display attribute
		_tmpDisplayAttr.wMask = 0;
		_tmpDisplayAttr.bUnderlineType = 0;
		_tmpDisplayAttr.crTextColor = (DWORD)tomUndefined;
		_tmpDisplayAttr.crBackColor = (DWORD)tomUndefined;
		_tmpDisplayAttr.crUnderlineColor = (DWORD)tomUndefined;
	}
	else if(Value == tomUndefined && !_prg)		// Only applicable
		_dwMask = 0;							//  for clones

	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
		{
			FormatSetter(_dwMask);
			_fApplyToTmp = 0;
		}
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextFont::SetAllCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the AllCaps state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetAllCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAllCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_ALLCAPS);
}

/*
 *	ITextFont::SetAnimation(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the animation type
 *
 *	@rdesc
 *		HRESULT = (Value defined) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtFont::SetAnimation (
	long Value)		//@parm New animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAnimation");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAnimationMax)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, Value);
}

/*
 *	ITextFont::SetBackColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the background color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 *	@devnote
 *		Legal values are tomUndefined, tomAutoColor (both negative) and
 *		in principle any positive values.  Currently wingdi.h only defines
 *		high bytes = 0, 1, 2, 4.  But more values might happen, so we only
 *		rule out negative values other than tomUndefined and tomAutoColor.
 */
STDMETHODIMP CTxtFont::SetBackColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBackColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if (_fApplyToTmp)
	{
		_tmpDisplayAttr.wMask |= APPLY_TMP_BACKCOLOR;
		_tmpDisplayAttr.crBackColor = (COLORREF)Value;
		return NOERROR;
	}

	_CF._dwEffects |= CFE_AUTOBACKCOLOR;		// Default AutoBackColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOBACKCOLOR;	// Turn off AutoBackColor
		_CF._crBackColor = (COLORREF)Value;		// Use new BackColor
	}
	
	return FormatSetter(CFM_BACKCOLOR);
}

/*
 *	ITextFont::SetBold(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the bold state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetBold (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBold");

	return EffectSetter(Value, CFM_BOLD, CFE_BOLD);
}

/*
 *	ITextFont::SetDuplicate(ITextFont *pFont) 
 *
 *	@mfunc
 *		Property put method that sets this text font character
 *		formatting to that given by pFont.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetDuplicate(
	ITextFont *pFont) 		//@parm Font object to apply to this font object
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetDuplicate");

	DWORD		dwMask = 0;
	BSTR		bstr;
	CTxtRange *	prg;
	long		Value;
	float		x;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pFont))			// If pFont belongs to this TOM
	{										//  engine, can cast and copy
		((CTxtFont *)pFont)->UpdateFormat();
		_CF = ((CTxtFont *)pFont)->_CF;
		dwMask = ((CTxtFont *)pFont)->_dwMask;// Use this mask in case this 			
	}										//  font is active
	else
	{										// Need to call pFont for all font
		prg = _prg;							//  properties
		_prg = NULL;						// Be sure it's a clone during
											//  transfer
		pFont->GetStyle(&Value);
		SetStyle(Value);

		pFont->GetAllCaps(&Value);
		SetAllCaps(Value);

		pFont->GetAnimation(&Value);
		SetAnimation(Value);

		pFont->GetBackColor(&Value);
		SetBackColor(Value);

		pFont->GetBold(&Value);
		SetBold(Value);

		pFont->GetEmboss(&Value);
		SetEmboss(Value);

		pFont->GetForeColor(&Value);
		SetForeColor(Value);

		pFont->GetHidden(&Value);
		SetHidden(Value);

		pFont->GetEngrave(&Value);
		SetEngrave(Value);

		pFont->GetItalic(&Value);
		SetItalic(Value);

		pFont->GetKerning(&x);
		SetKerning(x);

		pFont->GetLanguageID(&Value);
		SetLanguageID(Value);

		pFont->GetName(&bstr);
		SetName(bstr);
		SysFreeString(bstr);

		pFont->GetOutline(&Value);
		SetOutline(Value);

		pFont->GetPosition(&x);
		SetPosition(x);

		pFont->GetProtected(&Value);
		SetProtected(Value);

		pFont->GetShadow(&Value);
		SetShadow(Value);

		pFont->GetSize(&x);
		SetSize(x);

		pFont->GetSmallCaps(&Value);
		SetSmallCaps(Value);

		pFont->GetSpacing(&x);
		SetSpacing(x);

		pFont->GetStrikeThrough(&Value);
		SetStrikeThrough(Value);

		pFont->GetSubscript(&Value);
		SetSubscript(Value);

		pFont->GetSuperscript(&Value);
		SetSuperscript(Value);

		pFont->GetUnderline(&Value);
		SetUnderline(Value);

		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextFont::SetEmboss(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the embossed state according
 *		to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEmboss (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEmboss");

	return EffectSetter(Value, CFM_EMBOSS, CFE_EMBOSS);
}

/*
 *	ITextFont::SetForeColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the foreground color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetForeColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetForeColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if (_fApplyToTmp)
	{
		_tmpDisplayAttr.wMask |= APPLY_TMP_FORECOLOR;
		_tmpDisplayAttr.crTextColor = (COLORREF)Value;
		return NOERROR;
	}

	_CF._dwEffects |= CFE_AUTOCOLOR;			// Default AutoColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOCOLOR;		// Turn off AutoColor
		_CF._crTextColor = (COLORREF)Value;		// Use new TextColor
	}
	
	return FormatSetter(CFM_COLOR);
}

/*
 *	ITextFont::SetHidden(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the hidden state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetHidden (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetHidden");

	return EffectSetter(Value, CFM_HIDDEN, CFE_HIDDEN);
}

/*
 *	ITextFont::SetEngrave(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the imprint state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEngrave (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEngrave");

	return EffectSetter(Value, CFM_IMPRINT, CFE_IMPRINT);
}

/*
 *	ITextFont::SetItalic(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the italic state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetItalic (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetItalic");

	return EffectSetter(Value, CFM_ITALIC, CFE_ITALIC);
}

/*
 *	ITextFont::SetKerning(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetKerning (
	float Value)		//@parm New value of minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetKerning");

	return SetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetLanguageID(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the language ID (more
 *		generally LCID) according to the value given by Value.  See
 *		GetLanguageID() for more information.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetLanguageID (
	long Value)		//@parm New LCID to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetLanguageID");

	if ((Value & 0xF0000000) == tomCharset) 
	{
		// Sepcial case to set charset and pitchandfamily
		_CF._iCharRep = CharRepFromCharSet(Value);
		_CF._bPitchAndFamily = (BYTE)(Value >> 8);
		return FormatSetter(CFM_CHARSET);
	}
	return SetParameter((long *)&_CF._lcid, CFM_LCID, 4, Value);
}

/*
 *	ITextFont::SetName(BSTR Name) 
 *
 *	@mfunc
 *		Property put method that sets the font name to Name.
 *
 *	@rdesc
 *		HRESULT = (Name too long) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetName(
	BSTR Name)		//@parm New font name
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetName");

	LONG cch = SysStringLen(Name);

	if(cch > LF_FACESIZE)
		return E_INVALIDARG;

	if(!cch)									// NINCH
		return NOERROR;

	_CF._iFont = GetFontNameIndex(Name);
	_CF._iCharRep = GetFirstAvailCharRep(GetFontSignatureFromFace(_CF._iFont));

	return FormatSetter(CFM_FACE + CFM_CHARSET);
}

/*
 *	ITextFont::SetOutline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the outline state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetOutline (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetOutline");

	return EffectSetter(Value, CFM_OUTLINE, CFE_OUTLINE);
}

/*
 *	ITextFont::SetPosition(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetPosition (
	float Value)		//@parm New value of relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetPosition");

	return SetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetProtected(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the protected state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::SetProtected (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetProtected");

	return EffectSetter(Value, CFM_PROTECTED, CFE_PROTECTED);
}

/*
 *	ITextFont::SetShadow(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the shadow state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetShadow (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetShadow");

	return EffectSetter(Value, CFM_SHADOW, CFE_SHADOW);
}

/*
 *	ITextFont::SetSize(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the font size = Value (in
 *		floating-point points).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSize (
	float Value)		//@parm New font size to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSize");

	return SetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetSmallCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the SmallCaps state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSmallCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSmallCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_SMALLCAPS);
}

/*
 *	ITextFont::SetSpacing(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSpacing (
	float Value)		//@parm New value of intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSpacing");

	return SetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetStrikeThrough(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the StrikeThrough state
 *		according to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStrikeThrough (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStrikeThrough");

	return EffectSetter(Value, CFM_STRIKEOUT, CFE_STRIKEOUT);
}

/*
 *	ITextFont::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the character style handle for
 *		the characters in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStyle (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStyle");

	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, Value);
}

/*
 *	ITextFont::SetSubscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the subscript state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSubscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSubscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::SetSuperscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the superscript state
 *		according to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSuperscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSuperscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::SetUnderline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the underline style according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetUnderline (
	long Value)		//@parm New value of underline type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetUnderline");

	if (_fApplyToTmp)
	{
		if (Value == tomAutoColor)
			_tmpDisplayAttr.crUnderlineColor = (DWORD)tomAutoColor;
		else if ((((DWORD)Value) & 0x0FF000000) == 0x0FF000000)
			_tmpDisplayAttr.crUnderlineColor = ((DWORD)Value) & 0x000FFFFFF;	// Set UL color
		else
			_tmpDisplayAttr.bUnderlineType = (BYTE)(Value & 0x1F);				// Set UL style

		return NOERROR;
	}

	_CF._bUnderlineType = 0;					// Default no underline type
	if(Value < 0)								// tomTrue, tomUndefined, or
		return EffectSetter(Value, CFM_UNDERLINETYPE | CFM_UNDERLINE, CFE_UNDERLINE);

	if(Value > 0x0FFFF)							// Illegal underline type
		return E_INVALIDARG;

	_CF._bUnderlineType = (BYTE)(Value & 0x1F);
	_CF._bUnderlineColor = (BYTE)(Value/256);
	_CF._dwEffects &= ~CFM_UNDERLINE;			// Default underlining is off
	if(Value)
		_CF._dwEffects |= CFM_UNDERLINE;		// It's on
	
	return FormatSetter(CFM_UNDERLINETYPE + CFM_UNDERLINE);
}

/*
 *	ITextFont::SetWeight(long Value)
 *
 *	@mfunc
 *		Property put method that sets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetWeight (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetWeight");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((unsigned)Value > 900)					// Valid values satisfy:
		return E_INVALIDARG;					//  0 <= Value <= 900

	return SetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, Value);
}


//------------------------------- CTxtPara ------------------------------------

/*
 *	CTxtPara::CTxtPara(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtPara::CTxtPara(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask && !_PF._dwBorderColor); // We assume that object is zeroed (new'd)
	_PF._iTabs = -1;
}

/*
 *	CTxtPara::~CTxtPara()
 *
 *	@mfunc
 *		Destructor
 */
CTxtPara::~CTxtPara()
{
	Assert(_PF._iTabs == -1);
}


//------------------------- CTxtPara IUnknown Methods -------------------------------------

/*	CTxtPara::IUnknown methods
 *
 *		See tomdoc.cpp for comments
 */
STDMETHODIMP CTxtPara::QueryInterface (REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::QueryInterface");

	return ::QueryInterface(riid, IID_ITextPara, this, ppv, IsZombie());
}

STDMETHODIMP_(ULONG) CTxtPara::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtPara::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtPara IDispatch Methods -------------------------------------

/*
 *	CTxtPara::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtPara::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtPara::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoPara, ppTypeInfo);
}

/*
 *	CTxtPara::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextPara methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtPara::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoPara->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}

//------------------------ CTxtPara ITextPara Methods -------------------------------------

/*
 *	ITextPara::AddTab(float tbPos, long tbAlign, long tbLeader) 
 *
 *	@mfunc
 *		Method that adds a tab at the displacement tbPos, with type
 *		tbAlign, and leader style tbLeader.  The displacement is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::AddTab (
	float	tbPos,			//@parm New tab displacement
	long	tbAlign,		//@parm New tab type
	long	tbLeader)		//@parm New tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	//This doesn't seem correct because it doesn't ever look at whether or not
	//we are in a table.
	hr = _PF.AddTab(FPPTS_TO_TWIPS(tbPos), tbAlign, tbLeader, &_rgxTabs[0]);
	if(hr != NOERROR)
		return hr;

	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		paragraph formatting can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::CanChange");

	return CTxtFormat::CanChange(pbCanChange, ParaFormat);
}

/*
 *	ITextPara::ClearAllTabs() 
 *
 *	@mfunc
 *		Method that clears all tabs, reverting to equally spaced
 *		tabs with the default tab spacing.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::ClearAllTabs() 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::ClearAllTabs");

	_PF._bTabCount = 0;						// Signal to use default tab
	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::DeleteTab(tbPos) 
 *
 *	@mfunc
 *		Delete any tab at the displacement tbPos.  This displacement is
 *		given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::DeleteTab (
	float tbPos)		//@parm Displacement at which tab should be deleted
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::DeleteTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	hr = _PF.DeleteTab(FPPTS_TO_TWIPS(tbPos), &_rgxTabs[0]);
	return hr != NOERROR ? hr : FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::GetAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the current paragraph
 *		alignment value
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetAlignment (
	long *pValue)		//@parm Out parm to receive paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetAlignment");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(_PF._bAlignment > ARRAY_SIZE(g_rgREtoTOMAlign))	// Fix bogus value since
		_PF._bAlignment = 0;				//  array lookup can't use it

	*pValue = (_dwMask & PFM_ALIGNMENT)
			? (LONG)g_rgREtoTOMAlign[_PF._bAlignment] : tomUndefined;

	return hr;
}

/*
 *	ITextPara::GetHyphenation(long *pValue)
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress hyphenation for the paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetHyphenation (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetHyphenation");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = EffectGetter(pValue, PFM_DONOTHYPHEN);

	//Oh well, Word inverted meaning after we shipped...
	if(*pValue == tomTrue)
		*pValue = tomFalse;

	else if(*pValue == tomFalse)
		*pValue = tomTrue;

	return hr;
}

/*
 *	ITextPara::GetDuplicate(ITextPara **ppPara) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this text paragraph
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetDuplicate (
	ITextPara **ppPara)		//@parm Out parm to receive ITextPara clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetDuplicate");

	if(!ppPara)
		return E_INVALIDARG;

	*ppPara = NULL;

	if(IsZombie())
		return CO_E_RELEASED;
				
	CTxtPara *pPara = new CTxtPara(NULL);	// NULL creates a clone
	if(!pPara)								//  (its _prg is NULL)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	*pPara  = *this;						// Copy value of this object
	pPara->_prg = NULL;						// It's not attached to a rg
	*ppPara = pPara;						// Return ptr to clone
	return NOERROR;
}

/*
 *	ITextPara::GetFirstLineIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		first line of a paragraph relative to the left indent, which is used
 *		for subsequent lines.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetFirstLineIndent (
	float *pValue)		//@parm Out parm to receive first-line indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetFirstLineIndent");

	HRESULT hr = GetParameter(&_PF._dxOffset, PFM_OFFSET, -4, (long *)pValue);
	if(hr == NOERROR && *pValue != tomFloatUndefined)
		*pValue = -*pValue;						// Defined as negative of
	return hr;									//  RichEdit dxOffset
}

/*
 *	ITextPara::GetKeepTogether(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepTogether (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepTogether");

	return EffectGetter(pValue, PFM_KEEP);
}

/*
 *	ITextPara::GetKeepWithNext(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the paragraphs in this range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepWithNext (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepWithNext");

	return EffectGetter(pValue, PFM_KEEPNEXT);
}

#define	PFM_LEFTINDENT (PFM_STARTINDENT + PFM_OFFSET)

/*
 *	ITextPara::GetLeftIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent all
 *		but the first line of a paragraph.  The amount is given in
 *		floating-point points and is relative to the left margin.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		For the TOM left indent to be defined, both the RichEdit start
 *		indent and the offset must be defined (see XOR and AND in *pValue
 *		code).
 */
STDMETHODIMP CTxtPara::GetLeftIndent (
	float *pValue)		//@parm Out parm to receive left indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLeftIndent");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*pValue = ((_dwMask ^ PFM_LEFTINDENT) & PFM_LEFTINDENT)
			? tomFloatUndefined
			: TWIPS_TO_FPPTS(_PF._dxStartIndent + _PF._dxOffset);

	return hr;
}

/*
 *	ITextPara::GetLineSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line spacing value, which
 *		is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacing (
	float *pValue)		//@parm Out parm to receive line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacing");

	return GetParameter(&_PF._dyLineSpacing, PFM_LINESPACING, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetLineSpacingRule(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line-spacing rule for this range
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacingRule (
	long *pValue)		//@parm Out parm to receive line spacing rule
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacingRule");

	return GetParameter((long *)&_PF._bLineSpacingRule, PFM_LINESPACING,
						1, pValue);
}

/*
 *	ITextPara::GetListAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the kind of bullet/numbering text
 *		alignment to use with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListAlignment(
	long * pValue)		//@parm Out parm to receive numbering alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListAlignment");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR && *pValue != tomUndefined)
		*pValue &= 3;						// Kill all but alignment bits

	return hr;
}

/*
 *	ITextPara::GetListLevelIndex(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the list level index to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListLevelIndex(
	long * pValue)		//@parm Out parm to receive list level index
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListLevelIndex");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR)
		*pValue = (*pValue >> 4) & 0xf;		// Kill all but list level index
	return hr;
}

/*
 *	ITextPara::GetListStart(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the numbering start value to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListStart(
	long * pValue)			//@parm Out parm to receive numbering start value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListSpace");

	return GetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART, 2,
						pValue);
}

/*
 *	ITextPara::GetListTab(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListTab(
	float * pValue)			//@parm Out parm to receive list tab to text
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListTab");

	return GetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB, -2,
						(long *)pValue);
}

/*
 *	ITextPara::GetListType(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the type of list to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		TOM's values are:
 *
 *		List Type			  Value		Meaning
 *		tomNoList				0		Turn off paragraph numbering
 *		tomListBullet			1		default is bullet
 *		tomListNumberAsArabic	2		0, 1, 2, ...
 *		tomListNumberAsLCLetter	3		a, b, c, ...
 *		tomListNumberAsUCLetter	4		A, B, C, ...
 *		tomListNumberAsLCRoman	5		i, ii, iii, ...
 *		tomListNumberAsUCRoman	6		I, II, III, ...
 *		tomListNumberAsSequence	7		ListStart is 1st Unicode to use
 *
 *		Nibble 2 of _PF._wNumberingStyle says whether to number with trailing
 *		parenthesis, both parentheses, follow by period, or leave plain. This
 *		This nibble needs to be returned in nibble 4 of *pValue.
 *		The high bit (PFNS_NEWNUMBER) also needs to be returned.
 */
STDMETHODIMP CTxtPara::GetListType (
	long *pValue)		//@parm Out parm to receive type of list
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListType");

	HRESULT hr = GetParameter((long *)&_PF._wNumbering,
								PFM_NUMBERING, 2, pValue);

	// OR in Number style bits (see note above)
	if(hr == NOERROR && *pValue != tomUndefined) 
		*pValue |= (_PF._wNumberingStyle << 8) & 0x8F0000;
	return hr;
}

/*
 *	ITextPara::GetNoLineNumber(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress line numbering for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetNoLineNumber (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetNoLineNumber");

	return EffectGetter(pValue, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::GetPageBreakBefore(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		eject the page before the paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetPageBreakBefore (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetPageBreakBefore");

	return EffectGetter(pValue, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::GetRightIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		right margin of a paragraph relative to the right margin.  The
 *		amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetRightIndent (
	float *pValue)		//@parm Out parm to receive right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetRightIndent");

	return GetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceAfter(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		after a paragraph.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceAfter (
	float *pValue)		//@parm Out parm to receive space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceAfter");

	return GetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceBefore(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		before starting a paragraph.  The amount is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceBefore (
	float *pValue)		//@parm Out parm to receive space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceBefore");

	return GetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the style handle for the
 *		paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetStyle (
	long *	pValue)		//@parm Out parm to receive paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetStyle");

	return GetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, pValue);
}

/*
 *	ITextPara::GetTab(long iTab, float *ptbPos, long *ptAlign, long *ptbLeader) 
 *
 *	@mfunc
 *		Method that gets tab parameters for the iTab th tab, that
 *		is, set *ptbPos, *ptbAlign, and *ptbLeader equal to the iTab th
 *		tab's displacement, alignment, and leader style, respectively. 
 *		iTab has special values defined in the table below.  The
 *		displacement is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pdxptab || !ptbt || !pstyle || no iTab tab) ?
 *				  E_INVALIDARG : (exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetTab (
	long	iTab,			//@parm Index of tab to retrieve info for
	float *	ptbPos,			//@parm Out parm to receive tab displacement
	long *	ptbAlign,		//@parm Out parm to receive tab type
	long *	ptbLeader)		//@parm Out parm to receive tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTab");

	if(!ptbPos || !ptbAlign || !ptbLeader)
		return E_INVALIDARG;

	*ptbAlign = *ptbLeader = 0;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(!(_dwMask & PFM_TABSTOPS))			// Tabs are undefined (more than
	{										//  one set of definitions)
		*ptbPos = tomFloatUndefined;
		return hr;
	}

	LONG dxTab = 0;							// Default 0 in case GetTab fails

	if(iTab < 0 && iTab >= tomTabBack)		// Save *ptbPos if it's supposed
		dxTab = FPPTS_TO_TWIPS(*ptbPos);	//  be used (in general might get
											//  floating-point error)
	hr = _PF.GetTab(iTab, &dxTab, ptbAlign, ptbLeader, &_rgxTabs[0]);
	*ptbPos = TWIPS_TO_FPPTS(dxTab);

	return (hr == NOERROR && !dxTab) ? S_FALSE : hr;
}

/*
 *	ITextPara::GetTabCount(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tab count.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetTabCount (
	long *	pValue)		//@parm Out parm to receive tab count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTabCount");

	return GetParameter((long *)&_PF._bTabCount, PFM_TABSTOPS, 1, pValue);
}

/*
 *	ITextPara::GetWidowControl(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		control widows and orphans for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetWidowControl (
	long *	pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetWidowControl");

	return EffectGetter(pValue, PFM_NOWIDOWCONTROL);
}

/*
 *	ITextPara::IsEqual(ITextPara * pPara, long * pB) 
 *
 *	@mfunc
 *		Method that sets pB = tomTrue if this range has the same
 *		properties as *pPara. The IsEqual() method ignores entries for which
 *		either para object has a tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::IsEqual (
	ITextPara *	pPara,		//@parm ITextPara to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pPara))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _PFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtPara *pP = (CTxtPara *)pPara;
	hr = pP->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	CParaFormat *pPF = &(pP->_PF); 
	DWORD		 dwMask = pP->_dwMask;		// Save mask

	if(_dwMask != dwMask)					// The two have to be the same
		return S_FALSE;						//  for equality

	if((dwMask & PFM_TABSTOPS) && _PF._bTabCount)
	{
		_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);
		if(pP != this)						// If comparing to self,
		{									//  don't AddRef twice
			pP->_PF._iTabs = GetTabsCache()->Cache(&pP->_rgxTabs[0],
												   pPF->_bTabCount);
		}
	}
	if(dwMask & _PF.Delta(pPF, FALSE))		// Any difference?
		hr = S_FALSE;						// Yes. *pB set equal to tomFalse above
	else if(pB)
		*pB = tomTrue;

	CheckTabsAddRef();
	pP->CheckTabsAddRef();

	return hr;
}

/*
 *	ITextPara::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the paragraph formatting to the default
 *		values to 1) those defined by the RTF \pard control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined). 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Reset");

	Assert(tomApplyLater == tomApplyNow + 1);

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_PF = *_prg->GetPed()->GetParaFormat(-1);
			if(_PF._iTabs != -1)
			{
				const LONG *prgxTabs = _PF.GetTabs();
				_PF._iTabs = -1;
				for(LONG i = 0; i < _PF._bTabCount; i++)
					_rgxTabs[i] = prgxTabs[i];
			}
			FormatSetter(PFM_ALL2);
		}
		else
			_PF.InitDefault(0);
		_dwMask = PFM_ALL2;
	}
	else if(Value == tomUndefined && 			// Only applicable for clones
		(!_prg || _fApplyLater))				//  or delayed application
	{
		_dwMask = 0;							
	}
	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
			FormatSetter(_dwMask);
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextPara::SetAlignment(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the paragraph alignment to Value
 *
 *	@rdesc
 *		HRESULT = (Value > 3) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetAlignment (
	long Value)		//@parm New paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetAlignment");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((DWORD)Value >= ARRAY_SIZE(g_rgTOMtoREAlign))
		return E_INVALIDARG;

	_PF._bAlignment = g_rgTOMtoREAlign[Value];
	
	return FormatSetter(PFM_ALIGNMENT);
}

/*
 *	ITextPara::SetHyphenation(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of hyphenation for the paragraphs in the range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetHyphenation (
	long Value)		//@parm New tomBool for suppressing hyphenation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetHyphenation");

	if(Value == tomTrue)			// Invert meaning for RichEdit
		Value = tomFalse;			// Word inverted it late in the game...

	else if (Value == tomFalse)
		Value = tomTrue;

	return EffectSetter(Value, PFM_DONOTHYPHEN);
}

/*
 *	ITextPara::SetDuplicate(ITextPara *pPara) 
 *
 *	@mfunc
 *		Property put method that applies the paragraph formatting of pPara
 *		to this para object.  Note that tomUndefined values in pPara have
 *		no effect (NINCH - NoInputNoCHange).
 *
 *	@rdesc
 *		HRESULT = (!pPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR :
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetDuplicate (
	ITextPara *pPara)		//@parm New paragraph formatting
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetDuplicate");

	DWORD		dwMask = 0;
	long		iTab;
	CTxtRange *	prg;
	long		tbAlign;
	long		tbLeader;
	float		tbPos;
	long		Value;
	float		x, y, z;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pPara))			// If pPara belongs to this TOM
	{										//  engine, cast and copy
		((CTxtPara *)pPara)->UpdateFormat();// Since this TOM engine, can
		_PF = ((CTxtPara *)pPara)->_PF;		//  cast to a CTxtPara
		dwMask = ((CTxtPara *)pPara)->_dwMask;// Use this mask in case this 			
	}										//  para is active
	else
	{										// Need to call pFont for all para
		prg = _prg;							//  properties
		_prg = NULL;						// Turn into clone during transfer

		pPara->GetStyle(&Value);
		SetStyle(Value);

		pPara->GetAlignment(&Value);
		SetAlignment(Value);

		pPara->GetHyphenation(&Value);
		SetHyphenation(Value);

		pPara->GetKeepTogether(&Value);
		SetKeepTogether(Value);

		pPara->GetKeepWithNext(&Value);
		SetKeepWithNext(Value);

		pPara->GetFirstLineIndent(&x);
		pPara->GetLeftIndent (&y);
		pPara->GetRightIndent(&z);
		SetIndents(x, y, z);

		pPara->GetLineSpacingRule(&Value);
		pPara->GetLineSpacing(&y);
		SetLineSpacing(Value, y);

		pPara->GetNoLineNumber(&Value);
		SetNoLineNumber(Value);

		pPara->GetListAlignment(&Value);
		SetListAlignment(Value);

		pPara->GetListLevelIndex(&Value);
		SetListLevelIndex(Value);

		pPara->GetListStart(&Value);
		SetListStart(Value);

		pPara->GetListTab(&x);
		SetListTab(x);

		pPara->GetListType(&Value);
		SetListType(Value);

		pPara->GetPageBreakBefore(&Value);
		SetPageBreakBefore(Value);

		pPara->GetSpaceBefore(&y);
		SetSpaceBefore(y);

		pPara->GetSpaceAfter(&y);
		SetSpaceAfter(y);

		pPara->GetWidowControl(&Value);
		SetWidowControl(Value);

		ClearAllTabs();
		pPara->GetTabCount(&Value);
		for(iTab = 0; iTab < Value; iTab++)
		{
			pPara->GetTab(iTab, &tbPos, &tbAlign, &tbLeader);
			AddTab(tbPos, tbAlign, tbLeader);
		}
		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextPara::SetKeepTogether(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepTogether (
	long Value)		//@parm New tomBool for keeping lines together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepTogether");

	return EffectSetter(Value, PFM_KEEP);
}

/*
 *	ITextPara::SetKeepWithNext(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the paragraphs in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepWithNext (
	long Value)		//@parm New tomBool for keeping paragraphs together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepWithNext");

	return EffectSetter(Value, PFM_KEEPNEXT);
}

/*
 *	ITextPara::SetIndents(float First, float Left, float Right) 
 *
 *	@mfunc
 *		Method that sets the left indent of all but the first line
 *		of a paragraph equal to Left and sets the displacement of the first
 *		line of a paragraph relative to the left indent equal to First.  The
 *		left indent value is relative to the left margin. You can also set
 *		the right indent by giving the optional Right parameter a value (the
 *		(default is tomUndefined).  All indents are given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_INVALIDARG
 */
STDMETHODIMP CTxtPara::SetIndents (
	float First,	//@parm New first indent (1st-line offset relative to left indent)
	float Left,		//@parm New left indent (left offset of all but 1st line)
	float Right)	//@parm New right indent (right offset of all lines)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetIndents");

	DWORD	dwMask	= 0;
	LONG	j = (First != tomFloatUndefined) + (Left == tomFloatUndefined);

	if(IsZombie())
		return CO_E_RELEASED;

	if(j < 2)										// At least First or Left
	{												//  defined
		if(j == 1)									// Only one defined: need
			UpdateFormat();							//  current _PF._dxOffset

		if(First != tomFloatUndefined)
		{
			j = FPPTS_TO_TWIPS(First);				
	 		if(Left == tomFloatUndefined)			
			{
				_PF._dxStartIndent += _PF._dxOffset	// Cancel current offset
					+ j;							//  and add in new one
			}
			_PF._dxOffset = -j;						// Offset for all but 1st
			dwMask = PFM_OFFSET + PFM_STARTINDENT;	//  line
		} 
 		if(Left != tomFloatUndefined)
		{
			_PF._dxStartIndent =  FPPTS_TO_TWIPS(Left) - _PF._dxOffset;
			dwMask |= PFM_STARTINDENT;
		}
	}

	if(Right != tomFloatUndefined)
	{
		_PF._dxRightIndent = FPPTS_TO_TWIPS(Right);
		dwMask |= PFM_RIGHTINDENT;
	}

	return dwMask ? FormatSetter(dwMask) : NOERROR;
}

/*
 *	ITextPara::SetLineSpacing(long Rule, float Spacing) 
 *
 *	@mfunc
 *		Method that sets the paragraph line spacing rule to Rule and
 *		the line spacing to Spacing. If the line spacing rule treats the
 *		Spacing value as a linear dimension, then that dimension is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetLineSpacing (
	long	Rule,		//@parm Value of new line-spacing rule
	float	Spacing)	//@parm Value of new line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetLineSpacing");

 	LONG j = (Rule == tomUndefined) + (Spacing == tomFloatUndefined);

	if(j == 2)
		return NOERROR;

	if(j == 1 || (DWORD)Rule > 5 || Spacing < 0)
		return E_INVALIDARG;

	_PF._bLineSpacingRule = (BYTE)Rule;			// Default as if both are OK
	_PF._dyLineSpacing	 = (SHORT)FPPTS_TO_TWIPS(Spacing);

	return FormatSetter(PFM_LINESPACING);
}

/*
 *	ITextPara::SetListAlignment (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List alignment to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListAlignment(
	long Value)		//@parm Value of new list alignment
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAlignRight)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~3) | (Value & 3));
}

/*
 *	ITextPara::SetListLevelIndex (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of list level index to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListLevelIndex(
	long Value)
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 15)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~0xf0) | (Value << 4));
}

/*
 *	ITextPara::SetListStart (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the starting number to use for
 *		paragraph numbering
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListStart(
	long Value)		//@parm New numbering start value
{
	if(Value == tomUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART,
						2, Value);
}

/*
 *	ITextPara::SetListTab (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListTab(
	float Value)		//@parm New numbering tab value
{
	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB,
						-2, *(long *)&Value);
}

/*
 *	ITextPara::SetListType (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListType (
	long Value)		//@parm New List code
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetListType");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 0xf0000)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	_PF._wNumbering		= (WORD)Value;
	_PF._wNumberingStyle = (WORD)((Style & ~0x8F00) | ((Value >> 8) & 0x8F00));

	return FormatSetter(PFM_NUMBERING | PFM_NUMBERINGSTYLE);
}

/*
 *	ITextPara::SetNoLineNumber (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to suppress the numbering of paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetNoLineNumber (
	long Value)		//@parm New tomBool for suppressing line numbering
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetNoLineNumber");

	return EffectSetter(Value, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::SetPageBreakBefore (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to eject the page before each paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetPageBreakBefore (
	long Value)		//@parm New tomBool for ejecting page before paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetPageBreakBefore");

	return EffectSetter(Value, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::SetRightIndent (float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to indent the right
 *		margin of paragraph equal to Value, which is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetRightIndent (
	float Value)		//@parm New right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetRightIndent");

	return SetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceAfter(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		after finishing a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceAfter (
	float Value)		//@parm New space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceAfter");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceBefore(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		before starting a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceBefore (
	float Value)		//@parm New space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceBefore");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the paragraph style handle for
 *		the paragraphs in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetStyle (
	long Value)		//@parm New paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetStyle");

 	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, Value);
}

/*
 *	ITextPara::SetWidowControl(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of widows and orphans.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetWidowControl (
	long Value)		//@parm New tomBool for suppressing widows and orphans
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetWidowControl");

	return EffectSetter(Value, PFM_NOWIDOWCONTROL);
}


//----------------------------- CTxtFont Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtFont::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtFont::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*ptomBool = !(_dwMask		& dwMask) ? tomUndefined :
				(_CF._dwEffects & dwMask) ? tomTrue : tomFalse;
	
	return hr;
}

/*
 *	CTxtFont::EffectSetter (Value, dwMask, dwEffect)
 *
 *	@mfunc
 *		Mask off this range's effect bits identified by <p dwMask> and set
 *		effect bit given by <p dwEffect> equal to value given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtFont::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask, 	//@parm Bit mask identifying effect(s) to turn off
	DWORD	dwEffect)	//@parm Effect bit to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	if(Value == tomToggle)
	{
		if(_prg)								// If live Font object, update
		{										//  _CF.dwEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			LONG iFormat = _prg->_iFormat;		// Default iFormat for IP
			LONG cch	 = _prg->GetCch();

			if(cch)								// Range is nondegenerate
			{
				CFormatRunPtr rp(_prg->_rpCF);
				if(cch > 0)						// Get iFormat at cpFirst
					rp.Move(-cch);
				iFormat = rp.GetFormat();
			}
			_CF._dwEffects = _prg->GetPed()->GetCharFormat(iFormat)->_dwEffects;
		}
		_CF._dwEffects ^= dwEffect;			// Toggle effect(s)
		if (dwMask != dwEffect)
		{
			// Need to turn off other bits that are not being toggle
			DWORD	dwTurnOff = dwMask ^ dwEffect;
			_CF._dwEffects &= ~dwTurnOff;
		}
	}
	else
	{
		_CF._dwEffects &= ~dwMask;				// Default effect(s) off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			_CF._dwEffects |= dwEffect;			// Turn an effect on
		}
	}
	return FormatSetter(dwMask);
}

/*
 *	CTxtFont::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CCharFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtFont::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::FormatSetter");

	if(_prg && !_fApplyLater)
	{
		if (_fApplyToTmp)
			_CF._sTmpDisplayAttrIdx = GetTmpDisplayAttrIdx(_tmpDisplayAttr);

		HRESULT hr = _prg->CharFormatSetter(&_CF, dwMask, _fApplyToTmp ? CFM2_USETMPDISPATTR : 0);
		 if(hr != NOERROR)
			 return hr;
	}
	_dwMask |= dwMask;						// Collect data in font clone
	return NOERROR;
}

/*
 *	CTxtFont::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _CF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::GetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Font object, update
											//  _CF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtFont::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::SetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtFont::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this font object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtFont::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetCharFormat(&_CF);
	}
	return NOERROR;
}


//----------------------------- CTxtPara Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtPara::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtPara::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*ptomBool = !(_dwMask & dwMask) ? tomUndefined :
				(_PF._wEffects & (dwMask >> 16)) ? tomTrue : tomFalse;
	return hr;
}

/*
 *	CTxtPara::EffectSetter (Value, dwMask)
 *
 *	@mfunc
 *		Set this range's effect bit as given by <p dwMask> equal to value
 *		given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Note that the mask bits for paragraph effects are in the high word
 *		of _dwMask, but the effects are stored in the WORD _wEffects.
 */
HRESULT CTxtPara::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask) 	//@parm Bit mask identifying effect to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	DWORD dwEffects = _PF._wEffects << 16;		// Move effects over to where
												//  mask is
	if(Value == tomToggle)
	{
		if(_prg)								// If live Para object, update
		{										//  _PF._wEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			_dwMask = _prg->GetParaFormat(&_PF, 0);
			dwEffects = _PF._wEffects << 16;
			_PF._iTabs = -1;					// No interest in TABs here
		}
		if(_dwMask & dwMask)					// Effect is defined:
			dwEffects ^=  dwMask;				//  toggle it
		else									// Effect is NINCHed
			dwEffects &= ~dwMask;				// Turn it all off
	}
	else
	{
		dwEffects &= ~dwMask;					// Default effect off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			dwEffects |= dwMask;				// Turn it on
		}
	}

	_PF._wEffects = (WORD)(dwEffects >> 16);
	return FormatSetter(dwMask);
}

/*
 *	CTxtPara::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CParaFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtPara::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::FormatSetter");

	AssertSz(_PF._iTabs < 0,
		"CTxtPara::FormatSetter: illegal tabs index");

	if(_prg && !_fApplyLater)
	{
		if(dwMask & PFM_TABSTOPS)
			_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);

		HRESULT hr = _prg->ParaFormatSetter(&_PF, dwMask);
		CheckTabsAddRef();
		if(hr != NOERROR)
			return hr;
	}
	_dwMask |= dwMask;							// Collect data in para clone
	return NOERROR;
}

/*
 *	CTxtPara::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _PF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::GetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Para object, update
											//  _PF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtPara::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::SetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtPara::CheckTabsAddRef ()
 *
 *	@mfunc
 *		Release Tabs reference
 */
void CTxtPara::CheckTabsAddRef()
{
	if(_PF._iTabs >= 0)
	{
		GetTabsCache()->Release(_PF._iTabs);
		_PF._iTabs = -1;
	}
}

/*
 *	CTxtPara::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this para object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtPara::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetParaFormat(&_PF, 0);
		if(_PF._iTabs >= 0)
		{
			if(_PF.IsTableRowDelimiter())
				_PF._bTabCount = 0;
			else
				CopyMemory(_rgxTabs, GetTabsCache()->Deref(_PF._iTabs),
					   _PF._bTabCount*sizeof(LONG));
			_PF._iTabs = -1;
		}
	}
	return NOERROR;
}

//---------------------------- CTxtFormat Methods --------------------------------

/*
 *	CTxtFormat::CTxtFormat(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFormat::CTxtFormat(CTxtRange *prg)
{
	_cRefs	= 1;
	_prg	= prg;					// NULL for clone
	if(prg)
		prg->AddRef();
}

/*
 *	CTxtFormat::~CTxtFormat()
 *
 *	@mfunc
 *		Destructor
 */
CTxtFormat::~CTxtFormat()
{
	if(_prg)
		_prg->Release();
}

/*
 *	CTxtFormat::CanChange (pbCanChange)
 *
 *	@func
 *		Set *<p pbCanChange> = tomTRUE iff this format object can be changed
 *
 *	@rdesc
 *		HRESULT = (can change format) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This method is shared by ITextFont and ITextPara.  If pRange is NULL,
 *		the object is a clone, i.e., unattached to a CTxtRange
 */
HRESULT CTxtFormat::CanChange (
	long *pbCanChange,		//@parm Out parm to receive boolean value
	BOOL fPara)				//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFormat::CanChange");

	LONG fCanChange = tomTrue;
	
	if(_prg)
	{
		HRESULT hr = _prg->CanEdit(pbCanChange);
		if(hr != NOERROR)						// S_FALSE or CO_E_RELEASED
			return hr;

		if(!_prg->GetPed()->IsRich() && fPara)
			fCanChange = tomFalse;
	}
	if(pbCanChange)
		*pbCanChange = fCanChange;

	return fCanChange ? NOERROR : S_FALSE;
}

/*
 *	CTxtFormat::GetParameter (pParm, fDefined, Type, pValue)
 *
 *	@mfunc
 *		Set *pValue = *pLong unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::GetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to get
	DWORD	dwMask,		//@parm Nonzero iff defined
	long	Type,		//@parm # bytes of integer parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	if(!pValue)
		return E_INVALIDARG;

	Assert(pParm && sizeof(long) == 4 && sizeof(float) == 4);

	HRESULT hr = NOERROR;

	if(IsZombie())							// Check if attached to zombied
	{										//  range
		dwMask = 0;							// Nothing defined
		hr = CO_E_RELEASED;					// Setup return for following if
	}

	if(!dwMask)								// Parameter isn't defined
	{
		if(Type < 0)
			*(float *)pValue = tomFloatUndefined;
		else
			*pValue = tomUndefined;
		return hr;
	}

	*pValue = 0;

	switch(Type)							// Handle other cases
	{
	case 1:									// BYTE quantity
		*pValue = *(BYTE *)pParm;
		break;

	case 2:									// WORD quantity
		if(dwMask & (CFM_STYLE | PFM_STYLE))
			*pValue = *(SHORT *)pParm;		// Styles need sign extension
		else
			*pValue = *(WORD *)pParm;
		break;

	case -2:								// float from WORD or SHORT
		if(dwMask & (CFM_SPACING | CFM_SIZE	// Need sign extension for these
						| CFM_OFFSET))		//  (in high word, so don't
			*pValue = *(SHORT *)pParm;		//   conflict with PFM_xxx)		
		else
			*pValue = *(WORD *)pParm; 
		goto TO_FLOAT;

	case -4:								// float from LONG
		*pValue = *pParm;
TO_FLOAT:
		*(float *)pValue = TWIPS_TO_FPPTS(*pValue);
		break;

	case 4:
		*pValue = *pParm;
		break;

#ifdef DEBUG
	default:
		AssertSz(FALSE, "CTxtFormat::GetParameter:: Unknown Type");
		break;
#endif
	}

	return NOERROR;
}

/*
 *	CTxtFormat::SetParameter (pParm, fDefined, Type, Value)
 *
 *	@mfunc
 *		Set *pParm = Value unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::SetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to set
	long	Type,		//@parm # bytes of integer parameter or < 0 for float
	long 	Value)		//@parm New value for *pParm
{
	Assert(pParm);

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(Type > 0 && Value == tomUndefined)			// Undefined parameter
		return NOERROR;								// NINCH

	if(Type < 0)									// Value is a float
	{
		if(*(float *)&Value == tomFloatUndefined)	// Undefined parameter
			return NOERROR;							// NINCH
		Type = -Type;
		Value = FPPTS_TO_TWIPS(*(float *)&Value);	// Convert to a long
	}

	if(Type == 1)
	{
		if((DWORD)Value > 255)
			return E_INVALIDARG;
		*(BYTE *)pParm = (BYTE)Value;
	}
	else if(Type == 2)
	{
		if(Value < -32768 || Value > 65535)
			return E_INVALIDARG;					// Doesn't fit in 16 bits
		*(WORD *)pParm = (WORD)Value;
	}
	else
		*pParm = Value;

	return NOERROR;
}

/*
 *	CTxtFormat::IsTrue (f, pB)
 *
 *	@mfunc
 *		Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *	@rdesc
 *		HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtFormat::IsTrue(BOOL f, long *pB)
{
	if(pB)
		*pB = tomFalse;

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(f)
	{
		if(pB)
			*pB = tomTrue;
		return NOERROR;
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tomdoc.cpp ===
/*
 *	@doc TOM
 *
 *	@module tomdoc.cpp - Implement the ITextDocument interface on CTxtEdit |
 *	
 *		This module contains the implementation of the TOM ITextDocument
 *		class as well as the global TOM type-info routines
 *
 *	History: <nl>
 *		sep-95	MurrayS: stubs and auto-doc created <nl>
 *		nov-95	MurrayS: upgrade to top-level TOM interface
 *		dec-95	MurrayS: implemented file I/O methods
 *
 *	@future
 *		1. Implement Begin/EndEditCollection
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_disp.h"
#include "_rtfconv.h"
#include "_select.h"
#include "_font.h"
#include "_tomfmt.h"

ASSERTDATA

// TOM Type Info HRESULT and pointers
HRESULT		g_hrGetTypeInfo = NOERROR;
ITypeInfo *	g_pTypeInfoDoc;
ITypeInfo *	g_pTypeInfoSel;
ITypeInfo *	g_pTypeInfoFont;
ITypeInfo *	g_pTypeInfoPara;
ITypeLib  *	g_pTypeLib;

BYTE szUTF8BOM[] = {0xEF, 0xBB, 0xBF};		// UTF-8 for 0xFEFF

//------------------------ Global TOM Type Info Methods -----------------------------

/*
 *	GetTypeInfoPtrs()
 *
 *	@func
 *		Ensure that global TOM ITypeInfo ptrs are valid (else g_pTypeInfoDoc
 *		is NULL).  Return NOERROR immediately if g_pTypeInfoDoc is not NULL,
 *		i.e., type info ptrs are already valid.
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR
 *				: (HRESULT from LoadTypeLib or GetTypeInfoOfGuid)
 *
 *	@comm
 *		This routine should be called by any routine that uses the global
 *		type info ptrs, e.g., IDispatch::GetTypeInfo(), GetIDsOfNames, and
 *		Invoke.  That way if noone is using the type library info, it doesn't
 *		have to be loaded.
 *
 */
HRESULT GetTypeInfoPtrs()
{
	HRESULT	hr;
	CLock	lock;							// Only one thread at a time...
	WCHAR	szModulePath[MAX_PATH];



	if(g_pTypeInfoDoc)						// Type info ptrs already valid
		return NOERROR;

	if(g_hrGetTypeInfo != NOERROR)			// Tried to get before and failed
		return g_hrGetTypeInfo;

	// Obtain the path to this module's executable file
	if (W32->GetModuleFileName(hinstRE, szModulePath, MAX_PATH))
	{
		// Provide the full-path name so LoadTypeLib will not register
		// the type library
		hr = LoadTypeLib(szModulePath, &g_pTypeLib);
		if(hr != NOERROR)
			goto err;

		// Get ITypeInfo pointers with g_pTypeInfoDoc last
		hr = g_pTypeLib->GetTypeInfoOfGuid(IID_ITextSelection, &g_pTypeInfoSel);
		if(hr == NOERROR)
		{
			g_pTypeLib->GetTypeInfoOfGuid(IID_ITextFont,	 &g_pTypeInfoFont);
			g_pTypeLib->GetTypeInfoOfGuid(IID_ITextPara,	 &g_pTypeInfoPara);
			g_pTypeLib->GetTypeInfoOfGuid(IID_ITextDocument, &g_pTypeInfoDoc);

			if(g_pTypeInfoFont && g_pTypeInfoPara && g_pTypeInfoDoc)
				return NOERROR;					// Got 'em all
		}
	}
	hr = E_FAIL;

err:
	Assert("Error getting type info pointers");

	g_pTypeInfoDoc	= NULL;					// Type info ptrs not valid
	g_hrGetTypeInfo	= hr;					// Save HRESULT in case called
	return hr;								//  again
}

/*
 *	ReleaseTypeInfoPtrs()
 *
 *	@func
 *		Release TOM type info ptrs in case they have been defined.
 *		Called when RichEdit dll is being unloaded.
 */
void ReleaseTypeInfoPtrs()
{
	if(g_pTypeInfoDoc)
	{
		g_pTypeInfoDoc->Release();
		g_pTypeInfoSel->Release();
		g_pTypeInfoFont->Release();
		g_pTypeInfoPara->Release();
	}
	if(g_pTypeLib)
		g_pTypeLib->Release();
}

/*
 *	GetTypeInfo(iTypeInfo, &pTypeInfo, ppTypeInfo)
 *
 *	@func
 *		IDispatch helper function to check parameter validity and set
 *		*ppTypeInfo = pTypeInfo if OK
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	ITypeInfo *&pTypeInfo,		//@parm Address of desired type info ptr
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	if(!ppTypeInfo)
		return E_INVALIDARG;

	*ppTypeInfo = NULL;

	if(iTypeInfo > 1)
		return DISP_E_BADINDEX;

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr == NOERROR)
	{
		*ppTypeInfo = pTypeInfo;				// Have to use reference in
		pTypeInfo->AddRef();					//  case defined in this call
	}
	return hr;
}

/*
 *	MyRead(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		input.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyRead(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!ReadFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)NOERROR;
}

/*
 *	MyWrite(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		output.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyWrite(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!WriteFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)(*pcb ? NOERROR : E_FAIL);
}


//-----------------CTxtEdit IUnknown methods: see textserv.cpp -----------------------------


//------------------------ CTxtEdit IDispatch methods -------------------------

/*
 *	CTxtEdit::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtEdit::GetTypeInfoCount(
	UINT *pcTypeInfo)	//@parm Out parm to receive count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtEdit::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextDocument interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
 {
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoDoc, ppTypeInfo);
}

/*
 *	CTxtEdit::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for all TOM methods and properties
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine tries to find DISPIDs using the type information for
 *		ITextDocument. If that fails, it asks the selection to find the
 *		DISPIDs.
 */
STDMETHODIMP CTxtEdit::GetIDsOfNames(
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	hr = g_pTypeInfoDoc->GetIDsOfNames(rgszNames, cNames, rgdispid);

	if(hr == NOERROR)							// Succeeded in finding an
		return NOERROR;							//  ITextDocument method

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection knows
												//  the desired method
	if(!pSel)
		return hr;								// No selection

	return pSel->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

/*
 *	CTxtEdit::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke members for all TOM DISPIDs, i.e., for ITextDocument,
 *		ITextSelection, ITextRange, ITextFont, and ITextPara.  TOM DISPIDs
 *		for all but ITextDocument are delegated to the selection object.
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine trys to invoke ITextDocument members if the DISPID is
 *		in the range 0 thru 0xff.  It trys to invoke ITextSelection members if
 *		the DISPID is in the range 0x100 thru 0x4ff (this includes
 *		ITextSelection, ITextRange, ITextFont, and ITextPara).  It returns
 *		E_MEMBERNOTFOUND for DISPIDs outside these ranges.
 */
STDMETHODIMP CTxtEdit::Invoke(
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if((DWORD)dispidMember < 0x100)				// ITextDocment method
		return g_pTypeInfoDoc->Invoke((IDispatch *)this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection has
												//  the desired method
	if(pSel && (DWORD)dispidMember <= 0x4ff)
		return pSel->Invoke(dispidMember, riid, lcid, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	return DISP_E_MEMBERNOTFOUND;
}


//--------------------- ITextDocument Methods/Properties -----------------------

/*
 *	ITextDocument::BeginEditCollection()
 *
 *	@mfunc
 *		Method that turns on undo grouping
 *
 *	@rdesc
 *		HRESULT = (undo enabled) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::BeginEditCollection ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::BeginEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::EndEditCollection() 
 *
 *	@mfunc
 *		Method that turns off undo grouping
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::EndEditCollection () 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::EndEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::Freeze(long *pValue) 
 *
 *	@mfunc
 *		Method to increment the freeze count. If this count is nonzero,
 *		screen updating is disabled.  This allows a sequence of editing
 *		operations to be performed without the performance loss and
 *		flicker of screen updating.  See Unfreeze() to decrement the
 *		freeze count.
 *
 *	@rdesc
 *		HRESULT = (screen updating disabled) ? NOERROR : S_FALSE
 *
 *	@todo
 *		What about APIs like EM_LINEFROMCHAR that don't yet know how to
 *		react to a frozen display?
 */
STDMETHODIMP CTxtEdit::Freeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Freeze");

    CCallMgr callmgr(this);

	if(_pdp)
	{
		CCallMgr callmgr(this);

		_pdp->Freeze();
		if(_pdp->IsFrozen())
			_cFreeze++;
		else
			_cFreeze = 0;
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::GetDefaultTabStop (pValue) 
 *
 *	@mfunc
 *		Property get method that gets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetDefaultTabStop (
	float *	pValue)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultTabStop");

	if(!pValue)
		return E_INVALIDARG;
                                                                        
	const LONG lTab = GetDefaultTab();

	*pValue = TWIPS_TO_FPPTS(lTab);

	return NOERROR;
}

/*
 *	CTxtEdit::GetName (pName)
 *
 *	@mfunc
 *		Retrieve ITextDocument filename
 *
 *	@rdesc
 *		HRESULT = (!<p pName>) ? E_INVALIDARG :
 *				  (no name) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
STDMETHODIMP CTxtEdit::GetName (
	BSTR * pName)		//@parm Out parm to receive filename
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetName");

	if(!pName)
		return E_INVALIDARG;

	*pName = NULL;
	if(!_pDocInfo || !_pDocInfo->_pName)
		return S_FALSE;

	*pName = SysAllocString(_pDocInfo->_pName);
	
	return *pName ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument::GetSaved (pValue) 
 *
 *	@mfunc
 *		Property get method that gets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		Next time to aid C/C++ clients, we ought to make pValue optional
 *		and return S_FALSE if doc isn't saved, i.e., like our other
 *		boolean properties (see, e.g., ITextRange::IsEqual())
 */
STDMETHODIMP CTxtEdit::GetSaved (
	long *	pValue)		//@parm Out parm to receive Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSaved");

	if(!pValue)
		return E_INVALIDARG;

	*pValue = _fSaved ? tomTrue : tomFalse;
	return NOERROR;
}

/*
 *	ITextDocument::GetSelection (ITextSelection **ppSel) 
 *
 *	@mfunc
 *		Property get method that gets the active selection. 
 *
 *	@rdesc
 *		HRESULT = (!ppSel) ? E_INVALIDARG :
 *				  (if active selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelection (
	ITextSelection **ppSel)	//@parm Out parm to receive selection pointer
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelection");

	if(!ppSel)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();

	*ppSel = (ITextSelection *)psel;

	if( psel )
	{
		(*ppSel)->AddRef();
		return NOERROR;
	}

	return S_FALSE;
}

/*
 *	CTxtEdit::GetStoryCount(pCount)
 *
 *	@mfunc
 *		Get count of stories in this document.
 *
 *	@rdesc
 *		HRESULT = (!<p pCount>) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetStoryCount (
	LONG *pCount)		//@parm Out parm to receive count of stories
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryCount");

	if(!pCount)
		return E_INVALIDARG;

	*pCount = 1;
	return NOERROR;
}

/*
 *	ITextDocument::GetStoryRanges(ITextStoryRanges **ppStories) 
 *
 *	@mfunc
 *		Property get method that gets the story collection object
 *		used to enumerate the stories in a document.  Only invoke this
 *		method if GetStoryCount() returns a value greater than one.
 *
 *	@rdesc
 *		HRESULT = (if Stories collection exists) ? NOERROR : E_NOTIMPL
 */
STDMETHODIMP CTxtEdit::GetStoryRanges (
	ITextStoryRanges **ppStories) 	//@parm Out parm to receive stories ptr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryRanges");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::New() 
 *
 *	@mfunc
 *		Method that closes the current document and opens a document
 *		with a default name.  If changes have been made in the current
 *		document since the last save and document file information exists,
 *		the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::New ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::New");

	CloseFile(TRUE);	 					// Save and close file
	return SetText(NULL, 0, CP_ULE);
}

/*
 *	ITextDocument::Open(pVar, Flags, CodePage)
 *
 *	@mfunc
 *		Method that opens the document specified by pVar.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *	@future
 *		Handle IStream
 */
STDMETHODIMP CTxtEdit::Open (
	VARIANT *	pVar,		//@parm Filename or IStream
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Open");

	LONG		cb;								// Byte count for RTF check
	EDITSTREAM	es		= {0, NOERROR, MyRead};
	BOOL		fReplaceSel = Flags & tomPasteFile;
	HCURSOR		hcur;
	LRESULT		lres;
	TCHAR		szType[10];

	if(!pVar || CodePage && !IsUnicodeCP(CodePage) && !IsValidCodePage(CodePage))
		return E_INVALIDARG;					// IsValidCodePage(0) fails
												//  even tho CP_ACP = 0 (!)
	if((Flags & 0xF) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!fReplaceSel)							// If not replacing selection,
		New();									//  save current file and
												//  delete current text
	CDocInfo * pDocInfo = GetDocInfo();
	if(!pDocInfo)
		return E_OUTOFMEMORY;

	pDocInfo->_wFlags = (WORD)(Flags & ~0xf0);	// Save flags (w/o creation)

	// Process access, share, and create flags
	DWORD dwAccess = (Flags & tomReadOnly)
		? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xf;
	if(!dwCreate)								// Flags nibble 2 must contain
		dwCreate = OPEN_ALWAYS;					//  CreateFile's dwCreate

	if(pVar->vt == VT_BSTR && SysStringLen(pVar->bstrVal))
	{
		es.dwCookie = (DWORD_PTR)CreateFile(pVar->bstrVal, dwAccess, dwShare,
							 NULL, dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
		if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
			return HRESULT_FROM_WIN32(GetLastError());

		if(!fReplaceSel)						// If not replacing selection,
		{										//  allocate new pName
			pDocInfo->_pName = SysAllocString(pVar->bstrVal);
			if (!pDocInfo->_pName)
				return E_OUTOFMEMORY;
			pDocInfo->_hFile = (HANDLE)es.dwCookie;
			pDocInfo->_wFlags |= tomTruncateExisting;	// Setup Saves
		}
	}
	else
	{
		// FUTURE: check for IStream; if not, then fail
		return E_INVALIDARG;
	}

	Flags &= 0xf;								// Isolate conversion flags

	// Get first few bytes of file to check for RTF and Unicode BOM
	(*es.pfnCallback)(es.dwCookie, (LPBYTE)szType, 10, &cb);

	Flags = (!Flags || Flags == tomRTF) && IsRTF((char *)szType, cb)
		  ? tomRTF : tomText;

	LONG j = 0;									// Default rewind to 0
	if (Flags == tomRTF)						// RTF
		Flags = SF_RTF;							// Setup EM_STREAMIN for RTF
	else
	{											// If it starts with
		Flags = SF_TEXT;						// Setup EM_STREAMIN for text
		if(cb > 1 && *(WORD *)szType == BOM)	//  Unicode byte-order mark
		{										//  (BOM) file is Unicode, so
			Flags = SF_TEXT | SF_UNICODE;		//  use Unicode code page and
			j = 2;								//  bypass the BOM
		}										
		else if(cb > 1 && *(WORD *)szType == RBOM)// Big Endian BOM
		{										//  BOM
			Flags = SF_TEXT | SF_USECODEPAGE | (CP_UBE << 16);
			j = 2;								// Bypass the BOM
		}										
		else if(cb > 2 && W32->IsUTF8BOM((BYTE *)szType))
		{
			Flags = SF_TEXT | SF_USECODEPAGE | (CP_UTF8 << 16);
			j = 3;
		}
		else if(CodePage == CP_ULE)
			Flags = SF_TEXT | SF_UNICODE;

		else if(CodePage)
			Flags = SF_TEXT | SF_USECODEPAGE | (CodePage << 16);
	}

	SetFilePointer((HANDLE)es.dwCookie, j, NULL, FILE_BEGIN);	// Rewind

	if(fReplaceSel)
		Flags |= SFF_SELECTION;

	Flags |= SFF_KEEPDOCINFO;

	hcur = TxSetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMIN, Flags, (LPARAM)&es, &lres);
	TxSetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE) || fReplaceSel)
	{											// Full sharing or replaced
		CloseHandle((HANDLE)es.dwCookie);		//  selection, so close file
		if(!fReplaceSel)						// If replacing selection,
			pDocInfo->_hFile = NULL;				//  leave _pDocInfo->_hFile
	}
	_fSaved = fReplaceSel ? FALSE : TRUE;		// No changes yet unless
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::Range(long cpFirst, long cpLim, ITextRange **ppRange)  
 *
 *	@mfunc
 *		Method that gets a text range on the active story of the document
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtEdit::Range (
	long cpFirst, 				//@parm	Non active end of new range
	long cpLim, 				//@parm Active end of new range
	ITextRange ** ppRange)		//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Range");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = new CTxtRange(this, cpFirst, cpFirst - cpLim);
	
	if( *ppRange )
	{
		(*ppRange)->AddRef();		// CTxtRange() doesn't AddRef() because
		return NOERROR;				//  it's used internally for things
	}								//  besides TOM

	return E_OUTOFMEMORY;
}

/*
 *	ITextDocument::RangeFromPoint(long x, long y, ITextRange **ppRange) 
 *
 *	@mfunc
 *		Method that gets the degenerate range corresponding (at or nearest)
 *		to the point with the screen coordinates x and y.
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG :
 *				  (if out of RAM) ? E_OUTOFMEMORY :
 *				  (if range exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::RangeFromPoint (
	long	x,				//@parm Horizontal coord of point to use
	long	y,				//@parm	Vertical   coord of point to use
	ITextRange **ppRange)	//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::RangeFromPoint");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = (ITextRange *) new CTxtRange(this, 0, 0);

	if(!*ppRange)
		return E_OUTOFMEMORY;

	(*ppRange)->AddRef();				// CTxtRange() doesn't AddRef()
	return (*ppRange)->SetPoint(x, y, 0, 0);
}

/*
 *	ITextDocument::Redo(long Count, long *pCount) 
 *
 *	@mfunc
 *		Method to perform the redo operation Count times
 *
 *	@rdesc
 *		HRESULT = (if Count redos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Redo (
	long	Count,		//@parm Number of redo operations to perform
	long *	pCount)		//@parm Number of redo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Redo");
	CCallMgr	callmgr(this);

	LONG i = 0;

	// Freeze the display during the execution of the anti-events
	CFreezeDisplay fd(_pdp);
	HRESULT hr = NOERROR;

	for ( ; i < Count; i++)					//  loop does nothing
	{
		hr = PopAndExecuteAntiEvent(_predo, 0);
		if(hr != NOERROR)
			break;
	}

	if(pCount)
		*pCount = i;

	return hr == NOERROR && i != Count ? S_FALSE : hr;
}

/*
 *	ITextDocument::Save(pVar, Flags, CodePage) 
 *
 *	@mfunc
 *		Method that saves this ITextDocument to the target pVar,
 *		which is a VARIANT that can be a filename, an IStream, or NULL.  If
 *		NULL, the filename given by this document's name is used.  It that,
 *		in turn, is NULL, the method fails.  If pVar specifies a filename,
 *		that name should replace the current Name property.
 *
 *	@rdesc
 *		HRESULT = (!pVar) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_FAIL
 *
 *	@devnote
 *		This routine can be called with NULL arguments
 */
STDMETHODIMP CTxtEdit::Save (
	VARIANT *	pVar,		//@parm Save target (filename or IStream)
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Save");

	LONG		cb;			// Byte count for writing Unicode BOM
	EDITSTREAM	es		= {0, NOERROR, MyWrite};
	BOOL		fChange	= FALSE;				// No doc info change yet
	HCURSOR		hcur;
	CDocInfo *	pDocInfo = GetDocInfo();

	if(CodePage && !IsUnicodeCP(CodePage) && !IsValidCodePage(CodePage) ||
	   (DWORD)Flags > 0x1fff || Flags & tomReadOnly)
	{
		return E_INVALIDARG;
	}
	if((Flags & 0xf) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	if (pVar && pVar->vt == VT_BSTR &&			// Filename string
		pVar->bstrVal &&
		SysStringLen(pVar->bstrVal) &&			// NonNULL filename specified
		(!pDocInfo->_pName ||
		 OLEstrcmp(pVar->bstrVal, pDocInfo->_pName)))
	{											// Filename differs
		fChange = TRUE;							// Force write to new file
		CloseFile(FALSE);						// Close current file; no save
		pDocInfo->_pName = SysAllocString(pVar->bstrVal);
		if(!pDocInfo->_pName)
			return E_OUTOFMEMORY;
		pDocInfo->_wFlags &= ~0xf0;				// Kill previous create mode
	}

	DWORD flags = pDocInfo->_wFlags;
	if(!(Flags & 0xF))							// If convert flags are 0,									
		Flags |= flags & 0xF;					//  use values in doc info
	if(!(Flags & 0xF0))							// If create flags are 0,									
		Flags |= flags & 0xF0;					//  use values in doc info
	if(!(Flags & 0xF00))						// If share flags are 0,									
		Flags |= flags & 0xF00;					//  use values in doc info
	if(!CodePage)								// If code page is 0,
		CodePage = pDocInfo->_wCpg;				//  use code page in doc info

	if((DWORD)Flags != flags ||					// If flags or code page	
	   (WORD)CodePage != pDocInfo->_wCpg)		//  changed, force write
	{
		fChange = TRUE;
	}
	pDocInfo->_wFlags = (WORD)Flags;				// Save flags

	// Yikes, nowhere to save.  bail-out now
	if(!_pDocInfo->_pName)
		return E_FAIL;

	if(_fSaved && !fChange)						// No changes, so assume
		return NOERROR;							//  saved file is up to date

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xF;
	if(!dwCreate)
		dwCreate = CREATE_NEW;

	if(pDocInfo->_hFile)
	{
		CloseHandle(pDocInfo->_hFile);			// Close current file handle
		pDocInfo->_hFile = NULL;
	}

	es.dwCookie = (DWORD_PTR)CreateFile(pDocInfo->_pName, GENERIC_READ | GENERIC_WRITE, dwShare, NULL,
							dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
	if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());

	pDocInfo->_hFile = (HANDLE)es.dwCookie;

	Flags &= 0xF;								// Isolate conversion flags
	if(Flags == tomRTF)							// RTF
		Flags = SF_RTF;							// Setup EM_STREAMOUT for RTF
	else
	{											
		Flags = SF_TEXT;						// Setup EM_STREAMOUT for text
		if(IsUnicodeCP(CodePage) || CodePage == CP_UTF8)
		{										// If Unicode, start file with
			LONG  j = 2;						//  Unicode byte order mark
			WORD  wBOM = BOM;
			WORD  wRBOM = RBOM;
			BYTE *pb = (BYTE *)&wRBOM;			// Default Big Endian Unicode				
											
			if(CodePage == CP_UTF8)
			{
				j = 3;
				pb = szUTF8BOM;
			}
			else if(CodePage == CP_ULE)			// Little Endian Unicode
			{
				Flags = SF_TEXT | SF_UNICODE;
				pb = (BYTE *)&wBOM;
			}
			(*es.pfnCallback)(es.dwCookie, pb, j, &cb);
		}
	}
	if(CodePage && CodePage != CP_ULE)
		Flags |= SF_USECODEPAGE | (CodePage << 16);

	hcur = TxSetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMOUT, Flags, (LPARAM)&es, NULL);
	TxSetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE))
	{											// Full sharing, so close
		CloseHandle(pDocInfo->_hFile);			//  current file handle
		pDocInfo->_hFile = NULL;
	}
	_fSaved = TRUE;								// File is saved
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::SetDefaultTabStop (Value) 
 *
 *	@mfunc
 *		Property set method that sets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::SetDefaultTabStop (
	float Value)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultTabStop");

	if(Value <= 0)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->_dwDefaultTabStop = FPPTS_TO_TWIPS(Value);

	_pdp->UpdateView();
	return NOERROR;
}

/*
 *	ITextDocument::SetSaved (Value) 
 *
 *	@mfunc
 *		Property set method that sets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SetSaved (
	long	Value)		//@parm New value of Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetSaved");

	_fSaved = Value ? TRUE : FALSE;
	return NOERROR;
}

/*
 *	ITextDocument::Undo(Count, *pCount) 
 *
 *	@mfunc
 *		Method to perform the undo operation Count times or to control
 *		the nature of undo processing. Count = 0 stops undo processing
 *		and discards any saved undo states.  Count = -1 turns on undo
 *		processing with the default undo limit.  Count = tomSuspend
 *		suspends undo processing, but doesn't discard saved undo states,
 *		and Count = tomResume resumes undo processing with the undo states
 *		active when Count = tomSuspend was given.
 *
 *	@rdesc
 *		HRESULT = (if Count undos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Undo (
	long	Count,		//@parm Count of undo operations to perform
						//		0 stops undo processing
						//		-1 turns restores it
	long *	pCount)		//@parm Number of undo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Undo");
	CCallMgr callmgr(this);

	LONG i = 0;

	// Freeze display during execution of anti-events
	CFreezeDisplay fd(_pdp);
	HRESULT hr = NOERROR;
											// Note: for Count <= 0,
	for ( ; i < Count; i++)					//  loop does nothing
	{
		hr = PopAndExecuteAntiEvent(_pundo, 0);
		if(hr != NOERROR)
			break;
	}

	if(pCount)
		*pCount = i;

	if(Count <= 0)							
		i = HandleSetUndoLimit(Count);

	return hr == NOERROR && i != Count ? S_FALSE : hr;
}

/*
 *	ITextDocument::Unfreeze(pCount) 
 *
 *	@mfunc
 *		Method to decrement freeze count.  If this count goes to zero,
 *		screen updating is enabled.  This method cannot decrement the
 *		count below zero.
 *
 *	@rdesc
 *		HRESULT = (screen updating enabled) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		The display maintains its own private reference count which may
 *		temporarily exceed the reference count of this method.  So even
 *		if this method indicates that the display is unfrozen, it may be
 *		for a while longer.
 */
STDMETHODIMP CTxtEdit::Unfreeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Unfreeze");

    CCallMgr callmgr(this);

	if(_cFreeze)
	{
		CCallMgr callmgr(this);

		AssertSz(_pdp && _pdp->IsFrozen(),
			"CTxtEdit::Unfreeze: screen not frozen but expected to be");
		_cFreeze--;
		_pdp->Thaw();
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? S_FALSE : NOERROR;
}


//----------------------- ITextDocument2 Methods -----------------------
/*
 *	ITextDocument2::AttachMsgFilter(pFilter) 
 *
 *	@mfunc
 *		Method to attach a new message filter to the edit instance.
 *      All window messages received by the edit instance will be forwarded
 *      to the message filter.  The message filter must be bound to the document
 *		before it can be used (Refer to the ITextMessageFilter API).
 *
 *	@rdesc
 *		HRESULT = filter succesfully attached ? NOERROR : QI failure.
 */
STDMETHODIMP CTxtEdit::AttachMsgFilter (
	IUnknown *pFilter)		//@parm the IUnknown for the new message filter
{
	ITextMsgFilter *pMsgFilter = NULL;

	HRESULT hr = pFilter->QueryInterface(IID_ITextMsgFilter, (void **)&pMsgFilter);
	if (SUCCEEDED(hr))
	{
		if (_pMsgFilter)
			_pMsgFilter->AttachMsgFilter(pMsgFilter);
		else
			_pMsgFilter = pMsgFilter;
	}
	return hr;
}

/*
 *	ITextDocument2::GetEffectColor(Index, pcr)
 *
 *	@mfunc
 *		Method to retrieve the COLORREF color used in special attribute
 *		displays.  The first 15 values are for special underline colors 1 - 15.
 *      Later we may define indices for other effects, e.g., URLs, strikeout.
 *		If an index between 1 and 15 hasn't been defined by an appropriate
 *		call to ITextDocument2:SetEffectColor(), the corresponding WORD
 *		default color value given by g_Colors[] is returned.
 *
 *	@rdesc
 *		HRESULT = (valid active color index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetEffectColor(
	long	  Index,		//@parm Which special color to get
	COLORREF *pcr)			//@parm Out parm for color
{
	if(!pcr)
		return E_INVALIDARG;

	if(!IN_RANGE(1, Index, 15))
	{
		*pcr = (COLORREF)tomUndefined;
		return E_INVALIDARG;
	}

	*pcr = g_Colors[Index];

	CDocInfo *pDocInfo = GetDocInfo();
	if(!pDocInfo)
		return E_OUTOFMEMORY;
	
	Index--;
	if (Index < pDocInfo->_cColor &&
		pDocInfo->_prgColor[Index] != (COLORREF)tomUndefined)
	{
		*pcr = pDocInfo->_prgColor[Index];
	}
	return NOERROR;
}

/*
 *	ITextDocument2::SetEffectColor(Index, cr) 
 *
 *	@mfunc
 *		Method to save the Index'th special document color.  Indices
 *      1 - 15 are defined for underlining.  Later we may define
 *		indices for other effects, e.g., URLs, strikeout.
 *
 *	@rdesc
 *		HRESULT = (valid index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetEffectColor(
	long	 Index,			//@parm Which special color to set
	COLORREF cr)			//@parm Color to use
{
	CDocInfo *pDocInfo = GetDocInfo();
	if(!pDocInfo)
		return E_OUTOFMEMORY;

	Index--;
	if(!IN_RANGE(0, Index, 14))
		return E_INVALIDARG;

	if(Index >= pDocInfo->_cColor)
	{
		LONG	  cColor   = (Index + 4) & ~3;		// Round up to 4
		COLORREF *prgColor = (COLORREF *)PvReAlloc(pDocInfo->_prgColor,
												  cColor*sizeof(COLORREF));
		if(!prgColor)
			return E_OUTOFMEMORY;

		for(LONG i = pDocInfo->_cColor; i < cColor; i++)
			prgColor[i] = (COLORREF)tomUndefined;

		pDocInfo->_cColor   = (char)cColor;
		pDocInfo->_prgColor = prgColor;
	}
	pDocInfo->_prgColor[Index] = cr;	
	return NOERROR;
}

/*
 *	ITextDocument2::SetCaretType(CaretType) 
 *
 *	@mfunc
 *		Method to sllow programmatic control over the caret type.
 *      The form of the control is TBD as is its interaction with
 *      existing formatting (e.g. font size and italics).
 *
 *	@rdesc
 *		HRESULT = caret type is one we understand ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetCaretType(
	long CaretType)		//@parm specification of caret type to use
{
	// For now, just care about Korean block craet.
	if (CaretType == tomKoreanBlockCaret)
		_fKoreanBlockCaret = TRUE;
	else if (CaretType == tomNormalCaret)
		_fKoreanBlockCaret = FALSE;
	else
		return E_INVALIDARG;

	if (_psel && _psel->IsCaretShown() && _fFocus)
	{
		_psel->CreateCaret();
		TxShowCaret(TRUE);
	}
	return NOERROR;
}

/*
 *	ITextDocument2::GetCaretType(pCaretType)
 *
 *	@mfunc
 *		Method to retrieve the previously set caret type.
 *      TBD.  Can one get it without setting it?
 *
 *	@rdesc
 *		HRESULT = caret info OK ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetCaretType(
	long *pCaretType)		//@parm current caret type specification
{
	if (!pCaretType)
		return E_INVALIDARG;

	*pCaretType = _fKoreanBlockCaret ? tomKoreanBlockCaret : tomNormalCaret;
	return NOERROR;
}

/*
 *	ITextDocument2::GetImmContext(pContext) 
 *
 *	@mfunc
 *		Method to retrieve the IMM context from our host.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetImmContext(
	long *pContext)		//@parm Imm context
{
	if (!pContext)
		return E_INVALIDARG;

	*pContext = 0;

	if (!_fInOurHost)
	{
		// ask host for Imm Context
		HIMC hIMC = TxImmGetContext();
		
		*pContext = (long) hIMC;			
	}
	
	return *pContext ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument2::ReleaseImmContext(Context) 
 *
 *	@mfunc
 *		Method to release the IMM context.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::ReleaseImmContext(
	long Context)		//@parm Imm context to be release
{
	if (!_fInOurHost)
	{
		// ask host to release Imm Context
		TxImmReleaseContext((HIMC)Context);
		
		return NOERROR;			
	}
	
	return S_FALSE;
}

/*
 *	ITextDocument2::GetPreferredFont(cp, lCodePage, lOption, lCurCodePage, lCurFontSize,
 *		,pFontName, pPitchAndFamily, pNewFontSize) 
 *
 *	@mfunc
 *		Method to retrieve the preferred font name and pitch and family at a 
 *		given cp and codepage.
 *
 *	@rdesc
 *		HRESULT = FontName available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetPreferredFont(
	long cp,				//@parm cp
	long lCodepage,			//@parm codepage preferred
	long lOption,			//@parm option for matching current font
	long lCurCodePage,		//@parm current codepage
	long lCurFontSize,		//@parm current font size
	BSTR *pFontName,		//@parm preferred fontname
	long *pPitchAndFamily,	//@parm pitch and family 
	long *plNewFontSize)	//@parm new font size preferred 
{
	if (!pFontName || !IN_RANGE(IGNORE_CURRENT_FONT, lOption, MATCH_FONT_SIG))
		return E_INVALIDARG;

	if (!IsAutoFont())		// EXIT if auto font is turned off
		return S_FALSE;

	CRchTxtPtr	rtp(this, 0);
	CCFRunPtr	rp(rtp);
	short		iFont;
	short		yHeight;
	BYTE		bPitchAndFamily;
	BYTE		iCharRep = CharRepFromCodePage(lCodepage);

	rp.Move(cp);
	if (rp.GetPreferredFontInfo(
			iCharRep,
			iCharRep,
			iFont,
			yHeight,
			bPitchAndFamily,
			-1,
			lOption))
	{
		if (*pFontName)
			wcscpy(*pFontName, GetFontName((LONG)iFont));
		else
		{
			*pFontName = SysAllocString(GetFontName((LONG)iFont));
			if (!*pFontName)
				return E_OUTOFMEMORY;
		}	

		if (pPitchAndFamily)
			*pPitchAndFamily = bPitchAndFamily;

		// Calc the new font size if needed
		if (plNewFontSize)
		{
			*plNewFontSize = lCurFontSize;
			if (_fAutoFontSizeAdjust && lCodepage != lCurCodePage)
				*plNewFontSize = yHeight / TWIPS_PER_POINT;			// Set the preferred size
		}
		return S_OK;
	}
	return E_FAIL;
}

/*
 *	ITextDocument2::GetNotificationMode( long *plMode ) 
 *
 *	@mfunc
 *		Method to retrieve the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetNotificationMode(
	long *plMode)		//@parm current notification mode
{
	if (!plMode)
		return E_INVALIDARG;

	*plMode = _fSuppressNotify ? tomFalse : tomTrue;

	return NOERROR;
}

/*
 *	ITextDocument2::SetNotificationMode(lMode) 
 *
 *	@mfunc
 *		Method to set the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetNotificationMode(
	long lMode)		//@parm new notification mode
{
	if (lMode == tomFalse)
		_fSuppressNotify = 1;
	else if  (lMode == tomTrue)
		_fSuppressNotify = 0;
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextDocument2::GetClientRect(Type, pLeft, pTop,pRight, pBottom ) 
 *
 *	@mfunc
 *		Method to retrieve the client rect and inset adjustment.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetClientRect(
	long Type,				//@parm option
	long *pLeft,			//@parm left
	long *pTop,				//@parm top
	long *pRight,			//@parm right
	long *pBottom)			//@parm bottom
{
	if (!pLeft || !pTop || !pRight || !pBottom)
		return E_INVALIDARG;
	
	RECT rcArea;
	TxGetClientRect(&rcArea); 
	
	if ( Type & tomIncludeInset )
	{
		// Ajdust veiw inset
		RECTUV rcInset;
		TxGetViewInset( &rcInset, NULL );
		rcArea.right 	-= rcInset.right;
		rcArea.bottom 	-= rcInset.bottom;
		rcArea.left 	+= rcInset.left;
		rcArea.top 		+= rcInset.top;
	}

	// Caller wants screen coordinates?
	if ( !(Type & tomClientCoord) )
	{
		POINT	ptTopLeft = {rcArea.left, rcArea.top};
		POINT	ptBottomRight = {rcArea.right, rcArea.bottom};

		if (!TxClientToScreen(&ptTopLeft) ||
			!TxClientToScreen(&ptBottomRight))
			return E_FAIL;			// It is unexpected for this to happen

		*pLeft		= ptTopLeft.x;
		*pTop		= ptTopLeft.y;
		*pRight		= ptBottomRight.x;
		*pBottom	= ptBottomRight.y;
	}
	else
	{
		*pLeft		= rcArea.left;
		*pTop		= rcArea.top;
		*pRight		= rcArea.right;
		*pBottom	= rcArea.bottom;
	}

	return NOERROR;
}

/*
 *	ITextDocument2::GetSelectionEx(ppSel) 
 *
 *	@mfunc
 *		Method to retrieve selection.
 *
 *	@rdesc
 *		HRESULT = selection ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelectionEx(
	ITextSelection **ppSel)			//@parm  Get Selection object
{	
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelectionEx");

	if (_fInPlaceActive)
		return GetSelection (ppSel);

	Assert("Getting selection while not active");

	if(!ppSel)
		return E_INVALIDARG;

	*ppSel = NULL;
	return S_FALSE;
}

/*
 *	ITextDocument2::GetWindow(phWnd) 
 *
 *	@mfunc
 *		Method to get the host window
 *
 *	@rdesc
 *		HRESULT = NOERROR if host return hWnd
 */
STDMETHODIMP CTxtEdit::GetWindow(
	long *phWnd)				//@parm hWnd
{
	if (!phWnd)
		return E_INVALIDARG;

	return TxGetWindow((HWND *)phWnd);
}

/*
 *	ITextDocument2::GetFEFlags(pFEFlags) 
 *
 *	@mfunc
 *		Method to get Host FE flags
 *
 *	@rdesc
 *		HRESULT = NOERROR if host returns FE Flags
 */
STDMETHODIMP CTxtEdit::GetFEFlags(
	long *pFEFlags)			//@parm FE Flags
{
	return TxGetFEFlags(pFEFlags);
}

/*
 *	ITextDocument2::UpdateWindow(void) 
 *
 *	@mfunc
 *		Method to update the RE window
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::UpdateWindow(void)
{
	TxUpdateWindow();
	return NOERROR;
}

/*
 *	ITextDocument2::CheckTextLimit(long cch, long *pcch) 
 *
 *	@mfunc
 *		Method to check if the count of characters to be added would
 *		exceed max. text limit.  The number of characters exced is returned
 *		in pcch
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::CheckTextLimit(
	long cch,			//@parm count of characters to be added			
	long *pcch)			//@parm return the number of characters exced text limit
{
	if(!pcch)
		return E_INVALIDARG;

	*pcch = 0;
	if (cch > 0)
	{
		DWORD	cchNew = (DWORD)(GetAdjustedTextLength() + cch);
		if(cchNew > TxGetMaxLength())
			*pcch = cchNew - TxGetMaxLength();
	}

	return NOERROR;
}

/*
 *	ITextDocument2::IMEInProgress(lMode) 
 *
 *	@mfunc
 *		Method for IME message filter to inform client that IME composition
 *		is in progress.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::IMEInProgress(
	long lMode)		//@parm current IME composition status
{
	if (lMode == tomFalse)
		_fIMEInProgress = 0;
	else if  (lMode == tomTrue)
		_fIMEInProgress = 1;

	return NOERROR;
}

/*
 *	ITextDocument2::SysBeep(void) 
 *
 *	@mfunc
 *		Method to generate system beep.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SysBeep(void)
{	
	Beep();
	return NOERROR;
}

/*
 *	ITextDocument2::Update(lMode) 
 *
 *	@mfunc
 *		Method for update the selection or caret.  If lMode is tomTrue, then
 *		scroll the caret into view.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Update(
	long lMode)		//@parm current IME composition status
{
	if (!_psel)
		return S_FALSE;

	_psel->Update(lMode == tomTrue ? TRUE : FALSE);

	return NOERROR;
}

/*
 *	ITextDocument2::Notify(lNotify) 
 *
 *	@mfunc
 *		Method for notifying the host for certain IME events
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Notify(
	long lNotify)		//@parm Notification code
{
	TxNotify(lNotify, NULL);

	return NOERROR;
}

/*
 *	ITextDocument2::GetDocumentFont(ppITextFont) 
 *
 *	@mfunc
 *		Method for getting the default document font
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::GetDocumentFont(
	ITextFont **ppFont)		//@parm get ITextFont object
{
	CTxtFont	*pTxtFont;

	if(!ppFont)
		return E_INVALIDARG;

	pTxtFont =  new CTxtFont(NULL);

	if (pTxtFont)
	{
		pTxtFont->_CF = *GetCharFormat(-1);
		pTxtFont->_dwMask = CFM_ALL2;
	}

	*ppFont = (ITextFont *) pTxtFont;

	return *ppFont ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument2::GetDocumentPara(ppITextPara) 
 *
 *	@mfunc
 *		Method for getting the default document para
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::GetDocumentPara(
	ITextPara **ppPara)		//@parm get ITextPara object
{
	CTxtPara	*pTxtPara;

	if(!ppPara)
		return E_INVALIDARG;

	pTxtPara = new CTxtPara(NULL);

	if (pTxtPara)
	{
		pTxtPara->_PF = *GetParaFormat(-1);
		pTxtPara->_dwMask = PFM_ALL2;
		pTxtPara->_PF._bTabCount = 0;
		pTxtPara->_PF._iTabs = -1;
	}

	*ppPara = (ITextPara *) pTxtPara;
	return *ppPara ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument2::GetCallManager(ppVoid) 
 *
 *	@mfunc
 *		Method for getting the call manager
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::GetCallManager(
	IUnknown **ppVoid)		//@parm get CallMgr object
{
	CCallMgr	*pCallMgr;

	if(!ppVoid)
		return E_INVALIDARG;

	pCallMgr = new CCallMgr(this);

	*ppVoid = (IUnknown *) pCallMgr;
	return *ppVoid ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument2::ReleaseCallManager(ppITextPara) 
 *
 *	@mfunc
 *		Method for getting the default document para
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::ReleaseCallManager(
	IUnknown *pVoid)		//@parm Call Manager object
{
	CCallMgr	*pCallMgr;

	if(!pVoid)
		return E_INVALIDARG;

	pCallMgr = (CCallMgr *)pVoid;

	delete pCallMgr;

	return NOERROR;
}

//----------------------- ITextDocument Helper Functions -----------------------
/*
 *	CTxtEdit::CloseFile (bSave)
 *
 *	@mfunc
 *		Method that closes the current document. If changes have been made
 *		in the current document since the last save and document file
 *		information exists, the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::CloseFile (
	BOOL bSave)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Close");

	CDocInfo *pDocInfo = _pDocInfo;

	if(pDocInfo)
	{
		if(bSave)									// Save current file if
			Save(NULL, 0, 0);						//  any changes made
	
		// FUTURE(BradO):  This code is very similar to the destructor code.
		// We have a problem here in that some of the CDocInfo information
		// should persist from Open to Close to Open (ex. default tab stop)
		// mixed with other per-Open/Close info.  A better job of abstracting
		// these two types of info would really clean up this code.

		if(pDocInfo->_pName)
		{
			SysFreeString(pDocInfo->_pName);		// Free filename BSTR
			pDocInfo->_pName = NULL;
		}

		if(pDocInfo->_hFile)
		{
			CloseHandle(pDocInfo->_hFile);			// Close file if open
			pDocInfo->_hFile = NULL;
		}
		pDocInfo->_wFlags = 0;
		pDocInfo->_wCpg = 0;

		pDocInfo->_lcid = 0;
		pDocInfo->_lcidfe = 0;

		if(pDocInfo->_lpstrLeadingPunct)
		{
			FreePv(pDocInfo->_lpstrLeadingPunct);
			pDocInfo->_lpstrLeadingPunct = NULL;
		}

		if(pDocInfo->_lpstrFollowingPunct)
		{
			FreePv(pDocInfo->_lpstrFollowingPunct);
			pDocInfo->_lpstrFollowingPunct = NULL;
		}
	}
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCID (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCID (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCID");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->_lcid = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCID (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCID (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->_lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCIDFE (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCIDFE (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCIDFE");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->_lcidfe = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCIDFE (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCIDFE (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->_lcidfe;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDocumentType(bDocType) 
 *
 *	@mfunc
 *		Property set method that sets the document's type (none-\ltrdoc-\rtldoc)
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::SetDocumentType (
	LONG DocType)		//@parm New document-type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDocumentType");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->_bDocType = (BYTE)DocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDocumentType (pDocType) 
 *
 *	@mfunc
 *		Property get method that gets the document type
 *
 *	@rdesc
 *		HRESULT = (!pDocType) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDocumentType (
	LONG *pDocType)		//@parm Out parm with document type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDocumentType");

	if(!pDocType)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pDocType = _pDocInfo->_bDocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetLeadingPunct (plpstrLeadingPunct)
 *
 *	@mfunc
 *		Retrieve leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrLeadingPunct>) ? E_INVALIDARG :
 *				  (no leading punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetLeadingPunct (
	LPSTR * plpstrLeadingPunct)		//@parm Out parm to receive leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetLeadingPunct");

	if(!plpstrLeadingPunct)
		return E_INVALIDARG;

	*plpstrLeadingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->_lpstrLeadingPunct)
		return S_FALSE;

	*plpstrLeadingPunct = _pDocInfo->_lpstrLeadingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetLeadingPunct (lpstrLeadingPunct)
 *
 *	@mfunc
 *		Set leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetLeadingPunct (
	LPSTR lpstrLeadingPunct)	//@parm In parm containing leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetLeadingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->_lpstrLeadingPunct)
		FreePv(pDocInfo->_lpstrLeadingPunct);

	if(lpstrLeadingPunct && *lpstrLeadingPunct)
		pDocInfo->_lpstrLeadingPunct = lpstrLeadingPunct;
	else
	{
		pDocInfo->_lpstrLeadingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::GetFollowingPunct (plpstrFollowingPunct)
 *
 *	@mfunc
 *		Retrieve following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrFollowingPunct>) ? E_INVALIDARG :
 *				  (no following punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetFollowingPunct (
	LPSTR * plpstrFollowingPunct)		//@parm Out parm to receive following 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetFollowingPunct");

	if(!plpstrFollowingPunct)
		return E_INVALIDARG;

	*plpstrFollowingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->_lpstrFollowingPunct)
		return S_FALSE;

	*plpstrFollowingPunct = _pDocInfo->_lpstrFollowingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetFollowingPunct (lpstrFollowingPunct)
 *
 *	@mfunc
 *		Set following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetFollowingPunct (
	LPSTR lpstrFollowingPunct)		//@parm In parm containing following 
									//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetFollowingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->_lpstrFollowingPunct)
		FreePv(pDocInfo->_lpstrFollowingPunct);

	if(lpstrFollowingPunct && *lpstrFollowingPunct)
		pDocInfo->_lpstrFollowingPunct = lpstrFollowingPunct;
	else
	{
		pDocInfo->_lpstrFollowingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::InitDocInfo()
 *
 *	@mfunc	initialize doc info structure
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CTxtEdit::InitDocInfo()
{
	_wZoomNumerator = _wZoomDenominator = 0;// Turn off zoom
	
	// Reset Vertical style
	DWORD dwBits = 0;

	_phost->TxGetPropertyBits(TXTBIT_VERTICAL, &dwBits);

	if (dwBits & TXTBIT_VERTICAL)
	{
		_fUseAtFont = TRUE;
		HandleSetTextFlow(tflowSW);
	}
	else
	{
		_fUseAtFont = FALSE;
		HandleSetTextFlow(tflowES);
	}

	if(_pDocInfo)
	{
		_pDocInfo->Init();
		return NOERROR;
	}

	return GetDocInfo() ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CTxtEdit::GetBackgroundType()
 *
 *	@mfunc
 *		Get background type
 *
 *	@rdesc
 *		Background type (only for main display)
 */
LONG CTxtEdit::GetBackgroundType()
{
	return _pDocInfo ? _pDocInfo->_nFillType : -1;
}

/*
 *	CTxtEdit::TxGetBackColor()
 *
 *	@mfunc
 *		Get background color
 *
 *	@rdesc
 *		Background color (only for main display)
 */
COLORREF CTxtEdit::TxGetBackColor() const
{
	return (_pDocInfo && _pDocInfo->_nFillType == 0)
		? _pDocInfo->_crColor : _phost->TxGetSysColor(COLOR_WINDOW);
}

//----------------------- CDocInfo related Functions -----------------------
/*
 *	CDocInfo::Init()
 *
 *	@mfunc
 *		Initializer for CDocInfo
 *
 *	@comment
 *		It is assumed that CDocInfo created by a new operator that zeroes
 *		the structure. This initializer is called by the constructor and
 *		by CTxtEdit::InitDocInfo().
 */
void CDocInfo::Init()
{
	_wCpg = (WORD)GetACP();
	_lcid = GetSystemDefaultLCID();

	if(IsFELCID(_lcid))
	{
		_lcidfe = _lcid;
		_lcid = MAKELCID(sLanguageEnglishUS, SORT_DEFAULT);
	}

	_dwDefaultTabStop = lDefaultTab;
	_bDocType = 0;
	InitBackground();
}

/*
 *	CDocInfo::InitBackground()
 *
 *	@mfunc
 *		Background initializer for CDocInfo
 */
void CDocInfo::InitBackground()
{
	_nFillType = -1;
	_sFillAngle = 0;
	if(_hBitmapBack)
		DeleteObject(_hBitmapBack);
	GlobalFree(_hdata);
	_hdata = NULL;
	_hBitmapBack = NULL;
}

/*
 *	CDocInfo::~CDocInfo
 *
 *	@mfunc	destructor for the docinfo class
 */
CDocInfo::~CDocInfo()
{
	if(_pName)
		SysFreeString(_pName);

	if(_hFile)
		CloseHandle(_hFile);

	FreePv(_lpstrLeadingPunct);
	FreePv(_lpstrFollowingPunct);
	FreePv(_prgColor);
	if(_hBitmapBack)
		DeleteObject(_hBitmapBack);
	GlobalFree(_hdata);
}

/*
 *	CTxtEdit::GetDocInfo ()
 *
 *	@mfunc
 *		If _pDocInfo is NULL, equate it to a new CDocInfo.  In either case
 *		return _pDocInfo
 *
 *	@rdesc
 *		CTxtEdit::_pDocInfo, the ptr to the CDocInfo object
 */
CDocInfo * CTxtEdit::GetDocInfo()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetDocInfo");

	if (!_pDocInfo)
		_pDocInfo = new CDocInfo();

	// It is the caller's responsiblity to notice that an error occurred
	// in the allocation of the CDocInfo object.
	return _pDocInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textstor.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for textstor.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __textstor_h__
#define __textstor_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITextStoreACP_FWD_DEFINED__
#define __ITextStoreACP_FWD_DEFINED__
typedef interface ITextStoreACP ITextStoreACP;
#endif 	/* __ITextStoreACP_FWD_DEFINED__ */


#ifndef __ITextStoreACPSink_FWD_DEFINED__
#define __ITextStoreACPSink_FWD_DEFINED__
typedef interface ITextStoreACPSink ITextStoreACPSink;
#endif 	/* __ITextStoreACPSink_FWD_DEFINED__ */


#ifndef __IAnchor_FWD_DEFINED__
#define __IAnchor_FWD_DEFINED__
typedef interface IAnchor IAnchor;
#endif 	/* __IAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchor_FWD_DEFINED__
#define __ITextStoreAnchor_FWD_DEFINED__
typedef interface ITextStoreAnchor ITextStoreAnchor;
#endif 	/* __ITextStoreAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorSink_FWD_DEFINED__
#define __ITextStoreAnchorSink_FWD_DEFINED__
typedef interface ITextStoreAnchorSink ITextStoreAnchorSink;
#endif 	/* __ITextStoreAnchorSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_textstor_0000 */
/* [local] */ 


DEFINE_GUID (GUID_TS_SERVICE_DATAOBJECT, 0x6086fbb5, 0xe225, 0x46ce, 0xa7, 0x70, 0xc1, 0xbb, 0xd3, 0xe0, 0x5d, 0x7b);
DEFINE_GUID (GUID_TS_SERVICE_ACCESSIBLE, 0xf9786200, 0xa5bf, 0x4a0f, 0x8c, 0x24, 0xfb, 0x16, 0xf5, 0xd1, 0xaa, 0xbb);
DEFINE_GUID (GUID_TS_SERVICE_ACTIVEX,    0xea937a50, 0xc9a6, 0x4b7d, 0x89, 0x4a, 0x49, 0xd9, 0x9b, 0x78, 0x48, 0x34);
#define TS_E_INVALIDPOS      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define TS_E_NOLOCK          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define TS_E_NOOBJECT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define TS_E_NOSERVICE       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define TS_E_NOINTERFACE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define TS_E_NOSELECTION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define TS_E_NOLAYOUT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define TS_E_INVALIDPOINT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define TS_E_SYNCHRONOUS     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define TS_E_READONLY        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define TS_E_FORMAT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020a)
#define TS_S_ASYNC           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0300)
#define	TS_AS_TEXT_CHANGE	( 0x1 )

#define	TS_AS_SEL_CHANGE	( 0x2 )

#define	TS_AS_LAYOUT_CHANGE	( 0x4 )

#define	TS_AS_ATTR_CHANGE	( 0x8 )

#define	TS_AS_STATUS_CHANGE	( 0x10 )

#define	TS_AS_ALL_SINKS	( TS_AS_TEXT_CHANGE | TS_AS_SEL_CHANGE | TS_AS_LAYOUT_CHANGE | TS_AS_ATTR_CHANGE | TS_AS_STATUS_CHANGE )

#define	TS_LF_SYNC	( 0x1 )

#define	TS_LF_READ	( 0x2 )

#define	TS_LF_READWRITE	( 0x6 )

#define	TS_SD_READONLY	( 0x1 )

#define	TS_SD_LOADING	( 0x2 )

#define	TS_SS_DISJOINTSEL	( 0x1 )

#define	TS_SS_REGIONS	( 0x2 )

#define	TS_SS_TRANSITORY	( 0x4 )

#define	TS_SS_NOHIDDENTEXT	( 0x8 )

#define	TS_SD_MASKALL	( TS_SD_READONLY | TS_SD_LOADING )

#define	TS_ST_CORRECTION	( 0x1 )

#define	TS_ST_COMPOSITION	( 0x2 )

#define	TS_IE_CORRECTION	( 0x1 )

#define	TS_IE_COMPOSITION	( 0x2 )

#define	TS_TC_CORRECTION	( 0x1 )

#define	TS_IAS_NOQUERY	( 0x1 )

#define	TS_IAS_QUERYONLY	( 0x2 )

typedef /* [uuid] */  DECLSPEC_UUID("fec4f516-c503-45b1-a5fd-7a3d8ab07049") struct TS_STATUS
    {
    DWORD dwDynamicFlags;
    DWORD dwStaticFlags;
    } 	TS_STATUS;

typedef /* [uuid] */  DECLSPEC_UUID("f3181bd6-bcf0-41d3-a81c-474b17ec38fb") struct TS_TEXTCHANGE
    {
    LONG acpStart;
    LONG acpOldEnd;
    LONG acpNewEnd;
    } 	TS_TEXTCHANGE;

typedef /* [public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("05fcf85b-5e9c-4c3e-ab71-29471d4f38e7") 
enum __MIDL___MIDL_itf_textstor_0000_0001
    {	TS_AE_NONE	= 0,
	TS_AE_START	= 1,
	TS_AE_END	= 2
    } 	TsActiveSelEnd;

typedef /* [uuid] */  DECLSPEC_UUID("7ecc3ffa-8f73-4d91-98ed-76f8ac5b1600") struct TS_SELECTIONSTYLE
    {
    TsActiveSelEnd ase;
    BOOL fInterimChar;
    } 	TS_SELECTIONSTYLE;

typedef /* [uuid] */  DECLSPEC_UUID("c4b9c33b-8a0d-4426-bebe-d444a4701fe9") struct TS_SELECTION_ACP
    {
    LONG acpStart;
    LONG acpEnd;
    TS_SELECTIONSTYLE style;
    } 	TS_SELECTION_ACP;

typedef /* [uuid] */  DECLSPEC_UUID("b03413d2-0723-4c4e-9e08-2e9c1ff3772b") struct TS_SELECTION_ANCHOR
    {
    IAnchor *paStart;
    IAnchor *paEnd;
    TS_SELECTIONSTYLE style;
    } 	TS_SELECTION_ANCHOR;

#define	TS_DEFAULT_SELECTION	( ( ULONG  )-1 )

#define	GXFPF_ROUND_NEAREST	( 0x1 )

#define	GXFPF_NEAREST	( 0x2 )

#define	TS_CHAR_EMBEDDED	( 0xfffc )

#define	TS_CHAR_REGION	( 0 )

#define	TS_CHAR_REPLACEMENT	( 0xfffd )

typedef /* [uuid] */  DECLSPEC_UUID("ef3457d9-8446-49a7-a9e6-b50d9d5f3fd9") GUID TS_ATTRID;

typedef /* [uuid] */  DECLSPEC_UUID("2cc2b33f-1174-4507-b8d9-5bc0eb37c197") struct TS_ATTRVAL
    {
    TS_ATTRID idAttr;
    DWORD dwOverlapId;
    VARIANT varValue;
    } 	TS_ATTRVAL;

#define	TS_ATTR_FIND_BACKWARDS	( 0x1 )

#define	TS_ATTR_FIND_WANT_OFFSET	( 0x2 )

#define	TS_ATTR_FIND_UPDATESTART	( 0x4 )

#define	TS_ATTR_FIND_WANT_VALUE	( 0x8 )

#define	TS_ATTR_FIND_WANT_END	( 0x10 )

#define	TS_ATTR_FIND_HIDDEN	( 0x20 )

typedef /* [uuid] */  DECLSPEC_UUID("1faf509e-44c1-458e-950a-38a96705a62b") DWORD TsViewCookie;

#define	TS_VCOOKIE_NUL	( 0xffffffff )

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("7899d7c4-5f07-493c-a89a-fac8e777f476") 
enum __MIDL___MIDL_itf_textstor_0000_0002
    {	TS_LC_CREATE	= 0,
	TS_LC_CHANGE	= 1,
	TS_LC_DESTROY	= 2
    } 	TsLayoutCode;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("033b0df0-f193-4170-b47b-141afc247878") 
enum __MIDL___MIDL_itf_textstor_0000_0003
    {	TS_RT_PLAIN	= 0,
	TS_RT_HIDDEN	= TS_RT_PLAIN + 1,
	TS_RT_OPAQUE	= TS_RT_HIDDEN + 1
    } 	TsRunType;

typedef /* [uuid] */  DECLSPEC_UUID("a6231949-37c5-4b74-a24e-2a26c327201d") struct TS_RUNINFO
    {
    ULONG uCount;
    TsRunType type;
    } 	TS_RUNINFO;



extern RPC_IF_HANDLE __MIDL_itf_textstor_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_textstor_0000_v0_0_s_ifspec;

#ifndef __ITextStoreACP_INTERFACE_DEFINED__
#define __ITextStoreACP_INTERFACE_DEFINED__

/* interface ITextStoreACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28888fe3-c2a0-483a-a3ea-8cb1ce51ff3d")
    ITextStoreACP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSink( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [in] */ DWORD dwMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSink( 
            /* [in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestLock( 
            /* [in] */ DWORD dwLockFlags,
            /* [out] */ HRESULT *phrSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TS_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInsert( 
            /* [in] */ LONG acpTestStart,
            /* [in] */ LONG acpTestEnd,
            /* [in] */ ULONG cch,
            /* [out] */ LONG *pacpResultStart,
            /* [out] */ LONG *pacpResultEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_SELECTION_ACP *pSelection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TS_SELECTION_ACP *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [length_is][size_is][out] */ WCHAR *pchPlain,
            /* [in] */ ULONG cchPlainReq,
            /* [out] */ ULONG *pcchPlainRet,
            /* [length_is][size_is][out] */ TS_RUNINFO *prgRunInfo,
            /* [in] */ ULONG cRunInfoReq,
            /* [out] */ ULONG *pcRunInfoRet,
            /* [out] */ LONG *pacpNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ TS_TEXTCHANGE *pChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ IDataObject **ppDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedded( 
            /* [in] */ LONG acpPos,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInsertEmbedded( 
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbedded( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ TS_TEXTCHANGE *pChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertTextAtSelection( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ LONG *pacpStart,
            /* [out] */ LONG *pacpEnd,
            /* [out] */ TS_TEXTCHANGE *pChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbeddedAtSelection( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ LONG *pacpStart,
            /* [out] */ LONG *pacpEnd,
            /* [out] */ TS_TEXTCHANGE *pChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestSupportedAttrs( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestAttrsAtPosition( 
            /* [in] */ LONG acpPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestAttrsTransitioningAtPosition( 
            /* [in] */ LONG acpPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextAttrTransition( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpHalt,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacpNext,
            /* [out] */ BOOL *pfFound,
            /* [out] */ LONG *plFoundOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetrieveRequestedAttrs( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndACP( 
            /* [out] */ LONG *pacp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveView( 
            /* [out] */ TsViewCookie *pvcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetACPFromPoint( 
            /* [in] */ TsViewCookie vcView,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ TsViewCookie vcView,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [in] */ TsViewCookie vcView,
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [in] */ TsViewCookie vcView,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSink )( 
            ITextStoreACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [in] */ DWORD dwMask);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSink )( 
            ITextStoreACP * This,
            /* [in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *RequestLock )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwLockFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITextStoreACP * This,
            /* [out] */ TS_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsert )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpTestStart,
            /* [in] */ LONG acpTestEnd,
            /* [in] */ ULONG cch,
            /* [out] */ LONG *pacpResultStart,
            /* [out] */ LONG *pacpResultEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITextStoreACP * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_SELECTION_ACP *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITextStoreACP * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TS_SELECTION_ACP *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [length_is][size_is][out] */ WCHAR *pchPlain,
            /* [in] */ ULONG cchPlainReq,
            /* [out] */ ULONG *pcchPlainRet,
            /* [length_is][size_is][out] */ TS_RUNINFO *prgRunInfo,
            /* [in] */ ULONG cRunInfoReq,
            /* [out] */ ULONG *pcRunInfoRet,
            /* [out] */ LONG *pacpNext);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ TS_TEXTCHANGE *pChange);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpPos,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsertEmbedded )( 
            ITextStoreACP * This,
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ TS_TEXTCHANGE *pChange);
        
        HRESULT ( STDMETHODCALLTYPE *InsertTextAtSelection )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ LONG *pacpStart,
            /* [out] */ LONG *pacpEnd,
            /* [out] */ TS_TEXTCHANGE *pChange);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbeddedAtSelection )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ LONG *pacpStart,
            /* [out] */ LONG *pacpEnd,
            /* [out] */ TS_TEXTCHANGE *pChange);
        
        HRESULT ( STDMETHODCALLTYPE *RequestSupportedAttrs )( 
            ITextStoreACP * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAttrsAtPosition )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAttrsTransitioningAtPosition )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextAttrTransition )( 
            ITextStoreACP * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpHalt,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacpNext,
            /* [out] */ BOOL *pfFound,
            /* [out] */ LONG *plFoundOffset);
        
        HRESULT ( STDMETHODCALLTYPE *RetrieveRequestedAttrs )( 
            ITextStoreACP * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndACP )( 
            ITextStoreACP * This,
            /* [out] */ LONG *pacp);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITextStoreACP * This,
            /* [out] */ TsViewCookie *pvcView);
        
        HRESULT ( STDMETHODCALLTYPE *GetACPFromPoint )( 
            ITextStoreACP * This,
            /* [in] */ TsViewCookie vcView,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITextStoreACP * This,
            /* [in] */ TsViewCookie vcView,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITextStoreACP * This,
            /* [in] */ TsViewCookie vcView,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITextStoreACP * This,
            /* [in] */ TsViewCookie vcView,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } ITextStoreACPVtbl;

    interface ITextStoreACP
    {
        CONST_VTBL struct ITextStoreACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreACP_AdviseSink(This,riid,punk,dwMask)	\
    (This)->lpVtbl -> AdviseSink(This,riid,punk,dwMask)

#define ITextStoreACP_UnadviseSink(This,punk)	\
    (This)->lpVtbl -> UnadviseSink(This,punk)

#define ITextStoreACP_RequestLock(This,dwLockFlags,phrSession)	\
    (This)->lpVtbl -> RequestLock(This,dwLockFlags,phrSession)

#define ITextStoreACP_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITextStoreACP_QueryInsert(This,acpTestStart,acpTestEnd,cch,pacpResultStart,pacpResultEnd)	\
    (This)->lpVtbl -> QueryInsert(This,acpTestStart,acpTestEnd,cch,pacpResultStart,pacpResultEnd)

#define ITextStoreACP_GetSelection(This,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ulIndex,ulCount,pSelection,pcFetched)

#define ITextStoreACP_SetSelection(This,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ulCount,pSelection)

#define ITextStoreACP_GetText(This,acpStart,acpEnd,pchPlain,cchPlainReq,pcchPlainRet,prgRunInfo,cRunInfoReq,pcRunInfoRet,pacpNext)	\
    (This)->lpVtbl -> GetText(This,acpStart,acpEnd,pchPlain,cchPlainReq,pcchPlainRet,prgRunInfo,cRunInfoReq,pcRunInfoRet,pacpNext)

#define ITextStoreACP_SetText(This,dwFlags,acpStart,acpEnd,pchText,cch,pChange)	\
    (This)->lpVtbl -> SetText(This,dwFlags,acpStart,acpEnd,pchText,cch,pChange)

#define ITextStoreACP_GetFormattedText(This,acpStart,acpEnd,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,acpStart,acpEnd,ppDataObject)

#define ITextStoreACP_GetEmbedded(This,acpPos,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,acpPos,rguidService,riid,ppunk)

#define ITextStoreACP_QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)	\
    (This)->lpVtbl -> QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)

#define ITextStoreACP_InsertEmbedded(This,dwFlags,acpStart,acpEnd,pDataObject,pChange)	\
    (This)->lpVtbl -> InsertEmbedded(This,dwFlags,acpStart,acpEnd,pDataObject,pChange)

#define ITextStoreACP_InsertTextAtSelection(This,dwFlags,pchText,cch,pacpStart,pacpEnd,pChange)	\
    (This)->lpVtbl -> InsertTextAtSelection(This,dwFlags,pchText,cch,pacpStart,pacpEnd,pChange)

#define ITextStoreACP_InsertEmbeddedAtSelection(This,dwFlags,pDataObject,pacpStart,pacpEnd,pChange)	\
    (This)->lpVtbl -> InsertEmbeddedAtSelection(This,dwFlags,pDataObject,pacpStart,pacpEnd,pChange)

#define ITextStoreACP_RequestSupportedAttrs(This,dwFlags,cFilterAttrs,paFilterAttrs)	\
    (This)->lpVtbl -> RequestSupportedAttrs(This,dwFlags,cFilterAttrs,paFilterAttrs)

#define ITextStoreACP_RequestAttrsAtPosition(This,acpPos,cFilterAttrs,paFilterAttrs,dwFlags)	\
    (This)->lpVtbl -> RequestAttrsAtPosition(This,acpPos,cFilterAttrs,paFilterAttrs,dwFlags)

#define ITextStoreACP_RequestAttrsTransitioningAtPosition(This,acpPos,cFilterAttrs,paFilterAttrs,dwFlags)	\
    (This)->lpVtbl -> RequestAttrsTransitioningAtPosition(This,acpPos,cFilterAttrs,paFilterAttrs,dwFlags)

#define ITextStoreACP_FindNextAttrTransition(This,acpStart,acpHalt,cFilterAttrs,paFilterAttrs,dwFlags,pacpNext,pfFound,plFoundOffset)	\
    (This)->lpVtbl -> FindNextAttrTransition(This,acpStart,acpHalt,cFilterAttrs,paFilterAttrs,dwFlags,pacpNext,pfFound,plFoundOffset)

#define ITextStoreACP_RetrieveRequestedAttrs(This,ulCount,paAttrVals,pcFetched)	\
    (This)->lpVtbl -> RetrieveRequestedAttrs(This,ulCount,paAttrVals,pcFetched)

#define ITextStoreACP_GetEndACP(This,pacp)	\
    (This)->lpVtbl -> GetEndACP(This,pacp)

#define ITextStoreACP_GetActiveView(This,pvcView)	\
    (This)->lpVtbl -> GetActiveView(This,pvcView)

#define ITextStoreACP_GetACPFromPoint(This,vcView,ptScreen,dwFlags,pacp)	\
    (This)->lpVtbl -> GetACPFromPoint(This,vcView,ptScreen,dwFlags,pacp)

#define ITextStoreACP_GetTextExt(This,vcView,acpStart,acpEnd,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,vcView,acpStart,acpEnd,prc,pfClipped)

#define ITextStoreACP_GetScreenExt(This,vcView,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,vcView,prc)

#define ITextStoreACP_GetWnd(This,vcView,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,vcView,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreACP_AdviseSink_Proxy( 
    ITextStoreACP * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk,
    /* [in] */ DWORD dwMask);


void __RPC_STUB ITextStoreACP_AdviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_UnadviseSink_Proxy( 
    ITextStoreACP * This,
    /* [in] */ IUnknown *punk);


void __RPC_STUB ITextStoreACP_UnadviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_RequestLock_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwLockFlags,
    /* [out] */ HRESULT *phrSession);


void __RPC_STUB ITextStoreACP_RequestLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetStatus_Proxy( 
    ITextStoreACP * This,
    /* [out] */ TS_STATUS *pdcs);


void __RPC_STUB ITextStoreACP_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_QueryInsert_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpTestStart,
    /* [in] */ LONG acpTestEnd,
    /* [in] */ ULONG cch,
    /* [out] */ LONG *pacpResultStart,
    /* [out] */ LONG *pacpResultEnd);


void __RPC_STUB ITextStoreACP_QueryInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetSelection_Proxy( 
    ITextStoreACP * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TS_SELECTION_ACP *pSelection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITextStoreACP_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_SetSelection_Proxy( 
    ITextStoreACP * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const TS_SELECTION_ACP *pSelection);


void __RPC_STUB ITextStoreACP_SetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetText_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [length_is][size_is][out] */ WCHAR *pchPlain,
    /* [in] */ ULONG cchPlainReq,
    /* [out] */ ULONG *pcchPlainRet,
    /* [length_is][size_is][out] */ TS_RUNINFO *prgRunInfo,
    /* [in] */ ULONG cRunInfoReq,
    /* [out] */ ULONG *pcRunInfoRet,
    /* [out] */ LONG *pacpNext);


void __RPC_STUB ITextStoreACP_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_SetText_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ ULONG cch,
    /* [out] */ TS_TEXTCHANGE *pChange);


void __RPC_STUB ITextStoreACP_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetFormattedText_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ IDataObject **ppDataObject);


void __RPC_STUB ITextStoreACP_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetEmbedded_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpPos,
    /* [in] */ REFGUID rguidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITextStoreACP_GetEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_QueryInsertEmbedded_Proxy( 
    ITextStoreACP * This,
    /* [in] */ const GUID *pguidService,
    /* [in] */ const FORMATETC *pFormatEtc,
    /* [out] */ BOOL *pfInsertable);


void __RPC_STUB ITextStoreACP_QueryInsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_InsertEmbedded_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [in] */ IDataObject *pDataObject,
    /* [out] */ TS_TEXTCHANGE *pChange);


void __RPC_STUB ITextStoreACP_InsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_InsertTextAtSelection_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ ULONG cch,
    /* [out] */ LONG *pacpStart,
    /* [out] */ LONG *pacpEnd,
    /* [out] */ TS_TEXTCHANGE *pChange);


void __RPC_STUB ITextStoreACP_InsertTextAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_InsertEmbeddedAtSelection_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject,
    /* [out] */ LONG *pacpStart,
    /* [out] */ LONG *pacpEnd,
    /* [out] */ TS_TEXTCHANGE *pChange);


void __RPC_STUB ITextStoreACP_InsertEmbeddedAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_RequestSupportedAttrs_Proxy( 
    ITextStoreACP * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs);


void __RPC_STUB ITextStoreACP_RequestSupportedAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_RequestAttrsAtPosition_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpPos,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreACP_RequestAttrsAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_RequestAttrsTransitioningAtPosition_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpPos,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreACP_RequestAttrsTransitioningAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_FindNextAttrTransition_Proxy( 
    ITextStoreACP * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpHalt,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LONG *pacpNext,
    /* [out] */ BOOL *pfFound,
    /* [out] */ LONG *plFoundOffset);


void __RPC_STUB ITextStoreACP_FindNextAttrTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_RetrieveRequestedAttrs_Proxy( 
    ITextStoreACP * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITextStoreACP_RetrieveRequestedAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetEndACP_Proxy( 
    ITextStoreACP * This,
    /* [out] */ LONG *pacp);


void __RPC_STUB ITextStoreACP_GetEndACP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetActiveView_Proxy( 
    ITextStoreACP * This,
    /* [out] */ TsViewCookie *pvcView);


void __RPC_STUB ITextStoreACP_GetActiveView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetACPFromPoint_Proxy( 
    ITextStoreACP * This,
    /* [in] */ TsViewCookie vcView,
    /* [in] */ const POINT *ptScreen,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LONG *pacp);


void __RPC_STUB ITextStoreACP_GetACPFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetTextExt_Proxy( 
    ITextStoreACP * This,
    /* [in] */ TsViewCookie vcView,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITextStoreACP_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetScreenExt_Proxy( 
    ITextStoreACP * This,
    /* [in] */ TsViewCookie vcView,
    /* [out] */ RECT *prc);


void __RPC_STUB ITextStoreACP_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACP_GetWnd_Proxy( 
    ITextStoreACP * This,
    /* [in] */ TsViewCookie vcView,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITextStoreACP_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreACP_INTERFACE_DEFINED__ */


#ifndef __ITextStoreACPSink_INTERFACE_DEFINED__
#define __ITextStoreACPSink_INTERFACE_DEFINED__

/* interface ITextStoreACPSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreACPSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22d44c94-a419-4542-a272-ae26093ececf")
    ITextStoreACPSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTextChange( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ const TS_TEXTCHANGE *pChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( 
            /* [in] */ TsLayoutCode lcode,
            /* [in] */ TsViewCookie vcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAttrsChange( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [in] */ ULONG cAttrs,
            /* [size_is][in] */ const TS_ATTRID *paAttrs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLockGranted( 
            /* [in] */ DWORD dwLockFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStartEditTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndEditTransaction( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreACPSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreACPSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreACPSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreACPSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextChange )( 
            ITextStoreACPSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ const TS_TEXTCHANGE *pChange);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChange )( 
            ITextStoreACPSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITextStoreACPSink * This,
            /* [in] */ TsLayoutCode lcode,
            /* [in] */ TsViewCookie vcView);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITextStoreACPSink * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnAttrsChange )( 
            ITextStoreACPSink * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [in] */ ULONG cAttrs,
            /* [size_is][in] */ const TS_ATTRID *paAttrs);
        
        HRESULT ( STDMETHODCALLTYPE *OnLockGranted )( 
            ITextStoreACPSink * This,
            /* [in] */ DWORD dwLockFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartEditTransaction )( 
            ITextStoreACPSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEditTransaction )( 
            ITextStoreACPSink * This);
        
        END_INTERFACE
    } ITextStoreACPSinkVtbl;

    interface ITextStoreACPSink
    {
        CONST_VTBL struct ITextStoreACPSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreACPSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreACPSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreACPSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreACPSink_OnTextChange(This,dwFlags,pChange)	\
    (This)->lpVtbl -> OnTextChange(This,dwFlags,pChange)

#define ITextStoreACPSink_OnSelectionChange(This)	\
    (This)->lpVtbl -> OnSelectionChange(This)

#define ITextStoreACPSink_OnLayoutChange(This,lcode,vcView)	\
    (This)->lpVtbl -> OnLayoutChange(This,lcode,vcView)

#define ITextStoreACPSink_OnStatusChange(This,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,dwFlags)

#define ITextStoreACPSink_OnAttrsChange(This,acpStart,acpEnd,cAttrs,paAttrs)	\
    (This)->lpVtbl -> OnAttrsChange(This,acpStart,acpEnd,cAttrs,paAttrs)

#define ITextStoreACPSink_OnLockGranted(This,dwLockFlags)	\
    (This)->lpVtbl -> OnLockGranted(This,dwLockFlags)

#define ITextStoreACPSink_OnStartEditTransaction(This)	\
    (This)->lpVtbl -> OnStartEditTransaction(This)

#define ITextStoreACPSink_OnEndEditTransaction(This)	\
    (This)->lpVtbl -> OnEndEditTransaction(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnTextChange_Proxy( 
    ITextStoreACPSink * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ const TS_TEXTCHANGE *pChange);


void __RPC_STUB ITextStoreACPSink_OnTextChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnSelectionChange_Proxy( 
    ITextStoreACPSink * This);


void __RPC_STUB ITextStoreACPSink_OnSelectionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnLayoutChange_Proxy( 
    ITextStoreACPSink * This,
    /* [in] */ TsLayoutCode lcode,
    /* [in] */ TsViewCookie vcView);


void __RPC_STUB ITextStoreACPSink_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnStatusChange_Proxy( 
    ITextStoreACPSink * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreACPSink_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnAttrsChange_Proxy( 
    ITextStoreACPSink * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [in] */ ULONG cAttrs,
    /* [size_is][in] */ const TS_ATTRID *paAttrs);


void __RPC_STUB ITextStoreACPSink_OnAttrsChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnLockGranted_Proxy( 
    ITextStoreACPSink * This,
    /* [in] */ DWORD dwLockFlags);


void __RPC_STUB ITextStoreACPSink_OnLockGranted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnStartEditTransaction_Proxy( 
    ITextStoreACPSink * This);


void __RPC_STUB ITextStoreACPSink_OnStartEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPSink_OnEndEditTransaction_Proxy( 
    ITextStoreACPSink * This);


void __RPC_STUB ITextStoreACPSink_OnEndEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreACPSink_INTERFACE_DEFINED__ */


#ifndef __IAnchor_INTERFACE_DEFINED__
#define __IAnchor_INTERFACE_DEFINED__

/* interface IAnchor */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("daa8601e-7695-426f-9bb7-498a6aa64b68") 
enum __MIDL_IAnchor_0001
    {	TS_GR_BACKWARD	= 0,
	TS_GR_FORWARD	= 1
    } 	TsGravity;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("898e19df-4fb4-4af3-8daf-9b3c1145c79d") 
enum __MIDL_IAnchor_0002
    {	TS_SD_BACKWARD	= 0,
	TS_SD_FORWARD	= 1
    } 	TsShiftDir;

#define	TS_CH_PRECEDING_DEL	( 1 )

#define	TS_CH_FOLLOWING_DEL	( 2 )

#define	TS_SHIFT_COUNT_HIDDEN	( 0x1 )

#define	TS_SHIFT_HALT_HIDDEN	( 0x2 )

#define	TS_SHIFT_HALT_VISIBLE	( 0x4 )

#define	TS_SHIFT_COUNT_ONLY	( 0x8 )


EXTERN_C const IID IID_IAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0feb7e34-5a60-4356-8ef7-abdec2ff7cf8")
    IAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGravity( 
            /* [in] */ TsGravity gravity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGravity( 
            /* [out] */ TsGravity *pgravity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAnchor *paWith,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ IAnchor *paWith,
            /* [out] */ LONG *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shift( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [in] */ IAnchor *paHaltAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftTo( 
            /* [in] */ IAnchor *paSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftRegion( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ TsShiftDir dir,
            /* [out] */ BOOL *pfNoRegion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChangeHistoryMask( 
            /* [in] */ DWORD dwMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeHistory( 
            /* [out] */ DWORD *pdwHistory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearChangeHistory( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAnchor **ppaClone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            IAnchor * This,
            /* [in] */ TsGravity gravity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            IAnchor * This,
            /* [out] */ TsGravity *pgravity);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAnchor * This,
            /* [in] */ IAnchor *paWith,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IAnchor * This,
            /* [in] */ IAnchor *paWith,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *Shift )( 
            IAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [in] */ IAnchor *paHaltAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftTo )( 
            IAnchor * This,
            /* [in] */ IAnchor *paSite);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftRegion )( 
            IAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ TsShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *SetChangeHistoryMask )( 
            IAnchor * This,
            /* [in] */ DWORD dwMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeHistory )( 
            IAnchor * This,
            /* [out] */ DWORD *pdwHistory);
        
        HRESULT ( STDMETHODCALLTYPE *ClearChangeHistory )( 
            IAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAnchor * This,
            /* [out] */ IAnchor **ppaClone);
        
        END_INTERFACE
    } IAnchorVtbl;

    interface IAnchor
    {
        CONST_VTBL struct IAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnchor_SetGravity(This,gravity)	\
    (This)->lpVtbl -> SetGravity(This,gravity)

#define IAnchor_GetGravity(This,pgravity)	\
    (This)->lpVtbl -> GetGravity(This,pgravity)

#define IAnchor_IsEqual(This,paWith,pfEqual)	\
    (This)->lpVtbl -> IsEqual(This,paWith,pfEqual)

#define IAnchor_Compare(This,paWith,plResult)	\
    (This)->lpVtbl -> Compare(This,paWith,plResult)

#define IAnchor_Shift(This,dwFlags,cchReq,pcch,paHaltAnchor)	\
    (This)->lpVtbl -> Shift(This,dwFlags,cchReq,pcch,paHaltAnchor)

#define IAnchor_ShiftTo(This,paSite)	\
    (This)->lpVtbl -> ShiftTo(This,paSite)

#define IAnchor_ShiftRegion(This,dwFlags,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftRegion(This,dwFlags,dir,pfNoRegion)

#define IAnchor_SetChangeHistoryMask(This,dwMask)	\
    (This)->lpVtbl -> SetChangeHistoryMask(This,dwMask)

#define IAnchor_GetChangeHistory(This,pdwHistory)	\
    (This)->lpVtbl -> GetChangeHistory(This,pdwHistory)

#define IAnchor_ClearChangeHistory(This)	\
    (This)->lpVtbl -> ClearChangeHistory(This)

#define IAnchor_Clone(This,ppaClone)	\
    (This)->lpVtbl -> Clone(This,ppaClone)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAnchor_SetGravity_Proxy( 
    IAnchor * This,
    /* [in] */ TsGravity gravity);


void __RPC_STUB IAnchor_SetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_GetGravity_Proxy( 
    IAnchor * This,
    /* [out] */ TsGravity *pgravity);


void __RPC_STUB IAnchor_GetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_IsEqual_Proxy( 
    IAnchor * This,
    /* [in] */ IAnchor *paWith,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IAnchor_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_Compare_Proxy( 
    IAnchor * This,
    /* [in] */ IAnchor *paWith,
    /* [out] */ LONG *plResult);


void __RPC_STUB IAnchor_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_Shift_Proxy( 
    IAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LONG cchReq,
    /* [out] */ LONG *pcch,
    /* [in] */ IAnchor *paHaltAnchor);


void __RPC_STUB IAnchor_Shift_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_ShiftTo_Proxy( 
    IAnchor * This,
    /* [in] */ IAnchor *paSite);


void __RPC_STUB IAnchor_ShiftTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_ShiftRegion_Proxy( 
    IAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ TsShiftDir dir,
    /* [out] */ BOOL *pfNoRegion);


void __RPC_STUB IAnchor_ShiftRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_SetChangeHistoryMask_Proxy( 
    IAnchor * This,
    /* [in] */ DWORD dwMask);


void __RPC_STUB IAnchor_SetChangeHistoryMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_GetChangeHistory_Proxy( 
    IAnchor * This,
    /* [out] */ DWORD *pdwHistory);


void __RPC_STUB IAnchor_GetChangeHistory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_ClearChangeHistory_Proxy( 
    IAnchor * This);


void __RPC_STUB IAnchor_ClearChangeHistory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnchor_Clone_Proxy( 
    IAnchor * This,
    /* [out] */ IAnchor **ppaClone);


void __RPC_STUB IAnchor_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchor_INTERFACE_DEFINED__
#define __ITextStoreAnchor_INTERFACE_DEFINED__

/* interface ITextStoreAnchor */
/* [unique][uuid][object] */ 

#define	TS_GTA_HIDDEN	( 0x1 )

#define	TS_GEA_HIDDEN	( 0x1 )


EXTERN_C const IID IID_ITextStoreAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b2077b0-5f18-4dec-bee9-3cc722f5dfe0")
    ITextStoreAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSink( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [in] */ DWORD dwMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSink( 
            /* [in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestLock( 
            /* [in] */ DWORD dwLockFlags,
            /* [out] */ HRESULT *phrSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TS_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInsert( 
            /* [in] */ IAnchor *paTestStart,
            /* [in] */ IAnchor *paTestEnd,
            /* [in] */ ULONG cch,
            /* [out] */ IAnchor **ppaResultStart,
            /* [out] */ IAnchor **ppaResultEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_SELECTION_ANCHOR *pSelection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TS_SELECTION_ANCHOR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchReq,
            /* [out] */ ULONG *pcch,
            /* [in] */ BOOL fUpdateAnchor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ IDataObject **ppDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedded( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paPos,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbedded( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ IDataObject *pDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestSupportedAttrs( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestAttrsAtPosition( 
            /* [in] */ IAnchor *paPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestAttrsTransitioningAtPosition( 
            /* [in] */ IAnchor *paPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextAttrTransition( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paHalt,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfFound,
            /* [out] */ LONG *plFoundOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetrieveRequestedAttrs( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStart( 
            /* [out] */ IAnchor **ppaStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnd( 
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveView( 
            /* [out] */ TsViewCookie *pvcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAnchorFromPoint( 
            /* [in] */ TsViewCookie vcView,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAnchor **ppaSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ TsViewCookie vcView,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [in] */ TsViewCookie vcView,
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [in] */ TsViewCookie vcView,
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInsertEmbedded( 
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertTextAtSelection( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbeddedAtSelection( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSink )( 
            ITextStoreAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [in] */ DWORD dwMask);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSink )( 
            ITextStoreAnchor * This,
            /* [in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *RequestLock )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwLockFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITextStoreAnchor * This,
            /* [out] */ TS_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsert )( 
            ITextStoreAnchor * This,
            /* [in] */ IAnchor *paTestStart,
            /* [in] */ IAnchor *paTestEnd,
            /* [in] */ ULONG cch,
            /* [out] */ IAnchor **ppaResultStart,
            /* [out] */ IAnchor **ppaResultEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITextStoreAnchor * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_SELECTION_ANCHOR *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITextStoreAnchor * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TS_SELECTION_ANCHOR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchReq,
            /* [out] */ ULONG *pcch,
            /* [in] */ BOOL fUpdateAnchor);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITextStoreAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paPos,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *RequestSupportedAttrs )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAttrsAtPosition )( 
            ITextStoreAnchor * This,
            /* [in] */ IAnchor *paPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAttrsTransitioningAtPosition )( 
            ITextStoreAnchor * This,
            /* [in] */ IAnchor *paPos,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextAttrTransition )( 
            ITextStoreAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paHalt,
            /* [in] */ ULONG cFilterAttrs,
            /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfFound,
            /* [out] */ LONG *plFoundOffset);
        
        HRESULT ( STDMETHODCALLTYPE *RetrieveRequestedAttrs )( 
            ITextStoreAnchor * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITextStoreAnchor * This,
            /* [out] */ IAnchor **ppaStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITextStoreAnchor * This,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITextStoreAnchor * This,
            /* [out] */ TsViewCookie *pvcView);
        
        HRESULT ( STDMETHODCALLTYPE *GetAnchorFromPoint )( 
            ITextStoreAnchor * This,
            /* [in] */ TsViewCookie vcView,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IAnchor **ppaSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITextStoreAnchor * This,
            /* [in] */ TsViewCookie vcView,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITextStoreAnchor * This,
            /* [in] */ TsViewCookie vcView,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITextStoreAnchor * This,
            /* [in] */ TsViewCookie vcView,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsertEmbedded )( 
            ITextStoreAnchor * This,
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable);
        
        HRESULT ( STDMETHODCALLTYPE *InsertTextAtSelection )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ ULONG cch,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbeddedAtSelection )( 
            ITextStoreAnchor * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        END_INTERFACE
    } ITextStoreAnchorVtbl;

    interface ITextStoreAnchor
    {
        CONST_VTBL struct ITextStoreAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchor_AdviseSink(This,riid,punk,dwMask)	\
    (This)->lpVtbl -> AdviseSink(This,riid,punk,dwMask)

#define ITextStoreAnchor_UnadviseSink(This,punk)	\
    (This)->lpVtbl -> UnadviseSink(This,punk)

#define ITextStoreAnchor_RequestLock(This,dwLockFlags,phrSession)	\
    (This)->lpVtbl -> RequestLock(This,dwLockFlags,phrSession)

#define ITextStoreAnchor_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITextStoreAnchor_QueryInsert(This,paTestStart,paTestEnd,cch,ppaResultStart,ppaResultEnd)	\
    (This)->lpVtbl -> QueryInsert(This,paTestStart,paTestEnd,cch,ppaResultStart,ppaResultEnd)

#define ITextStoreAnchor_GetSelection(This,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ulIndex,ulCount,pSelection,pcFetched)

#define ITextStoreAnchor_SetSelection(This,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ulCount,pSelection)

#define ITextStoreAnchor_GetText(This,dwFlags,paStart,paEnd,pchText,cchReq,pcch,fUpdateAnchor)	\
    (This)->lpVtbl -> GetText(This,dwFlags,paStart,paEnd,pchText,cchReq,pcch,fUpdateAnchor)

#define ITextStoreAnchor_SetText(This,dwFlags,paStart,paEnd,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,dwFlags,paStart,paEnd,pchText,cch)

#define ITextStoreAnchor_GetFormattedText(This,paStart,paEnd,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,paStart,paEnd,ppDataObject)

#define ITextStoreAnchor_GetEmbedded(This,dwFlags,paPos,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,dwFlags,paPos,rguidService,riid,ppunk)

#define ITextStoreAnchor_InsertEmbedded(This,dwFlags,paStart,paEnd,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,dwFlags,paStart,paEnd,pDataObject)

#define ITextStoreAnchor_RequestSupportedAttrs(This,dwFlags,cFilterAttrs,paFilterAttrs)	\
    (This)->lpVtbl -> RequestSupportedAttrs(This,dwFlags,cFilterAttrs,paFilterAttrs)

#define ITextStoreAnchor_RequestAttrsAtPosition(This,paPos,cFilterAttrs,paFilterAttrs,dwFlags)	\
    (This)->lpVtbl -> RequestAttrsAtPosition(This,paPos,cFilterAttrs,paFilterAttrs,dwFlags)

#define ITextStoreAnchor_RequestAttrsTransitioningAtPosition(This,paPos,cFilterAttrs,paFilterAttrs,dwFlags)	\
    (This)->lpVtbl -> RequestAttrsTransitioningAtPosition(This,paPos,cFilterAttrs,paFilterAttrs,dwFlags)

#define ITextStoreAnchor_FindNextAttrTransition(This,paStart,paHalt,cFilterAttrs,paFilterAttrs,dwFlags,pfFound,plFoundOffset)	\
    (This)->lpVtbl -> FindNextAttrTransition(This,paStart,paHalt,cFilterAttrs,paFilterAttrs,dwFlags,pfFound,plFoundOffset)

#define ITextStoreAnchor_RetrieveRequestedAttrs(This,ulCount,paAttrVals,pcFetched)	\
    (This)->lpVtbl -> RetrieveRequestedAttrs(This,ulCount,paAttrVals,pcFetched)

#define ITextStoreAnchor_GetStart(This,ppaStart)	\
    (This)->lpVtbl -> GetStart(This,ppaStart)

#define ITextStoreAnchor_GetEnd(This,ppaEnd)	\
    (This)->lpVtbl -> GetEnd(This,ppaEnd)

#define ITextStoreAnchor_GetActiveView(This,pvcView)	\
    (This)->lpVtbl -> GetActiveView(This,pvcView)

#define ITextStoreAnchor_GetAnchorFromPoint(This,vcView,ptScreen,dwFlags,ppaSite)	\
    (This)->lpVtbl -> GetAnchorFromPoint(This,vcView,ptScreen,dwFlags,ppaSite)

#define ITextStoreAnchor_GetTextExt(This,vcView,paStart,paEnd,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,vcView,paStart,paEnd,prc,pfClipped)

#define ITextStoreAnchor_GetScreenExt(This,vcView,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,vcView,prc)

#define ITextStoreAnchor_GetWnd(This,vcView,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,vcView,phwnd)

#define ITextStoreAnchor_QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)	\
    (This)->lpVtbl -> QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)

#define ITextStoreAnchor_InsertTextAtSelection(This,dwFlags,pchText,cch,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> InsertTextAtSelection(This,dwFlags,pchText,cch,ppaStart,ppaEnd)

#define ITextStoreAnchor_InsertEmbeddedAtSelection(This,dwFlags,pDataObject,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> InsertEmbeddedAtSelection(This,dwFlags,pDataObject,ppaStart,ppaEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchor_AdviseSink_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk,
    /* [in] */ DWORD dwMask);


void __RPC_STUB ITextStoreAnchor_AdviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_UnadviseSink_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IUnknown *punk);


void __RPC_STUB ITextStoreAnchor_UnadviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_RequestLock_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwLockFlags,
    /* [out] */ HRESULT *phrSession);


void __RPC_STUB ITextStoreAnchor_RequestLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetStatus_Proxy( 
    ITextStoreAnchor * This,
    /* [out] */ TS_STATUS *pdcs);


void __RPC_STUB ITextStoreAnchor_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_QueryInsert_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IAnchor *paTestStart,
    /* [in] */ IAnchor *paTestEnd,
    /* [in] */ ULONG cch,
    /* [out] */ IAnchor **ppaResultStart,
    /* [out] */ IAnchor **ppaResultEnd);


void __RPC_STUB ITextStoreAnchor_QueryInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetSelection_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TS_SELECTION_ANCHOR *pSelection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITextStoreAnchor_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_SetSelection_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const TS_SELECTION_ANCHOR *pSelection);


void __RPC_STUB ITextStoreAnchor_SetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetText_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [length_is][size_is][out] */ WCHAR *pchText,
    /* [in] */ ULONG cchReq,
    /* [out] */ ULONG *pcch,
    /* [in] */ BOOL fUpdateAnchor);


void __RPC_STUB ITextStoreAnchor_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_SetText_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ ULONG cch);


void __RPC_STUB ITextStoreAnchor_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetFormattedText_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ IDataObject **ppDataObject);


void __RPC_STUB ITextStoreAnchor_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetEmbedded_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IAnchor *paPos,
    /* [in] */ REFGUID rguidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITextStoreAnchor_GetEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_InsertEmbedded_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ IDataObject *pDataObject);


void __RPC_STUB ITextStoreAnchor_InsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_RequestSupportedAttrs_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs);


void __RPC_STUB ITextStoreAnchor_RequestSupportedAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_RequestAttrsAtPosition_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IAnchor *paPos,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreAnchor_RequestAttrsAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_RequestAttrsTransitioningAtPosition_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IAnchor *paPos,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreAnchor_RequestAttrsTransitioningAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_FindNextAttrTransition_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paHalt,
    /* [in] */ ULONG cFilterAttrs,
    /* [unique][size_is][in] */ const TS_ATTRID *paFilterAttrs,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfFound,
    /* [out] */ LONG *plFoundOffset);


void __RPC_STUB ITextStoreAnchor_FindNextAttrTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_RetrieveRequestedAttrs_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TS_ATTRVAL *paAttrVals,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITextStoreAnchor_RetrieveRequestedAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetStart_Proxy( 
    ITextStoreAnchor * This,
    /* [out] */ IAnchor **ppaStart);


void __RPC_STUB ITextStoreAnchor_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetEnd_Proxy( 
    ITextStoreAnchor * This,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITextStoreAnchor_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetActiveView_Proxy( 
    ITextStoreAnchor * This,
    /* [out] */ TsViewCookie *pvcView);


void __RPC_STUB ITextStoreAnchor_GetActiveView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetAnchorFromPoint_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ TsViewCookie vcView,
    /* [in] */ const POINT *ptScreen,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IAnchor **ppaSite);


void __RPC_STUB ITextStoreAnchor_GetAnchorFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetTextExt_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ TsViewCookie vcView,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITextStoreAnchor_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetScreenExt_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ TsViewCookie vcView,
    /* [out] */ RECT *prc);


void __RPC_STUB ITextStoreAnchor_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_GetWnd_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ TsViewCookie vcView,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITextStoreAnchor_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_QueryInsertEmbedded_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ const GUID *pguidService,
    /* [in] */ const FORMATETC *pFormatEtc,
    /* [out] */ BOOL *pfInsertable);


void __RPC_STUB ITextStoreAnchor_QueryInsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_InsertTextAtSelection_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ ULONG cch,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITextStoreAnchor_InsertTextAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchor_InsertEmbeddedAtSelection_Proxy( 
    ITextStoreAnchor * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITextStoreAnchor_InsertEmbeddedAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorSink_INTERFACE_DEFINED__
#define __ITextStoreAnchorSink_INTERFACE_DEFINED__

/* interface ITextStoreAnchorSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e905-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTextChange( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( 
            /* [in] */ TsLayoutCode lcode,
            /* [in] */ TsViewCookie vcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAttrsChange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ULONG cAttrs,
            /* [size_is][in] */ const TS_ATTRID *paAttrs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLockGranted( 
            /* [in] */ DWORD dwLockFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStartEditTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndEditTransaction( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextChange )( 
            ITextStoreAnchorSink * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChange )( 
            ITextStoreAnchorSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITextStoreAnchorSink * This,
            /* [in] */ TsLayoutCode lcode,
            /* [in] */ TsViewCookie vcView);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITextStoreAnchorSink * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnAttrsChange )( 
            ITextStoreAnchorSink * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ULONG cAttrs,
            /* [size_is][in] */ const TS_ATTRID *paAttrs);
        
        HRESULT ( STDMETHODCALLTYPE *OnLockGranted )( 
            ITextStoreAnchorSink * This,
            /* [in] */ DWORD dwLockFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartEditTransaction )( 
            ITextStoreAnchorSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEditTransaction )( 
            ITextStoreAnchorSink * This);
        
        END_INTERFACE
    } ITextStoreAnchorSinkVtbl;

    interface ITextStoreAnchorSink
    {
        CONST_VTBL struct ITextStoreAnchorSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorSink_OnTextChange(This,dwFlags,paStart,paEnd)	\
    (This)->lpVtbl -> OnTextChange(This,dwFlags,paStart,paEnd)

#define ITextStoreAnchorSink_OnSelectionChange(This)	\
    (This)->lpVtbl -> OnSelectionChange(This)

#define ITextStoreAnchorSink_OnLayoutChange(This,lcode,vcView)	\
    (This)->lpVtbl -> OnLayoutChange(This,lcode,vcView)

#define ITextStoreAnchorSink_OnStatusChange(This,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,dwFlags)

#define ITextStoreAnchorSink_OnAttrsChange(This,paStart,paEnd,cAttrs,paAttrs)	\
    (This)->lpVtbl -> OnAttrsChange(This,paStart,paEnd,cAttrs,paAttrs)

#define ITextStoreAnchorSink_OnLockGranted(This,dwLockFlags)	\
    (This)->lpVtbl -> OnLockGranted(This,dwLockFlags)

#define ITextStoreAnchorSink_OnStartEditTransaction(This)	\
    (This)->lpVtbl -> OnStartEditTransaction(This)

#define ITextStoreAnchorSink_OnEndEditTransaction(This)	\
    (This)->lpVtbl -> OnEndEditTransaction(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnTextChange_Proxy( 
    ITextStoreAnchorSink * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITextStoreAnchorSink_OnTextChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnSelectionChange_Proxy( 
    ITextStoreAnchorSink * This);


void __RPC_STUB ITextStoreAnchorSink_OnSelectionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnLayoutChange_Proxy( 
    ITextStoreAnchorSink * This,
    /* [in] */ TsLayoutCode lcode,
    /* [in] */ TsViewCookie vcView);


void __RPC_STUB ITextStoreAnchorSink_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnStatusChange_Proxy( 
    ITextStoreAnchorSink * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITextStoreAnchorSink_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnAttrsChange_Proxy( 
    ITextStoreAnchorSink * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ULONG cAttrs,
    /* [size_is][in] */ const TS_ATTRID *paAttrs);


void __RPC_STUB ITextStoreAnchorSink_OnAttrsChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnLockGranted_Proxy( 
    ITextStoreAnchorSink * This,
    /* [in] */ DWORD dwLockFlags);


void __RPC_STUB ITextStoreAnchorSink_OnLockGranted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnStartEditTransaction_Proxy( 
    ITextStoreAnchorSink * This);


void __RPC_STUB ITextStoreAnchorSink_OnStartEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorSink_OnEndEditTransaction_Proxy( 
    ITextStoreAnchorSink * This);


void __RPC_STUB ITextStoreAnchorSink_OnEndEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorSink_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  CLIPFORMAT_UserSize(     unsigned long *, unsigned long            , CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal(  unsigned long *, unsigned char *, CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal(unsigned long *, unsigned char *, CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree(     unsigned long *, CLIPFORMAT * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tomrange.cpp ===
/*
 *	@doc TOM
 *
 *	@module	TOMRANGE.CPP - Implement the CTxtRange Class |
 *	
 *		This module contains the implementation of the TOM ITextRange
 *		interface on the CTxtRange object
 *
 *	History: <nl>
 *		5/24/95	- Alex Gounares: stubs created <nl>
 *		8/95	- MurrayS: main implementation <nl>
 *		11/95	- MurrayS: upgrade to TOM spec of 12/10/95 <nl>
 *		5/96	- MurrayS: added zombie protection
 *
 *	@comm
 *		All ITextRange methods return HRESULTs.  If the method can move a
 *		range cp, the HRESULT is NOERROR if movement occurs and S_FALSE if
 *		no movement occurs.  These methods usually take a <p pDelta> argument
 *		that returns the count of characters or Units actually moved.  If this
 *		parameter is NULL, E_INVALIDARG is returned.  Other return values
 *		include E_NOTIMPL, e.g., for Unit values not implemented, 
 *		E_OUTOFMEMORY, e.g., when allocations fail, and CO_E_RELEASED, when
 *		the CTxtEdit (_ped) to which the range is attached has been deleted.
 *
 *		For more complete documentation, please see tom.doc
 *
 *	@devnote
 *		All ptr parameters must be validated before use and all entry points
 *		need to check whether this range is a zombie.  These checks are
 *		done in one of three places: 1) immediately on entry to a function,
 *		2) immediately on entry to a helper function (e.g., private Mover()
 *		for the	move methods), or 3) before storing the out value.
 *		Alternative 3) is used for optional return values, such as pDelta
 *		and pB. 
 *
 *		To achieve a simple, efficient inheritance model, CTxtSelection
 *		inherits ITextSelection through CTxtRange.  Otherwise we'd have a
 *		diamond inheritance, since ITextSelection itself inherits from
 *		ITextRange. Diamond inheritance creates two copies of the multiply
 *		inherited class unless that class is inherited virtually. Virtual
 *		inheritance uses run-time base-offset tables and is slower and
 *		bigger.  To avoid such a mess, we include the extra ITextSelection
 *		methods in CTxtRange, with the intention that they'll never be called
 *		and therefore they return E_NOTIMPL. This is overridden for
 *		ITextSelection objects
 *
 *	@future
 *		1) Finder match ^p, etc.
 *		2) Fast GetEffects() method. Would speed up the myriad IsProtected()
 *		   calls and be useful for getting other effects as well.
 *		3) Fast copies/pastes of RichEdit binary format. This can be done by
 *		   creating a method to copy a range to a new CTxtStory and a method
 *		   to insert a CTxtStory.
 *		4) Delayed rendering
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_line.h"
#include "_frunptr.h"
#include "_tomfmt.h"
#include "_disp.h"
#include "_objmgr.h"
#include "_callmgr.h"
#include "_measure.h"

ASSERTDATA

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

HRESULT QueryInterface (REFIID riid, REFIID riid1, IUnknown *punk,
						void **ppv, BOOL fZombie);


//----------------- CTxtRange (ITextRange) PUBLIC methods ----------------------------------

//----------------------- CTxtRange IUnknown Methods -------------------------------------

/*
 *	CTxtRange::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT = (!ppv) ? E_INVALIDARG :
 *				  (interface found) ? NOERROR : E_NOINTERFACE
 */
STDMETHODIMP CTxtRange::QueryInterface (
	REFIID	riid,			//@parm Reference to requested interface ID
	void ** ppv)			//@parm Out parm to receive interface ptr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::QueryInterface");

	REFIID riid1 = _fSel && IsEqualIID(riid, IID_ITextSelection)
				 ? IID_ITextSelection : IID_ITextRange;
	return ::QueryInterface(riid, riid1, this, ppv, IsZombie());
}

/*
 *	CTxtRange::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::AddRef");

 	return ++_cRefs;
}

/*
 *	CTxtRange::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}

	Assert(_cRefs > 0);
	return _cRefs;
}


//------------------------ CTxtRange IDispatch Methods -------------------------------------

/*
 *	CTxtRange::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtRange::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextSelection interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoSel, ppTypeInfo);
}

/*
 *	CTxtRange::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for methods in the ITextSelection, ITextRange, ITextFont,
 *		and ITextPara interfaces
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		If the ITextFont and ITextPara ever offer more methods than exposed
 *		in their type libraries, the code should delegate to the corresponding
 *		GetIDsOfNames. The current code only gets DISPIDs for the methods in
 *		type libraries, thereby not having to instantiate the objects.
 */
STDMETHODIMP CTxtRange::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if(g_pTypeInfoSel->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
		return NOERROR;

	if(g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
		return NOERROR;

	return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtRange::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextRange and ITextSelection objects, as
 *		well as for ITextFont and ITextPara	interfaces on those objects.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtRange::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Invoke");

	HRESULT hr = GetTypeInfoPtrs();			// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if(IsZombie())
		return CO_E_RELEASED;

	IDispatch *	pDispatch;
	ITypeInfo *	pTypeInfo;

	if((DWORD)dispidMember <= 0x2ff)		// Include default (0), selection,
	{										//  and range DISPIDs
		pTypeInfo = g_pTypeInfoSel;
		pDispatch = this;
		AddRef();							// Compensate for Release() below
	}
	else if((DWORD)dispidMember <= 0x3ff)	// 0x300 to 0x3ff: DISPIDs
	{										//  reserved for ITextFont
		pTypeInfo = g_pTypeInfoFont;
		hr = GetFont((ITextFont**)&pDispatch);
	}
	else if((DWORD)dispidMember <= 0x4ff)	// 0x400 to 0x4ff: DISPIDs
	{										//  reserved for ITextPara
		pTypeInfo = g_pTypeInfoPara;
		hr = GetPara((ITextPara **)&pDispatch);
	}
	else									// dispidMember is negative or
		return DISP_E_MEMBERNOTFOUND;		//  > 0x4ff, i.e., not TOM

	if(hr != NOERROR)						// Couldn't instantiate ITextFont
		return hr;							//  or ITextPara

	hr = pTypeInfo->Invoke(pDispatch, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
	pDispatch->Release();
	return hr;
}


//----------------------- ITextRange Methods/Properties ------------------------

/*
 *	CTxtRange::CanEdit (pB)
 *
 *	@mfunc
 *		Set *<p pB> = tomTrue iff this range can be edited and
 *		pB isn't NULL
 *
 *	@rdesc
 *		HRESULT = (can edit) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanEdit (
	long * pB) 			//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanEdit");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	return IsTrue(!WriteAccessDenied(), pB);
}

/*
 *	CTxtRange::CanPaste (pVar, long Format, pB)
 *
 *	@mfunc
 *		Set *<p pB> = tomTrue iff the data object <p pVar>->punkVal can be
 *		pasted into this range and pB isn't NULL.  If <p pVar> is NULL,
 *		use the clipboard instead.
 *
 *	@rdesc
 *		HRESULT = (can paste) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanPaste (
	VARIANT *	pVar,		//@parm Data object to paste 
	long		Format,		//@parm Desired clipboard format
	long *		pB)  		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanPaste");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr		callmgr(GetPed());
	HRESULT			hr; 
	IDataObject *	pdo = NULL;				// Default clipboard

	if(pVar && pVar->vt == VT_UNKNOWN)
		pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);

	hr = IsTrue(!WriteAccessDenied() &&
				(GetPed()->GetDTE()->CanPaste(pdo, (CLIPFORMAT)Format, 
				 RECO_PASTE)), pB);
	if(pdo)
		pdo->Release();

	return hr;
}

/*
 *	ITextRange::ChangeCase (long Type) 
 *
 *	@mfunc
 *		Change the case of letters in this range according to Type:
 *
 *		tomSentenceCase	= 0: capitalize first letter of each sentence
 *		tomLowerCase	= 1: change all letters to lower case
 *		tomUpperCase	= 2: change all letters to upper case
 *		tomTitleCase	= 3: capitalize the first letter of each word
 *		tomToggleCase	= 4: toggle the case of each letter
 *	
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ChangeCase (
	long Type)		//@parm Type of case change. Default value: tomLower
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ChangeCase");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	IUndoBuilder *	publdr;
	CGenUndoBuilder	undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
	LONG			cpMin, cpMax;
	LONG			cch = GetRange(cpMin, cpMax);
	CRchTxtPtr		rtp(*this);

	undobldr.StopGroupTyping();

	rtp.SetCp(cpMin);
	return (rtp.ChangeCase(cch, Type, publdr)) ? NOERROR : S_FALSE;
}

/*
 *	CTxtRange::Collapse (bStart)
 *
 *	@mfunc
 *		Collapse this range into a degenerate point either at the
 *		the start (<p bStart> is nonzero or the end (<p bStart> = 0)
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Collapse (
	long bStart) 			//@parm Flag specifying end to collapse at
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Collapse");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());
 
	if(!_cch)							// Already collapsed
		return S_FALSE;					// Signal that no change occurred
		
	Collapser(bStart);
	Update(TRUE);						// Update selection
	return NOERROR;						// Signal that change occurred
}

/*
 *	CTxtRange::Copy (pVar)
 *
 *	@mfunc
 *		Copy the plain and/or rich text to a data object and return the
 *		object ptr in <p pVar>.  If <p pVar> is null, copy to the clipboard. 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Copy (
	VARIANT * pVar)				//@parm Out parm for data object 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Copy");

	if(IsZombie())
		return CO_E_RELEASED;

	LONG lStreamFormat = CheckTableSelection(FALSE, TRUE, NULL, 0)
					   ? SFF_WRITEXTRAPAR : 0;

	CLightDTEngine * pldte = &GetPed()->_ldte;

	if(pVar && pVar->vt == (VT_UNKNOWN | VT_BYREF))
	{
		return pldte->RangeToDataObject(this, SF_TEXT | SF_RTF | lStreamFormat,
									(IDataObject **)pVar->ppunkVal);
	}
	return pldte->CopyRangeToClipboard(this, lStreamFormat);
}

/*
 *	CTxtRange::Cut (pVar)
 *
 *	@mfunc
 *		Cut the plain and/or rich text to a data object and return the
 *		object ptr in <p pVar>.  If <p pVar> is null,
 *		cut to the clipboard. 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Cut (
	VARIANT * pVar)		//@parm Out parm for data object  
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Cut");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	HRESULT hr = Copy(pVar);

	Replacer(0, NULL);
	return hr;
}

/*
 *	CTxtRange::Delete (Unit, Count, pDelta)
 *
 *	@mfunc
 *		If this range is nondegenerate, delete it along with |Count| - 1 Units
 *		in the direction specified by the sign of Count.  If this range is
 *		degenerate, delete Count Units.
 *
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (all requested Units deleted) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Delete (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of chars to delete
	long *	pDelta)			//@parm Out parm to receive count of units deleted
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Delete");

	if(pDelta)
		*pDelta = 0;
	
	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	LONG	cchSave = _cch;					// Remember initial count
	LONG	cchText = GetAdjustedTextLength();
	LONG	CountOrg = Count;
	LONG	cpMin, cpMost;
	LONG	cUnit = 0;						// Default no Units
	MOVES	Mode = (Count >= 0) ? MOVE_END : MOVE_START;

	GetRange(cpMin, cpMost);
	if(cpMost > cchText)					// Can't delete final CR. To get
	{										//  *pDelta right, handle here
		Set(cpMin, cpMin - cchText);		// Backup before CR & set active
		if(Count > 0)						//  end at cpMin since there's
		{									//  nothing to delete forward
			Count = 0;
			if(!_cch)						// Only collapsed selection of
				Mode = MOVE_IP;				//  final CR: set up nothing
		}									//  deleted (MOVE_IP = 0)
	}
	if(Count)
	{
		if((_cch ^ Mode) < 0)				// Be sure active end is in
			FlipRange();					//  deletion direction
		if(cchSave)							// Deleting nondegenerate range
			Count -= Mode;					//  counts as one unit
		if(Mover(Unit, Count, &cUnit, Mode)	// Try to expand range for
			== E_INVALIDARG)				//  remaining Count Units
		{
			if(pDelta)
				*pDelta = 0;
			return E_INVALIDARG;
		}
		if(GetCp() > cchText && cUnit > 0)	// Range includes final CR, which
		{									//  cannot be deleted. Reduce
			if(Unit == tomCharacter)		//  counts for some Units
				cUnit -= GetTextLength() - cchText;
			else if(Unit == tomWord)
				cUnit--;					// An EOP qualifies as a tomWord
		}
	}

	if(cchSave)								// Deleting nondegenerate range
		cUnit += Mode;						//  counts as a Unit

	if(pDelta)
		*pDelta = cUnit;

	if(_cch)								// Mover() may have changed _cch
	{										
		IUndoBuilder *	publdr;
	 	CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

		if (publdr)
		{
			publdr->StopGroupTyping();
			publdr->SetNameID(UID_DELETE);
		}

		// FUTURE (murrays): the cchSave case should set up undo to
		// restore the original range, not the extended range resulting
		// when |CountOrg| > 1.  This could be done using two calls to
		// ReplaceRange(), one to delete the original range and one to
		// delete the rest
		SELRR selrr = !_fSel || cchSave	? SELRR_REMEMBERRANGE :
					  CountOrg > 0		? SELRR_REMEMBERCPMIN :
										  SELRR_REMEMBERENDIP;

		CheckTableSelection(TRUE, TRUE, NULL, 0);
		ReplaceRange(0, NULL, publdr, selrr);

		if (cUnit == CountOrg ||			// Delete(Unit,0,0)
			cUnit == 1 && !CountOrg)		//  deletes one "Unit", namely
		{									//  what's selected
			return NOERROR;					// Signal everything deleted as
		}									//  requested
	}
	else if(cchSave)						// Collapsed selection of final CR
	{										//  but didn't delete anything
		Update(TRUE);						// Selection highlighting changed
	}
	return S_FALSE;							// Less deleted than requested
}

/*
 *	CTxtRange::EndOf (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Move this range end(s) to end of the first overlapping Unit in
 *		the range.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit supported) ? S_FALSE	: E_NOTIMPL
 */
STDMETHODIMP CTxtRange::EndOf (
	long 	Unit,			//@parm Unit to use
	long 	Extend,			//@parm If true, leave other end alone 
	long *	pDelta)			//@parm Count of chars that End is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndOf");

	CCallMgr	callmgr(GetPed());
	LONG		cpMost;

	HRESULT hr = Expander (Unit, Extend, pDelta, NULL, &cpMost);
	if(hr == NOERROR)
		Update(TRUE);					// Update selection

	return hr;
}

/*
 *	CTxtRange::Expand (Unit, pDelta)
 *
 *	@mfunc
 *		Expand this range so that any partial Units it contains are
 *		completely contained.  If this range consists of one or more full
 *		Units, no change is made.  If this range is an insertion point at
 *		the beginning or within a Unit, Expand() expands this range to include
 *		that Unit.  If this range is an insertion point at the end of the
 *		story, Expand() tries to set this range to include the last Unit in
 *		the story.  The active end is always cpMost except for the last case.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit supported) ? S_FALSE	: E_NOTIMPL
 */
STDMETHODIMP CTxtRange::Expand (
	long	Unit,			//@parm Unit to expand range to
	long *	pDelta)			//@parm Out parm to receive count of chars added
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Expand");

	CCallMgr callmgr(GetPed());
	LONG	 cpMin, cpMost;

	HRESULT hr = Expander (Unit, TRUE, pDelta, &cpMin, &cpMost);

	if(SUCCEEDED(hr))
		Update(TRUE);					// Update selection

	return hr;
}

/*
 *	CTxtRange::FindText (bstr, cch, Flags, pLength)
 *
 *	@mfunc
 *		If this range isn't an insertion point already, convert it into an
 *		insertion point at its End if <p cch> <gt> 0 and at its Start if
 *		<p cch> <lt> 0.  Then search up to <p cch> characters of the range
 *		looking for the string <p bstr> subject to the compare flags
 *		<p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *		<lt> 0 the search is backward.  If the string is found, the range
 *		limits are changed to be those of the matched string and *<p pLength>
 *		is set equal to the length of the string. If the string isn't found,
 *		the range remains unchanged and *<p pLength> is set equal to 0.   
 *
 *	@rdesc
 *		HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Argument validation of the three Find methods is done by the helper
 *		function CTxtRange::Finder(bstr, cch, dwFlags, pDelta, fExtend, fFlip)
 */
STDMETHODIMP CTxtRange::FindText (
	BSTR	bstr,		//@parm String to find
	long	Count,		//@parm Max count of chars to search
	long	Flags,		//@parm Flags governing compares
	long *	pDelta)		//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindText");

	return Finder(bstr, Count, Flags, pDelta, MOVE_IP);
}

/*
 *	CTxtRange::FindTextEnd (bstr, cch, Flags, pLength)
 *
 *	@mfunc
 *		Starting from this range's End, search up to <p cch> characters
 *		looking for the string <p bstr> subject to the compare flags
 *		<p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *		<lt> 0 the search is backward.  If the string is found, the range
 *		limits are changed to be those of the matched string and *<p pLength>
 *		is set equal to the length of the string. If the string isn't found,
 *		the range remains unchanged and *<p pLength> is set equal to 0.   
 *
 *	@rdesc
 *		HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextEnd (
	BSTR	bstr,		//@parm String to find
	long	Count,		//@parm Max count of chars to search
	long	Flags,		//@parm Flags governing compares
	long *	pDelta)		//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextEnd");

	return Finder(bstr, Count, Flags, pDelta, MOVE_END);
}

/*
 *	CTxtRange::FindTextStart (bstr, cch, Flags, pDelta)
 *
 *	@mfunc
 *		Starting from this range's Start, search up to <p cch> characters
 *		looking for the string <p bstr> subject to the compare flags
 *		<p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *		<lt> 0 the search is backward.  If the string is found, the range
 *		limits are changed to be those of the matched string and *<p pLength>
 *		is set equal to the length of the string. If the string isn't found,
 *		the range remains unchanged and *<p pLength> is set equal to 0.   
 *
 *	@rdesc
 *		HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextStart (
	BSTR	bstr,		//@parm String to find
	long	Count,		//@parm Max count of chars to search
	long	Flags,		//@parm Flags governing compares
	long *	pDelta)		//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextStart");

	return Finder(bstr, Count, Flags, pDelta, MOVE_START);
}

/*
 *	CTxtRange::GetChar (pChar)
 *
 *	@mfunc
 *		Set *<p pChar> equal to the character at cpFirst  
 *
 *	@rdesc
 *		HRESULT = (<p pChar>) NOERROR ? E_INVALIDARG
 *
 *	@devnote
 *		This method is very handy for walking a range character by character
 *		from the Start. Accordingly, it's desirable that the active end
 *		is at the Start. We set this up for a range, since the API doesn't
 *		care which range end is active.  But we can't do this for a selection,
 *		since the selection API depends on the active end.
 */
STDMETHODIMP CTxtRange::GetChar (
	long * pChar)			//@parm Out parm for char
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetChar");

	HRESULT hr = GetLong(0, pChar);
	if(hr != NOERROR)
		return hr;

	if(_cch > 0)							// Active end at cpMost (End)
	{
		if(_fSel)
		{
			CTxtPtr tp(_rpTX);				// For selection, can't change
			tp.Move(-_cch);					//  active end
			*pChar = (long)(tp.GetChar()); 
			return NOERROR;
		}
		FlipRange();						// For range, it's more efficient
	}										//  to work from cpFirst and API
	*(DWORD *)pChar = _rpTX.GetChar();		//  doesn't expose RichEdit active
											//  end
	return NOERROR;
}

/*
 *	CTxtRange::GetDuplicate (ppRange)
 *
 *	@mfunc
 *		Get a clone of this range object.  For example, you may want to
 *		create an insertion point to traverse a range, so you clone the
 *		range and then set the clone's cpLim equal to its cpFirst. A range
 *		is characterized by its cpFirst, cpLim, and the story it belongs to. 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR :
 *				  (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 *
 *	@comm
 *		Even if this range is a selection, the clone returned is still only
 *		a range.
 */
STDMETHODIMP CTxtRange::GetDuplicate (
	ITextRange ** ppRange)		//@parm Out parm to receive duplicate of range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetDuplicate");

	HRESULT hr = GetLong(NULL, (LONG *)ppRange);
	if(hr != NOERROR)
		return hr;

#ifdef _WIN64
	*ppRange = NULL;
#endif

	ITextRange *prg = new CTxtRange(*this);
	if(prg)
	{
		*ppRange = prg;
		prg->AddRef();
		return NOERROR;
	}
	return E_OUTOFMEMORY;
}

/*
 *	ITextRange::GetEmbeddedObject (ppV)
 *
 *	@mfunc
 *		Property get method that gets a ptr to the object at cpFirst
 *
 *	@rdesc
 *		HRESULT = (!ppV) ? E_INVALIDARG :
 *				  (object found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetEmbeddedObject (
	IUnknown **ppV)			//@parm Out parm to receive embedded object
{
	HRESULT hr = GetLong(NULL, (LONG *)ppV);
	if(hr != NOERROR)
		return hr;

#ifdef _WIN64
	*ppV = NULL;
#endif

	if(GetObjectCount())
	{
		COleObject *pobj = GetPed()->_pobjmgr->GetObjectFromCp(GetCpMin());

		if(pobj && (*ppV = pobj->GetIUnknown()) != NULL)
		{
			(*ppV)->AddRef();
			return NOERROR;
		}
	}
	return S_FALSE;
}

/*
 *	CTxtRange::GetEnd (pcpLim)
 *
 *	@mfunc
 *		Get this range's End (cpMost) cp
 *
 *	@rdesc
 *		HRESULT = (<p pcpLim>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetEnd (
	long * pcpLim) 			//@parm Out parm to receive End cp value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetEnd");

	return GetLong(GetCpMost(), pcpLim);
}

/*
 *	CTxtRange::GetFont (ppFont)
 *
 *	@mfunc
 *		Get an ITextFont object with the character attributes of this range		
 *
 *	@rdesc
 *		HRESULT = <p ppFont> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFont (
	ITextFont ** ppFont)	//@parm Out parm to receive ITextFont object 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFont");
 
	HRESULT hr = GetLong(NULL, (LONG *)ppFont);
	if(hr != NOERROR)
		return hr;

#ifdef _WIN64
	*ppFont = NULL;
#endif

	*ppFont = (ITextFont *) new CTxtFont(this);
	return *ppFont ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CTxtRange::GetFormattedText (ppRange)
 *
 *	@mfunc
 *		Retrieves an ITextRange with this range's formatted text.
 *		If <p ppRange> is NULL, the clipboard is the target. 
 *
 *	@rdesc
 *		HRESULT = (if success)  ? NOERROR :
 *				  (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFormattedText (
	ITextRange ** ppRange)		//@parm Out parm to receive formatted text
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFormattedText");

	return GetDuplicate(ppRange);
}

/*
 *	CTxtRange::GetIndex (Unit, pIndex)
 *
 *	@mfunc
 *		Set *<p pIndex> equal to the Unit number at this range's cpFirst  
 *
 *	@rdesc
 *		HRESULT = (!<p pIndex>) ? E_INVALIDARG :
 *				  (Unit not implemented) ? E_NOTIMPL :
 *				  (Unit available) ? NOERROR : S_FALSE
 *	@future
 *		implement tomWindow?
 */
STDMETHODIMP CTxtRange::GetIndex (
	long	Unit,			//@parm Unit to index
	long *	pIndex)			//@parm Out parm to receive index value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIndex");

	HRESULT hr = GetLong(0, pIndex);
	if(hr != NOERROR)
		return hr;

	LONG	  cp;
	LONG	  cUnit = tomBackward;
	CTxtRange rg(*this);

	hr = rg.Expander(Unit, FALSE, NULL,			// Go to Start of Unit; else
							 &cp, NULL);		//  UnitCounter gives 1 extra
	if(FAILED(hr))
		return hr;								// Unit not recognized

	LONG cch = rg.UnitCounter(Unit, cUnit, 0,
			_fSel && cp == GetCp() && ((CTxtSelection *)this)->IsCaretNotAtBOL());
	
	if(cch == tomForward)						// UnitCounter() doesn't know
		return E_NOTIMPL;						//  Unit

	if(cch == tomBackward)						// Unit not in story
		return S_FALSE;

	*pIndex = -cUnit + 1;						// Make count positive and
												//  1-based
	return NOERROR;
}

/*
 *	CTxtRange::GetPara (ppPara)
 *
 *	@mfunc
 *		Get an ITextPara object with the paragraph attributes of this range		
 *
 *	@rdesc
 *		HRESULT = <p ppPara> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetPara (
	ITextPara ** ppPara)	//@parm Out parm to receive ITextPara object  
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetPara");
 
	HRESULT hr = GetLong(NULL, (LONG *)ppPara);
	if(hr != NOERROR)
		return hr;

#ifdef _WIN64
	*ppPara = NULL;
#endif

	*ppPara = (ITextPara *) new CTxtPara(this);
	return *ppPara ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CTxtRange::GetPoint (px, py, Type)
 *
 *	@mfunc
 *		Get point for selection Start or End and intraline position
 *		as determined by <p Type>.
 *
 *	@rdesc
 *		HRESULT = (!<p px> or !<p py>) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetPoint (
	long 	Type, 		//@parm Type of point
	long *	px,			//@parm Out parm for x coordinate
	long *	py)			//@parm Out parm for y coordinate
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetPoint");

	if(!px || !py)
		return E_INVALIDARG;

	*px = *py = 0;

 	if(IsZombie())
		return CO_E_RELEASED;

	LONG		ili;
	BOOL		fEnd = !(Type & tomStart);		// TRUE if get pt at end of range
	BOOL		fAtEnd = _cch && fEnd;			// TRUE if get ambiguous pt at end of line
	POINTUV		pt;
	CRchTxtPtr	rtp(*this);						// Default active end
	CTxtEdit *	ped = GetPed();
	CDisplay *	pdp = ped->_pdp;				// Save indirections

	if(!pdp || !ped->fInplaceActive())			// No display or not active
		return E_FAIL;							//  then we can do nothing

	if((_cch > 0) ^ fEnd)						// Move tp to active end
		rtp.Move(-_cch);

	ili = pdp->PointFromTp(rtp, NULL, fAtEnd, pt, NULL, Type & 0x1f);
	POINT		ptxy;
	pdp->PointFromPointuv(ptxy, pt);

	RECTUV rcView;								// Verify return value makes
												//  sense since PointFromTp
	pdp->GetViewRect(rcView, NULL);				//  may return values outside
												//  client rect
	rcView.bottom++;							// Enlarge Rect to include
	rcView.right++;								//  bottom and right edges
	if(ili >= 0 && (PtInRect(&rcView, pt) ||	// Function succeeded or
		(Type & tomAllowOffClient)))			//  allow off client rect pts
	{
		// Caller wants screen coordinates?
		if ( !(Type & tomClientCoord) )
			ped->TxClientToScreen(&ptxy);	

		*px = ptxy.x;
		*py = ptxy.y;
		return NOERROR;
	}
	return S_FALSE;								// Function failed
}

/*
 *	CTxtRange::GetStart	(pcpFirst)
 *
 *	@mfunc
 *		Get this range's Start (cpMin) cp
 *
 *	@rdesc
 *		HRESULT = (<p pcpFirst>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStart (
	long * pcpFirst) 		//@parm Out parm to receive Start cp value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStart");
 
	return GetLong(GetCpMin(), pcpFirst);
}

/*
 *	CTxtRange::GetStoryLength (pcch)
 *
 *	@mfunc
 *		Set *<p pcch> = count of chars in this range's story
 *
 *	@rdesc
 *		HRESULT = (<p pcch>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryLength (
	long * pcch)		//@parm Out parm to get length of this range's story
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryLength");

	return GetLong(GetTextLength(), pcch);
}

/*
 *	ITextRange::GetStoryType (pValue) 
 *
 *	@mfunc
 *		Property get method that gets the type of this range's
 *		story.
 *
 *	@rdesc
 *		HRESULT = (pValue) NOERROR ? E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryType (
	long *pValue)		//@parm Out parm to get type of this range's story
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryType");

	return GetLong(tomUnknownStory, pValue);
}

/*
 *	CTxtRange::GetText (pbstr)
 *
 *	@mfunc
 *		Get plain text in this range. The Text property is the default
 *		property for ITextRange.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR :
 *				  (!<p pbstr>) ? E_INVALIDARG : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::GetText (
	BSTR * pbstr)				//@parm Out parm to receive bstr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetText");

	HRESULT hr = GetLong(NULL, (LONG *)pbstr);
	if(hr != NOERROR)
		return hr;

#ifdef _WIN64
	*pbstr = NULL;
#endif

	if(!GetCch())
		return NOERROR;
		
	LONG cpMin, cpMost;
	LONG cch = GetRange(cpMin, cpMost);

	*pbstr = SysAllocStringLen(NULL, cch);
	if(!*pbstr)
		return E_OUTOFMEMORY;

	CTxtPtr	tp(_rpTX);
	tp.SetCp(cpMin);
	tp.GetText( cch, (WCHAR*) * pbstr );
	return NOERROR;
}

/*
 *	CTxtRange::InRange (pRange, pB)
 *
 *	@mfunc
 *		Returns *<p pB> = tomTrue iff this range points within or at the same
 *		text as <p pRange> does
 *
 *	@rdesc
 *		HRESULT = (within range) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::InRange (
	ITextRange * pRange,		//@parm ITextRange to compare with
	long *		 pB)			//@parm Out parm for comparison result
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InRange");

	return IsTrue(Comparer(pRange), pB);
}


/*
 *	CTxtRange::InStory (pRange, pB)
 *
 *	@mfunc
 *		Return *pB = tomTrue iff this range's story is the same as
 *		<p pRange>'s
 *
 *	@rdesc
 *		HRESULT = (in story) ? NOERROR : S_FALSE
 *
 *	@future
 *		If RichEdit acquires the ability to have multiple stories and 
 *		therefore ranges get a _story member, then compare that member
 *		instead of calling _rpTX.SameRuns().
 */
STDMETHODIMP CTxtRange::InStory (
	ITextRange *pRange,		//@parm ITextRange to query for private interface
	long *		pB)			//@parm Out parm to receive tomBool result
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InStory");
 
	return IsTrue(IsSameVtables(this, pRange) &&		// Same vtables,
		_rpTX.SameRuns(&((CTxtRange *)pRange)->_rpTX),	//  same Runs
		pB);
}

/*
 *	CTxtRange::IsEqual (pRange, pB)
 *
 *	@mfunc
 *		Returns *<p pB> = tomTrue iff this range points at the same text (cp's
 *		and story) as <p pRange> does and pB isn't NULL.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::IsEqual (
	ITextRange * pRange,		//@parm ITextRange to compare with
	long *		 pB)			//@parm Out parm for comparison result
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::IsEqual");

	return IsTrue(Comparer(pRange) < 0, pB);
}

/*
 *	CTxtRange::Move (Unit, Count, pDelta)
 *
 *	@mfunc
 *		Move end(s) <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *		actually moved. In general, this method converts a range into an
 *		insertion point if it isn't already, and moves the insertion point.
 *		If <p Count> <gt> 0, motion is forward toward the end of the story;
 *		if <p Count> <lt> 0, motion is backward toward the beginning.
 *		<p Count> = 0 moves cpFirst to the beginning of the <p Unit>
 *		containing cpFirst.
 *  
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit supported) ? S_FALSE	: E_NOTIMPL
 *	@devnote
 *		Argument validation of the three Move methods is done by the helper
 *		function CTxtRange::Mover(Unit, Count, pDelta, Mode)
 */
STDMETHODIMP CTxtRange::Move (
	long 	Unit,			//@parm Unit to use
	long 	Count,			//@parm Number of Units to move
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Move");
	CCallMgr	callmgr(GetPed());

	return Mover(Unit, Count, pDelta, MOVE_IP);
}

/*
 *	CTxtRange::MoveEnd (Unit, Count, pDelta)
 *
 *	@mfunc
 *		Move End end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *		actually moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit supported) ? S_FALSE	: E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveEnd (
	long 	Unit,			//@parm Unit to use
	long 	Count,			//@parm Number of Units to move
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEnd");
	CCallMgr	callmgr(GetPed());

	return Mover(Unit, Count, pDelta, MOVE_END);
}

/*
 *	CTxtRange::MoveEndUntil (Cset, Count, pDelta)
 *
 *	@mfunc
 *		Move the End just past all contiguous characters that are not found
 *		in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndUntil (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndUntil");

	return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_UNTIL);
}

/*
 *	CTxtRange::MoveEndWhile (Cset, Count, pDelta)
 *
 *	@mfunc
 *		Move the End just past all contiguous characters that are found in
 *		the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndWhile (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndWhile");

	return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_WHILE);
}

/*
 *	CTxtRange::MoveStart (Unit, Count, pDelta)
 *
 *	@mfunc
 *		Move Start end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *		actually moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit supported) ? S_FALSE	: E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveStart (
	long 	Unit,			//@parm Unit to use
	long 	Count,			//@parm Number of Units to move
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStart");
	CCallMgr	callmgr(GetPed());

	return Mover(Unit, Count, pDelta, MOVE_START);
}

/*
 *	CTxtRange::MoveStartUntil (Cset, Count, pDelta)
 *
 *	@mfunc
 *		Move the Start just past all contiguous characters that are not found
 *		in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartUntil (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartUntil");

	return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_UNTIL);
}

/*
 *	CTxtRange::MoveStartWhile (Cset, Count, pDelta)
 *
 *	@mfunc
 *		Move the Start just past all contiguous characters that are found in
 *		the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartWhile (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartWhile");

	return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_WHILE);
}

/*
 *	CTxtRange::MoveUntil (Cset,Count, pDelta)
 *
 *	@mfunc
 *		Convert this range into an insertion point if it isn't already,
 *		and keep moving the insertion point until encountering any
 *		character in the set of characters specified by the VARIANT cset
 *		parameter.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveUntil (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveUntil");
							
	return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_UNTIL);
}

/*
 *	CTxtRange::MoveWhile (Cset, Count, pDelta)
 *
 *	@mfunc
 *		Convert this range into an insertion point if it isn't already,
 *		and keep moving the insertion point so long as (while) the
 *		characters past by are found in set of characters specified by
 *		the VARIANT cset parameter.  Such a contiguous set of characters
 *		is known as a span of characters.  The magnitude of the <p Count>
 *		parameter gives the maximum number of characters to move past and
 *		the sign of <p Count> specifies the direction to move in.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 *
 *	@devnote
 *		Argument validation of the MoveWhile and MoveUntil methods is done by
 *		the helper CTxtRange::Matcher (Cset, Count, pDelta, fExtend, fSpan)
 */
STDMETHODIMP CTxtRange::MoveWhile (
	VARIANT * Cset,				//@parm Character match set to use
	long 	  Count,			//@parm Max number of characters to move past
	long *	  pDelta)			//@parm Out parm to receive actual count of
								//		characters end is moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveWhile");
							
	return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_WHILE);
}

/*
 *	CTxtRange::Paste (pVar, ClipboardFormat)
 *
 *	@mfunc
 *		Paste the data object <p pVar> into this range.  If
 *		<p pVar> is null, paste from the clipboard. 
 *
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Paste (
	VARIANT *pVar,				//@parm Data object to paste 
	long	 ClipboardFormat)	//@parm Desired clipboard format
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Paste");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr		callmgr(GetPed());
	HRESULT			hr;
	IDataObject *	pdo = NULL;			// Default clipboard
	IUndoBuilder *	publdr;
	CGenUndoBuilder	undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	if(pVar)
		if (pVar->vt == VT_UNKNOWN)
			pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);
		else if (pVar->vt == (VT_UNKNOWN | VT_BYREF))
			pdo = (IDataObject *)(*pVar->ppunkVal);

	hr = GetPed()->PasteDataObjectToRange (pdo, this,
		(WORD)ClipboardFormat, NULL, publdr, PDOR_NONE);

	if(pdo && pVar->vt == VT_UNKNOWN)
		pdo->Release();
	Update(TRUE);						// Update selection
	return hr;
}

/*
 *	ITextRange::ScrollIntoView(long Code) 
 *
 *	@mfunc
 *		Method that scrolls this range into view according to the
 *		code Code defined below.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ScrollIntoView (
	long Code)			//@parm Scroll code
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ScrollIntoView");

    // Check for invalid bits
    if (Code & ~(tomStart + tomEnd + TA_LEFT + TA_TOP + TA_BOTTOM + 
                TA_CENTER + TA_STARTOFLINE + TA_ENDOFLINE + TA_LOGICAL))
        return E_INVALIDARG;

    // Validate parameter
	long lCode = tomEnd;
	if (Code & tomStart)
	    lCode = tomStart;

	Code &= ~tomStart;

	if(IsZombie())
		return CO_E_RELEASED;

	// Get local copy of ped to save some indirections.
	CTxtEdit *ped = GetPed();

	if (!ped->fInplaceActive())
	{
		// If the control is not active, we can't get the information
		// because no one knows what our client rect is.
		return E_FAIL;
	}

	// Get a local copy of display to save some indirections. 
	CDisplay *pdp = ped->_pdp;

	if (pdp->IsFrozen())
	{
		return E_FAIL;
	}

	LONG cpStart;
	LONG cpForEnd;

	GetRange(cpStart, cpForEnd);

	// Get the view rectangle so we can compute the absolute x/y 
	RECTUV rcView;
	pdp->GetViewRect(rcView, NULL);

	// Set up tp for PointFromTp call
	CRchTxtPtr rtp(*this);

	if(_cch > 0)
		rtp.Move(-_cch);

	// Values used for making returned point locations absolute since
	// PointFromTp adjusts the point returned to be relative to the
	// display.
	const LONG upScrollAdj = pdp->GetUpScroll() - rcView.left;
	const LONG vpScrollAdj = pdp->GetVpScroll() - rcView.top;

	// Get the left/top for the start
	BOOL     taMask = Code & TA_STARTOFLINE; //set beginning of line flag
	BOOL	 fAtEnd = _cch ? TRUE : !rtp._rpTX.IsAfterEOP();
	POINTUV	 ptStart;
	CLinePtr rpStart(pdp);
	LONG	 iliStart = pdp->PointFromTp(rtp, NULL, _cch ? FALSE : fAtEnd,
										 ptStart, &rpStart, (lCode == tomStart && Code) ?  Code : 
										 TA_TOP + TA_LEFT);
	ptStart.u += upScrollAdj;
	ptStart.v += vpScrollAdj;

	// Get the right/bottom for the end
	rtp.SetCp(cpForEnd);

	POINTUV	 ptEnd;
	CLinePtr rpEnd(pdp);
	LONG	 iliEnd = pdp->PointFromTp(rtp, NULL, fAtEnd, ptEnd, &rpEnd, 
	                                   (lCode == tomEnd && Code) ?  Code : 
									   TA_BOTTOM + TA_RIGHT);
	ptEnd.u += upScrollAdj;
	ptEnd.v += vpScrollAdj;

	//
	// Calculate the vpScroll 
	//

	// The basic idea is to display both the start and the end if possible. But 
	// if it is not possible then display the requested end based on the input 
	// parameter.

	LONG dvpView = pdp->GetDvpView();
	LONG vpScroll;

	if (tomStart == lCode)
	{
		// Scroll the Start cp to the top of the view
		vpScroll = ptStart.v;
	}
	else
	{
		// Scroll the End cp to the bottom of the view
		vpScroll = ptEnd.v;
		if (!pdp->IsInPageView())
			vpScroll -= dvpView;
	}

	//
	// Calculate the X Scroll
	// 

	// Default scroll to beginning of the line
	LONG upScroll = 0;

	// Make view local to save a number of indirections
	LONG dupView = pdp->GetDupView();

	if (iliStart == iliEnd)
	{
		// Entire selection is on the same line so we want to display as
		// much of it as is possible.
		LONG xWidthSel = ptEnd.u - ptStart.u;

		if (xWidthSel > dupView)
		{
			// Selection length is greater than display width
			if (tomStart == lCode)
			{
				// Show Start requested - just start from beginning
				// of selection
				upScroll = ptStart.u;
			}
			else
			{
				// Show end requested - show as much of selection as
				// possible, ending with last character in the 
				// selection.
				upScroll = ptEnd.u - dupView;
			}
		}
		else if (xWidthSel < 0)
		{
		    xWidthSel = -xWidthSel;
		    if (xWidthSel > dupView)
		    {
    		    if (tomStart == lCode)
    		    {
    		        // Show Requested Start;
    		        upScroll = max(0, ptStart.u - dupView);		        
    		    }
    		    else
    		    {
    		        upScroll = max(0, ptEnd.u - dupView);
    		    }
    		}
    		else if (ptEnd.u > dupView || ptStart.u > dupView)
    		{
    		    // Check mask if position is outside the boundaries
    		    if (taMask)
    		        upScroll = ptStart.u - dupView;
    		    else
    		        upScroll = ptEnd.u - dupView;
    		}		    
		}
		else if (ptEnd.u > dupView || ptStart.u > dupView)
		{
		    // Check mask if position is outside the boundaries
			if (taMask)
		        upScroll = ptStart.u - dupView;
		    else
		        upScroll = ptEnd.u - dupView;
		}
	}	
	else 
	{
		// Multiline selection. Display as much as possible of the requested
		// end's line.

		// Calc width of line
		LONG xWidthLine = (tomStart == lCode)
			? rpStart->_dup + rpStart->_upStart
			: rpEnd->_dup + rpEnd->_upStart;


		// If line width is less than or equal to view, start at 
		// 0 otherwise we need to adjust starting position to 
		// show as much of the requested end's selection line 
		// as possible.
		if(xWidthLine > dupView)
		{
			if(tomStart == lCode)
			{
				// Start end to be displayed

				if(xWidthLine - ptStart.u > dupView)
				{
					// Selection is bigger than view, so start at beginning
					// and display as much as possible.
					upScroll = ptStart.u;
				}
				else
				{
					// Remember that this is a multiline selection so the 
					// selection on this line goes from ptStart.x to the 
					// end of line. Since the selection width is less than 
					// the width of the view, we just back up the width
					// of view to show the entire selection.
					upScroll = xWidthLine - dupView;
				}
			}
			else
			{
				// Show the end of the selection. In the multiline case,
				// this goes from the beginning of the line to End. So
				// we only have to adjust if the End is beyond the view.
				if(ptEnd.u > dupView)
				{
					// End beyond the view. Show as much as possible
					// of the selection.
					upScroll = ptEnd.u - dupView;
				}
			}
		}
	}

	// Do the scroll
	pdp->ScrollView(upScroll, vpScroll, FALSE, FALSE);

	return S_OK;
}

/*
 *	CTxtRange::Select ()
 *
 *	@mfunc
 *		Copy this range's cp's and story ptr to the active selection.
 *
 *	@rdesc
 *		HRESULT = (if selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Select ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Select");

	if(IsZombie())
		return CO_E_RELEASED;
 
	CCallMgr	   callmgr(GetPed());
	CTxtSelection *pSel = GetPed()->GetSel();

	if(pSel)
	{
		LONG cpMin, cpMost;
		GetRange(cpMin, cpMost);
		if (pSel->SetRange(cpMin, cpMost) == S_FALSE)
			pSel->Update(TRUE);	// Force a update selection
		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CTxtRange::SetChar (Char)
 *
 *	@mfunc
 *		Set char at cpFirst = <p Char>
 *
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (char stored) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Special cases could be much faster, e.g., just overtype the plain-
 *		text backing store unless at EOD or EOR.  Code below uses a cloned
 *		range to handle all cases easily and preserve undo capability.
 */
STDMETHODIMP CTxtRange::SetChar (
	long Char)				//@parm New value for char at cpFirst
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetChar");
	
	if(IsZombie())
		return CO_E_RELEASED;

	CTxtEdit *		ped = GetPed();
	CCallMgr		callmgr(ped);
	WCHAR			ch = (WCHAR)Char;			// Avoid endian problems
	CTxtRange		rg(*this);
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);
	CFreezeDisplay	fd(ped->_pdp);

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	if(!ped->_pdp->IsMultiLine() && IsEOP(Char))// EOPs are not	allowed in
		return S_FALSE;							//  single-line edit controls

	if(Char == CELL || IN_RANGE(STARTFIELD, Char, NOTACHAR))
		return S_FALSE;							// Can't insert table structure
												//  chars
	undobldr.StopGroupTyping();

	rg.Collapser(tomStart);						// Collapse at cpMin

	unsigned ch1 = rg._rpTX.GetChar();
	if(ch1 == CELL || IN_RANGE(STARTFIELD, ch1, NOTACHAR))
		return S_FALSE;							// Can't replace table structure
												//  chars
	rg.Move(1, TRUE);							// Try to select char at IP
    ped->OrCharFlags(GetCharFlags(&ch, 1), publdr);
	if(rg.ReplaceRange(1, &ch, publdr, SELRR_REMEMBERRANGE))
	{
		Update(TRUE);							// Update selection
		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CTxtRange::SetEnd (cp)
 *
 *	@mfunc
 *		Set this range's End cp
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *	@comm
 *		Note that setting this range's cpMost to <p cp> also sets cpMin to
 *		<p cp> if <p cp> < cpMin.
 */
STDMETHODIMP CTxtRange::SetEnd (
	long cp)							//@parm Desired new End cp
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetEnd");

	if(IsZombie())
		return CO_E_RELEASED;

	LONG cpMin = GetCpMin();

	ValidateCp(cp);
	return SetRange(min(cpMin, cp), cp);		// Active end is End
}

/*
 *	CTxtRange::SetFont (pFont)
 *
 *	@mfunc
 *		Set this range's character attributes to those given by <p pFont>.
 *		This method is a "character format painter".
 *
 *	@rdesc
 *		HRESULT = (!pFont) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetFont (
	ITextFont * pFont)	//@parm Font object with desired character formatting  
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFont");

	if(!pFont)
		return E_INVALIDARG;
	
	if(IsZombie())
		return CO_E_RELEASED;

	ITextFont *pFontApply = (ITextFont *) new CTxtFont(this);

	if(!pFontApply)
		return E_OUTOFMEMORY;

	HRESULT hr;
	if(*(LONG *)pFontApply == *(LONG *)pFont)		// If same vtable, use
		hr = CharFormatSetter(&((CTxtFont *)pFont)->_CF, //  its copy
					((CTxtFont *)pFont)->_dwMask);
	else											// Else copy
		hr = pFontApply->SetDuplicate(pFont);		//  to clone and apply

	pFontApply->Release();
	return hr;
}

/*
 *	CTxtRange::SetFormattedText (pRange)
 *
 *	@mfunc
 *		Replace this range's text with formatted text given by <p pRange>.
 *		If <p pRange> is NULL, paste from the clipboard.
 *
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *	@FUTURE
 *		Do this more efficiently if pRange points at a RichEdit range. This
 *		would also help with RichEdit D&D to RichEdit targets
 */
STDMETHODIMP CTxtRange::SetFormattedText (
	ITextRange * pRange)		//@parm Formatted text to replace this 
								// range's text
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFormattedText");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	LONG		cpMin = GetCpMin();
	HRESULT		hr;
	IUnknown *	pdo = NULL;
	VARIANT		vr;

	if(!pRange)
		return NOERROR;					// Nothing to paste

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	VariantInit(&vr);
	vr.vt = VT_UNKNOWN | VT_BYREF;
	vr.ppunkVal = &pdo;

	hr = pRange->Copy(&vr);
	if(hr == NOERROR)
	{
		hr = Paste(&vr, 0);
		pdo->Release();					// Release the data object
		_cch = GetCp() - cpMin;			// Select the new text
	}
	return hr;
}

/*
 *	CTxtRange::SetIndex (Unit, Index, Extend)
 *
 *	@mfunc
 *		If <p Extend> is zero, convert this range into an insertion point
 *		at the start of the	<p Index>th <p Unit> in the current story. If
 *		<p Extend> is nonzero, set this range to consist of this unit. The
 *		start of the story corresponds to <p Index> = 0 for all units.
 *
 *		Positive indices are 1-based and index relative to the beginning of
 *		the story.  Negative indices are -1-based and index relative to the
 *		end of the story.  So an index of 1 refers to the first Unit in the
 *		story and an index of -1 refers to the last Unit in the story.
 *
 *	@rdesc
 *		HRESULT = (invalid index) ? E_INVALIDARG :
 *				  (Unit not supported) ? E_NOTIMPL :
 *				  (change) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Currently moves out <p Index> <p Unit>s from the start of the story.
 *		Might be faster to move from current position, but would need to know
 *		the current index.
 */
STDMETHODIMP CTxtRange::SetIndex (
	long	Unit,			//@parm Unit to index
	long	Index,			//@parm Index value to use
	long	Extend)			//@parm if nonzero, set range to <p Unit>
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetIndex");
	
	if(IsZombie())
		return CO_E_RELEASED;

	if(!Index)
		return E_INVALIDARG;

	CCallMgr	callmgr(GetPed());

	LONG	  cchText = GetTextLength();
	CTxtRange rg(GetPed());						// Create IP at cp = 0

	if(Index > 0)								// Index going forward First
		Index--;								//  Unit is at start of	story
	else										// Index from end of story
		rg.Set(cchText, cchText);				//  selecting whole story

	LONG	cUnit;
	HRESULT hr = rg.Mover(Unit, Index, &cUnit, MOVE_END);
	if(FAILED(hr))
		return hr;

	if(Index != cUnit || rg.GetCp() == cchText)	// No such index in story
		return E_INVALIDARG;

	rg._cch = 0;								// Collapse at active end
												//  namely at cpMost
	LONG cpMin, cpMost;
	if(Extend)									// Select Index'th Unit
		rg.Expander(Unit, TRUE, NULL, &cpMin, &cpMost);

	if(Set(rg.GetCp(), rg._cch))				// Something changed
	{
		Update(TRUE);
		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CTxtRange::SetPara (pPara)
 *
 *	@mfunc
 *		Set this range's paragraph attributes to those given by <p pPara>
 *		This method is a "Paragraph format painter".
 *
 *	@rdesc
 *		HRESULT = (!pPara) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetPara (
	ITextPara * pPara)		//@parm Paragraph object with desired paragraph
{							//		formatting
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPara");

	if(!pPara)
		return E_INVALIDARG;

	if(IsZombie())
		return CO_E_RELEASED;

	ITextPara * pParaApply = (ITextPara *) new CTxtPara(this);

	if(!pParaApply)
		return E_OUTOFMEMORY;

	HRESULT hr;

	if(*(LONG *)pParaApply == *(LONG *)pPara)		// If same vtable, use
	{												//  its _PF
		hr = ParaFormatSetter(&((CTxtPara *)pPara)->_PF,
					((CTxtPara *)pPara)->_dwMask);
	}
	else											// Else copy
	   hr = pParaApply->SetDuplicate(pPara);		//  to clone and apply

	pParaApply->Release();
	return hr;
}

/*
 *	CTxtRange::SetPoint (x, y, Type, Extend)
 *
 *	@mfunc
 *		Select text at or up through (depending on <p Extend>) the point
 *		(<p x>, <p y>).
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtRange::SetPoint (
	long	x,			//@parm Horizontal coord of point to select
	long	y,			//@parm	Vertical   coord of point to select
	long	Type,		//@parm Defines the end to extend if Extend != 0.
	long 	Extend) 	//@parm Whether to extend selection to point
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPoint");

	if(IsZombie())
		return CO_E_RELEASED;

	// Copy the ped locally once to save some indirections
	CTxtEdit *ped = GetPed();
	CCallMgr  callmgr(ped);

	if(Type != tomStart && Type != tomEnd)
		return E_INVALIDARG;

	if(!ped->fInplaceActive())
	{
		// If we aren't inplace active we can't get a DC to
		// calculate the cp.
		return OLE_E_NOT_INPLACEACTIVE;
	}

	// Convert (x, y) from screen coordinates to client coordinates
	POINT ptxy = {x, y};
	// Caller specifies screen coordinates?
	if ( !(Type & tomClientCoord) )
		if(!ped->TxScreenToClient(&ptxy))
			return E_FAIL;			// It is unexpected for this to happen

	// Get cp for (x, y)
	POINTUV pt;	
	ped->_pdp->PointuvFromPoint(pt, ptxy);
	LONG cpSel = ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, TRUE);
	if(cpSel == -1)
		return E_FAIL;			// It is highly unexpected for this to fail

	// Extend range as requested
	LONG cchForSel = 0;
	if(Extend)
	{
		LONG cpMin, cpMost;
		GetRange(cpMin, cpMost);
		if(Type == tomStart)
			cchForSel = cpSel - cpMin;
		else
			cchForSel = cpSel - cpMost;
	}

	// Update range
	Set(cpSel, cchForSel);
	return S_OK;
}

/*
 *	CTxtRange::SetRange (cp1, cp2)
 *
 *	@mfunc
 *		Set this range's ends
 *
 *	@rdesc
 *		HRESULT = (cp1 > cp2) ? E_INVALIDARG
 *				: (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetRange (
	long cp1,		//@parm Char position for Start end
	long cp2)		//@parm Char position for End end 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetRange");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	LONG cpMin, cpMost;					// Save starting cp's for
										//  change determination
	GetRange(cpMin, cpMost);
	ValidateCp(cp1);
	ValidateCp(cp2);

	Set(cp2, cp2 - cp1);
	GetRange(cp1, cp2);					// See if either range end changed
	if(cp1 != cpMin || cp2 != cpMost)	//  (independent of active end)
	{
		Update(TRUE);					// Update selection
		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CTxtRange::SetStart (cp)
 *
 *	@mfunc
 *		Set this range's Start cp
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *	@comm
 *		Note that setting this range's cpMin to <p cp> also sets cpMost to
 *		<p cp> if <p cp> > cpMost.
 */
STDMETHODIMP CTxtRange::SetStart (
	long cp)							//@parm Desired new Start cp
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetStart");
	
	if(IsZombie())
		return CO_E_RELEASED;

	LONG cpMost = GetCpMost();

	ValidateCp(cp);
	return SetRange(max(cpMost, cp), cp);		// Active end is Start
}

/*
 *	CTxtRange::SetText (bstr)
 *
 *	@mfunc
 *		Replace text in this range by that given by <p bstr>.  If <p bstr>
 *		is NULL, delete text in range.
 *
 *	@rdesc
 *		HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetText (
	BSTR bstr)			//@parm Text to replace text in this range by
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetText");

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	LONG cchNew = bstr ? SysStringLen(bstr) : 0;
	_cch = Replacer(cchNew, (WCHAR *)bstr, RR_ITMZ_UNICODEBIDI);	// Select the new text

	_TEST_INVARIANT_

	GetPed()->TxSetMaxToMaxText();

	return _cch == cchNew ? NOERROR : S_FALSE;
}

/*
 *	CTxtRange::StartOf (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Move this range end(s) to start of the first overlapping Unit in
 *		the range.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::StartOf (
	long 	Unit,			//@parm Unit to use
	long 	Extend,			//@parm If true, leave other end alone 
	long *	pDelta)			//@parm Out parm to get count of chars that
							// 		StartOf moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::StartOf");

	CCallMgr callmgr(GetPed());
	LONG	 cpMin;
	HRESULT	 hr = Expander (Unit, Extend, pDelta, &cpMin, NULL);

	if(hr == NOERROR)
		Update(TRUE);					// Update selection

	return hr;
}


//---------------------- CTxtRange ITextSelection stubs -----------------------------

// Dummy CTxtRange routines to simplify CTxtSelection inheritance hierarchy

STDMETHODIMP CTxtRange::GetFlags (long * pFlags) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFlags");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::SetFlags (long Flags) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFlags");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::GetType (long * pType) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetType");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveLeft (long Unit, long Count, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Left");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveRight (long Unit, long Count, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Right");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveUp (long Unit, long Count, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Up");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveDown (long Unit, long Count, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Down");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::HomeKey (long Unit, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::HomeKey");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::EndKey (long Unit, long Extend, long * pDelta) 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndKey");
	return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::TypeText (BSTR bstr)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::TypeText");
	return E_NOTIMPL;
}


//--------------------- ITextRange Private Helper Methods -----------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtRange::Collapser (bStart)
 *
 *	@mfunc
 *		Internal routine to collapse this range into a degenerate point
 *		either at the the start (<p bStart> is nonzero or the end
 *		(<p bStart> = 0)
 */
void CTxtRange::Collapser (
	long bStart) 			//@parm Flag specifying end to collapse at
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEEXTERN, "CTxtRange::Collapser");

	if(bStart)							// Collapse to Start
	{
		if(_cch > 0)
			FlipRange();				// Move active end to range Start
	}
	else								// Collapse to End
	{
		if(_cch < 0)
			FlipRange();				// Move active end to range End

		const LONG cchText = GetAdjustedTextLength();

		if(GetCp() > cchText)			// IP can't follow final CR
			Set(cchText, 0);			//  so move it before
	}
	if(_cch)
		_fMoveBack = bStart != 0;
	_cch = 0;							// Collapse this range
	_fSelHasEOP = FALSE;				// Insertion points don't have
	_fSelExpandCell = FALSE;			//  EOPs, table rows or Cells
	_nSelExpandLevel = 0;

	if(_fSel)							// Notify if selection changed
		GetPed()->GetCallMgr()->SetSelectionChanged();

	Update_iFormat(-1);					// Make sure format is up to date
}

/*
 *	CTxtRange::Comparer(pRange)
 *
 *	@mfunc
 *		helper function for CTxtRange::InRange() and IsEqual()
 *
 *	@rdesc
 *		0 if not same story or if this range isn't contained by <p pRange>;
 *		-1 if ranges are equal; 1 if this range wholely contained in
 *		<p pRange>.
 *
 *	@comm
 *		Note that if this range is degenerate and *pRange is nondegenerate,
 *		this range is not included in *pRange if it's located at pRange's
 *		End position.
 */
LONG CTxtRange::Comparer (
	ITextRange * pRange)		//@parm ITextRange to compare with
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Comparer");

	LONG	cpMin, cpMost;
	LONG	Start, End;

	if(InStory(pRange, NULL) != NOERROR)	// If this range doesn't point at
		return 0;							//  same story as pRange's,
											//  return 0
	GetRange(cpMin, cpMost);				// Get this range's cp's
	pRange->GetStart(&Start);				// Get pRange's cp's
	pRange->GetEnd(&End);
	if(cpMin == Start && cpMost == End)		// Exact match
		return -1;
	return cpMin >= Start && cpMost <= End && cpMin < End;
}

/*
 *	CTxtRange::Expander (Unit, fExtend, pDelta, pcpMin, pcpMost)
 *
 *	@mfunc
 *		Helper function that expands this range so that partial Units it
 *		contains are completely contained according to the out parameters
 *		pcpMin and pcpMost.  If pcpMin is not NULL, the range is expanded to
 *		the	beginning of the Unit.  Similarly, if pcpMost is not NULL, the
 *		range is expanded to the end of the Unit. <p pDelta> is an out
 *		parameter that receives the number of chars	added to the range.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if Unit valid) ? S_FALSE : E_INVALIDARG
 *
 *	@devnote
 *		Used by ITextRange::Expand(), StartOf(), and EndOf(). Both pcpMin and
 *		pcpMost are nonNULL for Expand().  pcpMin is NULL for EndOf() and
 *		pcpMost is NULL for StartOf().
 *
 *	@future
 *		Discontiguous Units. Expander should expand only to end of Unit,
 *		rather than to start of next Unit.
 */
HRESULT CTxtRange::Expander (
	long	Unit,		//@parm Unit to expand range to
	BOOL	fExtend,	//@parm Expand this range if TRUE
	LONG *	pDelta,		//@parm Out parm that receives chars added
	LONG *	pcpMin,		//@parm Out parm that receives new cpMin
	LONG *	pcpMost)	//@parm Out parm that receives new cpMost
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Expander");
	
	if(IsZombie())
		return CO_E_RELEASED;

	LONG	cch = 0;						// Default no chars added
	LONG	cchRange;
	LONG	cchAdjustedText = GetAdjustedTextLength();
	LONG	cchText = GetTextLength();
	LONG	cp;
	LONG	cpMin, cpMost;
	BOOL	fUnitFound = TRUE;				// Most Units can be found
	LONG	cchCollapse;
	CDisplay *pdp;							//  but tomObject maybe not

	GetRange(cpMin, cpMost);				// Save starting cp's
	if(pcpMin)								// Default no change
	{
		*pcpMin = cpMin;
		AssertSz(!pcpMost || fExtend,
			"CTxtRange::Expander should extend if both pcpMin and pcpMost != 0");
	}
	if(pcpMost)
		*pcpMost = cpMost;
	if(pDelta)
		*pDelta = 0;

	if(Unit < 0)
	{
		// Valid attribute Units are high bit plus any combo of CFE_xxx. 
		// CFE_REVISED is most significant value currently defined.
		if(Unit & ~(2*CFM_REVISED - 1 + 0x80000000))
			return E_NOTIMPL;
		FindAttributes(pcpMin, pcpMost, Unit);
	}
	else
	{
		switch(Unit)						// Calculate new cp's
		{
		case tomObject:
			fUnitFound = FindObject(pcpMin, pcpMost);
			break;

		case tomCharacter:
			if (pcpMost && cpMin == cpMost &&// EndOf/Expand insertion point
				cpMost < cchText &&			//  with at least 1 more char
				(!cpMost || pcpMin))		//  at beginning of story or
			{								//  Expand(), then
				(*pcpMost)++;				//  expand by one char
			}
			break;

		case tomCharFormat:
			_rpCF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
			break;

		case tomParaFormat:
			_rpPF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
			break;

		case tomWord:
			FindWord (pcpMin, pcpMost, FW_INCLUDE_TRAILING_WHITESPACE);
			break;

		case tomSentence:
			FindSentence (pcpMin, pcpMost);
			break;

		case tomCell:
			FindCell (pcpMin, pcpMost);
			break;

		case tomRow:
			pdp = GetPed()->_pdp;
			if(!IsRich() || pdp && !pdp->IsMultiLine())
				return E_INVALIDARG;
			FindRow (pcpMin, pcpMost);
			break;							

		case tomScreen:						// Could be supported 
			if(!GetPed()->IsInPageView())	//  in Normal View using 
				return E_NOTIMPL;			//  ITextSelection::Down()
			Unit = tomPage;					// In Page View, it's an alias
											//  for tomPage
		case tomPage:
		case tomLine:
			pdp = GetPed()->_pdp;
			if(pdp)							// If this story has a display
			{								//  use line array
				CLinePtr rp(pdp);
				cp = GetCp();
				pdp->WaitForRecalc(cp, -1);
				rp.SetCp(cp, FALSE);
				if(Unit == tomLine || !rp.IsValid() || !pdp->IsInPageView())
					rp.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
				else
					rp.FindPage(pcpMin, pcpMost, cpMin, _cch, cchText);
				break;
			}
			if(Unit == tomPage)
				return S_FALSE;
											// Else fall thru to tomPara
		case tomParagraph:
			FindParagraph(pcpMin, pcpMost);
			break;

		case tomWindow:
			fUnitFound = FindVisibleRange(pcpMin, pcpMost);
			break;

		case tomStory:
			if(pcpMin)
				*pcpMin = 0;
			if(pcpMost)
				*pcpMost = cchText;
			break;

		default:
			return E_NOTIMPL;
		}
	}
	if(!fUnitFound)
		return S_FALSE;

	cchCollapse = !fExtend && _cch;			// Collapse counts as a char
								 			// Note: Expand() has fExtend = 0
	if(pcpMin)
	{
		cch = cpMin - *pcpMin;				// Default positive cch for Expand
		cpMin = *pcpMin;
	}

	if(pcpMost)								// EndOf() and Expand()
	{
		if(!fExtend)						// Will be IP if not already
		{
			if(cpMost > cchAdjustedText)	// If we collapse (EndOf only),
				cchCollapse = -cchCollapse;	//  it'll be before the final CR
			else
				*pcpMost = min(*pcpMost, cchAdjustedText);
		}
		cch += *pcpMost - cpMost;
		cp = cpMost = *pcpMost;
	}
	else									// StartOf()
	{
		cch = -cch;							// Invert count
		cp = cpMin;							// Active end at cpMin
		cchCollapse = -cchCollapse;			// Backward collapses count as -1
	}

	cch += cchCollapse;						// Collapse counts as a char
	if(cch)									// One or both ends changed
	{
		cchRange = cpMost - cpMin;			// cch for EndOf() and Expand()
		if(!pcpMost)						// Make negative for StartOf()
			cchRange = -cchRange;
		if(!fExtend)						// We're not expanding (EndOf()
			cchRange = 0;					//  or StartOf() call)
		if(Set(cp, cchRange))				// Set active end and signed cch
		{									// Something changed
			if(pDelta)						// Report cch if caller cares
				*pDelta = cch;
			return NOERROR;
		}
	}
	
	return S_FALSE;							// Report Unit found but no change
}

/*
 *	CTxtRange::Finder (bstr, Count, dwFlags, pDelta, Mode)
 *
 *	@mfunc
 *		Helper find function that moves active end up to <p cch> characters
 *		subject	to compare flags <p Flags> and the <p Mode>, which has the
 *		following possible values:
 *
 *		1:	set this range's cpMost = cpMost of matched string
 *		0:	set this range's cp's equal to those of matched string
 *		-1:	set this range's cpMin = cpMin of matched string
 *
 *		Return *<p pDelta> = # characters past.
 *
 *	@rdesc
 *		HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Used by ITextRange::FindText(), FindTextStart() and FindTextEnd()
 */
HRESULT CTxtRange::Finder (
	BSTR	bstr,		//@parm String to find
	long	Count,		//@parm Max count of chars to search
	long	Flags,		//@parm Flags governing compares
	LONG *	pDelta,		//@parm Out parm to receive count of chars moved
	MOVES	Mode)		//@parm Governs setting of range wrt matched string
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Finder");

	if(!bstr)
		return S_FALSE;

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());

	LONG		cpMin, cpMost;
	LONG		cch = GetRange(cpMin, cpMost);	// Get this range's cp's
	LONG		cchBstr = SysStringLen(bstr);
	LONG		cchSave = _cch;
	LONG		cp, cpMatch, cpSave;
	LONG		cpStart = cpMost;				// Default Start cp to range
	CRchTxtPtr	rtp(*this);						//  End

	if(Mode == MOVE_IP)							// FindText(): Count = 0 is
	{											//  treated specially: if IP,
		if(!Count)								//  compare string at IP; else
			Count = cch ? cch : cchBstr;		//  confine search to range
		if(Count > 0)							// Forward searches start from
			cpStart = cpMin;					//  beginning of range
	}
	else										// FindTextStart() or
	{											//   FindTextEnd()
		if(!Count)								// Compare string at IP; else
			Count = cch ? -Mode*cch : cchBstr;	//  confine search to range
		if(Mode < 0)							// Find from Start
			cpStart = cpMin;
	}

	cpSave = cpStart;							// Save starting cp
	cp = cpStart + Count;						// cp = limiting cp. Can be on
	cp = max(cp, 0);							//  either side of cpStart
	Flags &= ~FR_DOWN;							// Default search backward
	if(Count >= 0)								// It's forward, so set
		Flags |= FR_DOWN;						//  downward search bit

find:
	rtp.SetCp(cpStart);							// Move to start of search
	cpMatch = rtp.FindText(cp, Flags, bstr, cchBstr);
	if (Mode == MOVE_IP && cpMatch == cpMin &&	// Ordinary Find matched
		rtp.GetCp() == cpMost)					//  current range
	{
		Assert(cpStart == cpSave);				// (Can't loop twice)
		cpStart += Count > 0 ? 1 : -1;			// Move over one char
		goto find;								//  and try again
	}

	if(cpMatch < 0)								// Match failed
	{
		if(pDelta)								// Return match string length
			*pDelta = 0;						//  = 0
		return S_FALSE;							// Signal no match
	}


	// Match succeeded: set new cp and cch for range, update selection (if
	// this range is a selection), send notifications, and return NOERROR

	cp = rtp.GetCp();							// cp = cpMost of match string
	cch = cp - cpMatch;							// Default to select matched
												//  string (for MOVE_IP)
	if(pDelta)									// Return match string length
		*pDelta = cch;							//  if caller wants to know

	if(Mode != MOVE_IP)							// MOVE_START or MOVE_END
	{
		if(Mode == MOVE_START)					// MOVE_START moves to start
			cp = cpMatch;						//  of matched string
		cch = cp - cpSave;						// Distance end moved
		if(!cchSave && (Mode ^ cch) < 0)		// If crossed ends of initial
			cch = 0;							//  IP, use an IP
		else if(cchSave)						// Initially nondegenerate
		{										//  range
			if((cchSave ^ Mode) < 0)			// If wrong end is active,
				cchSave = -cchSave;				//  fake a FlipRange to get
			cch += cchSave;						//  new length
			if((cch ^ cchSave) < 0)				// If ends would cross,
				cch = 0;						//  convert to insertion point
		}
	}
	if ((cp != GetCp() || cch != _cch)			// Active end and/or length of
		&& Set(cp, cch))						//  range changed
	{											// Use the new values
		Update(TRUE);							// Update selection
	}
	return NOERROR;
}

/*
 *	CTxtRange::Matcher (Cset, Count, pDelta, fExtend, Match)
 *
 *	@mfunc
 *		Helper function to move active end up to <p cch> characters past
 *		all contiguous characters that are (<p Match> ? in : not in) the cset
 *		*<p pvar>.  If <p fExtend>, extend the range to include the characters
 *		past by. Return *<p pDelta> = # characters past by.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Matcher (
	VARIANT	*	Cset,		//@parm Character match set
	long		Count,		//@parm Max cch to match 
	long *		pDelta,		//@parm Out parm for cch moved 
	MOVES		Mode,		//@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
	MATCHES		Match)		//@parm MATCH_WHILE spans Cset; else break on Cset
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Matcher");

	// This (and other) code assumes the following conditions:
	Assert(MOVE_START == -1 && MOVE_IP == 0 && MOVE_END == 1);
	Assert(MATCH_UNTIL == 0 && MATCH_WHILE == 1);
	Assert(sizeof(WORD) == 2);						// 16-bit WORDs

	if(!Cset)
		return E_INVALIDARG;

	if(IsZombie())
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	LONG	cch;									// For cch moved
	WCHAR	ch;										// Current char
	LONG	count = Count;							// Count down variable
	LONG	cpSave;									// To save initial cp
	WORD	ctype;									// CT_TYPEx info for ch
	long	Delta;									// Value for *pDelta
	BOOL	fInCset;								// TRUE iff ch in Cset
	UINT	i, j;									// Handy indices
	LONG	iDir = (Count > 0) ? 1 : -1;			// Count increment
	long	lVal = Cset->lVal;
	WCHAR *	pch;									// Used to walk BSTR Cset
	CTxtPtr tp(_rpTX);								// tp to walk text with
	LONG	vt = Cset->vt;

	if(pDelta)										// Default neither motion
		*pDelta = 0;								//  nor match

	if (Mode == MOVE_IP && (_cch ^ Count) < 0 ||	// Wrong active	end:
		Mode != MOVE_IP && (_cch ^ Mode)  < 0) 
	{
		tp.Move(-_cch);								//  go to other end
	}
	cpSave = tp.GetCp();							// Save cp for checks

	if(Count > 0)									// If matching forward,
	{												//  get current char
		ch = tp.GetChar();
		count--;									// One less char to match
	}
	else											// If matching backward,
		ch = tp.NextCharCount(count);				//  start at previous char
													
	if(!ch)											// At one end or other, so
		return S_FALSE;								//  signal no match


	// Process built-in and explicit character sets
	if(vt & VT_BYREF)								// VB passes VT_BYREF
	{												//  unless args are
		lVal = *Cset->plVal;						//  enclosed in ()'s
		vt &= ~ VT_BYREF;
	}

	if(vt == VT_I2)									// Should be VT_I4, but
		lVal &= 0xffff;								//  facilitate common cases

	// Built-in char set: either Unicode range or CT_CTYPEx
	if(vt == VT_I4 || vt == VT_I2)
	{
		i = lVal & 0xffff;							// First code or CT mask
		j = lVal >> 16;								// Size of range
		if(lVal < 0)								// Unicode range Cset
		{											//  (sign bit is set)
			j &= 0x7fff;							// Kill sign bit
			while (((BOOL)Match ^ (ch - i > j)) &&		// ch in range or not
				   (ch = tp.NextCharCount(count)))	// Another char available
				   ;								// Note: count is passed
		}											//  by reference
		else										// CT_CTYPEx Cset
		{											// CT_CTYPEx is given by
			if(!j)									//  upper WORD of lVal
				j = CT_CTYPE1;						// 0 defaults to CT_CTYPE1
			do
			{
				ctype = 0;							// For each char, get
													//  string type info
				W32->GetStringTypeEx(0, j, &ch, 1, &ctype);

				// Loop (up to |Count| - 1 times) as long as the characters
				// encountered are in the Cset (Match = MATCH_WHILE (=1)),
				// or as long as they are not  (Match = MATCH_UNTIL (=0)).

				fInCset = (j == CT_CTYPE2)			// CT_CTYPE2 values are
						? (ctype == i)				//  mutually exclusive;
						: (ctype & i) != 0;	   		//  others can be combos

			} while ((Match ^ fInCset) == 0 &&
					 (ch = tp.NextCharCount(count)) != 0);
		}											// End of built-in Csets
	}												// End of Cset VT_I4

	// Explicit char set given by chars in Cset->bstrVal
	else if (Cset->vt == VT_BSTR)
	{
		//REVIEW (keithcu) What is going on here?
		if((DWORD_PTR)Cset->bstrVal < 0xfffff)		// Don't get fooled by
			return E_INVALIDARG;					//  invalid vt values
		j = SysStringLen(Cset->bstrVal);
		do
		{											// Set i = 0 if ch isn't
			pch = Cset->bstrVal;				//  in set; this stops
			for(i = j;								//  movement
				i && (ch != *pch++);				
				i--) ;
		
		// If we are doing a MATCH_WHILE routine then we only
		// continue while i > 0 becuase this indicates that we
		// found the char at the current cp in the CSet.  If
		// we were doing a MATCH_UNTIL then we should quit when
		// i != 0 becuase the current char was in the CSet.
		} while((Match == (i ? MATCH_WHILE : MATCH_UNTIL)) &&
			(ch = tp.NextCharCount(count)));		// Break if no more chars
	}												//  or ch not in set
	else
		return E_INVALIDARG;

	/* If MoveWhile, leave tp immediately after last matched char going
	 * forward and at that char going backward (helps to think of tp
	 * pointing in between chars).  If MoveUntil, leave tp at the char
	 * going forward and just after that char going backward.
	 *
     * E.g.: the code
	 *
	 *		r.MoveUntil	  (C1_DIGIT, tomForward, NULL)
	 *		r.MoveEndWhile(C1_DIGIT, tomForward, NULL)
	 *
	 * breaks at the first digit and selects the number going forward.
	 * Similarly
	 *
	 *		r.MoveUntil		(C1_DIGIT, tomBackward, NULL)
	 *		r.MoveStartWhile(C1_DIGIT, tomBackward, NULL)
	 *
	 * selects the number going backward.
	 */
	count = (Match == MATCH_WHILE && !ch)			// If MoveWhile, move past
		  ? iDir : 0;								//  last matched char
	if(Count < 0)
		count++;
	tp.Move(count);

	Delta = cch = 0;								// Suppress motion unless
	if(Match == MATCH_WHILE || ch)					//  match occurred
	{
		Delta = cch = tp.GetCp() - cpSave;			// Calculate distance moved
		if(Match == MATCH_UNTIL)					// For MoveUntil methods,
			Delta += iDir;							//  match counts as a char
	}

	if(pDelta)										// Report motion to caller
		*pDelta = Delta;							//  if it wants to know

	// Handle cases for which range is changed
	if(cch || (Delta && _cch && Mode == MOVE_IP))
	{
		if (Mode == MOVE_IP ||						// If move IP or asked to
			!_cch && (Mode ^ Count) < 0)			//  cross ends of initial
		{											//  IP, use an IP
			cch = 0;
		}
		else if(_cch)								// Initially nondegenerate
		{											//  range
			if((_cch ^ Mode) < 0)					// If wrong end is active,
				_cch = -_cch;						//  fake a FlipRange (will
			cch += _cch;							//  set cp shortly)
			if((cch ^ _cch) < 0)					// If ends crossed, convert
				cch = 0;							//  to insertion point
		}
		if(Set(tp.GetCp(), cch))					// Set new range cp and cch
		{
			Update(TRUE);							// Update selection
			return NOERROR;							// Signal match occurred
		}
		return S_FALSE;
	}

	// No change in range. Return NOERROR iff match occurred for MOVE_UNTIL
	return Delta ? NOERROR : S_FALSE;
}

/*
 *	CTxtRange::Mover (Unit, Count, pDelta, Mode)
 *
 *	@mfunc
 *		Helper function to move end(s) <p Count> <p Unit>s, which end(s)
 *		depending on Mode = MOVE_IP, MOVE_START, and MOVE_END.  Collapsing
 *		the range by using MOVE_IP counts as a Unit.
 *
 *		Extends range from End if <p Mode> = MOVE_END and from Start if
 *		<p Mode> = MOVE_START; else (MOVE_IP) it collapses range to Start if
 *		<p Count> <lt>= 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of Units moved
 *
 *		Used by ITextRange::Delete(), Move(), MoveStart(), MoveEnd(),
 *		and SetIndex()
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR :
 *				  (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Mover (
	long	Unit,		//@parm Unit to use for moving active end
	long	Count,		//@parm Count of units to move active end
	long *	pDelta,		//@parm Out parm for count of units moved
	MOVES	Mode)		//@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Mover");

	if(pDelta)
		*pDelta = 0;							// Default no units moved

	if(IsZombie())
		return CO_E_RELEASED;

	LONG	  cch;
	LONG	  cchAdj = GetAdjustedTextLength();
	LONG	  cchMax = 0;						// Default full story limits
	LONG	  cp;
	LONG	  cpMost = GetCpMost();
	LONG	  cUnitCollapse = 0;
	HRESULT	  hr = NOERROR;
	CTxtRange rg(*this);						// Use a copy to look around

	if(pDelta)
		*pDelta = 0;							// Default no units moved

	if(_cch && Count)							// Nondegenerate range
	{
		if(Mode == MOVE_IP)						// Insertion point: will
		{										//  collapse range if Unit is
			if((Count ^ rg._cch) < 0)			//  defined. Go to correct end
				rg.FlipRange();
			if(Count > 0)
			{
				if(cpMost > cchAdj)
				{
					cUnitCollapse = -1;			// Collapse before final CR
					Count = 0;					// No more motion
				}
				else
				{	//				 Extend pDelta pcpMin pcpMost
					hr = rg.Expander(Unit, FALSE, NULL, NULL, &cp);
					cUnitCollapse = 1;			// Collapse counts as a Unit
					Count--;					// One less Unit to count
				}
			}
			else
			{
				hr = rg.Expander(Unit, FALSE, NULL, &cp, NULL);
				cUnitCollapse = -1;
				Count++;
			}
			if(FAILED(hr))
				return hr;
		}
		else if((Mode ^ rg._cch) < 0)			// MOVE_START or MOVE_END
			rg.FlipRange();						// Go to Start or End
	}

	if(Count > 0 && Mode != MOVE_END)			// Moving IP or Start forward
	{
		cchMax = cchAdj - rg.GetCp();			// Can't pass final CR
		if(cchMax <= 0)							// Already at or past it
		{										// Only count comes from
			Count = cUnitCollapse;				//  possible collapse
			cp = cchAdj;						// Put active end at cchAdj
			cch = (Mode == MOVE_START && cpMost > cchAdj)
				? cp - cpMost : 0;
			goto set;
		}
	}

	cch = rg.UnitCounter(Unit, Count, cchMax);	// Count off Count Units

	if(cch == tomForward)						// Unit not implemented
		return E_NOTIMPL;
	
	if(cch == tomBackward)						// Unit not available, e.g.,
		return S_FALSE;							//  tomObject and no objects

	Count += cUnitCollapse;						// Add a Unit if collapse
	if(!Count)									// Nothing changed, so quit
		return S_FALSE;

	if (Mode == MOVE_IP ||						// MOVE_IP or
		!_cch && (Mode ^ Count) < 0)			//  initial IP end cross
	{
		cch = 0;								// New range is degenerate
	}
	else if(_cch)								// MOVE_START or MOVE_END
	{											//  with nondegenerate range
		if((_cch ^ Mode) < 0)					// Make _cch correspond to end
			_cch = -_cch;						//  that moved
		cch += _cch;							// Possible new range length
		if((cch ^ _cch) < 0)					// Nondegenerate end cross
			cch = 0;							// Use IP
	}
	cp = rg.GetCp();

set:
	if(Set(cp, cch))							// Attempt to set new range
	{											// Something changed
		if(pDelta)								// Report count of units
			*pDelta = Count;					//  moved
		Update(TRUE);							// Update selection
		return NOERROR;
	}
	return S_FALSE;
}

/*
 *
 *	CTxtRange::Replacer (cchNew, *pch)
 *	
 *	@mfunc
 *		Replace this range's using CHARFORMAT _iFormat and updating other
 *		text runs as needed.
 *
 *		Same as CTxtRange::CleanseAndReplaceRange(cchNew, *pch, publdr),
 *		except creates its own undo builder.
 *	
 *	@rdesc
 *		cch of text actually pasted
 *	
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::Replacer (
	LONG			cchNew,		//@parm Length of replacement text
	WCHAR const *	pch,		//@parm Replacement text
	DWORD			dwFlags)	//@parm ReplaceRange flags
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Replacer");

	IUndoBuilder *	publdr;
 	CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
	CFreezeDisplay	fd(GetPed()->_pdp);

	undobldr.StopGroupTyping();

	// Note: we don't check the limit on text here. Right now, this
	// is only called by Delete and SetText so this is OK. However,
	// we might want to reinvestigate this latter if this is called
	// by anything else.
	LONG cchEOP = 0;
	BOOL fTRDsInvolved;
	CheckTableSelection(TRUE, TRUE, &fTRDsInvolved, 0);

	if(fTRDsInvolved)
		cchEOP = DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, NULL, dwFlags);

	LONG cch = CleanseAndReplaceRange(cchNew, pch, FALSE, publdr, NULL, NULL, dwFlags);

	if(cchEOP && _rpTX.IsAfterEOP())
	{										// Don't need extra EOP anymore
		_cch = -cchEOP;						//  since text ended with one
		ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
		cchEOP = 0;
	}
	return cch + cchEOP;
}

/*
 *	CTxtRange::CharFormatSetter (pCF, dwMask)
 *
 *	@mfunc
 *		Helper function that's the same as CTxtRange::SetCharFormat(), but
 *		adds undo building, and notification.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::CharFormatSetter (
	const CCharFormat *pCF,	//@parm CCharFormat to fill with results
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm CHARFORMAT2 mask
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::CharFormatSetter");

	if(IsZombie())
		return CO_E_RELEASED;

	CTxtEdit *ped = GetPed();
 	CCallMgr		callmgr(ped);
	IUndoBuilder *	publdr;
 	CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	undobldr.StopGroupTyping();
	return SetCharFormat(pCF, FALSE, publdr, dwMask, dwMask2);
}

/*
 *	CTxtRange::ParaFormatSetter (pPF, dwMask)
 *
 *	@mfunc
 *		Helper function that's the same as CTxtRange::SetParaFormat(), but
 *		adds protection checking, undo building, and notification.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::ParaFormatSetter (
	const CParaFormat *pPF,	//@parm CParaFormat to fill with results
	DWORD			dwMask)	//@parm Mask to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::ParaFormatSetter");

	if(IsZombie())
		return CO_E_RELEASED;

	CTxtEdit *ped = GetPed();
 	CCallMgr		callmgr(ped);
	IUndoBuilder *	publdr;
 	CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

	if(WriteAccessDenied())
		return E_ACCESSDENIED;

	undobldr.StopGroupTyping();

	CheckTableSelection(FALSE, FALSE, NULL, 0);
	return SetParaFormat(pPF, publdr, dwMask & ~(PFM_TABLE | PFM_TABLEROWDELIMITER), 0);
}

/*
 *	CTxtRange::WriteAccessDenied()
 *
 *	@mfunc
 *		Returns TRUE iff at least part of the range is protected and the
 *		owner chooses to enforce it
 *
 *	@rdesc
 *		TRUE iff write access to range is denied
 */
BOOL CTxtRange::WriteAccessDenied ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::WriteAccessDenied");

	PROTECT	  iProt;
	CTxtEdit *ped = GetPed();

	if (ped && ped->TxGetReadOnly() ||
		((iProt = IsProtected(_cch ? CHKPROT_BACKWARD : CHKPROT_TOM)) == PROTECTED_YES ||
		(iProt == PROTECTED_ASK && ped->IsProtectionCheckingEnabled() && 
		 ped->QueryUseProtection(this, 0, 0, 0))))
	// N.B.  the preceding if statement assumes that IsProtected returns a tri-value
	{
		return TRUE;
	}

	return FALSE;
}

/*
 *	CTxtRange::IsTrue (f, pB)
 *
 *	@mfunc
 *		Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *	@rdesc
 *		HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::IsTrue(BOOL f, long *pB)
{
	if(pB)
		*pB = tomFalse;
	
	if(IsZombie())
		return CO_E_RELEASED;

	if(f)
	{
		if(pB)
			*pB = tomTrue;
		return NOERROR;
	}

	return S_FALSE;
}

/*
 *	CTxtRange::GetLong (lValue, pLong)
 *
 *	@mfunc
 *		Return *pLong = lValue provided pLong isn't NULL and this range
 *		isn't a zombie
 *
 *	@rdesc
 *		HRESULT	= (zombie) ? CO_E_RELEASED :
 *				  (pLong) ? NOERROR : E_INVALIDARG 
 */
HRESULT CTxtRange::GetLong (
	LONG lValue,		//@parm Long value to return
	long *pLong)		//@parm Out parm to receive long value
{
	if(IsZombie())
		return CO_E_RELEASED;	
	
	_TEST_INVARIANT_

	if(!pLong)
		return E_INVALIDARG;

	*pLong = lValue;



	return NOERROR;
}

/*
 *	IsSameVtables (punk1, punk2)
 *
 *	@mfunc
 *		Returns true if punk1 has same vtable as punk2
 *
 *	@rdesc
 *		TRUE iff punk1 has same vtable as punk2
 */
BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2)
{
	return punk1 && punk2 && *(long *)punk1 == *(long *)punk2; 
}

/*
 *	FPPTS_TO_TWIPS (x)
 *
 *	@mfunc
 *		Returns 20*x, i.e., the number of twips corresponding to
 *		x given in floating-point points.  The value is rounded.
 *
 *	@rdesc
 *		x converted to twips
 */
long FPPTS_TO_TWIPS(
	float x)
{
	return 20*x + ((x >= 0) ? 0.5 : -0.5);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\textstor_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for textstor.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITextStoreACP,0x28888fe3,0xc2a0,0x483a,0xa3,0xea,0x8c,0xb1,0xce,0x51,0xff,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPSink,0x22d44c94,0xa419,0x4542,0xa2,0x72,0xae,0x26,0x09,0x3e,0xce,0xcf);


MIDL_DEFINE_GUID(IID, IID_IAnchor,0x0feb7e34,0x5a60,0x4356,0x8e,0xf7,0xab,0xde,0xc2,0xff,0x7c,0xf8);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchor,0x9b2077b0,0x5f18,0x4dec,0xbe,0xe9,0x3c,0xc7,0x22,0xf5,0xdf,0xe0);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorSink,0xaa80e905,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for textstor.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITextStoreACP,0x28888fe3,0xc2a0,0x483a,0xa3,0xea,0x8c,0xb1,0xce,0x51,0xff,0x3d);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPSink,0x22d44c94,0xa419,0x4542,0xa2,0x72,0xae,0x26,0x09,0x3e,0xce,0xcf);


MIDL_DEFINE_GUID(IID, IID_IAnchor,0x0feb7e34,0x5a60,0x4356,0x8e,0xf7,0xab,0xde,0xc2,0xff,0x7c,0xf8);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchor,0x9b2077b0,0x5f18,0x4dec,0xbe,0xe9,0x3c,0xc7,0x22,0xf5,0xdf,0xe0);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorSink,0xaa80e905,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tokens.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _TOKENS.H -- All the tokens and then some |
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *		
 *	@devnote
 *		The Text Object Model (TOM) keywords come first followed by picture
 *		and object keywords.  The order within a group can matter, since it
 *		may be used to simplify the input process.  Token values <lt> 256
 *		(tokenMin) are used for target character Unicodes as are token values
 *		greater than tokenMax.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _TOKEN_H
#define _TOKEN_H

typedef	WORD	TOKEN;

/*
 *		Keyword --> Token table
 */
typedef struct _keyword
{
	CHAR *	szKeyword;				// The RTF keyword sans '\\'
	TOKEN	token;
} KEYWORD;


// @enum TOKENS | RichEdit RTF Control Word Tokens

typedef enum tagTOKEN				// Keyword tokens
{
	// Tokens for internal use
	tokenMin = 256,					// Lower tokens treated as Unicode chars
	tokenText = tokenMin,			// A string of characters
	tokenASCIIText,					// A string of characters with values <= 0x7F
	tokenUnknownKeyword,			// A keyword we don't recognize
	tokenError,						// Error condition token
#ifdef UNUSED_TOKENS
	tokenUnknown,					// Unknown token
#endif
	tokenEOF,						// End-of-file token
	tokenStartGroup, 				// Start group token
	tokenEndGroup,					// End group token
	tokenObjectDataValue,			// Data for object 
	tokenPictureDataValue,			// Data for picture


	// RTF control word tokens from here to end of enumeration
	tokenURtf,						// @emem urtf
	tokenPocketWord,				// @emem pwd
	tokenRtf,						// @emem rtf
	tokenCharSetAnsi,				// @emem ansi
	tokenMac,						// @emem mac
	tokenAnsiCodePage,				// @emem ansicpg
	tokenViewKind,					// @emem viewkind		
	tokenViewScale,					// @emem viewscale		

	tokenDefaultFont,				// @emem deff
	tokenDefaultBiDiFont,           // @emem adeff
	tokenDefaultLanguage,			// @emem deflang
	tokenDefaultLanguageFE,			// @emem deflangfe
	tokenDefaultTabWidth,			// @emem deftab
	tokenParagraphDefault,			// @emem pard
	tokenCharacterDefault,			// @emem plain


	// Fonts
	tokenFontTable,					// @emem fonttbl
	tokenFontSelect,				// @emem f
	tokenAssocFontSelect,			// @emem af
	tokenAssocFontSize,				// @emem afs
									//			Keep next 8 in order
	tokenFontFamilyDefault,			// @emem fnil
	tokenFontFamilyRoman,			// @emem froman
	tokenFontFamilySwiss,			// @emem fswiss
	tokenFontFamilyModern,			// @emem fmodern
	tokenFontFamilyScript,			// @emem fscript
	tokenFontFamilyDecorative,		// @emem fdecor
	tokenFontFamilyTechnical,		// @emem ftech
	tokenFontFamilyBidi,			// @emem fbidi

	tokenCharSet,					// @emem fcharset
	tokenPitch,						// @emem fprq
	tokenRealFontName,				// @emem fname
	tokenCodePage,					// @emem cpg
	tokenFontSize,					// @emem fs

	// Colors
	tokenColorTable,				// @emem colortbl
	tokenColorBackground,			// @emem highlight (used to be cb)
	tokenColorForeground,			// @emem cf
									//			Keep next 3 in order
	tokenColorRed,					// @emem red
	tokenColorGreen,				// @emem green
	tokenColorBlue,					// @emem blue


	// Character formatting						Keep next 15 effects in order
	tokenBold,						// @emem b
	tokenItalic,					// @emem i
	tokenUnderline,					// @emem ul
	tokenStrikeOut,					// @emem strike
	tokenProtect,					// @emem protect
	tokenLink,						// @emem link (check this...)
	tokenSmallCaps,					// @emem scaps
	tokenCaps,						// @emem caps
	tokenHiddenText,				// @emem v
	tokenOutline,					// @emem outl
	tokenShadow,					// @emem shad
	tokenEmboss,					// @emem embo
	tokenImprint,					// @emem impr
	tokenDisabled,					// @emem disabled
	tokenRevised,					// @emem revised

	tokenDeleted,					// @emem deleted

	tokenStopUnderline,				// @emem ulnone	Keep next 18 in order
	tokenUnderlineWord,				// @emem ulw - display as single
	tokenUnderlineDouble,			// @emem uldb - display as single
	tokenUnderlineDotted,			// @emem uld		
	tokenUnderlineDash,				// @emem uldash
	tokenUnderlineDashDotted,		// @emem uldashd	
	tokenUnderlineDashDotDotted,	// @emem uldashdd
	tokenUnderlineWave,				// @emem ulwave
	tokenUnderlineThick,			// @emem ulth
	tokenUnderlineHairline,			// @emem ulhair - display as single
	tokenUnderlineDoubleWave,		// @emem ululdbwave - display as wave
	tokenUnderlineHeavyWave,		// @emem ulhwave - display as wave
	tokenUnderlineLongDash,			// @emem ulldash - display as dash
	tokenUnderlineThickDash,		// @emem ulthdash - display as dash
	tokenUnderlineThickDashDot,		// @emem ulthdashd - disp as dash dot
	tokenUnderlineThickDashDotDot,	// @emem ulthdashdd - disp as dashdd
	tokenUnderlineThickDotted,		// @emem ulthd - display as dotted
	tokenUnderlineThickLongDash,	// @emem ulthldash - display as dash

	tokenDown,						// @emem dn
	tokenUp,						// @emem up
									// 				Keep next 3 in order
	tokenSubscript,					// @emem sub
	tokenNoSuperSub,				// @emem nosupersub
	tokenSuperscript,				// @emem super

	tokenAnimText,					// @emem animtext
	tokenExpand,					// @emem expndtw
	tokenKerning,					// @emem kerning
	tokenLanguage,					// @emem lang
	tokenCharStyle,					// @emem cs

	tokenHorzInVert,				// @emem horzvert


	// Paragraph Formatting
	tokenEndParagraph,				// @emem par
	tokenLineBreak,					// @emem line
	tokenIndentFirst,				// @emem fi
	tokenIndentLeft,				// @emem li
	tokenIndentRight,				// @emem ri
									//			Keep next 4 in order
	tokenAlignLeft,					// @emem ql		PFA_LEFT
	tokenAlignRight,				// @emem qr		PFA_RIGHT
	tokenAlignCenter,				// @emem qc		PFA_CENTER
	tokenAlignJustify,				// @emem qj		PFA_JUSTIFY

	tokenSpaceBefore,				// @emem sb
	tokenSpaceAfter,				// @emem sa
	tokenLineSpacing,				// @emem sl
	tokenLineSpacingRule,			// @emem slmult
	tokenDropCapLines,				// @emem dropcapli
	tokenStyle,						// @emem s

	tokenLToRPara,					// @emem ltrpar
	tokenBox,						// @emem box
									//			keep next 8 in order 
	tokenRToLPara,					// @emem rtlpar
	tokenKeep,						// @emem keep
	tokenKeepNext,					// @emem keepn
	tokenPageBreakBefore,			// @emem pagebb
	tokenNoLineNumber,				// @emem noline
	tokenNoWidCtlPar,				// @emem nowidctlpar
	tokenHyphPar,					// @emem hyphpar
	tokenSideBySide,				// @emem sbys
	tokenCollapsed,					// @emem collapsed
									// Keep following 8 together
	tokenBorderLeft,				// @emem brdrl
	tokenBorderTop,					// @emem brdrt
	tokenBorderRight,				// @emem brdrr
	tokenBorderBottom,				// @emem brdrb
	tokenCellBorderLeft,			// @emem clbrdrl
	tokenCellBorderTop,				// @emem clbrdrt
	tokenCellBorderRight,			// @emem clbrdrr
	tokenCellBorderBottom,			// @emem clbrdrb

	tokenCellBackColor,				// @emem clcbpat
	tokenCellForeColor,				// @emem clcfpat
	tokenCellShading,				// @emem clshdng
									// Keep following 2 together
	tokenCellAlignCenter,			// @emem clvertalc
	tokenCellAlignBottom,			// @emem clvertalb
	tokenCellLRTB,					// @emem cltxlrtb
	tokenCellTopBotRLVert,			// @emem cltxtbrlv
									// Keep following 3 together
	tokenBorderShadow,				// @emem brdrsh
	tokenBorderBetween,				// @emem brdrbtw
	tokenBorderOutside,				// @emem brdrbar
									// Keep following 8 together
	tokenBorderDash,				// @emem brdrdash
	tokenBorderDashSmall,			// @emem brdrdashsm
	tokenBorderDouble,				// @emem brdrdb
	tokenBorderDot,					// @emem brdrdot
	tokenBorderHairline,			// @emem brdrhair
	tokenBorderSingleThick,			// @emem brdrs
	tokenBorderDoubleThick,			// @emem brdrth
	tokenBorderTriple,				// @emem brdrtriple

	tokenBorderColor,				// @emem brdrcf
	tokenBorderWidth,				// @emem brdrw
	tokenBorderSpace,				// @emem brsp

	tokenColorBckgrndPat,			// @emem cbpat
	tokenColorForgrndPat,			// @emem cfpat
	tokenShading,					// @emem shading
	tokenBackground,				// @emem background
									//			keep next 12 in order
	tokenBckgrndBckDiag,			// @emem bgbdiag
	tokenBckgrndCross,				// @emem bgcross
	tokenBckgrndDiagCross,			// @emem bgdcross
	tokenBckgrndDrkBckDiag,			// @emem bgdkbdiag
	tokenBckgrndDrkCross,			// @emem bgdkcross
	tokenBckgrndDrkDiagCross,		// @emem bgdkdcross
	tokenBckgrndDrkFwdDiag,			// @emem bgdkfdiag
	tokenBckgrndDrkHoriz,			// @emem bgdkhoriz
	tokenBckgrndDrkVert,	   		// @emem bgdkvert
	tokenBckgrndFwdDiag,			// @emem bgfdiag
	tokenBckgrndHoriz,				// @emem bghoriz
	tokenBckgrndVert,				// @emem bgvert

	tokenTabPosition,				// @emem tx
	tokenTabBar,					// @emem tb
									//			keep next 5 in order 
	tokenTabLeaderDots,				// @emem tldot
	tokenTabLeaderHyphen,			// @emem tlhyph
	tokenTabLeaderUnderline,		// @emem tlul
	tokenTabLeaderThick,			// @emem tlth
	tokenTabLeaderEqual,			// @emem tleq
									//			keep next 4 in order 
	tokenCenterTab,					// @emem tqc
	tokenFlushRightTab,				// @emem tqr
	tokenDecimalTab,				// @emem tqdec

	tokenParaNum,					// @emem pn
	tokenParaNumIndent,				// @emem pnindent
	tokenParaNumBody,				// @emem pnlvlbody
	tokenParaNumCont,				// @emem pnlvlcont
									//			keep next 2 in order
	tokenParaNumAlignCenter,		// @emem pnqc
	tokenParaNumAlignRight,			// @emem pnqr
									//			keep next 6 in order
	tokenParaNumBullet,				// @emem pnlvlblt
	tokenParaNumDecimal,			// @emem pndec
	tokenParaNumLCLetter,			// @emem pnlcltr
	tokenParaNumUCLetter,			// @emem pnucltr
	tokenParaNumLCRoman,			// @emem pnlcrm
	tokenParaNumUCRoman,			// @emem pnucrm

	tokenParaNumText,				// @emem pntext
	tokenParaNumStart,				// @emem pnstart
	tokenParaNumAfter,				// @emem pntxta
	tokenParaNumBefore,				// @emem pntxtb

	tokenOptionalDestination,		// @emem *
	tokenField,						// @emem field
	tokenFieldResult,				// @emem fldrslt
	tokenFieldInstruction,			// @emem fldinst
	tokenStyleSheet,				// @emem stylesheet
	tokenEndSection,				// @emem sect
	tokenSectionDefault,			// @emem sectd
	tokenDocumentArea,				// @emem info

	// Tables
	tokenInTable,					// @emem intbl
	tokenCell,						// @emem cell
	tokenNestCell,					// @emem nestcell (must follow tokenCell)
	tokenCellHalfGap,				// @emem trgaph
	tokenCellX,						// @emem cellx
	tokenRow,						// @emem row
	tokenRowDefault,				// @emem trowd
	tokenRowHeight,					// @emem trrh
	tokenRowLeft,					// @emem trleft
	tokenRowAlignRight,				// @emem trqr	(trqc must follow trqr)
	tokenRowAlignCenter,			// @emem trqc
	tokenCellMergeDown,				// @emem clvmgf
	tokenCellMergeUp,				// @emem clvmrg
	tokenTableLevel,				// @emem itap
	tokenNestRow,					// @emem nestrow
	tokenNestTableProps,			// @emem nesttableprops
	tokenNoNestTables,				// @emem nonesttables
	tokenRToLRow,					// @emem rtlrow

	tokenUnicode,					// @emem u
	tokenUnicodeCharByteCount,		// @emem uc

	// Special characters
	tokenFormulaCharacter,			// |
	tokenIndexSubentry,				// :
									//				Keep next five in order
	tokenLToRChars,					// @emem ltrch
	tokenRToLChars,					// @emem rtlch
	tokenLOChars,					// @emem loch
	tokenHIChars,					// @emem hich
	tokenDBChars,					// @emem dbch

	tokenLToRDocument,				// @emem ltrdoc
	tokenDisplayLToR,				// @emem ltrmark	See also ltrpar
	tokenRToLDocument,				// @emem rtldoc
	tokenDisplayRToL,				// @emem rtlmark
	tokenZeroWidthJoiner,			// @emem zwj
	tokenZeroWidthNonJoiner,		// @emem zwnj

	//	T3J keywords
	tokenFollowingPunct,			// @emem fchars
	tokenLeadingPunct,				// @emem lchars

	tokenVerticalRender,			// @emem vertdoc
#ifdef FE
	tokenHorizontalRender,			// @emem horzdoc
	tokenVerticalRender,			// @emem vertdoc
	tokenNoOverflow,				// @emem nooverflow
	tokenNoWordBreak,				// @emem nocwrap
	tokenNoWordWrap,				// @emem nowwrap
#endif
	tokenPicture,					// @emem pict
	tokenObject,					// @emem object

	// Pictures						 				Keep next 4 in RECT order
	tokenPicFirst,
	tokenCropLeft = tokenPicFirst,	// @emem piccropl
	tokenCropTop,					// @emem piccropt
	tokenCropBottom,				// @emem piccropb
	tokenCropRight,					// @emem piccropr
	tokenHeight,					// @emem pich
	tokenWidth,						// @emem picw
	tokenScaleX,					// @emem picscalex
	tokenScaleY,					// @emem picscaley
	tokenDesiredHeight,				// @emem pichgoal
	tokenDesiredWidth,				// @emem picwgoal
									//				Keep next 5 in order
	tokenPictureWindowsBitmap,		// @emem wbitmap
	tokenPictureWindowsMetafile,	// @emem wmetafile
	tokenPictureWindowsDIB,			// @emem dibitmap
	tokenJpegBlip,					// @emem jpegblip
	tokenPngBlip,					// @emem pngblip

	tokenBinaryData,				// @emem bin
	tokenPictureQuickDraw,			// @emem macpict
	tokenPictureOS2Metafile,		// @emem pmmetafile
	tokenBitmapBitsPerPixel,		// @emem wbmbitspixel
	tokenBitmapNumPlanes,			// @emem wbmplanes
	tokenBitmapWidthBytes,			// @emem wbmwidthbytes

	// Objects
//	tokenCropLeft,					// @emem objcropl		(see // Pictures)
//	tokenCropTop,					// @emem objcropt
//	tokenCropRight,					// @emem objcropr
//	tokenCropBottom,				// @emem objcropb
//	tokenHeight,					// @emem objh
//	tokenWidth,						// @emem objw
//	tokenScaleX,					// @emem objscalex
//	tokenScaleY,					// @emem objscaley
									//				Keep next 3 in order
	tokenObjectEmbedded,			// @emem objemb
	tokenObjectLink,				// @emem objlink
	tokenObjectAutoLink,			// @emem objautlink

	tokenObjectClass,				// @emem objclass
	tokenObjectData,				// @emem objdata
	tokenObjectMacICEmbedder,		// @emem objicemb
	tokenObjectName,				// @emem objname
	tokenObjectMacPublisher,		// @emem objpub
	tokenObjectSetSize,				// @emem objsetsize
	tokenObjectMacSubscriber,		// @emem objsub
	tokenObjectResult,				// @emem result
	tokenObjectEBookImage,			// @emem objebookimage
	tokenObjLast = tokenObjectEBookImage,

	// Shapes
	tokenShape,						// @emem shp
	tokenShapeInstructions,			// @emem shpinst
	tokenShapeName,					// @emem sn
	tokenShapeValue,				// @emem sv
	tokenShapeWrap,					// @emem shpwr
	tokenPositionRight,				// @emem posxr

	tokenSTextFlow,					// @emem stextflow

	// Document info and layout
	tokenRevAuthor,					// @emem revauth

#ifdef UNUSED_TOKENS
	tokenTimeSecond,				// @emem sec
	tokenTimeMinute,				// @emem min
	tokenTimeHour,					// @emem hr
	tokenTimeDay,					// @emem dy
	tokenTimeMonth,					// @emem mo
	tokenTimeYear,					// @emem yr
	tokenMarginLeft,				// @emem margl
	tokenMarginRight,				// @emem margr
	tokenSectionMarginLeft,			// @emem marglsxn
	tokenSectionMarginRight,		// @emem margrsxn
#endif

	tokenObjectPlaceholder,			// @emem objattph

	tokenPage,						// @emem page

	tokenNullDestination,			// @emem ??various??
	tokenNullDestinationCond,		// @emem Conditional null destination

	tokenMax						// Larger tokens treated as Unicode chars
};

// Define values for \shp \sn fields
typedef enum tagShapeToken
{
	shapeFillColor = 1,				// @emem fillColor
	shapeFillBackColor,				// @emem fillBackColor
	shapeFillAngle,					// @emem fillAngle
	shapeFillType,					// @emem fillType
	shapeFillFocus					// @emem fillFocus
};

// @enum TOKENINDEX | RTFWrite Indices into rgKeyword[]

enum TOKENINDEX						// rgKeyword[] indices
{									// MUST be in exact 1-to-1 with rgKeyword
	i_adeff,						//  entries (see tokens.cpp).  Names consist
	i_af,
	i_afs,
	i_animtext,						
	i_ansi,
	i_ansicpg,						
	i_b,							
	i_background,
	i_bgbdiag,
	i_bgcross,
	i_bgdcross,
	i_bgdkbdiag,
	i_bgdkcross,
	i_bgdkdcross,
	i_bgdkfdiag,
	i_bgdkhoriz,
	i_bgdkvert,
	i_bgfdiag,
	i_bghoriz,
	i_bgvert,
	i_bin,
	i_blue,
	i_box,
	i_brdrb,
	i_brdrbar,
	i_brdrbtw,
	i_brdrcf,
	i_brdrdash,
	i_brdrdashsm,
	i_brdrdb,
	i_brdrdot,
	i_brdrhair,
	i_brdrl,
	i_brdrr,
	i_brdrs,
	i_brdrsh,
	i_brdrt,
	i_brdrth,
	i_brdrtriple,
	i_brdrw,
	i_brsp,
	i_bullet,
	i_caps,
	i_cbpat,
	i_cell,
	i_cellx,
	i_cf,
	i_cfpat,
	i_clbrdrb,
	i_clbrdrl,
	i_clbrdrr,
	i_clbrdrt,
	i_clcbpat,
	i_clcfpat,
	i_clshdng,
	i_cltxlrtb,
	i_cltxtbrlv,
	i_clvertalb,
	i_clvertalc,
	i_clvmgf,
	i_clvmrg,
	i_collapsed,
	i_colortbl,
	i_cpg,
	i_cs,
	i_dbch,
	i_deff,
	i_deflang,
	i_deflangfe,
	i_deftab,
	i_deleted,
	i_dibitmap,
	i_disabled,
	i_dn,
	i_dropcapli,
	i_embo,
	i_emdash,
	i_emspace,
	i_endash,
	i_enspace,
	i_expndtw,
	i_f,
	i_fbidi,
	i_fchars,
	i_fcharset,
	i_fdecor,
	i_fi,
	i_field,
	i_fldinst,
	i_fldrslt,
	i_fmodern,
	i_fname,
	i_fnil,
	i_fonttbl,
	i_footer,
	i_footerf,
	i_footerl,
	i_footerr,
	i_footnote,
	i_fprq,
	i_froman,
	i_fs,
	i_fscript,
	i_fswiss,
	i_ftech,
	i_ftncn,
	i_ftnsep,
	i_ftnsepc,
	i_green,
	i_header,
	i_headerf,
	i_headerl,
	i_headerr,
	i_hich,
	i_highlight,
	i_horzvert,
	i_hyphpar,
	i_i,
	i_impr,
	i_info,
	i_intbl,
	i_itap,
	i_jpegblip,
	i_keep,
	i_keepn,
	i_kerning,
	i_lang,
	i_lchars,
	i_ldblquote,
	i_li,
	i_line,
	i_lnkd,
	i_loch,
	i_lquote,
	i_ltrch,
	i_ltrdoc,
	i_ltrmark,
	i_ltrpar,
	i_mac,
	i_macpict,
	i_nestcell,
	i_nestrow,
	i_nesttableprops,
	i_noline,
	i_nonesttables,
	i_nosupersub,
	i_nowidctlpar,
	i_objattph,
	i_objautlink,
	i_objclass,
	i_objcropb,
	i_objcropl,
	i_objcropr,
	i_objcropt,
	i_objdata,
	i_objebookimage,
	i_object,
	i_objemb,
	i_objh,
	i_objicemb,
	i_objlink,
	i_objname,
	i_objpub,
	i_objscalex,
	i_objscaley,
	i_objsetsize,
	i_objsub,
	i_objw,
	i_outl,
	i_page,
	i_pagebb,
	i_par,
	i_pard,
	i_piccropb,
	i_piccropl,
	i_piccropr,
	i_piccropt,
	i_pich,
	i_pichgoal,
	i_picscalex,
	i_picscaley,
	i_pict,
	i_picw,
	i_picwgoal,
	i_plain,
	i_pmmetafile,
	i_pn,
	i_pndec,
	i_pngblip,
	i_pnindent,
	i_pnlcltr,
	i_pnlcrm,
	i_pnlvlblt,
	i_pnlvlbody,
	i_pnlvlcont,
	i_pnqc,
	i_pnqr,
	i_pnstart,
	i_pntext,
	i_pntxta,
	i_pntxtb,
	i_pnucltr,
	i_pnucrm,
	i_posxr,
	i_protect,
	i_pwd,
	i_qc,
	i_qj,
	i_ql,
	i_qr,
	i_rdblquote,
	i_red,
	i_result,
	i_revauth,
	i_revised,
	i_ri,
	i_row,
	i_rquote,
	i_rtf,
	i_rtlch,
	i_rtldoc,
	i_rtlmark,
	i_rtlpar,
	i_rtlrow,
	i_s,
	i_sa,
	i_sb,
	i_sbys,
	i_scaps,
	i_sect,
	i_sectd,
	i_shad,
	i_shading,
	i_shp,
	i_shpinst,
	i_shpwr,
	i_sl,
	i_slmult,
	i_sn,
	i_stextflow,
	i_strike,
	i_stylesheet,
	i_sub,
	i_super,
	i_sv,
	i_tab,
	i_tb,
	i_tc,
	i_tldot,
	i_tleq,
	i_tlhyph,
	i_tlth,
	i_tlul,
	i_tqc,
	i_tqdec,
	i_tqr,
	i_trbrdrb,
	i_trbrdrl,
	i_trbrdrr,
	i_trbrdrt,
	i_trgaph,
	i_trleft,
	i_trowd,
	i_trqc,
	i_trqr,
	i_trrh,
	i_tx,
	i_u,
	i_uc,
	i_ul,
	i_uld,
	i_uldash,
	i_uldashd,
	i_uldashdd,
	i_uldb,
	i_ulhair,
	i_ulhwave,
	i_ulldash,
	i_ulnone,
	i_ulth,
	i_ulthd,
	i_ulthdash,
	i_ulthdashd,
	i_ulthdashdd,
	i_ulthldash,
	i_ululdbwave,
	i_ulw,
	i_ulwave,
	i_up,
	i_urtf,
	i_v,
	i_vertdoc,
	i_viewkind,
	i_viewscale,
	i_wbitmap,
	i_wbmbitspixel,
	i_wbmplanes,
	i_wbmwidthbytes,
	i_wmetafile,
	i_xe,
	i_zwj,
	i_zwnj,
	i_TokenIndexMax
};

enum TOKENSHAPEINDEX				// rgShapeKeyword[] indices
{									// MUST be in exact 1-to-1 with rgShapeKeyword
	i_fillangle,					//  entries (see tokens.cpp).
	i_fillbackcolor,
	i_fillcolor,
	i_fillfocus,
	i_filltype
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\txtbrk.cpp ===
/*
 *		Text Breaker & Bit stream break array class implementation
 *		
 *		File:    txtbrk.cpp
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998-1999, Microsoft Corporation. All rights reserved.
 */


//#include "stdafx.h"
//#include "Array.h"

#include "_common.h"

#ifndef NOCOMPLEXSCRIPTS

#ifndef BITVIEW
#include "_edit.h"
#include "_frunptr.h"
#include "_range.h"
#include "_notmgr.h"
#endif
#include "_txtbrk.h"

CBreakArray::CBreakArray()
{
	_ibGap = 0;
	_cbGap = 0;
	_cbSize = 0;
	_cbBreak = 0;
}

void CBreakArray::CheckArray ()
{
	if (!IsValid())
	{
		// Add the first element. This is required to be a sentinel.
		Add(1, NULL);
	}
}

// Remove <cchOld> and insert <cchNew> break items at <cp>
LONG CBreakArray::ReplaceBreak (
	LONG	cp, 				// insertion cp
	LONG	cchOld,				// number of break item to be deleted
	LONG	cchNew)				// number of break item to be inserted
{
	PUSH_STATE(cp, cchNew, REPLACER);

	if (!cchOld && cchNew)
		return VALIDATE(InsertBreak (cp, cchNew));
	if (cchOld && !cchNew)
		return VALIDATE(RemoveBreak (cp, cchOld));

	LONG	cRep = 0;		// number of new break inserted after replacing

	if (cchOld > cchNew)
	{
		cRep = RemoveBreak(cp+cchNew, cchOld-cchNew);
		ClearBreak(cp, cchNew);
	}
	else if (cchOld < cchNew)
	{
		cRep = InsertBreak(cp+cchOld, cchNew-cchOld);
		ClearBreak(cp, cchOld);
	}
	else if (cchNew)
    {
		ClearBreak(cp, cchNew);
	}
	return VALIDATE(cRep);
}


// Add <cch> break items at <cp>
// note: This routine assumes there is no gap left in the bit array
LONG CBreakArray::AddBreak(
	LONG	cp, 
	LONG	cch)
{
	Assert (cp == _cbBreak);
	LONG	cchAdd = min(cch, _cbSize - _cbBreak);
	LONG	c;

	_cbBreak += cchAdd;
	cch -= cchAdd;
	if (cch > 0)
	{
		cp += cchAdd;
		c = (cch + RSIZE-1)/RSIZE;
		Insert (cp / RSIZE, c);
		_cbSize += c * RSIZE;
		_cbBreak += cch;
		cchAdd += cch;
	}
	return cchAdd;
}


// Insert <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::InsertBreak (
	LONG	cp, 				// insertion point cp
	LONG	cch)				// number of break item to be inserted
{
	LONG	cIns = 0;			// number of break inserted
	ITEM	*peli, *pelj;
	LONG	cchSave = cch;

	PUSH_STATE(cp, cch, INSERTER);

	// Make sure we establish the array
	CheckArray();

	if (cp == _ibGap)
	{
		// The insertion takes place at the gap,
		// reposition and shrink the gap down
		for (cIns=0 ; cch > 0 && cIns < _cbGap; cIns++, cch--, cp++)
		{
			peli = Elem(cp / RSIZE);
			*peli &= ~(1<<(cp % RSIZE));
		}
		_cbGap -= cIns;
		_ibGap += cIns;
		_cbBreak += cIns;
	}
	else 
	{
		// The insertion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}
	
	if (cch <= 0)
		return VALIDATE(cIns);

	if (cp == _cbBreak)
		return VALIDATE(cIns + AddBreak(cp, cch));

	Assert (_cbGap == 0 && cp < _cbBreak);

	LONG	cit = (cch+RSIZE-1) / RSIZE;
	LONG	i = cp / RSIZE;
	LONG	j;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp

	// Insert items
	Insert (i+1, cit);
	cIns += (cit * RSIZE);

	// Get the [i]
	peli = Elem(i);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~ul;
	ul &= *peli;
	uh &= *peli;

	// Reference the [j]
	j = i + cit;

	// Move L to [i]; move H to [j]
	*peli = ul;
	pelj = Elem(j);
	Assert (pelj);
	*pelj = uh;

	// Calculate gap position
	_ibGap = cp + (cch / RSIZE) * RSIZE;
	_cbGap = cit*RSIZE - cch;

	Assert(_cbGap < RSIZE && cIns - _cbGap == cchSave);

	_cbSize += (cIns - cchSave + cch);
	_cbBreak += cch;

	return VALIDATE(cIns - _cbGap);
}

// Remove <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::RemoveBreak (
	LONG	cp, 				// deletion point cp
	LONG	cch)				// number of break item to be deleted
{
	Assert (IsValid() && cp + cch <= _cbBreak);

	PUSH_STATE(cp, cch, REMOVER);

	LONG	i = cp / RSIZE;
	LONG	j;
	LONG	cDel = 0;			// number of break deleted

	if (cp == _ibGap)
	{
		// The deletion takes place at the gap,
		// reposition and expand the gap
		cDel = cch;
		_cbGap += cch;
		_cbBreak -= cch;
		cch = 0;

		// Optimise the gap size:
		// Keep the gap small so we dont spend much time collapsing it.
		j = (_ibGap+_cbGap) / RSIZE - i - 1;
		if (j > 0)
		{
			Remove(i+1, j);
			_cbGap -= j * RSIZE;
			_cbSize -= j * RSIZE;
		}
	}
	else
	{
		// The deletion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}

	if (!cch)
		return VALIDATE(-cDel);

	LONG	cit = cch / RSIZE;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	j = (cp+cch) / RSIZE;

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~MASK_LOW (-1, (cp+cch) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove <cch/RSIZE> items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Or L to [i]
	*peli |= ul;


	// Calculate gap position
	_ibGap = cp;
	_cbGap = cch % RSIZE;

	Assert(_cbGap < RSIZE && cDel + _cbGap == cch);

	_cbSize -= cDel;
	_cbBreak -= cch;

	return VALIDATE(-cDel - _cbGap);
}


// Determine if we can break between char[cp-1] and [cp]
BOOL CBreakArray::GetBreak (LONG cp)
{
	if (!IsValid() || cp >= _cbBreak)
		return FALSE;

	cp += cp < _ibGap ? 0 : _cbGap;

	if (cp / RSIZE < Count() - 1)
		return